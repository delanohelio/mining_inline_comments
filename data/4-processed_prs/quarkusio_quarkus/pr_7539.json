{"pr_number": 7539, "pr_title": "Write the getting started with reactive documentation", "pr_createdAt": "2020-03-03T18:04:00Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7539", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDIwNw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387210207", "bodyText": "Please don't use that here, we want this config to be global and not per guide.", "author": "gsmet", "createdAt": "2020-03-03T18:28:02Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzMjczMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387232731", "bodyText": "I copied it from another file", "author": "cescoffier", "createdAt": "2020-03-03T19:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzMzA5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387233097", "bodyText": "(the original getting-started)", "author": "cescoffier", "createdAt": "2020-03-03T19:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0Njk1OA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387246958", "bodyText": "OK, I suppose it will work fine then.", "author": "gsmet", "createdAt": "2020-03-03T19:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0OTg4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387249883", "bodyText": "I've removed them, wondering if we should remove it from the original getting-started.", "author": "cescoffier", "createdAt": "2020-03-03T19:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1Mjc3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387252772", "bodyText": "I think it would be safer. If one day we want to change it, we will want to do it globally.", "author": "gsmet", "createdAt": "2020-03-03T19:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDMwMg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387210302", "bodyText": "That one looks suspicious too.", "author": "gsmet", "createdAt": "2020-03-03T18:28:13Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMTg0MA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387211840", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n          \n          \n            \n            The computation only starts once there is an actual need for it (i.e. a subscriber enlists).", "author": "gsmet", "createdAt": "2020-03-03T18:31:01Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMjY3OA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387212678", "bodyText": "Aren't we going to ditch that at some point?", "author": "gsmet", "createdAt": "2020-03-03T18:32:33Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzNTk0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387235946", "bodyText": "Publisher is the base, we removed Reactive Streams Operators.", "author": "cescoffier", "createdAt": "2020-03-03T19:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMjY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMzQwMw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387213403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            But enough talking, start to get your hands dirty!\n          \n          \n            \n            But enough talking, let's get our hands dirty!\n          \n      \n    \n    \n  \n\n?", "author": "gsmet", "createdAt": "2020-03-03T18:33:48Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMzYyMg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387213622", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For Linux & macOS users\n          \n          \n            \n            For Linux and macOS users\n          \n      \n    \n    \n  \n\n(we should avoid & per doc rules)", "author": "gsmet", "createdAt": "2020-03-03T18:34:13Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNDAzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387214031", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n          \n          \n            \n            The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialize payloads.", "author": "gsmet", "createdAt": "2020-03-03T18:35:01Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNDE3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387214179", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's now creates a `ReactiveGreetingService` class with the following content:\n          \n          \n            \n            Let's now create a `ReactiveGreetingService` class with the following content:", "author": "gsmet", "createdAt": "2020-03-03T18:35:16Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNDc0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387214749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n          \n          \n            \n            These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.", "author": "gsmet", "createdAt": "2020-03-03T18:36:13Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNDk3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387214976", "bodyText": "It's minor but the indentation is off.", "author": "gsmet", "createdAt": "2020-03-03T18:36:38Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0MTQ3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387241476", "bodyText": "Fixed.", "author": "cescoffier", "createdAt": "2020-03-03T19:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNDk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNTc0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387215747", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This application is interacting with a Postgresql database, so you need one:\n          \n          \n            \n            This application is interacting with a PostgreSQL database, so you need one:", "author": "gsmet", "createdAt": "2020-03-03T18:38:08Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNTg4NA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387215884", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, let's configure our data source.\n          \n          \n            \n            Then, let's configure our datasource.", "author": "gsmet", "createdAt": "2020-03-03T18:38:23Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNjQ4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387216487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n          \n          \n            \n            quarkus.datasource.username=quarkus_test\n          \n          \n            \n            quarkus.datasource.password=quarkus_test\n          \n          \n            \n            quarkus.datasource.db-kind=postgresql\n          \n          \n            \n            quarkus.datasource.username=quarkus_test\n          \n          \n            \n            quarkus.datasource.password=quarkus_test\n          \n          \n            \n            quarkus.datasource.reactive.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n          \n      \n    \n    \n  \n\nwould be the new way of doing things now.", "author": "gsmet", "createdAt": "2020-03-03T18:39:27Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNzAzNg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387217036", "bodyText": "IIRC, you can even remove the vertx-reactive: part when doing it this way.", "author": "gsmet", "createdAt": "2020-03-03T18:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNjQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0MTU4OA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387241588", "bodyText": "I will try tomorrow morning.", "author": "cescoffier", "createdAt": "2020-03-03T19:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNjQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0NDI0NA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387244244", "bodyText": "It's working, thanks!", "author": "cescoffier", "createdAt": "2020-03-03T19:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNjQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNjYyMw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387216623", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The 3 first lines define the data source.\n          \n          \n            \n            The 3 first lines define the datasource.", "author": "gsmet", "createdAt": "2020-03-03T18:39:41Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNjczMw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387216733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n          \n          \n            \n            Note the database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.", "author": "gsmet", "createdAt": "2020-03-03T18:39:54Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNzI0MA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387217240", "bodyText": "If you get rid of the prefix, you can remove this note.", "author": "gsmet", "createdAt": "2020-03-03T18:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNjczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNzg0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387217846", "bodyText": "this is a bit weird when the database has retrieved the result. Is the database retrieving things?", "author": "gsmet", "createdAt": "2020-03-03T18:41:53Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzNzIxMA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387237210", "bodyText": "changing it to  when the results have been retrieved.", "author": "cescoffier", "createdAt": "2020-03-03T19:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNzg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxODEzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387218135", "bodyText": "We should avoid star imports.", "author": "gsmet", "createdAt": "2020-03-03T18:42:25Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.*;", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzOTk2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387239966", "bodyText": "Yes, got bitten by the check on the quickstart.", "author": "cescoffier", "createdAt": "2020-03-03T19:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxODEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxODUyNA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387218524", "bodyText": "You have the RabbitMQ work three times.", "author": "gsmet", "createdAt": "2020-03-03T18:43:10Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.*;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0MDMzMg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387240332", "bodyText": "You know I love rabbits!", "author": "cescoffier", "createdAt": "2020-03-03T19:22:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxODUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxODk4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387218981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * `andForget` methods such as `writeAndForget`. `andForget` is available for method returning an `Uni`.\n          \n          \n            \n            * `andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.", "author": "gsmet", "createdAt": "2020-03-03T18:43:56Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.*;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning an `Uni`.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTQxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387219419", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Mutiny provides utilities to convert Rx Java 2 and Project Reactor types to `Uni` and `Multi`.\n          \n          \n            \n            Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.", "author": "gsmet", "createdAt": "2020-03-03T18:44:44Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.*;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning an `Uni`.\n+`andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.\n+However, remember that if you don't subscribe, the operation would not be triggered.\n+`andForget` manages this for you and manage the subscription.\n+* `toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`\n+* `toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`\n+\n+=== Using RxJava or Reactor APIs\n+\n+Mutiny provides utilities to convert Rx Java 2 and Project Reactor types to `Uni` and `Multi`.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTc0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387219741", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Rx Java 2 converters are available in the following dependency:\n          \n          \n            \n            RxJava 2 converters are available in the following dependency:", "author": "gsmet", "createdAt": "2020-03-03T18:45:18Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.*;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning an `Uni`.\n+`andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.\n+However, remember that if you don't subscribe, the operation would not be triggered.\n+`andForget` manages this for you and manage the subscription.\n+* `toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`\n+* `toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`\n+\n+=== Using RxJava or Reactor APIs\n+\n+Mutiny provides utilities to convert Rx Java 2 and Project Reactor types to `Uni` and `Multi`.\n+\n+Rx Java 2 converters are available in the following dependency:", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTkwMg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387219902", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can creates `Unis` and `Multis` as follows:\n          \n          \n            \n            So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:", "author": "gsmet", "createdAt": "2020-03-03T18:45:35Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.*;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning an `Uni`.\n+`andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.\n+However, remember that if you don't subscribe, the operation would not be triggered.\n+`andForget` manages this for you and manage the subscription.\n+* `toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`\n+* `toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`\n+\n+=== Using RxJava or Reactor APIs\n+\n+Mutiny provides utilities to convert Rx Java 2 and Project Reactor types to `Uni` and `Multi`.\n+\n+Rx Java 2 converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-rxjava</artifactId>\n+    <version>$VERSION</version>\n+</dependency>\n+----\n+\n+So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can creates `Unis` and `Multis` as follows:", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTk3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387219972", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also transform `Unis` and `Multis` into Rx Java types:\n          \n          \n            \n            You can also transform `Unis` and `Multis` into RxJava types:", "author": "gsmet", "createdAt": "2020-03-03T18:45:44Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.*;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning an `Uni`.\n+`andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.\n+However, remember that if you don't subscribe, the operation would not be triggered.\n+`andForget` manages this for you and manage the subscription.\n+* `toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`\n+* `toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`\n+\n+=== Using RxJava or Reactor APIs\n+\n+Mutiny provides utilities to convert Rx Java 2 and Project Reactor types to `Uni` and `Multi`.\n+\n+Rx Java 2 converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-rxjava</artifactId>\n+    <version>$VERSION</version>\n+</dependency>\n+----\n+\n+So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can creates `Unis` and `Multis` as follows:\n+\n+[source, java]\n+----\n+import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n+import io.smallrye.mutiny.converters.uni.UniRxConverters;\n+// ...\n+Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\n+Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\n+Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\n+Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\n+Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\n+Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n+\n+Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\n+Multi<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\n+Multi<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\n+Multi<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n+Multi<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\n+Multi<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n+----\n+\n+You can also transform `Unis` and `Multis` into Rx Java types:", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyMDEzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387220139", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            So if you have an API returningReactor types (`Mono`, `Flux`), you can creates `Unis` and `Multis` as follows:\n          \n          \n            \n            So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:", "author": "gsmet", "createdAt": "2020-03-03T18:46:00Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,854 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+:toc: macro\n+:toclevels: 4\n+:doctype: book\n+:icons: font\n+:docinfo1:\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e., a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, start to get your hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux & macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialized payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now creates a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka and any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a Postgresql database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our data source.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkus_test\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the data source.\n+Note database URL prefix, using `vertx-reactive` instead of the traditional `jdbc`.\n+It indicates that this data source uses a reactive driver.\n+\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the database has retrieved the result.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.*;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning an `Uni`.\n+`andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.\n+However, remember that if you don't subscribe, the operation would not be triggered.\n+`andForget` manages this for you and manage the subscription.\n+* `toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`\n+* `toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`\n+\n+=== Using RxJava or Reactor APIs\n+\n+Mutiny provides utilities to convert Rx Java 2 and Project Reactor types to `Uni` and `Multi`.\n+\n+Rx Java 2 converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-rxjava</artifactId>\n+    <version>$VERSION</version>\n+</dependency>\n+----\n+\n+So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can creates `Unis` and `Multis` as follows:\n+\n+[source, java]\n+----\n+import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n+import io.smallrye.mutiny.converters.uni.UniRxConverters;\n+// ...\n+Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\n+Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\n+Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\n+Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\n+Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\n+Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n+\n+Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\n+Multi<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\n+Multi<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\n+Multi<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n+Multi<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\n+Multi<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n+----\n+\n+You can also transform `Unis` and `Multis` into Rx Java types:\n+\n+[source, java]\n+----\n+Completable completable = uni.convert().with(UniRxConverters.toCompletable());\n+Single<Optional<String>> single = uni.convert().with(UniRxConverters.toSingle());\n+Single<String> single2 = uni.convert().with(UniRxConverters.toSingle().failOnNull());\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Observable<String> observable = uni.convert().with(UniRxConverters.toObservable());\n+Flowable<String> flowable = uni.convert().with(UniRxConverters.toFlowable());\n+// ...\n+Completable completable = multi.convert().with(MultiRxConverters.toCompletable());\n+Single<Optional<String>> single = multi.convert().with(MultiRxConverters.toSingle());\n+Single<String> single2 = multi.convert().with(MultiRxConverters\n+        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\n+Maybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\n+Observable<String> observable = multi.convert().with(MultiRxConverters.toObservable());\n+Flowable<String> flowable = multi.convert().with(MultiRxConverters.toFlowable());\n+----\n+\n+Project Reactor converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-reactor</artifactId>\n+    <version>$VERSION</version>\n+</dependency>\n+----\n+\n+So if you have an API returningReactor types (`Mono`, `Flux`), you can creates `Unis` and `Multis` as follows:", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyMDY5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387220692", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you are interested in reactive, we recommend the link:getting-started-reactive[getting started with reactive guide], where you can see how to implement reactive applications with Quarkus.\n          \n          \n            \n            If you are interested in reactive, we recommend the link:getting-started-reactive[Getting started with reactive guide], where you can see how to implement reactive applications with Quarkus.", "author": "gsmet", "createdAt": "2020-03-03T18:47:00Z", "path": "docs/src/main/asciidoc/getting-started.adoc", "diffHunk": "@@ -443,26 +443,12 @@ So if you want to deploy your application somewhere, you need to copy the _runne\n \n NOTE: Before running the application, don't forget to stop the hot reload mode (hit `CTRL+C`), or you will have a port conflict.\n \n-== Async\n-\n-The resource can also use `CompletionStage` or `Uni` (requires the `quarkus-resteasy-mutiny` extension) as return type to handle asynchronous actions:\n-\n-[source,java]\n-----\n-@GET\n-@Produces(MediaType.TEXT_PLAIN)\n-public Uni<String> hello() {\n-    return Uni.createFrom().item(() -> \"hello\");\n-}\n-----\n-\n-The async version of the code is available in the {quickstarts-base-url}[GitHub] repository, in the `getting-started-async` directory.\n-\n == What's next?\n \n This guide covered the creation of an application using Quarkus.\n However, there is much more.\n We recommend continuing the journey with the link:building-native-image[building a native executable guide], where you learn about creating a native executable and packaging it in a container.\n+If you are interested in reactive, we recommend the link:getting-started-reactive[getting started with reactive guide], where you can see how to implement reactive applications with Quarkus.", "originalCommit": "3254b56babb85db70c0ade2f158c867d5832edd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dd1ac558268415f7cee4c10b484c30c156895ba5", "url": "https://github.com/quarkusio/quarkus/commit/dd1ac558268415f7cee4c10b484c30c156895ba5", "message": "Write the getting started with reactive documentation\n\nCo-Authored-By: Guillaume Smet <guillaume.smet@gmail.com>", "committedDate": "2020-03-03T19:23:59Z", "type": "forcePushed"}, {"oid": "7c6a15dfd3a4ca04656ba087ea9d739a61d2c88e", "url": "https://github.com/quarkusio/quarkus/commit/7c6a15dfd3a4ca04656ba087ea9d739a61d2c88e", "message": "Write the getting started with reactive documentation\n\nCo-Authored-By: Guillaume Smet <guillaume.smet@gmail.com>", "committedDate": "2020-03-03T19:35:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MzUzNw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387543537", "bodyText": "Maybe add a note on why we need SseElementType :\n\nthe @SseElementType annotation indicating the type of each event, as the @Produces annotation defines SERVER_SENT_EVENTS JAX-RS needs it to knows the content-type of each event.", "author": "loicmathieu", "createdAt": "2020-03-04T09:30:42Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,840 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e. a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, let's get our hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux and macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialize payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now create a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+  return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.", "originalCommit": "7c6a15dfd3a4ca04656ba087ea9d739a61d2c88e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MzY4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387543682", "bodyText": "Maybe use a more recent version, 11.2 ?", "author": "loicmathieu", "createdAt": "2020-03-04T09:30:54Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,840 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e. a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, let's get our hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux and macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialize payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now create a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+  return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a PostgreSQL database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5", "originalCommit": "7c6a15dfd3a4ca04656ba087ea9d739a61d2c88e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0MzkxOA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387643918", "bodyText": "Done.", "author": "cescoffier", "createdAt": "2020-03-04T12:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MzY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MzgxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387543811", "bodyText": "version should comes from Quarkus bom or we risk having non-coherent versions of mutiny", "author": "loicmathieu", "createdAt": "2020-03-04T09:31:05Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,840 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e. a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, let's get our hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux and macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialize payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now create a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+  return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a PostgreSQL database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our datasource.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the datasource.\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.\n+`andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.\n+However, remember that if you don't subscribe, the operation would not be triggered.\n+`andForget` manages this for you and manage the subscription.\n+* `toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`\n+* `toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`\n+\n+=== Using RxJava or Reactor APIs\n+\n+Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.\n+\n+RxJava 2 converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-rxjava</artifactId>\n+    <version>$VERSION</version>", "originalCommit": "7c6a15dfd3a4ca04656ba087ea9d739a61d2c88e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2NTg3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387565879", "bodyText": "Yeah, if it's in the BOM, we could skip the version.", "author": "gsmet", "createdAt": "2020-03-04T10:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzNDUwNA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387634504", "bodyText": "It's not in the BOM :-) But I can add them.", "author": "cescoffier", "createdAt": "2020-03-04T12:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0Mzc0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387643749", "bodyText": "Defined in the BOM, documentation updated.", "author": "cescoffier", "createdAt": "2020-03-04T12:47:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MzgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0Mzg4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387543887", "bodyText": "same here : in the bom", "author": "loicmathieu", "createdAt": "2020-03-04T09:31:12Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,840 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e. a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, let's get our hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux and macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialize payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now create a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+  return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a PostgreSQL database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our datasource.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the datasource.\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.\n+`andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.\n+However, remember that if you don't subscribe, the operation would not be triggered.\n+`andForget` manages this for you and manage the subscription.\n+* `toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`\n+* `toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`\n+\n+=== Using RxJava or Reactor APIs\n+\n+Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.\n+\n+RxJava 2 converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-rxjava</artifactId>\n+    <version>$VERSION</version>\n+</dependency>\n+----\n+\n+So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:\n+\n+[source, java]\n+----\n+import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n+import io.smallrye.mutiny.converters.uni.UniRxConverters;\n+// ...\n+Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\n+Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\n+Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\n+Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\n+Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\n+Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n+\n+Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\n+Multi<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\n+Multi<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\n+Multi<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n+Multi<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\n+Multi<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n+----\n+\n+You can also transform `Unis` and `Multis` into RxJava types:\n+\n+[source, java]\n+----\n+Completable completable = uni.convert().with(UniRxConverters.toCompletable());\n+Single<Optional<String>> single = uni.convert().with(UniRxConverters.toSingle());\n+Single<String> single2 = uni.convert().with(UniRxConverters.toSingle().failOnNull());\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Observable<String> observable = uni.convert().with(UniRxConverters.toObservable());\n+Flowable<String> flowable = uni.convert().with(UniRxConverters.toFlowable());\n+// ...\n+Completable completable = multi.convert().with(MultiRxConverters.toCompletable());\n+Single<Optional<String>> single = multi.convert().with(MultiRxConverters.toSingle());\n+Single<String> single2 = multi.convert().with(MultiRxConverters\n+        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\n+Maybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\n+Observable<String> observable = multi.convert().with(MultiRxConverters.toObservable());\n+Flowable<String> flowable = multi.convert().with(MultiRxConverters.toFlowable());\n+----\n+\n+Project Reactor converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-reactor</artifactId>\n+    <version>$VERSION</version>", "originalCommit": "7c6a15dfd3a4ca04656ba087ea9d739a61d2c88e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0Mzk0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387543945", "bodyText": "Maybe rename the title as\n=== Using CompletionStages or Publisher API\n\nTh current one feels strange to me.", "author": "loicmathieu", "createdAt": "2020-03-04T09:31:19Z", "path": "docs/src/main/asciidoc/getting-started-reactive.adoc", "diffHunk": "@@ -0,0 +1,840 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Getting started with Reactive\n+\n+include::./attributes.adoc[]\n+\n+Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.\n+This guide covers:\n+\n+* A quick glance at the Quarkus engine and how it enables reactive\n+* A brief introduction to Mutiny - the reactive programming library used by Quarkus\n+* Bootstrapping a reactive application\n+* Creating a reactive JAX-RS endpoint (asynchronous, streams...)\n+* Using reactive database access\n+* Interacting with other reactive APIs\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== Solutions\n+\n+We recommend that you follow the instructions from <<bootstrapping-the-project,Boostrapping project>> and onwards to create the application step by step.\n+\n+However, you can go right to the completed example.\n+\n+Download an {quickstarts-archive-url}[archive] or clone the git repository:\n+\n+[source,shell,subs=attributes+]\n+----\n+git clone {quickstarts-clone-url}\n+----\n+\n+The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.\n+\n+== The multiple reactive facets of Quarkus\n+\n+Quarkus is reactive.\n+If you look under the hood, you will find a reactive engine powering your Quarkus application.\n+This engine is Eclipse Vert.x (https://vertx.io).\n+Every IO interaction passes through the non-blocking and reactive Vert.x engine.\n+\n+image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 50%]\n+\n+Let's take 2 examples to explain how it works.\n+Imagine an incoming HTTP request.\n+The (Vert.x) HTTP server receives the request and then routes it to the application.\n+If the request targets a JAX-RS resource, the routing layer invokes the resource method in a worker thread and writes the response when the data is available.\n+So far, nothing new or outstanding.\n+The following picture depicts this behavior.\n+\n+image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 50%]\n+\n+But if the HTTP request targets a reactive (non-blocking) route, the routing layer invokes the route on the IO thread giving lots of benefits such as higher concurrency and performance:\n+\n+image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 50%]\n+\n+As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.\n+But, to fully benefit from this model, the application code should be written in a non-blocking manner.\n+That\u2019s where having a reactive API is an ultimate weapon.\n+\n+== Mutiny - A reactive programming library\n+\n+https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.\n+It offers 2 types:\n+\n+* `io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result\n+* `io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams\n+\n+Both types are lazy and follow a subscription pattern.\n+The computation only starts once there is an actual need for it (i.e. a subscriber enlists).\n+\n+[source, java]\n+----\n+uni.subscribe().with(\n+    result -> System.out.println(\"result is \" + result),\n+    failure -> failure.printStackTrace()\n+);\n+\n+multi.subscribe().with(\n+    item -> System.out.println(\"Got \" + item),\n+    failure -> failure.printStackTrace()\n+);\n+----\n+\n+Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).\n+These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.\n+The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.\n+It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.\n+\n+[source, java]\n+----\n+httpCall\n+    .onFailure().recoverWithItem(\"my fallback\");\n+----\n+\n+You may wonder about Reactive Streams (https://www.reactive-streams.org/).\n+`Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.\n+`Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.\n+It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.\n+\n+Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.\n+For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.\n+\n+[source, java]\n+----\n+// Block until the result is available\n+String result = uni.await().indefinitely();\n+\n+// Transform an asynchronous stream into a blocking iterable\n+stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n+----\n+\n+At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...\n+Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:\n+\n+[source, java]\n+----\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+But, what about Vert.x?\n+Vert.x APIs are also available using Mutiny types.\n+The following snippet shows a usage of the Vert.x Web Client:\n+\n+[source, java]\n+----\n+// Use io.vertx.mutiny.ext.web.client.WebClient\n+client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+// ...\n+Uni<JsonObject> uni =\n+    client.get(\"/api/fruit/\" + name)\n+        .send()\n+        .onItem().apply(resp -> {\n+            if (resp.statusCode() == 200) {\n+                return resp.bodyAsJsonObject();\n+            } else {\n+                return new JsonObject()\n+                        .put(\"code\", resp.statusCode())\n+                        .put(\"message\", resp.bodyAsString());\n+            }\n+        });\n+----\n+\n+Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.\n+\n+But enough talking, let's get our hands dirty!\n+\n+== Bootstrapping the project\n+\n+The easiest way to create a new Quarkus project is to open a terminal and run the following command:\n+\n+For Linux and macOS users\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive \\\n+    -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" \\\n+    -Dpath=\"/hello\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb\"\n+cd getting-started-reactive\n+----\n+\n+For Windows users\n+\n+- If using cmd, (don't use forward slash `\\`)\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.quickstart.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+- If using Powershell, wrap `-D` parameters in double quotes\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.quickstart.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-mutiny,resteasy-jsonb\"\n+----\n+\n+It generates the following in  `./getting-started-reactive`:\n+\n+* the Maven structure\n+* an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`\n+* an associated unit test\n+* a landing page that is accessible on `http://localhost:8080` after starting the application\n+* example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`\n+* the application configuration file\n+\n+The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy JSON-B to serialize payloads.\n+\n+=== Reactive JAX-RS resources\n+\n+During the project creation, the `src/main/java/org/acme/quickstart/ReactiveGreetingResource.java` file has been created with the following content:\n+\n+[source,java]\n+----\n+package org.acme.quickstart;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+It's a very simple REST endpoint, returning \"hello\" to requests on \"/hello\".\n+\n+Let's now create a `ReactiveGreetingService` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import java.time.Duration;\n+\n+@ApplicationScoped\n+public class ReactiveGreetingService {\n+\n+    public Uni<String> greeting(String name) {\n+        return Uni.createFrom().item(name)\n+                .onItem().apply(n -> String.format(\"hello %s\", name));\n+    }\n+}\n+----\n+\n+Then, edit the `ReactiveGreetingResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.getting.started;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import org.jboss.resteasy.annotations.SseElementType;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+import org.reactivestreams.Publisher;\n+\n+@Path(\"/hello\")\n+public class ReactiveGreetingResource {\n+\n+    @Inject\n+    ReactiveGreetingService service;\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"/greeting/{name}\")\n+    public Uni<String> greeting(@PathParam String name) {\n+        return service.greeting(name);\n+    }\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+}\n+----\n+\n+The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.\n+While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`. We cover this later in this guide.\n+\n+Now, start the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Once running, check that you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.\n+\n+== Handling streams\n+So far, we only return an asynchronous result.\n+In this section, we extend the application with streams conveying multiple items.\n+These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.\n+\n+In the `ReactiveGreetingService`, add the following method:\n+\n+[source, java]\n+----\n+public Multi<String> greetings(int count, String name) {\n+  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n+        .onItem().apply(n -> String.format(\"hello %s - %d\", name, n))\n+        .transform().byTakingFirstItems(count);\n+}\n+----\n+\n+It generates a greeting message every second and stops after `count` messages.\n+\n+In the `ReactiveGreetingResource` add the following method:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.APPLICATION_JSON)\n+@Path(\"/greeting/{count}/{name}\")\n+public Multi<String> greetings(@PathParam int count, @PathParam String name) {\n+  return service.greetings(count, name);\n+}\n+----\n+\n+This endpoint streams the items to the client as a JSON Array.\n+The name and number of messages are parameterized using path parameters.\n+\n+So calling the endpoint produces something like:\n+[source, shell]\n+----\n+$ curl http://localhost:8080/hello/greeting/3/neo\n+[\"hello neo - 0\",\"hello neo - 1\",\"hello neo - 2\"]\n+----\n+\n+We can also generate Server-Sent Event responses by returning a `Multi`:\n+\n+[source, java]\n+----\n+@GET\n+@Produces(MediaType.SERVER_SENT_EVENTS)\n+@SseElementType(MediaType.TEXT_PLAIN)\n+@Path(\"/stream/{count}/{name}\")\n+public Multi<String> greetingsAsStream(@PathParam int count, @PathParam String name) {\n+    return service.greetings(count, name);\n+}\n+----\n+\n+The only difference with the previous snippet is the produced type and the `@SseElementType` annotation indicating the type of each event.\n+\n+You can see the result using:\n+\n+[source, shell]\n+----\n+$ curl -N http://localhost:8080/hello/stream/5/neo\n+data: hello neo - 0\n+\n+data: hello neo - 1\n+\n+data: hello neo - 2\n+\n+data: hello neo - 3\n+\n+data: hello neo - 4\n+----\n+\n+== Using Reactive APIs\n+\n+=== Using Quarkus reactive APIs\n+\n+Quarkus provides many reactive APIs using the Mutiny model.\n+In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.\n+\n+Create a new project using:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=getting-started-reactive-crud \\\n+    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-mutiny, resteasy-jsonb, reactive-pg-client\"\n+cd getting-started-reactive-crud\n+----\n+\n+This application is interacting with a PostgreSQL database, so you need one:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n+           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n+           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n+           -p 5432:5432 postgres:10.5\n+----\n+\n+Then, let's configure our datasource.\n+Open the `src/main/resources/application.properties` and add the following content:\n+\n+[source, properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n+myapp.schema.create=true\n+----\n+\n+The 3 first lines define the datasource.\n+The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.\n+\n+Now, let's create our _entity_.\n+Create the `org.acme.reactive.crud.Fruit` class with the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import io.vertx.mutiny.sqlclient.Row;\n+import io.vertx.mutiny.sqlclient.RowSet;\n+import io.vertx.mutiny.sqlclient.Tuple;\n+\n+import java.util.stream.StreamSupport;\n+\n+public class Fruit {\n+\n+    public Long id;\n+\n+    public String name;\n+\n+    public Fruit() {\n+        // default constructor.\n+    }\n+\n+    public Fruit(String name) {\n+        this.name = name;\n+    }\n+\n+    public Fruit(Long id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public static Multi<Fruit> findAll(PgPool client) {\n+        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\")\n+                // Create a Multi from the set of rows:\n+                .onItem().produceMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n+                // For each row create a fruit instance\n+                .onItem().apply(Fruit::from);\n+    }\n+\n+    public static Uni<Fruit> findById(PgPool client, Long id) {\n+        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(RowSet::iterator)\n+                .onItem().apply(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n+    }\n+\n+    public Uni<Long> save(PgPool client) {\n+        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\", Tuple.of(name))\n+                .onItem().apply(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n+    }\n+\n+    public Uni<Boolean> update(PgPool client) {\n+        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\", Tuple.of(name, id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    public static Uni<Boolean> delete(PgPool client, Long id) {\n+        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\", Tuple.of(id))\n+                .onItem().apply(pgRowSet -> pgRowSet.rowCount() == 1);\n+    }\n+\n+    private static Fruit from(Row row) {\n+        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n+    }\n+}\n+----\n+\n+This _entity_ contains a few fields and methods to find, update, and delete rows from the database.\n+These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.\n+Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.\n+So you only transform the results from the database into _business-friendly_ objects.\n+\n+Then, let's use this `Fruit` class in the `FruitResource`.\n+Edit the `FruitResource` class to match the following content:\n+\n+[source, java]\n+----\n+package org.acme.reactive.crud;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.pgclient.PgPool;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+import javax.ws.rs.core.Response.Status;\n+import java.net.URI;\n+\n+@Path(\"fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+\n+    @Inject\n+    @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\")\n+    boolean schemaCreate;\n+\n+    @Inject\n+    PgPool client;\n+\n+    @PostConstruct\n+    void config() {\n+        if (schemaCreate) {\n+            initdb();\n+        }\n+    }\n+\n+    private void initdb() {\n+        client.query(\"DROP TABLE IF EXISTS fruits\")\n+                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\"))\n+                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\"))\n+                .await().indefinitely();\n+    }\n+\n+    @GET\n+    public Multi<Fruit> get() {\n+        return Fruit.findAll(client);\n+    }\n+\n+    @GET\n+    @Path(\"{id}\")\n+    public Uni<Response> getSingle(@PathParam Long id) {\n+        return Fruit.findById(client, id)\n+                .onItem().apply(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n+                .onItem().apply(ResponseBuilder::build);\n+    }\n+\n+    @POST\n+    public Uni<Response> create(Fruit fruit) {\n+        return fruit.save(client)\n+                .onItem().apply(id -> URI.create(\"/fruits/\" + id))\n+                .onItem().apply(uri -> Response.created(uri).build());\n+    }\n+\n+    @PUT\n+    @Path(\"{id}\")\n+    public Uni<Response> update(@PathParam Long id, Fruit fruit) {\n+        return fruit.update(client)\n+                .onItem().apply(updated -> updated ? Status.OK : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+\n+    @DELETE\n+    @Path(\"{id}\")\n+    public Uni<Response> delete(@PathParam Long id) {\n+        return Fruit.delete(client, id)\n+                .onItem().apply(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n+                .onItem().apply(status -> Response.status(status).build());\n+    }\n+}\n+----\n+\n+This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.\n+\n+=== Using Vert.x clients\n+\n+The previous example uses a _service_ provided by Quarkus.\n+Also, you can use Vert.x clients directly.\n+There is a Mutiny version of the Vert.x APIs.\n+This API is divided into several artifacts you can import independently:\n+\n+|===\n+|groupId:artifactId | Description\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n+|Mutiny API for Vert.x Core\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n+|Mutiny API for the Vert.x Mail Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n+|Mutiny API for the Vert.x Web Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n+|Mutiny API for the Vert.x Mongo Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n+|Mutiny API for the Vert.x Redis Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n+|Mutiny API for the Vert.x Cassandra Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n+|Mutiny API for the Vert.x Consul Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n+|Mutiny API for the Vert.x Kafka Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n+|Mutiny API for the Vert.x AMQP Client\n+\n+|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n+|Mutiny API for the Vert.x RabbitMQ Client\n+|===\n+\n+You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.\n+\n+Let's take an example.\n+Add the following dependency to your application:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+</dependency>\n+----\n+\n+It provides the Mutiny API of the Vert.x Web Client.\n+Then, you can use the web client as follows:\n+\n+[source, java]\n+----\n+package org.acme.vertx;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/fruit-data\")\n+public class ResourceUsingWebClient {\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    private WebClient client;\n+\n+    @PostConstruct\n+    void initialize() {\n+        this.client = WebClient.create(vertx,\n+                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n+                        .setTrustAll(true));\n+    }\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @Path(\"/{name}\")\n+    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n+        return client.get(\"/api/fruit/\" + name)\n+                .send()\n+                .map(resp -> {\n+                    if (resp.statusCode() == 200) {\n+                        return resp.bodyAsJsonObject();\n+                    } else {\n+                        return new JsonObject()\n+                                .put(\"code\", resp.statusCode())\n+                                .put(\"message\", resp.bodyAsString());\n+                    }\n+                });\n+    }\n+\n+}\n+----\n+\n+There are 2 important points:\n+\n+1. The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;\n+2. The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.\n+\n+The Mutiny version of the Vert.x APIs also offers:\n+\n+* `andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.\n+Be aware not to block the event loop / IO thread that way.\n+* `andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.\n+`andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.\n+However, remember that if you don't subscribe, the operation would not be triggered.\n+`andForget` manages this for you and manage the subscription.\n+* `toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`\n+* `toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`\n+\n+=== Using RxJava or Reactor APIs\n+\n+Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.\n+\n+RxJava 2 converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-rxjava</artifactId>\n+    <version>$VERSION</version>\n+</dependency>\n+----\n+\n+So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:\n+\n+[source, java]\n+----\n+import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n+import io.smallrye.mutiny.converters.uni.UniRxConverters;\n+// ...\n+Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\n+Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\n+Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\n+Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\n+Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\n+Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n+\n+Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\n+Multi<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\n+Multi<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\n+Multi<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n+Multi<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\n+Multi<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n+----\n+\n+You can also transform `Unis` and `Multis` into RxJava types:\n+\n+[source, java]\n+----\n+Completable completable = uni.convert().with(UniRxConverters.toCompletable());\n+Single<Optional<String>> single = uni.convert().with(UniRxConverters.toSingle());\n+Single<String> single2 = uni.convert().with(UniRxConverters.toSingle().failOnNull());\n+Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n+Observable<String> observable = uni.convert().with(UniRxConverters.toObservable());\n+Flowable<String> flowable = uni.convert().with(UniRxConverters.toFlowable());\n+// ...\n+Completable completable = multi.convert().with(MultiRxConverters.toCompletable());\n+Single<Optional<String>> single = multi.convert().with(MultiRxConverters.toSingle());\n+Single<String> single2 = multi.convert().with(MultiRxConverters\n+        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\n+Maybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\n+Observable<String> observable = multi.convert().with(MultiRxConverters.toObservable());\n+Flowable<String> flowable = multi.convert().with(MultiRxConverters.toFlowable());\n+----\n+\n+Project Reactor converters are available in the following dependency:\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.smallrye.reactive</groupId>\n+    <artifactId>mutiny-reactor</artifactId>\n+    <version>$VERSION</version>\n+</dependency>\n+----\n+\n+So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:\n+\n+[source, java]\n+----\n+import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\n+import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n+// ...\n+Uni<String> uniFromMono = Uni.createFrom().converter(UniReactorConverters.fromMono(), mono);\n+Uni<String> uniFromFlux = Uni.createFrom().converter(UniReactorConverters.fromFlux(), flux);\n+\n+Multi<String> multiFromMono = Multi.createFrom().converter(MultiReactorConverters.fromMono(), mono);\n+Multi<String> multiFromFlux = Multi.createFrom().converter(MultiReactorConverters.fromFlux(), flux);\n+----\n+\n+You can also transform `Unis` and `Multis` into Reactor types:\n+\n+[source, java]\n+----\n+Mono<String> mono = uni.convert().with(UniReactorConverters.toMono());\n+Flux<String> flux = uni.convert().with(UniReactorConverters.toFlux());\n+\n+Mono<String> mono2 = multi.convert().with(MultiReactorConverters.toMono());\n+Flux<String> flux2 = multi.convert().with(MultiReactorConverters.toFlux());\n+----\n+\n+=== Using API using CompletionStages or Publisher", "originalCommit": "7c6a15dfd3a4ca04656ba087ea9d739a61d2c88e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0MzgxMA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387643810", "bodyText": "Fixed.", "author": "cescoffier", "createdAt": "2020-03-04T12:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0Mzk0NQ=="}], "type": "inlineReview"}, {"oid": "37137c53af794d975e96bd2681720e6916626f34", "url": "https://github.com/quarkusio/quarkus/commit/37137c53af794d975e96bd2681720e6916626f34", "message": "Cross-reference the Mutiny section of the getting started with reactive in the various guides using Mutiny", "committedDate": "2020-03-04T12:46:49Z", "type": "forcePushed"}, {"oid": "9321bc598a910ce7bbd3df4378cdbfe2866388be", "url": "https://github.com/quarkusio/quarkus/commit/9321bc598a910ce7bbd3df4378cdbfe2866388be", "message": "Cross-reference the Mutiny section of the getting started with reactive in the various guides using Mutiny", "committedDate": "2020-03-04T12:51:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTg3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387659871", "bodyText": "read the link:getting-started-reactive#mutiny[Getting Started with Reactive] guide first\n\nOR\n\nread the link:getting-started-reactive#mutiny[Getting Started with Reactive] first", "author": "loicmathieu", "createdAt": "2020-03-04T13:18:47Z", "path": "docs/src/main/asciidoc/mailer.adoc", "diffHunk": "@@ -110,6 +110,12 @@ NOTE: The two APIs are equivalent feature-wise. Actually the `Mailer` implementa\n `io.quarkus.mailer.ReactiveMailer` is deprecated in favor of `io.quarkus.mailer.reactive.ReactiveMailer`.\n ====\n \n+[TIP]\n+.Mutiny\n+====\n+The reactive mailer uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive] first.", "originalCommit": "9321bc598a910ce7bbd3df4378cdbfe2866388be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1MDg0OA==", "url": "https://github.com/quarkusio/quarkus/pull/7539#discussion_r387950848", "bodyText": "I force pushed a fix.", "author": "gsmet", "createdAt": "2020-03-04T21:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTg3MQ=="}], "type": "inlineReview"}, {"oid": "7ac3cc602bb98af3dad5cf57f26f407d5dc2f2b6", "url": "https://github.com/quarkusio/quarkus/commit/7ac3cc602bb98af3dad5cf57f26f407d5dc2f2b6", "message": "Write the getting started with reactive documentation\n\nCo-Authored-By: Guillaume Smet <guillaume.smet@gmail.com>", "committedDate": "2020-03-04T21:40:47Z", "type": "commit"}, {"oid": "57990b8ce0531140ec408b9d50c374ca30ca7691", "url": "https://github.com/quarkusio/quarkus/commit/57990b8ce0531140ec408b9d50c374ca30ca7691", "message": "Add the Mutiny converters to the BOM file", "committedDate": "2020-03-04T21:40:47Z", "type": "commit"}, {"oid": "ba4e7811709c7c22257d867fe43452986e3479fa", "url": "https://github.com/quarkusio/quarkus/commit/ba4e7811709c7c22257d867fe43452986e3479fa", "message": "Cross-reference the Mutiny section of the getting started with reactive in the various guides using Mutiny", "committedDate": "2020-03-04T21:40:47Z", "type": "commit"}, {"oid": "ba4e7811709c7c22257d867fe43452986e3479fa", "url": "https://github.com/quarkusio/quarkus/commit/ba4e7811709c7c22257d867fe43452986e3479fa", "message": "Cross-reference the Mutiny section of the getting started with reactive in the various guides using Mutiny", "committedDate": "2020-03-04T21:40:47Z", "type": "forcePushed"}]}