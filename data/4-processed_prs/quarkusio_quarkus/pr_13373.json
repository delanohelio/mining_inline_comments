{"pr_number": 13373, "pr_title": "Spring Data REST", "pr_createdAt": "2020-11-19T10:36:29Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13373", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3MjA5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r526972097", "bodyText": "I am wondering how this worked before...", "author": "geoand", "createdAt": "2020-11-19T15:22:40Z", "path": "extensions/panache/rest-data-panache/deployment/src/main/java/io/quarkus/rest/data/panache/deployment/properties/ResourcePropertiesBuildItem.java", "diffHunk": "@@ -2,7 +2,7 @@\n \n import io.quarkus.builder.item.MultiBuildItem;\n \n-public class ResourcePropertiesBuildItem extends MultiBuildItem {\n+public final class ResourcePropertiesBuildItem extends MultiBuildItem {", "originalCommit": "ae590b3d105a12b23b83f265bf112f1b492bd15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUxMjY2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r527512662", "bodyText": "No idea :/", "author": "gytis", "createdAt": "2020-11-20T08:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3MjA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3NDI2MA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r526974260", "bodyText": "s/nor/or", "author": "geoand", "createdAt": "2020-11-19T15:25:18Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+== Run the application as a native binary\n+\n+You can of course create a native executable following the instructions of the link:building-native-image[this] guide.\n+\n+== Supported Spring Data REST functionalities\n+\n+Quarkus currently supports a subset of Spring Data REST features, namely the most useful and most commonly used features.\n+\n+=== What is supported\n+\n+The following sections described the most important supported features of Spring Data REST.\n+\n+==== Automatic REST endpoint generation\n+\n+Interfaces that extend any of the following Spring Data repositories get automatically generated REST endpoints:\n+\n+* `org.springframework.data.repository.CrudRepository`\n+* `org.springframework.data.repository.PagingAndSortingRepository`\n+* `org.springframework.data.jpa.repository.JpaRepository`\n+\n+Endpoints generated from the above repositories expose five common REST operations:\n+\n+* `GET /fruits` - lists all entities or returns a page if `PagingAndSortingRepository` or `JpaRepository` is used.\n+* `GET /fruits/:id` - returns an entity by ID.\n+* `POST /fruits` - creates a new entity.\n+* `PUT /fruits/:id` - updates an existing entity or creates a new one with a specified ID (if allowed by the entity definition).\n+* `DELETE /fruits/:id` - deletes an entity by ID.\n+\n+There are two supported data types: `application/json` and `application/hal+json`.\n+The former is used by default, but it is highly recommended to specify which one do you prefer with an `Accept` header.\n+\n+==== Exposing many entities\n+\n+If a database contains many entities, it might not be a great idea to return them all at once.\n+`PagingAndSortingRepository` allows `spring-data-rest` extension to access data in chunks.\n+\n+Replace the `CrudRepository` with `PagingAndSortingRepository` in the `FruitsRepository`:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.PagingAndSortingRepository;\n+\n+public interface FruitsRepository extends PagingAndSortingRepository<Fruit, Long> {\n+}\n+----\n+\n+Now the `GET /fruits` will accept three new query parameters: `sort`, `page` and `size`.\n+\n+|===\n+| Query parameter | Description | Default value | Example values\n+\n+| `sort`\n+| Sorts the entities that are returned by the list operation\n+| \"\"\n+| `?sort=name` (ascending name), `?sort=name,-color` (ascending name and descending color)\n+\n+| `page`\n+| Zero indexed page number. Invalid value is interpreted as 0.\n+| 0\n+| 0, 11, 100\n+\n+| `size`\n+| Page size. Minimal accepted value is 1. Any lower value is interpreted as 1.\n+| 20\n+| 1, 11, 100\n+|===\n+\n+For paged responses, `spring-data-rest` also returns a set of link headers that can be used to access other pages: first, previous, next and last.\n+\n+==== Fine tuning endpoints generation\n+\n+This allows user to specify which methods should be exposed and what path should be used to access them.\n+Spring Data REST provides two annotations that can be used: `@RepositoryRestResource` and `@RestResource`.\n+`spring-data-rest` extension supports the `exported` and `path` attributes of these annotations.\n+\n+Assume for example that fruits repository should be accessible by a `/my-fruits` path and only allow `GET` operation.\n+In such a case, `FruitsRepository` would look like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import java.util.Optional;\n+\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.rest.core.annotation.RepositoryRestResource;\n+import org.springframework.data.rest.core.annotation.RestResource;\n+\n+@RepositoryRestResource(exported = false, path = \"/my-fruits\")\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+\n+    @RestResource(exported = true)\n+    Optional<Fruit> findById(Long id);\n+\n+    @RestResource(exported = true)\n+    Iterable<Fruit> findAll();\n+}\n+----\n+\n+`spring-data-rest` uses only a subset of the repository methods for data access.\n+It is important to annotate the correct method in order to customize its REST endpoint:\n+\n+|===\n+|REST operation |CrudRepository |PagingAndSortingRepository and JpaRepository\n+\n+|Get by ID\n+|`Optional<T> findById(ID id)`\n+|`Optional<T> findById(ID id)`\n+\n+|List\n+|`Iterable<T> findAll()`\n+|`Page<T> findAll(Pageable pageable)`\n+\n+|Create\n+|`<S extends T> S save(S entity)`\n+|`<S extends T> S save(S entity)`\n+\n+|Update\n+|`<S extends T> S save(S entity)`\n+|`<S extends T> S save(S entity)`\n+\n+|Delete\n+|`void deleteById(ID id)`\n+|`void deleteById(ID id)`\n+|===\n+\n+=== What is currently unsupported\n+\n+* Only the repository methods listed above are supported. No other standard nor custom methods are supported.", "originalCommit": "ae590b3d105a12b23b83f265bf112f1b492bd15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3NDk0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r526974942", "bodyText": "Is there a way to opt out of REST Resource generation?\nShould there be some kind of build time warning if there is a clashing user defined Resource?", "author": "geoand", "createdAt": "2020-11-19T15:26:08Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.", "originalCommit": "ae590b3d105a12b23b83f265bf112f1b492bd15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUxNTgzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r527515835", "bodyText": "You can annotate interface or a method with either @RepositoryRestResource(exported=false) or @RestResource(exported=false). It will still generate a JAX-RS class but it will not have any method. I don't think that should cause any clashing though.\nI'm not sure if there is an easy way to produce such a warning in a current state (there might be with the new REST extension). It is a valid scenario to have two classes on a same base path. In any case that would be something to look at in the rest-data-panache extension. spring-data-rest does not generate JAX-RS endpoints.", "author": "gytis", "createdAt": "2020-11-20T08:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3NDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUxODg0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r527518841", "bodyText": "Good to know.\nDoes spring-data-rest proper have a way of disabling the exposure of the REST endpoint or is it all-or-nothing on the sense that if you have spring-data-rest, you expose all the repositories?", "author": "geoand", "createdAt": "2020-11-20T08:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3NDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYwMTQ4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r527601481", "bodyText": "By default Spring Data REST picks up almost everything everything. Then you can either disable separate repositories using the annotations that I've mentioned above or change the detection strategy in application properties (all, public, public or annotated (default), annotated).\nI think we should add a similar configuration option too. But we could do it as a separate feature and add it to the rest-data-panache too. For now the only way to disable would be with an annotation.", "author": "gytis", "createdAt": "2020-11-20T10:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3NDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0OTY0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r527649647", "bodyText": "Okay. Let's address the configuration in a follow-up PR", "author": "geoand", "createdAt": "2020-11-20T12:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3NDk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3NjU1NA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r526976554", "bodyText": "We'll also need this test added to the GH Actions config", "author": "geoand", "createdAt": "2020-11-19T15:28:10Z", "path": "integration-tests/spring-data-rest/pom.xml", "diffHunk": "@@ -0,0 +1,168 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "originalCommit": "ae590b3d105a12b23b83f265bf112f1b492bd15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3OTQ3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r526979475", "bodyText": "I'd like to have a comment on this method describing what steps it performs and why they are needed", "author": "geoand", "createdAt": "2020-11-19T15:31:50Z", "path": "extensions/spring-data-rest/deployment/src/main/java/io/quarkus/spring/data/rest/deployment/SpringDataRestProcessor.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package io.quarkus.spring.data.rest.deployment;\n+\n+import static io.quarkus.deployment.Feature.SPRING_DATA_REST;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.springframework.data.jpa.repository.JpaRepository;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.PagingAndSortingRepository;\n+\n+import io.quarkus.arc.deployment.GeneratedBeanBuildItem;\n+import io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.rest.data.panache.deployment.ResourceMetadata;\n+import io.quarkus.rest.data.panache.deployment.RestDataResourceBuildItem;\n+import io.quarkus.rest.data.panache.deployment.properties.ResourcePropertiesBuildItem;\n+import io.quarkus.spring.data.rest.deployment.crud.CrudMethodsImplementor;\n+import io.quarkus.spring.data.rest.deployment.crud.CrudPropertiesProvider;\n+import io.quarkus.spring.data.rest.deployment.paging.PagingAndSortingMethodsImplementor;\n+import io.quarkus.spring.data.rest.deployment.paging.PagingAndSortingPropertiesProvider;\n+\n+class SpringDataRestProcessor {\n+\n+    private static final DotName CRUD_REPOSITORY_INTERFACE = DotName.createSimple(CrudRepository.class.getName());\n+\n+    private static final DotName PAGING_AND_SORTING_REPOSITORY_INTERFACE = DotName\n+            .createSimple(PagingAndSortingRepository.class.getName());\n+\n+    private static final DotName JPA_REPOSITORY_INTERFACE = DotName.createSimple(JpaRepository.class.getName());\n+\n+    private static final List<DotName> EXCLUDED_INTERFACES = Arrays.asList(\n+            CRUD_REPOSITORY_INTERFACE,\n+            PAGING_AND_SORTING_REPOSITORY_INTERFACE,\n+            JPA_REPOSITORY_INTERFACE);\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(SPRING_DATA_REST);\n+    }\n+\n+    @BuildStep\n+    void registerCrudRepositories(CombinedIndexBuildItem indexBuildItem,\n+            BuildProducer<GeneratedBeanBuildItem> implementationsProducer,\n+            BuildProducer<RestDataResourceBuildItem> restDataResourceProducer,\n+            BuildProducer<ResourcePropertiesBuildItem> resourcePropertiesProducer,\n+            BuildProducer<UnremovableBeanBuildItem> unremovableBeansProducer) {\n+        IndexView index = indexBuildItem.getIndex();\n+\n+        implementResources(implementationsProducer, restDataResourceProducer, resourcePropertiesProducer,\n+                unremovableBeansProducer, new CrudMethodsImplementor(index), new CrudPropertiesProvider(index),\n+                getRepositoriesToImplement(index, CRUD_REPOSITORY_INTERFACE));\n+    }\n+\n+    @BuildStep\n+    void registerPagingAndSortingRepositories(CombinedIndexBuildItem indexBuildItem,\n+            BuildProducer<GeneratedBeanBuildItem> implementationsProducer,\n+            BuildProducer<RestDataResourceBuildItem> restDataResourceProducer,\n+            BuildProducer<ResourcePropertiesBuildItem> resourcePropertiesProducer,\n+            BuildProducer<UnremovableBeanBuildItem> unremovableBeansProducer) {\n+        IndexView index = indexBuildItem.getIndex();\n+\n+        implementResources(implementationsProducer, restDataResourceProducer, resourcePropertiesProducer,\n+                unremovableBeansProducer, new PagingAndSortingMethodsImplementor(index),\n+                new PagingAndSortingPropertiesProvider(index),\n+                getRepositoriesToImplement(index, PAGING_AND_SORTING_REPOSITORY_INTERFACE, JPA_REPOSITORY_INTERFACE));\n+    }\n+\n+    private void implementResources(BuildProducer<GeneratedBeanBuildItem> implementationsProducer,", "originalCommit": "ae590b3d105a12b23b83f265bf112f1b492bd15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6b8eed65557cae0b876622cce32f9181ac3f4302", "url": "https://github.com/quarkusio/quarkus/commit/6b8eed65557cae0b876622cce32f9181ac3f4302", "message": "Spring Data REST", "committedDate": "2020-11-20T08:48:14Z", "type": "forcePushed"}, {"oid": "fe0fc4d17ef7bc18890f38bd7ca604c7a875f062", "url": "https://github.com/quarkusio/quarkus/commit/fe0fc4d17ef7bc18890f38bd7ca604c7a875f062", "message": "Spring Data REST", "committedDate": "2020-11-20T09:13:34Z", "type": "forcePushed"}, {"oid": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "url": "https://github.com/quarkusio/quarkus/commit/889f9d30fe3ec32b3bee32439e0d866d4981e45f", "message": "Spring Data REST", "committedDate": "2020-11-20T13:24:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxOTYyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528619627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n          \n          \n            \n            While users are encouraged to use REST Data with Panache for the REST data access endpoints generation,", "author": "gsmet", "createdAt": "2020-11-23T10:58:17Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxOTcyMw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528619723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n          \n          \n            \n            Quarkus provides a compatibility layer for Spring Data REST in the form of the `spring-data-rest` extension.", "author": "gsmet", "createdAt": "2020-11-23T10:58:28Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxOTk1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528619951", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This command generates a Maven project with a `spring-data-rest` extension.\n          \n          \n            \n            This command generates a Maven project with the `spring-data-rest` extension.", "author": "gsmet", "createdAt": "2020-11-23T10:58:54Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMDY3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528620676", "bodyText": "I think you should mention the other extensions here too. Especially since you mention Jackson/JSON-B later.", "author": "gsmet", "createdAt": "2020-11-23T11:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxOTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMDE4OA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528620188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n          \n          \n            \n            For the tests you will also need REST Assured. Add it to the `pom.xml`:", "author": "gsmet", "createdAt": "2020-11-23T10:59:21Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMTIxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528621219", "bodyText": "Just remove this, it will generate a warning if you don't have the initial-size set.", "author": "gsmet", "createdAt": "2020-11-23T11:01:06Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMTYyNg==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528621626", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In a typical Spring Data fashion create a repository like so:\n          \n          \n            \n            In a typical Spring Data fashion, create a repository like so:", "author": "gsmet", "createdAt": "2020-11-23T11:01:51Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMjA0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528622049", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n          \n          \n            \n            The `spring-data-jpa` extension will generate an implementation for this repository. Then the `spring-data-rest` extension will generate a REST CRUD resource for it.", "author": "gsmet", "createdAt": "2020-11-23T11:02:33Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMjE3OA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528622178", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The test can be easily run by issuing: `./mvnw test`\n          \n          \n            \n            The test can be easily run by issuing: `./mvnw test`.", "author": "gsmet", "createdAt": "2020-11-23T11:02:50Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMjMzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528622339", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ./mvnw compile quarkus:dev\n          \n          \n            \n            ./mvnw quarkus:dev", "author": "gsmet", "createdAt": "2020-11-23T11:03:07Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMjc0OA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528622748", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can of course create a native executable following the instructions of the link:building-native-image[this] guide.\n          \n          \n            \n            You can of course create a native executable following the instructions of the link:building-native-image[Building native executables] guide.", "author": "gsmet", "createdAt": "2020-11-23T11:03:58Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+== Run the application as a native binary\n+\n+You can of course create a native executable following the instructions of the link:building-native-image[this] guide.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMjk2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528622963", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The following sections described the most important supported features of Spring Data REST.\n          \n          \n            \n            The following sections describe the most important supported features of Spring Data REST.", "author": "gsmet", "createdAt": "2020-11-23T11:04:20Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+== Run the application as a native binary\n+\n+You can of course create a native executable following the instructions of the link:building-native-image[this] guide.\n+\n+== Supported Spring Data REST functionalities\n+\n+Quarkus currently supports a subset of Spring Data REST features, namely the most useful and most commonly used features.\n+\n+=== What is supported\n+\n+The following sections described the most important supported features of Spring Data REST.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzMwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528623305", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The former is used by default, but it is highly recommended to specify which one do you prefer with an `Accept` header.\n          \n          \n            \n            The former is used by default, but it is highly recommended to specify which one you prefer with an `Accept` header.", "author": "gsmet", "createdAt": "2020-11-23T11:04:55Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+== Run the application as a native binary\n+\n+You can of course create a native executable following the instructions of the link:building-native-image[this] guide.\n+\n+== Supported Spring Data REST functionalities\n+\n+Quarkus currently supports a subset of Spring Data REST features, namely the most useful and most commonly used features.\n+\n+=== What is supported\n+\n+The following sections described the most important supported features of Spring Data REST.\n+\n+==== Automatic REST endpoint generation\n+\n+Interfaces that extend any of the following Spring Data repositories get automatically generated REST endpoints:\n+\n+* `org.springframework.data.repository.CrudRepository`\n+* `org.springframework.data.repository.PagingAndSortingRepository`\n+* `org.springframework.data.jpa.repository.JpaRepository`\n+\n+Endpoints generated from the above repositories expose five common REST operations:\n+\n+* `GET /fruits` - lists all entities or returns a page if `PagingAndSortingRepository` or `JpaRepository` is used.\n+* `GET /fruits/:id` - returns an entity by ID.\n+* `POST /fruits` - creates a new entity.\n+* `PUT /fruits/:id` - updates an existing entity or creates a new one with a specified ID (if allowed by the entity definition).\n+* `DELETE /fruits/:id` - deletes an entity by ID.\n+\n+There are two supported data types: `application/json` and `application/hal+json`.\n+The former is used by default, but it is highly recommended to specify which one do you prefer with an `Accept` header.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzQ4OA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528623488", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `PagingAndSortingRepository` allows `spring-data-rest` extension to access data in chunks.\n          \n          \n            \n            `PagingAndSortingRepository` allows the `spring-data-rest` extension to access data in chunks.", "author": "gsmet", "createdAt": "2020-11-23T11:05:14Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+== Run the application as a native binary\n+\n+You can of course create a native executable following the instructions of the link:building-native-image[this] guide.\n+\n+== Supported Spring Data REST functionalities\n+\n+Quarkus currently supports a subset of Spring Data REST features, namely the most useful and most commonly used features.\n+\n+=== What is supported\n+\n+The following sections described the most important supported features of Spring Data REST.\n+\n+==== Automatic REST endpoint generation\n+\n+Interfaces that extend any of the following Spring Data repositories get automatically generated REST endpoints:\n+\n+* `org.springframework.data.repository.CrudRepository`\n+* `org.springframework.data.repository.PagingAndSortingRepository`\n+* `org.springframework.data.jpa.repository.JpaRepository`\n+\n+Endpoints generated from the above repositories expose five common REST operations:\n+\n+* `GET /fruits` - lists all entities or returns a page if `PagingAndSortingRepository` or `JpaRepository` is used.\n+* `GET /fruits/:id` - returns an entity by ID.\n+* `POST /fruits` - creates a new entity.\n+* `PUT /fruits/:id` - updates an existing entity or creates a new one with a specified ID (if allowed by the entity definition).\n+* `DELETE /fruits/:id` - deletes an entity by ID.\n+\n+There are two supported data types: `application/json` and `application/hal+json`.\n+The former is used by default, but it is highly recommended to specify which one do you prefer with an `Accept` header.\n+\n+==== Exposing many entities\n+\n+If a database contains many entities, it might not be a great idea to return them all at once.\n+`PagingAndSortingRepository` allows `spring-data-rest` extension to access data in chunks.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzgxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528623815", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `spring-data-rest` extension supports the `exported` and `path` attributes of these annotations.\n          \n          \n            \n            The `spring-data-rest` extension supports the `exported` and `path` attributes of these annotations.", "author": "gsmet", "createdAt": "2020-11-23T11:05:52Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+== Run the application as a native binary\n+\n+You can of course create a native executable following the instructions of the link:building-native-image[this] guide.\n+\n+== Supported Spring Data REST functionalities\n+\n+Quarkus currently supports a subset of Spring Data REST features, namely the most useful and most commonly used features.\n+\n+=== What is supported\n+\n+The following sections described the most important supported features of Spring Data REST.\n+\n+==== Automatic REST endpoint generation\n+\n+Interfaces that extend any of the following Spring Data repositories get automatically generated REST endpoints:\n+\n+* `org.springframework.data.repository.CrudRepository`\n+* `org.springframework.data.repository.PagingAndSortingRepository`\n+* `org.springframework.data.jpa.repository.JpaRepository`\n+\n+Endpoints generated from the above repositories expose five common REST operations:\n+\n+* `GET /fruits` - lists all entities or returns a page if `PagingAndSortingRepository` or `JpaRepository` is used.\n+* `GET /fruits/:id` - returns an entity by ID.\n+* `POST /fruits` - creates a new entity.\n+* `PUT /fruits/:id` - updates an existing entity or creates a new one with a specified ID (if allowed by the entity definition).\n+* `DELETE /fruits/:id` - deletes an entity by ID.\n+\n+There are two supported data types: `application/json` and `application/hal+json`.\n+The former is used by default, but it is highly recommended to specify which one do you prefer with an `Accept` header.\n+\n+==== Exposing many entities\n+\n+If a database contains many entities, it might not be a great idea to return them all at once.\n+`PagingAndSortingRepository` allows `spring-data-rest` extension to access data in chunks.\n+\n+Replace the `CrudRepository` with `PagingAndSortingRepository` in the `FruitsRepository`:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.PagingAndSortingRepository;\n+\n+public interface FruitsRepository extends PagingAndSortingRepository<Fruit, Long> {\n+}\n+----\n+\n+Now the `GET /fruits` will accept three new query parameters: `sort`, `page` and `size`.\n+\n+|===\n+| Query parameter | Description | Default value | Example values\n+\n+| `sort`\n+| Sorts the entities that are returned by the list operation\n+| \"\"\n+| `?sort=name` (ascending name), `?sort=name,-color` (ascending name and descending color)\n+\n+| `page`\n+| Zero indexed page number. Invalid value is interpreted as 0.\n+| 0\n+| 0, 11, 100\n+\n+| `size`\n+| Page size. Minimal accepted value is 1. Any lower value is interpreted as 1.\n+| 20\n+| 1, 11, 100\n+|===\n+\n+For paged responses, `spring-data-rest` also returns a set of link headers that can be used to access other pages: first, previous, next and last.\n+\n+==== Fine tuning endpoints generation\n+\n+This allows user to specify which methods should be exposed and what path should be used to access them.\n+Spring Data REST provides two annotations that can be used: `@RepositoryRestResource` and `@RestResource`.\n+`spring-data-rest` extension supports the `exported` and `path` attributes of these annotations.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzkxMw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528623913", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Assume for example that fruits repository should be accessible by a `/my-fruits` path and only allow `GET` operation.\n          \n          \n            \n            Assume for example that the Fruits repository should be accessible by a `/my-fruits` path and only allow `GET` operations.", "author": "gsmet", "createdAt": "2020-11-23T11:06:04Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+== Run the application as a native binary\n+\n+You can of course create a native executable following the instructions of the link:building-native-image[this] guide.\n+\n+== Supported Spring Data REST functionalities\n+\n+Quarkus currently supports a subset of Spring Data REST features, namely the most useful and most commonly used features.\n+\n+=== What is supported\n+\n+The following sections described the most important supported features of Spring Data REST.\n+\n+==== Automatic REST endpoint generation\n+\n+Interfaces that extend any of the following Spring Data repositories get automatically generated REST endpoints:\n+\n+* `org.springframework.data.repository.CrudRepository`\n+* `org.springframework.data.repository.PagingAndSortingRepository`\n+* `org.springframework.data.jpa.repository.JpaRepository`\n+\n+Endpoints generated from the above repositories expose five common REST operations:\n+\n+* `GET /fruits` - lists all entities or returns a page if `PagingAndSortingRepository` or `JpaRepository` is used.\n+* `GET /fruits/:id` - returns an entity by ID.\n+* `POST /fruits` - creates a new entity.\n+* `PUT /fruits/:id` - updates an existing entity or creates a new one with a specified ID (if allowed by the entity definition).\n+* `DELETE /fruits/:id` - deletes an entity by ID.\n+\n+There are two supported data types: `application/json` and `application/hal+json`.\n+The former is used by default, but it is highly recommended to specify which one do you prefer with an `Accept` header.\n+\n+==== Exposing many entities\n+\n+If a database contains many entities, it might not be a great idea to return them all at once.\n+`PagingAndSortingRepository` allows `spring-data-rest` extension to access data in chunks.\n+\n+Replace the `CrudRepository` with `PagingAndSortingRepository` in the `FruitsRepository`:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.PagingAndSortingRepository;\n+\n+public interface FruitsRepository extends PagingAndSortingRepository<Fruit, Long> {\n+}\n+----\n+\n+Now the `GET /fruits` will accept three new query parameters: `sort`, `page` and `size`.\n+\n+|===\n+| Query parameter | Description | Default value | Example values\n+\n+| `sort`\n+| Sorts the entities that are returned by the list operation\n+| \"\"\n+| `?sort=name` (ascending name), `?sort=name,-color` (ascending name and descending color)\n+\n+| `page`\n+| Zero indexed page number. Invalid value is interpreted as 0.\n+| 0\n+| 0, 11, 100\n+\n+| `size`\n+| Page size. Minimal accepted value is 1. Any lower value is interpreted as 1.\n+| 20\n+| 1, 11, 100\n+|===\n+\n+For paged responses, `spring-data-rest` also returns a set of link headers that can be used to access other pages: first, previous, next and last.\n+\n+==== Fine tuning endpoints generation\n+\n+This allows user to specify which methods should be exposed and what path should be used to access them.\n+Spring Data REST provides two annotations that can be used: `@RepositoryRestResource` and `@RestResource`.\n+`spring-data-rest` extension supports the `exported` and `path` attributes of these annotations.\n+\n+Assume for example that fruits repository should be accessible by a `/my-fruits` path and only allow `GET` operation.", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNDM3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528624379", "bodyText": "This guide should be added as a link in all the other guides.", "author": "gsmet", "createdAt": "2020-11-23T11:06:55Z", "path": "docs/src/main/asciidoc/spring-data-rest.adoc", "diffHunk": "@@ -0,0 +1,441 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Extension for Spring Data REST\n+\n+include::./attributes.adoc[]\n+:extension-status: experimental\n+\n+Whiles users are encouraged to use a REST Data with Panache for the REST data access endpoints generation,\n+Quarkus provides a compatibility layer for Spring Data REST in a form of `spring-data-rest` extension.\n+\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `spring-data-rest-quickstart` {quickstarts-tree-url}/spring-data-rest-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,bash,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=spring-data-rest-quickstart \\\n+    -Dextensions=\"spring-data-rest,resteasy-jackson,quarkus-jdbc-postgresql\"\n+cd spring-data-rest-quickstart\n+----\n+\n+This command generates a Maven project with a `spring-data-rest` extension.\n+\n+If you already have your Quarkus project configured, you can add the `spring-data-rest` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"spring-data-rest\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-spring-data-rest</artifactId>\n+</dependency>\n+----\n+\n+For the tests you will also need a `rest-assured` dependency. Add it to the `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.rest-assured</groupId>\n+    <artifactId>rest-assured</artifactId>\n+    <scope>test</scope>\n+</dependency>\n+----\n+\n+Note: both `resteasy-jackson` and `resteasy-jsonb` are supported and can be interchanged.\n+\n+== Define the Entity\n+\n+Throughout the course of this guide, the following JPA Entity will be used:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+\n+@Entity\n+public class Fruit {\n+\n+    @Id\n+    @GeneratedValue\n+    private Long id;\n+\n+    private String name;\n+\n+    private String color;\n+\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, String color) {\n+        this.name = name;\n+        this.color = color;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+}\n+----\n+\n+\n+== Configure database access properties\n+\n+Add the following properties to `application.properties` to configure access to a local PostgreSQL instance.\n+\n+[source,properties]\n+----\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql:quarkus_test\n+quarkus.datasource.jdbc.max-size=8\n+quarkus.datasource.jdbc.min-size=2\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+This configuration assumes that PostgreSQL will be running locally.\n+\n+A very easy way to accomplish that is by using the following Docker command:\n+\n+[source,bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5\n+----\n+\n+If you plan on using a different setup, please change your `application.properties` accordingly.\n+\n+== Prepare the data\n+\n+To make it easier to showcase some capabilities of Spring Data REST on Quarkus, some test data should be inserted into the database\n+by adding the following content to a new file named `src/main/resources/import.sql`:\n+\n+[source,sql]\n+----\n+INSERT INTO fruit(id, name, color) VALUES (1, 'Cherry', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (2, 'Apple', 'Red');\n+INSERT INTO fruit(id, name, color) VALUES (3, 'Banana', 'Yellow');\n+INSERT INTO fruit(id, name, color) VALUES (4, 'Avocado', 'Green');\n+INSERT INTO fruit(id, name, color) VALUES (5, 'Strawberry', 'Red');\n+----\n+\n+Hibernate ORM will execute these queries on application startup.\n+\n+== Define the repository\n+\n+It is now time to define the repository that will be used to access `Fruit`.\n+In a typical Spring Data fashion create a repository like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+}\n+----\n+\n+The `FruitsRepository` above extends Spring Data's `org.springframework.data.repository.CrudRepository` which means that all of the latter's methods are\n+available to `FruitsRepository`.\n+\n+`spring-data-jpa` will generate an implementation for this repository. Then `spring-data-rest` will generate a REST CRUD resource for it.\n+\n+== Update the test\n+\n+To test the capabilities of `FruitsRepository` proceed to update the content of `FruitsRepositoryTest` to:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.core.IsNot.not;\n+\n+@QuarkusTest\n+class FruitsRepositoryTest {\n+\n+    @Test\n+    void testListAllFruits() {\n+        //List all, should have all 3 fruits the database has initially:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        containsString(\"Cherry\"),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Delete the Cherry:\n+        given()\n+                .when().delete(\"/fruits/1\")\n+                .then()\n+                .statusCode(204);\n+\n+        //List all, cherry should be missing now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Banana\")\n+                );\n+\n+        //Create a new Fruit\n+        given()\n+                .contentType(\"application/json\")\n+                .accept(\"application/json\")\n+                .body(\"{\\\"name\\\": \\\"Orange\\\", \\\"color\\\": \\\"Orange\\\"}\")\n+                .when().post(\"/fruits\")\n+                .then()\n+                .statusCode(201)\n+                .body(containsString(\"Orange\"))\n+                .body(\"id\", notNullValue())\n+                .extract().body().jsonPath().getString(\"id\");\n+\n+        //List all, Orange should be present now:\n+        given()\n+                .accept(\"application/json\")\n+                .when().get(\"/fruits\")\n+                .then()\n+                .statusCode(200)\n+                .body(\n+                        not(containsString(\"Cherry\")),\n+                        containsString(\"Apple\"),\n+                        containsString(\"Orange\")\n+                );\n+    }\n+}\n+\n+----\n+\n+The test can be easily run by issuing: `./mvnw test`\n+\n+== Package and run the application\n+\n+Quarkus dev mode works with the defined repositories just like with any other Quarkus extension, greatly enhancing your productivity during the dev cycle.\n+The application can be started in dev mode as usual using:\n+\n+[source, bash]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+== Run the application as a native binary\n+\n+You can of course create a native executable following the instructions of the link:building-native-image[this] guide.\n+\n+== Supported Spring Data REST functionalities\n+\n+Quarkus currently supports a subset of Spring Data REST features, namely the most useful and most commonly used features.\n+\n+=== What is supported\n+\n+The following sections described the most important supported features of Spring Data REST.\n+\n+==== Automatic REST endpoint generation\n+\n+Interfaces that extend any of the following Spring Data repositories get automatically generated REST endpoints:\n+\n+* `org.springframework.data.repository.CrudRepository`\n+* `org.springframework.data.repository.PagingAndSortingRepository`\n+* `org.springframework.data.jpa.repository.JpaRepository`\n+\n+Endpoints generated from the above repositories expose five common REST operations:\n+\n+* `GET /fruits` - lists all entities or returns a page if `PagingAndSortingRepository` or `JpaRepository` is used.\n+* `GET /fruits/:id` - returns an entity by ID.\n+* `POST /fruits` - creates a new entity.\n+* `PUT /fruits/:id` - updates an existing entity or creates a new one with a specified ID (if allowed by the entity definition).\n+* `DELETE /fruits/:id` - deletes an entity by ID.\n+\n+There are two supported data types: `application/json` and `application/hal+json`.\n+The former is used by default, but it is highly recommended to specify which one do you prefer with an `Accept` header.\n+\n+==== Exposing many entities\n+\n+If a database contains many entities, it might not be a great idea to return them all at once.\n+`PagingAndSortingRepository` allows `spring-data-rest` extension to access data in chunks.\n+\n+Replace the `CrudRepository` with `PagingAndSortingRepository` in the `FruitsRepository`:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import org.springframework.data.repository.PagingAndSortingRepository;\n+\n+public interface FruitsRepository extends PagingAndSortingRepository<Fruit, Long> {\n+}\n+----\n+\n+Now the `GET /fruits` will accept three new query parameters: `sort`, `page` and `size`.\n+\n+|===\n+| Query parameter | Description | Default value | Example values\n+\n+| `sort`\n+| Sorts the entities that are returned by the list operation\n+| \"\"\n+| `?sort=name` (ascending name), `?sort=name,-color` (ascending name and descending color)\n+\n+| `page`\n+| Zero indexed page number. Invalid value is interpreted as 0.\n+| 0\n+| 0, 11, 100\n+\n+| `size`\n+| Page size. Minimal accepted value is 1. Any lower value is interpreted as 1.\n+| 20\n+| 1, 11, 100\n+|===\n+\n+For paged responses, `spring-data-rest` also returns a set of link headers that can be used to access other pages: first, previous, next and last.\n+\n+==== Fine tuning endpoints generation\n+\n+This allows user to specify which methods should be exposed and what path should be used to access them.\n+Spring Data REST provides two annotations that can be used: `@RepositoryRestResource` and `@RestResource`.\n+`spring-data-rest` extension supports the `exported` and `path` attributes of these annotations.\n+\n+Assume for example that fruits repository should be accessible by a `/my-fruits` path and only allow `GET` operation.\n+In such a case, `FruitsRepository` would look like so:\n+\n+[source,java]\n+----\n+package org.acme.spring.data.rest;\n+\n+import java.util.Optional;\n+\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.rest.core.annotation.RepositoryRestResource;\n+import org.springframework.data.rest.core.annotation.RestResource;\n+\n+@RepositoryRestResource(exported = false, path = \"/my-fruits\")\n+public interface FruitsRepository extends CrudRepository<Fruit, Long> {\n+\n+    @RestResource(exported = true)\n+    Optional<Fruit> findById(Long id);\n+\n+    @RestResource(exported = true)\n+    Iterable<Fruit> findAll();\n+}\n+----\n+\n+`spring-data-rest` uses only a subset of the repository methods for data access.\n+It is important to annotate the correct method in order to customize its REST endpoint:\n+\n+|===\n+|REST operation |CrudRepository |PagingAndSortingRepository and JpaRepository\n+\n+|Get by ID\n+|`Optional<T> findById(ID id)`\n+|`Optional<T> findById(ID id)`\n+\n+|List\n+|`Iterable<T> findAll()`\n+|`Page<T> findAll(Pageable pageable)`\n+\n+|Create\n+|`<S extends T> S save(S entity)`\n+|`<S extends T> S save(S entity)`\n+\n+|Update\n+|`<S extends T> S save(S entity)`\n+|`<S extends T> S save(S entity)`\n+\n+|Delete\n+|`void deleteById(ID id)`\n+|`void deleteById(ID id)`\n+|===\n+\n+=== What is currently unsupported\n+\n+* Only the repository methods listed above are supported. No other standard or custom methods are supported.\n+* Only the `exposed` and `path` REST resource annotation properties are supported.\n+\n+== Important Technical Note\n+\n+Please note that the Spring support in Quarkus does not start a Spring Application Context nor are any Spring infrastructure classes run.\n+Spring classes and annotations are only used for reading metadata and / or are used as user code method return types or parameter types.\n+\n+== More Spring guides\n+\n+Quarkus has more Spring compatibility features. See the following guides for more details:\n+\n+* link:spring-data-jpa[Quarkus - Extension for Spring Data JPA]\n+* link:spring-di[Quarkus - Extension for Spring DI]\n+* link:spring-web[Quarkus - Extension for Spring Web]\n+* link:spring-security[Quarkus - Extension for Spring Security]\n+* link:spring-cloud-config-client[Quarkus - Reading properties from Spring Cloud Config Server]\n+* link:spring-boot-properties[Quarkus - Extension for Spring Boot properties]\n+* link:spring-cache[Quarkus - Extension for Spring Cache]\n+* link:spring-scheduled[Quarkus - Extension for Spring Scheduled]", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNDY3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528624677", "bodyText": "Please format pom files with 4 spaces (valid for all pom files in this PR).", "author": "gsmet", "createdAt": "2020-11-23T11:07:29Z", "path": "extensions/spring-data-rest/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,72 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <artifactId>quarkus-spring-data-rest-parent</artifactId>\n+    <groupId>io.quarkus</groupId>\n+    <version>999-SNAPSHOT</version>\n+    <relativePath>../pom.xml</relativePath>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>quarkus-spring-data-rest-deployment</artifactId>\n+  <name>Quarkus - Spring - Data REST - Deployment</name>", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTE2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528625161", "bodyText": "So I understand this shouldn't be merged for now?", "author": "gsmet", "createdAt": "2020-11-23T11:08:25Z", "path": "extensions/spring-data-rest/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,97 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <artifactId>quarkus-spring-data-rest-parent</artifactId>\n+    <groupId>io.quarkus</groupId>\n+    <version>999-SNAPSHOT</version>\n+    <relativePath>../pom.xml</relativePath>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>quarkus-spring-data-rest</artifactId>\n+  <name>Quarkus - Spring - Data REST - Runtime</name>\n+  <description>Generate JAX-RS resources for a Spring Data application</description>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-rest-data-panache</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-spring-data-jpa</artifactId>\n+    </dependency>\n+    <dependency><!-- TODO create Quarkus Spring Data REST API jar -->", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYzMzU1MA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528633550", "bodyText": "@geoand what do you think? Should be merge it with a regular Spring dependency and replace it once we have a new minimal one? Or should we postpone merging until we have a minimal dependency ready?\nWe replaced them later in the other Spring extensions, no?", "author": "gytis", "createdAt": "2020-11-23T11:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY0MTA4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528641089", "bodyText": "Oh shoot...\nI didn't notice this, although I did think about it at some point... My bad!\nWe should not include the upstream spring-data-rest-core . As now none of our Spring deps depend on upstream spring stuff, we should keep up with that pattern and create a new miminal jar before merging this.", "author": "geoand", "createdAt": "2020-11-23T11:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY0Mzg1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528643852", "bodyText": "Sure, I'll create a new minimal JAR for Spring Data REST then.", "author": "gytis", "createdAt": "2020-11-23T11:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTMwMA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528625300", "bodyText": "This should be in the BOM once you have created the artifact.", "author": "gsmet", "createdAt": "2020-11-23T11:08:41Z", "path": "extensions/spring-data-rest/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,97 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <artifactId>quarkus-spring-data-rest-parent</artifactId>\n+    <groupId>io.quarkus</groupId>\n+    <version>999-SNAPSHOT</version>\n+    <relativePath>../pom.xml</relativePath>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>quarkus-spring-data-rest</artifactId>\n+  <name>Quarkus - Spring - Data REST - Runtime</name>\n+  <description>Generate JAX-RS resources for a Spring Data application</description>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-rest-data-panache</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-spring-data-jpa</artifactId>\n+    </dependency>\n+    <dependency><!-- TODO create Quarkus Spring Data REST API jar -->\n+      <groupId>org.springframework.data</groupId>\n+      <artifactId>spring-data-rest-core</artifactId>\n+      <version>3.3.0.RELEASE</version>", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTQ5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528625497", "bodyText": "you should add data and rest as keywords.", "author": "gsmet", "createdAt": "2020-11-23T11:09:04Z", "path": "extensions/spring-data-rest/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,11 @@\n+---\n+name: \"Quarkus Extension for Spring Data REST\"\n+metadata:\n+  keywords:\n+    - \"spring-data\"\n+    - \"spring-data-rest\"\n+    - \"spring\"", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528626239", "bodyText": "Given we are taking the sort parameter from the REST URL, can we check it's not sensitive to SQL injections?", "author": "gsmet", "createdAt": "2020-11-23T11:10:24Z", "path": "extensions/spring-data-rest/deployment/src/main/java/io/quarkus/spring/data/rest/deployment/paging/PagingAndSortingMethodsImplementor.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package io.quarkus.spring.data.rest.deployment.paging;\n+\n+import static io.quarkus.gizmo.FieldDescriptor.of;\n+import static io.quarkus.gizmo.MethodDescriptor.ofMethod;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.jboss.jandex.IndexView;\n+import org.springframework.data.domain.PageRequest;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+import org.springframework.data.repository.PagingAndSortingRepository;\n+\n+import io.quarkus.gizmo.AssignableResultHandle;\n+import io.quarkus.gizmo.BranchResult;\n+import io.quarkus.gizmo.BytecodeCreator;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.rest.data.panache.deployment.Constants;\n+import io.quarkus.spring.data.rest.deployment.crud.CrudMethodsImplementor;\n+\n+public class PagingAndSortingMethodsImplementor extends CrudMethodsImplementor {\n+\n+    public static final MethodDescriptor LIST_PAGED = ofMethod(PagingAndSortingRepository.class, \"findAll\",\n+            org.springframework.data.domain.Page.class, Pageable.class);\n+\n+    private static final Class<?> PANACHE_PAGE = io.quarkus.panache.common.Page.class;\n+\n+    private static final Class<?> PANACHE_SORT = io.quarkus.panache.common.Sort.class;\n+\n+    private static final Class<?> PANACHE_COLUMN = io.quarkus.panache.common.Sort.Column.class;\n+\n+    private static final Class<?> PANACHE_DIRECTION = io.quarkus.panache.common.Sort.Direction.class;\n+\n+    public PagingAndSortingMethodsImplementor(IndexView index) {\n+        super(index);\n+    }\n+\n+    public void implementList(ClassCreator classCreator, String repositoryInterface) {\n+        MethodCreator methodCreator = classCreator.getMethodCreator(\"list\", List.class, Page.class,\n+                io.quarkus.panache.common.Sort.class);\n+\n+        ResultHandle page = methodCreator.getMethodParam(0);\n+        ResultHandle sort = methodCreator.getMethodParam(1);\n+        ResultHandle pageable = toPageable(methodCreator, page, sort);", "originalCommit": "889f9d30fe3ec32b3bee32439e0d866d4981e45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYzNTgwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528635809", "bodyText": "Here page and sort are already io.quarkus.panache.common.Page and io.quarkus.panache.common.Sort. They're instantiated from the query parameters by rest-data-panache extension.\nThis extension (same as Hibernate and MongoDB Data REST alternatives) handle only data access logic. JAX-RS resource is handled in the same way for all of them by the rest-data-panache.", "author": "gytis", "createdAt": "2020-11-23T11:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYzNzcyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528637729", "bodyText": "I disagree with that.\nYour extension makes it visible and applies absolutely no checks on the content coming from the URL. It's different when it's just Panache API, people can do their own checks.\nSo we need to check it's not sensitive to SQL injections otherwise you have a big security risk.", "author": "gsmet", "createdAt": "2020-11-23T11:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY0MzE3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r528643179", "bodyText": "I'm not saying that it shouldn't be checked. I'm saying that this is not the place to do it. This extension does not handle the JAX-RS logic. It only implements user defined interface that extends https://github.com/quarkusio/quarkus/blob/master/extensions/panache/rest-data-panache/runtime/src/main/java/io/quarkus/rest/data/panache/RestDataResource.java.\nrest-data-panache generates the JAX-RS resource and then calls spring-data-rest generated method for data access. So these two page and sort parameters are already instances of io.quarkus.panache.common.Page and io.quarkus.panache.common.Sort.\nIf we need to add query parameter validation we need to add it here https://github.com/quarkusio/quarkus/blob/master/extensions/panache/rest-data-panache/deployment/src/main/java/io/quarkus/rest/data/panache/deployment/methods/ListMethodImplementor.java#L104. However, wouldn't Panache Query builder escape all the query parameters automatically?", "author": "gytis", "createdAt": "2020-11-23T11:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ4MjQ2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r529482463", "bodyText": "I'm not saying that it shouldn't be checked. I'm saying that this is not the place to do it.\n\nWell, I haven't really reviewed the other extension so I see it now for this one. I still think this should carefully be addressed.\n\nHowever, wouldn't Panache Query builder escape all the query parameters automatically?\n\nIt didn't a while ago. That's why I think we should check if it's safe or not.", "author": "gsmet", "createdAt": "2020-11-24T11:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NTk3MA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r530975970", "bodyText": "@FroMage maybe you know how unsafe it is to pass arbitrary parameters to the Panache Sort object? Are they somehow parsed down the line by Panache or Hibernate/Mongo? If this is unsafe, do you have a recommendation on what type of validation is needed?\nIn any case, I don't think that this issue should holdup this PR. If the validation has to be added, it will be added to the rest-data-panache extension.", "author": "gytis", "createdAt": "2020-11-26T11:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0MzA1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r531043053", "bodyText": "It's indeed unsafe because we end up generating an HQL query in PanacheJpaUtil.toOrderBy (not sure about Mongo but probably it is too).\nIndeed the check really belongs in the REST layer as you say, especially wrt error handling. As to what you can check, here's what HQL allows:\norderByClause\n// todo (6.0) : null precedence\n\t: ORDER BY sortSpecification (COMMA sortSpecification)*\n\t;\n\nsortSpecification\n\t: expression collationSpecification? orderingSpecification?\n\t;\n\ncollationSpecification\n\t:\tCOLLATE collateName\n\t;\n\ncollateName\n\t:\tdotIdentifierSequence\n\t;\n\norderingSpecification\n\t:\tASC\n\t|\tDESC\n\t;\n\nexpression is particularly nasty because it's pretty much a free for all.\nOTOH if your REST API specifies that the supported set of sort options is limited, then you can probably limit it to:\nIDENTIFIER\n\t:\t('a'..'z'|'A'..'Z'|'_'|'$'|'\\u0080'..'\\ufffe')('a'..'z'|'A'..'Z'|'_'|'$'|'0'..'9'|'\\u0080'..'\\ufffe')*\n\nHTH :)", "author": "FroMage", "createdAt": "2020-11-26T13:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0MzUyOA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r531043528", "bodyText": "BTW, all this is from the panacheql extension, you have the lexer and parser files there with all the info you need ;)", "author": "FroMage", "createdAt": "2020-11-26T13:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0OTc2OA==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r531049768", "bodyText": "Thanks @FroMage, this is very helpful. I'll add a query parameter validator to the rest-data-extension and will raise a new PR with it.", "author": "gytis", "createdAt": "2020-11-26T14:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU3MzU5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13373#discussion_r531573596", "bodyText": "I've created a separate pull request to add a sort parameter validation #13514", "author": "gytis", "createdAt": "2020-11-27T12:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNjIzOQ=="}], "type": "inlineReview"}, {"oid": "9be3e429cfc243a8dedf75e7b4893274c85bfb91", "url": "https://github.com/quarkusio/quarkus/commit/9be3e429cfc243a8dedf75e7b4893274c85bfb91", "message": "Spring Data REST", "committedDate": "2020-11-23T11:16:23Z", "type": "forcePushed"}, {"oid": "1e017ceded29572b48e81f6f8017432f34bb32bc", "url": "https://github.com/quarkusio/quarkus/commit/1e017ceded29572b48e81f6f8017432f34bb32bc", "message": "Spring Data REST", "committedDate": "2020-11-23T11:30:23Z", "type": "forcePushed"}, {"oid": "16a005d4d71bceb5c278dfb2e7bb56a5b2a0786e", "url": "https://github.com/quarkusio/quarkus/commit/16a005d4d71bceb5c278dfb2e7bb56a5b2a0786e", "message": "Spring Data REST", "committedDate": "2020-11-23T11:48:19Z", "type": "forcePushed"}, {"oid": "7579a10a241377f6272c3dbacd19947c58706d3c", "url": "https://github.com/quarkusio/quarkus/commit/7579a10a241377f6272c3dbacd19947c58706d3c", "message": "Spring Data REST", "committedDate": "2020-11-24T08:27:58Z", "type": "forcePushed"}, {"oid": "ed784d14eeec22e66429e543f60bcd50bc67dde4", "url": "https://github.com/quarkusio/quarkus/commit/ed784d14eeec22e66429e543f60bcd50bc67dde4", "message": "Spring Data REST", "committedDate": "2020-11-25T11:14:45Z", "type": "forcePushed"}, {"oid": "e29b9178b71951f0111915966ad9cdb89bbc0d39", "url": "https://github.com/quarkusio/quarkus/commit/e29b9178b71951f0111915966ad9cdb89bbc0d39", "message": "Spring Data REST", "committedDate": "2020-12-09T11:06:14Z", "type": "forcePushed"}, {"oid": "d6d52008f8dfef26017652d7237987763035ef9e", "url": "https://github.com/quarkusio/quarkus/commit/d6d52008f8dfef26017652d7237987763035ef9e", "message": "Spring Data REST", "committedDate": "2020-12-10T12:36:12Z", "type": "commit"}, {"oid": "d6d52008f8dfef26017652d7237987763035ef9e", "url": "https://github.com/quarkusio/quarkus/commit/d6d52008f8dfef26017652d7237987763035ef9e", "message": "Spring Data REST", "committedDate": "2020-12-10T12:36:12Z", "type": "forcePushed"}]}