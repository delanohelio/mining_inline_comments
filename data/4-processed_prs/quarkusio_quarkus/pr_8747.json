{"pr_number": 8747, "pr_title": "Add Vault Database Guide", "pr_createdAt": "2020-04-22T13:37:00Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8747", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5Mjc3NA==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412992774", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and security :\n          \n          \n            \n            and security:", "author": "gsmet", "createdAt": "2020-04-22T13:41:26Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5MjkzNA==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412992934", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Property fetched from the KV Secret Engine using the Vault MP Config Source\n          \n          \n            \n            * Property fetched from the KV Secret Engine using the Vault MicroProfile Config Source", "author": "gsmet", "createdAt": "2020-04-22T13:41:39Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :\n+\n+* Property fetched from the KV Secret Engine using the Vault MP Config Source", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5Mzk5OA==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412993998", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Vault MP Config Source\n          \n          \n            \n            == Vault MicroProfile Config Source", "author": "gsmet", "createdAt": "2020-04-22T13:42:54Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :\n+\n+* Property fetched from the KV Secret Engine using the Vault MP Config Source\n+* Quarkus Credentials Provider\n+* Vault Dynamic DB Credentials\n+\n+This guide aims at providing examples for each of those approaches. We will reuse the application implemented\n+in the {base-guide} and enhance it with a simple persistence use case.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 20 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+\n+=== Application\n+\n+We assume the {base-guide} application has been developed, a Vault container is running, and the root token is known.\n+In this section we are going to start a PostgreSQL database, and add a persistence service in the application.\n+\n+Add the _Hibernate_ and _PostgreSQL_ extensions to the application:\n+----\n+mvn quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-hibernate-orm,io.quarkus:quarkus-jdbc-postgresql\"\n+----\n+\n+Create a simple service:\n+\n+[source, java]\n+----\n+@ApplicationScoped\n+public class SantaClausService {\n+\n+    @Inject\n+    EntityManager em;\n+\n+    @Transactional\n+    public List<Gift> getGifts() {\n+        return (List<Gift>) em.createQuery(\"select g from Gift g\").getResultList();\n+    }\n+}\n+----\n+\n+With its `Gift` entity:\n+\n+[source, java]\n+----\n+@Entity\n+public class Gift {\n+\n+    private Long id;\n+    private String name;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator=\"giftSeq\")\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+----\n+\n+Finally, add a new endpoint in `GreetingResource`:\n+\n+[source, java]\n+----\n+@Inject\n+SantaClausService santaClausService;\n+\n+@GET\n+@Path(\"/gift-count\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public int geGiftCount() {\n+    return santaClausService.getGifts().size();\n+}\n+----\n+\n+Start a PostgreSQL database:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name postgres-quarkus-hibernate -e POSTGRES_USER=sarah -e POSTGRES_PASSWORD=connor -e POSTGRES_DB=mydatabase -p 5432:5432 postgres:10.5\n+----\n+\n+Now we are ready to configure Vault and Quarkus to be able to connect to this database from the application.\n+\n+== Vault MP Config Source", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5NDYwMg==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412994602", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            that requires a secret information in the configuration (i.e. not just _Agroal)_.\n          \n          \n            \n            that requires a secret information in the configuration (i.e. not just _Agroal_).", "author": "gsmet", "createdAt": "2020-04-22T13:43:40Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :\n+\n+* Property fetched from the KV Secret Engine using the Vault MP Config Source\n+* Quarkus Credentials Provider\n+* Vault Dynamic DB Credentials\n+\n+This guide aims at providing examples for each of those approaches. We will reuse the application implemented\n+in the {base-guide} and enhance it with a simple persistence use case.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 20 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+\n+=== Application\n+\n+We assume the {base-guide} application has been developed, a Vault container is running, and the root token is known.\n+In this section we are going to start a PostgreSQL database, and add a persistence service in the application.\n+\n+Add the _Hibernate_ and _PostgreSQL_ extensions to the application:\n+----\n+mvn quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-hibernate-orm,io.quarkus:quarkus-jdbc-postgresql\"\n+----\n+\n+Create a simple service:\n+\n+[source, java]\n+----\n+@ApplicationScoped\n+public class SantaClausService {\n+\n+    @Inject\n+    EntityManager em;\n+\n+    @Transactional\n+    public List<Gift> getGifts() {\n+        return (List<Gift>) em.createQuery(\"select g from Gift g\").getResultList();\n+    }\n+}\n+----\n+\n+With its `Gift` entity:\n+\n+[source, java]\n+----\n+@Entity\n+public class Gift {\n+\n+    private Long id;\n+    private String name;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator=\"giftSeq\")\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+----\n+\n+Finally, add a new endpoint in `GreetingResource`:\n+\n+[source, java]\n+----\n+@Inject\n+SantaClausService santaClausService;\n+\n+@GET\n+@Path(\"/gift-count\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public int geGiftCount() {\n+    return santaClausService.getGifts().size();\n+}\n+----\n+\n+Start a PostgreSQL database:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name postgres-quarkus-hibernate -e POSTGRES_USER=sarah -e POSTGRES_PASSWORD=connor -e POSTGRES_DB=mydatabase -p 5432:5432 postgres:10.5\n+----\n+\n+Now we are ready to configure Vault and Quarkus to be able to connect to this database from the application.\n+\n+== Vault MP Config Source\n+\n+The simplest approach is to write the database password in the KV secret engine under the path that is\n+fetched from the Vault MicroProfile Config Source.\n+\n+Open a new shell, `docker exec` in the Vault container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+export VAULT_TOKEN={root-token}\n+----\n+\n+Add a `dbpassword` property in the `config` path of the KV secret engine, beside the original `a-private-key`\n+property:\n+[source, shell]\n+----\n+vault kv put secret/myapps/vault-quickstart/config a-private-key=123456 dbpassword=connor\n+----\n+\n+Add the following configuration in Quarkus to use the value of property `dbpassword` as our database password:\n+[source, properties]\n+----\n+# configure your datasource\n+quarkus.datasource.db-kind = postgresql\n+quarkus.datasource.username = sarah\n+quarkus.datasource.password = ${dbpassword}\n+quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n+\n+# drop and create the database at startup (use `update` to only update the schema)\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+Compile and start the application:\n+[source, shell]\n+----\n+./mvnw package\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Test it with the `gift-count` endpoint:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/hello/gift-count\n+----\n+\n+You should see:\n+\n+[source, shell]\n+----\n+0\n+----\n+\n+This approach is certainly the simplest of all. It has also the big advantage of working with any subsystem\n+that requires a secret information in the configuration (i.e. not just _Agroal)_.", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5NDg1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412994859", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            vault has been updated with the new password.\n          \n          \n            \n            Vault has been updated with the new password.", "author": "gsmet", "createdAt": "2020-04-22T13:43:58Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :\n+\n+* Property fetched from the KV Secret Engine using the Vault MP Config Source\n+* Quarkus Credentials Provider\n+* Vault Dynamic DB Credentials\n+\n+This guide aims at providing examples for each of those approaches. We will reuse the application implemented\n+in the {base-guide} and enhance it with a simple persistence use case.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 20 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+\n+=== Application\n+\n+We assume the {base-guide} application has been developed, a Vault container is running, and the root token is known.\n+In this section we are going to start a PostgreSQL database, and add a persistence service in the application.\n+\n+Add the _Hibernate_ and _PostgreSQL_ extensions to the application:\n+----\n+mvn quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-hibernate-orm,io.quarkus:quarkus-jdbc-postgresql\"\n+----\n+\n+Create a simple service:\n+\n+[source, java]\n+----\n+@ApplicationScoped\n+public class SantaClausService {\n+\n+    @Inject\n+    EntityManager em;\n+\n+    @Transactional\n+    public List<Gift> getGifts() {\n+        return (List<Gift>) em.createQuery(\"select g from Gift g\").getResultList();\n+    }\n+}\n+----\n+\n+With its `Gift` entity:\n+\n+[source, java]\n+----\n+@Entity\n+public class Gift {\n+\n+    private Long id;\n+    private String name;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator=\"giftSeq\")\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+----\n+\n+Finally, add a new endpoint in `GreetingResource`:\n+\n+[source, java]\n+----\n+@Inject\n+SantaClausService santaClausService;\n+\n+@GET\n+@Path(\"/gift-count\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public int geGiftCount() {\n+    return santaClausService.getGifts().size();\n+}\n+----\n+\n+Start a PostgreSQL database:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name postgres-quarkus-hibernate -e POSTGRES_USER=sarah -e POSTGRES_PASSWORD=connor -e POSTGRES_DB=mydatabase -p 5432:5432 postgres:10.5\n+----\n+\n+Now we are ready to configure Vault and Quarkus to be able to connect to this database from the application.\n+\n+== Vault MP Config Source\n+\n+The simplest approach is to write the database password in the KV secret engine under the path that is\n+fetched from the Vault MicroProfile Config Source.\n+\n+Open a new shell, `docker exec` in the Vault container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+export VAULT_TOKEN={root-token}\n+----\n+\n+Add a `dbpassword` property in the `config` path of the KV secret engine, beside the original `a-private-key`\n+property:\n+[source, shell]\n+----\n+vault kv put secret/myapps/vault-quickstart/config a-private-key=123456 dbpassword=connor\n+----\n+\n+Add the following configuration in Quarkus to use the value of property `dbpassword` as our database password:\n+[source, properties]\n+----\n+# configure your datasource\n+quarkus.datasource.db-kind = postgresql\n+quarkus.datasource.username = sarah\n+quarkus.datasource.password = ${dbpassword}\n+quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n+\n+# drop and create the database at startup (use `update` to only update the schema)\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+Compile and start the application:\n+[source, shell]\n+----\n+./mvnw package\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Test it with the `gift-count` endpoint:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/hello/gift-count\n+----\n+\n+You should see:\n+\n+[source, shell]\n+----\n+0\n+----\n+\n+This approach is certainly the simplest of all. It has also the big advantage of working with any subsystem\n+that requires a secret information in the configuration (i.e. not just _Agroal)_.\n+The only drawback is that the password will never be fetched again from Vault after the initial property loading.\n+This means that if the db password was changed while running, the application would have to be restarted after\n+vault has been updated with the new password.", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5NTE3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412995176", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            component between the `agroal` datasource and Vault. The additional configuration required is small, and it\n          \n          \n            \n            component between the Agroal datasource and Vault. The additional configuration required is small, and it", "author": "gsmet", "createdAt": "2020-04-22T13:44:18Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :\n+\n+* Property fetched from the KV Secret Engine using the Vault MP Config Source\n+* Quarkus Credentials Provider\n+* Vault Dynamic DB Credentials\n+\n+This guide aims at providing examples for each of those approaches. We will reuse the application implemented\n+in the {base-guide} and enhance it with a simple persistence use case.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 20 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+\n+=== Application\n+\n+We assume the {base-guide} application has been developed, a Vault container is running, and the root token is known.\n+In this section we are going to start a PostgreSQL database, and add a persistence service in the application.\n+\n+Add the _Hibernate_ and _PostgreSQL_ extensions to the application:\n+----\n+mvn quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-hibernate-orm,io.quarkus:quarkus-jdbc-postgresql\"\n+----\n+\n+Create a simple service:\n+\n+[source, java]\n+----\n+@ApplicationScoped\n+public class SantaClausService {\n+\n+    @Inject\n+    EntityManager em;\n+\n+    @Transactional\n+    public List<Gift> getGifts() {\n+        return (List<Gift>) em.createQuery(\"select g from Gift g\").getResultList();\n+    }\n+}\n+----\n+\n+With its `Gift` entity:\n+\n+[source, java]\n+----\n+@Entity\n+public class Gift {\n+\n+    private Long id;\n+    private String name;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator=\"giftSeq\")\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+----\n+\n+Finally, add a new endpoint in `GreetingResource`:\n+\n+[source, java]\n+----\n+@Inject\n+SantaClausService santaClausService;\n+\n+@GET\n+@Path(\"/gift-count\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public int geGiftCount() {\n+    return santaClausService.getGifts().size();\n+}\n+----\n+\n+Start a PostgreSQL database:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name postgres-quarkus-hibernate -e POSTGRES_USER=sarah -e POSTGRES_PASSWORD=connor -e POSTGRES_DB=mydatabase -p 5432:5432 postgres:10.5\n+----\n+\n+Now we are ready to configure Vault and Quarkus to be able to connect to this database from the application.\n+\n+== Vault MP Config Source\n+\n+The simplest approach is to write the database password in the KV secret engine under the path that is\n+fetched from the Vault MicroProfile Config Source.\n+\n+Open a new shell, `docker exec` in the Vault container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+export VAULT_TOKEN={root-token}\n+----\n+\n+Add a `dbpassword` property in the `config` path of the KV secret engine, beside the original `a-private-key`\n+property:\n+[source, shell]\n+----\n+vault kv put secret/myapps/vault-quickstart/config a-private-key=123456 dbpassword=connor\n+----\n+\n+Add the following configuration in Quarkus to use the value of property `dbpassword` as our database password:\n+[source, properties]\n+----\n+# configure your datasource\n+quarkus.datasource.db-kind = postgresql\n+quarkus.datasource.username = sarah\n+quarkus.datasource.password = ${dbpassword}\n+quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n+\n+# drop and create the database at startup (use `update` to only update the schema)\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+Compile and start the application:\n+[source, shell]\n+----\n+./mvnw package\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Test it with the `gift-count` endpoint:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/hello/gift-count\n+----\n+\n+You should see:\n+\n+[source, shell]\n+----\n+0\n+----\n+\n+This approach is certainly the simplest of all. It has also the big advantage of working with any subsystem\n+that requires a secret information in the configuration (i.e. not just _Agroal)_.\n+The only drawback is that the password will never be fetched again from Vault after the initial property loading.\n+This means that if the db password was changed while running, the application would have to be restarted after\n+vault has been updated with the new password.\n+This contrasts with the credentials provider approach, which fetches the password from Vault every time a connection\n+creation is attempted.\n+\n+== Credentials Provider\n+\n+In this approach we introduce a new abstraction called the _Credentials Provider_ that acts as an intermediary\n+component between the `agroal` datasource and Vault. The additional configuration required is small, and it", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5NTM5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412995396", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            is has the major advantage of handling gracefuly database password change while the application is running,\n          \n          \n            \n            has the major advantage of handling gracefully database password change while the application is running,", "author": "gsmet", "createdAt": "2020-04-22T13:44:35Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :\n+\n+* Property fetched from the KV Secret Engine using the Vault MP Config Source\n+* Quarkus Credentials Provider\n+* Vault Dynamic DB Credentials\n+\n+This guide aims at providing examples for each of those approaches. We will reuse the application implemented\n+in the {base-guide} and enhance it with a simple persistence use case.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 20 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+\n+=== Application\n+\n+We assume the {base-guide} application has been developed, a Vault container is running, and the root token is known.\n+In this section we are going to start a PostgreSQL database, and add a persistence service in the application.\n+\n+Add the _Hibernate_ and _PostgreSQL_ extensions to the application:\n+----\n+mvn quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-hibernate-orm,io.quarkus:quarkus-jdbc-postgresql\"\n+----\n+\n+Create a simple service:\n+\n+[source, java]\n+----\n+@ApplicationScoped\n+public class SantaClausService {\n+\n+    @Inject\n+    EntityManager em;\n+\n+    @Transactional\n+    public List<Gift> getGifts() {\n+        return (List<Gift>) em.createQuery(\"select g from Gift g\").getResultList();\n+    }\n+}\n+----\n+\n+With its `Gift` entity:\n+\n+[source, java]\n+----\n+@Entity\n+public class Gift {\n+\n+    private Long id;\n+    private String name;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator=\"giftSeq\")\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+----\n+\n+Finally, add a new endpoint in `GreetingResource`:\n+\n+[source, java]\n+----\n+@Inject\n+SantaClausService santaClausService;\n+\n+@GET\n+@Path(\"/gift-count\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public int geGiftCount() {\n+    return santaClausService.getGifts().size();\n+}\n+----\n+\n+Start a PostgreSQL database:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name postgres-quarkus-hibernate -e POSTGRES_USER=sarah -e POSTGRES_PASSWORD=connor -e POSTGRES_DB=mydatabase -p 5432:5432 postgres:10.5\n+----\n+\n+Now we are ready to configure Vault and Quarkus to be able to connect to this database from the application.\n+\n+== Vault MP Config Source\n+\n+The simplest approach is to write the database password in the KV secret engine under the path that is\n+fetched from the Vault MicroProfile Config Source.\n+\n+Open a new shell, `docker exec` in the Vault container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+export VAULT_TOKEN={root-token}\n+----\n+\n+Add a `dbpassword` property in the `config` path of the KV secret engine, beside the original `a-private-key`\n+property:\n+[source, shell]\n+----\n+vault kv put secret/myapps/vault-quickstart/config a-private-key=123456 dbpassword=connor\n+----\n+\n+Add the following configuration in Quarkus to use the value of property `dbpassword` as our database password:\n+[source, properties]\n+----\n+# configure your datasource\n+quarkus.datasource.db-kind = postgresql\n+quarkus.datasource.username = sarah\n+quarkus.datasource.password = ${dbpassword}\n+quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n+\n+# drop and create the database at startup (use `update` to only update the schema)\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+Compile and start the application:\n+[source, shell]\n+----\n+./mvnw package\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Test it with the `gift-count` endpoint:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/hello/gift-count\n+----\n+\n+You should see:\n+\n+[source, shell]\n+----\n+0\n+----\n+\n+This approach is certainly the simplest of all. It has also the big advantage of working with any subsystem\n+that requires a secret information in the configuration (i.e. not just _Agroal)_.\n+The only drawback is that the password will never be fetched again from Vault after the initial property loading.\n+This means that if the db password was changed while running, the application would have to be restarted after\n+vault has been updated with the new password.\n+This contrasts with the credentials provider approach, which fetches the password from Vault every time a connection\n+creation is attempted.\n+\n+== Credentials Provider\n+\n+In this approach we introduce a new abstraction called the _Credentials Provider_ that acts as an intermediary\n+component between the `agroal` datasource and Vault. The additional configuration required is small, and it\n+is has the major advantage of handling gracefuly database password change while the application is running,", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5NzUyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412997525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            for simplicity we disabled _tls_ between Vault and the PostgreSQL database):\n          \n          \n            \n            for simplicity we disabled _TLS_ between Vault and the PostgreSQL database):", "author": "gsmet", "createdAt": "2020-04-22T13:47:07Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :\n+\n+* Property fetched from the KV Secret Engine using the Vault MP Config Source\n+* Quarkus Credentials Provider\n+* Vault Dynamic DB Credentials\n+\n+This guide aims at providing examples for each of those approaches. We will reuse the application implemented\n+in the {base-guide} and enhance it with a simple persistence use case.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 20 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+\n+=== Application\n+\n+We assume the {base-guide} application has been developed, a Vault container is running, and the root token is known.\n+In this section we are going to start a PostgreSQL database, and add a persistence service in the application.\n+\n+Add the _Hibernate_ and _PostgreSQL_ extensions to the application:\n+----\n+mvn quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-hibernate-orm,io.quarkus:quarkus-jdbc-postgresql\"\n+----\n+\n+Create a simple service:\n+\n+[source, java]\n+----\n+@ApplicationScoped\n+public class SantaClausService {\n+\n+    @Inject\n+    EntityManager em;\n+\n+    @Transactional\n+    public List<Gift> getGifts() {\n+        return (List<Gift>) em.createQuery(\"select g from Gift g\").getResultList();\n+    }\n+}\n+----\n+\n+With its `Gift` entity:\n+\n+[source, java]\n+----\n+@Entity\n+public class Gift {\n+\n+    private Long id;\n+    private String name;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator=\"giftSeq\")\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+----\n+\n+Finally, add a new endpoint in `GreetingResource`:\n+\n+[source, java]\n+----\n+@Inject\n+SantaClausService santaClausService;\n+\n+@GET\n+@Path(\"/gift-count\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public int geGiftCount() {\n+    return santaClausService.getGifts().size();\n+}\n+----\n+\n+Start a PostgreSQL database:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name postgres-quarkus-hibernate -e POSTGRES_USER=sarah -e POSTGRES_PASSWORD=connor -e POSTGRES_DB=mydatabase -p 5432:5432 postgres:10.5\n+----\n+\n+Now we are ready to configure Vault and Quarkus to be able to connect to this database from the application.\n+\n+== Vault MP Config Source\n+\n+The simplest approach is to write the database password in the KV secret engine under the path that is\n+fetched from the Vault MicroProfile Config Source.\n+\n+Open a new shell, `docker exec` in the Vault container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+export VAULT_TOKEN={root-token}\n+----\n+\n+Add a `dbpassword` property in the `config` path of the KV secret engine, beside the original `a-private-key`\n+property:\n+[source, shell]\n+----\n+vault kv put secret/myapps/vault-quickstart/config a-private-key=123456 dbpassword=connor\n+----\n+\n+Add the following configuration in Quarkus to use the value of property `dbpassword` as our database password:\n+[source, properties]\n+----\n+# configure your datasource\n+quarkus.datasource.db-kind = postgresql\n+quarkus.datasource.username = sarah\n+quarkus.datasource.password = ${dbpassword}\n+quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n+\n+# drop and create the database at startup (use `update` to only update the schema)\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+Compile and start the application:\n+[source, shell]\n+----\n+./mvnw package\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Test it with the `gift-count` endpoint:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/hello/gift-count\n+----\n+\n+You should see:\n+\n+[source, shell]\n+----\n+0\n+----\n+\n+This approach is certainly the simplest of all. It has also the big advantage of working with any subsystem\n+that requires a secret information in the configuration (i.e. not just _Agroal)_.\n+The only drawback is that the password will never be fetched again from Vault after the initial property loading.\n+This means that if the db password was changed while running, the application would have to be restarted after\n+vault has been updated with the new password.\n+This contrasts with the credentials provider approach, which fetches the password from Vault every time a connection\n+creation is attempted.\n+\n+== Credentials Provider\n+\n+In this approach we introduce a new abstraction called the _Credentials Provider_ that acts as an intermediary\n+component between the `agroal` datasource and Vault. The additional configuration required is small, and it\n+is has the major advantage of handling gracefuly database password change while the application is running,\n+without any restart. Since all new connections go through the _Credentials Provider_ to fetch their password,\n+we make sure we have a fresh value every time.\n+\n+Create a new path (different than the `config` path) in Vault where the database password will be added:\n+\n+[source, shell, subs=attributes+]\n+----\n+vault kv put secret/myapps/vault-quickstart/db password=connor\n+----\n+\n+Since we allowed read access on `secret/myapps/vault-quickstart/*` subpaths in the policy, there is nothing else\n+we have to do to allow the application to read it.\n+\n+When fetching credentials from Vault that are intended to be used by the Agroal connection pool, we need\n+first to create a named Vault credentials provider in the {config-file}:\n+\n+[source, properties]\n+----\n+quarkus.vault.credentials-provider.mydatabase.kv-path=myapps/vault-quickstart/db\n+----\n+\n+This defines a credentials provider `mydatabase` that will fetch the password from key `password`\n+at path `myapps/vault-quickstart/db`.\n+\n+The credentials provider can now be used in the datasource configuration, in place of the `password`\n+property:\n+\n+[source, properties]\n+----\n+# configure your datasource\n+quarkus.datasource.db-kind = postgresql\n+quarkus.datasource.username = sarah\n+quarkus.datasource.credentials-provider = mydatabase\n+quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n+----\n+\n+Recompile, start and test the `gift-count` endpoint. You should see `0` again.\n+\n+== Dynamic Database Credentials\n+\n+The two previous approaches work well and are very popular. However they rely on a well known user configured\n+in the application (i.e. the database user), and the security comes from the confidentiality of the password.\n+If the password was stolen, we would have to change it in the database and in Vault. Regulary rotating passwords\n+is actually a very good practice to limit (in time) the impact of getting the password stolen.\n+\n+A more sophisticated approach consists in letting Vault create and retire database accounts on a regular basis.\n+This is supported in Vault with the https://www.vaultproject.io/docs/secrets/databases[Database secret engine]. A number\n+of databases are supported, such as https://www.vaultproject.io/docs/secrets/databases/postgresql[PostgreSQL].\n+\n+First we need to enable the `database` secret engine, configure the `postgresql-database-plugin` and create\n+the database role `mydbrole` (replace `10.0.0.3` by the actual host that is running the PostgreSQL container;\n+for simplicity we disabled _tls_ between Vault and the PostgreSQL database):", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5ODAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/8747#discussion_r412998024", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            user. Since a user will be created everytime the applications starts, database objects will be created\n          \n          \n            \n            user. Since a user will be created every time the applications starts, database objects will be created", "author": "gsmet", "createdAt": "2020-04-22T13:47:43Z", "path": "docs/src/main/asciidoc/vault-datasource.adoc", "diffHunk": "@@ -0,0 +1,328 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using HashiCorp Vault with Databases\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:config-file: application.properties\n+\n+The most common use case when working with Vault is to keep confidential the database connection credentials.\n+There are several approaches that are supported in Quarkus, with different levels of sophistication\n+and security :\n+\n+* Property fetched from the KV Secret Engine using the Vault MP Config Source\n+* Quarkus Credentials Provider\n+* Vault Dynamic DB Credentials\n+\n+This guide aims at providing examples for each of those approaches. We will reuse the application implemented\n+in the {base-guide} and enhance it with a simple persistence use case.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 20 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+\n+=== Application\n+\n+We assume the {base-guide} application has been developed, a Vault container is running, and the root token is known.\n+In this section we are going to start a PostgreSQL database, and add a persistence service in the application.\n+\n+Add the _Hibernate_ and _PostgreSQL_ extensions to the application:\n+----\n+mvn quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-hibernate-orm,io.quarkus:quarkus-jdbc-postgresql\"\n+----\n+\n+Create a simple service:\n+\n+[source, java]\n+----\n+@ApplicationScoped\n+public class SantaClausService {\n+\n+    @Inject\n+    EntityManager em;\n+\n+    @Transactional\n+    public List<Gift> getGifts() {\n+        return (List<Gift>) em.createQuery(\"select g from Gift g\").getResultList();\n+    }\n+}\n+----\n+\n+With its `Gift` entity:\n+\n+[source, java]\n+----\n+@Entity\n+public class Gift {\n+\n+    private Long id;\n+    private String name;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator=\"giftSeq\")\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}\n+----\n+\n+Finally, add a new endpoint in `GreetingResource`:\n+\n+[source, java]\n+----\n+@Inject\n+SantaClausService santaClausService;\n+\n+@GET\n+@Path(\"/gift-count\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public int geGiftCount() {\n+    return santaClausService.getGifts().size();\n+}\n+----\n+\n+Start a PostgreSQL database:\n+\n+[source, shell]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name postgres-quarkus-hibernate -e POSTGRES_USER=sarah -e POSTGRES_PASSWORD=connor -e POSTGRES_DB=mydatabase -p 5432:5432 postgres:10.5\n+----\n+\n+Now we are ready to configure Vault and Quarkus to be able to connect to this database from the application.\n+\n+== Vault MP Config Source\n+\n+The simplest approach is to write the database password in the KV secret engine under the path that is\n+fetched from the Vault MicroProfile Config Source.\n+\n+Open a new shell, `docker exec` in the Vault container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+export VAULT_TOKEN={root-token}\n+----\n+\n+Add a `dbpassword` property in the `config` path of the KV secret engine, beside the original `a-private-key`\n+property:\n+[source, shell]\n+----\n+vault kv put secret/myapps/vault-quickstart/config a-private-key=123456 dbpassword=connor\n+----\n+\n+Add the following configuration in Quarkus to use the value of property `dbpassword` as our database password:\n+[source, properties]\n+----\n+# configure your datasource\n+quarkus.datasource.db-kind = postgresql\n+quarkus.datasource.username = sarah\n+quarkus.datasource.password = ${dbpassword}\n+quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n+\n+# drop and create the database at startup (use `update` to only update the schema)\n+quarkus.hibernate-orm.database.generation=drop-and-create\n+----\n+\n+Compile and start the application:\n+[source, shell]\n+----\n+./mvnw package\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Test it with the `gift-count` endpoint:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/hello/gift-count\n+----\n+\n+You should see:\n+\n+[source, shell]\n+----\n+0\n+----\n+\n+This approach is certainly the simplest of all. It has also the big advantage of working with any subsystem\n+that requires a secret information in the configuration (i.e. not just _Agroal)_.\n+The only drawback is that the password will never be fetched again from Vault after the initial property loading.\n+This means that if the db password was changed while running, the application would have to be restarted after\n+vault has been updated with the new password.\n+This contrasts with the credentials provider approach, which fetches the password from Vault every time a connection\n+creation is attempted.\n+\n+== Credentials Provider\n+\n+In this approach we introduce a new abstraction called the _Credentials Provider_ that acts as an intermediary\n+component between the `agroal` datasource and Vault. The additional configuration required is small, and it\n+is has the major advantage of handling gracefuly database password change while the application is running,\n+without any restart. Since all new connections go through the _Credentials Provider_ to fetch their password,\n+we make sure we have a fresh value every time.\n+\n+Create a new path (different than the `config` path) in Vault where the database password will be added:\n+\n+[source, shell, subs=attributes+]\n+----\n+vault kv put secret/myapps/vault-quickstart/db password=connor\n+----\n+\n+Since we allowed read access on `secret/myapps/vault-quickstart/*` subpaths in the policy, there is nothing else\n+we have to do to allow the application to read it.\n+\n+When fetching credentials from Vault that are intended to be used by the Agroal connection pool, we need\n+first to create a named Vault credentials provider in the {config-file}:\n+\n+[source, properties]\n+----\n+quarkus.vault.credentials-provider.mydatabase.kv-path=myapps/vault-quickstart/db\n+----\n+\n+This defines a credentials provider `mydatabase` that will fetch the password from key `password`\n+at path `myapps/vault-quickstart/db`.\n+\n+The credentials provider can now be used in the datasource configuration, in place of the `password`\n+property:\n+\n+[source, properties]\n+----\n+# configure your datasource\n+quarkus.datasource.db-kind = postgresql\n+quarkus.datasource.username = sarah\n+quarkus.datasource.credentials-provider = mydatabase\n+quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n+----\n+\n+Recompile, start and test the `gift-count` endpoint. You should see `0` again.\n+\n+== Dynamic Database Credentials\n+\n+The two previous approaches work well and are very popular. However they rely on a well known user configured\n+in the application (i.e. the database user), and the security comes from the confidentiality of the password.\n+If the password was stolen, we would have to change it in the database and in Vault. Regulary rotating passwords\n+is actually a very good practice to limit (in time) the impact of getting the password stolen.\n+\n+A more sophisticated approach consists in letting Vault create and retire database accounts on a regular basis.\n+This is supported in Vault with the https://www.vaultproject.io/docs/secrets/databases[Database secret engine]. A number\n+of databases are supported, such as https://www.vaultproject.io/docs/secrets/databases/postgresql[PostgreSQL].\n+\n+First we need to enable the `database` secret engine, configure the `postgresql-database-plugin` and create\n+the database role `mydbrole` (replace `10.0.0.3` by the actual host that is running the PostgreSQL container;\n+for simplicity we disabled _tls_ between Vault and the PostgreSQL database):\n+[source, shell, subs=attributes+]\n+----\n+vault secrets enable database\n+\n+vault write database/config/mydb \\\n+    plugin_name=postgresql-database-plugin \\\n+    allowed_roles=mydbrole \\\n+    connection_url=postgresql://{{username}}:{{password}}@10.0.0.3:5432/mydatabase?sslmode=disable \\\n+    username=sarah \\\n+    password=connor\n+\n+cat <<EOF > vault-postgres-creation.sql\n+CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';\n+GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO \"{{name}}\";\n+GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public to \"{{name}}\";\n+EOF\n+\n+vault write database/roles/mydbrole \\\n+    db_name=mydb creation_statements=@vault-postgres-creation.sql \\\n+    default_ttl=1h \\\n+    max_ttl=24h \\\n+    revocation_statements=\"ALTER ROLE \\\"{{name}}\\\" NOLOGIN;\" \\\n+    renew_statements=\"ALTER ROLE \\\"{{name}}\\\" VALID UNTIL '{{expiration}}';\"\n+----\n+\n+[NOTE]\n+====\n+For this use case, user `sarah` configured above needs to be a PostgreSQL super user with the capability\n+to create users.\n+====\n+\n+Then we need to give a read capability to the Quarkus application on path `database/creds/mydbrole`.\n+[source, shell]\n+----\n+cat <<EOF | vault policy write vault-quickstart-policy -\n+path \"secret/data/myapps/vault-quickstart/*\" {\n+  capabilities = [\"read\"]\n+}\n+path \"database/creds/mydbrole\" {\n+  capabilities = [ \"read\" ]\n+}\n+EOF\n+----\n+\n+Now that Vault knows how to create users in PostgreSQL, we juste need to change the `mydatabase` credentials\n+provider to use a `database-credentials-role`.\n+[source, properties]\n+----\n+quarkus.vault.credentials-provider.mydatabase.database-credentials-role=mydbrole\n+----\n+\n+[NOTE]\n+====\n+When using `quarkus.hibernate-orm.database.generation=drop-create`, objects get created with the applicative\n+user. Since a user will be created everytime the applications starts, database objects will be created", "originalCommit": "15a2ebc926b6a82a00647e10b6fbaa67fcd8e10a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ae62b1f99295dc8dc153e774470c13a39effa70", "url": "https://github.com/quarkusio/quarkus/commit/2ae62b1f99295dc8dc153e774470c13a39effa70", "message": "Add Vault Database Guide", "committedDate": "2020-04-22T13:59:15Z", "type": "commit"}, {"oid": "2ae62b1f99295dc8dc153e774470c13a39effa70", "url": "https://github.com/quarkusio/quarkus/commit/2ae62b1f99295dc8dc153e774470c13a39effa70", "message": "Add Vault Database Guide", "committedDate": "2020-04-22T13:59:15Z", "type": "forcePushed"}]}