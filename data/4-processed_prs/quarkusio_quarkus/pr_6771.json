{"pr_number": 6771, "pr_title": "Fix FaultTolerance perf issue related to the creation of FaultToleranceOperation", "pr_createdAt": "2020-01-24T14:55:22Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/6771", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODE2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370688166", "bodyText": "You can make the QuarkusFaultToleranceOperationProvider a @Singleton and then there is no need to use static field here. Instead, you can use Arc.container().instance(QuarkusFaultToleranceOperationProvider.class).init(Map<String,FaultToleranceOperation> ops) in the recorder.", "author": "mkouba", "createdAt": "2020-01-24T15:20:03Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/QuarkusFaultToleranceOperationProvider.java", "diffHunk": "@@ -1,22 +1,39 @@\n package io.quarkus.smallrye.faulttolerance.runtime;\n \n import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import javax.annotation.Priority;\n import javax.enterprise.context.Dependent;\n import javax.enterprise.inject.Alternative;\n \n+import org.jboss.logging.Logger;\n+\n import io.smallrye.faulttolerance.FaultToleranceOperationProvider;\n import io.smallrye.faulttolerance.config.FaultToleranceOperation;\n \n @Dependent\n @Alternative\n @Priority(1)\n public class QuarkusFaultToleranceOperationProvider implements FaultToleranceOperationProvider {\n+    private static final Logger LOG = Logger.getLogger(QuarkusFaultToleranceOperationProvider.class);\n+    static final Map<String, FaultToleranceOperation> OPERATIONS = new ConcurrentHashMap<>();", "originalCommit": "771d3f57d83e8db9342f05bcf3b15bf56a0ba277", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5MzI3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370693277", "bodyText": "OK, will do.\nAnd if I don't implements computeIfAbsent I should be able to use an HashMap directly instead of a concurrent one as the map will never be modified outside the enhancer.", "author": "loicmathieu", "createdAt": "2020-01-24T15:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NDMxMw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370694313", "bodyText": "Yep, an optimized immutable map would be a perfect fit but unfotunately there is no such impl in JDK.", "author": "mkouba", "createdAt": "2020-01-24T15:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODgzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370688835", "bodyText": "We could use Map.computeIfAbsent() if a FaultToleranceOperation is not found in the cache...", "author": "mkouba", "createdAt": "2020-01-24T15:21:21Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/QuarkusFaultToleranceOperationProvider.java", "diffHunk": "@@ -1,22 +1,39 @@\n package io.quarkus.smallrye.faulttolerance.runtime;\n \n import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import javax.annotation.Priority;\n import javax.enterprise.context.Dependent;\n import javax.enterprise.inject.Alternative;\n \n+import org.jboss.logging.Logger;\n+\n import io.smallrye.faulttolerance.FaultToleranceOperationProvider;\n import io.smallrye.faulttolerance.config.FaultToleranceOperation;\n \n @Dependent\n @Alternative\n @Priority(1)\n public class QuarkusFaultToleranceOperationProvider implements FaultToleranceOperationProvider {\n+    private static final Logger LOG = Logger.getLogger(QuarkusFaultToleranceOperationProvider.class);\n+    static final Map<String, FaultToleranceOperation> OPERATIONS = new ConcurrentHashMap<>();\n \n     @Override\n     public FaultToleranceOperation get(Class<?> beanClass, Method method) {\n+        String key = getCacheKey(beanClass, method);\n+        FaultToleranceOperation operation = OPERATIONS.get(key);\n+        return operation != null ? operation : createAtRuntime(beanClass, method, key);", "originalCommit": "771d3f57d83e8db9342f05bcf3b15bf56a0ba277", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5MjAzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370692031", "bodyText": "This was on my first impl\u00e9mentation, but as with the current one the operation should always be in the cache I don't know if it worth it.\nIt is here to catch potential bugs, and as it will be inside the hot code path I prefere to use get instead of computeIfAbsent. We could revisit it later if needed.", "author": "loicmathieu", "createdAt": "2020-01-24T15:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5MjA5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370692099", "bodyText": "My HV benchmarks taught me the hard way that using get() is faster if having the operation in the cache is the most common use case.", "author": "gsmet", "createdAt": "2020-01-24T15:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5MjU2NA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370692564", "bodyText": "+1", "author": "mkouba", "createdAt": "2020-01-24T15:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5Mzk4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370693989", "bodyText": "I remember having similar discussions on the PRs :). I say no computeIfAbsent anywhere on the hot path :)", "author": "geoand", "createdAt": "2020-01-24T15:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5NjU0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370696545", "bodyText": "Well, it depends on how many times it's invoked ;-). From my experience microbenchmarks are often tricky and the bottlenecks identified in the infra code might not be bottlenecks at all in a real app and vice versa.", "author": "mkouba", "createdAt": "2020-01-24T15:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwODczOA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370708738", "bodyText": "Well, with native image, stuff are a little different as there is no optimisation based on branch prediction (unless for paid customers using the new PGO mechanism of GraalVM). So computeIfAbsent could be more slow on native image than on JVM mode ...\nHaving said that, if I didn't saw any benchmark written with JMH that prove this I will deny it ;)\nAnyway, I switch to regular HashMap and uses get as the operation should always be present (in fact I can move to a runtime exception if not in the cache if we prefere ... like a NPE :) )", "author": "loicmathieu", "createdAt": "2020-01-24T15:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODk5OA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370688998", "bodyText": "No System.out.print please ;-)", "author": "mkouba", "createdAt": "2020-01-24T15:21:40Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/SmallryeFaultToleranceRecorder.java", "diffHunk": "@@ -66,11 +70,12 @@ public void validate(List<String> beanNames) {\n     private Set<Method> getMethodsForValidation(Class<?> beanClass) {\n         Set<Method> allMethods = new HashSet<>();\n         Class<?> currentClass = beanClass;\n-        while (!currentClass.equals(Object.class)) {\n+        System.out.println(currentClass);", "originalCommit": "771d3f57d83e8db9342f05bcf3b15bf56a0ba277", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY5MDkzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370690931", "bodyText": "Still a draft :).\nI will remove it", "author": "loicmathieu", "createdAt": "2020-01-24T15:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwODk1OA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370708958", "bodyText": "Removed", "author": "loicmathieu", "createdAt": "2020-01-24T15:59:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY4ODk5OA=="}], "type": "inlineReview"}, {"oid": "f4d9701f9d742301c9dc278dda4bf1daa263c2ab", "url": "https://github.com/quarkusio/quarkus/commit/f4d9701f9d742301c9dc278dda4bf1daa263c2ab", "message": "Use Jandex to avoid loading all beans for FT annotations", "committedDate": "2020-01-24T15:54:34Z", "type": "forcePushed"}, {"oid": "a4a53ffc832e529edb3313e0483e7a6b0d067c78", "url": "https://github.com/quarkusio/quarkus/commit/a4a53ffc832e529edb3313e0483e7a6b0d067c78", "message": "Use Jandex to avoid loading all beans for FT annotations", "committedDate": "2020-01-24T16:34:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MjI4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370952283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // gather all beans that uses FT annotations\n          \n          \n            \n                    // gather all beans that use FT annotations", "author": "gsmet", "createdAt": "2020-01-25T19:49:14Z", "path": "extensions/smallrye-fault-tolerance/deployment/src/main/java/io/quarkus/smallrye/faulttolerance/deployment/SmallRyeFaultToleranceProcessor.java", "diffHunk": "@@ -153,6 +153,27 @@ public void transform(TransformationContext context) {\n                     .setDefaultScope(DotName.createSimple(Singleton.class.getName())).build());\n             systemProperty.produce(new SystemPropertyBuildItem(\"MP_Fault_Tolerance_Metrics_Enabled\", \"false\"));\n         }\n+\n+        // gather all beans that uses FT annotations", "originalCommit": "a4a53ffc832e529edb3313e0483e7a6b0d067c78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MjMxOA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r370952318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    throw new RuntimeException(\"FT annotations should only be present on CLASS or METHOD targets\");\n          \n          \n            \n                                    throw new RuntimeException(\"MicroProfile Fault Tolerance annotations should only be present on class or method targets\");", "author": "gsmet", "createdAt": "2020-01-25T19:50:01Z", "path": "extensions/smallrye-fault-tolerance/deployment/src/main/java/io/quarkus/smallrye/faulttolerance/deployment/SmallRyeFaultToleranceProcessor.java", "diffHunk": "@@ -153,6 +153,27 @@ public void transform(TransformationContext context) {\n                     .setDefaultScope(DotName.createSimple(Singleton.class.getName())).build());\n             systemProperty.produce(new SystemPropertyBuildItem(\"MP_Fault_Tolerance_Metrics_Enabled\", \"false\"));\n         }\n+\n+        // gather all beans that uses FT annotations\n+        for (DotName ftAnno : ftAnnotations) {\n+            for (AnnotationInstance annotationInstance : index.getAnnotations(ftAnno)) {\n+                switch (annotationInstance.target().kind()) {\n+                    case CLASS: {\n+                        ClassInfo classInfo = annotationInstance.target().asClass();\n+                        ftOperations.produce(new FaultToleranceOperationBuildItem(classInfo));\n+                        break;\n+                    }\n+                    case METHOD: {\n+                        MethodInfo methodInfo = annotationInstance.target().asMethod();\n+                        ftOperations.produce(new FaultToleranceOperationBuildItem(methodInfo.declaringClass(), methodInfo));\n+                        break;\n+                    }\n+                    default:\n+                        throw new RuntimeException(\"FT annotations should only be present on CLASS or METHOD targets\");", "originalCommit": "a4a53ffc832e529edb3313e0483e7a6b0d067c78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "669bc16abc10ef1dda7732761fbb35c605825741", "url": "https://github.com/quarkusio/quarkus/commit/669bc16abc10ef1dda7732761fbb35c605825741", "message": "Use Jandex to avoid loading all beans for FT annotations", "committedDate": "2020-01-27T09:11:02Z", "type": "forcePushed"}, {"oid": "93806db1aa65622323ffcb4536fc9b23a7c2662f", "url": "https://github.com/quarkusio/quarkus/commit/93806db1aa65622323ffcb4536fc9b23a7c2662f", "message": "Use Jandex to avoid loading all beans for FT annotations", "committedDate": "2020-01-27T09:42:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4Mjc3NA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371282774", "bodyText": "We're only interested in class beans which have at least one around invoke interceptor... so something like this could slightly improve the perf: validationPhase.getContext().beans().stream().filter(BeanInfo::hasAroundInvokeInterceptors).iterator()", "author": "mkouba", "createdAt": "2020-01-27T14:49:12Z", "path": "extensions/smallrye-fault-tolerance/deployment/src/main/java/io/quarkus/smallrye/faulttolerance/deployment/SmallRyeFaultToleranceProcessor.java", "diffHunk": "@@ -187,13 +192,42 @@ public void transform(TransformationContext ctx) {\n     @BuildStep\n     // needs to be RUNTIME_INIT because we need to read MP Config\n     @Record(ExecutionTime.RUNTIME_INIT)\n-    void validateFaultToleranceAnnotations(\n-            ValidationPhaseBuildItem validationPhase, SmallryeFaultToleranceRecorder recorder) {\n-        List<String> beanNames = new ArrayList<>();\n-        for (BeanInfo bean : validationPhase.getContext().beans().classBeans()) {\n-            beanNames.add(bean.getBeanClass().toString());\n+    void validateFaultToleranceAnnotations(SmallryeFaultToleranceRecorder recorder,\n+            ValidationPhaseBuildItem validationPhase) {\n+        AnnotationStore annotationStore = validationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+        Set<String> beanNames = new HashSet<>();\n+        IndexView index = combinedIndexBuildItem.getIndex();\n+\n+        for (BeanInfo info : validationPhase.getContext().beans()) {", "originalCommit": "59cac3a4b791378e56f5eaff3b30621a52d20029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMxNzcwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371317701", "bodyText": "No possible or we will miss the annotations on interfaces (like the one for rest client)", "author": "loicmathieu", "createdAt": "2020-01-27T15:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4Mjc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4Mjg3MA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371282870", "bodyText": "Unused variable?", "author": "mkouba", "createdAt": "2020-01-27T14:49:22Z", "path": "extensions/smallrye-fault-tolerance/deployment/src/main/java/io/quarkus/smallrye/faulttolerance/deployment/SmallRyeFaultToleranceProcessor.java", "diffHunk": "@@ -187,13 +192,42 @@ public void transform(TransformationContext ctx) {\n     @BuildStep\n     // needs to be RUNTIME_INIT because we need to read MP Config\n     @Record(ExecutionTime.RUNTIME_INIT)\n-    void validateFaultToleranceAnnotations(\n-            ValidationPhaseBuildItem validationPhase, SmallryeFaultToleranceRecorder recorder) {\n-        List<String> beanNames = new ArrayList<>();\n-        for (BeanInfo bean : validationPhase.getContext().beans().classBeans()) {\n-            beanNames.add(bean.getBeanClass().toString());\n+    void validateFaultToleranceAnnotations(SmallryeFaultToleranceRecorder recorder,\n+            ValidationPhaseBuildItem validationPhase) {\n+        AnnotationStore annotationStore = validationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+        Set<String> beanNames = new HashSet<>();\n+        IndexView index = combinedIndexBuildItem.getIndex();", "originalCommit": "59cac3a4b791378e56f5eaff3b30621a52d20029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMxNzg2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371317865", "bodyText": "Yes, removed, sorry.", "author": "loicmathieu", "createdAt": "2020-01-27T15:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4Mjg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NTUyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371285529", "bodyText": "I think that using BeanArchiveIndexBuildItem would be more appropriate in this case. Also the injected fields of SmallRyeFaultToleranceProcessor should be probably turned into injected params of the SmallRyeFaultToleranceProcessor.build() build step (they're not shared so it does not make much sense to use fields). I know that it's not a subject of this PR but it would deserve a small refactoring ;-).", "author": "mkouba", "createdAt": "2020-01-27T14:53:57Z", "path": "extensions/smallrye-fault-tolerance/deployment/src/main/java/io/quarkus/smallrye/faulttolerance/deployment/SmallRyeFaultToleranceProcessor.java", "diffHunk": "@@ -187,13 +192,42 @@ public void transform(TransformationContext ctx) {\n     @BuildStep\n     // needs to be RUNTIME_INIT because we need to read MP Config\n     @Record(ExecutionTime.RUNTIME_INIT)\n-    void validateFaultToleranceAnnotations(\n-            ValidationPhaseBuildItem validationPhase, SmallryeFaultToleranceRecorder recorder) {\n-        List<String> beanNames = new ArrayList<>();\n-        for (BeanInfo bean : validationPhase.getContext().beans().classBeans()) {\n-            beanNames.add(bean.getBeanClass().toString());\n+    void validateFaultToleranceAnnotations(SmallryeFaultToleranceRecorder recorder,\n+            ValidationPhaseBuildItem validationPhase) {\n+        AnnotationStore annotationStore = validationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+        Set<String> beanNames = new HashSet<>();\n+        IndexView index = combinedIndexBuildItem.getIndex();\n+\n+        for (BeanInfo info : validationPhase.getContext().beans()) {\n+            if (hasFTAnnotations(annotationStore, info.getImplClazz())) {\n+                beanNames.add(info.getBeanClass().toString());\n+            }\n         }\n-        recorder.validate(beanNames);\n+\n+        recorder.createFaultToleranceOperation(beanNames);\n+    }\n+\n+    private boolean hasFTAnnotations(AnnotationStore annotationStore, ClassInfo info) {\n+        // first check annotations on type\n+        if (annotationStore.hasAnyAnnotation(info, FT_ANNOTATIONS)) {\n+            return true;\n+        }\n+\n+        // then check on the methods\n+        for (MethodInfo method : info.methods()) {\n+            if (annotationStore.hasAnyAnnotation(method, FT_ANNOTATIONS)) {\n+                return true;\n+            }\n+        }\n+\n+        // then check on the parent\n+        DotName parentClassName = info.superName();\n+        ClassInfo parentClassInfo = combinedIndexBuildItem.getIndex().getClassByName(parentClassName);", "originalCommit": "59cac3a4b791378e56f5eaff3b30621a52d20029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMxODI2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371318262", "bodyText": "Switch to BeanArchiveIndexBuildItem.\nRefactor to inject everything via parameters.", "author": "loicmathieu", "createdAt": "2020-01-27T15:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NTkzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371285935", "bodyText": "You can reuse io.quarkus.arc.processor.DotNames.OBJECT.", "author": "mkouba", "createdAt": "2020-01-27T14:54:36Z", "path": "extensions/smallrye-fault-tolerance/deployment/src/main/java/io/quarkus/smallrye/faulttolerance/deployment/SmallRyeFaultToleranceProcessor.java", "diffHunk": "@@ -187,13 +192,42 @@ public void transform(TransformationContext ctx) {\n     @BuildStep\n     // needs to be RUNTIME_INIT because we need to read MP Config\n     @Record(ExecutionTime.RUNTIME_INIT)\n-    void validateFaultToleranceAnnotations(\n-            ValidationPhaseBuildItem validationPhase, SmallryeFaultToleranceRecorder recorder) {\n-        List<String> beanNames = new ArrayList<>();\n-        for (BeanInfo bean : validationPhase.getContext().beans().classBeans()) {\n-            beanNames.add(bean.getBeanClass().toString());\n+    void validateFaultToleranceAnnotations(SmallryeFaultToleranceRecorder recorder,\n+            ValidationPhaseBuildItem validationPhase) {\n+        AnnotationStore annotationStore = validationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+        Set<String> beanNames = new HashSet<>();\n+        IndexView index = combinedIndexBuildItem.getIndex();\n+\n+        for (BeanInfo info : validationPhase.getContext().beans()) {\n+            if (hasFTAnnotations(annotationStore, info.getImplClazz())) {\n+                beanNames.add(info.getBeanClass().toString());\n+            }\n         }\n-        recorder.validate(beanNames);\n+\n+        recorder.createFaultToleranceOperation(beanNames);\n+    }\n+\n+    private boolean hasFTAnnotations(AnnotationStore annotationStore, ClassInfo info) {\n+        // first check annotations on type\n+        if (annotationStore.hasAnyAnnotation(info, FT_ANNOTATIONS)) {\n+            return true;\n+        }\n+\n+        // then check on the methods\n+        for (MethodInfo method : info.methods()) {\n+            if (annotationStore.hasAnyAnnotation(method, FT_ANNOTATIONS)) {\n+                return true;\n+            }\n+        }\n+\n+        // then check on the parent\n+        DotName parentClassName = info.superName();\n+        ClassInfo parentClassInfo = combinedIndexBuildItem.getIndex().getClassByName(parentClassName);\n+        if (parentClassName.equals(DOTNAME_OBJECT) || parentClassInfo == null) {", "originalCommit": "59cac3a4b791378e56f5eaff3b30621a52d20029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMxODMyNw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371318327", "bodyText": "Done", "author": "loicmathieu", "createdAt": "2020-01-27T15:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NTkzNQ=="}], "type": "inlineReview"}, {"oid": "0504e5defe80e972f1a77e1194e849d7b139f2fa", "url": "https://github.com/quarkusio/quarkus/commit/0504e5defe80e972f1a77e1194e849d7b139f2fa", "message": "fix: improve FT processor", "committedDate": "2020-01-28T12:08:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NDgyMA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371784820", "bodyText": "We have to use a thread-safe Map impl here. I'd make this field final and use the ConcurrentHashMap. And then in the init() method use Map.putAll().", "author": "mkouba", "createdAt": "2020-01-28T12:55:59Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/QuarkusFaultToleranceOperationProvider.java", "diffHunk": "@@ -1,22 +1,50 @@\n package io.quarkus.smallrye.faulttolerance.runtime;\n \n import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.function.Function;\n \n import javax.annotation.Priority;\n-import javax.enterprise.context.Dependent;\n import javax.enterprise.inject.Alternative;\n+import javax.inject.Singleton;\n+\n+import org.jboss.logging.Logger;\n \n import io.smallrye.faulttolerance.FaultToleranceOperationProvider;\n import io.smallrye.faulttolerance.config.FaultToleranceOperation;\n \n-@Dependent\n+@Singleton\n @Alternative\n @Priority(1)\n public class QuarkusFaultToleranceOperationProvider implements FaultToleranceOperationProvider {\n+    private static final Logger LOG = Logger.getLogger(QuarkusFaultToleranceOperationProvider.class);\n+    private Map<String, FaultToleranceOperation> operationCache;", "originalCommit": "0504e5defe80e972f1a77e1194e849d7b139f2fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyMzE5MA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371823190", "bodyText": "Ah sorry, it was in my first implementation, I forgot to switch it.", "author": "loicmathieu", "createdAt": "2020-01-28T14:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371785933", "bodyText": "It's a pity that we have to create a new Function for each invocation of get(). But that's something we can live with ;-).", "author": "mkouba", "createdAt": "2020-01-28T12:58:26Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/QuarkusFaultToleranceOperationProvider.java", "diffHunk": "@@ -1,22 +1,50 @@\n package io.quarkus.smallrye.faulttolerance.runtime;\n \n import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.function.Function;\n \n import javax.annotation.Priority;\n-import javax.enterprise.context.Dependent;\n import javax.enterprise.inject.Alternative;\n+import javax.inject.Singleton;\n+\n+import org.jboss.logging.Logger;\n \n import io.smallrye.faulttolerance.FaultToleranceOperationProvider;\n import io.smallrye.faulttolerance.config.FaultToleranceOperation;\n \n-@Dependent\n+@Singleton\n @Alternative\n @Priority(1)\n public class QuarkusFaultToleranceOperationProvider implements FaultToleranceOperationProvider {\n+    private static final Logger LOG = Logger.getLogger(QuarkusFaultToleranceOperationProvider.class);\n+    private Map<String, FaultToleranceOperation> operationCache;\n+\n+    /**\n+     * Called by SmallryeFaultToleranceRecorder to init the operation cache.\n+     */\n+    void init(Map<String, FaultToleranceOperation> operationCache) {\n+        this.operationCache = operationCache;\n+    }\n \n     @Override\n     public FaultToleranceOperation get(Class<?> beanClass, Method method) {\n+        String key = getCacheKey(beanClass, method);\n+        return operationCache.computeIfAbsent(key, new Function<String, FaultToleranceOperation>() {", "originalCommit": "0504e5defe80e972f1a77e1194e849d7b139f2fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0Mjk5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371842999", "bodyText": "I don't see why we don't make the function a constant? Is there something forbidding it?", "author": "gsmet", "createdAt": "2020-01-28T14:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NDU4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371844585", "bodyText": "Because we use the method arguments inside the function -> createAtRuntime(beanClass, method, key).", "author": "mkouba", "createdAt": "2020-01-28T14:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg1MTA1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371851053", "bodyText": "It's possible if I used a CompositeKey with beanClass and method instead of a String. So everything needed to create the operation will be on the key and the Function could be a constant.", "author": "loicmathieu", "createdAt": "2020-01-28T14:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg1NjAxNg==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371856016", "bodyText": "Yeah, I was thinking about that.\nTBH, the best solution here is to do what I suggested first: we do a first get() call and only call computeIfAbsent if we have nothing. As previously mentioned, I did some extensive benchmarks on HV and it's significantly faster if this is called often (and I suppose it will be called for every call to a function that is marked with FT annotations or am I missing something?). And this will avoid creating the function if this is in the cache.", "author": "gsmet", "createdAt": "2020-01-28T15:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg1NjU0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371856546", "bodyText": "That would not help much - you'll have to create a new key object for each get() anyway...", "author": "mkouba", "createdAt": "2020-01-28T15:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg2MjQwNw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371862407", "bodyText": "Previsouly I created a new String for each object so it should be the same ...", "author": "loicmathieu", "createdAt": "2020-01-28T15:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg2MzQ3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371863472", "bodyText": "And the key object just hold two references for existing object so should be small regarding a new string ...", "author": "loicmathieu", "createdAt": "2020-01-28T15:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg2Nzk0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371867949", "bodyText": "@gsmet @mkouba updated with a composite CacheKey to avoid re-creating the Function on each call and implemented @gsmet optimization on the CHM.\nIf it's OK I'll squash the last commit and we'll be ready to go :)", "author": "loicmathieu", "createdAt": "2020-01-28T15:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1OTk4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372359982", "bodyText": "@mkouba you won't avoid creating the key but you can avoid creating the function.", "author": "gsmet", "createdAt": "2020-01-29T12:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NTkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NjI3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371786279", "bodyText": "WARN seems to be a bit strict. I think that INFO would be enough...", "author": "mkouba", "createdAt": "2020-01-28T12:59:11Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/QuarkusFaultToleranceOperationProvider.java", "diffHunk": "@@ -1,22 +1,50 @@\n package io.quarkus.smallrye.faulttolerance.runtime;\n \n import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.function.Function;\n \n import javax.annotation.Priority;\n-import javax.enterprise.context.Dependent;\n import javax.enterprise.inject.Alternative;\n+import javax.inject.Singleton;\n+\n+import org.jboss.logging.Logger;\n \n import io.smallrye.faulttolerance.FaultToleranceOperationProvider;\n import io.smallrye.faulttolerance.config.FaultToleranceOperation;\n \n-@Dependent\n+@Singleton\n @Alternative\n @Priority(1)\n public class QuarkusFaultToleranceOperationProvider implements FaultToleranceOperationProvider {\n+    private static final Logger LOG = Logger.getLogger(QuarkusFaultToleranceOperationProvider.class);\n+    private Map<String, FaultToleranceOperation> operationCache;\n+\n+    /**\n+     * Called by SmallryeFaultToleranceRecorder to init the operation cache.\n+     */\n+    void init(Map<String, FaultToleranceOperation> operationCache) {\n+        this.operationCache = operationCache;\n+    }\n \n     @Override\n     public FaultToleranceOperation get(Class<?> beanClass, Method method) {\n+        String key = getCacheKey(beanClass, method);\n+        return operationCache.computeIfAbsent(key, new Function<String, FaultToleranceOperation>() {\n+            @Override\n+            public FaultToleranceOperation apply(String key) {\n+                return createAtRuntime(beanClass, method, key);\n+            }\n+        });\n+    }\n+\n+    private FaultToleranceOperation createAtRuntime(Class<?> beanClass, Method method, String key) {\n+        LOG.warnf(\"FaultToleranceOperation not found in the cache for %s creating it at runtime\", key);", "originalCommit": "0504e5defe80e972f1a77e1194e849d7b139f2fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyNDkzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371824931", "bodyText": "Yes, now that we define that it can occurs and it's not a bug, INFO seems better.", "author": "loicmathieu", "createdAt": "2020-01-28T14:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NjI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzOTUwNA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371839504", "bodyText": "Do we really need an INFO if it's the normal behavior? Or it's not a normal behavior?\nIf it's normal behavior, it should just be debug.", "author": "gsmet", "createdAt": "2020-01-28T14:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NjI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0MzQ4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371843483", "bodyText": "It will be logged only once, and should arrives in very rare conditions (using the builder aproach for RestClient is one that we thin of, this aproach is not documented on the Quarkus site).\nBut I'm OK with DEBUG ...", "author": "loicmathieu", "createdAt": "2020-01-28T14:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NjI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg1NjQ2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371856463", "bodyText": "If it's something that can happen and doesn't need any action by the user then debug is enough IMHO.", "author": "gsmet", "createdAt": "2020-01-28T15:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NjI3OQ=="}], "type": "inlineReview"}, {"oid": "04898a3b7ec67b3e50afd1e3bad5d0b4d7cee76b", "url": "https://github.com/quarkusio/quarkus/commit/04898a3b7ec67b3e50afd1e3bad5d0b4d7cee76b", "message": "Avoid to re-create Fault Tolerance metadata for each request", "committedDate": "2020-01-28T14:25:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg2ODE3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371868172", "bodyText": "What are the getters/setters for?", "author": "mkouba", "createdAt": "2020-01-28T15:21:22Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/QuarkusFaultToleranceOperationProvider.java", "diffHunk": "@@ -19,33 +20,73 @@\n @Priority(1)\n public class QuarkusFaultToleranceOperationProvider implements FaultToleranceOperationProvider {\n     private static final Logger LOG = Logger.getLogger(QuarkusFaultToleranceOperationProvider.class);\n-    private final Map<String, FaultToleranceOperation> operationCache = new ConcurrentHashMap<>();\n+\n+    private final Map<CacheKey, FaultToleranceOperation> operationCache = new ConcurrentHashMap<>();\n+    private final Function<CacheKey, FaultToleranceOperation> cacheFunction = new Function<CacheKey, FaultToleranceOperation>() {\n+        @Override\n+        public FaultToleranceOperation apply(CacheKey key) {\n+            return createAtRuntime(key);\n+        }\n+    };\n \n     /**\n      * Called by SmallryeFaultToleranceRecorder to init the operation cache.\n      */\n-    void init(Map<String, FaultToleranceOperation> operationCache) {\n+    void init(Map<CacheKey, FaultToleranceOperation> operationCache) {\n         this.operationCache.putAll(operationCache);\n     }\n \n     @Override\n     public FaultToleranceOperation get(Class<?> beanClass, Method method) {\n-        String key = getCacheKey(beanClass, method);\n-        return operationCache.computeIfAbsent(key, new Function<String, FaultToleranceOperation>() {\n-            @Override\n-            public FaultToleranceOperation apply(String key) {\n-                return createAtRuntime(beanClass, method, key);\n-            }\n-        });\n+        CacheKey key = new CacheKey(beanClass, method);\n+        FaultToleranceOperation existing = operationCache.get(key);\n+        return existing != null ? existing : operationCache.computeIfAbsent(key, cacheFunction);\n     }\n \n-    private FaultToleranceOperation createAtRuntime(Class<?> beanClass, Method method, String key) {\n-        LOG.infof(\"FaultToleranceOperation not found in the cache for %s creating it at runtime\", key);\n-        return FaultToleranceOperation.of(beanClass, method);\n+    private FaultToleranceOperation createAtRuntime(CacheKey key) {\n+        LOG.debugf(\"FaultToleranceOperation not found in the cache for %s creating it at runtime\", key);\n+        return FaultToleranceOperation.of(key.beanClass, key.method);\n     }\n \n-    static String getCacheKey(Class<?> beanClass, Method method) {\n-        return beanClass.getName() + \"::\" + method.toGenericString();\n-    }\n+    static class CacheKey {\n+        private Class<?> beanClass;\n+        private Method method;\n+\n+        public CacheKey(Class<?> beanClass, Method method) {\n+            this.beanClass = beanClass;\n+            this.method = method;\n+        }\n+\n+        public Class<?> getBeanClass() {", "originalCommit": "6c42b2d64df62f76b8ccaf9348c798c191f072f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg3MzMyMw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r371873323", "bodyText": "Useless, removed, sorry.", "author": "loicmathieu", "createdAt": "2020-01-28T15:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg2ODE3Mg=="}], "type": "inlineReview"}, {"oid": "28749f113c759af330f31ccfd48fd978885b2028", "url": "https://github.com/quarkusio/quarkus/commit/28749f113c759af330f31ccfd48fd978885b2028", "message": "Optimise the FT operation cache mechanism", "committedDate": "2020-01-28T15:28:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODcwNg==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372338706", "bodyText": "It's minor but I would compute the hashCode in the constructor if it can become a hot path. That's what we do in HV.\nThat allows to cache the hashCode once and for all for all the items that are in the map.", "author": "gsmet", "createdAt": "2020-01-29T11:51:55Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/QuarkusFaultToleranceOperationProvider.java", "diffHunk": "@@ -1,22 +1,76 @@\n package io.quarkus.smallrye.faulttolerance.runtime;\n \n import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n \n import javax.annotation.Priority;\n-import javax.enterprise.context.Dependent;\n import javax.enterprise.inject.Alternative;\n+import javax.inject.Singleton;\n+\n+import org.jboss.logging.Logger;\n \n import io.smallrye.faulttolerance.FaultToleranceOperationProvider;\n import io.smallrye.faulttolerance.config.FaultToleranceOperation;\n \n-@Dependent\n+@Singleton\n @Alternative\n @Priority(1)\n public class QuarkusFaultToleranceOperationProvider implements FaultToleranceOperationProvider {\n+    private static final Logger LOG = Logger.getLogger(QuarkusFaultToleranceOperationProvider.class);\n+\n+    private final Map<CacheKey, FaultToleranceOperation> operationCache = new ConcurrentHashMap<>();\n+    private final Function<CacheKey, FaultToleranceOperation> cacheFunction = new Function<CacheKey, FaultToleranceOperation>() {\n+        @Override\n+        public FaultToleranceOperation apply(CacheKey key) {\n+            return createAtRuntime(key);\n+        }\n+    };\n+\n+    /**\n+     * Called by SmallryeFaultToleranceRecorder to init the operation cache.\n+     */\n+    void init(Map<CacheKey, FaultToleranceOperation> operationCache) {\n+        this.operationCache.putAll(operationCache);\n+    }\n \n     @Override\n     public FaultToleranceOperation get(Class<?> beanClass, Method method) {\n-        return FaultToleranceOperation.of(beanClass, method);\n+        CacheKey key = new CacheKey(beanClass, method);\n+        FaultToleranceOperation existing = operationCache.get(key);\n+        return existing != null ? existing : operationCache.computeIfAbsent(key, cacheFunction);\n+    }\n+\n+    private FaultToleranceOperation createAtRuntime(CacheKey key) {\n+        LOG.debugf(\"FaultToleranceOperation not found in the cache for %s creating it at runtime\", key);\n+        return FaultToleranceOperation.of(key.beanClass, key.method);\n     }\n \n+    static class CacheKey {\n+        private Class<?> beanClass;\n+        private Method method;\n+\n+        public CacheKey(Class<?> beanClass, Method method) {\n+            this.beanClass = beanClass;\n+            this.method = method;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            CacheKey cacheKey = (CacheKey) o;\n+            return Objects.equals(beanClass, cacheKey.beanClass) &&\n+                    Objects.equals(method, cacheKey.method);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(beanClass, method);", "originalCommit": "28749f113c759af330f31ccfd48fd978885b2028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NDIyNg==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372354226", "bodyText": "+1 and also make the fields final please.", "author": "mkouba", "createdAt": "2020-01-29T12:28:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2MDQ3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372360471", "bodyText": "Actually, I'm torn on that, not having the fields final make the JDK do some weird optimizations :). I removed them from the key objects in HV after Sanne gave me the idea to test it and benchmark it.", "author": "gsmet", "createdAt": "2020-01-29T12:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2MjE3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372362172", "bodyText": "So I'm not following. Was it better or worse ;-). In any case, the key should be immutable and it's not.", "author": "mkouba", "createdAt": "2020-01-29T12:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372545619", "bodyText": "@gmset good catch on the cache of the hashCode, I'm not used to do it but totaly worth it :)\nRegarding final fields, I add final to all three fields, I can remove it.\n@gmset it's very interesting, I was not aware of performance penalty on final field writes inside a constructor so I make some research and yes, there is a small performance penalty because the VM emmit a memory barrier when one of the field written inside a constructor is final. The cost of the barrier is minimal (5ns on ARM, almost nefligeable on x86). As always some good explaination/experiments on this can be found on Alexey Shipilev blog: https://shipilev.net/blog/2014/all-fields-are-final/\nI you want, I can remove the three final modifier ...", "author": "loicmathieu", "createdAt": "2020-01-29T18:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1MTQ5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372551491", "bodyText": "In my HV benchmarks (and I have no idea why), removing the final from the fields did help. In HV, the only classes that don't have final fields are the classes used as keys. It's a very hot path though.", "author": "gsmet", "createdAt": "2020-01-29T18:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTc2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372779763", "bodyText": "OK, to please @gsmet ;) I remove the final modifier.\nReady to be merged", "author": "loicmathieu", "createdAt": "2020-01-30T06:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODg5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372338899", "bodyText": "If you end up taking into account my comment below, please use curly braces for the two statements above.", "author": "gsmet", "createdAt": "2020-01-29T11:52:27Z", "path": "extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/QuarkusFaultToleranceOperationProvider.java", "diffHunk": "@@ -1,22 +1,76 @@\n package io.quarkus.smallrye.faulttolerance.runtime;\n \n import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n \n import javax.annotation.Priority;\n-import javax.enterprise.context.Dependent;\n import javax.enterprise.inject.Alternative;\n+import javax.inject.Singleton;\n+\n+import org.jboss.logging.Logger;\n \n import io.smallrye.faulttolerance.FaultToleranceOperationProvider;\n import io.smallrye.faulttolerance.config.FaultToleranceOperation;\n \n-@Dependent\n+@Singleton\n @Alternative\n @Priority(1)\n public class QuarkusFaultToleranceOperationProvider implements FaultToleranceOperationProvider {\n+    private static final Logger LOG = Logger.getLogger(QuarkusFaultToleranceOperationProvider.class);\n+\n+    private final Map<CacheKey, FaultToleranceOperation> operationCache = new ConcurrentHashMap<>();\n+    private final Function<CacheKey, FaultToleranceOperation> cacheFunction = new Function<CacheKey, FaultToleranceOperation>() {\n+        @Override\n+        public FaultToleranceOperation apply(CacheKey key) {\n+            return createAtRuntime(key);\n+        }\n+    };\n+\n+    /**\n+     * Called by SmallryeFaultToleranceRecorder to init the operation cache.\n+     */\n+    void init(Map<CacheKey, FaultToleranceOperation> operationCache) {\n+        this.operationCache.putAll(operationCache);\n+    }\n \n     @Override\n     public FaultToleranceOperation get(Class<?> beanClass, Method method) {\n-        return FaultToleranceOperation.of(beanClass, method);\n+        CacheKey key = new CacheKey(beanClass, method);\n+        FaultToleranceOperation existing = operationCache.get(key);\n+        return existing != null ? existing : operationCache.computeIfAbsent(key, cacheFunction);\n+    }\n+\n+    private FaultToleranceOperation createAtRuntime(CacheKey key) {\n+        LOG.debugf(\"FaultToleranceOperation not found in the cache for %s creating it at runtime\", key);\n+        return FaultToleranceOperation.of(key.beanClass, key.method);\n     }\n \n+    static class CacheKey {\n+        private Class<?> beanClass;\n+        private Method method;\n+\n+        public CacheKey(Class<?> beanClass, Method method) {\n+            this.beanClass = beanClass;\n+            this.method = method;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;", "originalCommit": "28749f113c759af330f31ccfd48fd978885b2028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0Mzk3NA==", "url": "https://github.com/quarkusio/quarkus/pull/6771#discussion_r372543974", "bodyText": "Done, I should update my IDEA templates as I prefere having the curly braces ...", "author": "loicmathieu", "createdAt": "2020-01-29T18:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMzODg5OQ=="}], "type": "inlineReview"}, {"oid": "d7e9de00d8d3d559da54a99a9e0cea347fd02a4d", "url": "https://github.com/quarkusio/quarkus/commit/d7e9de00d8d3d559da54a99a9e0cea347fd02a4d", "message": "fix: no need to check if it's a classBean when using beans.classBeans()\n\nclassBeans() uses `filter(BeanInfo::isClassBean)` so the check is already done", "committedDate": "2020-01-29T17:19:42Z", "type": "commit"}, {"oid": "54e8087de64b06ebbbd23c01cd914e0b158b0595", "url": "https://github.com/quarkusio/quarkus/commit/54e8087de64b06ebbbd23c01cd914e0b158b0595", "message": "Avoid to re-create Fault Tolerance metadata for each request", "committedDate": "2020-01-29T17:19:42Z", "type": "forcePushed"}, {"oid": "4af812bba979680bb3cd3ed77e3d958645d83f2c", "url": "https://github.com/quarkusio/quarkus/commit/4af812bba979680bb3cd3ed77e3d958645d83f2c", "message": "Avoid to re-create Fault Tolerance metadata for each request", "committedDate": "2020-01-30T06:30:34Z", "type": "commit"}, {"oid": "4af812bba979680bb3cd3ed77e3d958645d83f2c", "url": "https://github.com/quarkusio/quarkus/commit/4af812bba979680bb3cd3ed77e3d958645d83f2c", "message": "Avoid to re-create Fault Tolerance metadata for each request", "committedDate": "2020-01-30T06:30:34Z", "type": "forcePushed"}]}