{"pr_number": 9717, "pr_title": "Swagger and static resource support AWS Lambda HTTP, Azure HTTP", "pr_createdAt": "2020-06-02T00:00:55Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9717", "timeline": [{"oid": "1912d0f3e41db997efca870a0e1cae6538529dc2", "url": "https://github.com/quarkusio/quarkus/commit/1912d0f3e41db997efca870a0e1cae6538529dc2", "message": "Support FileRegions\n\nlambda formatting\n\nvirtual handler", "committedDate": "2020-06-02T00:02:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1NzE1NA==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r433557154", "bodyText": "I don't think this is correct. I think you need to create a buffer that is the size of file.count(), then just calling transferTo once should be enough. If you don't have enough space in the buffer then there is no way to read all the contents.", "author": "stuartwdouglas", "createdAt": "2020-06-02T00:26:31Z", "path": "extensions/amazon-lambda-http/runtime/src/main/java/io/quarkus/amazon/lambda/http/LambdaHttpHandler.java", "diffHunk": "@@ -46,19 +53,102 @@ public AwsProxyResponse handleRequest(AwsProxyRequest request, Context context)\n             }\n         }\n \n-        VirtualClientConnection connection = VirtualClientConnection.connect(VertxHttpRecorder.VIRTUAL_HTTP, clientAddress);\n         try {\n-            return nettyDispatch(connection, request);\n+            return nettyDispatch(clientAddress, request);\n         } catch (Exception e) {\n+            log.error(\"Request Failure\", e);\n             return new AwsProxyResponse(500, errorHeaders, \"{ \\\"message\\\": \\\"Internal Server Error\\\" }\");\n-        } finally {\n-            connection.close();\n         }\n \n     }\n \n-    private AwsProxyResponse nettyDispatch(VirtualClientConnection connection, AwsProxyRequest request) throws Exception {\n+    private class NettyResponseHandler implements VirtualResponseHandler {\n+        AwsProxyResponse responseBuilder = new AwsProxyResponse();\n+        ByteArrayOutputStream baos;\n+        WritableByteChannel byteChannel;\n+        final AwsProxyRequest request;\n+        CompletableFuture<AwsProxyResponse> future = new CompletableFuture<>();\n+\n+        public NettyResponseHandler(AwsProxyRequest request) {\n+            this.request = request;\n+        }\n+\n+        public CompletableFuture<AwsProxyResponse> getFuture() {\n+            return future;\n+        }\n+\n+        @Override\n+        public void handleMessage(Object msg) {\n+            try {\n+                //log.info(\"Got message: \" + msg.getClass().getName());\n+\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse res = (HttpResponse) msg;\n+                    responseBuilder.setStatusCode(res.status().code());\n+\n+                    if (request.getRequestSource() == AwsProxyRequest.RequestSource.ALB) {\n+                        responseBuilder.setStatusDescription(res.status().reasonPhrase());\n+                    }\n+                    responseBuilder.setMultiValueHeaders(new Headers());\n+                    for (String name : res.headers().names()) {\n+                        for (String v : res.headers().getAll(name)) {\n+                            responseBuilder.getMultiValueHeaders().add(name, v);\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    HttpContent content = (HttpContent) msg;\n+                    int readable = content.content().readableBytes();\n+                    if (baos == null && readable > 0) {\n+                        baos = createByteStream();\n+                    }\n+                    for (int i = 0; i < readable; i++) {\n+                        baos.write(content.content().readByte());\n+                    }\n+                }\n+                if (msg instanceof FileRegion) {\n+                    FileRegion file = (FileRegion) msg;\n+                    if (file.count() > 0 && file.transferred() < file.count()) {\n+                        if (baos == null)\n+                            baos = createByteStream();\n+                        if (byteChannel == null)\n+                            byteChannel = Channels.newChannel(baos);\n+                        // AbstractNioByteChannel also seems to do a spin, albeit with a count.\n+                        while (file.transferred() < file.count()) {\n+                            file.transferTo(byteChannel, file.transferred());", "originalCommit": "1912d0f3e41db997efca870a0e1cae6538529dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMTIwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r433611201", "bodyText": "The channel is a ByteArrayOutputStream:\nChannels.newChannel(baos);\nI thought the problem would have been on the read of the file.  That's why I was worried.", "author": "patriot1burke", "createdAt": "2020-06-02T04:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1NzE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxNTgyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r433615829", "bodyText": "Ah yea, in that case I think it should just work without the loop. According to the docs:\nFewer than the requested number of * bytes are transferred if this channel's file contains fewer than * <tt>count</tt> bytes starting at the given <tt>position</tt>, or if the * target channel is non-blocking and it has fewer than <tt>count</tt> * bytes free in its output buffer. \nThis should be a blocking channel, so as far as I can see it should always succeed in one call. The ones inside Netty itself are working with non-blocking channels.", "author": "stuartwdouglas", "createdAt": "2020-06-02T04:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1NzE1NA=="}], "type": "inlineReview"}, {"oid": "52311f882c3c590e4994af4107cb434a4f26530e", "url": "https://github.com/quarkusio/quarkus/commit/52311f882c3c590e4994af4107cb434a4f26530e", "message": "Support FileRegions\n\nlambda formatting\n\nvirtual handler\n\npoll loop error messages", "committedDate": "2020-06-02T15:53:36Z", "type": "forcePushed"}, {"oid": "03dfd8c1b8327b1d3cc3c1828eb4144697c1f464", "url": "https://github.com/quarkusio/quarkus/commit/03dfd8c1b8327b1d3cc3c1828eb4144697c1f464", "message": "Support FileRegions\n\nlambda formatting\n\nvirtual handler\n\npoll loop error messages\n\ngit rid of poll loop", "committedDate": "2020-06-02T15:59:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1Njg4MA==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r434256880", "bodyText": "This should be file.count().", "author": "stuartwdouglas", "createdAt": "2020-06-03T01:14:22Z", "path": "extensions/amazon-lambda-http/runtime/src/main/java/io/quarkus/amazon/lambda/http/LambdaHttpHandler.java", "diffHunk": "@@ -46,19 +53,99 @@ public AwsProxyResponse handleRequest(AwsProxyRequest request, Context context)\n             }\n         }\n \n-        VirtualClientConnection connection = VirtualClientConnection.connect(VertxHttpRecorder.VIRTUAL_HTTP, clientAddress);\n         try {\n-            return nettyDispatch(connection, request);\n+            return nettyDispatch(clientAddress, request);\n         } catch (Exception e) {\n+            log.error(\"Request Failure\", e);\n             return new AwsProxyResponse(500, errorHeaders, \"{ \\\"message\\\": \\\"Internal Server Error\\\" }\");\n-        } finally {\n-            connection.close();\n         }\n \n     }\n \n-    private AwsProxyResponse nettyDispatch(VirtualClientConnection connection, AwsProxyRequest request) throws Exception {\n+    private class NettyResponseHandler implements VirtualResponseHandler {\n+        AwsProxyResponse responseBuilder = new AwsProxyResponse();\n+        ByteArrayOutputStream baos;\n+        WritableByteChannel byteChannel;\n+        final AwsProxyRequest request;\n+        CompletableFuture<AwsProxyResponse> future = new CompletableFuture<>();\n+\n+        public NettyResponseHandler(AwsProxyRequest request) {\n+            this.request = request;\n+        }\n+\n+        public CompletableFuture<AwsProxyResponse> getFuture() {\n+            return future;\n+        }\n+\n+        @Override\n+        public void handleMessage(Object msg) {\n+            try {\n+                //log.info(\"Got message: \" + msg.getClass().getName());\n+\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse res = (HttpResponse) msg;\n+                    responseBuilder.setStatusCode(res.status().code());\n+\n+                    if (request.getRequestSource() == AwsProxyRequest.RequestSource.ALB) {\n+                        responseBuilder.setStatusDescription(res.status().reasonPhrase());\n+                    }\n+                    responseBuilder.setMultiValueHeaders(new Headers());\n+                    for (String name : res.headers().names()) {\n+                        for (String v : res.headers().getAll(name)) {\n+                            responseBuilder.getMultiValueHeaders().add(name, v);\n+                        }\n+                    }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    HttpContent content = (HttpContent) msg;\n+                    int readable = content.content().readableBytes();\n+                    if (baos == null && readable > 0) {\n+                        baos = createByteStream();\n+                    }\n+                    for (int i = 0; i < readable; i++) {\n+                        baos.write(content.content().readByte());\n+                    }\n+                }\n+                if (msg instanceof FileRegion) {\n+                    FileRegion file = (FileRegion) msg;\n+                    if (file.count() > 0 && file.transferred() < file.count()) {\n+                        if (baos == null)\n+                            baos = createByteStream();\n+                        if (byteChannel == null)\n+                            byteChannel = Channels.newChannel(baos);\n+                        file.transferTo(byteChannel, file.transferred());", "originalCommit": "03dfd8c1b8327b1d3cc3c1828eb4144697c1f464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI3NzcwNA==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r434277704", "bodyText": "ok, that concerns me because my test passes.", "author": "patriot1burke", "createdAt": "2020-06-03T02:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1Njg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI3ODY3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r434278671", "bodyText": "Actually no, I am completly wrong here. This should be file.transferred(), which will always be 0.", "author": "stuartwdouglas", "createdAt": "2020-06-03T02:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1Njg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI3ODk4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r434278981", "bodyText": "@patriot1burke sorry for the noise, I got confused between the parameters the underlying file channel takes and the FileRegion itself.", "author": "stuartwdouglas", "createdAt": "2020-06-03T02:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1Njg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NzA4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r434297081", "bodyText": "Yeah, I remember why I had it like that. Its supposed to be position, not how many.", "author": "patriot1burke", "createdAt": "2020-06-03T04:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1Njg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NzA5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9717#discussion_r434257093", "bodyText": "should be .count().", "author": "stuartwdouglas", "createdAt": "2020-06-03T01:15:13Z", "path": "extensions/azure-functions-http/runtime/src/main/java/io/quarkus/azure/functions/resteasy/runtime/BaseFunction.java", "diffHunk": "@@ -92,51 +92,83 @@ protected HttpResponseMessage nettyDispatch(VirtualClientConnection connection,\n             requestContent = new DefaultLastHttpContent(body);\n         }\n \n+        ResponseHandler handler = new ResponseHandler(request);\n+        VirtualClientConnection connection = VirtualClientConnection.connect(handler, VertxHttpRecorder.VIRTUAL_HTTP);\n+\n         connection.sendMessage(nettyRequest);\n         connection.sendMessage(requestContent);\n-        HttpResponseMessage.Builder responseBuilder = null;\n-        ByteArrayOutputStream baos = null;\n         try {\n-            for (;;) {\n-                // todo should we timeout? have a timeout config?\n-                //log.info(\"waiting for message\");\n-                Object msg = connection.queue().poll(100, TimeUnit.MILLISECONDS);\n-                try {\n-                    if (msg == null)\n-                        continue;\n-                    //log.info(\"Got message: \" + msg.getClass().getName());\n-\n-                    if (msg instanceof HttpResponse) {\n-                        HttpResponse res = (HttpResponse) msg;\n-                        responseBuilder = request.createResponseBuilder(HttpStatus.valueOf(res.status().code()));\n-                        for (Map.Entry<String, String> entry : res.headers()) {\n-                            responseBuilder.header(entry.getKey(), entry.getValue());\n-                        }\n+            return handler.future.get();\n+        } finally {\n+            connection.close();\n+        }\n+    }\n+\n+    private ByteArrayOutputStream createByteStream() {\n+        ByteArrayOutputStream baos;\n+        baos = new ByteArrayOutputStream(500);\n+        return baos;\n+    }\n+\n+    private class ResponseHandler implements VirtualResponseHandler {\n+        HttpResponseMessage.Builder responseBuilder;\n+        ByteArrayOutputStream baos;\n+        WritableByteChannel byteChannel;\n+        CompletableFuture<HttpResponseMessage> future = new CompletableFuture<>();\n+        final HttpRequestMessage<Optional<byte[]>> request;\n+\n+        public ResponseHandler(HttpRequestMessage<Optional<byte[]>> request) {\n+            this.request = request;\n+        }\n+\n+        @Override\n+        public void handleMessage(Object msg) {\n+            try {\n+                //log.info(\"Got message: \" + msg.getClass().getName());\n+\n+                if (msg instanceof HttpResponse) {\n+                    HttpResponse res = (HttpResponse) msg;\n+                    responseBuilder = request.createResponseBuilder(HttpStatus.valueOf(res.status().code()));\n+                    for (Map.Entry<String, String> entry : res.headers()) {\n+                        responseBuilder.header(entry.getKey(), entry.getValue());\n                     }\n-                    if (msg instanceof HttpContent) {\n-                        HttpContent content = (HttpContent) msg;\n-                        if (baos == null) {\n-                            // todo what is right size?\n-                            baos = new ByteArrayOutputStream(500);\n-                        }\n-                        int readable = content.content().readableBytes();\n-                        for (int i = 0; i < readable; i++) {\n-                            baos.write(content.content().readByte());\n-                        }\n+                }\n+                if (msg instanceof HttpContent) {\n+                    HttpContent content = (HttpContent) msg;\n+                    if (baos == null) {\n+                        // todo what is right size?\n+                        baos = createByteStream();\n                     }\n-                    if (msg instanceof LastHttpContent) {\n-                        responseBuilder.body(baos.toByteArray());\n-                        return responseBuilder.build();\n+                    int readable = content.content().readableBytes();\n+                    for (int i = 0; i < readable; i++) {\n+                        baos.write(content.content().readByte());\n                     }\n-                } finally {\n-                    if (msg != null)\n-                        ReferenceCountUtil.release(msg);\n                 }\n+                if (msg instanceof FileRegion) {\n+                    FileRegion file = (FileRegion) msg;\n+                    if (file.count() > 0 && file.transferred() < file.count()) {\n+                        if (baos == null)\n+                            baos = createByteStream();\n+                        if (byteChannel == null)\n+                            byteChannel = Channels.newChannel(baos);\n+                        file.transferTo(byteChannel, file.transferred());", "originalCommit": "03dfd8c1b8327b1d3cc3c1828eb4144697c1f464", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b4cb8192f677ae033c9d3d9aaecf8cc62fb210e4", "url": "https://github.com/quarkusio/quarkus/commit/b4cb8192f677ae033c9d3d9aaecf8cc62fb210e4", "message": "Support FileRegions\n\nlambda formatting\n\nvirtual handler\n\npoll loop error messages\n\ngit rid of poll loop\n\nfix transferTo", "committedDate": "2020-06-03T02:46:28Z", "type": "forcePushed"}, {"oid": "e09716890053fc7ae54ff89b0e4db93cb268bd6b", "url": "https://github.com/quarkusio/quarkus/commit/e09716890053fc7ae54ff89b0e4db93cb268bd6b", "message": "Support FileRegions\n\nlambda formatting\n\nvirtual handler\n\npoll loop error messages\n\ngit rid of poll loop\n\nfix transferTo\n\nrevert back", "committedDate": "2020-06-03T04:12:23Z", "type": "forcePushed"}, {"oid": "d91e04c9490626a7b4484b3c962ba56615b02819", "url": "https://github.com/quarkusio/quarkus/commit/d91e04c9490626a7b4484b3c962ba56615b02819", "message": "Support FileRegions\n\nlambda formatting\n\nvirtual handler\n\npoll loop error messages\n\ngit rid of poll loop\n\nfix transferTo\n\nrevert back", "committedDate": "2020-06-03T14:13:27Z", "type": "forcePushed"}, {"oid": "2e76ec50882c8b453411c43b9040ce683cb2fa87", "url": "https://github.com/quarkusio/quarkus/commit/2e76ec50882c8b453411c43b9040ce683cb2fa87", "message": "Support FileRegions\n\nlambda formatting\n\nvirtual handler\n\npoll loop error messages\n\ngit rid of poll loop\n\nfix transferTo\n\nrevert back", "committedDate": "2020-06-03T21:11:01Z", "type": "commit"}, {"oid": "2e76ec50882c8b453411c43b9040ce683cb2fa87", "url": "https://github.com/quarkusio/quarkus/commit/2e76ec50882c8b453411c43b9040ce683cb2fa87", "message": "Support FileRegions\n\nlambda formatting\n\nvirtual handler\n\npoll loop error messages\n\ngit rid of poll loop\n\nfix transferTo\n\nrevert back", "committedDate": "2020-06-03T21:11:01Z", "type": "forcePushed"}]}