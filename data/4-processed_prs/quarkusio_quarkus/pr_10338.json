{"pr_number": 10338, "pr_title": "Scheduler - add Scheduled#concurrentExecution() strategy", "pr_createdAt": "2020-06-29T12:55:14Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/10338", "timeline": [{"oid": "100c687cc4d491edfdace4cf531bd156c04f31e5", "url": "https://github.com/quarkusio/quarkus/commit/100c687cc4d491edfdace4cf531bd156c04f31e5", "message": "Scheduler - add Scheduled#concurrentExecution() strategy\n\n- resolves  #9883 and #10203", "committedDate": "2020-06-29T12:53:40Z", "type": "commit"}, {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "url": "https://github.com/quarkusio/quarkus/commit/71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "message": "Add scheduler reference guide\n\n- also mentions Scheduled#concurrentExecution()", "committedDate": "2020-06-30T08:42:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NDE3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447654176", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n          \n          \n            \n            The `quarkus-scheduler` extension brings the API and a lightweight in-memory scheduler implementation.", "author": "gsmet", "createdAt": "2020-06-30T12:46:45Z", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.", "originalCommit": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NDk1OA==", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447654958", "bodyText": "Should we raise a warning in this case?", "author": "gsmet", "createdAt": "2020-06-30T12:48:04Z", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.", "originalCommit": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwODY0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447708649", "bodyText": "That's a good point.", "author": "mkouba", "createdAt": "2020-06-30T14:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NDk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1Njc5OA==", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447656798", "bodyText": "Maybe we should raise a warning too?", "author": "gsmet", "createdAt": "2020-06-30T12:51:07Z", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.\n+If none is specified, the build fails with an `IllegalStateException`.\n+\n+==== CRON\n+\n+A CRON trigger is defined by a cron-like expression.\n+For example `\"0 15 10 * * ?\"` fires at 10:15am every day.\n+\n+.CRON Trigger Example\n+[source,java]\n+----\n+@Scheduled(cron = \"0 15 10 * * ?\")\n+void fireAt10AmEveryDay() { }\n+----\n+\n+The syntax used in CRON expressions is controlled by the `quarkus.scheduler.cron-type` property.\n+The values can be `cron4j`, `quartz`, `unix` and `spring`.\n+`quartz` is used by default.\n+\n+If a CRON expression starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead. \n+\n+.CRON Config Property Example\n+[source,java]\n+----\n+@Scheduled(cron = \"{myMethod.cron.expr}\")\n+void myMethod() { }\n+----\n+\n+==== Intervals\n+\n+An interval trigger defines a period between invocations.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value of `@Scheduled#every()` is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit then the `PT` prefix is added automatically.\n+So for example, `15m` can be used instead of `PT15M` and is parsed as \"15 minutes\".\n+\n+.Interval Trigger Example\n+[source,java]\n+----\n+@Scheduled(every = \"15m\")\n+void every15Mins() { }\n+----\n+\n+If a value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead.\n+\n+.Interval Config Property Example\n+[source,java]\n+----\n+@Scheduled(every = \"{myMethod.every.expr}\")\n+void myMethod() { }\n+----\n+\n+=== Identity\n+\n+By default, a unique id is generated for each scheduled method.\n+This id is used in log messages and during debugging.\n+Sometimes a possibility to specify an explicit id may come in handy.\n+\n+.Identity Example\n+[source,java]\n+----\n+@Scheduled(identity = \"myScheduledMethod\")\n+void myMethod() { }\n+----\n+\n+=== Delayed Execution\n+\n+`@Scheduled` provides two ways to delay the time a trigger should start firing at.\n+\n+`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay together.\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delay = 2, delayUnit = TimeUnit.HOUR) <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The trigger fires for the first time two hours after the application start.\n+\n+NOTE: The final value is always rounded to full second.\n+\n+`@Scheduled#delayed()` is a text alternative to the properties above.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit, the `PT` prefix is added automatically.\n+So for example, `15s` can be used instead of `PT15S` and is parsed as \"15 seconds\".\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"2h\")\n+void everyTwoSeconds() { }\n+----\n+\n+NOTE: If `@Scheduled#delay()` is set to a value greater then zero the value of `@Scheduled#delayed()` is ignored.", "originalCommit": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NzYxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447657611", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can even disable scheduler for particular <<getting-started-testing#testing_different_profiles,Test Profiles>>.\n          \n          \n            \n            You can even disable the scheduler for particular <<getting-started-testing#testing_different_profiles,Test Profiles>>.", "author": "gsmet", "createdAt": "2020-06-30T12:52:28Z", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.\n+If none is specified, the build fails with an `IllegalStateException`.\n+\n+==== CRON\n+\n+A CRON trigger is defined by a cron-like expression.\n+For example `\"0 15 10 * * ?\"` fires at 10:15am every day.\n+\n+.CRON Trigger Example\n+[source,java]\n+----\n+@Scheduled(cron = \"0 15 10 * * ?\")\n+void fireAt10AmEveryDay() { }\n+----\n+\n+The syntax used in CRON expressions is controlled by the `quarkus.scheduler.cron-type` property.\n+The values can be `cron4j`, `quartz`, `unix` and `spring`.\n+`quartz` is used by default.\n+\n+If a CRON expression starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead. \n+\n+.CRON Config Property Example\n+[source,java]\n+----\n+@Scheduled(cron = \"{myMethod.cron.expr}\")\n+void myMethod() { }\n+----\n+\n+==== Intervals\n+\n+An interval trigger defines a period between invocations.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value of `@Scheduled#every()` is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit then the `PT` prefix is added automatically.\n+So for example, `15m` can be used instead of `PT15M` and is parsed as \"15 minutes\".\n+\n+.Interval Trigger Example\n+[source,java]\n+----\n+@Scheduled(every = \"15m\")\n+void every15Mins() { }\n+----\n+\n+If a value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead.\n+\n+.Interval Config Property Example\n+[source,java]\n+----\n+@Scheduled(every = \"{myMethod.every.expr}\")\n+void myMethod() { }\n+----\n+\n+=== Identity\n+\n+By default, a unique id is generated for each scheduled method.\n+This id is used in log messages and during debugging.\n+Sometimes a possibility to specify an explicit id may come in handy.\n+\n+.Identity Example\n+[source,java]\n+----\n+@Scheduled(identity = \"myScheduledMethod\")\n+void myMethod() { }\n+----\n+\n+=== Delayed Execution\n+\n+`@Scheduled` provides two ways to delay the time a trigger should start firing at.\n+\n+`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay together.\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delay = 2, delayUnit = TimeUnit.HOUR) <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The trigger fires for the first time two hours after the application start.\n+\n+NOTE: The final value is always rounded to full second.\n+\n+`@Scheduled#delayed()` is a text alternative to the properties above.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit, the `PT` prefix is added automatically.\n+So for example, `15s` can be used instead of `PT15S` and is parsed as \"15 seconds\".\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"2h\")\n+void everyTwoSeconds() { }\n+----\n+\n+NOTE: If `@Scheduled#delay()` is set to a value greater then zero the value of `@Scheduled#delayed()` is ignored.\n+\n+The main advantage over `@Scheduled#delay()` is that the value is configurable.\n+If the value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead: \n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"{myMethod.delay.expr}\") <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The config property `myMethod.delay.expr` is used to set the delay.\n+\n+[[concurrent_execution]]\n+=== Concurrent Execution\n+\n+By default, a scheduled method can be executed concurrently.\n+Nevertheless, it is possible to specify the strategy to handle concurrent executions via `@Scheduled#concurrentExecution()`.\n+\n+[source,java]\n+----\n+import static io.quarkus.scheduler.Scheduled.ConcurrentExection.SKIP;\n+\n+@Scheduled(every = \"1s\", concurrentExecution = SKIP) <1>\n+void nonConcurrent() {\n+  // we can be sure that this method is never executed concurrently\n+}\n+----\n+<1> Concurrent executions are skipped.\n+\n+== Scheduler\n+\n+Quarkus provides a built-in bean of type `io.quarkus.scheduler.Scheduler` that can be injected and used to pause/resume the scheduler.\n+\n+.Scheduler Injection Example\n+[source,java]\n+----\n+import io.quarkus.scheduler.Scheduler;\n+\n+class MyService {\n+\n+   @Inject\n+   Scheduler scheduler;\n+\n+   void ping() {\n+      scheduler.pause(); <1>\n+      if (scheduler.isRunning()) {\n+         throw new IllegalStateException(\"This should never happen!\");\n+      }\n+      scheduler.resume(); <2>\n+   }\n+}\n+----\n+<1> Pause all triggers.\n+<2> Resume the scheduler.\n+\n+== Programmatic Scheduling\n+\n+If you need to schedule a job programmatically you'll need to add the link:quartz[Quartz extension] and use the Quartz API direcly.\n+\n+.Programmatic Scheduling with Quartz API\n+[source,java]\n+----\n+import org.quartz.Scheduler;\n+\n+class MyJobs {\n+\n+    void onStart(@Observes StartupEvent event, Scheduler quartz) throws SchedulerException {\n+        JobDetail job = JobBuilder.newJob(SomeJob.class)\n+                .withIdentity(\"myJob\", \"myGroup\")\n+                .build();\n+        Trigger trigger = TriggerBuilder.newTrigger()\n+                .withIdentity(\"myTrigger\", \"myGroup\")\n+                .startNow()\n+                .withSchedule(SimpleScheduleBuilder.simpleSchedule()\n+                        .withIntervalInSeconds(1)\n+                        .repeatForever())\n+                .build();\n+        quartz.scheduleJob(job, trigger);\n+    }\n+}\n+----\n+\n+== Scheduled Methods and Testing\n+\n+It is often desirable to disable the scheduler when running the tests.\n+The scheduler can be disabled through the runtime config property `quarkus.scheduler.enabled`.\n+If set to `false` the scheduler is not started even though the application contains scheduled methods.\n+You can even disable scheduler for particular <<getting-started-testing#testing_different_profiles,Test Profiles>>.", "originalCommit": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1ODA2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447658067", "bodyText": "ConcurrentExection -> ConcurrentExecution", "author": "gsmet", "createdAt": "2020-06-30T12:53:15Z", "path": "extensions/scheduler/runtime/src/main/java/io/quarkus/scheduler/Scheduled.java", "diffHunk": "@@ -104,6 +105,14 @@\n      */\n     String delayed() default \"\";\n \n+    /**\n+     * Specify the strategy to handle concurrent execution of a scheduled method. By default, a scheduled method can be executed\n+     * concurrently.\n+     * \n+     * @return the concurrent execution strategy\n+     */\n+    ConcurrentExection concurrentExecution() default PROCEED;", "originalCommit": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY2MDkzNw==", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447660937", "bodyText": "Just check the refactoring picked this one too.", "author": "gsmet", "createdAt": "2020-06-30T12:57:56Z", "path": "extensions/scheduler/runtime/src/main/java/io/quarkus/scheduler/runtime/SkipConcurrentExecutionInvoker.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.quarkus.scheduler.runtime;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.scheduler.Scheduled;\n+import io.quarkus.scheduler.ScheduledExecution;\n+\n+/**\n+ * A scheduled invoker wrapper that skips concurrent executions.\n+ * \n+ * @see Scheduled#concurrentExecution()\n+ * @see io.quarkus.scheduler.Scheduled.ConcurrentExection#SKIP", "originalCommit": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY2MTA4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447661082", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static io.quarkus.scheduler.Scheduled.ConcurrentExection.SKIP;\n          \n          \n            \n            import static io.quarkus.scheduler.Scheduled.ConcurrentExecution.SKIP;", "author": "gsmet", "createdAt": "2020-06-30T12:58:10Z", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.\n+If none is specified, the build fails with an `IllegalStateException`.\n+\n+==== CRON\n+\n+A CRON trigger is defined by a cron-like expression.\n+For example `\"0 15 10 * * ?\"` fires at 10:15am every day.\n+\n+.CRON Trigger Example\n+[source,java]\n+----\n+@Scheduled(cron = \"0 15 10 * * ?\")\n+void fireAt10AmEveryDay() { }\n+----\n+\n+The syntax used in CRON expressions is controlled by the `quarkus.scheduler.cron-type` property.\n+The values can be `cron4j`, `quartz`, `unix` and `spring`.\n+`quartz` is used by default.\n+\n+If a CRON expression starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead. \n+\n+.CRON Config Property Example\n+[source,java]\n+----\n+@Scheduled(cron = \"{myMethod.cron.expr}\")\n+void myMethod() { }\n+----\n+\n+==== Intervals\n+\n+An interval trigger defines a period between invocations.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value of `@Scheduled#every()` is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit then the `PT` prefix is added automatically.\n+So for example, `15m` can be used instead of `PT15M` and is parsed as \"15 minutes\".\n+\n+.Interval Trigger Example\n+[source,java]\n+----\n+@Scheduled(every = \"15m\")\n+void every15Mins() { }\n+----\n+\n+If a value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead.\n+\n+.Interval Config Property Example\n+[source,java]\n+----\n+@Scheduled(every = \"{myMethod.every.expr}\")\n+void myMethod() { }\n+----\n+\n+=== Identity\n+\n+By default, a unique id is generated for each scheduled method.\n+This id is used in log messages and during debugging.\n+Sometimes a possibility to specify an explicit id may come in handy.\n+\n+.Identity Example\n+[source,java]\n+----\n+@Scheduled(identity = \"myScheduledMethod\")\n+void myMethod() { }\n+----\n+\n+=== Delayed Execution\n+\n+`@Scheduled` provides two ways to delay the time a trigger should start firing at.\n+\n+`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay together.\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delay = 2, delayUnit = TimeUnit.HOUR) <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The trigger fires for the first time two hours after the application start.\n+\n+NOTE: The final value is always rounded to full second.\n+\n+`@Scheduled#delayed()` is a text alternative to the properties above.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit, the `PT` prefix is added automatically.\n+So for example, `15s` can be used instead of `PT15S` and is parsed as \"15 seconds\".\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"2h\")\n+void everyTwoSeconds() { }\n+----\n+\n+NOTE: If `@Scheduled#delay()` is set to a value greater then zero the value of `@Scheduled#delayed()` is ignored.\n+\n+The main advantage over `@Scheduled#delay()` is that the value is configurable.\n+If the value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead: \n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"{myMethod.delay.expr}\") <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The config property `myMethod.delay.expr` is used to set the delay.\n+\n+[[concurrent_execution]]\n+=== Concurrent Execution\n+\n+By default, a scheduled method can be executed concurrently.\n+Nevertheless, it is possible to specify the strategy to handle concurrent executions via `@Scheduled#concurrentExecution()`.\n+\n+[source,java]\n+----\n+import static io.quarkus.scheduler.Scheduled.ConcurrentExection.SKIP;", "originalCommit": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f7e986f7f52460d698c4f650f2068f5420286af", "url": "https://github.com/quarkusio/quarkus/commit/3f7e986f7f52460d698c4f650f2068f5420286af", "message": "Add scheduler reference guide\n\n- also mentions Scheduled#concurrentExecution()", "committedDate": "2020-06-30T14:47:27Z", "type": "forcePushed"}, {"oid": "a2b76920b161ffdbaa4ad2ed427879ddde95734b", "url": "https://github.com/quarkusio/quarkus/commit/a2b76920b161ffdbaa4ad2ed427879ddde95734b", "message": "Add scheduler reference guide\n\n- also mentions Scheduled#concurrentExecution()", "committedDate": "2020-06-30T15:14:09Z", "type": "commit"}, {"oid": "a2b76920b161ffdbaa4ad2ed427879ddde95734b", "url": "https://github.com/quarkusio/quarkus/commit/a2b76920b161ffdbaa4ad2ed427879ddde95734b", "message": "Add scheduler reference guide\n\n- also mentions Scheduled#concurrentExecution()", "committedDate": "2020-06-30T15:14:09Z", "type": "forcePushed"}, {"oid": "5b966047b8fa9639f6e2ff20a0e7df28e50b6d45", "url": "https://github.com/quarkusio/quarkus/commit/5b966047b8fa9639f6e2ff20a0e7df28e50b6d45", "message": "Fix SpringScheduledProcessor", "committedDate": "2020-07-01T06:49:22Z", "type": "commit"}]}