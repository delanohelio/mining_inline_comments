{"pr_number": 13257, "pr_title": "Remove Uni await for OIDC code access token validation and user info calls", "pr_createdAt": "2020-11-12T13:39:15Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13257", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNjU2OA==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522126568", "bodyText": "Why removing the deprecation?", "author": "cescoffier", "createdAt": "2020-11-12T14:01:11Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -35,6 +36,11 @@\n \n @ApplicationScoped\n public class OidcIdentityProvider implements IdentityProvider<TokenAuthenticationRequest> {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private static final Uni<AccessToken> NULL_CODE_ACCESS_TOKEN_UNI = Uni.createFrom().nullItem();", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE0OTI0MA==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522149240", "bodyText": "@cescoffier What do you mean ? AccessToken is deprecated in Vert.x 3.8.x hence I add to avoid the IDE warnings...", "author": "sberyozkin", "createdAt": "2020-11-12T14:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2NTM1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522165355", "bodyText": "ah ok, I was referring to the mutiny part.", "author": "cescoffier", "createdAt": "2020-11-12T14:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNjU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNzA4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522127083", "bodyText": "should be a constant.", "author": "cescoffier", "createdAt": "2020-11-12T14:01:53Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyODY4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522128683", "bodyText": "even if blocking is allowed, it may be not called on the same thread. This method is called on the subscription thread, not the assembly thread.", "author": "cescoffier", "createdAt": "2020-11-12T14:04:10Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2ODc5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522168791", "bodyText": "@cescoffier I'm just trying to follow the same pattern as Stuart does here. I can remove these BlockingOperationContext checks ?\nBut see this comment below, at this point the blocking executor may already be involved due to a refresh token check. My understanding is that in such cases this BlockingOperationControl check would just let that executor thread act as a subscription thread  I'm scared about trying to talk about these terms :-) but it feels like it is correct :-) )", "author": "sberyozkin", "createdAt": "2020-11-12T14:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyODY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3NTM3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522175379", "bodyText": "And yes, it will be gone once that refresh token check becomes Uni async friendy, I'm actually nearly finished in another branch", "author": "sberyozkin", "createdAt": "2020-11-12T15:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyODY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4MTg5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522181899", "bodyText": "Except that in Stuart's code, the check is done at subscription time. You are doing it at assembly time and hope for the best are subscription:\n// This is called at assembly time\nUni.createFrom().emitter(e -> {\n   // This is called at subscription time\n});\nThe thread used at assembly and subscription time may be different. So if assembly time can block, it does not means you can block at subscription time (or the opposite).", "author": "cescoffier", "createdAt": "2020-11-12T15:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyODY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNDY0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522214642", "bodyText": "Hey @cescoffier I'm on it, I'm learning something new here and at this rate I may qualify as a junior Mutiny bug fixer and start helping @jponge :-)", "author": "sberyozkin", "createdAt": "2020-11-12T15:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyODY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyOTE0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522129147", "bodyText": "Any reason to not use Infrastructure.getDEfaultWorkerPool()?", "author": "cescoffier", "createdAt": "2020-11-12T14:04:46Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE1NjQ3NA==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522156474", "bodyText": "@cescoffier It is the same executor which Stuart uses here so I'm just trying to keep it consistent. Perhaps you'd like to open an issue for Stuart (or I can do it) to replace this executor with Infrastructure.getDEfaultWorkerPool() ?", "author": "sberyozkin", "createdAt": "2020-11-12T14:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyOTE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2NTkyNA==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522165924", "bodyText": "it's actually the same pool.", "author": "cescoffier", "createdAt": "2020-11-12T14:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyOTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyOTg0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522129849", "bodyText": "if I'm not mistaken this may be blocking, here you may be on the event loop.", "author": "cescoffier", "createdAt": "2020-11-12T14:05:46Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                    @Override\n+                                    public void run() {\n+                                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext,\n+                                                userInfo);\n+                                    }\n+                                });\n+                            }\n+                        });\n+            }\n+        } else {\n+            return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                @Override\n+                public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                    createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MDM2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522170363", "bodyText": "@cescoffier please see this comment below. Unless it is an opaque token it should be fine to have on the IO thread, because it is a JWT token which is verified by a locally cached JWK keys", "author": "sberyozkin", "createdAt": "2020-11-12T14:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyOTg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522130707", "bodyText": "on which thread is this called? Are you 100% sure it cannot be the event loop?", "author": "cescoffier", "createdAt": "2020-11-12T14:07:00Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                    @Override\n+                                    public void run() {\n+                                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext,\n+                                                userInfo);\n+                                    }\n+                                });\n+                            }\n+                        });\n+            }\n+        } else {\n+            return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                @Override\n+                public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                    createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                }\n+            });\n+        }\n+    }\n \n-                                // Token has been verified, as a JWT or an opaque token, possibly involving\n-                                // an introspection request.\n-                                final TokenCredential tokenCred = request.getToken();\n+    @SuppressWarnings(\"deprecation\")\n+    private void createSecurityIdentityWithOidcServer(UniEmitter<? super SecurityIdentity> uniEmitter,\n+            RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n+        resolvedContext.auth.decodeToken(request.getToken().getToken(),\n+                new Handler<AsyncResult<AccessToken>>() {\n+                    @Override", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMTQzNw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522131437", "bodyText": "where is the blocking call you mentioned earlier?", "author": "cescoffier", "createdAt": "2020-11-12T14:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2MzU4MA==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522163580", "bodyText": "@cescoffier Yeah; so if it is an IdToken which is a case with the code flow - then it is JWT => hence in 99% cases it is a local verification; if it is a bearer token (the one coming with HTTP Authorization) and it is JWT - the same situation. So it is OK to run it on the IO thread.\nBut if either token is opaque (binary) then it must be a remote introspection call done internally by Vert.x as part of this decodeToken call - hence in such cases it is a blocking call.\n\nwhere is the blocking call you mentioned earlier?\n\nRight now, if OIDC is configured to refresh the token then it will run in the blocking executor starting from here, before the decision to verify the token is made, hence this blocking operation control check", "author": "sberyozkin", "createdAt": "2020-11-12T14:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2NzU0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522167545", "bodyText": "Vert.x is doing a blocking call and block the event loop? That would be a first. @pmlopes, isn't this hidden?", "author": "cescoffier", "createdAt": "2020-11-12T14:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2OTI1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522169253", "bodyText": "I guess that for you, as a user, you don't see the Vert.x gymnastics.", "author": "cescoffier", "createdAt": "2020-11-12T14:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4MjQ5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522182491", "bodyText": "I've no knowledge on the mentioned code, but I can assure that the calls from vert.x auth to the idp server are asynchronous. There's no executeBlocking code on vertx-auth-oauth2`", "author": "pmlopes", "createdAt": "2020-11-12T15:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4NjI0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522186241", "bodyText": "HI @cescoffier @pmlopes I think there may be some confusion now, I did not say Vert.x does a blocking call, I meant that since introspection calls are remote it is better for Quarkus OIDC to run them on the blocking executor, this is why we see so many blocked cases, as in case of the issue this PR is trying to fix, etc", "author": "sberyozkin", "createdAt": "2020-11-12T15:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4ODE0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522188146", "bodyText": "@sberyozkin That is a bit confusing. Why \"since introspection calls are remote it is better for Quarkus OIDC to run them on the blocking executor\"?  Where are these calls? In Vert.x (and so non-blocking) or in some other code?", "author": "cescoffier", "createdAt": "2020-11-12T15:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4OTM3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522189371", "bodyText": "Is it just easier for you to handle the validation? But in this case, how do you make the call (as you may mess up with the event loop used to execute the call and go back to blocking indefinitely).", "author": "cescoffier", "createdAt": "2020-11-12T15:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyODY4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522228682", "bodyText": "@cescoffier the introspection calls are in Vert.x OAuth2, they are non-blocking (i.e async) but the introspection call is expensive, so we use the Executor for all such remote calls (introspection - starting from this PR, refresh tokens, OIDC connection resolution) and userinfo; IMHO it is OK, perhaps we can revisit it as part of a separate issue, but I believe it is not a bad idea...", "author": "sberyozkin", "createdAt": "2020-11-12T16:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzMjA2MA==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522232060", "bodyText": "@cescoffier the previous PR where you helped with splitting the tenant context resolution was related to a remote tenant connection resolution which was run on IO thread in one code branch...even though in Vert.x it is an async call", "author": "sberyozkin", "createdAt": "2020-11-12T16:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMTAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522131024", "bodyText": "better failing and not throwing.", "author": "cescoffier", "createdAt": "2020-11-12T14:07:24Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                    @Override\n+                                    public void run() {\n+                                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext,\n+                                                userInfo);\n+                                    }\n+                                });\n+                            }\n+                        });\n+            }\n+        } else {\n+            return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                @Override\n+                public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                    createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                }\n+            });\n+        }\n+    }\n \n-                                // Token has been verified, as a JWT or an opaque token, possibly involving\n-                                // an introspection request.\n-                                final TokenCredential tokenCred = request.getToken();\n+    @SuppressWarnings(\"deprecation\")\n+    private void createSecurityIdentityWithOidcServer(UniEmitter<? super SecurityIdentity> uniEmitter,\n+            RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n+        resolvedContext.auth.decodeToken(request.getToken().getToken(),\n+                new Handler<AsyncResult<AccessToken>>() {\n+                    @Override\n+                    public void handle(AsyncResult<AccessToken> event) {\n+                        if (event.failed()) {\n+                            uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n+                            return;\n+                        }\n \n-                                JsonObject tokenJson = event.result().accessToken();\n+                        // Token has been verified, as a JWT or an opaque token, possibly involving\n+                        // an introspection request.\n+                        final TokenCredential tokenCred = request.getToken();\n \n-                                if (tokenJson == null) {\n-                                    // JSON token representation may be null not only if it is an opaque access token\n-                                    // but also if it is JWT and no JWK with a matching kid is available, asynchronous\n-                                    // JWK refresh has not finished yet, but the fallback introspection request has succeeded.\n-                                    tokenJson = OidcUtils.decodeJwtContent(tokenCred.getToken());\n-                                }\n-                                if (tokenJson != null) {\n-                                    OidcUtils.validatePrimaryJwtTokenType(resolvedContext.oidcConfig.token, tokenJson);\n-                                    JsonObject rolesJson = getRolesJson(vertxContext, resolvedContext, tokenCred, tokenJson,\n-                                            userInfo);\n-                                    try {\n-                                        SecurityIdentity securityIdentity = validateAndCreateIdentity(vertxContext, tokenCred,\n-                                                resolvedContext.oidcConfig,\n-                                                tokenJson, rolesJson, userInfo);\n-                                        if (tokenAutoRefreshPrepared(tokenJson, vertxContext, resolvedContext.oidcConfig)) {\n-                                            throw new TokenAutoRefreshException(securityIdentity);\n-                                        } else {\n-                                            uniEmitter.complete(securityIdentity);\n-                                        }\n-                                    } catch (Throwable ex) {\n-                                        uniEmitter.fail(ex);\n-                                    }\n-                                } else if (tokenCred instanceof IdTokenCredential\n-                                        || tokenCred instanceof AccessTokenCredential\n-                                                && !((AccessTokenCredential) tokenCred).isOpaque()) {\n-                                    uniEmitter\n-                                            .fail(new AuthenticationFailedException(\"JWT token can not be converted to JSON\"));\n+                        JsonObject tokenJson = event.result().accessToken();\n+\n+                        if (tokenJson == null) {\n+                            // JSON token representation may be null not only if it is an opaque access token\n+                            // but also if it is JWT and no JWK with a matching kid is available, asynchronous\n+                            // JWK refresh has not finished yet, but the fallback introspection request has succeeded.\n+                            tokenJson = OidcUtils.decodeJwtContent(tokenCred.getToken());\n+                        }\n+                        if (tokenJson != null) {\n+                            OidcUtils.validatePrimaryJwtTokenType(resolvedContext.oidcConfig.token, tokenJson);\n+                            JsonObject rolesJson = getRolesJson(vertxContext, resolvedContext, tokenCred, tokenJson,\n+                                    userInfo);\n+                            try {\n+                                SecurityIdentity securityIdentity = validateAndCreateIdentity(vertxContext, tokenCred,\n+                                        resolvedContext.oidcConfig,\n+                                        tokenJson, rolesJson, userInfo);\n+                                if (tokenAutoRefreshPrepared(tokenJson, vertxContext, resolvedContext.oidcConfig)) {\n+                                    throw new TokenAutoRefreshException(securityIdentity);", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMjg5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522132895", "bodyText": "again, may be a different thread. assembly and subscription threads different might be different.", "author": "cescoffier", "createdAt": "2020-11-12T14:09:59Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -224,23 +286,62 @@ private static JsonObject getRolesJson(RoutingContext vertxContext, TenantConfig\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private static AccessToken verifyCodeFlowAccessToken(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<AccessToken> verifyCodeFlowAccessTokenUni(RoutingContext vertxContext, TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super AccessToken>>() {\n-            @Override\n-            public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n-                resolvedContext.auth.decodeToken((String) vertxContext.get(\"access_token\"),\n-                        new Handler<AsyncResult<AccessToken>>() {\n-                            @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n+        if (request.getToken() instanceof IdTokenCredential\n+                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n+                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n+            final String codeAccessToken = (String) vertxContext.get(\"access_token\");\n+            if (OidcUtils.isOpaqueToken(codeAccessToken)) {\n+                // remote introspection is required, a blocking call\n+                if (BlockingOperationControl.isBlockingAllowed()) {\n+                    return Uni.createFrom().emitter(\n+                            new Consumer<UniEmitter<? super AccessToken>>() {\n+                                @Override\n+                                public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n+                                    verifyCodeFlowAccessToken(uniEmitter, resolvedContext, codeAccessToken);", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MjMwNw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522172307", "bodyText": "@cescoffier please see the comment above about this BlockingOperationControl check, I think it is correct for now", "author": "sberyozkin", "createdAt": "2020-11-12T15:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4Mjk5NA==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522182994", "bodyText": "I don't believe it is.", "author": "cescoffier", "createdAt": "2020-11-12T15:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4NzI4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522187281", "bodyText": "@cescoffier This code just tries to run the remote operations in the executor, what is not correct about it ?", "author": "sberyozkin", "createdAt": "2020-11-12T15:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4OTEzNw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522189137", "bodyText": "@cescoffier never mind, let me think about your assembly vs subscription clarification above", "author": "sberyozkin", "createdAt": "2020-11-12T15:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMjg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzNjYxMw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522136613", "bodyText": "I don't get why sometimes it must be wrapped on an executor and sometimes not.", "author": "cescoffier", "createdAt": "2020-11-12T14:15:12Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -224,23 +286,62 @@ private static JsonObject getRolesJson(RoutingContext vertxContext, TenantConfig\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private static AccessToken verifyCodeFlowAccessToken(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<AccessToken> verifyCodeFlowAccessTokenUni(RoutingContext vertxContext, TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super AccessToken>>() {\n-            @Override\n-            public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n-                resolvedContext.auth.decodeToken((String) vertxContext.get(\"access_token\"),\n-                        new Handler<AsyncResult<AccessToken>>() {\n-                            @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n+        if (request.getToken() instanceof IdTokenCredential\n+                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n+                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n+            final String codeAccessToken = (String) vertxContext.get(\"access_token\");\n+            if (OidcUtils.isOpaqueToken(codeAccessToken)) {\n+                // remote introspection is required, a blocking call\n+                if (BlockingOperationControl.isBlockingAllowed()) {\n+                    return Uni.createFrom().emitter(\n+                            new Consumer<UniEmitter<? super AccessToken>>() {\n+                                @Override\n+                                public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n+                                    verifyCodeFlowAccessToken(uniEmitter, resolvedContext, codeAccessToken);\n                                 }\n-                                uniEmitter.complete(event.result());\n-                            }\n-                        });\n+                            });\n+                } else {\n+                    return Uni.createFrom().emitter(\n+                            new Consumer<UniEmitter<? super AccessToken>>() {\n+                                @Override\n+                                public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n+                                    tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            verifyCodeFlowAccessToken(uniEmitter, resolvedContext, codeAccessToken);\n+                                        }\n+                                    });\n+                                }\n+                            });\n+                }\n+            } else {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super AccessToken>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n+                        verifyCodeFlowAccessToken(uniEmitter, resolvedContext, codeAccessToken);", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3Nzc5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522177797", "bodyText": "@cescoffier Please see above, this and this comments", "author": "sberyozkin", "createdAt": "2020-11-12T15:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzNjYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzNjk2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522136963", "bodyText": "Again, same issue.", "author": "cescoffier", "createdAt": "2020-11-12T14:15:42Z", "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -266,33 +367,57 @@ public void handle(AsyncResult<AccessToken> event) {\n         }\n     }\n \n-    private static JsonObject getUserInfo(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<JsonObject> getUserInfoUni(RoutingContext vertxContext, TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n+        if (resolvedContext.oidcConfig.authentication.isUserInfoRequired()) {\n+            if (BlockingOperationControl.isBlockingAllowed()) {", "originalCommit": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3OTY0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522179645", "bodyText": "@cescoffier sure, hope the above comments, this and this ones, will clarify it :-)", "author": "sberyozkin", "createdAt": "2020-11-12T15:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzNjk2Mw=="}], "type": "inlineReview"}, {"oid": "994c6b8caecfa7c9cabc8346f57a943cb2879b35", "url": "https://github.com/quarkusio/quarkus/commit/994c6b8caecfa7c9cabc8346f57a943cb2879b35", "message": "Remove Uni await for OIDC code access token validation and user info calls", "committedDate": "2020-11-12T15:15:23Z", "type": "forcePushed"}, {"oid": "4a2afc076575abaac486c5d23b698b2e6d8594ef", "url": "https://github.com/quarkusio/quarkus/commit/4a2afc076575abaac486c5d23b698b2e6d8594ef", "message": "Remove Uni await for OIDC code access token validation and user info calls", "committedDate": "2020-11-12T16:05:23Z", "type": "commit"}, {"oid": "4a2afc076575abaac486c5d23b698b2e6d8594ef", "url": "https://github.com/quarkusio/quarkus/commit/4a2afc076575abaac486c5d23b698b2e6d8594ef", "message": "Remove Uni await for OIDC code access token validation and user info calls", "committedDate": "2020-11-12T16:05:23Z", "type": "forcePushed"}]}