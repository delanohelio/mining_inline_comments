{"pr_number": 9462, "pr_title": "Add a TROUBLESHOOTING.md page with performance related tips", "pr_createdAt": "2020-05-19T15:33:32Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9462", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNTM3NA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427435374", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Or definitively using `sysctl`:\n          \n          \n            \n            Or permanently using `sysctl`:", "author": "geoand", "createdAt": "2020-05-19T16:26:58Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNTUyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427435521", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For your session:\n          \n          \n            \n            For your terminal session:", "author": "geoand", "createdAt": "2020-05-19T16:27:10Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNjU0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427436542", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n          \n          \n            \n            If you want a deeper introduction to Async Profiler, do checkout [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).", "author": "geoand", "createdAt": "2020-05-19T16:28:38Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNjk4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427436989", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            you must make some OS configuration.\n          \n          \n            \n            you must first apply a couple OS configuration options.", "author": "geoand", "createdAt": "2020-05-19T16:29:18Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTA4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427439085", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n          \n          \n            \n            If needed, see [this](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling) section in the documentation site for details.", "author": "geoand", "createdAt": "2020-05-19T16:32:16Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTYzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471631", "bodyText": "what is documentation site?", "author": "gsmet", "createdAt": "2020-05-19T17:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MzYzMA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427793630", "bodyText": "In fact it's the README of Async Profiler, there is no documentation site.\nMaybe I can re-phrase to section in the Async Profiler site.", "author": "loicmathieu", "createdAt": "2020-05-20T07:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MDI1OA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427440258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n          \n          \n            \n            To profile application while it is running, it is recommended to use the command line as you can choose when to start the profiler and prevent your profile data from being bloated with startup events. <br/>", "author": "geoand", "createdAt": "2020-05-19T16:33:41Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTk5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471991", "bodyText": "Let's remove all the <br/>", "author": "gsmet", "createdAt": "2020-05-19T17:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MDI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MzkyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427793921", "bodyText": "I'll change all the <br/> to double space.", "author": "loicmathieu", "createdAt": "2020-05-20T07:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MDI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTIxNA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427441214", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n          \n          \n            \n            This can be important as any application performs a lot of bootstrapping operation upon startup that won't occur at any other during the application lifecycle. <br/>", "author": "geoand", "createdAt": "2020-05-19T16:35:08Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTQ4NA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427441484", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n          \n          \n            \n            By starting the profiling on demand, you prevent these bootstrap instructions from being part of the profile data.", "author": "geoand", "createdAt": "2020-05-19T16:35:37Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427441911", "bodyText": "Maybe we  should have some links for wrk(2), gatling, hyperfoil etc...", "author": "geoand", "createdAt": "2020-05-19T16:36:17Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5NDk1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427794955", "bodyText": "There is so many tools and some are paid so I don' want us to promote some over others ...\nAdding links seems to promote these tools.", "author": "loicmathieu", "createdAt": "2020-05-20T07:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNzM1OA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427827358", "bodyText": "I don't agree, but I won't fight it :).\nFor example we probably do want to be linking to wrk2 instead of wrk, it's too easy for people to get confused.", "author": "geoand", "createdAt": "2020-05-20T08:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NTMyOA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427845328", "bodyText": "OK, so maybe I can add some commonly tools with there links: ab, wrk2, Gatling, Apache JMeter at least ...", "author": "loicmathieu", "createdAt": "2020-05-20T08:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0Njg0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427846846", "bodyText": "Sounds good to me, \ud83d\udc4d", "author": "geoand", "createdAt": "2020-05-20T08:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg2MDU1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427860559", "bodyText": "Updated", "author": "loicmathieu", "createdAt": "2020-05-20T09:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg3NTc0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427875745", "bodyText": "If are going to link to tools, we want to link to tools that we know do not suffer from co-ordination ommission problems, otherwise we end up with issues like this: #9202", "author": "johnaohara", "createdAt": "2020-05-20T09:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg3NjU5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427876597", "bodyText": "Maye this should be a separate doc with list of tools that we use, and how to use them?", "author": "johnaohara", "createdAt": "2020-05-20T09:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NDI2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427894267", "bodyText": "I can remove ab from the list.\nAs I previously said, load testing is a vast and debatable subject.\nThere is multiple type of tools (URL basher, scenario based load testing, ...), some are paid some are free, some uses complex injectors, ...\nAnd using these tools is far from easy ...\nI added these ones because these are the one I'm used to, but any will works to generates a profile (not any will works to simulate correctly user interaction).\nI'm open to suggestion here, we can add a section about them or create a dedicated page for them later.\nWe also have the performance page where we can add some section to tools used to generate load: https://quarkus.io/guides/performance-measure\nMaybe we need to link this page inside the performance page ?", "author": "loicmathieu", "createdAt": "2020-05-20T10:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzY5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427443691", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n          \n          \n            \n            It is usually advised to profile an application under load. Such load could be created by a load generator tool (wrk, gatling, ...)", "author": "geoand", "createdAt": "2020-05-19T16:39:11Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NDkxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427444915", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n          \n          \n            \n            and to start profiling only after some warmup time to allow Java's Just In Time compiler of Java to optimize your application code (not to mention giving the opportunity for database caches to warmup, etc...).", "author": "geoand", "createdAt": "2020-05-19T16:41:02Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTAxMA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427445010", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To start CPU profiling, enter the following command:\n          \n          \n            \n            To start CPU profiling, execute the following command:", "author": "geoand", "createdAt": "2020-05-19T16:41:13Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTE3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427445171", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n          \n          \n            \n            `-b 4000000` is used to increase the frame buffer size as the default is often too small.", "author": "geoand", "createdAt": "2020-05-19T16:41:30Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTQ3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427445479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n          \n          \n            \n            To end profiling and gather the results you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>", "author": "geoand", "createdAt": "2020-05-19T16:41:59Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mjg5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427472897", "bodyText": "s/this will tells/this will tell/", "author": "gsmet", "createdAt": "2020-05-19T17:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTgyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427445821", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n          \n          \n            \n            It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the `svg` file extension)", "author": "geoand", "createdAt": "2020-05-19T16:42:32Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MzQwNg==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427473406", "bodyText": "s/automatically detect/automatically detects/", "author": "gsmet", "createdAt": "2020-05-19T17:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NjcwOA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427446708", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n          \n          \n            \n            One very useful option is `-s` (or `--simple`) that results in simple class names being used instead of FQDNs, thus making the FlameGraph more readable (at cost of not showing the package names of classes). <br/>", "author": "geoand", "createdAt": "2020-05-19T16:43:52Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mzg3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427473877", "bodyText": "FQCNs?", "author": "gsmet", "createdAt": "2020-05-19T17:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NjcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NzI1NA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427447254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To start allocation profiling, enter the following command:\n          \n          \n            \n            To start allocation profiling, execute the following command:", "author": "geoand", "createdAt": "2020-05-19T16:44:42Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0ODE5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427448197", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n          \n          \n            \n            `-e` (or `--event`) allow to specify the type of event to profile. The default profile type is CPU, but in this case as we are interested in allocation profiling, we specify `alloc` as the `-e` value.", "author": "geoand", "createdAt": "2020-05-19T16:46:12Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0ODYzMA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427448630", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then you can stop your profiling the same way as for CPU profiling.\n          \n          \n            \n            Stopping allocation profiling is done in the same way as for the previously shown CPU profiling.", "author": "geoand", "createdAt": "2020-05-19T16:46:53Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0OTAwOA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427449008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here is some example command lines:\n          \n          \n            \n            Some example usages are:", "author": "geoand", "createdAt": "2020-05-19T16:47:28Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0OTI1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427449255", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Be careful that short options are not supported inside the agent, you need to use the long version.\n          \n          \n            \n            Note that short options are not supported inside the agent, you need to use their long versions.", "author": "geoand", "createdAt": "2020-05-19T16:47:48Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MDA3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427450076", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n          \n          \n            \n            By default, Async Profiler sample events every 10ms. When it comes to profiling / debugging a Quarkus startup issue, this value is often too high as Quarkus starst very fast ;) <br/>", "author": "geoand", "createdAt": "2020-05-19T16:49:07Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475024", "bodyText": "I would remove the smiley.", "author": "gsmet", "createdAt": "2020-05-19T17:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MDA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5NjQ2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427796466", "bodyText": "OK, and maybe the typo of @geoand starst => starts :)", "author": "loicmathieu", "createdAt": "2020-05-20T07:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MDA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MDUxOA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427450518", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            That's why I configure the profiling interval to 1000000ns (so 1ms).\n          \n          \n            \n            For that reason, it is not uncommon to configure the profiling interval to 1000000ns (i.e. 1ms).", "author": "geoand", "createdAt": "2020-05-19T16:49:52Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MTU4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427451587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n          \n          \n            \n            For profiling Quarkus dev mode, the Java agent is again necessary. It can be used in the same way as for the production application with the exception that `agentpath` option needs to be set via the `jvm.args` system property.", "author": "geoand", "createdAt": "2020-05-19T16:51:27Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTc1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475753", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # On CentOS, RHEL and some other RPM-based distributions\n          \n          \n            \n            # On CentOS, RHEL and some other RPM-based distributions - Java 8", "author": "johnaohara", "createdAt": "2020-05-19T17:29:46Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTgxOA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427469818", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To help us to troubleshoot your issues, we will need some performance insight from your application.\n          \n          \n            \n            To help us troubleshooting your issues, we will need some performance insights from your application.", "author": "gsmet", "createdAt": "2020-05-19T17:20:41Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MDYwNA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427790604", "bodyText": "Gracie plugin of IntelliJ suggests to replace troubleshooting by to troubleshoot. But maybe it's a difference between english english and american english ?", "author": "loicmathieu", "createdAt": "2020-05-20T07:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzMjQxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427832415", "bodyText": "Maybe @geoand can share some light on to troubleshoot vs troubleshooting ?", "author": "loicmathieu", "createdAt": "2020-05-20T08:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzNTg1NA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427835854", "bodyText": "I am definitely not an English grammar expert (having grown up bilingual but crucially, not having attended English speaking school), but for the most corrent way of saying it would be:\nTo help us troubleshoot", "author": "geoand", "createdAt": "2020-05-20T08:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NDI2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427844263", "bodyText": "OK, done.", "author": "loicmathieu", "createdAt": "2020-05-20T08:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTkzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427469939", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n          \n          \n            \n            On Linux or macOS, one of the best way to gather performance insights would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph)", "author": "gsmet", "createdAt": "2020-05-19T17:20:54Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) ", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MDQwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427470409", "bodyText": "<br/>? Maybe we can avoid that :)", "author": "gsmet", "createdAt": "2020-05-19T17:21:36Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MTg5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427791897", "bodyText": "Apparently two or more spaces do the same: it break the line without creating a new paragraph.\nDidn't know this as <br/> also works.", "author": "loicmathieu", "createdAt": "2020-05-20T07:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MDQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDY2MA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427820660", "bodyText": "Replaces all <br/> with two spaces.", "author": "loicmathieu", "createdAt": "2020-05-20T08:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MDQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTAzOA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471038", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For allocation profiling, you also need to install HotStop debug symbol.\n          \n          \n            \n            For allocation profiling, you also need to install HotSpot debug symbol.", "author": "gsmet", "createdAt": "2020-05-19T17:22:32Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTM0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471342", "bodyText": "I'm not sure I would recommend that. I think most people don't use the JDK from the distribution.", "author": "gsmet", "createdAt": "2020-05-19T17:23:01Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MzAxNg==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427793016", "bodyText": "The way to install debug info on a non-distribution JDK is way harder, you need to download it and build it (and building C code can fail in a lot of possible ways).\nI can find a link to add but it's way easier to install it this way and use the JDK from the distribution to launch the application.", "author": "loicmathieu", "createdAt": "2020-05-20T07:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDQ1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427820456", "bodyText": "In fact you need to build your own JDK ...\nIn this case I would suggest to use a fastdebug build, it will be a slower JVM (JVM asserts will be enabled) but it includes debug symbols so it will works.", "author": "loicmathieu", "createdAt": "2020-05-20T08:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzNTMwMw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427835303", "bodyText": "I added a reference to fastdebug builds, didn't include a specific link but I could add one to https://builds.shipilev.net/ it's the only place I know where you can find those builds", "author": "loicmathieu", "createdAt": "2020-05-20T08:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTc1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471755", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Asych Profiler comes with a Java agent, and a command line.\n          \n          \n            \n            Async Profiler comes with a Java agent, and a command line.", "author": "gsmet", "createdAt": "2020-05-19T17:23:40Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MjU5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427472593", "bodyText": "It's unclear where profiler.sh comes from.", "author": "gsmet", "createdAt": "2020-05-19T17:25:03Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0MzY4OA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427843688", "bodyText": "I /path/to/asynch-profiler to be clear.", "author": "loicmathieu", "createdAt": "2020-05-20T08:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MjU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MzA5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427473097", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n          \n          \n            \n            The output is a text file that is not really usable, so let's use our preferred performance representation: the FlameGraph.", "author": "gsmet", "createdAt": "2020-05-19T17:25:47Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NDAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427474024", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n          \n          \n            \n            You can also limit the profiling duration by using `-d` (or `--duration`) followed by the duration in seconds.", "author": "gsmet", "createdAt": "2020-05-19T17:27:11Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTMzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475331", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.\n          \n          \n            \n            You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` section of your pom.xml.", "author": "gsmet", "createdAt": "2020-05-19T17:29:09Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n+\n+```shell script\n+# profile CPU startup\n+mvn quarkus:dev -Djvm.args=\"agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\"\n+\n+# profile allocation startup\n+mvn quarkus:dev -Djvm.args=\"-agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\"\n+```\n+\n+You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTQ0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475443", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## And what about Windows ?\n          \n          \n            \n            ## And what about Windows?", "author": "gsmet", "createdAt": "2020-05-19T17:29:19Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n+\n+```shell script\n+# profile CPU startup\n+mvn quarkus:dev -Djvm.args=\"agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\"\n+\n+# profile allocation startup\n+mvn quarkus:dev -Djvm.args=\"-agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\"\n+```\n+\n+You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.\n+\n+## And what about Windows ?", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTU2NA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475564", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The following java options will enable JFR to record profiling data inside a `myrecording.jfr` file that can then be used by JMC - Java Mission Control for analysis.\n          \n          \n            \n            The following Java options will enable JFR to record profiling data inside a `myrecording.jfr` file that can then be used by JMC - Java Mission Control for analysis.", "author": "gsmet", "createdAt": "2020-05-19T17:29:32Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n+\n+```shell script\n+# profile CPU startup\n+mvn quarkus:dev -Djvm.args=\"agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\"\n+\n+# profile allocation startup\n+mvn quarkus:dev -Djvm.args=\"-agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\"\n+```\n+\n+You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.\n+\n+## And what about Windows ?\n+\n+If you are on Windows, you can still get useful performance insights using JFR - Java Flight Recorder.\n+\n+The following java options will enable JFR to record profiling data inside a `myrecording.jfr` file that can then be used by JMC - Java Mission Control for analysis.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTc4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475785", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here I configure JFR with a deeper stack depth as the default is usually not enough.\n          \n          \n            \n            Here we configure JFR with a deeper stack depth as the default is usually not enough.", "author": "gsmet", "createdAt": "2020-05-19T17:29:49Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n+\n+```shell script\n+# profile CPU startup\n+mvn quarkus:dev -Djvm.args=\"agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\"\n+\n+# profile allocation startup\n+mvn quarkus:dev -Djvm.args=\"-agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\"\n+```\n+\n+You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.\n+\n+## And what about Windows ?\n+\n+If you are on Windows, you can still get useful performance insights using JFR - Java Flight Recorder.\n+\n+The following java options will enable JFR to record profiling data inside a `myrecording.jfr` file that can then be used by JMC - Java Mission Control for analysis.\n+\n+```shell script\n+-XX:+FlightRecorder -XX:StartFlightRecording=filename=myrecording.jfr,settings=profile -XX:FlightRecorderOptions=stackdepth=64\n+```\n+\n+Here I configure JFR with a deeper stack depth as the default is usually not enough.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjEyOA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427476128", "bodyText": "General comment: s/FlameGraphs/flame graphs/g", "author": "gsmet", "createdAt": "2020-05-19T17:30:14Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxOTg4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427819886", "bodyText": "Done", "author": "loicmathieu", "createdAt": "2020-05-20T08:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyMDkyMA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427820920", "bodyText": "done", "author": "loicmathieu", "createdAt": "2020-05-20T08:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MTk0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427481949", "bodyText": "I wanted to add a suggestion here, but suggestion syntax is the same as a code block;\nOn CentOS, RHEL and some other RPM-based distributions - Java 11\ndebuginfo-install java-11-openjdk", "author": "johnaohara", "createdAt": "2020-05-19T17:39:17Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxOTc5NA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427819794", "bodyText": "Added", "author": "loicmathieu", "createdAt": "2020-05-20T08:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MTk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjQzOA==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427486438", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n          \n          \n            \n            You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds. If you use the `--duration` option, the output file will be created automatically at the end of the duration period. You do not need to start and stop the profiler.", "author": "johnaohara", "createdAt": "2020-05-19T17:46:17Z", "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.", "originalCommit": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc4OTQ5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427789493", "bodyText": "I think we still need to start the profiler so it should be\n\nYou do not need to stop the profiler.", "author": "loicmathieu", "createdAt": "2020-05-20T07:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgwMDQ5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427800491", "bodyText": "If you execute ;\n$ ./profiler.sh -d 30 <pid>\n\nThis is the same as;\n$ ./profiler.sh start <pid>\n$ sleep 30\n$ ./profiler.sh stop <pid>\n\nThis will attach the profiler to process <pid>, run for 30s then stop and write the output. A user does not need to execute $ ./profiler.sh start -b <pid> beforehand\nMaybe this should be clearer, e.g. \"You do not need to explicitly start and stop the profiler.\"", "author": "johnaohara", "createdAt": "2020-05-20T07:35:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxOTY1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427819653", "bodyText": "Ah OK, so start is the default command!", "author": "loicmathieu", "createdAt": "2020-05-20T08:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzNTcxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427835715", "bodyText": "Done", "author": "loicmathieu", "createdAt": "2020-05-20T08:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjQzOA=="}], "type": "inlineReview"}, {"oid": "68c7e8bf8f3d57c139151976a61f4d41ecb66d1e", "url": "https://github.com/quarkusio/quarkus/commit/68c7e8bf8f3d57c139151976a61f4d41ecb66d1e", "message": "Add a TROUBLESHOOTING.md page with performance related tips", "committedDate": "2020-05-20T08:07:37Z", "type": "forcePushed"}, {"oid": "cbf487948c19603fea184fbb564d85b3d739cdc8", "url": "https://github.com/quarkusio/quarkus/commit/cbf487948c19603fea184fbb564d85b3d739cdc8", "message": "Add a TROUBLESHOOTING.md page with performance related tips", "committedDate": "2020-05-20T08:31:51Z", "type": "forcePushed"}, {"oid": "50c8f13a4c49231ca2996d5c3e40d96a4c124478", "url": "https://github.com/quarkusio/quarkus/commit/50c8f13a4c49231ca2996d5c3e40d96a4c124478", "message": "Add a TROUBLESHOOTING.md page with performance related tips", "committedDate": "2020-05-20T08:47:56Z", "type": "forcePushed"}, {"oid": "7db7c044658c666c5ad94b0d05bcd791e3cede95", "url": "https://github.com/quarkusio/quarkus/commit/7db7c044658c666c5ad94b0d05bcd791e3cede95", "message": "Add a TROUBLESHOOTING.md page with performance related tips", "committedDate": "2020-05-20T09:10:42Z", "type": "commit"}, {"oid": "7db7c044658c666c5ad94b0d05bcd791e3cede95", "url": "https://github.com/quarkusio/quarkus/commit/7db7c044658c666c5ad94b0d05bcd791e3cede95", "message": "Add a TROUBLESHOOTING.md page with performance related tips", "committedDate": "2020-05-20T09:10:42Z", "type": "forcePushed"}]}