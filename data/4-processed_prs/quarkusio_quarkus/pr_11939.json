{"pr_number": 11939, "pr_title": "JSON exporter for Micrometer", "pr_createdAt": "2020-09-07T12:07:59Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/11939", "timeline": [{"oid": "4c02b0498c26a6dd697b6cae106273d3183d8b5a", "url": "https://github.com/quarkusio/quarkus/commit/4c02b0498c26a6dd697b6cae106273d3183d8b5a", "message": "move /metrics-json endpoint to /metrics", "committedDate": "2020-09-08T07:47:20Z", "type": "forcePushed"}, {"oid": "73d5e13ca496c26e8732dc96b7b49819017514a9", "url": "https://github.com/quarkusio/quarkus/commit/73d5e13ca496c26e8732dc96b7b49819017514a9", "message": "move /metrics-json endpoint to /metrics", "committedDate": "2020-09-08T07:51:08Z", "type": "forcePushed"}, {"oid": "ff7837b90af707fc5795c53f44390bd9c8e72e73", "url": "https://github.com/quarkusio/quarkus/commit/ff7837b90af707fc5795c53f44390bd9c8e72e73", "message": "move /metrics-json endpoint to /metrics", "committedDate": "2020-09-08T08:55:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MjYyMw==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r484992623", "bodyText": "You don't need the indirection..\n    gauge = io.micrometer.core.instrument.Gauge.builder(metricInfo.name(), longAdder, LongAdder::doubleValue)", "author": "ebullient", "createdAt": "2020-09-08T15:03:26Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/mpmetrics/ConcurrentGaugeImpl.java", "diffHunk": "@@ -14,7 +15,8 @@\n     Gauge gauge;\n \n     ConcurrentGaugeImpl register(MpMetadata metadata, MetricDescriptor metricInfo, MeterRegistry registry) {\n-        gauge = io.micrometer.core.instrument.Gauge.builder(metricInfo.name(), longAdder::longValue)\n+        ToDoubleFunction<LongAdder> function = LongAdder::doubleValue;\n+        gauge = io.micrometer.core.instrument.Gauge.builder(metricInfo.name(), longAdder, function)", "originalCommit": "93546ccbb6a589f43dea8e7b7cc15c48126cf4d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5OTA3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r484999072", "bodyText": "I still am not sure how the two registries are interacting, but I think it is clear that when both are present, the way the json registry observes the value of the gauge causes the prometheus registry value to observe NaN, and that breaks the planet. ;)  Switching over to invoking a method on the object is fine, but we should avoid allocation of ToDoubleFunction for each instance. We could make that lambda a static, or we could use a method on the object:\n    double getDoubleValue() {\n        return getValue().doubleValue();\n    }\n\nand reference that:\n                gauge = io.micrometer.core.instrument.Gauge.builder(metadata.name, this, GaugeAdapterImpl::getDoubleValue)", "author": "ebullient", "createdAt": "2020-09-08T15:12:58Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/mpmetrics/AnnotatedGaugeAdapter.java", "diffHunk": "@@ -52,7 +53,8 @@ public GaugeAdapterImpl(String name, String description, String targetName, Stri\n         public GaugeAdapterImpl register(MetricDescriptor id, MeterRegistry registry) {\n             this.id = id;\n             if (gauge == null || metadata.cleanDirtyMetadata()) {\n-                gauge = io.micrometer.core.instrument.Gauge.builder(metadata.name, this::getValue)\n+                ToDoubleFunction<GaugeAdapterImpl> function = i -> i.getValue().doubleValue();\n+                gauge = io.micrometer.core.instrument.Gauge.builder(metadata.name, this, function)", "originalCommit": "93546ccbb6a589f43dea8e7b7cc15c48126cf4d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwMDAwMA==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485000000", "bodyText": "Execution of this step should still be guarded as others are.", "author": "ebullient", "createdAt": "2020-09-08T15:14:18Z", "path": "extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/export/JsonRegistryProcessor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.quarkus.micrometer.deployment.export;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.micrometer.deployment.MicrometerRegistryProviderBuildItem;\n+import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n+import io.quarkus.micrometer.runtime.export.JsonMeterRegistryProvider;\n+import io.quarkus.micrometer.runtime.export.JsonRecorder;\n+import io.quarkus.micrometer.runtime.registry.json.JsonMeterRegistry;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+\n+public class JsonRegistryProcessor {\n+\n+    private static final Logger log = Logger.getLogger(JsonRegistryProcessor.class);\n+\n+    @BuildStep\n+    @Record(ExecutionTime.STATIC_INIT)", "originalCommit": "93546ccbb6a589f43dea8e7b7cc15c48126cf4d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTQ3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485345475", "bodyText": "Why exactly is it useful to wrap it into a BooleanSupplier that checks whether the configuration enables it, instead of simply doing the same by an if condition in the method? Other extensions do it this way, including those where you wrote this code (HibernateOrmMetricsProcessor).", "author": "jmartisk", "createdAt": "2020-09-09T05:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwMDAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwMDMwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485000309", "bodyText": "Why is reflection necessary for these classes? I'm missing something", "author": "ebullient", "createdAt": "2020-09-08T15:14:48Z", "path": "extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/export/JsonRegistryProcessor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.quarkus.micrometer.deployment.export;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.micrometer.deployment.MicrometerRegistryProviderBuildItem;\n+import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n+import io.quarkus.micrometer.runtime.export.JsonMeterRegistryProvider;\n+import io.quarkus.micrometer.runtime.export.JsonRecorder;\n+import io.quarkus.micrometer.runtime.registry.json.JsonMeterRegistry;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+\n+public class JsonRegistryProcessor {\n+\n+    private static final Logger log = Logger.getLogger(JsonRegistryProcessor.class);\n+\n+    @BuildStep\n+    @Record(ExecutionTime.STATIC_INIT)\n+    public void initializeJsonRegistry(MicrometerConfig config,\n+            BuildProducer<MicrometerRegistryProviderBuildItem> registryProviders,\n+            BuildProducer<RouteBuildItem> routes,\n+            BuildProducer<AdditionalBeanBuildItem> additionalBeans,\n+            JsonRecorder recorder,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClasses) {\n+        if (config.checkRegistryEnabledWithDefault(config.export.json)) {\n+            additionalBeans.produce(AdditionalBeanBuildItem.builder()\n+                    .addBeanClass(JsonMeterRegistryProvider.class)\n+                    .setUnremovable().build());\n+            registryProviders.produce(new MicrometerRegistryProviderBuildItem(JsonMeterRegistry.class));\n+            routes.produce(new RouteBuildItem(recorder.route(config.export.json.path), recorder.getHandler()));\n+            reflectiveClasses.produce(ReflectiveClassBuildItem\n+                    .builder(\"org.HdrHistogram.Histogram\",\n+                            \"org.HdrHistogram.DoubleHistogram\",\n+                            \"org.HdrHistogram.ConcurrentHistogram\")\n+                    .constructors(true).build());", "originalCommit": "93546ccbb6a589f43dea8e7b7cc15c48126cf4d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2MzExMg==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485363112", "bodyText": "I don't know, but without this, native mode breaks.", "author": "jmartisk", "createdAt": "2020-09-09T06:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwMDMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNTcwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485015705", "bodyText": "I would like to understand where these values come from. Negative values don't seem correct for an out-of-the-box default. Can we talk through this?", "author": "ebullient", "createdAt": "2020-09-08T15:36:44Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/registry/json/JsonMeterRegistry.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package io.quarkus.micrometer.runtime.registry.json;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToLongFunction;\n+\n+import io.micrometer.core.instrument.Clock;\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.DistributionSummary;\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.FunctionTimer;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.LongTaskTimer;\n+import io.micrometer.core.instrument.Measurement;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Timer;\n+import io.micrometer.core.instrument.cumulative.CumulativeCounter;\n+import io.micrometer.core.instrument.cumulative.CumulativeDistributionSummary;\n+import io.micrometer.core.instrument.cumulative.CumulativeFunctionCounter;\n+import io.micrometer.core.instrument.cumulative.CumulativeFunctionTimer;\n+import io.micrometer.core.instrument.distribution.DistributionStatisticConfig;\n+import io.micrometer.core.instrument.distribution.pause.PauseDetector;\n+import io.micrometer.core.instrument.internal.DefaultGauge;\n+import io.micrometer.core.instrument.internal.DefaultMeter;\n+import io.micrometer.core.instrument.noop.NoopLongTaskTimer;\n+\n+/**\n+ * A registry that, when exported, mimics the JSON exporter from MP Metrics 3.0\n+ * as closely as it is reasonable to attempt to.\n+ */\n+public class JsonMeterRegistry extends MeterRegistry {\n+\n+    private final JsonExporter jsonExporter;\n+\n+    public JsonMeterRegistry(Clock clock) {\n+        super(clock);\n+        this.jsonExporter = new JsonExporter();\n+    }\n+\n+    @Override\n+    protected <T> Gauge newGauge(Meter.Id id, T obj, ToDoubleFunction<T> valueFunction) {\n+        return new DefaultGauge<>(id, obj, valueFunction);\n+    }\n+\n+    @Override\n+    protected Counter newCounter(Meter.Id id) {\n+        return new CumulativeCounter(id);\n+    }\n+\n+    @Override\n+    protected Timer newTimer(Meter.Id id, DistributionStatisticConfig distributionStatisticConfig,\n+            PauseDetector pauseDetector) {\n+        // turn off percentiles and histograms because we don't need them for the JSON export\n+        distributionStatisticConfig = DistributionStatisticConfig.builder()\n+                .percentilesHistogram(false)\n+                .percentiles(new double[0])\n+                .build()\n+                .merge(distributionStatisticConfig);\n+        return new JsonTimer(id, clock, distributionStatisticConfig, pauseDetector, getBaseTimeUnit());\n+    }\n+\n+    @Override\n+    protected DistributionSummary newDistributionSummary(Meter.Id id, DistributionStatisticConfig distributionStatisticConfig,\n+            double scale) {\n+        distributionStatisticConfig = DistributionStatisticConfig.builder()\n+                .percentilePrecision(3)\n+                .percentilesHistogram(false)\n+                .minimumExpectedValue(Double.MIN_VALUE)\n+                .maximumExpectedValue(Double.MAX_VALUE)\n+                .bufferLength(1024)\n+                .expiry(Duration.ofDays(3))\n+                .build()", "originalCommit": "93546ccbb6a589f43dea8e7b7cc15c48126cf4d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1NjI1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485356255", "bodyText": "The expiry and bufferLength, I just guessed. Perhaps they should be configurable?\nNot sure what you mean by negative values. There are no negative values. Double.MIN_VALUE is greater than zero.", "author": "jmartisk", "createdAt": "2020-09-09T05:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNTcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQzNzgzOA==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485437838", "bodyText": "You're right. I forgot that Double doesn't work that way \ud83e\udd26\u200d\u2640\ufe0f", "author": "ebullient", "createdAt": "2020-09-09T08:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNTcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzMTg4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r489531886", "bodyText": "Mark this one resolved. ;)", "author": "ebullient", "createdAt": "2020-09-16T15:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNTcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMzMyNw==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485023327", "bodyText": "p50 getSnapshot().getMedian()\np75 getSnapshot().get75thPercentile()\np95 getSnapshot().get95thPercentile()\np98 getSnapshot().get98thPercentile()\np99 getSnapshot().get99thPercentile()\np999 getSnapshot().get999thPercentile()\n?", "author": "ebullient", "createdAt": "2020-09-08T15:48:05Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/registry/json/JsonMeterRegistry.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package io.quarkus.micrometer.runtime.registry.json;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToLongFunction;\n+\n+import io.micrometer.core.instrument.Clock;\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.DistributionSummary;\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.FunctionTimer;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.LongTaskTimer;\n+import io.micrometer.core.instrument.Measurement;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Timer;\n+import io.micrometer.core.instrument.cumulative.CumulativeCounter;\n+import io.micrometer.core.instrument.cumulative.CumulativeDistributionSummary;\n+import io.micrometer.core.instrument.cumulative.CumulativeFunctionCounter;\n+import io.micrometer.core.instrument.cumulative.CumulativeFunctionTimer;\n+import io.micrometer.core.instrument.distribution.DistributionStatisticConfig;\n+import io.micrometer.core.instrument.distribution.pause.PauseDetector;\n+import io.micrometer.core.instrument.internal.DefaultGauge;\n+import io.micrometer.core.instrument.internal.DefaultMeter;\n+import io.micrometer.core.instrument.noop.NoopLongTaskTimer;\n+\n+/**\n+ * A registry that, when exported, mimics the JSON exporter from MP Metrics 3.0\n+ * as closely as it is reasonable to attempt to.\n+ */\n+public class JsonMeterRegistry extends MeterRegistry {\n+\n+    private final JsonExporter jsonExporter;\n+\n+    public JsonMeterRegistry(Clock clock) {\n+        super(clock);\n+        this.jsonExporter = new JsonExporter();\n+    }\n+\n+    @Override\n+    protected <T> Gauge newGauge(Meter.Id id, T obj, ToDoubleFunction<T> valueFunction) {\n+        return new DefaultGauge<>(id, obj, valueFunction);\n+    }\n+\n+    @Override\n+    protected Counter newCounter(Meter.Id id) {\n+        return new CumulativeCounter(id);\n+    }\n+\n+    @Override\n+    protected Timer newTimer(Meter.Id id, DistributionStatisticConfig distributionStatisticConfig,\n+            PauseDetector pauseDetector) {\n+        // turn off percentiles and histograms because we don't need them for the JSON export\n+        distributionStatisticConfig = DistributionStatisticConfig.builder()\n+                .percentilesHistogram(false)\n+                .percentiles(new double[0])\n+                .build()\n+                .merge(distributionStatisticConfig);\n+        return new JsonTimer(id, clock, distributionStatisticConfig, pauseDetector, getBaseTimeUnit());\n+    }\n+\n+    @Override\n+    protected DistributionSummary newDistributionSummary(Meter.Id id, DistributionStatisticConfig distributionStatisticConfig,\n+            double scale) {\n+        distributionStatisticConfig = DistributionStatisticConfig.builder()\n+                .percentilePrecision(3)\n+                .percentilesHistogram(false)\n+                .minimumExpectedValue(Double.MIN_VALUE)\n+                .maximumExpectedValue(Double.MAX_VALUE)\n+                .bufferLength(1024)\n+                .expiry(Duration.ofDays(3))\n+                .build()\n+                .merge(distributionStatisticConfig);\n+        return new CumulativeDistributionSummary(id, clock, distributionStatisticConfig, scale, false);\n+    }\n+\n+    @Override\n+    protected Meter newMeter(Meter.Id id, Meter.Type type, Iterable<Measurement> measurements) {\n+        return new DefaultMeter(id, type, measurements);\n+    }\n+\n+    @Override\n+    protected <T> FunctionTimer newFunctionTimer(Meter.Id id, T obj, ToLongFunction<T> countFunction,\n+            ToDoubleFunction<T> totalTimeFunction, TimeUnit totalTimeFunctionUnit) {\n+        return new CumulativeFunctionTimer<>(id, obj, countFunction, totalTimeFunction,\n+                totalTimeFunctionUnit, getBaseTimeUnit());\n+    }\n+\n+    @Override\n+    protected <T> FunctionCounter newFunctionCounter(Meter.Id id, T obj, ToDoubleFunction<T> countFunction) {\n+        return new CumulativeFunctionCounter<>(id, obj, countFunction);\n+    }\n+\n+    @Override\n+    protected LongTaskTimer newLongTaskTimer(Meter.Id id, DistributionStatisticConfig distributionStatisticConfig) {\n+        return new NoopLongTaskTimer(id);\n+    }\n+\n+    @Override\n+    protected TimeUnit getBaseTimeUnit() {\n+        return TimeUnit.MILLISECONDS;\n+    }\n+\n+    @Override\n+    protected DistributionStatisticConfig defaultHistogramConfig() {\n+        return DistributionStatisticConfig.builder()\n+                .percentiles(0.5, 0.75, 0.95, 0.98, 0.99)", "originalCommit": "93546ccbb6a589f43dea8e7b7cc15c48126cf4d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyNDQ0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485024445", "bodyText": "One thing we could consider is not publishing the percentiles by default (but publish the other calculations), and rely on the usual MeterFilter behavior for users to turn those on.. the memory implications for using histograms isn't trivial.", "author": "ebullient", "createdAt": "2020-09-08T15:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2MDUzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485560535", "bodyText": "I added the missing 99.9%.\nWhether to publish percentiles by default, I'd say yes, since we are trying to emulate the MP Metrics exporter, which does that always \ud83d\udc30", "author": "jmartisk", "createdAt": "2020-09-09T12:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzMjcxNg==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r489532716", "bodyText": "This one is resolved, too. ;)", "author": "ebullient", "createdAt": "2020-09-16T15:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMzMyNw=="}], "type": "inlineReview"}, {"oid": "b6243833b35aab2285598db908875374bfb2ee58", "url": "https://github.com/quarkusio/quarkus/commit/b6243833b35aab2285598db908875374bfb2ee58", "message": "avoid instantiating ToDoubleFunction unnecessarily", "committedDate": "2020-09-09T05:36:40Z", "type": "forcePushed"}, {"oid": "6af0a4b5916ce4763221145bd460f33a6ec764e2", "url": "https://github.com/quarkusio/quarkus/commit/6af0a4b5916ce4763221145bd460f33a6ec764e2", "message": "Add 99.9th percentile", "committedDate": "2020-09-09T06:07:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5NTU3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r485895571", "bodyText": "Given what this does (retrieve from collection effectively retrieves from the stream repeatedly), I think you should rejigger this to use the match function on the Meter interface as is done here:\nhttps://github.com/micrometer-metrics/micrometer/blob/master/implementations/micrometer-registry-appoptics/src/main/java/io/micrometer/appoptics/AppOpticsMeterRegistry.java#L98\n(most other registries do this as well).\nGives you a one time loop through everything that you can use to initialize those collections with what you need, and then you can emit the lot at the end.", "author": "ebullient", "createdAt": "2020-09-09T20:14:42Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/registry/json/JsonExporter.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.quarkus.micrometer.runtime.registry.json;\n+\n+import java.io.StringWriter;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.json.JsonObject;\n+import javax.json.JsonObjectBuilder;\n+import javax.json.JsonValue;\n+import javax.json.JsonWriter;\n+import javax.json.spi.JsonProvider;\n+import javax.json.stream.JsonGenerator;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.DistributionSummary;\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.FunctionTimer;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Timer;\n+import io.micrometer.core.instrument.distribution.HistogramSnapshot;\n+import io.micrometer.core.instrument.distribution.ValueAtPercentile;\n+\n+public class JsonExporter {\n+\n+    private static final Map<String, ?> JSON_CONFIG = Collections.singletonMap(JsonGenerator.PRETTY_PRINTING, true);\n+    private static final JsonProvider JSON_PROVIDER = JsonProvider.provider();\n+\n+    public JsonExporter() {\n+    }\n+\n+    public StringBuilder exportEverything(JsonMeterRegistry meterRegistry) {\n+        JsonObjectBuilder root = JSON_PROVIDER.createObjectBuilder();\n+        exportCounters(retrieveFromCollection(Counter.class, meterRegistry)).forEach(root::add);\n+        exportGauges(retrieveFromCollection(Gauge.class, meterRegistry)).forEach(root::add);\n+        exportFunctionCounters(retrieveFromCollection(FunctionCounter.class, meterRegistry)).forEach(root::add);\n+        exportTimers(retrieveFromCollection(Timer.class, meterRegistry)).forEach(root::add);\n+        exportFunctionTimers(retrieveFromCollection(FunctionTimer.class, meterRegistry)).forEach(root::add);\n+        exportDistributionSummaries(retrieveFromCollection(DistributionSummary.class, meterRegistry)).forEach(root::add);\n+        return stringify(root.build());", "originalCommit": "2cb39c6076aedab11675e4d0747bb7e8942f7082", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0MDcxNw==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r486140717", "bodyText": "Given that the Meter.match method takes functions that act on only one meter at a time (and I need to group the meters by name and type first to be able to export), I don't see any other use for it than for potentially performing the grouping itself, but it would feel quite awkward and we can do that more effectively using pure Java streams.. So I guess I'd need more hints how you imagine doing this?!", "author": "jmartisk", "createdAt": "2020-09-10T07:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5NTU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2OTQ4NA==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r486169484", "bodyText": "I could imagine this\n        List<Gauge> gauges = new ArrayList<>();\n        List<Counter> counters = new ArrayList<>();\n        List<TimeGauge> timeGauges = new ArrayList<>();\n        List<FunctionCounter> functionCounters = new ArrayList<>();\n        List<Timer> timers = new ArrayList<>();\n        List<LongTaskTimer> longTaskTimers = new ArrayList<>();\n        List<FunctionTimer> functionTimers = new ArrayList<>();\n        List<DistributionSummary> distributionSummaries = new ArrayList<>();\n        List<Meter> meters = new ArrayList<>();\n        meterRegistry.getMeters().forEach(meter -> meter.match(gauges::add,\n                counters::add,\n                timers::add,\n                distributionSummaries::add,\n                longTaskTimers::add,\n                timeGauges::add,\n                functionCounters::add,\n                functionTimers::add,\n                meters::add));\n        exportCounters(counters).forEach(root::add);\n        exportGauges(gauges).forEach(root::add);\n        exportTimeGauges(timeGauges).forEach(root::add);\n        exportFunctionCounters(functionCounters).forEach(root::add);\n        exportTimers(timers).forEach(root::add);\n        exportLongTaskTimers(longTaskTimers).forEach(root::add);\n        exportFunctionTimers(functionTimers).forEach(root::add);\n        exportDistributionSummaries(distributionSummaries).forEach(root::add);\n\nbut perhaps you had something better in mind", "author": "jmartisk", "createdAt": "2020-09-10T08:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5NTU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM0NzA3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r486347071", "bodyText": "Well. The way it exists now, you're iterating the list of registered meters several times: registry.getMeters().stream() in retrieveFromCollection. The above does that iteration/collection in one fell swoop.", "author": "ebullient", "createdAt": "2020-09-10T13:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5NTU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY5NzA1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r487697051", "bodyText": "Ok, I committed this change.", "author": "jmartisk", "createdAt": "2020-09-14T07:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5NTU3MQ=="}], "type": "inlineReview"}, {"oid": "f74bb82f39880104df1fef85d473531ff5eef48c", "url": "https://github.com/quarkusio/quarkus/commit/f74bb82f39880104df1fef85d473531ff5eef48c", "message": "improve meter iteration in the exporter", "committedDate": "2020-09-14T07:13:25Z", "type": "forcePushed"}, {"oid": "af139822b20d95c50547457ca85ee83150ff6878", "url": "https://github.com/quarkusio/quarkus/commit/af139822b20d95c50547457ca85ee83150ff6878", "message": "make bufferLength and expiry configurable", "committedDate": "2020-09-15T08:56:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMjY4NA==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r489512684", "bodyText": "Not sure the configureJsonRegistry or object vars are necessary?\n    @Produces\n    @Singleton\n    public JsonMeterRegistry registry(Clock clock, Config config) {\n        return new JsonMeterRegistry(clock, config.export.json.bufferLength, config.export.json.expiry);\n    }\n\nThat should just work (injection of microprofile config)?", "author": "ebullient", "createdAt": "2020-09-16T15:07:42Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/export/JsonMeterRegistryProvider.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package io.quarkus.micrometer.runtime.export;\n+\n+import java.time.Duration;\n+\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Singleton;\n+\n+import io.micrometer.core.instrument.Clock;\n+import io.quarkus.micrometer.runtime.registry.json.JsonMeterRegistry;\n+\n+@Singleton\n+public class JsonMeterRegistryProvider {\n+\n+    private Integer bufferLength;\n+    private Duration expiry;\n+\n+    @Produces\n+    @Singleton\n+    public JsonMeterRegistry registry(Clock clock) {\n+        return new JsonMeterRegistry(clock, bufferLength, expiry);\n+    }\n+\n+    public void configureJsonRegistry(Integer bufferLength, Duration expiry) {\n+        this.bufferLength = bufferLength;\n+        this.expiry = expiry;\n+    }", "originalCommit": "af139822b20d95c50547457ca85ee83150ff6878", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMjk3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r489512972", "bodyText": "See other comment -- not sure why this step is necessary.", "author": "ebullient", "createdAt": "2020-09-16T15:08:03Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/export/JsonRecorder.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.micrometer.runtime.export;\n+\n+import java.util.function.Function;\n+\n+import io.quarkus.arc.runtime.BeanContainer;\n+import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n+import io.quarkus.micrometer.runtime.export.handlers.JsonHandler;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.vertx.ext.web.Route;\n+import io.vertx.ext.web.Router;\n+\n+@Recorder\n+public class JsonRecorder {\n+    JsonHandler handler;\n+\n+    public JsonHandler getHandler() {\n+        if (handler == null) {\n+            handler = new JsonHandler();\n+        }\n+\n+        return handler;\n+    }\n+\n+    public void configureJsonRegistry(MicrometerConfig config, BeanContainer beanContainer) {\n+        beanContainer\n+                .instance(JsonMeterRegistryProvider.class)\n+                .configureJsonRegistry(config.export.json.bufferLength, config.export.json.expiry);\n+    }", "originalCommit": "af139822b20d95c50547457ca85ee83150ff6878", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMzY0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r489513641", "bodyText": "WOOHOO! =)", "author": "ebullient", "createdAt": "2020-09-16T15:08:57Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/registry/json/JsonDistributionSummary.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package io.quarkus.micrometer.runtime.registry.json;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.DoubleAdder;\n+\n+import io.micrometer.core.instrument.AbstractDistributionSummary;\n+import io.micrometer.core.instrument.Clock;\n+import io.micrometer.core.instrument.Measurement;\n+import io.micrometer.core.instrument.Statistic;\n+import io.micrometer.core.instrument.distribution.DistributionStatisticConfig;\n+import io.micrometer.core.instrument.distribution.TimeWindowMax;\n+\n+public class JsonDistributionSummary extends AbstractDistributionSummary {\n+\n+    private final AtomicLong count;\n+    private final DoubleAdder total;\n+    private final TimeWindowMax max;\n+    private final TimeWindowMin min;\n+\n+    public JsonDistributionSummary(Id id, Clock clock, DistributionStatisticConfig distributionStatisticConfig,\n+            double scale, boolean supportsAggregablePercentiles) {\n+        super(id, clock, distributionStatisticConfig, scale, supportsAggregablePercentiles);\n+        this.count = new AtomicLong();\n+        this.total = new DoubleAdder();\n+        this.max = new TimeWindowMax(clock, distributionStatisticConfig);\n+        this.min = new TimeWindowMin(clock, distributionStatisticConfig);\n+    }\n+", "originalCommit": "af139822b20d95c50547457ca85ee83150ff6878", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMzg1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r489513855", "bodyText": "AtomicLong or LongAdder?", "author": "ebullient", "createdAt": "2020-09-16T15:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMzY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUyNjQ3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r489526479", "bodyText": "I basically copied this over from Micrometer's CumulativeDistributionSummary and they have an AtomicLong there ;) but yes this is probably a good idea, will change", "author": "jmartisk", "createdAt": "2020-09-16T15:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMzY0MQ=="}], "type": "inlineReview"}, {"oid": "928f180271c1a51b3b46e441b1d4f9806ac8faa7", "url": "https://github.com/quarkusio/quarkus/commit/928f180271c1a51b3b46e441b1d4f9806ac8faa7", "message": "JSON exporter for Micrometer", "committedDate": "2020-09-17T08:07:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwMjU1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r492702553", "bodyText": "Javadoc doesn't match the actual config default. Which should it be?", "author": "kenfinnigan", "createdAt": "2020-09-22T12:44:32Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/config/JsonConfig.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package io.quarkus.micrometer.runtime.config;\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class JsonConfig implements MicrometerConfig.CapabilityEnabled {\n+    /**\n+     * Support for export to JSON format. Off by default.\n+     */\n+    @ConfigItem(defaultValue = \"false\")\n+    public Optional<Boolean> enabled;\n+\n+    /**\n+     * The path for the JSON metrics endpoint.\n+     * The default value is {@code /metrics-json}.\n+     */\n+    @ConfigItem(defaultValue = \"/metrics\")", "originalCommit": "928f180271c1a51b3b46e441b1d4f9806ac8faa7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyMzk3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r492723971", "bodyText": "Good catch, changed the javadoc to /metrics", "author": "jmartisk", "createdAt": "2020-09-22T13:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwMjU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2MzIyMw==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r492763223", "bodyText": "Thanks!", "author": "kenfinnigan", "createdAt": "2020-09-22T14:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwMjU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwMzk1NA==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r492703954", "bodyText": "I might have missed this somewhere, but should the content type be changed? I thought \"004\" was the right one for Prometheus?", "author": "kenfinnigan", "createdAt": "2020-09-22T12:46:44Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/export/PrometheusRecorder.java", "diffHunk": "@@ -24,7 +23,7 @@ public PrometheusHandler getHandler() {\n         return new Function<Router, Route>() {\n             @Override\n             public Route apply(Router router) {\n-                return router.route(path).produces(TextFormat.CONTENT_TYPE_004);\n+                return router.route(path).order(1).produces(\"text/plain\");", "originalCommit": "928f180271c1a51b3b46e441b1d4f9806ac8faa7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNTUxMg==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r492725512", "bodyText": "Jan and I talked about this one. Due to precedence order, it's safer to use text plain... if the suffix (for type 004 is there), it gets weird with JSON being on the same endpoint.\nCan two types be produced in different orders? (text/plain at order(1) AND 004)?", "author": "ebullient", "createdAt": "2020-09-22T13:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwMzk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNjcyMw==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r492726723", "bodyText": "This is only for handler matching purposes, this is not what will be sent to the client. The actual content type is set in the handler: https://github.com/quarkusio/quarkus/blob/1.8.1.Final/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/export/handlers/PrometheusHandler.java#L34\nThe thing is that there are now potentially two distinct handlers living on the same /metrics endpoint. Vert.x chooses the handler based on this produces value, and if we left this value as text/plain; version=0.0.4; charset=utf-8, then it would only be matched if the client sent an Accept header with this whole value. So if the client requested Accept: text/plain there would be no matched handler to handle the request.", "author": "jmartisk", "createdAt": "2020-09-22T13:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwMzk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2MzQ3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/11939#discussion_r492763479", "bodyText": "Aha, now I remember that.\nThanks for the explanation!", "author": "kenfinnigan", "createdAt": "2020-09-22T14:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwMzk1NA=="}], "type": "inlineReview"}, {"oid": "daab6d4ef2a18624421f44ece64bc1c2e376dafb", "url": "https://github.com/quarkusio/quarkus/commit/daab6d4ef2a18624421f44ece64bc1c2e376dafb", "message": "JSON exporter for Micrometer", "committedDate": "2020-09-22T13:15:35Z", "type": "commit"}, {"oid": "daab6d4ef2a18624421f44ece64bc1c2e376dafb", "url": "https://github.com/quarkusio/quarkus/commit/daab6d4ef2a18624421f44ece64bc1c2e376dafb", "message": "JSON exporter for Micrometer", "committedDate": "2020-09-22T13:15:35Z", "type": "forcePushed"}]}