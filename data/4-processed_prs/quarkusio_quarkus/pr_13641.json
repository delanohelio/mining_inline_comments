{"pr_number": 13641, "pr_title": "Add oidc-client, oidc-client-filter and oidc-token-propagation extensions", "pr_createdAt": "2020-12-02T18:17:57Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13641", "timeline": [{"oid": "0812300c4efd836611b341a780e4f9d8bae0108c", "url": "https://github.com/quarkusio/quarkus/commit/0812300c4efd836611b341a780e4f9d8bae0108c", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-03T10:48:16Z", "type": "forcePushed"}, {"oid": "707f92d67b58d85b9aaf2475b99da11c53686a14", "url": "https://github.com/quarkusio/quarkus/commit/707f92d67b58d85b9aaf2475b99da11c53686a14", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-03T11:26:10Z", "type": "forcePushed"}, {"oid": "f1e0d6c8561c05ce2472136344868fd69eb0140f", "url": "https://github.com/quarkusio/quarkus/commit/f1e0d6c8561c05ce2472136344868fd69eb0140f", "message": "Load OidcClient filter with a custom annotation", "committedDate": "2020-12-06T18:14:05Z", "type": "forcePushed"}, {"oid": "2e0898d96a990bfee805722d65d28078cb1f7d28", "url": "https://github.com/quarkusio/quarkus/commit/2e0898d96a990bfee805722d65d28078cb1f7d28", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-07T16:57:09Z", "type": "forcePushed"}, {"oid": "65ad379c4ec2cad1013002e08ff1f9fc74f88b37", "url": "https://github.com/quarkusio/quarkus/commit/65ad379c4ec2cad1013002e08ff1f9fc74f88b37", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-07T18:04:45Z", "type": "forcePushed"}, {"oid": "751cdae20a5608a237ce62d58ee66c66603695c8", "url": "https://github.com/quarkusio/quarkus/commit/751cdae20a5608a237ce62d58ee66c66603695c8", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-08T16:18:53Z", "type": "forcePushed"}, {"oid": "2422a13b7db944049b6bba2ea349d465d3fd5073", "url": "https://github.com/quarkusio/quarkus/commit/2422a13b7db944049b6bba2ea349d465d3fd5073", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-08T18:41:38Z", "type": "forcePushed"}, {"oid": "cfd565c07074242f9f179b666e957004b873285a", "url": "https://github.com/quarkusio/quarkus/commit/cfd565c07074242f9f179b666e957004b873285a", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-09T14:35:54Z", "type": "forcePushed"}, {"oid": "912c0ec5069e490b7ee7c52829b3fcf47f13d453", "url": "https://github.com/quarkusio/quarkus/commit/912c0ec5069e490b7ee7c52829b3fcf47f13d453", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-09T17:04:02Z", "type": "forcePushed"}, {"oid": "94290cd2810ac5d0fa63f305dfeeb353d41634e2", "url": "https://github.com/quarkusio/quarkus/commit/94290cd2810ac5d0fa63f305dfeeb353d41634e2", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-09T17:11:35Z", "type": "forcePushed"}, {"oid": "7c66607041b3e0e3116e6a7fa0f94ed13e84bea2", "url": "https://github.com/quarkusio/quarkus/commit/7c66607041b3e0e3116e6a7fa0f94ed13e84bea2", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-10T10:12:20Z", "type": "forcePushed"}, {"oid": "52540c3947f4a824c2454d222cf303839b17485e", "url": "https://github.com/quarkusio/quarkus/commit/52540c3947f4a824c2454d222cf303839b17485e", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-10T11:04:07Z", "type": "forcePushed"}, {"oid": "113b7339bc427ef5c1e0af04a4e5a8c90b53e57e", "url": "https://github.com/quarkusio/quarkus/commit/113b7339bc427ef5c1e0af04a4e5a8c90b53e57e", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-11T18:02:31Z", "type": "forcePushed"}, {"oid": "ec0c79dc843b29701bd94b83645e17aad807abb7", "url": "https://github.com/quarkusio/quarkus/commit/ec0c79dc843b29701bd94b83645e17aad807abb7", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-13T17:37:14Z", "type": "forcePushed"}, {"oid": "b600f42fc6923d2a92f5398db8a20ec198ee8290", "url": "https://github.com/quarkusio/quarkus/commit/b600f42fc6923d2a92f5398db8a20ec198ee8290", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-14T18:47:38Z", "type": "forcePushed"}, {"oid": "16ef1c492c97a8f4a8da00b2eb1348d0c73834de", "url": "https://github.com/quarkusio/quarkus/commit/16ef1c492c97a8f4a8da00b2eb1348d0c73834de", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-14T22:35:08Z", "type": "forcePushed"}, {"oid": "ab55074a7b2a0765b87ac55db192e4a3b5c9e271", "url": "https://github.com/quarkusio/quarkus/commit/ab55074a7b2a0765b87ac55db192e4a3b5c9e271", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-15T13:06:46Z", "type": "forcePushed"}, {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "url": "https://github.com/quarkusio/quarkus/commit/5092b249c039f4376f9602ea6a5e9f18235f9c9e", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-15T17:51:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc0Nzk4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543747986", "bodyText": "I would say that quarkus.oidc-client.grant.type=password makes more sense.", "author": "pedroigor", "createdAt": "2020-12-15T22:57:00Z", "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MjM3NA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543752374", "bodyText": "I'm not sure it makes sense to set up the client with user because I'm not sure if that is a valid use case for chaining services. So, refresh tokens should only make sense if the application is a web-app that authenticates using code flow and needs to access downstream services.\nFor service-to-service communication it would makes more sense client credentials where refresh tokens are not supposed to be issued (in Keycloak we are changing this).\nBtw, is it possible to use this filter using a bearer token sent to a service type application ? One thing nice here would be the possibility to automatically exchange tokens depending on the service the application is calling. So that another token is issued by the AS and meant to use in the target service.", "author": "pedroigor", "createdAt": "2020-12-15T23:06:15Z", "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.\n+\n+In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.\n+\n+== Use OidcClient directly\n+\n+One can use `OidcClient` directly as follows:\n+\n+```\n+import javax.inject.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@Path(\"/service\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClient client;\n+\n+    volatile GrantTokens currentTokens;\n+\n+    @PostConstruct\n+    public init() {\n+        currentTokens = client.getTokens().await().indefinitely();\n+    }\n+\n+    @GET\n+    public String getResponse() {\n+        \n+        GrantTokens tokens = currentTokens;\n+        if (tokens.isAccessTokenExpired) {\n+            tokens = client.refreshTokens(tokens.getRefreshToken().await.indefinitely();\n+            currentTokens = tokens;\n+        } \n+        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc\n+    }\n+}\n+```\n+\n+== Use OidcClient as Microprofile RestClient client filter\n+\n+`quarkus-oidc-rest-client` extension provides `io.quarkus.oidc.rest.client.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.\n+\n+By default this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxMzcyMA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544213720", "bodyText": "Hi @pedroigor yeah, I'm just trying to position this client as a generic oidc client, beyond chaining the services or a service to service, you know we have many places were we use RestAssured or Keycloak admin api to get a token with a password grant; and I'm also keeping an option open for supporting the custom grants.\nRight now this filter is not linked to the incoming tokens, the case where the coming in bearer token is used in the next invocation is not covered - in this simplest form there is nothing we can suggest but using the context propagation where JsonWebToken is injected in the client filter where one would just add its value to the Authorization header - I think I may add this simple filter anyway - and we've had an exchange tokens issue closed recently till better times :-) - so after this PR, I'll reopen that issue and we can enhance it with the exchange protocol, that should be interesting", "author": "sberyozkin", "createdAt": "2020-12-16T11:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MjM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk5MDIxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544990215", "bodyText": "Hey @pedroigor Re that new filter which would propagate the token, not sure I'll have time to put it into this PR, I'll see, but I'm thinking of naming it TokenPropagationRequestFilter as opposed to OidcClientRequestFilter which is shipped in this PR - the latter is not related in anyway to the endpoint authentication, while the former would pick up the injected token - in the 1st iteration it would just put it into the header, later - we will wire in the exchange protocol.\nDoes it sound good to you ?", "author": "sberyozkin", "createdAt": "2020-12-17T10:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MjM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NDA2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545984062", "bodyText": "Sure", "author": "pedroigor", "createdAt": "2020-12-18T17:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MjM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MzExOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543753119", "bodyText": "Small typo in directly.", "author": "pedroigor", "createdAt": "2020-12-15T23:07:40Z", "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.\n+\n+In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.\n+\n+== Use OidcClient directly\n+\n+One can use `OidcClient` directly as follows:\n+\n+```\n+import javax.inject.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@Path(\"/service\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClient client;\n+\n+    volatile GrantTokens currentTokens;\n+\n+    @PostConstruct\n+    public init() {\n+        currentTokens = client.getTokens().await().indefinitely();\n+    }\n+\n+    @GET\n+    public String getResponse() {\n+        \n+        GrantTokens tokens = currentTokens;\n+        if (tokens.isAccessTokenExpired) {\n+            tokens = client.refreshTokens(tokens.getRefreshToken().await.indefinitely();\n+            currentTokens = tokens;\n+        } \n+        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc\n+    }\n+}\n+```\n+\n+== Use OidcClient as Microprofile RestClient client filter\n+\n+`quarkus-oidc-rest-client` extension provides `io.quarkus.oidc.rest.client.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.\n+\n+By default this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.\n+\n+You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.rest.client.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:\n+\n+```\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientFilter;\n+\n+@RegisterRestClient\n+@OidcClientFilter\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+or\n+\n+```\n+import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientRequestFilter;\n+\n+@RegisterRestClient\n+@RegisterProvider(OidcClientRequestFilter.class)\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc.rest.client.register-filter=true` property is set. \n+\n+\n+== Use injected GrantTokens\n+\n+If you prefer you can use your own custom filter and inject `GrantTokens`:\n+\n+```\n+@Provider\n+@Priority(Priorities.AUTHENTICATION)\n+@RequestScoped\n+public class OidcClientRequestCustomFilter implements ClientRequestFilter {\n+\n+    @Inject\n+    GrantTokens grantTokens;\n+\n+    @Override\n+    public void filter(ClientRequestContext requestContext) throws IOException {\n+        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, \"Bearer \" + grantTokens.getAccessToken());\n+    }\n+}\n+```\n+\n+The `GrantTokens` producer will acquire and refresh the tokens and the custom filter will decide how and when to use the token.\n+\n+See also the previous section about delaying the token acquisition in some cases.\n+\n+== OidcClients\n+\n+`io.quarkus.oidc.client.OidcClient` is a container of `OidcClient`s - it includes a default `OidcClient` (which can also be injected directrly as described above) and named clients which can be configured like this:", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MzU3NA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543753574", "bodyText": "Maybe this would be nicer if you provide a @OidcClient annotation where you can define a name and have the named  client injected.", "author": "pedroigor", "createdAt": "2020-12-15T23:08:50Z", "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.\n+\n+In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.\n+\n+== Use OidcClient directly\n+\n+One can use `OidcClient` directly as follows:\n+\n+```\n+import javax.inject.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@Path(\"/service\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClient client;\n+\n+    volatile GrantTokens currentTokens;\n+\n+    @PostConstruct\n+    public init() {\n+        currentTokens = client.getTokens().await().indefinitely();\n+    }\n+\n+    @GET\n+    public String getResponse() {\n+        \n+        GrantTokens tokens = currentTokens;\n+        if (tokens.isAccessTokenExpired) {\n+            tokens = client.refreshTokens(tokens.getRefreshToken().await.indefinitely();\n+            currentTokens = tokens;\n+        } \n+        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc\n+    }\n+}\n+```\n+\n+== Use OidcClient as Microprofile RestClient client filter\n+\n+`quarkus-oidc-rest-client` extension provides `io.quarkus.oidc.rest.client.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.\n+\n+By default this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.\n+\n+You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.rest.client.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:\n+\n+```\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientFilter;\n+\n+@RegisterRestClient\n+@OidcClientFilter\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+or\n+\n+```\n+import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientRequestFilter;\n+\n+@RegisterRestClient\n+@RegisterProvider(OidcClientRequestFilter.class)\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc.rest.client.register-filter=true` property is set. \n+\n+\n+== Use injected GrantTokens\n+\n+If you prefer you can use your own custom filter and inject `GrantTokens`:\n+\n+```\n+@Provider\n+@Priority(Priorities.AUTHENTICATION)\n+@RequestScoped\n+public class OidcClientRequestCustomFilter implements ClientRequestFilter {\n+\n+    @Inject\n+    GrantTokens grantTokens;\n+\n+    @Override\n+    public void filter(ClientRequestContext requestContext) throws IOException {\n+        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, \"Bearer \" + grantTokens.getAccessToken());\n+    }\n+}\n+```\n+\n+The `GrantTokens` producer will acquire and refresh the tokens and the custom filter will decide how and when to use the token.\n+\n+See also the previous section about delaying the token acquisition in some cases.\n+\n+== OidcClients\n+\n+`io.quarkus.oidc.client.OidcClient` is a container of `OidcClient`s - it includes a default `OidcClient` (which can also be injected directrly as described above) and named clients which can be configured like this:\n+\n+```\n+quarkus.oidc-client.client-enabled=false\n+\n+quarkus.oidc-client.jwt-secret.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.jwt-secret.client-id=quarkus-app\n+quarkus.oidc-client.jwt-secret.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow\n+```\n+\n+Note in this case the default client is disabled with a `client-enabled=false` property. The `jwt-secret` client can be accessed like this:\n+\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClients;\n+\n+@Path(\"/clients\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClients clients;\n+\n+    @GET\n+    public String getResponse() {\n+        OidcClient client = clients.getClient(\"jwt-secret\");", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxNTYzMg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544215632", "bodyText": "Nice idea, I'll have a look; I'll keep OidcClients as I've already prototyped creating the clients on demand by copying/pasting your code from quarkus-oidc with a few cosmetic updates :-)", "author": "sberyozkin", "createdAt": "2020-12-16T11:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwODA4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545208082", "bodyText": "@pedroigor Hi Pedro, Martin @mkouba explained it is not going to work for ApplicationScoped endpoints, so for now I'll have to resolve this comment without any action. Using OidcClients is a bit more verbose to get a named client but I suppose it is a more complete approach - as it also allows to create the clients dynamically; As I suggested in the docs, if the users have multiple named clients then, at least when they have OIDC multi-tenancy, then can use a tenant id for a client look up, this selection of the named clients is supposed to be dynamic I guess; thanks, nice idea though :-)", "author": "sberyozkin", "createdAt": "2020-12-17T16:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MzU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NDk1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543754952", "bodyText": "You probably have a reason for that ... Wouldn't be better Tokens ?", "author": "pedroigor", "createdAt": "2020-12-15T23:11:56Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/GrantTokens.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.oidc.client;\n+\n+/**\n+ * Access and Refresh tokens returned from a token grant request\n+ */\n+public class GrantTokens {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxNzAxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544217015", "bodyText": "I did not like GrantTokens first but then somehow got used to it :-), no particular reason, just wanted to say the tokens is product of the grant request, but just Tokens is simpler I guess", "author": "sberyozkin", "createdAt": "2020-12-16T11:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MzU1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544643559", "bodyText": "done", "author": "sberyozkin", "createdAt": "2020-12-16T21:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NDk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NTkyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543755927", "bodyText": "Maybe a no-arg refreshTokens would help to avoid boilerplate code to get refresh token and then call this method?", "author": "pedroigor", "createdAt": "2020-12-15T23:14:02Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/OidcClient.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.quarkus.oidc.client;\n+\n+import java.io.Closeable;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Token grant client\n+ */\n+public interface OidcClient extends Closeable {\n+\n+    /**\n+     * Returns the grant tokens\n+     */\n+    Uni<GrantTokens> getTokens();\n+\n+    /**\n+     * Refreshes the grant tokens\n+     */\n+    Uni<GrantTokens> refreshTokens(String refreshToken);", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxODI5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544218297", "bodyText": "But OidcClientImpl is not keeping the tokens itself. I guess in a good number of cases the users won't use this client directly but via the filter which is hiding these expiry and refresh tokens checks. It will be used directly only if the users are comfortable with using this client manually or the existing filters don't really fit their cases", "author": "sberyozkin", "createdAt": "2020-12-16T11:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDA0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543770047", "bodyText": "Shouldn't this guard against concurrent refresh? If you send off multiple client requests at once (e.g. when using a reactive client), you need to track if there is an operation in progress and piggy back on the existing operation rather than attempting another concurrent refresh.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:46:49Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensHelper.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.smallrye.mutiny.Uni;\n+\n+public class GrantTokensHelper {\n+\n+    private volatile GrantTokens grantTokens;\n+\n+    public GrantTokens prepareTokens(OidcClient oidcClient) {\n+        if (grantTokens == null) {\n+            grantTokens = oidcClient.getTokens().await().indefinitely();\n+        }\n+        return grantTokens;\n+    }\n+\n+    public Uni<GrantTokens> getTokens(OidcClient oidcClient) {\n+\n+        GrantTokens currentTokens = prepareTokens(oidcClient);\n+\n+        if (currentTokens.isAccessTokenExpired()) {\n+            // Particularly, a client_credentials response is not guaranteed to return a refresh token\n+            Uni<GrantTokens> newTokensUni = currentTokens.getRefreshToken() != null", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzI4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544223281", "bodyText": "@stuartwdouglas yes there is a (very) small window there for the concurrent refresh or token acquisition but I thought it was not critical, this operation in itself can be repeated, OIDC servers will control a number of times the tokens will be refreshed but a a few extra refresh operations won't affect it.\nAs opposed to having to sync, or did you mean implementing  you need to track if there is an operation in progress and piggy back on the existing operation in terms of Uni ? It sounds right, just need to figure how to do it :-)", "author": "sberyozkin", "createdAt": "2020-12-16T11:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MDc0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545970743", "bodyText": "@stuartwdouglas I've added some code there to make sure no unnecessary refresh or a postponed token acquisition occurs, have a look please, that should be fine.", "author": "sberyozkin", "createdAt": "2020-12-18T17:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTExNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543771117", "bodyText": "I don't think this is the correct scope? It means you will be getting a new token for every request?", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:49:27Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensProducer.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import javax.enterprise.context.RequestScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@RequestScoped\n+public class GrantTokensProducer extends AbstractGrantTokensProducer {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNDAwNA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544224004", "bodyText": "This producer gets the initial set of tokens on the initialization time, and it needs to be called on every request for this producer to check if the token has expired", "author": "sberyozkin", "createdAt": "2020-12-16T11:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543771566", "bodyText": "These tokens are dependent scoped, so they will have the same lifecycle as the object they are injected into. If you inject them into an @ApplicationScoped bean or a singleton they will never be refreshed.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:50:30Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensProducer.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import javax.enterprise.context.RequestScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@RequestScoped\n+public class GrantTokensProducer extends AbstractGrantTokensProducer {\n+\n+    @Produces\n+    public GrantTokens produceTokens() {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNjA3NA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544226074", "bodyText": "@stuartwdouglas I'll check, sure, I have a test checking the logs which confirm the tokens have been refreshed (with the filter which uses @OidcClient) and I have a test which verifies the tokens have been refreshed with @GrantTokensProducer/@GrantTokens but I'll add the log check there as well :-)", "author": "sberyozkin", "createdAt": "2020-12-16T11:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMTA1MA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544711050", "bodyText": "Your test works because you have explicitly marker the filter as @RequestScoped. But this means that every request will require a request to KC to get the keys.\nI think the keys should be stored in a singleton, which will mean that most requests don't need to make any requests to KC. When they keys expire the singleton can manage the refresh process and make sure they are only refreshed once.", "author": "stuartwdouglas", "createdAt": "2020-12-17T00:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1Mjc1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544952756", "bodyText": "@stuartwdouglas Oh, do you mean the filter is re-initialized on every request ? that is not good then yeah", "author": "sberyozkin", "createdAt": "2020-12-17T09:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MjEwMg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543772102", "bodyText": "I think a lot of these should be final.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:51:35Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzY4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543773682", "bodyText": "I think you can just use transform rather than transformToUni here, as emitGrantTokens does not do anything async.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:55:07Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;\n+    private String tokenRequestUri;\n+    private MultiMap tokenGrantParams;\n+    private MultiMap commonRefreshGrantParams;\n+    private String grantType;\n+    private String clientSecretBasicAuthScheme;\n+    private Key clientJwtKey;\n+    private OidcClientConfig oidcConfig;\n+\n+    public OidcClientImpl() {\n+    }\n+\n+    public OidcClientImpl(WebClient client, String tokenRequestUri,\n+            MultiMap tokenGrantParams, MultiMap commonRefreshGrantParams, OidcClientConfig oidcClientConfig) {\n+        this.client = client;\n+        this.tokenRequestUri = tokenRequestUri;\n+        this.tokenGrantParams = tokenGrantParams;\n+        this.commonRefreshGrantParams = commonRefreshGrantParams;\n+        this.grantType = oidcClientConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\";\n+        this.oidcConfig = oidcClientConfig;\n+        initClientSecretBasicAuth();\n+    }\n+\n+    private void initClientSecretBasicAuth() {\n+        if (OidcCommonUtils.isClientSecretBasicAuthRequired(oidcConfig.credentials)) {\n+            clientSecretBasicAuthScheme = \"Basic \"\n+                    + Base64.getEncoder().encodeToString(\n+                            (oidcConfig.getClientId().get() + \":\" + OidcCommonUtils.clientSecret(oidcConfig.credentials))\n+                                    .getBytes(StandardCharsets.UTF_8));\n+        } else if (OidcCommonUtils.isClientJwtAuthRequired(oidcConfig.credentials)) {\n+            // if it is a refresh then a map has already been copied\n+            clientJwtKey = OidcCommonUtils.clientJwtKey(oidcConfig.credentials);\n+        }\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> getTokens() {\n+        return getJsonResponse(tokenGrantParams, false);\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+        if (refreshToken == null) {\n+            throw new OidcClientException(\"Refresh token is null\");\n+        }\n+        MultiMap refreshGrantParams = copyMultiMap(commonRefreshGrantParams);\n+        refreshGrantParams.add(REFRESH_TOKEN, refreshToken);\n+        return getJsonResponse(refreshGrantParams, true);\n+    }\n+\n+    private Uni<GrantTokens> getJsonResponse(MultiMap body, boolean refresh) {\n+        HttpRequest<Buffer> request = client.post(tokenRequestUri);\n+        if (clientSecretBasicAuthScheme != null) {\n+            request.putHeader(AUTHORIZATION_HEADER, clientSecretBasicAuthScheme);\n+        } else if (clientJwtKey != null) {\n+            // if it is a refresh then a map has already been copied\n+            body = !refresh ? copyMultiMap(body) : body;\n+            body.add(CLIENT_ASSERTION_TYPE, JWT_BEARER_CLIENT_ASSERTION_TYPE);\n+            body.add(CLIENT_ASSERTION, OidcCommonUtils.signJwtWithKey(oidcConfig, clientJwtKey));\n+        }\n+        return request.sendForm(body).onItem()\n+                .transformToUni(resp -> emitGrantTokens(resp, refresh));", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzkyOA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543773928", "bodyText": "Why would this happen? Shouldn't this give some kind of user feedback?", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:55:46Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;\n+    private String tokenRequestUri;\n+    private MultiMap tokenGrantParams;\n+    private MultiMap commonRefreshGrantParams;\n+    private String grantType;\n+    private String clientSecretBasicAuthScheme;\n+    private Key clientJwtKey;\n+    private OidcClientConfig oidcConfig;\n+\n+    public OidcClientImpl() {\n+    }\n+\n+    public OidcClientImpl(WebClient client, String tokenRequestUri,\n+            MultiMap tokenGrantParams, MultiMap commonRefreshGrantParams, OidcClientConfig oidcClientConfig) {\n+        this.client = client;\n+        this.tokenRequestUri = tokenRequestUri;\n+        this.tokenGrantParams = tokenGrantParams;\n+        this.commonRefreshGrantParams = commonRefreshGrantParams;\n+        this.grantType = oidcClientConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\";\n+        this.oidcConfig = oidcClientConfig;\n+        initClientSecretBasicAuth();\n+    }\n+\n+    private void initClientSecretBasicAuth() {\n+        if (OidcCommonUtils.isClientSecretBasicAuthRequired(oidcConfig.credentials)) {\n+            clientSecretBasicAuthScheme = \"Basic \"\n+                    + Base64.getEncoder().encodeToString(\n+                            (oidcConfig.getClientId().get() + \":\" + OidcCommonUtils.clientSecret(oidcConfig.credentials))\n+                                    .getBytes(StandardCharsets.UTF_8));\n+        } else if (OidcCommonUtils.isClientJwtAuthRequired(oidcConfig.credentials)) {\n+            // if it is a refresh then a map has already been copied\n+            clientJwtKey = OidcCommonUtils.clientJwtKey(oidcConfig.credentials);\n+        }\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> getTokens() {\n+        return getJsonResponse(tokenGrantParams, false);\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+        if (refreshToken == null) {\n+            throw new OidcClientException(\"Refresh token is null\");\n+        }\n+        MultiMap refreshGrantParams = copyMultiMap(commonRefreshGrantParams);\n+        refreshGrantParams.add(REFRESH_TOKEN, refreshToken);\n+        return getJsonResponse(refreshGrantParams, true);\n+    }\n+\n+    private Uni<GrantTokens> getJsonResponse(MultiMap body, boolean refresh) {\n+        HttpRequest<Buffer> request = client.post(tokenRequestUri);\n+        if (clientSecretBasicAuthScheme != null) {\n+            request.putHeader(AUTHORIZATION_HEADER, clientSecretBasicAuthScheme);\n+        } else if (clientJwtKey != null) {\n+            // if it is a refresh then a map has already been copied\n+            body = !refresh ? copyMultiMap(body) : body;\n+            body.add(CLIENT_ASSERTION_TYPE, JWT_BEARER_CLIENT_ASSERTION_TYPE);\n+            body.add(CLIENT_ASSERTION, OidcCommonUtils.signJwtWithKey(oidcConfig, clientJwtKey));\n+        }\n+        return request.sendForm(body).onItem()\n+                .transformToUni(resp -> emitGrantTokens(resp, refresh));\n+    }\n+\n+    private Uni<GrantTokens> emitGrantTokens(HttpResponse<Buffer> resp, boolean refresh) {\n+        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super GrantTokens>>() {\n+            @Override\n+            public void accept(UniEmitter<? super GrantTokens> emitter) {\n+                if (resp.statusCode() == 200) {\n+                    LOG.debugf(\"Tokens have been %s\", refresh ? \"refreshed\" : \"acquired\");\n+                    JsonObject json = resp.bodyAsJsonObject();\n+                    final String accessToken = json.getString(ACCESS_TOKEN);\n+                    final String refreshToken = json.getString(REFRESH_TOKEN);\n+                    Long accessTokenExpiresAt = json.getLong(EXPIRES_AT);\n+                    if (accessTokenExpiresAt == null) {\n+                        accessTokenExpiresAt = getExpiresJwtClaim(accessToken);\n+                    }\n+                    emitter.complete(new GrantTokens(accessToken, accessTokenExpiresAt, refreshToken));\n+                } else {\n+                    LOG.errorf(\"%s token grant request has failed: %s\", (refresh ? \"refresh\" : grantType), resp.bodyAsString());\n+                    emitter.fail(new OidcClientException());\n+                }\n+            }\n+        });\n+    }\n+\n+    private static Long getExpiresJwtClaim(String accessToken) {\n+        String[] parts = accessToken.split(\"\\\\.\");\n+        if (parts.length == 3) {\n+            try {\n+                JsonObject claims = new JsonObject(new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8));\n+                return claims.getLong(Claims.exp.name());\n+            } catch (IllegalArgumentException ex) {\n+                return null;", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2MjYxNg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r546962616", "bodyText": "This still needs to be addressed.", "author": "stuartwdouglas", "createdAt": "2020-12-21T22:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE5ODAyOA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r547198028", "bodyText": "@stuartwdouglas sorry, missed it. OK, a token grant response should include an expiry time, but if it is not included, (as in case of Keycloak) then an attempt is made to decode the access token as JWT token and get the exp claim - this exception is only to handle the JsonObject.getLong exception - should not ever happen in practice - but indeed, some debug message should be added", "author": "sberyozkin", "createdAt": "2020-12-22T10:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NDM2MA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543774360", "bodyText": "It does not really matter, but you don't have to use RuntimeValue unless the item can't be proxied. OidcClients is an interface so it is not really needed.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:56:52Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTAxMw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543775013", "bodyText": "There are lots of these 'magic constants' everywhere. I think we should add an OIDCConstants class somewhere with constants for all these.", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:58:33Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        OidcClient defaultClient = createOidcClient(oidcClientsConfig.defaultClient, \"Default\", tlsConfig, vertx);\n+\n+        Map<String, OidcClient> staticOidcClients = new HashMap<>();\n+\n+        for (Map.Entry<String, OidcClientConfig> clientConfig : oidcClientsConfig.namedClients.entrySet()) {\n+            staticOidcClients.put(clientConfig.getKey(),\n+                    createOidcClient(clientConfig.getValue(), clientConfig.getKey(), tlsConfig, vertx));\n+        }\n+\n+        return new RuntimeValue<>(new OidcClientsImpl(defaultClient, staticOidcClients));\n+    }\n+\n+    public Supplier<OidcClient> createOidcClientBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClient>() {\n+\n+            @Override\n+            public OidcClient get() {\n+                return clients.getValue().getClient();\n+            }\n+        };\n+    }\n+\n+    public Supplier<OidcClients> createOidcClientsBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClients>() {\n+\n+            @Override\n+            public OidcClients get() {\n+                return clients.getValue();\n+            }\n+        };\n+    }\n+\n+    protected static OidcClient createOidcClient(OidcClientConfig oidcConfig, String oidcClientId,\n+            TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        if (!oidcConfig.clientEnabled) {\n+            String message = String.format(\"'%s' client configuration is disabled\", oidcClientId);\n+            LOG.debug(message);\n+            return new OidcClient() {\n+\n+                @Override\n+                public Uni<GrantTokens> getTokens() {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public void close() throws IOException {\n+                }\n+            };\n+        }\n+\n+        OidcCommonUtils.verifyCommonConfiguration(oidcConfig);\n+\n+        String authServerUriString = OidcCommonUtils.getAuthServerUrl(oidcConfig);\n+\n+        WebClientOptions options = new WebClientOptions();\n+\n+        URI authServerUri = URI.create(authServerUriString);\n+        if (authServerUri.getPort() != -1) {\n+            options.setDefaultPort(authServerUri.getPort());\n+        }\n+        OidcCommonUtils.setHttpClientOptions(oidcConfig, tlsConfig, options);\n+\n+        WebClient client = WebClient.create(new io.vertx.mutiny.core.Vertx(vertx.get()), options);\n+\n+        String tokenRequestUri = null;\n+        if (!oidcConfig.discoveryEnabled) {\n+            tokenRequestUri = OidcCommonUtils.getOidcEndpointUrl(authServerUriString, oidcConfig.tokenPath);\n+        } else {\n+            tokenRequestUri = discoverTokenRequestUri(client, authServerUriString, oidcConfig);\n+        }\n+        if (tokenRequestUri == null) {\n+            throw new ConfigurationException(\n+                    \"OpenId Connect Provider token endpoint URL is not configured and can not be discovered\");\n+        }\n+\n+        MultiMap tokenGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, tokenGrantParams,\n+                oidcConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\");\n+        if (oidcConfig.grant.type == Grant.Type.USER) {\n+            Map<String, String> passwordGrantOptions = oidcConfig.grantOptions.get(\"user\");\n+            tokenGrantParams.add(\"username\", passwordGrantOptions.get(\"name\"));\n+            tokenGrantParams.add(\"password\", passwordGrantOptions.get(\"password\"));\n+        }\n+\n+        MultiMap commonRefreshGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, commonRefreshGrantParams, \"refresh_token\");\n+\n+        return new OidcClientImpl(client, tokenRequestUri, tokenGrantParams, commonRefreshGrantParams, oidcConfig);\n+    }\n+\n+    private static void setGrantClientParams(OidcClientConfig oidcConfig, MultiMap grantParams, String grantType) {\n+        grantParams.add(\"grant_type\", grantType);\n+        Credentials creds = oidcConfig.getCredentials();\n+        if (OidcCommonUtils.isClientSecretPostAuthRequired(creds)) {\n+            grantParams.add(\"client_id\", oidcConfig.clientId.get());", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyODAzMA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544228030", "bodyText": "@stuartwdouglas good point, now that this PR introduces oidc-common we can have OIDCConstants there, I'll see how it goes, if I have time I'll do it with this PR otheriwise I'll create a follow up issue and take care of it there", "author": "sberyozkin", "createdAt": "2020-12-16T11:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MjQyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545292427", "bodyText": "@stuartwdouglas Just did it, definitely worth it :-), moved a good number of those magic constants from quarkus-oidc-client and a few from quarkus-oidc, more common ones will be added there from now on", "author": "sberyozkin", "createdAt": "2020-12-17T18:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTU5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543775597", "bodyText": "Shouldn't this throw an exception to trigger the retry code above?", "author": "stuartwdouglas", "createdAt": "2020-12-15T23:59:58Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        OidcClient defaultClient = createOidcClient(oidcClientsConfig.defaultClient, \"Default\", tlsConfig, vertx);\n+\n+        Map<String, OidcClient> staticOidcClients = new HashMap<>();\n+\n+        for (Map.Entry<String, OidcClientConfig> clientConfig : oidcClientsConfig.namedClients.entrySet()) {\n+            staticOidcClients.put(clientConfig.getKey(),\n+                    createOidcClient(clientConfig.getValue(), clientConfig.getKey(), tlsConfig, vertx));\n+        }\n+\n+        return new RuntimeValue<>(new OidcClientsImpl(defaultClient, staticOidcClients));\n+    }\n+\n+    public Supplier<OidcClient> createOidcClientBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClient>() {\n+\n+            @Override\n+            public OidcClient get() {\n+                return clients.getValue().getClient();\n+            }\n+        };\n+    }\n+\n+    public Supplier<OidcClients> createOidcClientsBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClients>() {\n+\n+            @Override\n+            public OidcClients get() {\n+                return clients.getValue();\n+            }\n+        };\n+    }\n+\n+    protected static OidcClient createOidcClient(OidcClientConfig oidcConfig, String oidcClientId,\n+            TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        if (!oidcConfig.clientEnabled) {\n+            String message = String.format(\"'%s' client configuration is disabled\", oidcClientId);\n+            LOG.debug(message);\n+            return new OidcClient() {\n+\n+                @Override\n+                public Uni<GrantTokens> getTokens() {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public void close() throws IOException {\n+                }\n+            };\n+        }\n+\n+        OidcCommonUtils.verifyCommonConfiguration(oidcConfig);\n+\n+        String authServerUriString = OidcCommonUtils.getAuthServerUrl(oidcConfig);\n+\n+        WebClientOptions options = new WebClientOptions();\n+\n+        URI authServerUri = URI.create(authServerUriString);\n+        if (authServerUri.getPort() != -1) {\n+            options.setDefaultPort(authServerUri.getPort());\n+        }\n+        OidcCommonUtils.setHttpClientOptions(oidcConfig, tlsConfig, options);\n+\n+        WebClient client = WebClient.create(new io.vertx.mutiny.core.Vertx(vertx.get()), options);\n+\n+        String tokenRequestUri = null;\n+        if (!oidcConfig.discoveryEnabled) {\n+            tokenRequestUri = OidcCommonUtils.getOidcEndpointUrl(authServerUriString, oidcConfig.tokenPath);\n+        } else {\n+            tokenRequestUri = discoverTokenRequestUri(client, authServerUriString, oidcConfig);\n+        }\n+        if (tokenRequestUri == null) {\n+            throw new ConfigurationException(\n+                    \"OpenId Connect Provider token endpoint URL is not configured and can not be discovered\");\n+        }\n+\n+        MultiMap tokenGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, tokenGrantParams,\n+                oidcConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\");\n+        if (oidcConfig.grant.type == Grant.Type.USER) {\n+            Map<String, String> passwordGrantOptions = oidcConfig.grantOptions.get(\"user\");\n+            tokenGrantParams.add(\"username\", passwordGrantOptions.get(\"name\"));\n+            tokenGrantParams.add(\"password\", passwordGrantOptions.get(\"password\"));\n+        }\n+\n+        MultiMap commonRefreshGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, commonRefreshGrantParams, \"refresh_token\");\n+\n+        return new OidcClientImpl(client, tokenRequestUri, tokenGrantParams, commonRefreshGrantParams, oidcConfig);\n+    }\n+\n+    private static void setGrantClientParams(OidcClientConfig oidcConfig, MultiMap grantParams, String grantType) {\n+        grantParams.add(\"grant_type\", grantType);\n+        Credentials creds = oidcConfig.getCredentials();\n+        if (OidcCommonUtils.isClientSecretPostAuthRequired(creds)) {\n+            grantParams.add(\"client_id\", oidcConfig.clientId.get());\n+            grantParams.add(\"client_secret\", OidcCommonUtils.clientSecret(creds));\n+        }\n+        if (oidcConfig.scopes.isPresent()) {\n+            grantParams.add(\"scope\", oidcConfig.scopes.get().stream().collect(Collectors.joining(\" \")));\n+        }\n+    }\n+\n+    private static String discoverTokenRequestUri(WebClient client, String authServerUrl, OidcClientConfig oidcConfig) {\n+        final long connectionRetryCount = OidcCommonUtils.getConnectionRetryCount(oidcConfig);\n+        if (connectionRetryCount > 1) {\n+            LOG.infof(\"Connecting to IDP for up to %d times every 2 seconds\", connectionRetryCount);\n+        }\n+\n+        for (long i = 0; i < connectionRetryCount; i++) {\n+            try {\n+                if (oidcConfig.discoveryEnabled) {\n+                    return discoverTokenEndpoint(client, authServerUrl);\n+                }\n+                break;\n+            } catch (Throwable throwable) {\n+                while (throwable instanceof CompletionException && throwable.getCause() != null) {\n+                    throwable = throwable.getCause();\n+                }\n+                if (throwable instanceof OidcClientException) {\n+                    if (i + 1 < connectionRetryCount) {\n+                        try {\n+                            Thread.sleep(2000);\n+                        } catch (InterruptedException iex) {\n+                            // continue connecting\n+                        }\n+                    } else {\n+                        throw (OidcClientException) throwable;\n+                    }\n+                } else {\n+                    throw new OidcClientException(throwable);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static String discoverTokenEndpoint(WebClient client, String authServerUrl) {\n+        String discoveryUrl = authServerUrl + \"/.well-known/openid-configuration\";\n+        return client.get(discoveryUrl).send().onItem().transform(resp -> {\n+            if (resp.statusCode() == 200) {\n+                JsonObject json = resp.bodyAsJsonObject();\n+                return json.getString(\"token_endpoint\");\n+            } else {\n+                LOG.tracef(\"Discovery has failed, status code: %d\", resp.statusCode());", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNjkwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544226905", "bodyText": "@stuartwdouglas Likely not as it is not a connection error, but the discovery document retrieval problem", "author": "sberyozkin", "createdAt": "2020-12-16T11:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3Njg3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543776877", "bodyText": "At some point we should look at consolidating these into some kind of common utility. It could actually be useful for end users as well to have an easy way to setup keycloak for tests.", "author": "stuartwdouglas", "createdAt": "2020-12-16T00:03:08Z", "path": "extensions/oidc-rest-client/deployment/src/test/java/io/quarkus/oidc/rest/client/KeycloakRealmResourceManager.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.oidc.rest.client;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.keycloak.representations.AccessTokenResponse;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.CredentialRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.RoleRepresentation;\n+import org.keycloak.representations.idm.RolesRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.util.JsonSerialization;\n+\n+import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n+import io.restassured.RestAssured;\n+\n+public class KeycloakRealmResourceManager implements QuarkusTestResourceLifecycleManager {", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyODUzNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544228537", "bodyText": "@stuartwdouglas +1, @cemnura is helping out with improving the test support for OIDC so we can work with him on it", "author": "sberyozkin", "createdAt": "2020-12-16T11:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3Njg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5OTgzNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545299837", "bodyText": "@stuartwdouglas see #13957", "author": "sberyozkin", "createdAt": "2020-12-17T18:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3Njg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3OTM5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543779392", "bodyText": "I don't think you should allow direct injection of the GrantTokens, as there is no CDI scope that this maps to. It would be very easy to accidentally inject them into a long lived object, which will appear to work for a while until the tokens expire (e.g. likely work in tests and staging, then fail once the production env has been up for a while). This example only works because you have made the filter @RequestScoped, which is not something we really encourage.\nI think you should instead inject a GrantTokensProducer, which as a get() and getAsync() method. This object can be application scoped and actually manage the tokens in a thread safe manner so that new tokens don't need to be acquired per request.", "author": "stuartwdouglas", "createdAt": "2020-12-16T00:09:33Z", "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.\n+\n+In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.\n+\n+== Use OidcClient directly\n+\n+One can use `OidcClient` directly as follows:\n+\n+```\n+import javax.inject.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@Path(\"/service\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClient client;\n+\n+    volatile GrantTokens currentTokens;\n+\n+    @PostConstruct\n+    public init() {\n+        currentTokens = client.getTokens().await().indefinitely();\n+    }\n+\n+    @GET\n+    public String getResponse() {\n+        \n+        GrantTokens tokens = currentTokens;\n+        if (tokens.isAccessTokenExpired) {\n+            tokens = client.refreshTokens(tokens.getRefreshToken().await.indefinitely();\n+            currentTokens = tokens;\n+        } \n+        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc\n+    }\n+}\n+```\n+\n+== Use OidcClient as Microprofile RestClient client filter\n+\n+`quarkus-oidc-rest-client` extension provides `io.quarkus.oidc.rest.client.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.\n+\n+By default this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.\n+\n+You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.rest.client.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:\n+\n+```\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientFilter;\n+\n+@RegisterRestClient\n+@OidcClientFilter\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+or\n+\n+```\n+import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientRequestFilter;\n+\n+@RegisterRestClient\n+@RegisterProvider(OidcClientRequestFilter.class)\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc.rest.client.register-filter=true` property is set. \n+\n+\n+== Use injected GrantTokens\n+\n+If you prefer you can use your own custom filter and inject `GrantTokens`:\n+\n+```\n+@Provider\n+@Priority(Priorities.AUTHENTICATION)\n+@RequestScoped\n+public class OidcClientRequestCustomFilter implements ClientRequestFilter {\n+\n+    @Inject\n+    GrantTokens grantTokens;", "originalCommit": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyOTI1OA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r544229258", "bodyText": "@stuartwdouglas As I mentioned above I have a working test - but I'll review that test, may be it is broken :-)", "author": "sberyozkin", "createdAt": "2020-12-16T11:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3OTM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA0MjEyMw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545042123", "bodyText": "@stuartwdouglas Hi Stuart, I've resolved 2 related comments, thanks for highlighting the problems with this specific producer; so, first of all GrantTokens and GrantTokensProducer got renamed based on @pedroigor 's suggestion to simplify so the Grant part has gone from their names.\nTokensProducer is now @Singleton but it @RequestScoped Produces the tokens. Because it is a singleton it gets the initial set of tokens on its initialization time only once and then it will either return them or refresh them. This should be correct now.\nThe other thing about TokensProducer and the injected Tokens is that it is not a main thing this PR is after - OidcClient already provides the direct async access to Tokens, and OidcClientRequestFilter manages them too which is what I'd expect most users would use, injected Tokens is a little utility for those users who just don't want to use the provided filter or OidcClient directly and it now works correctly I believe.\nBy the way, I've added a check log code (where the log is checked that it contains a refresh token confirmation) but what I've found is that apparently, when multiple tests run, as in oidc-client/deployment, the target dir seems to be locked somehow, and this check log only works if I run the individual test,\ni.e, the following works:\nmvn install -Pdocker-keycloak -Ptest-keycloak -Dtest=OidcClientUserPasswordCustomFilterTestCase\n\nThis test would successfully detect target/quarkus.log and check the records there.\nThe same test fails with:\nmvn install -Pdocker-keycloak -Ptest-keycloak\n\nIt runs more than one test, not only OidcClientUserPasswordCustomFilterTestCase, and OidcClientUserPasswordCustomFilterTestCase fails with the message that target/quarkus.log is not available.\nDo you know what may be going on ? I've removed the checkLog code from it for now, as integration-tests/oidc-client also checks the log and it works fine", "author": "sberyozkin", "createdAt": "2020-12-17T12:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3OTM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MTcwNA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r545971704", "bodyText": "@stuartwdouglas I've also updated integration-tests/oidc-client to check that log only contains a single acquisition and refresh entry, there are a few tests there which depend on a singleton OidcClientRequestFilter, before I added @Singleton to it it re-acquiring for every test so yeah now it is all good I think", "author": "sberyozkin", "createdAt": "2020-12-18T17:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3OTM5Mg=="}], "type": "inlineReview"}, {"oid": "37c86c2405c6ea7ae8021dea17c8827ac20d8377", "url": "https://github.com/quarkusio/quarkus/commit/37c86c2405c6ea7ae8021dea17c8827ac20d8377", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-16T21:41:37Z", "type": "forcePushed"}, {"oid": "5eff91f5a8f7f4b4109e25a6ba60f2509459db65", "url": "https://github.com/quarkusio/quarkus/commit/5eff91f5a8f7f4b4109e25a6ba60f2509459db65", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-16T21:46:52Z", "type": "forcePushed"}, {"oid": "b910a9e70b2690f6ca594f7efc4453e0ac282f92", "url": "https://github.com/quarkusio/quarkus/commit/b910a9e70b2690f6ca594f7efc4453e0ac282f92", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-17T11:39:33Z", "type": "forcePushed"}, {"oid": "f3f12eb0a773169a92ce1c9d00e46df49785efe2", "url": "https://github.com/quarkusio/quarkus/commit/f3f12eb0a773169a92ce1c9d00e46df49785efe2", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-17T18:00:08Z", "type": "forcePushed"}, {"oid": "b474c40b2c37ffdb9b79471e235be7f53532f510", "url": "https://github.com/quarkusio/quarkus/commit/b474c40b2c37ffdb9b79471e235be7f53532f510", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-18T17:07:05Z", "type": "forcePushed"}, {"oid": "1250071f3f142be3eac4f7ab81f3488a4f4c788a", "url": "https://github.com/quarkusio/quarkus/commit/1250071f3f142be3eac4f7ab81f3488a4f4c788a", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-20T17:33:14Z", "type": "forcePushed"}, {"oid": "d4da4b8dfc367f396fb9fb508a9bcc451509eba7", "url": "https://github.com/quarkusio/quarkus/commit/d4da4b8dfc367f396fb9fb508a9bcc451509eba7", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-21T18:21:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r546965437", "bodyText": "We can't really do this via locks when you are dealing with reactive code. getTokens() can be called by the same thread for reactive code, but for different requests. The logic below also has a few issues.", "author": "stuartwdouglas", "createdAt": "2020-12-21T22:41:34Z", "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/TokensHelper.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.Tokens;\n+import io.smallrye.mutiny.Uni;\n+\n+public class TokensHelper {\n+\n+    private volatile Tokens tokens;\n+    private ReentrantLock tokenAcquisitionLock = new ReentrantLock();", "originalCommit": "d4da4b8dfc367f396fb9fb508a9bcc451509eba7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwMDg5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r547200896", "bodyText": "@stuartwdouglas, thanks a lot; I have to admit this possibility did not occur to me :-) - I was primarily focused on running this code from the client filter which at this moment of time is not reactive ready yet as if I understand it correctly - Steph said he was only planning to support the reactive client filters in 'regular' RestEasy - but you are right it has to be done right - as I'd like to have these filters running eventually in the reactive mode :-)\nAlso, thanks for getting this code right, let me learn what has changed, cheers", "author": "sberyozkin", "createdAt": "2020-12-22T10:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwNTk0MA==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r547205940", "bodyText": "@stuartwdouglas - compare and swap :-) - I'm getting inspired here and I've just pulled Java Concurrentcy in Practice 2nd edition from the bookshelf though I suspect it may've gone a bit outdated :-)", "author": "sberyozkin", "createdAt": "2020-12-22T10:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwOTY0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r547209649", "bodyText": "@stuartwdouglas - actually - I'm finally getting how to make sure Uni can be kept as a state property, it must be deferred, I've been thinking of keeping it in quarkus-oidc somewhere as a state value but could not get how to do it :-)", "author": "sberyozkin", "createdAt": "2020-12-22T10:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw=="}], "type": "inlineReview"}, {"oid": "267932b6873b65d1ff8a4fd6e39455035912c8b8", "url": "https://github.com/quarkusio/quarkus/commit/267932b6873b65d1ff8a4fd6e39455035912c8b8", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-22T11:44:32Z", "type": "forcePushed"}, {"oid": "e60427e1941a788757c7e92851b0b401d0c4beea", "url": "https://github.com/quarkusio/quarkus/commit/e60427e1941a788757c7e92851b0b401d0c4beea", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-22T17:27:00Z", "type": "forcePushed"}, {"oid": "3050a142d3d65fa8819744ead91007c7bd6e61a6", "url": "https://github.com/quarkusio/quarkus/commit/3050a142d3d65fa8819744ead91007c7bd6e61a6", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-22T17:42:57Z", "type": "forcePushed"}, {"oid": "43c33ba285b5dbb6e7dd21b926fe38cb9b01dd87", "url": "https://github.com/quarkusio/quarkus/commit/43c33ba285b5dbb6e7dd21b926fe38cb9b01dd87", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-24T12:15:56Z", "type": "forcePushed"}, {"oid": "981960220cc86d2a7763b601d9a9ceaed04118b5", "url": "https://github.com/quarkusio/quarkus/commit/981960220cc86d2a7763b601d9a9ceaed04118b5", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2020-12-24T14:52:45Z", "type": "forcePushed"}, {"oid": "879348a03ebdd576caab0938ffa3b9db8c1b7331", "url": "https://github.com/quarkusio/quarkus/commit/879348a03ebdd576caab0938ffa3b9db8c1b7331", "message": "Update the runtime pom descriptions and extension resources", "committedDate": "2021-01-05T12:11:38Z", "type": "forcePushed"}, {"oid": "d3c6b25759011c6623fa93fea296821d963de36d", "url": "https://github.com/quarkusio/quarkus/commit/d3c6b25759011c6623fa93fea296821d963de36d", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2021-01-05T13:15:06Z", "type": "commit"}, {"oid": "d3c6b25759011c6623fa93fea296821d963de36d", "url": "https://github.com/quarkusio/quarkus/commit/d3c6b25759011c6623fa93fea296821d963de36d", "message": "Create oidc-client and oidc-rest-client extensions", "committedDate": "2021-01-05T13:15:06Z", "type": "forcePushed"}]}