{"pr_number": 7579, "pr_title": "OptaPlanner extension guide", "pr_createdAt": "2020-03-04T18:50:15Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7579", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3MjA3MA==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387872070", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n          \n          \n            \n            This guide walks you through the process of creating a Quarkus\n          \n      \n    \n    \n  \n\nNo need for a link here.", "author": "gsmet", "createdAt": "2020-03-04T19:04:58Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3Mzk4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387873989", "bodyText": "I'm not sure this will work on the website. Could you follow how it's done in other guides? See the Kafka one for instance.", "author": "gsmet", "createdAt": "2020-03-04T19:08:36Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM3Mjc4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388372789", "bodyText": "Ah, the issue is not the subdirectory, but the \"images/\" prefix? removing that", "author": "ge0ffrey", "createdAt": "2020-03-05T15:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3Mzk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM4MzY3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388383676", "bodyText": "I'll avoid the subdirectory for now too, just so it's like the others", "author": "ge0ffrey", "createdAt": "2020-03-05T15:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3Mzk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387874733", "bodyText": "Could you please follow how we do it in the other guides? We usually point to the quickstart and provide the command line to create the project. We don't put the Maven file.", "author": "gsmet", "createdAt": "2020-03-04T19:10:03Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM4OTI5NA==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388389294", "bodyText": "The lack of the maven file makes it harder to build the example as a user.\nAlso, in the first step, the maven file doesn't add in hibernate. Only at the end of the guide we talk about adding hibernate and adjusting the SolverManager's usage pattern accordingly. But the intermediate solution (without hibernate) still makes sense for many use cases too.\n\nTherefor, I strongly recommend keeping the maven file. Wydt?", "author": "ge0ffrey", "createdAt": "2020-03-05T15:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyMzgxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388923815", "bodyText": "You don't need the pom file if you are following the same pattern as the other guides: https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/hibernate-search-elasticsearch.adoc#creating-the-maven-project .\nThe command will scaffold the project for you properly.\nI don't understand why it wouldn't work in your case?", "author": "gsmet", "createdAt": "2020-03-06T14:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2NzU1MA==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388967550", "bodyText": "Happy to do that to get this merged - for consistency - but I think it's naive to presume that most people that follow the guide start from scratch: some will do it on top of an existing project (I always did it that way). The spring guides show the entire maven and gradle file, probably for that reason.\nIt's not uncommon for users reading the guide to take their existing project (often result of another guide), copy paste the missing dependencies on it and start doing a similar thing as the guide, only to refactor it - once it works - into what they exactly need. At least I do it like that more often than not to add a new technology :)", "author": "ge0ffrey", "createdAt": "2020-03-06T15:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUxOTE3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r389519172", "bodyText": "@gsmet I 'll reduce the pom.xml to just the dependencies and refer for the rest like the other quarkus guides. Ok?", "author": "ge0ffrey", "createdAt": "2020-03-09T08:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU3NzMwMg==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r389577302", "bodyText": "Done, also added some info around Gradle and added the guide url in optaplanner's quarkus-extension.yaml", "author": "ge0ffrey", "createdAt": "2020-03-09T10:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NDI0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r389984245", "bodyText": "I think I would remove the Gradle instructions to be in line with what we do in the other guides. People can translate easily.", "author": "gsmet", "createdAt": "2020-03-09T21:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NTg5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r390145897", "bodyText": "They can translate, but they want to be able to copy-paste (not everyone starts from scratch). If Gradle is a first class citizen of Gradle, and we want Quarkus to feel friendly for Gradle users, then these need to be here too, just like in the Spring guides. Basically a \"Maven first, Gradle too\" story (just like a \"Java first, Kotlin and Scala too\" story).\nI understand that for consistency you might not want some of the guides to have it and others not. I'd rather just keep them and create an issue to adjust the other guides too. Alternatively, we could comment out the gradle instructions for now... Wdyt?\n\nSource: https://snyk.io/blog/jvm-ecosystem-report-2020/", "author": "ge0ffrey", "createdAt": "2020-03-10T08:07:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1NzcwOA==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r390657708", "bodyText": "I think I would rather hide them for now.\nI'm not sure we want to clutter each guide with Gradle stuff so we would have to discuss that first.", "author": "gsmet", "createdAt": "2020-03-10T22:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwOTg0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r390809843", "bodyText": "As you wish", "author": "ge0ffrey", "createdAt": "2020-03-11T08:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxMjAzNg==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r390812036", "bodyText": "@gsmet Done (hidden gradle instructions). Rebased on master and squashed. No more open conversations that I am aware of. Should be good to merge :)", "author": "ge0ffrey", "createdAt": "2020-03-11T08:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NzM3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387877375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * If it adheres to all hard constraints, then it is an _feasible_ solution,\n          \n          \n            \n            * If it adheres to all hard constraints, then it is a _feasible_ solution,", "author": "gsmet", "createdAt": "2020-03-04T19:15:02Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3ODA2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387878067", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n          \n          \n            \n            Following the same logic, the `roomList` field also has an `@ValueRangeProvider` annotation.", "author": "gsmet", "createdAt": "2020-03-04T19:16:19Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTUyNw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387879527", "bodyText": "can you use proper source blocks? These ones don't look good on the website.", "author": "gsmet", "createdAt": "2020-03-04T19:18:53Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTYzMA==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387879630", "bodyText": "Same here for the source block.", "author": "gsmet", "createdAt": "2020-03-04T19:19:05Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTgzMg==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387879832", "bodyText": "source block", "author": "gsmet", "createdAt": "2020-03-04T19:19:27Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:\n+\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTkwOA==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387879908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the service returns output similar to the following example:\n          \n          \n            \n            the service returns an output similar to the following example:\n          \n      \n    \n    \n  \n\n?", "author": "gsmet", "createdAt": "2020-03-04T19:19:36Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MDA4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387880086", "bodyText": "source block", "author": "gsmet", "createdAt": "2020-03-04T19:19:57Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:\n+\n+----\n+HTTP/1.1 200\n+Content-Type: application/json\n+...\n+\n+{\"timeslotList\":...,\"roomList\":...,\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room B\"}},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room B\"}}],\"score\":\"0hard/0soft\"}\n+----\n+\n+Notice that your application assigned all four lessons to one of the two time slots and one of the two rooms.\n+Also notice that it conforms to all hard constraints.\n+For example, M. Curie's two lessons are in different time slots.\n+\n+On the server side, the `info` log show what OptaPlanner did in those five seconds:\n+\n+[options=\"nowrap\"]\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTExNw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387881117", "bodyText": "I wonder if you should use a JSON formatter to format the output and make things more readable? You could add jq as a prerequisite and use it to format the JSON outputs?", "author": "gsmet", "createdAt": "2020-03-04T19:21:48Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:\n+\n+----\n+HTTP/1.1 200\n+Content-Type: application/json\n+...\n+\n+{\"timeslotList\":...,\"roomList\":...,\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room B\"}},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room B\"}}],\"score\":\"0hard/0soft\"}\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQwNDY1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388404652", "bodyText": "I also thought about it, seeing it in other examples, but I am not sure if it's worth the cost:\n\nan extra prerequisite (a hoop to jump through to get started)\nthat json is already abbreviated, notice the \"...\" in there - it doesn't help parsing\na pretty json is still no visualization of the schedule: it's impractical to see broken hard constraints in there. A UI is needed to visualize the schedule (optaplanner != hibernate in that aspect), that's why we have that JS file in the quickstart...\n\nI feel the pain though.", "author": "ge0ffrey", "createdAt": "2020-03-05T16:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTMxMg==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387881312", "bodyText": "Source block.", "author": "gsmet", "createdAt": "2020-03-04T19:22:13Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:\n+\n+----\n+HTTP/1.1 200\n+Content-Type: application/json\n+...\n+\n+{\"timeslotList\":...,\"roomList\":...,\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room B\"}},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room B\"}}],\"score\":\"0hard/0soft\"}\n+----\n+\n+Notice that your application assigned all four lessons to one of the two time slots and one of the two rooms.\n+Also notice that it conforms to all hard constraints.\n+For example, M. Curie's two lessons are in different time slots.\n+\n+On the server side, the `info` log show what OptaPlanner did in those five seconds:\n+\n+[options=\"nowrap\"]\n+----\n+... Solving started: time spent (33), best score (-8init/0hard/0soft), environment mode (REPRODUCIBLE), random (JDK with seed 0).\n+... Construction Heuristic phase (0) ended: time spent (73), best score (0hard/0soft), score calculation speed (459/sec), step total (4).\n+... Local Search phase (1) ended: time spent (5000), best score (0hard/0soft), score calculation speed (28949/sec), step total (28398).\n+... Solving ended: time spent (5000), best score (0hard/0soft), score calculation speed (28524/sec), phase total (2), environment mode (REPRODUCIBLE).\n+----\n+\n+=== Test the application\n+\n+A good application includes test coverage.\n+In a JUnit test, generate a test dataset and send it to the `TimeTableResource` to solve.\n+\n+Create the `src/test/java/org/acme/solver/TimeTableResourceTest.java` class:\n+\n+[source,java]\n+----\n+package org.acme;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.acme.domain.Room;\n+import org.acme.domain.Timeslot;\n+import org.acme.domain.Lesson;\n+import org.acme.domain.TimeTable;\n+import org.acme.rest.TimeTableResource;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@QuarkusTest\n+public class TimeTableResourceTest {\n+\n+    @Inject\n+    private TimeTableResource timeTableResource;\n+\n+    @Test\n+    @Timeout(600_000)\n+    public void solve() {\n+        TimeTable problem = generateProblem();\n+        TimeTable solution = timeTableResource.solve(problem);\n+        assertFalse(solution.getLessonList().isEmpty());\n+        for (Lesson lesson : solution.getLessonList()) {\n+            assertNotNull(lesson.getTimeslot());\n+            assertNotNull(lesson.getRoom());\n+        }\n+        assertTrue(solution.getScore().isFeasible());\n+    }\n+\n+    private TimeTable generateProblem() {\n+        List<Timeslot> timeslotList = new ArrayList<>();\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(8, 30), LocalTime.of(9, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(9, 30), LocalTime.of(10, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(10, 30), LocalTime.of(11, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(13, 30), LocalTime.of(14, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(14, 30), LocalTime.of(15, 30)));\n+\n+        List<Room> roomList = new ArrayList<>();\n+        roomList.add(new Room(\"Room A\"));\n+        roomList.add(new Room(\"Room B\"));\n+        roomList.add(new Room(\"Room C\"));\n+\n+        List<Lesson> lessonList = new ArrayList<>();\n+        lessonList.add(new Lesson(101L, \"Math\", \"B. May\", \"9th grade\"));\n+        lessonList.add(new Lesson(102L, \"Physics\", \"M. Curie\", \"9th grade\"));\n+        lessonList.add(new Lesson(103L, \"Geography\", \"M. Polo\", \"9th grade\"));\n+        lessonList.add(new Lesson(104L, \"English\", \"I. Jones\", \"9th grade\"));\n+        lessonList.add(new Lesson(105L, \"Spanish\", \"P. Cruz\", \"9th grade\"));\n+\n+        lessonList.add(new Lesson(201L, \"Math\", \"B. May\", \"10th grade\"));\n+        lessonList.add(new Lesson(202L, \"Chemistry\", \"M. Curie\", \"10th grade\"));\n+        lessonList.add(new Lesson(203L, \"History\", \"I. Jones\", \"10th grade\"));\n+        lessonList.add(new Lesson(204L, \"English\", \"P. Cruz\", \"10th grade\"));\n+        lessonList.add(new Lesson(205L, \"French\", \"M. Curie\", \"10th grade\"));\n+        return new TimeTable(timeslotList, roomList, lessonList);\n+    }\n+\n+}\n+----\n+\n+This test verifies that after solving, all lessons are assigned to a time slot and a room.\n+It also verifies that it found a feasible solution (no hard constraints broken).\n+\n+Add a test properties to the `src/main/resources/application.properties` file:\n+\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTczMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387881731", "bodyText": "Source block.", "author": "gsmet", "createdAt": "2020-03-04T19:22:54Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:\n+\n+----\n+HTTP/1.1 200\n+Content-Type: application/json\n+...\n+\n+{\"timeslotList\":...,\"roomList\":...,\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room B\"}},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room B\"}}],\"score\":\"0hard/0soft\"}\n+----\n+\n+Notice that your application assigned all four lessons to one of the two time slots and one of the two rooms.\n+Also notice that it conforms to all hard constraints.\n+For example, M. Curie's two lessons are in different time slots.\n+\n+On the server side, the `info` log show what OptaPlanner did in those five seconds:\n+\n+[options=\"nowrap\"]\n+----\n+... Solving started: time spent (33), best score (-8init/0hard/0soft), environment mode (REPRODUCIBLE), random (JDK with seed 0).\n+... Construction Heuristic phase (0) ended: time spent (73), best score (0hard/0soft), score calculation speed (459/sec), step total (4).\n+... Local Search phase (1) ended: time spent (5000), best score (0hard/0soft), score calculation speed (28949/sec), step total (28398).\n+... Solving ended: time spent (5000), best score (0hard/0soft), score calculation speed (28524/sec), phase total (2), environment mode (REPRODUCIBLE).\n+----\n+\n+=== Test the application\n+\n+A good application includes test coverage.\n+In a JUnit test, generate a test dataset and send it to the `TimeTableResource` to solve.\n+\n+Create the `src/test/java/org/acme/solver/TimeTableResourceTest.java` class:\n+\n+[source,java]\n+----\n+package org.acme;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.acme.domain.Room;\n+import org.acme.domain.Timeslot;\n+import org.acme.domain.Lesson;\n+import org.acme.domain.TimeTable;\n+import org.acme.rest.TimeTableResource;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@QuarkusTest\n+public class TimeTableResourceTest {\n+\n+    @Inject\n+    private TimeTableResource timeTableResource;\n+\n+    @Test\n+    @Timeout(600_000)\n+    public void solve() {\n+        TimeTable problem = generateProblem();\n+        TimeTable solution = timeTableResource.solve(problem);\n+        assertFalse(solution.getLessonList().isEmpty());\n+        for (Lesson lesson : solution.getLessonList()) {\n+            assertNotNull(lesson.getTimeslot());\n+            assertNotNull(lesson.getRoom());\n+        }\n+        assertTrue(solution.getScore().isFeasible());\n+    }\n+\n+    private TimeTable generateProblem() {\n+        List<Timeslot> timeslotList = new ArrayList<>();\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(8, 30), LocalTime.of(9, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(9, 30), LocalTime.of(10, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(10, 30), LocalTime.of(11, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(13, 30), LocalTime.of(14, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(14, 30), LocalTime.of(15, 30)));\n+\n+        List<Room> roomList = new ArrayList<>();\n+        roomList.add(new Room(\"Room A\"));\n+        roomList.add(new Room(\"Room B\"));\n+        roomList.add(new Room(\"Room C\"));\n+\n+        List<Lesson> lessonList = new ArrayList<>();\n+        lessonList.add(new Lesson(101L, \"Math\", \"B. May\", \"9th grade\"));\n+        lessonList.add(new Lesson(102L, \"Physics\", \"M. Curie\", \"9th grade\"));\n+        lessonList.add(new Lesson(103L, \"Geography\", \"M. Polo\", \"9th grade\"));\n+        lessonList.add(new Lesson(104L, \"English\", \"I. Jones\", \"9th grade\"));\n+        lessonList.add(new Lesson(105L, \"Spanish\", \"P. Cruz\", \"9th grade\"));\n+\n+        lessonList.add(new Lesson(201L, \"Math\", \"B. May\", \"10th grade\"));\n+        lessonList.add(new Lesson(202L, \"Chemistry\", \"M. Curie\", \"10th grade\"));\n+        lessonList.add(new Lesson(203L, \"History\", \"I. Jones\", \"10th grade\"));\n+        lessonList.add(new Lesson(204L, \"English\", \"P. Cruz\", \"10th grade\"));\n+        lessonList.add(new Lesson(205L, \"French\", \"M. Curie\", \"10th grade\"));\n+        return new TimeTable(timeslotList, roomList, lessonList);\n+    }\n+\n+}\n+----\n+\n+This test verifies that after solving, all lessons are assigned to a time slot and a room.\n+It also verifies that it found a feasible solution (no hard constraints broken).\n+\n+Add a test properties to the `src/main/resources/application.properties` file:\n+\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+\n+# Effectively disable this termination in favor of the best-score-limit\n+%test.quarkus.optaplanner.solver.termination.spent-limit=1h\n+%test.quarkus.optaplanner.solver.termination.best-score-limit=0hard/*soft\n+----\n+\n+Normally, the solver finds a feasible solution in less than 200 milliseconds.\n+Notice how the `application.properties` overwrites the solver termination during tests\n+to terminate as soon as a feasible solution (`0hard/*soft`) is found.\n+This avoids hard coding a solver time, because the unit test might run on arbitrary hardware.\n+This approach ensures that the test runs long enough to find a feasible solution, even on slow machines.\n+But it does not run a millisecond longer than it strictly must, even on fast machines.\n+\n+=== Logging\n+\n+When adding constraints in your `ConstraintProvider`,\n+keep an eye on the _score calculation speed_ in the `info` log,\n+after solving for the same amount of time, to assess the performance impact:\n+\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE2MzY1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388163659", "bodyText": "@gsmet This is console output (logging). What is the best way to format that?\nA) Nothing, it's not source code\nB) [source,shell] What happens if that contains a log line with shell keywords?\nC) [source]", "author": "ge0ffrey", "createdAt": "2020-03-05T09:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE2NTc3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388165777", "bodyText": "You can just use [source]. We don't have proper formatting on the website if we don't have that.", "author": "gsmet", "createdAt": "2020-03-05T09:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTg1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387881857", "bodyText": "Source block.", "author": "gsmet", "createdAt": "2020-03-04T19:23:09Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:\n+\n+----\n+HTTP/1.1 200\n+Content-Type: application/json\n+...\n+\n+{\"timeslotList\":...,\"roomList\":...,\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room B\"}},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room B\"}}],\"score\":\"0hard/0soft\"}\n+----\n+\n+Notice that your application assigned all four lessons to one of the two time slots and one of the two rooms.\n+Also notice that it conforms to all hard constraints.\n+For example, M. Curie's two lessons are in different time slots.\n+\n+On the server side, the `info` log show what OptaPlanner did in those five seconds:\n+\n+[options=\"nowrap\"]\n+----\n+... Solving started: time spent (33), best score (-8init/0hard/0soft), environment mode (REPRODUCIBLE), random (JDK with seed 0).\n+... Construction Heuristic phase (0) ended: time spent (73), best score (0hard/0soft), score calculation speed (459/sec), step total (4).\n+... Local Search phase (1) ended: time spent (5000), best score (0hard/0soft), score calculation speed (28949/sec), step total (28398).\n+... Solving ended: time spent (5000), best score (0hard/0soft), score calculation speed (28524/sec), phase total (2), environment mode (REPRODUCIBLE).\n+----\n+\n+=== Test the application\n+\n+A good application includes test coverage.\n+In a JUnit test, generate a test dataset and send it to the `TimeTableResource` to solve.\n+\n+Create the `src/test/java/org/acme/solver/TimeTableResourceTest.java` class:\n+\n+[source,java]\n+----\n+package org.acme;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.acme.domain.Room;\n+import org.acme.domain.Timeslot;\n+import org.acme.domain.Lesson;\n+import org.acme.domain.TimeTable;\n+import org.acme.rest.TimeTableResource;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@QuarkusTest\n+public class TimeTableResourceTest {\n+\n+    @Inject\n+    private TimeTableResource timeTableResource;\n+\n+    @Test\n+    @Timeout(600_000)\n+    public void solve() {\n+        TimeTable problem = generateProblem();\n+        TimeTable solution = timeTableResource.solve(problem);\n+        assertFalse(solution.getLessonList().isEmpty());\n+        for (Lesson lesson : solution.getLessonList()) {\n+            assertNotNull(lesson.getTimeslot());\n+            assertNotNull(lesson.getRoom());\n+        }\n+        assertTrue(solution.getScore().isFeasible());\n+    }\n+\n+    private TimeTable generateProblem() {\n+        List<Timeslot> timeslotList = new ArrayList<>();\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(8, 30), LocalTime.of(9, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(9, 30), LocalTime.of(10, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(10, 30), LocalTime.of(11, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(13, 30), LocalTime.of(14, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(14, 30), LocalTime.of(15, 30)));\n+\n+        List<Room> roomList = new ArrayList<>();\n+        roomList.add(new Room(\"Room A\"));\n+        roomList.add(new Room(\"Room B\"));\n+        roomList.add(new Room(\"Room C\"));\n+\n+        List<Lesson> lessonList = new ArrayList<>();\n+        lessonList.add(new Lesson(101L, \"Math\", \"B. May\", \"9th grade\"));\n+        lessonList.add(new Lesson(102L, \"Physics\", \"M. Curie\", \"9th grade\"));\n+        lessonList.add(new Lesson(103L, \"Geography\", \"M. Polo\", \"9th grade\"));\n+        lessonList.add(new Lesson(104L, \"English\", \"I. Jones\", \"9th grade\"));\n+        lessonList.add(new Lesson(105L, \"Spanish\", \"P. Cruz\", \"9th grade\"));\n+\n+        lessonList.add(new Lesson(201L, \"Math\", \"B. May\", \"10th grade\"));\n+        lessonList.add(new Lesson(202L, \"Chemistry\", \"M. Curie\", \"10th grade\"));\n+        lessonList.add(new Lesson(203L, \"History\", \"I. Jones\", \"10th grade\"));\n+        lessonList.add(new Lesson(204L, \"English\", \"P. Cruz\", \"10th grade\"));\n+        lessonList.add(new Lesson(205L, \"French\", \"M. Curie\", \"10th grade\"));\n+        return new TimeTable(timeslotList, roomList, lessonList);\n+    }\n+\n+}\n+----\n+\n+This test verifies that after solving, all lessons are assigned to a time slot and a room.\n+It also verifies that it found a feasible solution (no hard constraints broken).\n+\n+Add a test properties to the `src/main/resources/application.properties` file:\n+\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+\n+# Effectively disable this termination in favor of the best-score-limit\n+%test.quarkus.optaplanner.solver.termination.spent-limit=1h\n+%test.quarkus.optaplanner.solver.termination.best-score-limit=0hard/*soft\n+----\n+\n+Normally, the solver finds a feasible solution in less than 200 milliseconds.\n+Notice how the `application.properties` overwrites the solver termination during tests\n+to terminate as soon as a feasible solution (`0hard/*soft`) is found.\n+This avoids hard coding a solver time, because the unit test might run on arbitrary hardware.\n+This approach ensures that the test runs long enough to find a feasible solution, even on slow machines.\n+But it does not run a millisecond longer than it strictly must, even on fast machines.\n+\n+=== Logging\n+\n+When adding constraints in your `ConstraintProvider`,\n+keep an eye on the _score calculation speed_ in the `info` log,\n+after solving for the same amount of time, to assess the performance impact:\n+\n+----\n+... Solving ended: ..., score calculation speed (29455/sec), ...\n+----\n+\n+To understand how OptaPlanner is solving your problem internally,\n+change the logging in the `application.properties` file or with a `-D` system property:\n+\n+[source,properties]\n+----\n+quarkus.log.category.\"org.optaplanner\".level=debug\n+----\n+\n+Use `debug` logging to show every _step_:\n+\n+[options=\"nowrap\"]\n+----", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MjAyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387882021", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You have just developed a https://quarkus.io/[Quarkus] application with https://www.optaplanner.org/[OptaPlanner]!\n          \n          \n            \n            You have just developed a Quarkus application with https://www.optaplanner.org/[OptaPlanner]!", "author": "gsmet", "createdAt": "2020-03-04T19:23:28Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:\n+\n+----\n+HTTP/1.1 200\n+Content-Type: application/json\n+...\n+\n+{\"timeslotList\":...,\"roomList\":...,\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room B\"}},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room B\"}}],\"score\":\"0hard/0soft\"}\n+----\n+\n+Notice that your application assigned all four lessons to one of the two time slots and one of the two rooms.\n+Also notice that it conforms to all hard constraints.\n+For example, M. Curie's two lessons are in different time slots.\n+\n+On the server side, the `info` log show what OptaPlanner did in those five seconds:\n+\n+[options=\"nowrap\"]\n+----\n+... Solving started: time spent (33), best score (-8init/0hard/0soft), environment mode (REPRODUCIBLE), random (JDK with seed 0).\n+... Construction Heuristic phase (0) ended: time spent (73), best score (0hard/0soft), score calculation speed (459/sec), step total (4).\n+... Local Search phase (1) ended: time spent (5000), best score (0hard/0soft), score calculation speed (28949/sec), step total (28398).\n+... Solving ended: time spent (5000), best score (0hard/0soft), score calculation speed (28524/sec), phase total (2), environment mode (REPRODUCIBLE).\n+----\n+\n+=== Test the application\n+\n+A good application includes test coverage.\n+In a JUnit test, generate a test dataset and send it to the `TimeTableResource` to solve.\n+\n+Create the `src/test/java/org/acme/solver/TimeTableResourceTest.java` class:\n+\n+[source,java]\n+----\n+package org.acme;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.acme.domain.Room;\n+import org.acme.domain.Timeslot;\n+import org.acme.domain.Lesson;\n+import org.acme.domain.TimeTable;\n+import org.acme.rest.TimeTableResource;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@QuarkusTest\n+public class TimeTableResourceTest {\n+\n+    @Inject\n+    private TimeTableResource timeTableResource;\n+\n+    @Test\n+    @Timeout(600_000)\n+    public void solve() {\n+        TimeTable problem = generateProblem();\n+        TimeTable solution = timeTableResource.solve(problem);\n+        assertFalse(solution.getLessonList().isEmpty());\n+        for (Lesson lesson : solution.getLessonList()) {\n+            assertNotNull(lesson.getTimeslot());\n+            assertNotNull(lesson.getRoom());\n+        }\n+        assertTrue(solution.getScore().isFeasible());\n+    }\n+\n+    private TimeTable generateProblem() {\n+        List<Timeslot> timeslotList = new ArrayList<>();\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(8, 30), LocalTime.of(9, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(9, 30), LocalTime.of(10, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(10, 30), LocalTime.of(11, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(13, 30), LocalTime.of(14, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(14, 30), LocalTime.of(15, 30)));\n+\n+        List<Room> roomList = new ArrayList<>();\n+        roomList.add(new Room(\"Room A\"));\n+        roomList.add(new Room(\"Room B\"));\n+        roomList.add(new Room(\"Room C\"));\n+\n+        List<Lesson> lessonList = new ArrayList<>();\n+        lessonList.add(new Lesson(101L, \"Math\", \"B. May\", \"9th grade\"));\n+        lessonList.add(new Lesson(102L, \"Physics\", \"M. Curie\", \"9th grade\"));\n+        lessonList.add(new Lesson(103L, \"Geography\", \"M. Polo\", \"9th grade\"));\n+        lessonList.add(new Lesson(104L, \"English\", \"I. Jones\", \"9th grade\"));\n+        lessonList.add(new Lesson(105L, \"Spanish\", \"P. Cruz\", \"9th grade\"));\n+\n+        lessonList.add(new Lesson(201L, \"Math\", \"B. May\", \"10th grade\"));\n+        lessonList.add(new Lesson(202L, \"Chemistry\", \"M. Curie\", \"10th grade\"));\n+        lessonList.add(new Lesson(203L, \"History\", \"I. Jones\", \"10th grade\"));\n+        lessonList.add(new Lesson(204L, \"English\", \"P. Cruz\", \"10th grade\"));\n+        lessonList.add(new Lesson(205L, \"French\", \"M. Curie\", \"10th grade\"));\n+        return new TimeTable(timeslotList, roomList, lessonList);\n+    }\n+\n+}\n+----\n+\n+This test verifies that after solving, all lessons are assigned to a time slot and a room.\n+It also verifies that it found a feasible solution (no hard constraints broken).\n+\n+Add a test properties to the `src/main/resources/application.properties` file:\n+\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+\n+# Effectively disable this termination in favor of the best-score-limit\n+%test.quarkus.optaplanner.solver.termination.spent-limit=1h\n+%test.quarkus.optaplanner.solver.termination.best-score-limit=0hard/*soft\n+----\n+\n+Normally, the solver finds a feasible solution in less than 200 milliseconds.\n+Notice how the `application.properties` overwrites the solver termination during tests\n+to terminate as soon as a feasible solution (`0hard/*soft`) is found.\n+This avoids hard coding a solver time, because the unit test might run on arbitrary hardware.\n+This approach ensures that the test runs long enough to find a feasible solution, even on slow machines.\n+But it does not run a millisecond longer than it strictly must, even on fast machines.\n+\n+=== Logging\n+\n+When adding constraints in your `ConstraintProvider`,\n+keep an eye on the _score calculation speed_ in the `info` log,\n+after solving for the same amount of time, to assess the performance impact:\n+\n+----\n+... Solving ended: ..., score calculation speed (29455/sec), ...\n+----\n+\n+To understand how OptaPlanner is solving your problem internally,\n+change the logging in the `application.properties` file or with a `-D` system property:\n+\n+[source,properties]\n+----\n+quarkus.log.category.\"org.optaplanner\".level=debug\n+----\n+\n+Use `debug` logging to show every _step_:\n+\n+[options=\"nowrap\"]\n+----\n+... Solving started: time spent (67), best score (-20init/0hard/0soft), environment mode (REPRODUCIBLE), random (JDK with seed 0).\n+...     CH step (0), time spent (128), score (-18init/0hard/0soft), selected move count (15), picked move ([Math(101) {null -> Room A}, Math(101) {null -> MONDAY 08:30}]).\n+...     CH step (1), time spent (145), score (-16init/0hard/0soft), selected move count (15), picked move ([Physics(102) {null -> Room A}, Physics(102) {null -> MONDAY 09:30}]).\n+...\n+----\n+\n+Use `trace` logging to show every _step_ and every _move_ per step.\n+\n+== Summary\n+\n+Congratulations!\n+You have just developed a https://quarkus.io/[Quarkus] application with https://www.optaplanner.org/[OptaPlanner]!", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MjcxNg==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r387882716", "bodyText": "This should be at the beginning as mentioned above.", "author": "gsmet", "createdAt": "2020-03-04T19:24:45Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1034 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a https://quarkus.io/[Quarkus]\n+application with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::images/optaplanner/timeTableAppScreenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* about 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+\n+== The build file and the dependencies\n+\n+Use https://code.quarkus.io/[code.quarkus.io] to generate an application\n+with the following extensions:\n+\n+* RESTEasy JAX-RS (`quarkus-resteasy`)\n+* RESTEasy Jackson (`quarkus-resteasy-jackson`)\n+* OptaPlanner (`quarkus-optaplanner`)\n+* OptaPlanner Jackson (`quarkus-optaplanner-jackson`)\n+\n+In Maven, your `pom.xml` file has the following content:\n+\n+[source,xml]\n+----\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <modelVersion>4.0.0</modelVersion>\n+  <groupId>org.acme</groupId>\n+  <artifactId>acme-optaplanner</artifactId>\n+  <version>1.0.0-SNAPSHOT</version>\n+\n+  <properties>\n+    <quarkus.version>...</quarkus.version>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+    <maven.compiler.target>1.8</maven.compiler.target>\n+    <maven.compiler.source>1.8</maven.compiler.source>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+  </properties>\n+\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-bom</artifactId>\n+        <version>${quarkus.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-maven-plugin</artifactId>\n+        <version>${quarkus.version}</version>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>build</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>\n+----\n+\n+== Model the domain objects\n+\n+Your goal is to assign each lesson to a time slot and a room.\n+You will create these classes:\n+\n+image::images/optaplanner/timeTableClassDiagramPure.png[]\n+\n+=== Timeslot\n+\n+The `Timeslot` class represents a time interval when lessons are taught,\n+for example, `Monday 10:30 - 11:30` or `Tuesday 13:30 - 14:30`.\n+For simplicity's sake, all time slots have the same duration\n+and there are no time slots during lunch or other breaks.\n+\n+A time slot has no date, because a high school schedule just repeats every week.\n+So there is no need for https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#continuousPlanning[continuous planning].\n+\n+Create the `src/main/java/org/acme/domain/Timeslot.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+\n+public class Timeslot {\n+\n+    private DayOfWeek dayOfWeek;\n+    private LocalTime startTime;\n+    private LocalTime endTime;\n+\n+    public Timeslot() {\n+    }\n+\n+    public Timeslot(DayOfWeek dayOfWeek, LocalTime startTime, LocalTime endTime) {\n+        this.dayOfWeek = dayOfWeek;\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+    }\n+\n+    public DayOfWeek getDayOfWeek() {\n+        return dayOfWeek;\n+    }\n+\n+    public LocalTime getStartTime() {\n+        return startTime;\n+    }\n+\n+    public LocalTime getEndTime() {\n+        return endTime;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return dayOfWeek + \" \" + startTime.toString();\n+    }\n+\n+}\n+----\n+\n+Because no `Timeslot` instances change during solving, a `Timeslot` is called a _problem fact_.\n+Such classes do not require any OptaPlanner specific annotations.\n+\n+Notice the `toString()` method keeps the output short,\n+so it is easier to read OptaPlanner's `DEBUG` or `TRACE` log, as shown later.\n+\n+=== Room\n+\n+The `Room` class represents a location where lessons are taught,\n+for example, `Room A` or `Room B`.\n+For simplicity's sake, all rooms are without capacity limits\n+and they can accommodate all lessons.\n+\n+Create the `src/main/java/org/acme/domain/Room.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+public class Room {\n+\n+    private String name;\n+\n+    public Room() {\n+    }\n+\n+    public Room(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+}\n+----\n+\n+`Room` instances do not change during solving, so `Room` is also a _problem fact_.\n+\n+=== Lesson\n+\n+During a lesson, represented by the `Lesson` class,\n+a teacher teaches a subject to a group of students,\n+for example, `Math by A.Turing for 9th grade` or `Chemistry by M.Curie for 10th grade`.\n+If a subject is taught multiple times per week by the same teacher to the same student group,\n+there are multiple `Lesson` instances that are only distinguishable by `id`.\n+For example, the 9th grade has six math lessons a week.\n+\n+During solving, OptaPlanner changes the `timeslot` and `room` fields of the `Lesson` class,\n+to assign each lesson to a time slot and a room.\n+Because OptaPlanner changes these fields, `Lesson` is a _planning entity_:\n+\n+image::images/optaplanner/timeTableClassDiagramAnnotated.png[]\n+\n+Most of the fields in the previous diagram contain input data, except for the orange fields:\n+A lesson's `timeslot` and `room` fields are unassigned (`null`) in the input data\n+and assigned (not `null`) in the output data.\n+OptaPlanner changes these fields during solving.\n+Such fields are called planning variables.\n+In order for OptaPlanner to recognize them,\n+both the `timeslot` and `room` fields require an `@PlanningVariable` annotation.\n+Their containing class, `Lesson`, requires an `@PlanningEntity` annotation.\n+\n+Create the `src/main/java/org/acme/domain/Lesson.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.lookup.PlanningId;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+\n+@PlanningEntity\n+public class Lesson {\n+\n+    @PlanningId\n+    private Long id;\n+\n+    private String subject;\n+    private String teacher;\n+    private String studentGroup;\n+\n+    @PlanningVariable(valueRangeProviderRefs = \"timeslotRange\")\n+    private Timeslot timeslot;\n+    @PlanningVariable(valueRangeProviderRefs = \"roomRange\")\n+    private Room room;\n+\n+    public Lesson() {\n+    }\n+\n+    public Lesson(Long id, String subject, String teacher, String studentGroup) {\n+        this.id = id;\n+        this.subject = subject;\n+        this.teacher = teacher;\n+        this.studentGroup = studentGroup;\n+    }\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public String getSubject() {\n+        return subject;\n+    }\n+\n+    public String getTeacher() {\n+        return teacher;\n+    }\n+\n+    public String getStudentGroup() {\n+        return studentGroup;\n+    }\n+\n+    public Timeslot getTimeslot() {\n+        return timeslot;\n+    }\n+\n+    public void setTimeslot(Timeslot timeslot) {\n+        this.timeslot = timeslot;\n+    }\n+\n+    public Room getRoom() {\n+        return room;\n+    }\n+\n+    public void setRoom(Room room) {\n+        this.room = room;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return subject + \"(\" + id + \")\";\n+    }\n+\n+}\n+----\n+\n+The `Lesson` class has an `@PlanningEntity` annotation,\n+so OptaPlanner knows that this class changes during solving\n+because it contains one or more planning variables.\n+\n+The `timeslot` field has an `@PlanningVariable` annotation,\n+so OptaPlanner knows that it can change its value.\n+In order to find potential `Timeslot` instances to assign to this field,\n+OptaPlanner uses the `valueRangeProviderRefs` property to connect to a value range provider\n+(explained later) that provides a `List<Timeslot>` to pick from.\n+\n+The `room` field also has an `@PlanningVariable` annotation, for the same reasons.\n+\n+[NOTE]\n+====\n+Determining the `@PlanningVariable` fields for an arbitrary constraint solving use case\n+is often challenging the first time.\n+Read https://docs.optaplanner.org/latestFinal/optaplanner-docs/html_single/index.html#domainModelingGuide[the domain modeling guidelines]\n+to avoid common pitfalls.\n+====\n+\n+== Define the constraints and calculate the score\n+\n+A _score_ represents the quality of a given solution.\n+The higher the better.\n+OptaPlanner looks for the best solution, which is the solution with the highest score found in the available time.\n+It could be the _optimal_ solution.\n+\n+Because this use case has hard and soft constraints,\n+use the `HardSoftScore` class to represent the score:\n+\n+* Hard constraints must not be broken. For example: _A room can have at most one lesson at the same time._\n+* Soft constraints should not be broken. For example: _A teacher prefers to teach in a single room._\n+\n+Hard constraints are weighted against other hard constraints.\n+Soft constraints are weighted too, against other soft constraints.\n+*Hard constraints always outweigh soft constraints*, regardless of their respective weights.\n+\n+To calculate the score, you could implement an `EasyScoreCalculator` class:\n+\n+[source,java]\n+----\n+public class TimeTableEasyScoreCalculator implements EasyScoreCalculator<TimeTable> {\n+\n+    @Override\n+    public HardSoftScore calculateScore(TimeTable timeTable) {\n+        List<Lesson> lessonList = timeTable.getLessonList();\n+        int hardScore = 0;\n+        for (Lesson a : lessonList) {\n+            for (Lesson b : lessonList) {\n+                if (a.getTimeslot() != null && a.getTimeslot().equals(b.getTimeslot())\n+                        && a.getId() < b.getId()) {\n+                    // A room can accommodate at most one lesson at the same time.\n+                    if (a.getRoom() != null && a.getRoom().equals(b.getRoom())) {\n+                        hardScore--;\n+                    }\n+                    // A teacher can teach at most one lesson at the same time.\n+                    if (a.getTeacher().equals(b.getTeacher())) {\n+                        hardScore--;\n+                    }\n+                    // A student can attend at most one lesson at the same time.\n+                    if (a.getStudentGroup().equals(b.getStudentGroup())) {\n+                        hardScore--;\n+                    }\n+                }\n+            }\n+        }\n+        int softScore = 0;\n+        // Soft constraints are only implemented in optaplanner-quickstart\n+        return HardSoftScore.of(hardScore, softScore);\n+    }\n+\n+}\n+----\n+\n+Unfortunately **that does not scale well**, because it is non-incremental:\n+every time a lesson is assigned to a different time slot or room,\n+all lessons are re-evaluated to calculate the new score.\n+\n+Instead, create a `src/main/java/org/acme/solver/TimeTableConstraintProvider.java` class\n+to perform incremental score calculation.\n+It uses OptaPlanner's ConstraintStream API which is inspired by Java 8 Streams and SQL:\n+\n+[source,java]\n+----\n+package org.acme.solver;\n+\n+import org.acme.domain.Lesson;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+\n+public class TimeTableConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                roomConflict(constraintFactory),\n+                teacherConflict(constraintFactory),\n+                studentGroupConflict(constraintFactory),\n+                // Soft constraints are only implemented in optaplanner-quickstart\n+        };\n+    }\n+\n+    private Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        // A room can accommodate at most one lesson at the same time.\n+\n+        // Select a lesson ...\n+        return constraintFactory.from(Lesson.class)\n+                // ... and pair it with another lesson ...\n+                .join(Lesson.class,\n+                        // ... in the same timeslot ...\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        // ... in the same room ...\n+                        Joiners.equal(Lesson::getRoom),\n+                        // ... and the pair is unique (different id, no reverse pairs)\n+                        Joiners.lessThan(Lesson::getId))\n+                // then penalize each pair with a hard weight.\n+                .penalize(\"Room conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint teacherConflict(ConstraintFactory constraintFactory) {\n+        // A teacher can teach at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getTeacher))\n+                .penalize(\"Teacher conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    private Constraint studentGroupConflict(ConstraintFactory constraintFactory) {\n+        // A student can attend at most one lesson at the same time.\n+        return constraintFactory\n+                .fromUniquePair(Lesson.class,\n+                        Joiners.equal(Lesson::getTimeslot),\n+                        Joiners.equal(Lesson::getStudentGroup))\n+                .penalize(\"Student group conflict\", HardSoftScore.ONE_HARD);\n+    }\n+\n+}\n+----\n+\n+The `ConstraintProvider` scales an order of magnitude better than the `EasyScoreCalculator`: __O__(n) instead of __O__(n\u00b2).\n+\n+== Gather the domain objects in a planning solution\n+\n+A `TimeTable` wraps all `Timeslot`, `Room`, and `Lesson` instances of a single dataset.\n+Furthermore, because it contains all lessons, each with a specific planning variable state,\n+it is a _planning solution_ and it has a score:\n+\n+* If lessons are still unassigned, then it is an _uninitialized_ solution,\n+for example, a solution with the score `-4init/0hard/0soft`.\n+* If it breaks hard constraints, then it is an _infeasible_ solution,\n+for example, a solution with the score `-2hard/-3soft`.\n+* If it adheres to all hard constraints, then it is an _feasible_ solution,\n+for example, a solution with the score `0hard/-7soft`.\n+\n+Create the `src/main/java/org/acme/domain/TimeTable.java` class:\n+\n+[source,java]\n+----\n+package org.acme.domain;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+\n+@PlanningSolution\n+public class TimeTable {\n+\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"timeslotRange\")\n+    private List<Timeslot> timeslotList;\n+    @ProblemFactCollectionProperty\n+    @ValueRangeProvider(id = \"roomRange\")\n+    private List<Room> roomList;\n+    @PlanningEntityCollectionProperty\n+    private List<Lesson> lessonList;\n+\n+    @PlanningScore\n+    private HardSoftScore score;\n+\n+    public TimeTable() {\n+    }\n+\n+    public TimeTable(List<Timeslot> timeslotList, List<Room> roomList, List<Lesson> lessonList) {\n+        this.timeslotList = timeslotList;\n+        this.roomList = roomList;\n+        this.lessonList = lessonList;\n+    }\n+\n+    public List<Timeslot> getTimeslotList() {\n+        return timeslotList;\n+    }\n+\n+    public List<Room> getRoomList() {\n+        return roomList;\n+    }\n+\n+    public List<Lesson> getLessonList() {\n+        return lessonList;\n+    }\n+\n+    public HardSoftScore getScore() {\n+        return score;\n+    }\n+\n+}\n+----\n+\n+The `TimeTable` class has an `@PlanningSolution` annotation,\n+so OptaPlanner knows that this class contains all of the input and output data.\n+\n+Specifically, this class is the input of the problem:\n+\n+* A `timeslotList` field with all time slots\n+** This is a list of problem facts, because they do not change during solving.\n+* A `roomList` field with all rooms\n+** This is a list of problem facts, because they do not change during solving.\n+* A `lessonList` field with all lessons\n+** This is a list of planning entities, because they change during solving.\n+** Of each `Lesson`:\n+*** The values of the `timeslot` and `room` fields are typically still `null`, so unassigned.\n+They are planning variables.\n+***  The other fields, such as `subject`, `teacher` and `studentGroup`, are filled in.\n+These fields are problem properties.\n+\n+However, this class is also the output of the solution:\n+\n+* A `lessonList` field for which each `Lesson` instance has non-null `timeslot` and `room` fields after solving\n+* A `score` field that represents the quality of the output solution, for example, `0hard/-5soft`\n+\n+=== The value range providers\n+\n+That `timeslotList` field is a value range provider.\n+It holds the `Timeslot` instances which OptaPlanner can pick from to assign to the `timeslot` field of `Lesson` instances.\n+The `timeslotList` field has an `@ValueRangeProvider` annotation to connect those two,\n+by matching the `id` with the `valueRangeProviderRefs` of the `@PlanningVariable` in the `Lesson`.\n+\n+Following the same logic, the `roomList` field also  has an `@ValueRangeProvider` annotation.\n+\n+=== The problem fact and planning entity properties\n+\n+Furthermore, OptaPlanner needs to know which `Lesson` instances it can change\n+as well as how to retrieve the `Timeslot` and `Room` instances used for score calculation\n+by your `TimeTableConstraintProvider`.\n+\n+The `timeslotList` and `roomList` fields have an `@ProblemFactCollectionProperty` annotation,\n+so your `TimeTableConstraintProvider` can select _from_ those instances.\n+\n+The `lessonList` has an `@PlanningEntityCollectionProperty` annotation,\n+so OptaPlanner can change them during solving\n+and your `TimeTableConstraintProvider` can select _from_ those too.\n+\n+== Create the solver service\n+\n+Now you are ready to put everything together and create a REST service.\n+But solving planning problems on REST threads causes HTTP timeout issues.\n+Therefore, the Quarkus extension injects a `SolverManager`,\n+which runs solvers in a separate thread pool\n+and can solve multiple datasets in parallel.\n+\n+Create the `src/main/java/org/acme/solver/TimeTableResource.java` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.acme.domain.TimeTable;\n+import org.optaplanner.core.api.solver.SolverJob;\n+import org.optaplanner.core.api.solver.SolverManager;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    @Inject\n+    private SolverManager<TimeTable, UUID> solverManager;\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public TimeTable solve(TimeTable problem) {\n+        UUID problemId = UUID.randomUUID();\n+        // Submit the problem to start solving\n+        SolverJob<TimeTable, UUID> solverJob = solverManager.solve(problemId, problem);\n+        TimeTable solution;\n+        try {\n+            // Wait until the solving ends\n+            solution = solverJob.getFinalBestSolution();\n+        } catch (InterruptedException | ExecutionException e) {\n+            throw new IllegalStateException(\"Solving failed.\", e);\n+        }\n+        return solution;\n+    }\n+\n+}\n+----\n+\n+For simplicity's sake, this initial implementation waits for the solver to finish,\n+which can still cause an HTTP timeout.\n+The _complete_ implementation avoids HTTP timeouts much more elegantly.\n+\n+== Set the termination time\n+\n+Without a termination setting or a termination event, the solver runs forever.\n+To avoid that, limit the solving time to five seconds.\n+That is short enough to avoid the HTTP timeout.\n+\n+Create the `src/main/resources/application.properties` file:\n+\n+[source,properties]\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+----\n+\n+\n+== Make the application executable\n+\n+First start the application:\n+\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+=== Try the application\n+\n+Now that the application is running, you can test the REST service.\n+You can use any REST client you wish.\n+The following example uses the Linux command `curl` to send a POST request:\n+\n+----\n+$ curl -i -X POST http://localhost:8080/timeTable/solve -H \"Content-Type:application/json\" -d '{\"timeslotList\":[{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"}],\"roomList\":[{\"name\":\"Room A\"},{\"name\":\"Room B\"}],\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\"},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\"},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\"},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\"}]}'\n+----\n+\n+After about five seconds, according to the termination spent time defined in your `application.properties`,\n+the service returns output similar to the following example:\n+\n+----\n+HTTP/1.1 200\n+Content-Type: application/json\n+...\n+\n+{\"timeslotList\":...,\"roomList\":...,\"lessonList\":[{\"id\":1,\"subject\":\"Math\",\"teacher\":\"A. Turing\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":2,\"subject\":\"Chemistry\",\"teacher\":\"M. Curie\",\"studentGroup\":\"9th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room A\"}},{\"id\":3,\"subject\":\"French\",\"teacher\":\"M. Curie\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"08:30:00\",\"endTime\":\"09:30:00\"},\"room\":{\"name\":\"Room B\"}},{\"id\":4,\"subject\":\"History\",\"teacher\":\"I. Jones\",\"studentGroup\":\"10th grade\",\"timeslot\":{\"dayOfWeek\":\"MONDAY\",\"startTime\":\"09:30:00\",\"endTime\":\"10:30:00\"},\"room\":{\"name\":\"Room B\"}}],\"score\":\"0hard/0soft\"}\n+----\n+\n+Notice that your application assigned all four lessons to one of the two time slots and one of the two rooms.\n+Also notice that it conforms to all hard constraints.\n+For example, M. Curie's two lessons are in different time slots.\n+\n+On the server side, the `info` log show what OptaPlanner did in those five seconds:\n+\n+[options=\"nowrap\"]\n+----\n+... Solving started: time spent (33), best score (-8init/0hard/0soft), environment mode (REPRODUCIBLE), random (JDK with seed 0).\n+... Construction Heuristic phase (0) ended: time spent (73), best score (0hard/0soft), score calculation speed (459/sec), step total (4).\n+... Local Search phase (1) ended: time spent (5000), best score (0hard/0soft), score calculation speed (28949/sec), step total (28398).\n+... Solving ended: time spent (5000), best score (0hard/0soft), score calculation speed (28524/sec), phase total (2), environment mode (REPRODUCIBLE).\n+----\n+\n+=== Test the application\n+\n+A good application includes test coverage.\n+In a JUnit test, generate a test dataset and send it to the `TimeTableResource` to solve.\n+\n+Create the `src/test/java/org/acme/solver/TimeTableResourceTest.java` class:\n+\n+[source,java]\n+----\n+package org.acme;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.acme.domain.Room;\n+import org.acme.domain.Timeslot;\n+import org.acme.domain.Lesson;\n+import org.acme.domain.TimeTable;\n+import org.acme.rest.TimeTableResource;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@QuarkusTest\n+public class TimeTableResourceTest {\n+\n+    @Inject\n+    private TimeTableResource timeTableResource;\n+\n+    @Test\n+    @Timeout(600_000)\n+    public void solve() {\n+        TimeTable problem = generateProblem();\n+        TimeTable solution = timeTableResource.solve(problem);\n+        assertFalse(solution.getLessonList().isEmpty());\n+        for (Lesson lesson : solution.getLessonList()) {\n+            assertNotNull(lesson.getTimeslot());\n+            assertNotNull(lesson.getRoom());\n+        }\n+        assertTrue(solution.getScore().isFeasible());\n+    }\n+\n+    private TimeTable generateProblem() {\n+        List<Timeslot> timeslotList = new ArrayList<>();\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(8, 30), LocalTime.of(9, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(9, 30), LocalTime.of(10, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(10, 30), LocalTime.of(11, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(13, 30), LocalTime.of(14, 30)));\n+        timeslotList.add(new Timeslot(DayOfWeek.MONDAY, LocalTime.of(14, 30), LocalTime.of(15, 30)));\n+\n+        List<Room> roomList = new ArrayList<>();\n+        roomList.add(new Room(\"Room A\"));\n+        roomList.add(new Room(\"Room B\"));\n+        roomList.add(new Room(\"Room C\"));\n+\n+        List<Lesson> lessonList = new ArrayList<>();\n+        lessonList.add(new Lesson(101L, \"Math\", \"B. May\", \"9th grade\"));\n+        lessonList.add(new Lesson(102L, \"Physics\", \"M. Curie\", \"9th grade\"));\n+        lessonList.add(new Lesson(103L, \"Geography\", \"M. Polo\", \"9th grade\"));\n+        lessonList.add(new Lesson(104L, \"English\", \"I. Jones\", \"9th grade\"));\n+        lessonList.add(new Lesson(105L, \"Spanish\", \"P. Cruz\", \"9th grade\"));\n+\n+        lessonList.add(new Lesson(201L, \"Math\", \"B. May\", \"10th grade\"));\n+        lessonList.add(new Lesson(202L, \"Chemistry\", \"M. Curie\", \"10th grade\"));\n+        lessonList.add(new Lesson(203L, \"History\", \"I. Jones\", \"10th grade\"));\n+        lessonList.add(new Lesson(204L, \"English\", \"P. Cruz\", \"10th grade\"));\n+        lessonList.add(new Lesson(205L, \"French\", \"M. Curie\", \"10th grade\"));\n+        return new TimeTable(timeslotList, roomList, lessonList);\n+    }\n+\n+}\n+----\n+\n+This test verifies that after solving, all lessons are assigned to a time slot and a room.\n+It also verifies that it found a feasible solution (no hard constraints broken).\n+\n+Add a test properties to the `src/main/resources/application.properties` file:\n+\n+----\n+# The solver runs only for 5 seconds to avoid a HTTP timeout in this simple implementation.\n+# It's recommended to run for at least 5 minutes (\"5m\") otherwise.\n+quarkus.optaplanner.solver.termination.spent-limit=5s\n+\n+# Effectively disable this termination in favor of the best-score-limit\n+%test.quarkus.optaplanner.solver.termination.spent-limit=1h\n+%test.quarkus.optaplanner.solver.termination.best-score-limit=0hard/*soft\n+----\n+\n+Normally, the solver finds a feasible solution in less than 200 milliseconds.\n+Notice how the `application.properties` overwrites the solver termination during tests\n+to terminate as soon as a feasible solution (`0hard/*soft`) is found.\n+This avoids hard coding a solver time, because the unit test might run on arbitrary hardware.\n+This approach ensures that the test runs long enough to find a feasible solution, even on slow machines.\n+But it does not run a millisecond longer than it strictly must, even on fast machines.\n+\n+=== Logging\n+\n+When adding constraints in your `ConstraintProvider`,\n+keep an eye on the _score calculation speed_ in the `info` log,\n+after solving for the same amount of time, to assess the performance impact:\n+\n+----\n+... Solving ended: ..., score calculation speed (29455/sec), ...\n+----\n+\n+To understand how OptaPlanner is solving your problem internally,\n+change the logging in the `application.properties` file or with a `-D` system property:\n+\n+[source,properties]\n+----\n+quarkus.log.category.\"org.optaplanner\".level=debug\n+----\n+\n+Use `debug` logging to show every _step_:\n+\n+[options=\"nowrap\"]\n+----\n+... Solving started: time spent (67), best score (-20init/0hard/0soft), environment mode (REPRODUCIBLE), random (JDK with seed 0).\n+...     CH step (0), time spent (128), score (-18init/0hard/0soft), selected move count (15), picked move ([Math(101) {null -> Room A}, Math(101) {null -> MONDAY 08:30}]).\n+...     CH step (1), time spent (145), score (-16init/0hard/0soft), selected move count (15), picked move ([Physics(102) {null -> Room A}, Physics(102) {null -> MONDAY 09:30}]).\n+...\n+----\n+\n+Use `trace` logging to show every _step_ and every _move_ per step.\n+\n+== Summary\n+\n+Congratulations!\n+You have just developed a https://quarkus.io/[Quarkus] application with https://www.optaplanner.org/[OptaPlanner]!\n+\n+== Further improvements: Database and UI integration\n+\n+Now try adding database and UI integration:\n+\n+. Store `Timeslot`, `Room`, and `Lesson` in the database with https://quarkus.io/guides/hibernate-orm-panache[Hibernate and Panache].\n+\n+. https://quarkus.io/guides/rest-json[Expose them through REST].\n+\n+. Adjust the `TimeTableResource` to read and write a `TimeTable` in a single transaction\n+and use those accordingly:\n++\n+[source,java]\n+----\n+package org.acme.optaplanner.rest;\n+\n+import javax.inject.Inject;\n+import javax.transaction.Transactional;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import io.quarkus.panache.common.Sort;\n+import org.acme.optaplanner.domain.Lesson;\n+import org.acme.optaplanner.domain.Room;\n+import org.acme.optaplanner.domain.TimeTable;\n+import org.acme.optaplanner.domain.Timeslot;\n+import org.optaplanner.core.api.score.ScoreManager;\n+import org.optaplanner.core.api.solver.SolverManager;\n+import org.optaplanner.core.api.solver.SolverStatus;\n+\n+@Path(\"/timeTable\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class TimeTableResource {\n+\n+    public static final Long SINGLETON_TIME_TABLE_ID = 1L;\n+\n+    @Inject\n+    private SolverManager<TimeTable, Long> solverManager;\n+    @Inject\n+    private ScoreManager<TimeTable> scoreManager;\n+\n+    // To try, open http://localhost:8080/timeTable\n+    @GET\n+    public TimeTable getTimeTable() {\n+        // Get the solver status before loading the solution\n+        // to avoid the race condition that the solver terminates between them\n+        SolverStatus solverStatus = getSolverStatus();\n+        TimeTable solution = findById(SINGLETON_TIME_TABLE_ID);\n+        scoreManager.updateScore(solution); // Sets the score\n+        solution.setSolverStatus(solverStatus);\n+        return solution;\n+    }\n+\n+    @POST\n+    @Path(\"/solve\")\n+    public void solve() {\n+        solverManager.solveAndListen(SINGLETON_TIME_TABLE_ID,\n+                this::findById,\n+                this::save);\n+    }\n+\n+    public SolverStatus getSolverStatus() {\n+        return solverManager.getSolverStatus(SINGLETON_TIME_TABLE_ID);\n+    }\n+\n+    @POST\n+    @Path(\"/stopSolving\")\n+    public void stopSolving() {\n+        solverManager.terminateEarly(SINGLETON_TIME_TABLE_ID);\n+    }\n+\n+    @Transactional\n+    protected TimeTable findById(Long id) {\n+        if (!SINGLETON_TIME_TABLE_ID.equals(id)) {\n+            throw new IllegalStateException(\"There is no timeTable with id (\" + id + \").\");\n+        }\n+        // Occurs in a single transaction, so each initialized lesson references the same timeslot/room instance\n+        // that is contained by the timeTable's timeslotList/roomList.\n+        return new TimeTable(\n+                Timeslot.listAll(Sort.by(\"dayOfWeek\").and(\"startTime\").and(\"endTime\").and(\"id\")),\n+                Room.listAll(Sort.by(\"name\").and(\"id\")),\n+                Lesson.listAll(Sort.by(\"subject\").and(\"teacher\").and(\"studentGroup\").and(\"id\")));\n+    }\n+\n+    @Transactional\n+    protected void save(TimeTable timeTable) {\n+        for (Lesson lesson : timeTable.getLessonList()) {\n+            // TODO this is awfully naive: optimistic locking causes issues if called by the SolverManager\n+            Lesson attachedLesson = Lesson.findById(lesson.getId());\n+            attachedLesson.setTimeslot(lesson.getTimeslot());\n+            attachedLesson.setRoom(lesson.getRoom());\n+        }\n+    }\n+\n+}\n+----\n++\n+For simplicity's sake, this code handles only one `TimeTable`,\n+but it is straightforward to enable multi-tenancy and handle multiple `TimeTable` instances of different high schools in parallel.\n++\n+The `getTimeTable()` method returns the latest time table from the database.\n+It uses the `ScoreManager` (which is automatically injected)\n+to calculate the score of that time table, so the UI can show the score.\n++\n+The `solve()` method starts a job to solve the current time table and store the time slot and room assignments in the database.\n+It uses the `SolverManager.solveAndListen()` method to listen to intermediate best solutions\n+and update the database accordingly.\n+This enables the UI to show progress while the backend is still solving.\n+\n+. Adjust the `TimeTableResourceTest` accordingly, now that the `solve()` method returns immediately.\n+Poll for the latest solution until the solver finishes solving:\n++\n+[source,java]\n+----\n+package org.acme.optaplanner.rest;\n+\n+import javax.inject.Inject;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.acme.optaplanner.domain.Lesson;\n+import org.acme.optaplanner.domain.TimeTable;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import org.optaplanner.core.api.solver.SolverStatus;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@QuarkusTest\n+public class TimeTableResourceTest {\n+\n+    @Inject\n+    private TimeTableResource timeTableResource;\n+\n+    @Test\n+    @Timeout(600_000)\n+    public void solveDemoDataUntilFeasible() throws InterruptedException {\n+        timeTableResource.solve();\n+        TimeTable timeTable = timeTableResource.getTimeTable();\n+        while (timeTable.getSolverStatus() != SolverStatus.NOT_SOLVING) {\n+            // Quick polling (not a Test Thread Sleep anti-pattern)\n+            // Test is still fast on fast machines and doesn't randomly fail on slow machines.\n+            Thread.sleep(20L);\n+            timeTable = timeTableResource.getTimeTable();\n+        }\n+        assertFalse(timeTable.getLessonList().isEmpty());\n+        for (Lesson lesson : timeTable.getLessonList()) {\n+            assertNotNull(lesson.getTimeslot());\n+            assertNotNull(lesson.getRoom());\n+        }\n+        assertTrue(timeTable.getScore().isFeasible());\n+    }\n+\n+}\n+----\n+\n+. Build an attractive web UI on top of these REST methods to visualize the timetable.\n+\n+Take a look at the `optaplanner-quickstart` source code\n+in https://github.com/quarkusio/quarkus-quickstarts[the Quarkus quickstarts repository]\n+to see how this all turns out.", "originalCommit": "6f60eefbd80d451e73c0fc240937734ad687570a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM5ODk5MA==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r388398990", "bodyText": "Done, but I am adding an anchor link back to the Solution section in the beginning here, so readers do find the sources if need be.", "author": "ge0ffrey", "createdAt": "2020-03-05T16:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MjcxNg=="}], "type": "inlineReview"}, {"oid": "ea197ddf0e0f82c8ad02e63dd1b032569adf3853", "url": "https://github.com/quarkusio/quarkus/commit/ea197ddf0e0f82c8ad02e63dd1b032569adf3853", "message": "OptaPlanner guide", "committedDate": "2020-03-05T16:21:27Z", "type": "forcePushed"}, {"oid": "67566747f0e294ab64ba8ed832911aa39b32d95a", "url": "https://github.com/quarkusio/quarkus/commit/67566747f0e294ab64ba8ed832911aa39b32d95a", "message": "OptaPlanner guide", "committedDate": "2020-03-09T10:32:08Z", "type": "forcePushed"}, {"oid": "194b850e43e723b5283a5ce33c9316040c9dcded", "url": "https://github.com/quarkusio/quarkus/commit/194b850e43e723b5283a5ce33c9316040c9dcded", "message": "OptaPlanner guide", "committedDate": "2020-03-09T14:50:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MzcwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r389983701", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can skip this guide and go straight to the completed example:\n          \n          \n            \n            \n          \n          \n            \n            Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n          \n          \n            \n            The solution is located in {quickstarts-tree-url}/optaplanner-quickstart[the `optaplanner-quickstart` directory].\n          \n          \n            \n            We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example.\n          \n          \n            \n            \n          \n          \n            \n            Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n          \n          \n            \n            \n          \n          \n            \n            The solution is located in {quickstarts-tree-url}/optaplanner-quickstart[the `optaplanner-quickstart` directory].", "author": "gsmet", "createdAt": "2020-03-09T21:55:21Z", "path": "docs/src/main/asciidoc/optaplanner.adoc", "diffHunk": "@@ -0,0 +1,1018 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= OptaPlanner - Using AI to optimize a schedule with OptaPlanner\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+This guide walks you through the process of creating a Quarkus application\n+with https://www.optaplanner.org/[OptaPlanner]'s constraint solving Artificial Intelligence (AI).\n+\n+== What you will build\n+\n+You will build a REST application that optimizes a school timetable for students and teachers:\n+\n+image::optaplanner-time-table-app-screenshot.png[]\n+\n+Your service will assign `Lesson` instances to `Timeslot` and `Room` instances automatically\n+by using AI to adhere to hard and soft scheduling _constraints_, such as:\n+\n+* A room can have at most one lesson at the same time.\n+* A teacher can teach at most one lesson at the same time.\n+* A student can attend at most one lesson at the same time.\n+* A teacher prefers to teach in a single room.\n+* A teacher prefers to teach sequential lessons and dislikes gaps between lessons.\n+\n+Mathematically speaking, school timetabling is an _NP-hard_ problem.\n+That means it is difficult to scale.\n+Simply brute force iterating through all possible combinations takes millions of years\n+for a non-trivial dataset, even on a supercomputer.\n+Luckily, AI constraint solvers such as OptaPlanner have advanced algorithms\n+that deliver a near-optimal solution in a reasonable amount of time.\n+\n+[[solution]]\n+== Solution\n+\n+You can skip this guide and go straight to the completed example:\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+The solution is located in {quickstarts-tree-url}/optaplanner-quickstart[the `optaplanner-quickstart` directory].", "originalCommit": "194b850e43e723b5283a5ce33c9316040c9dcded", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0ODEwMw==", "url": "https://github.com/quarkusio/quarkus/pull/7579#discussion_r390148103", "bodyText": "Applying and squashing :)", "author": "ge0ffrey", "createdAt": "2020-03-10T08:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MzcwMQ=="}], "type": "inlineReview"}, {"oid": "615e194707d2e0a915ba10aa45ee4159583fc1dc", "url": "https://github.com/quarkusio/quarkus/commit/615e194707d2e0a915ba10aa45ee4159583fc1dc", "message": "OptaPlanner guide", "committedDate": "2020-03-10T08:13:24Z", "type": "forcePushed"}, {"oid": "0977756e335d168006d5bd427902950fb87e9cc0", "url": "https://github.com/quarkusio/quarkus/commit/0977756e335d168006d5bd427902950fb87e9cc0", "message": "OptaPlanner guide", "committedDate": "2020-03-11T08:33:52Z", "type": "commit"}, {"oid": "0977756e335d168006d5bd427902950fb87e9cc0", "url": "https://github.com/quarkusio/quarkus/commit/0977756e335d168006d5bd427902950fb87e9cc0", "message": "OptaPlanner guide", "committedDate": "2020-03-11T08:33:52Z", "type": "forcePushed"}]}