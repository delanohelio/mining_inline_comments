{"pr_number": 7568, "pr_title": "added possibility to add custom named handlers", "pr_createdAt": "2020-03-04T14:44:08Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7568", "timeline": [{"oid": "73fa56148da454a8c0c47bb025a63a20ec173707", "url": "https://github.com/quarkusio/quarkus/commit/73fa56148da454a8c0c47bb025a63a20ec173707", "message": "added possibility to add custom named handlers", "committedDate": "2020-03-04T14:50:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r387991116", "bodyText": "Why have a multi build item that in turn contains a map of multiple values, instead of having the build item contain only String name and RuntimeValue<Optional<Handler>> values?  (Apologies if this conversation already happened and I just don't remember).", "author": "dmlloyd", "createdAt": "2020-03-04T23:15:01Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/builditem/NamedLogHandlersBuildItem.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package io.quarkus.deployment.builditem;\n+\n+import java.util.Map;\n+import java.util.logging.Handler;\n+\n+import org.wildfly.common.Assert;\n+\n+import io.quarkus.builder.item.MultiBuildItem;\n+import io.quarkus.runtime.RuntimeValue;\n+\n+/**\n+ * A build item for adding additional named logging handlers.\n+ */\n+public final class NamedLogHandlersBuildItem extends MultiBuildItem {\n+    private final RuntimeValue<Map<String, Handler>> namedHandlersValue;", "originalCommit": "73fa56148da454a8c0c47bb025a63a20ec173707", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEwMzgxNw==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388103817", "bodyText": "First I tried using multiple build items with RuntimeValue<Map.Entry<String, Handler>>. But then I have to collect all of the entries to a single map which got me an exception like (I'm not sure but something like) \"cannot invoke method getValue() on ProxyObject NamedLogHandlersBuildItem, it is only allowed to pass it to a recorder.\"\nI have one last idea how to do this better. Let me check it out. Then I will comment again.", "author": "hartimcwildfly", "createdAt": "2020-03-05T06:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE4ODY4MA==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388188680", "bodyText": "So I tried it with RuntimeValue<Map.Entry<String, Handler>> but I could not find another solution.\nProblems are:\nDoing it like case 1 always results in a NPE when accessing rlogConfig.handlerConfigMap.entrySet()\ncase 1:\nclass RlogProcessor {\n\n    private static final String FEATURE = \"rlog\";\n\n    @BuildStep\n    FeatureBuildItem feature() {\n        return new FeatureBuildItem(FEATURE);\n    }\n\n    @BuildStep\n    @Record(ExecutionTime.RUNTIME_INIT)\n    List<NamedLogHandlersBuildItem> addRLogHandlers(final RlogConfig rlogConfig,\n            RlogHandlerValueFactory rlogHandlerValueFactory) {\n        return rlogConfig.handlerConfigMap.entrySet().stream()\n                .map(entry -> rlogHandlerValueFactory.createNamedHandler(entry.getKey(), entry.getValue()))\n                .map(NamedLogHandlersBuildItem::new).collect(Collectors.toList());\n    }\n}\n\n@Recorder\npublic class RlogHandlerValueFactory {\n\n    private static final Logger LOG = Logger.getLogger(RlogHandlerValueFactory.class);\n\n    private Handler createHandler(HandlerConfig handlerConfig) {\n        RlogHandler handler = new RlogHandler();\n        handler.setLevel(handlerConfig.level);\n        handler.setFilename(handlerConfig.filename);\n        handler.setPort(handlerConfig.port);\n        handler.setStandalone(handlerConfig.standalone);\n        handler.setLocalDir(handlerConfig.localDir);\n        handler.setFormatter(new SimpleFormatter());\n\n        return handler;\n    }\n}\nWhen returning List<RuntimeValue<Map.Entry<String, Handler>> and then wrap each of it in separate BuildItem like in case2.\nI get the exception: \"java.lang.RuntimeException: You cannot invoke stream() directly on an object returned from the bytecode recorder, you can only pass it back into the recorder as a parameter\"\ncase 2:\nclass RlogProcessor {\n\n    private static final String FEATURE = \"rlog\";\n\n    @BuildStep\n    FeatureBuildItem feature() {\n        return new FeatureBuildItem(FEATURE);\n    }\n\n    @BuildStep\n    @Record(ExecutionTime.RUNTIME_INIT)\n    List<NamedLogHandlersBuildItem> addRLogHandlers(final RlogConfig rlogConfig,\n            RlogHandlerValueFactory rlogHandlerValueFactory) {\n        return rlogHandlerValueFactory.createNamedHandler(rlogConfig).stream().map(NamedLogHandlersBuildItem::new).collect(Collectors.toList());\n    }\n}\n\n@Recorder\npublic class RlogHandlerValueFactory {\n    private static final Logger LOG = Logger.getLogger(RlogHandlerValueFactory.class);\n\n    public List<RuntimeValue<Map.Entry<String, Handler>>> createNamedHandler(RlogConfig rlogConfig) {\n        return rlogConfig.handlerConfigMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> createHandler(entry.getValue()))).entrySet().stream()\n                .map(RuntimeValue::new).collect(Collectors.toList());\n    }\n\n    private Handler createHandler(HandlerConfig handlerConfig) {\n        RlogHandler handler = new RlogHandler();\n        handler.setLevel(handlerConfig.level);\n        handler.setFilename(handlerConfig.filename);\n        handler.setPort(handlerConfig.port);\n        handler.setStandalone(handlerConfig.standalone);\n        handler.setLocalDir(handlerConfig.localDir);\n        handler.setFormatter(new SimpleFormatter());\n\n        return handler;\n    }\n}\nSo IMHO the solution with RuntimeValue<Map<String, Handler>> is the only one which works.", "author": "hartimcwildfly", "createdAt": "2020-03-05T09:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyNTAxMA==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388325010", "bodyText": "Are you trying to set it up so that the list of run time handlers can be completely customized at run time?", "author": "dmlloyd", "createdAt": "2020-03-05T14:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyNzM4NA==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388327384", "bodyText": "Sorry, I don't understand what you mean.\nDo you mean adding a new handler while quarkus already runs?", "author": "hartimcwildfly", "createdAt": "2020-03-05T14:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyOTQ2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388329466", "bodyText": "Normally we set up the set of handlers that are going to be used during build and static initialization.  So for example the build items in this case would consist of a String name (which is fixed at build) and a RuntimeValue<Optional<Handler>> (which can be set at run time, or it can be left out if the handler is disabled at run time).  This means that you couldn't add a new handler without rebuilding the application, but it also optimizes the code for native images where the unused handler code can be eliminated.", "author": "dmlloyd", "createdAt": "2020-03-05T14:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMzNDQ1OA==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388334458", "bodyText": "Ahh I see. I did not consider this, but as I'm using RuntimeValue<Map<String, Handler>> the additional named handlers should be fully customizable at runtime. (which is what I want and which IMHO makes sense for additional named handlers). For the sake of completion I will test if my assumption is correct. -> So I will build the quarkus app without application.properties and then start it with a config which consists of some additional named handlers.", "author": "hartimcwildfly", "createdAt": "2020-03-05T14:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM0MTA5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388341099", "bodyText": "Yup works as expected.", "author": "hartimcwildfly", "createdAt": "2020-03-05T14:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkxMjc5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388912796", "bodyText": "What's the status? Can this be merged?", "author": "hartimcwildfly", "createdAt": "2020-03-06T13:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk0MjU5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388942597", "bodyText": "As I said we normally strive for build time binding to ensure that dead code can be eliminated at run time.  We'd have to verify that this actually is the case.  But my queue is non-empty and I won't have time to look into it until next week.", "author": "dmlloyd", "createdAt": "2020-03-06T14:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2NjEzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r388966135", "bodyText": "But I don't think that it makes sense to fix/set the config of the loggers at compile time. So I would leave the PR as is.", "author": "hartimcwildfly", "createdAt": "2020-03-06T15:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MzkwMw==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r389263903", "bodyText": "I would not propose fixing the configuration at compile time, but I would consider the possibility of fixing the possible set of handlers at compile time, with run time configuration enabling or disabling the handlers as needed, plus allowing some properties to be run time configured.  This is the general Quarkus approach to things like this.\nAs I said though I'll be looking at this next week, and then I can give more concrete feedback.", "author": "dmlloyd", "createdAt": "2020-03-07T15:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxMDI0OA==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r389310248", "bodyText": "Ok. Thank you for your answer. Sorry for bothering.", "author": "hartimcwildfly", "createdAt": "2020-03-07T20:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgxNzcyNg==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r404817726", "bodyText": "Here is my final opinion for this.  Do not use a Map.   Create a new static or top-level class called NamedHandler with fields String and Handler.  The RuntimeValue should have type RuntimeValue<Optional<NamedHandler>>.  Each build item publishes one single named handler.", "author": "dmlloyd", "createdAt": "2020-04-07T13:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgxOTQwNA==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r404819404", "bodyText": "Ok I will try. Thank you for your answer!", "author": "hartimcwildfly", "createdAt": "2020-04-07T13:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1NzkyMg==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r405057922", "bodyText": "Ok. I think I know why it didn't work. I didn't understand the concept with the BuildItems, BuildSteps, Recorders etc. good enough. I don't understand it completely yet, but things are getting better. So just give me some time.", "author": "hartimcwildfly", "createdAt": "2020-04-07T19:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE0ODY3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406148677", "bodyText": "I spent a few hours. But I couldn't find a solution to generate multiple MultiBuildItems in a BuildStep with a runtime configuration containing a Map. I took a look at other MultiBuildItems. They either generate one MultiBuildItem per BuildStep or they produce multiple ones in a single BuiltStep but with static values not coming from the runtime configuration. The only one which covers the case \"one buildstep, runtime config, multiple MultiBuildItems\" was the AgroalProcessor. But I couldn't copy the pattern to my Processor because the AgroalProcessor is quite complex and I don't know how to adapt.\nI would be very happy if you could provide an example how to generate multiple MultiBuildItems from a runtime config containing some kind of collection.", "author": "hartimcwildfly", "createdAt": "2020-04-09T11:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyNjkwMg==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406226902", "bodyText": "In your build step, instead of returning a build item, accept a parameter of type BuildProducer<YourBuildItem>.  Then you can call produce on it as many times as you need to.", "author": "dmlloyd", "createdAt": "2020-04-09T14:02:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI2MjcxNw==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406262717", "bodyText": "I will provide a minimal example which is compatible to this PR. Maybe you find my mistake.", "author": "hartimcwildfly", "createdAt": "2020-04-09T14:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3MDYwNw==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406270607", "bodyText": "https://github.com/hartimcwildfly/quarkus-logging-extension If I run a quarkus app with the config in the README file, there should be a console handler with the name \"0\". But when I debug into io.quarkus.runtime.logging.LoggingSetupRecorder#initializeLogging I can see that no NamedLogHandlerBuildItem was created. When stopping at  io.quarkus.logging.rlog.RlogConfig$$accessor#get_handlerConfigMap I determine that the handler config is present. The getter is called various times. The configMap is only empty at the first call.", "author": "hartimcwildfly", "createdAt": "2020-04-09T15:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyNTU0MA==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406325540", "bodyText": "You can't actually construct the handler in the build step.  When we run build steps, the code isn't actually executed the way that you would think; it's actually recorded instead.  So the work of this method should be done in a separate class with the @Recorder annotation.", "author": "dmlloyd", "createdAt": "2020-04-09T16:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNDA5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406334096", "bodyText": "I feared that it has to to with this construct with the bytecode recording.", "author": "hartimcwildfly", "createdAt": "2020-04-09T16:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNzcyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406337725", "bodyText": "On which method of which example are you refering? It's quite confusing. Can you make an example of a general structure?", "author": "hartimcwildfly", "createdAt": "2020-04-09T16:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM0MDg1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406340852", "bodyText": "Ahh I think I understand it now. At runtime the acutal buildstep is not run only the code which was recorded at build time. But in my case the recorder code was not recorded at build time because the map was empty so we never jumped from the build step into the recorder code?", "author": "hartimcwildfly", "createdAt": "2020-04-09T16:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM0ODAzMw==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406348033", "bodyText": "Got it: So I need a recorder which consumes the RlogConfig and another recorder which consumes an Map.Entry<String, HandlerConfig>. And the BuildStep just runs the recorder with the RlogConfig.", "author": "hartimcwildfly", "createdAt": "2020-04-09T17:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM1NzA0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406357049", "bodyText": "Sorry I realize there's an error in my previous post.\nA \"recorder\" is a plain class annotated with @Recorder, which is run at run time.  This is a normal class in every respect; Quarkus creates the instance for you and then calls the methods at the appropriate time.\nA \"recording step\" is a build step that has the @Record annotation.  It should do as little as possible other than calling methods on your recorder class.", "author": "dmlloyd", "createdAt": "2020-04-09T17:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM1NzE2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406357161", "bodyText": "I'm told that this is not confusing. :-)", "author": "dmlloyd", "createdAt": "2020-04-09T17:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDk5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406370992", "bodyText": "Thank you for your patience. Now I feel so dumb :D I'm going to squash the commits and then you can review it (did you see my last commit?) and hopefully merge.", "author": "hartimcwildfly", "createdAt": "2020-04-09T17:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM5NjY5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406396692", "bodyText": "Hmm I now understand how everythings works with the code recording. But the problem stays the same. The recorded code is called at quarkus startup and the returned value will be wrapped in a BuildItem (whose wrapper was created at build time). This means that we know at build time how many/which builditems exist. This is also the reason why whe use Optional in the LogHandlerBuildItem. The BuildItems for the handlers are present in any case. If we do not enable the handler the BuildItem is still there but with an Optional.empty.\ntl;dr: Using NamedLogHandlerBuildItem for each named log handler does not work!\nWe have to pack multiple named handlers into one BuildItem.\nThe named console, file and syslog handlers are not wrapped in a builditem they are instanciated in the recorder method. This is why the amount of them is not fixed at build time.\nIs this correct?", "author": "hartimcwildfly", "createdAt": "2020-04-09T18:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTc0NA==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406405744", "bodyText": "Well we come back to the problem that we need to know what the possible handlers are at build time so we can ensure that they're in the final image.  It'd be OK to have an enable switch on them, but they have to be known at build time.\nThe reason that console/file/syslog get away with it is that they are always included.  But making it dynamic at run time leaves it completely open-ended.", "author": "dmlloyd", "createdAt": "2020-04-09T18:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxMjU0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r406412543", "bodyText": "And what's wrong with the fully dynamic approach using NamedLogHandlersBuildItem containing the Map<String, Handler> ? I would prefer the dynamic one, but if you decide for the static one, I will edit the PR and do it static. Then we can finally complete this PR and I don't have to bother you any more :D", "author": "hartimcwildfly", "createdAt": "2020-04-09T18:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxMjA0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7568#discussion_r407512041", "bodyText": "My concern is simply that the native image size might be needlessly inflated.  But, I guess I'm worrying before there is a known problem.  So I guess a map is OK.", "author": "dmlloyd", "createdAt": "2020-04-13T14:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTExNg=="}], "type": "inlineReview"}, {"oid": "70772262e52027dbc397614d1a951b150210e5c9", "url": "https://github.com/quarkusio/quarkus/commit/70772262e52027dbc397614d1a951b150210e5c9", "message": "wrapping a single named handler in NamedLogHandlerBuildItem instead of a map", "committedDate": "2020-04-09T13:16:12Z", "type": "forcePushed"}, {"oid": "14aa08215f35e04a8832326558e8ab0a27c8ce83", "url": "https://github.com/quarkusio/quarkus/commit/14aa08215f35e04a8832326558e8ab0a27c8ce83", "message": "added support for custom named log handlers", "committedDate": "2020-04-09T17:45:44Z", "type": "forcePushed"}, {"oid": "92579682674c8e878398945507b25253e2143aff", "url": "https://github.com/quarkusio/quarkus/commit/92579682674c8e878398945507b25253e2143aff", "message": "added support for custom named log handlers", "committedDate": "2020-04-09T17:48:17Z", "type": "forcePushed"}, {"oid": "f1eeb6b2c772c193e0558a9acf6868ac31d80093", "url": "https://github.com/quarkusio/quarkus/commit/f1eeb6b2c772c193e0558a9acf6868ac31d80093", "message": "added support for custom named log handlers", "committedDate": "2020-04-13T15:37:45Z", "type": "commit"}, {"oid": "f1eeb6b2c772c193e0558a9acf6868ac31d80093", "url": "https://github.com/quarkusio/quarkus/commit/f1eeb6b2c772c193e0558a9acf6868ac31d80093", "message": "added support for custom named log handlers", "committedDate": "2020-04-13T15:37:45Z", "type": "forcePushed"}]}