{"pr_number": 6398, "pr_title": "Improvements to STM text", "pr_createdAt": "2020-01-04T11:58:22Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/6398", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzQyNw==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083427", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, the tend to be the\n          \n          \n            \n            Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, it tends to be the\n          \n      \n    \n    \n  \n\nbut it might just be me not being native.", "author": "gsmet", "createdAt": "2020-01-05T10:26:32Z", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -8,22 +8,79 @@ https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n include::./attributes.adoc[]\n :extension-status: preview\n \n-Quarkus supports the Software Transactional Memory (STM) implementation provided by the\n-Narayana open source project. Narayana STM allows a program to group object accesses into\n-a transaction such that other transactions either see all of the changes at once or they\n-see none of them.\n-\n-STM offers an approach to developing transactional applications in a highly concurrent\n-environment with some of the same characteristics of ACID (Atomicity, Consistency,\n-Isolation and Durability) transactions.\n-\n-To use Narayana STM you must define which objects you would like to be transactional using java\n-annotations. Please refer to the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM manual]\n-and the https://narayana.io//docs/project/index.html#d0e16133[STM annotations guide] for more details.\n+Software Transactional Memory (STM) has been around in research environments since the late\n+1990's and has relatively recently started to appear in products and various programming\n+languages. We won't go into all of the details behind STM but the interested reader could look at https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].\n+However, suffice it to say that STM offers an approach to developing transactional applications in a highly\n+concurrent environment with some of the same characteristics of ACID transactions, which you've probably already used\n+through JTA. Importantly though, the Durability property is relaxed (removed) within STM implementations,\n+or at least made optional. This is not the situation with JTA, where state changes are made durable\n+to a relational database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[the X/Open XA\n+standard].\n+\n+Note, the STM implementation provided by Quarkus is based on the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. This document isn't meant to be a replacement for that project's documentation so you may want\n+to look at that for more detail. However, we will try to focus more on how you can combine some of the key capabilities\n+into Quarkus when developing Kubernetes native applications and microservices.\n+\n+== Why use STM with Quarkus?\n+\n+Now you may still be asking yourself \"Why STM instead of JTA?\" or \"What are the benefits\n+to STM that I don't get from JTA?\" Let's try to answer those or similar questions, with\n+a particular focus on why we think they're great for Quarkus, microservices and Kubernetes\n+native applications. So in no specific order ...\n+\n+* The goal of STM is to simplify object reads and writes from multiple threads/protect\n+state from concurrent updates. The Quarkus STM implementation will safely manage any conflicts between\n+these threads using whatever isolation model has been chosen to protect that specific state\n+instance (object in the case of Quarkus). In Quarkus STM, there are two isolation implementations,\n+pessimistic (the default), which would cause conflicting threads to be blocked until the original\n+has completed its updates (committed or aborted the transaction); then there's the optimistic\n+approach which allows all of the threads to proceed and checks for conflicts at commit time, where\n+one or more of the threads may be forced to abort if there have been conflicting updates.\n+\n+* STM objects have state but it doesn't need to be persistent (durable). In fact the\n+default behaviour is for objects managed within transactional memory to be volatile, such that\n+if the service or microservice within which they are being used crashes or is spawned elsewhere, e.g.,\n+by a scheduler, all state in memory is lost and the objects start from scratch. But surely you get this and more\n+with JTA (and a suitable transactional datastore) and don't need to worry about restarting your application?\n+Not quite. There's a trade-off here: we're doing away\n+with persistent state and the overhead of reading from and then writing (and sync-ing) to the datastore during each\n+transaction. This makes updates to (volatile) state very fast but you still get the benefits of atomic updates\n+across multiple STM objects (e.g., objects your team wrote then calling objects you inherited from another team and requiring\n+them to make all-or-nothing updates), as well as consistency\n+and isolation in the presence of concurrent threads/users (common in distributed microservices architectures).\n+Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, the tend to be the", "originalCommit": "fd143c11efadcad61ced77c911fead8c12f34fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwNTU3OA==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363105578", "bodyText": "Good catch.", "author": "nmcl", "createdAt": "2020-01-05T17:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzQ4NA==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083484", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            categorising STM-aware and STM-unware classes through an interface bounday; specifically all STM-aware objects\n          \n          \n            \n            categorising STM-aware and STM-unaware classes through an interface boundary; specifically all STM-aware objects", "author": "gsmet", "createdAt": "2020-01-05T10:27:44Z", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -43,12 +100,17 @@ To use the extension include it as a dependency in your application pom:\n </dependencies>\n --\n \n-Now you may use the STM library just like you would normally use it. But briefly, the process is:\n+== Defining STM-aware classes\n \n-== Defining Transactional Objects\n+In order for the STM subsytem to have knowledge about which classes are to be managed within the context\n+of transactional memory it is necessary to provide a minimal level of instrumentation. This occurs by\n+categorising STM-aware and STM-unware classes through an interface bounday; specifically all STM-aware objects", "originalCommit": "fd143c11efadcad61ced77c911fead8c12f34fdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzUxMA==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083510", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to\n          \n          \n            \n            if a transaction aborts. As mentioned earlier, if those annotations are not present then defaults are chosen to", "author": "gsmet", "createdAt": "2020-01-05T10:28:34Z", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -59,15 +121,48 @@ public interface FlightService {\n }\n --\n \n-Unless specified using other annotations, all public methods of implementations of this object will be assumed to modify the state of the object.\n-Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement\n-interfaces marked with the `@Transactional` annotation.\n+Classes which implement this interface are able to use additional annotations from Narayana to tell the STM\n+subsystem about things such as whether a method will modify the state of the object, or what state variables\n+within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back\n+if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to", "originalCommit": "fd143c11efadcad61ced77c911fead8c12f34fdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzU3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083575", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example, by using the ReadLock annotation on the `getNumberOfBookings` method, we are able to tell the\n          \n          \n            \n            For example, by using the `@ReadLock` annotation on the `getNumberOfBookings` method, we are able to tell the", "author": "gsmet", "createdAt": "2020-01-05T10:29:27Z", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -59,15 +121,48 @@ public interface FlightService {\n }\n --\n \n-Unless specified using other annotations, all public methods of implementations of this object will be assumed to modify the state of the object.\n-Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement\n-interfaces marked with the `@Transactional` annotation.\n+Classes which implement this interface are able to use additional annotations from Narayana to tell the STM\n+subsystem about things such as whether a method will modify the state of the object, or what state variables\n+within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back\n+if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to\n+guarantee safety, such as assuming all methods will modify state.\n+\n+[source,java]\n+--\n+public class FlightServiceImpl implements FlightService {\n+    @ReadLock\n+    public int getNumberOfBookings() { ... }\n+    public void makeBooking(String details) {...}\n+    \n+    @NotState\n+    private int timesCalled;\n+}\n+--\n+\n+For example, by using the ReadLock annotation on the `getNumberOfBookings` method, we are able to tell the", "originalCommit": "fd143c11efadcad61ced77c911fead8c12f34fdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzU4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083585", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            memory. Also, the NotState annotation tells the system to ignore `timesCalled` when transactions commit or\n          \n          \n            \n            memory. Also, the `@NotState` annotation tells the system to ignore `timesCalled` when transactions commit or", "author": "gsmet", "createdAt": "2020-01-05T10:29:38Z", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -59,15 +121,48 @@ public interface FlightService {\n }\n --\n \n-Unless specified using other annotations, all public methods of implementations of this object will be assumed to modify the state of the object.\n-Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement\n-interfaces marked with the `@Transactional` annotation.\n+Classes which implement this interface are able to use additional annotations from Narayana to tell the STM\n+subsystem about things such as whether a method will modify the state of the object, or what state variables\n+within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back\n+if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to\n+guarantee safety, such as assuming all methods will modify state.\n+\n+[source,java]\n+--\n+public class FlightServiceImpl implements FlightService {\n+    @ReadLock\n+    public int getNumberOfBookings() { ... }\n+    public void makeBooking(String details) {...}\n+    \n+    @NotState\n+    private int timesCalled;\n+}\n+--\n+\n+For example, by using the ReadLock annotation on the `getNumberOfBookings` method, we are able to tell the\n+STM subsystem that no state modifications will occur in this object when it is used in the transactional\n+memory. Also, the NotState annotation tells the system to ignore `timesCalled` when transactions commit or", "originalCommit": "fd143c11efadcad61ced77c911fead8c12f34fdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzY5OA==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083698", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            be confusing to use especially in a Kuberenetes native environment such as Quarkus, but hopefully\n          \n          \n            \n            be confusing to use especially in a Kubernetes native environment such as Quarkus, but hopefully", "author": "gsmet", "createdAt": "2020-01-05T10:31:53Z", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -59,15 +121,48 @@ public interface FlightService {\n }\n --\n \n-Unless specified using other annotations, all public methods of implementations of this object will be assumed to modify the state of the object.\n-Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement\n-interfaces marked with the `@Transactional` annotation.\n+Classes which implement this interface are able to use additional annotations from Narayana to tell the STM\n+subsystem about things such as whether a method will modify the state of the object, or what state variables\n+within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back\n+if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to\n+guarantee safety, such as assuming all methods will modify state.\n+\n+[source,java]\n+--\n+public class FlightServiceImpl implements FlightService {\n+    @ReadLock\n+    public int getNumberOfBookings() { ... }\n+    public void makeBooking(String details) {...}\n+    \n+    @NotState\n+    private int timesCalled;\n+}\n+--\n+\n+For example, by using the ReadLock annotation on the `getNumberOfBookings` method, we are able to tell the\n+STM subsystem that no state modifications will occur in this object when it is used in the transactional\n+memory. Also, the NotState annotation tells the system to ignore `timesCalled` when transactions commit or\n+abort, so this value only changes due to application code.\n+\n+Please refer to the Narayana guide for details of how to exert finer grained control over the transactional\n+behaviour of objects that implement interfaces marked with the `@Transactional` annotation.\n \n == Creating STM objects\n \n-The STM library needs to be told which objects it should be managing by providing a container for the transactional memory.\n-The default container (`org.jboss.stm.Container`) provides support for volatile objects that cannot be shared between JVMs\n-(although other constructors do allow for other models):\n+The STM subsystem needs to be told about which objects it should be managing. The Quarkus (aka Narayana) STM implementation\n+does this by providing containers of transactional memory within which these object instances reside. Until an object\n+is placed within one of these STM containers it cannot be managed within transactions and any state changes will\n+not possess the A, C, I (or even D) properties.\n+\n+Note, the term \"container\" was defined within the STM implementation years before Linux containers came along. It may\n+be confusing to use especially in a Kuberenetes native environment such as Quarkus, but hopefully", "originalCommit": "fd143c11efadcad61ced77c911fead8c12f34fdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzcxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083719", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> Then you create an instance that implements FlightService. You should not use it directly at this stage because\n          \n          \n            \n            <2> Then you create an instance that implements `FlightService`. You should not use it directly at this stage because", "author": "gsmet", "createdAt": "2020-01-05T10:32:32Z", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -82,25 +177,30 @@ The default container (`org.jboss.stm.Container`) provides support for volatile\n \n <1> You need to tell each Container about the type of objects for which it will be responsible. In this example\n     it will be instances that implement the FlightService interface.\n-<2> Then you create an instance that implements FlightService. You cannot use it directly at this stage because\n-    its operations aren't being monitored by the Container.\n-<3> To obtain a managed instance, pass the instance to the `container` to obtain a reference through which you\n-    will be able perform transactional operations. This reference can be used safely from multiple threads\n-    (provided that each thread uses it in a transaction context - see the next section.\n+<2> Then you create an instance that implements FlightService. You should not use it directly at this stage because", "originalCommit": "fd143c11efadcad61ced77c911fead8c12f34fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwNTY4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363105682", "bodyText": "Must've been there originally because I haven't edited that text yet ...", "author": "nmcl", "createdAt": "2020-01-05T17:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4Mzc2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083761", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            a transaction already associated with the caling thread then each of these annotations behaves slightly differently:\n          \n          \n            \n            a transaction already associated with the calling thread then each of these annotations behaves slightly differently:", "author": "gsmet", "createdAt": "2020-01-05T10:33:17Z", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -82,25 +177,30 @@ The default container (`org.jboss.stm.Container`) provides support for volatile\n \n <1> You need to tell each Container about the type of objects for which it will be responsible. In this example\n     it will be instances that implement the FlightService interface.\n-<2> Then you create an instance that implements FlightService. You cannot use it directly at this stage because\n-    its operations aren't being monitored by the Container.\n-<3> To obtain a managed instance, pass the instance to the `container` to obtain a reference through which you\n-    will be able perform transactional operations. This reference can be used safely from multiple threads\n-    (provided that each thread uses it in a transaction context - see the next section.\n+<2> Then you create an instance that implements FlightService. You should not use it directly at this stage because\n+    access to it is not being managed by the STM subsystem.\n+<3> To obtain a managed instance, pass the original object to the STM `container` which then returns a reference\n+    through which you will be able perform transactional operations. This reference can be used safely from multiple threads.\n \n == Defining transaction boundaries\n \n-STM objects must be accessed within a transaction (otherwise they will behave just like any other java object).\n-You can define the transaction boundary in two ways:\n+Once an object is placed within an STM container the application developer can manage the scope of transactions\n+within which it is used. There are some annotations which can be applied to the STM-aware class to have the\n+container automatically create a transaction whenever a specific method is invoked.\n \n === Declarative approach\n \n-The easiest, but less flexible, way to define your transaction boundaries is to place an `@NestedTopLevel` or `@Nested` annotation on the interface.\n-Then when a method of your transactional object is invoked a new transaction will be created for the duration of the method call.\n+If the `@NestedTopLevel` or `@Nested` annotation is placed on a method signature then the STM container will\n+start a new transaction when that method is invoked and attempt to commit it when the method returns. If there is\n+a transaction already associated with the caling thread then each of these annotations behaves slightly differently:", "originalCommit": "fd143c11efadcad61ced77c911fead8c12f34fdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e2f0019dc8efcf00e4bfd71f1032168178b21277", "url": "https://github.com/quarkusio/quarkus/commit/e2f0019dc8efcf00e4bfd71f1032168178b21277", "message": "Improved STM text\n\nWill make further changes once I've modified the quickstart code itself.\n\nhttps://github.com/quarkusio/quarkusio.github.io/issues/411\n\nhttps://github.com/quarkusio/quarkusio.github.io/pull/417", "committedDate": "2020-01-06T08:08:19Z", "type": "commit"}, {"oid": "e2f0019dc8efcf00e4bfd71f1032168178b21277", "url": "https://github.com/quarkusio/quarkus/commit/e2f0019dc8efcf00e4bfd71f1032168178b21277", "message": "Improved STM text\n\nWill make further changes once I've modified the quickstart code itself.\n\nhttps://github.com/quarkusio/quarkusio.github.io/issues/411\n\nhttps://github.com/quarkusio/quarkusio.github.io/pull/417", "committedDate": "2020-01-06T08:08:19Z", "type": "forcePushed"}]}