{"pr_number": 7417, "pr_title": "Kafka Streams SASL and SSL config", "pr_createdAt": "2020-02-25T14:57:47Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7417", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384426606", "bodyText": "Why is this a string, shouldn't it be rather a double (some for some more props below)?", "author": "gunnarmorling", "createdAt": "2020-02-26T11:12:04Z", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;", "originalCommit": "fa1326ce07f8a0a706a0ede54f698ef5538d1829", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4OTA3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384489073", "bodyText": "Yeah, I didn't bother, since KS's config takes care of the conversions anyway.\nIf you think we should, then this can easily be changed.", "author": "alesj", "createdAt": "2020-02-26T13:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ5MTI1NA==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384491254", "bodyText": "Let's ask @gsmet. My understanding is that Quarkus wants to expose properly typed options, so to offer e.g. editor support (validation) down the road.", "author": "gunnarmorling", "createdAt": "2020-02-26T13:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5OTc0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384999745", "bodyText": "Yes, the Quarkus config should be properly typed.", "author": "gsmet", "createdAt": "2020-02-27T09:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwMDgyMg==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r385000822", "bodyText": "Yes, it should be typed.", "author": "gsmet", "createdAt": "2020-02-27T09:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzQzMw==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384427433", "bodyText": "Should be an int. But also worth double checking with Quarkus guidelines: should it be rather Duration, and be given as such (which would impact the option name, though, which might not be desirable as it's coming from Kafka upstream IIUC).", "author": "gunnarmorling", "createdAt": "2020-02-26T11:13:44Z", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;\n+\n+    /**\n+     * Percentage of random jitter added to the renewal time\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.jitter\")\n+    public Optional<String> kerberosTicketRenewJitter;\n+\n+    /**\n+     * Percentage of random jitter added to the renewal time\n+     */\n+    @ConfigItem(name = \"kerberos.min.time.before.relogin\")\n+    public Optional<String> kerberosMinTimeBeforeRelogin;\n+\n+    /**\n+     * Login refresh thread will sleep until the specified window factor relative to the\n+     * credential's lifetime has been reached.\n+     */\n+    @ConfigItem(name = \"login.refresh.window.factor\")\n+    public Optional<String> loginRefreshWindowFactor;\n+\n+    /**\n+     * The maximum amount of random jitter relative to the credential's lifetime\n+     */\n+    @ConfigItem(name = \"login.refresh.window.jitter\")\n+    public Optional<String> loginRefreshWindowJitter;\n+\n+    /**\n+     * The desired minimum time for the login refresh thread to wait before refreshing a credential\n+     */\n+    @ConfigItem(name = \"login.refresh.min.period.seconds\")\n+    public Optional<String> loginRefreshMinPeriodSeconds;\n+\n+    /**\n+     * The amount of buffer time before credential expiration to maintain when refreshing a credential\n+     */\n+    @ConfigItem(name = \"login.refresh.buffer.seconds\")\n+    public Optional<String> loginRefreshBufferSeconds;", "originalCommit": "fa1326ce07f8a0a706a0ede54f698ef5538d1829", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwMTE5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r385001195", "bodyText": "Yeah all these properties should be Duration and we should drop the Seconds part. They will be documented so it's OK.", "author": "gsmet", "createdAt": "2020-02-27T09:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzgzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384427839", "bodyText": "How about adding a package visible accessor?", "author": "gunnarmorling", "createdAt": "2020-02-26T11:14:39Z", "path": "integration-tests/kafka-streams/src/test/java/io/quarkus/it/kafka/streams/KafkaStreamsPropertiesTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package io.quarkus.it.kafka.streams;\n+\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import io.quarkus.test.common.QuarkusTestResource;\n+import io.quarkus.test.junit.QuarkusTest;\n+\n+@QuarkusTestResource(KafkaTestResource.class)\n+@QuarkusTest\n+public class KafkaStreamsPropertiesTest {\n+\n+    @Inject\n+    KafkaStreams streams;\n+\n+    @Test\n+    public void testProperties() throws Exception {\n+        // reflection hack ... no other way to get raw props ...\n+        Field configField = KafkaStreams.class.getDeclaredField(\"config\");\n+        configField.setAccessible(true);\n+        StreamsConfig config = (StreamsConfig) configField.get(streams);", "originalCommit": "fa1326ce07f8a0a706a0ede54f698ef5538d1829", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4OTYyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384489629", "bodyText": "What do you mean?", "author": "alesj", "createdAt": "2020-02-26T13:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ5MTgwNA==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384491804", "bodyText": "Ah, seems you get a field from the upstream KafkaStreams object. I thought about having a getter in our own object (topology manager), where we could expose a package-visible getter for testing purposes.", "author": "gunnarmorling", "createdAt": "2020-02-26T13:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwMDYwNA==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r385000604", "bodyText": "In Quarkus config, we use a dot to separate sections and a dash to separate words. It's a general comment about the config key of this PR.", "author": "gsmet", "createdAt": "2020-02-27T09:21:53Z", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsRuntimeConfig.java", "diffHunk": "@@ -37,10 +37,42 @@\n     @ConfigItem\n     public List<String> topics;\n \n+    /**\n+     * The schema registry key.\n+     * e.g. to diff between different registry impls / instances\n+     * as they have this registry url under different property key.\n+     */\n+    @ConfigItem(name = \"schema.registry.key\", defaultValue = \"schema.registry.url\")\n+    public String schemaRegistryKey;\n+\n+    /**\n+     * The schema registry url.\n+     */\n+    @ConfigItem(name = \"schema.registry.url\")", "originalCommit": "fa1326ce07f8a0a706a0ede54f698ef5538d1829", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "34c8025e390f78ef629008a004b3493998c9289a", "url": "https://github.com/quarkusio/quarkus/commit/34c8025e390f78ef629008a004b3493998c9289a", "message": "Add SSL test(s).", "committedDate": "2020-02-28T14:27:08Z", "type": "forcePushed"}, {"oid": "d4b1fbc4f2626423d57ba4cf6a571f427f334afd", "url": "https://github.com/quarkusio/quarkus/commit/d4b1fbc4f2626423d57ba4cf6a571f427f334afd", "message": "Make props typed, use dash.", "committedDate": "2020-03-03T13:21:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzNzkwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r395637909", "bodyText": "Perhaps clarify the value to be used for Apicurio?", "author": "gunnarmorling", "createdAt": "2020-03-20T13:33:12Z", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsRuntimeConfig.java", "diffHunk": "@@ -37,10 +37,42 @@\n     @ConfigItem\n     public List<String> topics;\n \n+    /**\n+     * The schema registry key.\n+     * e.g. to diff between different registry impls / instances", "originalCommit": "d4b1fbc4f2626423d57ba4cf6a571f427f334afd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NzQwOA==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r396477408", "bodyText": "OK, will do.", "author": "alesj", "createdAt": "2020-03-23T14:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzNzkwOQ=="}], "type": "inlineReview"}, {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69", "url": "https://github.com/quarkusio/quarkus/commit/16df4e9ac65e8caf28c7f92ddfed01161fbb2c69", "message": "Get rid of runtime lambdas in Kafka Streams", "committedDate": "2020-04-28T12:54:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r416621956", "bodyText": "I don't understand why we need that here?", "author": "gsmet", "createdAt": "2020-04-28T13:40:59Z", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "originalCommit": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4ODMxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417188315", "bodyText": "There is no other (or better / smarter) way to pass-in an empty string.\n(that's what I've been told by @dmlloyd )\nAnd in this case you need to have an empty string, to disable this config/setting.", "author": "alesj", "createdAt": "2020-04-29T09:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1MjU0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417252543", "bodyText": "OK. Can't say I'm excited about it but can't think of a better solution. Or maybe we could use -1 to disable? It's a bit of dark magic but could be documented.\nJust a proposal, WDYT?", "author": "gsmet", "createdAt": "2020-04-29T11:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1NDIyOA==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417254228", "bodyText": "It's a string ... so setting a number ... hmmm, dunno :-)", "author": "alesj", "createdAt": "2020-04-29T11:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMzY0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417423649", "bodyText": "There is no other (or better / smarter) way to pass-in an empty string.\n(that's what I've been told by @dmlloyd )\n\nNo it's not; I definitely never told you that.  If you want a string which can be empty, use Optional<String> with orElse(\"\").  If you want an integer which can be empty, use OptionalInt (int has no native empty representation though, so orElse won't help in this case).\n\nAnd in this case you need to have an empty string, to disable this config/setting.\n\nThen it should be Optional.", "author": "dmlloyd", "createdAt": "2020-04-29T15:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MjM5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417982395", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,\n          \n          \n            \n                        setProperty(ssl.endpointIdentificationAlgorithm.orElse(\"\"), streamsProperties,", "author": "dmlloyd", "createdAt": "2020-04-30T12:46:35Z", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "originalCommit": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5ODgzMA==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r419298830", "bodyText": "How are you gonna get Optional.empty() if default is \"https\" ... ?\nOr it looks like I don't understand how @configitem with defaultValue and Optional work together?", "author": "alesj", "createdAt": "2020-05-04T09:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MjM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2MzU3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r419363579", "bodyText": "An empty Optional means the value was empty - meaning, the user explicitly gave an empty value.  If the user does not give a value, then the default is used, so in this case you'd get an Optional.of(\"https\").", "author": "dmlloyd", "createdAt": "2020-05-04T11:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MjM5NQ=="}], "type": "inlineReview"}, {"oid": "dba2d4bbc758adda9e72a470766d21d4f5c87c96", "url": "https://github.com/quarkusio/quarkus/commit/dba2d4bbc758adda9e72a470766d21d4f5c87c96", "message": "Handle #4961 - Kafka Streams sasl, ssl config.", "committedDate": "2020-05-18T11:54:55Z", "type": "forcePushed"}, {"oid": "d3d550bbee83c2e315e942e3848aa4090f5b9a85", "url": "https://github.com/quarkusio/quarkus/commit/d3d550bbee83c2e315e942e3848aa4090f5b9a85", "message": "Handle #4961 - Kafka Streams sasl, ssl config.", "committedDate": "2020-05-18T14:52:51Z", "type": "forcePushed"}, {"oid": "2040dc05998c6616a562ba3ef19d2bf4bb838f58", "url": "https://github.com/quarkusio/quarkus/commit/2040dc05998c6616a562ba3ef19d2bf4bb838f58", "message": "Handle #4961 - Kafka Streams sasl, ssl config.", "committedDate": "2020-05-20T09:38:10Z", "type": "forcePushed"}, {"oid": "75914f6c99ff4b5fa25a95e991b92f8349fb11c2", "url": "https://github.com/quarkusio/quarkus/commit/75914f6c99ff4b5fa25a95e991b92f8349fb11c2", "message": "Handle #4961 - Kafka Streams sasl, ssl config.", "committedDate": "2020-06-22T10:32:21Z", "type": "commit"}, {"oid": "75914f6c99ff4b5fa25a95e991b92f8349fb11c2", "url": "https://github.com/quarkusio/quarkus/commit/75914f6c99ff4b5fa25a95e991b92f8349fb11c2", "message": "Handle #4961 - Kafka Streams sasl, ssl config.", "committedDate": "2020-06-22T10:32:21Z", "type": "forcePushed"}, {"oid": "daf56bf1ba6a633a8e803b7964167d881f6f0661", "url": "https://github.com/quarkusio/quarkus/commit/daf56bf1ba6a633a8e803b7964167d881f6f0661", "message": "Fix \"SSL Handshake failed\" issue\n\n- Add security.protocol as quarkus runtime options and allow replaying\n  the option as runtime init\n- Enable enableAllSecurityServices when building the native image for\n  the integration test", "committedDate": "2020-06-22T15:00:37Z", "type": "commit"}]}