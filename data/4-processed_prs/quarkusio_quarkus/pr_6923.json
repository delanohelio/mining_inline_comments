{"pr_number": 6923, "pr_title": "doc: active record and repository patterns", "pr_createdAt": "2020-01-31T18:13:51Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/6923", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEzMjg3OA==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r374132878", "bodyText": "style wise, try and keep your sentences light. By definition what you write is what you recommend.\nAlso \"in general\", \"usually\" etc bring no value.\nAlso be positive, negations are always triggering some negative loops in the brain\nKeep sentences short.\nAdd custom queries on your entities outside of the entities themselves.\nThat way, you and your co-workers can find the easily and queries are right next to the object they operate on.\nAdding them as static methods in your entity class is the Panache Active Record way.", "author": "emmanuelbernard", "createdAt": "2020-02-03T14:30:08Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,154 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+In general, we recommend not adding custom queries for your entities outside of the entities themselves,", "originalCommit": "836f9d7a41b06d466648209cf7b887c7f157c2b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEzMzIzOA==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r374133238", "bodyText": "s/Absolutely a/A/\nJust be factual, not theatrical.", "author": "emmanuelbernard", "createdAt": "2020-02-03T14:30:48Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,154 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+In general, we recommend not adding custom queries for your entities outside of the entities themselves,\n+to keep all model queries close to the models they operate on. So we recommend adding them as static methods\n+in your entity class:\n+\n+[source,java]\n+----\n+@Entity\n+public class Person extends PanacheEntity {\n+    public String name;\n+    public LocalDate birth;\n+    public Status status;\n+\n+    public static Person findByName(String name){\n+        return find(\"name\", name).firstResult();\n+    }\n+\n+    public static List<Person> findAlive(){\n+        return list(\"status\", Status.Alive);\n+    }\n+\n+    public static void deleteStefs(){\n+        delete(\"name\", \"Stef\");\n+    }\n+}\n+----\n+\n+== Solution 2: using the repository pattern\n+\n+=== Defining your repository\n+\n+When using Repositories, you can get the exact same convenient methods as with the active record pattern injected in your Repository,\n+by making them implements `PanacheRepository`:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PersonRepository implements PanacheRepository<Person> {\n+\n+   // put your custom logic here as instance methods\n+\n+   public Person findByName(String name){\n+       return find(\"name\", name).firstResult();\n+   }\n+\n+   public List<Person> findAlive(){\n+       return list(\"status\", Status.Alive);\n+   }\n+\n+   public void deleteStefs(){\n+       delete(\"name\", \"Stef\");\n+  }\n+}\n+----\n+\n+Absolutely all the operations that are defined on `PanacheEntityBase` are available on your repository, so using it", "originalCommit": "836f9d7a41b06d466648209cf7b887c7f157c2b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEzMzUzNA==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r374133534", "bodyText": "Split sentence in 2, it's too long and hard to read.", "author": "emmanuelbernard", "createdAt": "2020-02-03T14:31:23Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,154 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+In general, we recommend not adding custom queries for your entities outside of the entities themselves,\n+to keep all model queries close to the models they operate on. So we recommend adding them as static methods\n+in your entity class:\n+\n+[source,java]\n+----\n+@Entity\n+public class Person extends PanacheEntity {\n+    public String name;\n+    public LocalDate birth;\n+    public Status status;\n+\n+    public static Person findByName(String name){\n+        return find(\"name\", name).firstResult();\n+    }\n+\n+    public static List<Person> findAlive(){\n+        return list(\"status\", Status.Alive);\n+    }\n+\n+    public static void deleteStefs(){\n+        delete(\"name\", \"Stef\");\n+    }\n+}\n+----\n+\n+== Solution 2: using the repository pattern\n+\n+=== Defining your repository\n+\n+When using Repositories, you can get the exact same convenient methods as with the active record pattern injected in your Repository,\n+by making them implements `PanacheRepository`:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PersonRepository implements PanacheRepository<Person> {\n+\n+   // put your custom logic here as instance methods\n+\n+   public Person findByName(String name){\n+       return find(\"name\", name).firstResult();\n+   }\n+\n+   public List<Person> findAlive(){\n+       return list(\"status\", Status.Alive);\n+   }\n+\n+   public void deleteStefs(){\n+       delete(\"name\", \"Stef\");\n+  }\n+}\n+----\n+\n+Absolutely all the operations that are defined on `PanacheEntityBase` are available on your repository, so using it\n+is exactly the same except you need to inject it:\n+\n+[source,java]\n+----\n+@Inject\n+PersonRepository personRepository;\n+\n+@GET\n+public long count(){\n+    return personRepository.count();\n+}\n+----\n+\n+Even with repositories, you can keep your entities as subclasses of `PanacheEntity` in order to get the ID and public fields working,", "originalCommit": "836f9d7a41b06d466648209cf7b887c7f157c2b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a537db7f0ba181357a7b6a3de72eba36164169cb", "url": "https://github.com/quarkusio/quarkus/commit/a537db7f0ba181357a7b6a3de72eba36164169cb", "message": "doc: active record and repository patterns\n\nFixes #6135", "committedDate": "2020-02-03T15:47:09Z", "type": "forcePushed"}, {"oid": "75544541ae6e25adb05ff363ae4b7341c9c71f17", "url": "https://github.com/quarkusio/quarkus/commit/75544541ae6e25adb05ff363ae4b7341c9c71f17", "message": "doc: active record and repository patterns\n\nFixes #6135 and #6945", "committedDate": "2020-02-04T12:38:06Z", "type": "forcePushed"}, {"oid": "d311e32bbddcce019dd5bba1cb2731ee42021638", "url": "https://github.com/quarkusio/quarkus/commit/d311e32bbddcce019dd5bba1cb2731ee42021638", "message": "doc: active record and repository patterns\n\nFixes #6135 and #6945", "committedDate": "2020-02-10T10:39:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzIxMg==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384437212", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: what you just see is the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.\n          \n          \n            \n            NOTE: what was described above is essentially the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.", "author": "geoand", "createdAt": "2020-02-26T11:34:55Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -43,13 +43,26 @@ Does this look interesting? Read on!\n \n NOTE: the `list()` method might be surprising at first. It takes fragments of HQL (JP-QL) queries and contextualizes the rest. That makes for very concise but yet readable code.\n \n+NOTE: what you just see is the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0MjY1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384442659", "bodyText": "is a essentially the isn't the a superfluous ?", "author": "loicmathieu", "createdAt": "2020-02-26T11:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzIxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0MzU1MA==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384443550", "bodyText": "the a was indeed a mistake :)", "author": "geoand", "createdAt": "2020-02-26T11:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzU2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384437569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Hibernate with Panache also provides the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheRepository`.\n          \n          \n            \n            Hibernate with Panache also allows for the use of the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheRepository`.", "author": "geoand", "createdAt": "2020-02-26T11:35:42Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -43,13 +43,26 @@ Does this look interesting? Read on!\n \n NOTE: the `list()` method might be surprising at first. It takes fragments of HQL (JP-QL) queries and contextualizes the rest. That makes for very concise but yet readable code.\n \n+NOTE: what you just see is the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.\n+Hibernate with Panache also provides the more classical link:https://martinfowler.com/eaaCatalog/repository.html[repository pattern] via `PanacheRepository`.", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0NDI4NA==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384444284", "bodyText": "This suggestion look like a verb is missing ... Di you means allow for the use ?", "author": "loicmathieu", "createdAt": "2020-02-26T11:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0NTk5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384445993", "bodyText": "Yup :)", "author": "geoand", "createdAt": "2020-02-26T11:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzODcwNg==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384438706", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            That way, you and your co-workers can find them easily, and queries are right next to the object they operate on.\n          \n          \n            \n            That way, you and your co-workers can find them easily, and queries are co-located with the object they operate on.", "author": "geoand", "createdAt": "2020-02-26T11:38:16Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,194 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+Add custom queries on your entities inside the entities themselves.\n+That way, you and your co-workers can find them easily, and queries are right next to the object they operate on.", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzODk2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384438965", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Quarkus will generates them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.\n          \n          \n            \n            Quarkus will generate them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.", "author": "geoand", "createdAt": "2020-02-26T11:38:50Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,194 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+Add custom queries on your entities inside the entities themselves.\n+That way, you and your co-workers can find them easily, and queries are right next to the object they operate on.\n+Adding them as static methods in your entity class is the Panache Active Record way.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person extends PanacheEntity {\n+    public String name;\n+    public LocalDate birth;\n+    public Status status;\n+\n+    public static Person findByName(String name){\n+        return find(\"name\", name).firstResult();\n+    }\n+\n+    public static List<Person> findAlive(){\n+        return list(\"status\", Status.Alive);\n+    }\n+\n+    public static void deleteStefs(){\n+        delete(\"name\", \"Stef\");\n+    }\n+}\n+----\n+\n+== Solution 2: using the repository pattern\n+\n+\n+=== Defining your entity\n+\n+When using the repository pattern, you can define your entities as regular JPA entities.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person {\n+    @Id @GeneratedValue private Long id;\n+    private String name;\n+    private LocalDate birth;\n+    private Status status;\n+\n+    public Long getId(){\n+        return id;\n+    }\n+    public void setId(Long id){\n+        this.id = id;\n+    }\n+    public String getName() {\n+        return name;\n+    }\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+    public LocalDate getBirth() {\n+        return birth;\n+    }\n+    public void setBirth(LocalDate birth) {\n+        this.birth = birth;\n+    }\n+    public Status getStatus() {\n+        return status;\n+    }\n+    public void setStatus(Status status) {\n+        this.status = status;\n+    }\n+}\n+----\n+\n+TIP: If you don't want to bother defining getters/setters for your entities, you can make them extend `PanacheEntityBase` and\n+Quarkus will generates them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzOTEwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384439109", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When using Repositories, you can get the exact same convenient methods as with the active record pattern, injected in your Repository,\n          \n          \n            \n            When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository,", "author": "geoand", "createdAt": "2020-02-26T11:39:08Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,194 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+Add custom queries on your entities inside the entities themselves.\n+That way, you and your co-workers can find them easily, and queries are right next to the object they operate on.\n+Adding them as static methods in your entity class is the Panache Active Record way.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person extends PanacheEntity {\n+    public String name;\n+    public LocalDate birth;\n+    public Status status;\n+\n+    public static Person findByName(String name){\n+        return find(\"name\", name).firstResult();\n+    }\n+\n+    public static List<Person> findAlive(){\n+        return list(\"status\", Status.Alive);\n+    }\n+\n+    public static void deleteStefs(){\n+        delete(\"name\", \"Stef\");\n+    }\n+}\n+----\n+\n+== Solution 2: using the repository pattern\n+\n+\n+=== Defining your entity\n+\n+When using the repository pattern, you can define your entities as regular JPA entities.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person {\n+    @Id @GeneratedValue private Long id;\n+    private String name;\n+    private LocalDate birth;\n+    private Status status;\n+\n+    public Long getId(){\n+        return id;\n+    }\n+    public void setId(Long id){\n+        this.id = id;\n+    }\n+    public String getName() {\n+        return name;\n+    }\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+    public LocalDate getBirth() {\n+        return birth;\n+    }\n+    public void setBirth(LocalDate birth) {\n+        this.birth = birth;\n+    }\n+    public Status getStatus() {\n+        return status;\n+    }\n+    public void setStatus(Status status) {\n+        this.status = status;\n+    }\n+}\n+----\n+\n+TIP: If you don't want to bother defining getters/setters for your entities, you can make them extend `PanacheEntityBase` and\n+Quarkus will generates them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.\n+\n+=== Defining your repository\n \n-== Paging\n+When using Repositories, you can get the exact same convenient methods as with the active record pattern, injected in your Repository,", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzOTI4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384439281", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once you have written your repository, here are the most common operations you will be able to do:\n          \n          \n            \n            Once you have written your repository, here are the most common operations you will be able to perform:", "author": "geoand", "createdAt": "2020-02-26T11:39:31Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,194 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+Add custom queries on your entities inside the entities themselves.\n+That way, you and your co-workers can find them easily, and queries are right next to the object they operate on.\n+Adding them as static methods in your entity class is the Panache Active Record way.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person extends PanacheEntity {\n+    public String name;\n+    public LocalDate birth;\n+    public Status status;\n+\n+    public static Person findByName(String name){\n+        return find(\"name\", name).firstResult();\n+    }\n+\n+    public static List<Person> findAlive(){\n+        return list(\"status\", Status.Alive);\n+    }\n+\n+    public static void deleteStefs(){\n+        delete(\"name\", \"Stef\");\n+    }\n+}\n+----\n+\n+== Solution 2: using the repository pattern\n+\n+\n+=== Defining your entity\n+\n+When using the repository pattern, you can define your entities as regular JPA entities.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person {\n+    @Id @GeneratedValue private Long id;\n+    private String name;\n+    private LocalDate birth;\n+    private Status status;\n+\n+    public Long getId(){\n+        return id;\n+    }\n+    public void setId(Long id){\n+        this.id = id;\n+    }\n+    public String getName() {\n+        return name;\n+    }\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+    public LocalDate getBirth() {\n+        return birth;\n+    }\n+    public void setBirth(LocalDate birth) {\n+        this.birth = birth;\n+    }\n+    public Status getStatus() {\n+        return status;\n+    }\n+    public void setStatus(Status status) {\n+        this.status = status;\n+    }\n+}\n+----\n+\n+TIP: If you don't want to bother defining getters/setters for your entities, you can make them extend `PanacheEntityBase` and\n+Quarkus will generates them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.\n+\n+=== Defining your repository\n \n-== Paging\n+When using Repositories, you can get the exact same convenient methods as with the active record pattern, injected in your Repository,\n+by making them implements `PanacheRepository`:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PersonRepository implements PanacheRepository<Person> {\n+\n+   // put your custom logic here as instance methods\n+\n+   public Person findByName(String name){\n+       return find(\"name\", name).firstResult();\n+   }\n+\n+   public List<Person> findAlive(){\n+       return list(\"status\", Status.Alive);\n+   }\n+\n+   public void deleteStefs(){\n+       delete(\"name\", \"Stef\");\n+  }\n+}\n+----\n+\n+All the operations that are defined on `PanacheEntityBase` are available on your repository, so using it\n+is exactly the same as using the active record pattern, except you need to inject it:\n+\n+[source,java]\n+----\n+@Inject\n+PersonRepository personRepository;\n+\n+@GET\n+public long count(){\n+    return personRepository.count();\n+}\n+----\n+\n+=== Most useful operations\n+\n+Once you have written your repository, here are the most common operations you will be able to do:", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzOTQ3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384439476", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            but they can be done with the repository pattern as well.\n          \n          \n            \n            but keep in mind that they can be performed with the repository pattern as well.", "author": "geoand", "createdAt": "2020-02-26T11:40:02Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,194 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+Add custom queries on your entities inside the entities themselves.\n+That way, you and your co-workers can find them easily, and queries are right next to the object they operate on.\n+Adding them as static methods in your entity class is the Panache Active Record way.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person extends PanacheEntity {\n+    public String name;\n+    public LocalDate birth;\n+    public Status status;\n+\n+    public static Person findByName(String name){\n+        return find(\"name\", name).firstResult();\n+    }\n+\n+    public static List<Person> findAlive(){\n+        return list(\"status\", Status.Alive);\n+    }\n+\n+    public static void deleteStefs(){\n+        delete(\"name\", \"Stef\");\n+    }\n+}\n+----\n+\n+== Solution 2: using the repository pattern\n+\n+\n+=== Defining your entity\n+\n+When using the repository pattern, you can define your entities as regular JPA entities.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person {\n+    @Id @GeneratedValue private Long id;\n+    private String name;\n+    private LocalDate birth;\n+    private Status status;\n+\n+    public Long getId(){\n+        return id;\n+    }\n+    public void setId(Long id){\n+        this.id = id;\n+    }\n+    public String getName() {\n+        return name;\n+    }\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+    public LocalDate getBirth() {\n+        return birth;\n+    }\n+    public void setBirth(LocalDate birth) {\n+        this.birth = birth;\n+    }\n+    public Status getStatus() {\n+        return status;\n+    }\n+    public void setStatus(Status status) {\n+        this.status = status;\n+    }\n+}\n+----\n+\n+TIP: If you don't want to bother defining getters/setters for your entities, you can make them extend `PanacheEntityBase` and\n+Quarkus will generates them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.\n+\n+=== Defining your repository\n \n-== Paging\n+When using Repositories, you can get the exact same convenient methods as with the active record pattern, injected in your Repository,\n+by making them implements `PanacheRepository`:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PersonRepository implements PanacheRepository<Person> {\n+\n+   // put your custom logic here as instance methods\n+\n+   public Person findByName(String name){\n+       return find(\"name\", name).firstResult();\n+   }\n+\n+   public List<Person> findAlive(){\n+       return list(\"status\", Status.Alive);\n+   }\n+\n+   public void deleteStefs(){\n+       delete(\"name\", \"Stef\");\n+  }\n+}\n+----\n+\n+All the operations that are defined on `PanacheEntityBase` are available on your repository, so using it\n+is exactly the same as using the active record pattern, except you need to inject it:\n+\n+[source,java]\n+----\n+@Inject\n+PersonRepository personRepository;\n+\n+@GET\n+public long count(){\n+    return personRepository.count();\n+}\n+----\n+\n+=== Most useful operations\n+\n+Once you have written your repository, here are the most common operations you will be able to do:\n+\n+[source,java]\n+----\n+// creating a person\n+Person person = new Person();\n+person.name = \"Stef\";\n+person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);\n+person.status = Status.Alive;\n+\n+// persist it\n+personRepository.persist(person);\n+\n+// note that once persisted, you don't need to explicitly save your entity: all\n+// modifications are automatically persisted on transaction commit.\n+\n+// check if it's persistent\n+if(personRepository.isPersistent(person)){\n+    // delete it\n+    personRepository.delete(person);\n+}\n+\n+// getting a list of all Person entities\n+List<Person> allPersons = personRepository.listAll();\n+\n+// finding a specific person by ID\n+person = personRepository.findById(personId);\n+\n+// finding a specific person by ID via an Optional\n+Optional<Person> optional = personRepository.findByIdOptional(personId);\n+person = optional.orElseThrow(() -> new NotFoundException());\n+\n+// finding all living persons\n+List<Person> livingPersons = personRepository.list(\"status\", Status.Alive);\n+\n+// counting all persons\n+long countAll = personRepository.count();\n+\n+// counting all living persons\n+long countAlive = personRepository.count(\"status\", Status.Alive);\n+\n+// delete all living persons\n+personRepository.delete(\"status\", Status.Alive);\n+\n+// delete all persons\n+personRepository.deleteAll();\n+\n+// update all living persons\n+personRepository.update(\"name = 'Moral' where status = ?1\", Status.Alive);\n+\n+----\n+\n+All `list` methods have equivalent `stream` versions.\n+\n+[source,java]\n+----\n+Stream<Person> persons = personRepository.streamAll();\n+List<String> namesButEmmanuels = persons\n+    .map(p -> p.name.toLowerCase() )\n+    .filter( n -> ! \"emmanuel\".equals(n) )\n+    .collect(Collectors.toList());\n+----\n+\n+NOTE: The `stream` methods require a transaction to work.\n+\n+NOTE: The rest of the documentation show usages based on the active record pattern only,\n+but they can be done with the repository pattern as well.", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0NTA2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384445069", "bodyText": "Isn't a they missing ?\nbut keep in mind that can be performed  => but keep in mind that they can be performed  ?", "author": "loicmathieu", "createdAt": "2020-02-26T11:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzOTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0NjQyNA==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384446424", "bodyText": "Yeah... And now you know why I don't usually review docs :). My hands are always a step behind my thought  :(", "author": "geoand", "createdAt": "2020-02-26T11:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzOTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0NzE1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384447159", "bodyText": ";)", "author": "loicmathieu", "createdAt": "2020-02-26T11:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzOTQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzOTg3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384439873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We just don't feel the need to duplicate all the documentation for both patterns.\n          \n          \n            \n            The repository pattern examples have been omitted for brevity.", "author": "geoand", "createdAt": "2020-02-26T11:40:57Z", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -198,8 +213,194 @@ List<String> namesButEmmanuels = persons\n \n NOTE: The `stream` methods require a transaction to work.\n \n+=== Adding entity methods\n+\n+Add custom queries on your entities inside the entities themselves.\n+That way, you and your co-workers can find them easily, and queries are right next to the object they operate on.\n+Adding them as static methods in your entity class is the Panache Active Record way.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person extends PanacheEntity {\n+    public String name;\n+    public LocalDate birth;\n+    public Status status;\n+\n+    public static Person findByName(String name){\n+        return find(\"name\", name).firstResult();\n+    }\n+\n+    public static List<Person> findAlive(){\n+        return list(\"status\", Status.Alive);\n+    }\n+\n+    public static void deleteStefs(){\n+        delete(\"name\", \"Stef\");\n+    }\n+}\n+----\n+\n+== Solution 2: using the repository pattern\n+\n+\n+=== Defining your entity\n+\n+When using the repository pattern, you can define your entities as regular JPA entities.\n+\n+[source,java]\n+----\n+@Entity\n+public class Person {\n+    @Id @GeneratedValue private Long id;\n+    private String name;\n+    private LocalDate birth;\n+    private Status status;\n+\n+    public Long getId(){\n+        return id;\n+    }\n+    public void setId(Long id){\n+        this.id = id;\n+    }\n+    public String getName() {\n+        return name;\n+    }\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+    public LocalDate getBirth() {\n+        return birth;\n+    }\n+    public void setBirth(LocalDate birth) {\n+        this.birth = birth;\n+    }\n+    public Status getStatus() {\n+        return status;\n+    }\n+    public void setStatus(Status status) {\n+        this.status = status;\n+    }\n+}\n+----\n+\n+TIP: If you don't want to bother defining getters/setters for your entities, you can make them extend `PanacheEntityBase` and\n+Quarkus will generates them for you. You can even extend `PanacheEntity` and take advantage of the default ID it provides.\n+\n+=== Defining your repository\n \n-== Paging\n+When using Repositories, you can get the exact same convenient methods as with the active record pattern, injected in your Repository,\n+by making them implements `PanacheRepository`:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PersonRepository implements PanacheRepository<Person> {\n+\n+   // put your custom logic here as instance methods\n+\n+   public Person findByName(String name){\n+       return find(\"name\", name).firstResult();\n+   }\n+\n+   public List<Person> findAlive(){\n+       return list(\"status\", Status.Alive);\n+   }\n+\n+   public void deleteStefs(){\n+       delete(\"name\", \"Stef\");\n+  }\n+}\n+----\n+\n+All the operations that are defined on `PanacheEntityBase` are available on your repository, so using it\n+is exactly the same as using the active record pattern, except you need to inject it:\n+\n+[source,java]\n+----\n+@Inject\n+PersonRepository personRepository;\n+\n+@GET\n+public long count(){\n+    return personRepository.count();\n+}\n+----\n+\n+=== Most useful operations\n+\n+Once you have written your repository, here are the most common operations you will be able to do:\n+\n+[source,java]\n+----\n+// creating a person\n+Person person = new Person();\n+person.name = \"Stef\";\n+person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);\n+person.status = Status.Alive;\n+\n+// persist it\n+personRepository.persist(person);\n+\n+// note that once persisted, you don't need to explicitly save your entity: all\n+// modifications are automatically persisted on transaction commit.\n+\n+// check if it's persistent\n+if(personRepository.isPersistent(person)){\n+    // delete it\n+    personRepository.delete(person);\n+}\n+\n+// getting a list of all Person entities\n+List<Person> allPersons = personRepository.listAll();\n+\n+// finding a specific person by ID\n+person = personRepository.findById(personId);\n+\n+// finding a specific person by ID via an Optional\n+Optional<Person> optional = personRepository.findByIdOptional(personId);\n+person = optional.orElseThrow(() -> new NotFoundException());\n+\n+// finding all living persons\n+List<Person> livingPersons = personRepository.list(\"status\", Status.Alive);\n+\n+// counting all persons\n+long countAll = personRepository.count();\n+\n+// counting all living persons\n+long countAlive = personRepository.count(\"status\", Status.Alive);\n+\n+// delete all living persons\n+personRepository.delete(\"status\", Status.Alive);\n+\n+// delete all persons\n+personRepository.deleteAll();\n+\n+// update all living persons\n+personRepository.update(\"name = 'Moral' where status = ?1\", Status.Alive);\n+\n+----\n+\n+All `list` methods have equivalent `stream` versions.\n+\n+[source,java]\n+----\n+Stream<Person> persons = personRepository.streamAll();\n+List<String> namesButEmmanuels = persons\n+    .map(p -> p.name.toLowerCase() )\n+    .filter( n -> ! \"emmanuel\".equals(n) )\n+    .collect(Collectors.toList());\n+----\n+\n+NOTE: The `stream` methods require a transaction to work.\n+\n+NOTE: The rest of the documentation show usages based on the active record pattern only,\n+but they can be done with the repository pattern as well.\n+We just don't feel the need to duplicate all the documentation for both patterns.", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0MDM0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384440349", "bodyText": "Please just copy the changes I proposed in the other doc to this one :)", "author": "geoand", "createdAt": "2020-02-26T11:41:58Z", "path": "docs/src/main/asciidoc/mongodb-panache.adoc", "diffHunk": "@@ -50,6 +50,9 @@ NOTE: the `list()` method might be surprising at first. It takes fragments of Pa\n That makes for very concise but yet readable code.\n MongoDB native queries are also supported.\n \n+NOTE: what you just see is the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[active record pattern], sometimes just called the entity pattern.", "originalCommit": "d311e32bbddcce019dd5bba1cb2731ee42021638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0NTMyMA==", "url": "https://github.com/quarkusio/quarkus/pull/6923#discussion_r384445320", "bodyText": "OK, will do it", "author": "loicmathieu", "createdAt": "2020-02-26T11:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0MDM0OQ=="}], "type": "inlineReview"}, {"oid": "737a697aba145892ef76d403ac30e9d1b88500b0", "url": "https://github.com/quarkusio/quarkus/commit/737a697aba145892ef76d403ac30e9d1b88500b0", "message": "doc: active record and repository patterns\n\nFixes #6135 and #6945\nWIP Apply suggestions from code review\r\n\r\nwill be squashed later\n\nCo-Authored-By: Georgios Andrianakis <geoand@gmail.com>", "committedDate": "2020-02-26T12:07:38Z", "type": "commit"}, {"oid": "737a697aba145892ef76d403ac30e9d1b88500b0", "url": "https://github.com/quarkusio/quarkus/commit/737a697aba145892ef76d403ac30e9d1b88500b0", "message": "doc: active record and repository patterns\n\nFixes #6135 and #6945\nWIP Apply suggestions from code review\r\n\r\nwill be squashed later\n\nCo-Authored-By: Georgios Andrianakis <geoand@gmail.com>", "committedDate": "2020-02-26T12:07:38Z", "type": "forcePushed"}]}