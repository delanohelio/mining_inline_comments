{"pr_number": 7927, "pr_title": "Document RequestStreamHandler, JUnit tests, Gradle, AWS SDK Java v2, and AWS ASK SDK", "pr_createdAt": "2020-03-18T06:59:10Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7927", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4NjA1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394186059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NB: For Gradle projects please <<gradle,see below>>, or for further reference consult the guide in the link:gradle-tooling[Gradle setup page].\n          \n          \n            \n            NOTE: For Gradle projects please <<gradle,see below>>, or for further reference consult the guide in the link:gradle-tooling[Gradle setup page].\n          \n      \n    \n    \n  \n\n(you will have nice Asciidoc formatting with NOTE)", "author": "gsmet", "createdAt": "2020-03-18T08:49:29Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -27,6 +27,8 @@ To complete this guide, you need:\n * https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]\n * https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing\n \n+NB: For Gradle projects please <<gradle,see below>>, or for further reference consult the guide in the link:gradle-tooling[Gradle setup page].", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4NjU1MA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394186550", "bodyText": "For multi-lines note, better use:\n[NOTE]\n====\nYour\nmulti-line\nnote\nhere.\n====", "author": "gsmet", "createdAt": "2020-03-18T08:50:26Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -49,17 +51,26 @@ mvn archetype:generate \\\n        -DarchetypeVersion={quarkus-version}\n ----\n \n+NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4Njc4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394186783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]\n          \n          \n            \n            NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[code.quarkus.io]\n          \n      \n    \n    \n  \n\n(that's how we call it)", "author": "gsmet", "createdAt": "2020-03-18T08:50:52Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -49,17 +51,26 @@ mvn archetype:generate \\\n        -DarchetypeVersion={quarkus-version}\n ----\n \n+NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4NjkwNA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394186904", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            adding the `quarkus-amazon-lambda` extension as a dependencies.\n          \n          \n            \n            adding the `quarkus-amazon-lambda` extension as a dependency.", "author": "gsmet", "createdAt": "2020-03-18T08:51:05Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -49,17 +51,26 @@ mvn archetype:generate \\\n        -DarchetypeVersion={quarkus-version}\n ----\n \n+NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]\n+adding the `quarkus-amazon-lambda` extension as a dependencies.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4NzA5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394187092", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The depdency for `quarkus-test-amazon-lambda` will also need to be added.\n          \n          \n            \n            The dependency for `quarkus-test-amazon-lambda` will also need to be added.", "author": "gsmet", "createdAt": "2020-03-18T08:51:27Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -49,17 +51,26 @@ mvn archetype:generate \\\n        -DarchetypeVersion={quarkus-version}\n ----\n \n+NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]\n+adding the `quarkus-amazon-lambda` extension as a dependencies.\n+Copy the build.gradle, gradle.properties and settings.gradle into the above generated Maven archetype project, to follow along with this guide.\n+Execute: gradle wrapper to setup the gradle wrapper (recommended).\n+The depdency for `quarkus-test-amazon-lambda` will also need to be added.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4NzMwNA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394187304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler<?, ?> or RequestStreamHandler` interface.\n          \n          \n            \n            The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler<?, ?>` or `RequestStreamHandler` interfaces.", "author": "gsmet", "createdAt": "2020-03-18T08:51:48Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -49,17 +51,26 @@ mvn archetype:generate \\\n        -DarchetypeVersion={quarkus-version}\n ----\n \n+NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]\n+adding the `quarkus-amazon-lambda` extension as a dependencies.\n+Copy the build.gradle, gradle.properties and settings.gradle into the above generated Maven archetype project, to follow along with this guide.\n+Execute: gradle wrapper to setup the gradle wrapper (recommended).\n+The depdency for `quarkus-test-amazon-lambda` will also need to be added.\n+For full Gradle details <<gradle, see below>>.\n+\n+[[choose]]\n == Choose Your Lambda\n \n-The `quarkus-amazon-lambda` extension scans your project for a class that implements the Amazon `RequestHandler` interface.\n+The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler<?, ?> or RequestStreamHandler` interface.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4NzQ1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394187451", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If it finds more than one handler class, a build time exception will also be thrown. For Alexa Skills, implement the RequestStreamHandler directly, rather than subclassing\n          \n          \n            \n            If it finds more than one handler class, a build time exception will also be thrown. For Alexa Skills, implement the `RequestStreamHandler` directly, rather than subclassing", "author": "gsmet", "createdAt": "2020-03-18T08:52:05Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -49,17 +51,26 @@ mvn archetype:generate \\\n        -DarchetypeVersion={quarkus-version}\n ----\n \n+NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]\n+adding the `quarkus-amazon-lambda` extension as a dependencies.\n+Copy the build.gradle, gradle.properties and settings.gradle into the above generated Maven archetype project, to follow along with this guide.\n+Execute: gradle wrapper to setup the gradle wrapper (recommended).\n+The depdency for `quarkus-test-amazon-lambda` will also need to be added.\n+For full Gradle details <<gradle, see below>>.\n+\n+[[choose]]\n == Choose Your Lambda\n \n-The `quarkus-amazon-lambda` extension scans your project for a class that implements the Amazon `RequestHandler` interface.\n+The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler<?, ?> or RequestStreamHandler` interface.\n It must find a class in your project that implements this interface or it will throw a build time failure.\n-If it finds more than one handler class, a build time exception will also be thrown.\n+If it finds more than one handler class, a build time exception will also be thrown. For Alexa Skills, implement the RequestStreamHandler directly, rather than subclassing", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4NzU2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394187565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SkillStreamHandler, for more detail, <<alexa, see below>>.\n          \n          \n            \n            `SkillStreamHandler`, for more detail, <<alexa, see below>>.", "author": "gsmet", "createdAt": "2020-03-18T08:52:15Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -49,17 +51,26 @@ mvn archetype:generate \\\n        -DarchetypeVersion={quarkus-version}\n ----\n \n+NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]\n+adding the `quarkus-amazon-lambda` extension as a dependencies.\n+Copy the build.gradle, gradle.properties and settings.gradle into the above generated Maven archetype project, to follow along with this guide.\n+Execute: gradle wrapper to setup the gradle wrapper (recommended).\n+The depdency for `quarkus-test-amazon-lambda` will also need to be added.\n+For full Gradle details <<gradle, see below>>.\n+\n+[[choose]]\n == Choose Your Lambda\n \n-The `quarkus-amazon-lambda` extension scans your project for a class that implements the Amazon `RequestHandler` interface.\n+The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler<?, ?> or RequestStreamHandler` interface.\n It must find a class in your project that implements this interface or it will throw a build time failure.\n-If it finds more than one handler class, a build time exception will also be thrown.\n+If it finds more than one handler class, a build time exception will also be thrown. For Alexa Skills, implement the RequestStreamHandler directly, rather than subclassing\n+SkillStreamHandler, for more detail, <<alexa, see below>>.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4Nzc1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394187756", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The generated project has three lambdas within it.  Two that implement the RequestHandler<?, ?> interface, and one that implements the RequestStreamHandler interface. One that is used and two that are unused.  If you open up\n          \n          \n            \n            The generated project has three lambdas within it.  Two that implement the `RequestHandler<?, ?>` interface, and one that implements the `RequestStreamHandler` interface. One that is used and two that are unused.  If you open up", "author": "gsmet", "createdAt": "2020-03-18T08:52:34Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -49,17 +51,26 @@ mvn archetype:generate \\\n        -DarchetypeVersion={quarkus-version}\n ----\n \n+NOTE: If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[Code with Quarkus]\n+adding the `quarkus-amazon-lambda` extension as a dependencies.\n+Copy the build.gradle, gradle.properties and settings.gradle into the above generated Maven archetype project, to follow along with this guide.\n+Execute: gradle wrapper to setup the gradle wrapper (recommended).\n+The depdency for `quarkus-test-amazon-lambda` will also need to be added.\n+For full Gradle details <<gradle, see below>>.\n+\n+[[choose]]\n == Choose Your Lambda\n \n-The `quarkus-amazon-lambda` extension scans your project for a class that implements the Amazon `RequestHandler` interface.\n+The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler<?, ?> or RequestStreamHandler` interface.\n It must find a class in your project that implements this interface or it will throw a build time failure.\n-If it finds more than one handler class, a build time exception will also be thrown.\n+If it finds more than one handler class, a build time exception will also be thrown. For Alexa Skills, implement the RequestStreamHandler directly, rather than subclassing\n+SkillStreamHandler, for more detail, <<alexa, see below>>.\n \n Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just\n an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one\n project and use configuration or an environment variable to pick the handler you want to deploy.\n \n-The generated project has two lambdas within it.  One that is used and one that is unused.  If you open up\n+The generated project has three lambdas within it.  Two that implement the RequestHandler<?, ?> interface, and one that implements the RequestStreamHandler interface. One that is used and two that are unused.  If you open up", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4ODMxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394188315", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and setup the LAMBDA_ROLE_ARN environment variable (as described above), please execute manage.sh without any parameters.\n          \n          \n            \n            and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.", "author": "gsmet", "createdAt": "2020-03-18T08:53:37Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -121,7 +141,21 @@ The `manage.sh` script is for managing your lambda using the AWS Lambda Java run\n your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n to create, delete, and update your lambdas.\n \n-`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.  You can create your function using the following command:\n+`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.\n+\n+NOTE: To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys,\n+and setup the LAMBDA_ROLE_ARN environment variable (as described above), please execute manage.sh without any parameters.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4ODQyNA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394188424", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: If using Gradle, the path to the binaries in the manage.sh must be changed from `target` to `build`\n          \n          \n            \n            NOTE: If using Gradle, the path to the binaries in the `manage.sh` must be changed from `target` to `build`", "author": "gsmet", "createdAt": "2020-03-18T08:53:51Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -121,7 +141,21 @@ The `manage.sh` script is for managing your lambda using the AWS Lambda Java run\n your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n to create, delete, and update your lambdas.\n \n-`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.  You can create your function using the following command:\n+`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.\n+\n+NOTE: To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys,\n+and setup the LAMBDA_ROLE_ARN environment variable (as described above), please execute manage.sh without any parameters.\n+A usage statement will be printed to guide you accordingly.\n+\n+NOTE: If using Gradle, the path to the binaries in the manage.sh must be changed from `target` to `build`", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4OTIzNg==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394189236", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n          \n          \n            \n            To illustrate, the project generated by the Maven archetype, generates a JUnit test for the `RequestHandler<?, ?>`, which is shown below.", "author": "gsmet", "createdAt": "2020-03-18T08:55:22Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4OTQ0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394189447", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n          \n          \n            \n            Similarly, if you are using a `RequestStreamHandler` implementation, you can add a matching JUnit test, like below,", "author": "gsmet", "createdAt": "2020-03-18T08:55:41Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4OTUzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394189535", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            which aligns to the generated StreamLambda class in the generated project.\n          \n          \n            \n            which aligns to the generated `StreamLambda` class in the generated project.", "author": "gsmet", "createdAt": "2020-03-18T08:55:50Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4OTY4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394189687", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            whether RequestHandler<?, ?> or RequestStreamHandler.\n          \n          \n            \n            whether `RequestHandler<?, ?>` or `RequestStreamHandler`.", "author": "gsmet", "createdAt": "2020-03-18T08:56:07Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4OTgwNw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394189807", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n          \n          \n            \n            Two versions of the test for `RequestStreamHandler` are presented below.  You can use either, depending on", "author": "gsmet", "createdAt": "2020-03-18T08:56:20Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4OTk5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394189996", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n          \n          \n            \n            If your code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.", "author": "gsmet", "createdAt": "2020-03-18T08:56:40Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MDE1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394190156", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n          \n          \n            \n            To add JUnit functionality for native tests, add the `@NativeImageTest` annotation to a subclass of your test class, which will execute against your native image, and can be leveraged in an IDE.", "author": "gsmet", "createdAt": "2020-03-18T08:56:59Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MDU2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394190563", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n          \n          \n            \n            In addition, remember to enable the AWS X-Ray tracing parameter in `manage.sh`, in the `cmd_create()` function.  This can also be set in the AWS Management Console.", "author": "gsmet", "createdAt": "2020-03-18T08:57:44Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MDkyMA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394190920", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n          \n          \n            \n            AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in `manage.sh` `cmd_create()`. Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.", "author": "gsmet", "createdAt": "2020-03-18T08:58:21Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MTExNA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394191114", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n          \n          \n            \n            If your code makes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,", "author": "gsmet", "createdAt": "2020-03-18T08:58:41Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MTM5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394191393", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n          \n          \n            \n            For native image, however the URL Connection client must be preferred over the Apache HTTP Client", "author": "gsmet", "createdAt": "2020-03-18T08:59:11Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MTYzNA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394191634", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n          \n          \n            \n            You must force your AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,", "author": "gsmet", "createdAt": "2020-03-18T08:59:35Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MTg2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394191861", "bodyText": "I think it would probably be better to use the quarkus-jaxb extension. I think it adds that class for reflection.", "author": "gsmet", "createdAt": "2020-03-18T09:00:01Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwMTg3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394801877", "bodyText": "Thanks for the tip.  I confirm that works in my sample project, updating the docs accordingly.", "author": "oztimpower", "createdAt": "2020-03-19T05:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MTg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MjA2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394192067", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For Maven, `add` the following to your `pom.xml`.\n          \n          \n            \n            For Maven, add the following to your `pom.xml`.", "author": "gsmet", "createdAt": "2020-03-18T09:00:22Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MjU4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394192585", "bodyText": "This is not needed anymore with GraalVM 19.3. As it's the minimal version now, we can get rid if that sunec thing.", "author": "gsmet", "createdAt": "2020-03-18T09:01:22Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.\n+\n+[source,xml]\n+----\n+\n+    <properties>\n+        <aws.sdk2.version>2.10.69</aws.sdk2.version>\n+    </properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <dependency>\n+                <groupId>software.amazon.awssdk</groupId>\n+                <artifactId>bom</artifactId>\n+                <version>${aws.sdk2.version}</version>\n+                <type>pom</type>\n+                <scope>import</scope>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>apache-client</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <!-- sqs/sns/s3 etc -->\n+            <artifactId>sqs</artifactId>\n+            <exclusions>\n+                <!-- exclude the apache-client and netty client -->\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>apache-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>netty-nio-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.jboss.logging</groupId>\n+            <artifactId>commons-logging-jboss-logging</artifactId>\n+            <version>1.0.0.Final</version>\n+        </dependency>\n+    </dependencies>\n+----\n+\n+NOTE: if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,\n+there is some additional work to bundle the function.zip, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].\n+\n+NOTE: If you have a Linux installation of GraalVM, you can reference the artifacts directly; if not, you will need to use Docker.\n+\n+To bundle the missing artifacts, we need to first extract them from the Docker image used to build the native image.\n+\n+We do this by starting up a Docker container, in the background, and attaching to that container to copy the artifacts.\n+\n+First, let's start the GraalVM container, noting the container id output.\n+[source, shell]\n+----\n+docker run -it -d --entrypoint bash quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java8\n+\n+# This will output a container id, like 6304eea6179522aff69acb38eca90bedfd4b970a5475aa37ccda3585bc2abdde\n+# Note this value as we will need it for the commands below\n+----\n+\n+First, libsunec.so, the C library used for the SSL implementation:\n+\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/amd64/libsunec.so src/main/resources/", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg1OTY3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394859671", "bodyText": "Unfortunately that's not the case, I wish it was.  GraalVM 19.3.1 or otherwise.  I've tried Quarkus 1.2.0.Final, 1.2.1.Final, 1.3.0.Final and 999-SNAPSHOT (HEAD) and it's all the same.\nFor example see #7846.\nFor anyone going through that pain (which can turn them away from Quarkus & native-image), I think there's value in having the info there, until it never happens again.  Happy to also publish a reproducible project to show this, it's how I've generated the detail for the documentation featured here.\nWith 1.3.0.Final and GraalVM 19.3.1 (and native-image SSL enabled):\n[INFO] [io.quarkus.deployment.pkg.steps.NativeImageBuildStep] Running Quarkus native-image plugin on GraalVM Version 19.3.1 CE\n\n286 | [INFO] [io.quarkus.deployment.pkg.steps.NativeImageBuildStep] /opt/graalvm/bin/native-image -J-Djava.util.logging.manager=org.jboss.logmanager.LogManager -J-Dsun.nio.ch.maxUpdateArraySize=100 -J-Dvertx.logger-delegate-factory-class-name=io.quarkus.vertx.core.runtime.VertxLogDelegateFactory -J-Dvertx.disableDnsResolver=true -J-Dio.netty.leakDetection.level=DISABLED -J-Dio.netty.allocator.maxOrder=1 -J-Dcom.sun.xml.bind.v2.bytecode.ClassTailor.noOptimize=true -J-Duser.language=en -J-Dfile.encoding=ANSI_X3.4-1968 --initialize-at-build-time= -H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime -H:+JNI -jar gw-sqs-push-1.0-SNAPSHOT-runner.jar -H:FallbackThreshold=0 -H:+ReportExceptionStackTraces -H:-AddAllCharsets -H:-IncludeAllTimeZones -H:EnableURLProtocols=http,https --enable-all-security-services -H:NativeLinkerOption=-no-pie --no-server -H:-UseServiceLoaderFeature -H:+StackTrace gw-sqs-push-1.0-SNAPSHOT-runner\n\n\nInvoking function (sh manage.sh native invoke)\n483 | ++ aws lambda invoke response.txt --function-name GwSqsPushNativeFunction --payload file://payload.json --log-type Tail --query LogResult --output text\n484 | ++ base64 -d\n485 | START RequestId: ea42071e-111e-4d19-b1ee-3da17e54d7cf Version: $LATEST\n486 | handleRequest: Invoked with request [ SQSRequest(firstName=Timothy, lastName=Power) ]\n487 | 2020-03-19 05:25:42,649 INFO  [org.tjp.LambdaSQSPush] (Lambda Thread) handleRequest: Invoked with request [ SQSRequest(firstName=Timothy, lastName=Power) ]\n488 | \u00a0\n489 | handleRequest: Error [ Unable to execute HTTP request: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty ]\n490 | [Ljava.lang.StackTraceElement;@7fd3712e4c98END RequestId: ea42071e-111e-4d19-b1ee-3da17e54d7cf\n491 | REPORT RequestId: ea42071e-111e-4d19-b1ee-3da17e54d7cf  Duration: 428.63 ms Billed Duration: 500 ms Memory Size: 256 MB Max Memory Used: 40 MB  Init Duration: 18.13 ms\n492 | {\"body\":\"{ \\\"exception\\\": \\\"Unable to execute HTTP request: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty\\\" }\",\"headers\":{\"Content-Type\":\"application/json\",\"X-Custom-Header\":\"application/json\"},\"statusCode\":500}/codebuild/output/src105077389/src", "author": "oztimpower", "createdAt": "2020-03-19T08:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MjU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTYyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r395079629", "bodyText": "Marking this as resolved, since it's still an issue, is that ok?", "author": "oztimpower", "createdAt": "2020-03-19T14:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MjU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5Mjg0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394192846", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You final archive will look like this:\n          \n          \n            \n            Your final archive will look like this:", "author": "gsmet", "createdAt": "2020-03-18T09:01:50Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.\n+\n+[source,xml]\n+----\n+\n+    <properties>\n+        <aws.sdk2.version>2.10.69</aws.sdk2.version>\n+    </properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <dependency>\n+                <groupId>software.amazon.awssdk</groupId>\n+                <artifactId>bom</artifactId>\n+                <version>${aws.sdk2.version}</version>\n+                <type>pom</type>\n+                <scope>import</scope>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>apache-client</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <!-- sqs/sns/s3 etc -->\n+            <artifactId>sqs</artifactId>\n+            <exclusions>\n+                <!-- exclude the apache-client and netty client -->\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>apache-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>netty-nio-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.jboss.logging</groupId>\n+            <artifactId>commons-logging-jboss-logging</artifactId>\n+            <version>1.0.0.Final</version>\n+        </dependency>\n+    </dependencies>\n+----\n+\n+NOTE: if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,\n+there is some additional work to bundle the function.zip, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].\n+\n+NOTE: If you have a Linux installation of GraalVM, you can reference the artifacts directly; if not, you will need to use Docker.\n+\n+To bundle the missing artifacts, we need to first extract them from the Docker image used to build the native image.\n+\n+We do this by starting up a Docker container, in the background, and attaching to that container to copy the artifacts.\n+\n+First, let's start the GraalVM container, noting the container id output.\n+[source, shell]\n+----\n+docker run -it -d --entrypoint bash quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java8\n+\n+# This will output a container id, like 6304eea6179522aff69acb38eca90bedfd4b970a5475aa37ccda3585bc2abdde\n+# Note this value as we will need it for the commands below\n+----\n+\n+First, libsunec.so, the C library used for the SSL implementation:\n+\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/amd64/libsunec.so src/main/resources/\n+----\n+\n+Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/security/cacerts src/main/resources/\n+----\n+\n+We then create a new function.zip that adds these artifacts.  As we now need to execute a bootstrap script,\n+we have to rename the Quarkus image to a new name, here `boostrap.bin`, and use the below script as `bootstrap`.\n+\n+[source, shell]\n+----\n+./bootstrap.bin \\\n+    -Djava.library.path=${LAMBDA_TASK_ROOT}/ssl \\\n+    -Djavax.net.ssl.trustStore=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustAnchors=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustStorePassword=changeit\n+----\n+\n+You final archive will look like this:", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5Mjk5MA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394192990", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This can be automated with a new Maven assembly zip.xml, for a new profile, such function-zip.xml\n          \n          \n            \n            This can be automated with a new Maven assembly zip.xml, for a new profile, such as the `function-zip.xml` below:", "author": "gsmet", "createdAt": "2020-03-18T09:02:07Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.\n+\n+[source,xml]\n+----\n+\n+    <properties>\n+        <aws.sdk2.version>2.10.69</aws.sdk2.version>\n+    </properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <dependency>\n+                <groupId>software.amazon.awssdk</groupId>\n+                <artifactId>bom</artifactId>\n+                <version>${aws.sdk2.version}</version>\n+                <type>pom</type>\n+                <scope>import</scope>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>apache-client</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <!-- sqs/sns/s3 etc -->\n+            <artifactId>sqs</artifactId>\n+            <exclusions>\n+                <!-- exclude the apache-client and netty client -->\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>apache-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>netty-nio-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.jboss.logging</groupId>\n+            <artifactId>commons-logging-jboss-logging</artifactId>\n+            <version>1.0.0.Final</version>\n+        </dependency>\n+    </dependencies>\n+----\n+\n+NOTE: if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,\n+there is some additional work to bundle the function.zip, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].\n+\n+NOTE: If you have a Linux installation of GraalVM, you can reference the artifacts directly; if not, you will need to use Docker.\n+\n+To bundle the missing artifacts, we need to first extract them from the Docker image used to build the native image.\n+\n+We do this by starting up a Docker container, in the background, and attaching to that container to copy the artifacts.\n+\n+First, let's start the GraalVM container, noting the container id output.\n+[source, shell]\n+----\n+docker run -it -d --entrypoint bash quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java8\n+\n+# This will output a container id, like 6304eea6179522aff69acb38eca90bedfd4b970a5475aa37ccda3585bc2abdde\n+# Note this value as we will need it for the commands below\n+----\n+\n+First, libsunec.so, the C library used for the SSL implementation:\n+\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/amd64/libsunec.so src/main/resources/\n+----\n+\n+Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/security/cacerts src/main/resources/\n+----\n+\n+We then create a new function.zip that adds these artifacts.  As we now need to execute a bootstrap script,\n+we have to rename the Quarkus image to a new name, here `boostrap.bin`, and use the below script as `bootstrap`.\n+\n+[source, shell]\n+----\n+./bootstrap.bin \\\n+    -Djava.library.path=${LAMBDA_TASK_ROOT}/ssl \\\n+    -Djavax.net.ssl.trustStore=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustAnchors=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustStorePassword=changeit\n+----\n+\n+You final archive will look like this:\n+[source, shell]\n+----\n+jar tvf target/function.zip\n+\n+    bootstrap\n+    bootstrap.bin\n+    ssl/\n+    ssl/cacerts\n+    ssl/libsunec.so\n+----\n+\n+This can be automated with a new Maven assembly zip.xml, for a new profile, such function-zip.xml", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MzMzNA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394193334", "bodyText": "As mentioned above, this shouldn't be needed anymore.", "author": "gsmet", "createdAt": "2020-03-18T09:02:39Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.\n+\n+[source,xml]\n+----\n+\n+    <properties>\n+        <aws.sdk2.version>2.10.69</aws.sdk2.version>\n+    </properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <dependency>\n+                <groupId>software.amazon.awssdk</groupId>\n+                <artifactId>bom</artifactId>\n+                <version>${aws.sdk2.version}</version>\n+                <type>pom</type>\n+                <scope>import</scope>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>apache-client</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <!-- sqs/sns/s3 etc -->\n+            <artifactId>sqs</artifactId>\n+            <exclusions>\n+                <!-- exclude the apache-client and netty client -->\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>apache-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>netty-nio-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.jboss.logging</groupId>\n+            <artifactId>commons-logging-jboss-logging</artifactId>\n+            <version>1.0.0.Final</version>\n+        </dependency>\n+    </dependencies>\n+----\n+\n+NOTE: if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,\n+there is some additional work to bundle the function.zip, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].\n+\n+NOTE: If you have a Linux installation of GraalVM, you can reference the artifacts directly; if not, you will need to use Docker.\n+\n+To bundle the missing artifacts, we need to first extract them from the Docker image used to build the native image.\n+\n+We do this by starting up a Docker container, in the background, and attaching to that container to copy the artifacts.\n+\n+First, let's start the GraalVM container, noting the container id output.\n+[source, shell]\n+----\n+docker run -it -d --entrypoint bash quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java8\n+\n+# This will output a container id, like 6304eea6179522aff69acb38eca90bedfd4b970a5475aa37ccda3585bc2abdde\n+# Note this value as we will need it for the commands below\n+----\n+\n+First, libsunec.so, the C library used for the SSL implementation:\n+\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/amd64/libsunec.so src/main/resources/\n+----\n+\n+Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/security/cacerts src/main/resources/\n+----\n+\n+We then create a new function.zip that adds these artifacts.  As we now need to execute a bootstrap script,\n+we have to rename the Quarkus image to a new name, here `boostrap.bin`, and use the below script as `bootstrap`.\n+\n+[source, shell]\n+----\n+./bootstrap.bin \\\n+    -Djava.library.path=${LAMBDA_TASK_ROOT}/ssl \\\n+    -Djavax.net.ssl.trustStore=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustAnchors=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustStorePassword=changeit\n+----\n+\n+You final archive will look like this:\n+[source, shell]\n+----\n+jar tvf target/function.zip\n+\n+    bootstrap\n+    bootstrap.bin\n+    ssl/\n+    ssl/cacerts\n+    ssl/libsunec.so\n+----\n+\n+This can be automated with a new Maven assembly zip.xml, for a new profile, such function-zip.xml\n+\n+[source, xml]\n+----\n+<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n+          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n+    <id>function-package</id>\n+    <formats>\n+        <format>zip</format>\n+    </formats>\n+    <includeBaseDirectory>false</includeBaseDirectory>\n+    <files>\n+        <file>\n+            <source>${project.build.directory}${file.separator}${artifactId}-${version}-runner</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap.bin</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}cacerts</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>cacerts</destName>\n+            <fileMode>644</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}bootstrap</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}libsunec.so</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MzY3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394193672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            which implements the RequestStreamHandler::requestHandler.  If you examine the source code for this class it is very simple,\n          \n          \n            \n            which implements the `RequestStreamHandler::requestHandler` method.  If you examine the source code for this class it is very simple,", "author": "gsmet", "createdAt": "2020-03-18T09:03:12Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.\n+\n+[source,xml]\n+----\n+\n+    <properties>\n+        <aws.sdk2.version>2.10.69</aws.sdk2.version>\n+    </properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <dependency>\n+                <groupId>software.amazon.awssdk</groupId>\n+                <artifactId>bom</artifactId>\n+                <version>${aws.sdk2.version}</version>\n+                <type>pom</type>\n+                <scope>import</scope>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>apache-client</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <!-- sqs/sns/s3 etc -->\n+            <artifactId>sqs</artifactId>\n+            <exclusions>\n+                <!-- exclude the apache-client and netty client -->\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>apache-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>netty-nio-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.jboss.logging</groupId>\n+            <artifactId>commons-logging-jboss-logging</artifactId>\n+            <version>1.0.0.Final</version>\n+        </dependency>\n+    </dependencies>\n+----\n+\n+NOTE: if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,\n+there is some additional work to bundle the function.zip, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].\n+\n+NOTE: If you have a Linux installation of GraalVM, you can reference the artifacts directly; if not, you will need to use Docker.\n+\n+To bundle the missing artifacts, we need to first extract them from the Docker image used to build the native image.\n+\n+We do this by starting up a Docker container, in the background, and attaching to that container to copy the artifacts.\n+\n+First, let's start the GraalVM container, noting the container id output.\n+[source, shell]\n+----\n+docker run -it -d --entrypoint bash quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java8\n+\n+# This will output a container id, like 6304eea6179522aff69acb38eca90bedfd4b970a5475aa37ccda3585bc2abdde\n+# Note this value as we will need it for the commands below\n+----\n+\n+First, libsunec.so, the C library used for the SSL implementation:\n+\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/amd64/libsunec.so src/main/resources/\n+----\n+\n+Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/security/cacerts src/main/resources/\n+----\n+\n+We then create a new function.zip that adds these artifacts.  As we now need to execute a bootstrap script,\n+we have to rename the Quarkus image to a new name, here `boostrap.bin`, and use the below script as `bootstrap`.\n+\n+[source, shell]\n+----\n+./bootstrap.bin \\\n+    -Djava.library.path=${LAMBDA_TASK_ROOT}/ssl \\\n+    -Djavax.net.ssl.trustStore=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustAnchors=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustStorePassword=changeit\n+----\n+\n+You final archive will look like this:\n+[source, shell]\n+----\n+jar tvf target/function.zip\n+\n+    bootstrap\n+    bootstrap.bin\n+    ssl/\n+    ssl/cacerts\n+    ssl/libsunec.so\n+----\n+\n+This can be automated with a new Maven assembly zip.xml, for a new profile, such function-zip.xml\n+\n+[source, xml]\n+----\n+<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n+          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n+    <id>function-package</id>\n+    <formats>\n+        <format>zip</format>\n+    </formats>\n+    <includeBaseDirectory>false</includeBaseDirectory>\n+    <files>\n+        <file>\n+            <source>${project.build.directory}${file.separator}${artifactId}-${version}-runner</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap.bin</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}cacerts</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>cacerts</destName>\n+            <fileMode>644</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}bootstrap</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}libsunec.so</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>libsunec.so</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+    </files>\n+</assembly>\n+----\n+\n+Maven profile to execute the new function.zip:\n+\n+[source, xml]\n+----\n+        <profile>\n+            <id>zip</id>\n+            <activation>\n+                <property>\n+                    <name>zip</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-assembly-plugin</artifactId>\n+                        <version>3.1.0</version>\n+                        <executions>\n+                            <execution>\n+                                <id>zip-assembly</id>\n+                                <phase>package</phase>\n+                                <goals>\n+                                    <goal>single</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <finalName>function</finalName>\n+                                    <descriptors>\n+                                        <descriptor>src/assembly/function-zip.xml</descriptor>\n+                                    </descriptors>\n+                                    <attach>false</attach>\n+                                    <appendAssemblyId>false</appendAssemblyId>\n+                                </configuration>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+----\n+\n+[[alexa]]\n+== Writing Skills with the Amazon Alexa ASK SDK v2\n+\n+The starting point for an Alexa Skill on AWS Lambda is typically via subclassing `SkillStreamHandler`,\n+which implements the RequestStreamHandler::requestHandler.  If you examine the source code for this class it is very simple,", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5Mzc3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394193773", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: Quarkus requires a direct implementation of the RequestStreamHandler, as the build process will scan only directly implemented interfaces,\n          \n          \n            \n            NOTE: Quarkus requires a direct implementation of `RequestStreamHandler`, as the build process will scan only directly implemented interfaces,", "author": "gsmet", "createdAt": "2020-03-18T09:03:24Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.\n+\n+[source,xml]\n+----\n+\n+    <properties>\n+        <aws.sdk2.version>2.10.69</aws.sdk2.version>\n+    </properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <dependency>\n+                <groupId>software.amazon.awssdk</groupId>\n+                <artifactId>bom</artifactId>\n+                <version>${aws.sdk2.version}</version>\n+                <type>pom</type>\n+                <scope>import</scope>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>apache-client</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <!-- sqs/sns/s3 etc -->\n+            <artifactId>sqs</artifactId>\n+            <exclusions>\n+                <!-- exclude the apache-client and netty client -->\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>apache-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>netty-nio-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.jboss.logging</groupId>\n+            <artifactId>commons-logging-jboss-logging</artifactId>\n+            <version>1.0.0.Final</version>\n+        </dependency>\n+    </dependencies>\n+----\n+\n+NOTE: if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,\n+there is some additional work to bundle the function.zip, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].\n+\n+NOTE: If you have a Linux installation of GraalVM, you can reference the artifacts directly; if not, you will need to use Docker.\n+\n+To bundle the missing artifacts, we need to first extract them from the Docker image used to build the native image.\n+\n+We do this by starting up a Docker container, in the background, and attaching to that container to copy the artifacts.\n+\n+First, let's start the GraalVM container, noting the container id output.\n+[source, shell]\n+----\n+docker run -it -d --entrypoint bash quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java8\n+\n+# This will output a container id, like 6304eea6179522aff69acb38eca90bedfd4b970a5475aa37ccda3585bc2abdde\n+# Note this value as we will need it for the commands below\n+----\n+\n+First, libsunec.so, the C library used for the SSL implementation:\n+\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/amd64/libsunec.so src/main/resources/\n+----\n+\n+Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/security/cacerts src/main/resources/\n+----\n+\n+We then create a new function.zip that adds these artifacts.  As we now need to execute a bootstrap script,\n+we have to rename the Quarkus image to a new name, here `boostrap.bin`, and use the below script as `bootstrap`.\n+\n+[source, shell]\n+----\n+./bootstrap.bin \\\n+    -Djava.library.path=${LAMBDA_TASK_ROOT}/ssl \\\n+    -Djavax.net.ssl.trustStore=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustAnchors=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustStorePassword=changeit\n+----\n+\n+You final archive will look like this:\n+[source, shell]\n+----\n+jar tvf target/function.zip\n+\n+    bootstrap\n+    bootstrap.bin\n+    ssl/\n+    ssl/cacerts\n+    ssl/libsunec.so\n+----\n+\n+This can be automated with a new Maven assembly zip.xml, for a new profile, such function-zip.xml\n+\n+[source, xml]\n+----\n+<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n+          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n+    <id>function-package</id>\n+    <formats>\n+        <format>zip</format>\n+    </formats>\n+    <includeBaseDirectory>false</includeBaseDirectory>\n+    <files>\n+        <file>\n+            <source>${project.build.directory}${file.separator}${artifactId}-${version}-runner</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap.bin</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}cacerts</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>cacerts</destName>\n+            <fileMode>644</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}bootstrap</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}libsunec.so</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>libsunec.so</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+    </files>\n+</assembly>\n+----\n+\n+Maven profile to execute the new function.zip:\n+\n+[source, xml]\n+----\n+        <profile>\n+            <id>zip</id>\n+            <activation>\n+                <property>\n+                    <name>zip</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-assembly-plugin</artifactId>\n+                        <version>3.1.0</version>\n+                        <executions>\n+                            <execution>\n+                                <id>zip-assembly</id>\n+                                <phase>package</phase>\n+                                <goals>\n+                                    <goal>single</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <finalName>function</finalName>\n+                                    <descriptors>\n+                                        <descriptor>src/assembly/function-zip.xml</descriptor>\n+                                    </descriptors>\n+                                    <attach>false</attach>\n+                                    <appendAssemblyId>false</appendAssemblyId>\n+                                </configuration>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+----\n+\n+[[alexa]]\n+== Writing Skills with the Amazon Alexa ASK SDK v2\n+\n+The starting point for an Alexa Skill on AWS Lambda is typically via subclassing `SkillStreamHandler`,\n+which implements the RequestStreamHandler::requestHandler.  If you examine the source code for this class it is very simple,\n+and can be implemented directly without this helper base class.\n+\n+NOTE: Quarkus requires a direct implementation of the RequestStreamHandler, as the build process will scan only directly implemented interfaces,", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MzkwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394193909", "bodyText": "Why don't we fix that instead?", "author": "gsmet", "createdAt": "2020-03-18T09:03:41Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.\n+\n+[source,xml]\n+----\n+\n+    <properties>\n+        <aws.sdk2.version>2.10.69</aws.sdk2.version>\n+    </properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <dependency>\n+                <groupId>software.amazon.awssdk</groupId>\n+                <artifactId>bom</artifactId>\n+                <version>${aws.sdk2.version}</version>\n+                <type>pom</type>\n+                <scope>import</scope>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>apache-client</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <!-- sqs/sns/s3 etc -->\n+            <artifactId>sqs</artifactId>\n+            <exclusions>\n+                <!-- exclude the apache-client and netty client -->\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>apache-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>netty-nio-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.jboss.logging</groupId>\n+            <artifactId>commons-logging-jboss-logging</artifactId>\n+            <version>1.0.0.Final</version>\n+        </dependency>\n+    </dependencies>\n+----\n+\n+NOTE: if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,\n+there is some additional work to bundle the function.zip, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].\n+\n+NOTE: If you have a Linux installation of GraalVM, you can reference the artifacts directly; if not, you will need to use Docker.\n+\n+To bundle the missing artifacts, we need to first extract them from the Docker image used to build the native image.\n+\n+We do this by starting up a Docker container, in the background, and attaching to that container to copy the artifacts.\n+\n+First, let's start the GraalVM container, noting the container id output.\n+[source, shell]\n+----\n+docker run -it -d --entrypoint bash quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java8\n+\n+# This will output a container id, like 6304eea6179522aff69acb38eca90bedfd4b970a5475aa37ccda3585bc2abdde\n+# Note this value as we will need it for the commands below\n+----\n+\n+First, libsunec.so, the C library used for the SSL implementation:\n+\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/amd64/libsunec.so src/main/resources/\n+----\n+\n+Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/security/cacerts src/main/resources/\n+----\n+\n+We then create a new function.zip that adds these artifacts.  As we now need to execute a bootstrap script,\n+we have to rename the Quarkus image to a new name, here `boostrap.bin`, and use the below script as `bootstrap`.\n+\n+[source, shell]\n+----\n+./bootstrap.bin \\\n+    -Djava.library.path=${LAMBDA_TASK_ROOT}/ssl \\\n+    -Djavax.net.ssl.trustStore=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustAnchors=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustStorePassword=changeit\n+----\n+\n+You final archive will look like this:\n+[source, shell]\n+----\n+jar tvf target/function.zip\n+\n+    bootstrap\n+    bootstrap.bin\n+    ssl/\n+    ssl/cacerts\n+    ssl/libsunec.so\n+----\n+\n+This can be automated with a new Maven assembly zip.xml, for a new profile, such function-zip.xml\n+\n+[source, xml]\n+----\n+<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n+          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n+    <id>function-package</id>\n+    <formats>\n+        <format>zip</format>\n+    </formats>\n+    <includeBaseDirectory>false</includeBaseDirectory>\n+    <files>\n+        <file>\n+            <source>${project.build.directory}${file.separator}${artifactId}-${version}-runner</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap.bin</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}cacerts</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>cacerts</destName>\n+            <fileMode>644</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}bootstrap</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}libsunec.so</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>libsunec.so</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+    </files>\n+</assembly>\n+----\n+\n+Maven profile to execute the new function.zip:\n+\n+[source, xml]\n+----\n+        <profile>\n+            <id>zip</id>\n+            <activation>\n+                <property>\n+                    <name>zip</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-assembly-plugin</artifactId>\n+                        <version>3.1.0</version>\n+                        <executions>\n+                            <execution>\n+                                <id>zip-assembly</id>\n+                                <phase>package</phase>\n+                                <goals>\n+                                    <goal>single</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <finalName>function</finalName>\n+                                    <descriptors>\n+                                        <descriptor>src/assembly/function-zip.xml</descriptor>\n+                                    </descriptors>\n+                                    <attach>false</attach>\n+                                    <appendAssemblyId>false</appendAssemblyId>\n+                                </configuration>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+----\n+\n+[[alexa]]\n+== Writing Skills with the Amazon Alexa ASK SDK v2\n+\n+The starting point for an Alexa Skill on AWS Lambda is typically via subclassing `SkillStreamHandler`,\n+which implements the RequestStreamHandler::requestHandler.  If you examine the source code for this class it is very simple,\n+and can be implemented directly without this helper base class.\n+\n+NOTE: Quarkus requires a direct implementation of the RequestStreamHandler, as the build process will scan only directly implemented interfaces,\n+inherited interfaces will not be seen.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwMTYwOA==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394801608", "bodyText": "Yes... part of the reason I added this to the docs was to draw attention to this.  If a core member (or someone who understands what to change in the core libraries) could help make the change that would be appreciated.  I'll raise a separate Feature Request item for it.", "author": "oztimpower", "createdAt": "2020-03-19T05:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MzkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA4Njg4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r395086883", "bodyText": "Followed the instruction on #7955 to check for subclasses of the SkillStreamHandler also.  I have this working (2 lines of code, plus runtime bom addition).\nHence, I'm removing all Alexa references from the document.", "author": "oztimpower", "createdAt": "2020-03-19T14:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5MzkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE5NDEyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/7927#discussion_r394194121", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Specifically you add a requestHandler implementation as below.\n          \n          \n            \n            Specifically you add a `RequestStreamHandler` implementation as below.", "author": "gsmet", "createdAt": "2020-03-18T09:04:03Z", "path": "docs/src/main/asciidoc/amazon-lambda.adoc", "diffHunk": "@@ -240,33 +294,469 @@ of things you need to do.  Take a look at the generated example project to get a\n 3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.\n \n-NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar\n+[[gradle]]\n+== Gradle build\n+\n+Similarly for Gradle projects, if you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there are a couple\n+of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.\n+\n+1. Include the `quarkus-amazon-lambda`, and `quarkus-test-amazon-lambda` extensions as Gradle dependencies, as below\n+2. Configure Quarkus to build an `uber-jar` (via appending --uber-jar to the Gradle build command)\n+3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.\n+\n+\n+Example Gradle dependencies:\n+\n+[source, groovy]\n+----\n+dependencies {\n+    implementation enforcedPlatform(\"${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}\")\n+    implementation 'io.quarkus:quarkus-resteasy'\n+    implementation 'io.quarkus:quarkus-amazon-lambda'\n+\n+    testimplementation  \"io.quarkus:quarkus-test-amazon-lambda\"\n+\n+    testImplementation 'io.quarkus:quarkus-junit5'\n+    testImplementation 'io.rest-assured:rest-assured'\n+}\n+----\n+\n+\n+== Integration Testing\n+The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function,\n+via the integration layer that Quarkus provides.  This is true for both JVM and native modes.\n+It provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+To illustrate, the project generated by the Maven archetype, generates a JUnit test for the RequestHandler<?, ?>, which is shown below.\n+The test replicates the execution environment, for the function that is selected for invocation, as described <<choose, above>>.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaHandlerTest {\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        InputObject in = new InputObject();\n+        in.setGreeting(\"Hello\");\n+        in.setName(\"Stu\");\n+\n+        OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n+\n+        Assertions.assertEquals(\"Hello Stu\", out.getResult());\n+        Assertions.assertTrue(out.getRequestId().matches(\"aws-request-\\\\d\"), \"Expected requestId as 'aws-request-<number>'\");\n+    }\n+}\n+----\n+\n+Similarly, if you are using a RequestStreamHandler implementation, you can add a matching JUnit test, like below,\n+which aligns to the generated StreamLambda class in the generated project.\n+\n+Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces,\n+whether RequestHandler<?, ?> or RequestStreamHandler.\n+\n+Two versions of the Test for RequestStreamHandler are presented below.  You can use either, depending on\n+the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.\n+\n+[source,java]\n+----\n+@QuarkusTest\n+public class LambdaStreamHandlerTest {\n+\n+    private static Logger LOG = Logger.getLogger(LambdaStreamHandlerTest.class);\n+\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        String out = LambdaClient.invoke(String.class, \"lowercase\");\n+        Assertions.assertEquals(\"LOWERCASE\", out);\n+    }\n+\n+    @Test\n+    public void testInputStreamSuccess() {\n+        try {\n+            String input = \"{ \\\"name\\\": \\\"Bill\\\", \\\"greeting\\\": \\\"hello\\\"}\";\n+            InputStream inputStream = new ByteArrayInputStream(input.getBytes());\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n+            LambdaClient.invoke(inputStream, outputStream);\n+\n+            ByteArrayInputStream out = new ByteArrayInputStream(outputStream.toByteArray());\n+            StringBuilder response = new StringBuilder();\n+            int i = 0;\n+            while ((i = out.read()) != -1) {\n+                response.append((char)i);\n+            }\n+\n+            Assertions.assertTrue(response.toString().contains(\"BILL\"));\n+        } catch (Exception e) {\n+            Assertions.fail(e.getMessage());\n+        }\n+    }\n+\n+}\n+----\n+\n+If you code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.\n+\n+To add JUnit functionality for native tests, add the @NativeImageTest to a subclass of your Test class, which will execute against your native image, and can be leveraged in an IDE.\n+\n \n == Testing with the SAM CLI\n \n The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires\n https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n-to take advantage of it.  Otherwise, dev mode should be sufficient for most of your needs.\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n \n A starter template has been generated for both JVM and native execution modes.\n \n-Run the following SAM CLI command to locally test your lambda function:\n+Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+NOTE: If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`\n \n [source]\n ----\n-sam local invoke --template sam.jvm.yaml --event {json test file}\n+sam local invoke --template sam.jvm.yaml --event payload.json\n ----\n \n The native image can also be locally tested using the `sam.native.yaml` template:\n \n [source]\n ----\n-sam local invoke --template sam.native.yaml --event {json test file}\n+sam local invoke --template sam.native.yaml --event payload.json\n ----\n \n == Tracing with AWS XRay and GraalVM\n \n If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda\n you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray\n library is not fully compatible with GraalVM so we had to do some integration work to make this work.\n+\n+In addition, remember to enable the AWS X-Ray tracing parameter in manage.sh, in the cmd_create() function.  This can also be set in the AWS Management Console.\n+[source]\n+----\n+    --tracing-config Mode=Active\n+----\n+\n+For the sam template files, add the following to the YAML function Properties.\n+[source]\n+----\n+    Tracing: Active\n+----\n+\n+AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in manage.sh cmd_create(). Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.\n+\n+[[https]]\n+== Using HTTPS or SSL/TLS\n+\n+If you code makes invokes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image,\n+as GraalVM will only include the dependencies when explictly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.\n+For further information, please consult the link:native-and-ssl[Quarkus SSL guide]\n+\n+Open src/main/resources/application.properties and add the following line to enable SSL in your native image.\n+\n+[source]\n+----\n+quarkus.ssl.native=true\n+----\n+\n+[[aws-sdk-v2]]\n+== Using the AWS Java SDK v2\n+\n+With minimal integration, it is possible to leverage the AWS Java SDK v2,\n+which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.\n+\n+For native image, however the URL Connection client must be preferred over the ApacheHTTP Client\n+when using synchronous mode, due to issues in the GraalVM compilation (at present).\n+\n+\n+Create a `reflection-config.json` file in `src/main/resources/`\n+[source, json]\n+----\n+[\n+  {\n+    \"name\":\"com.sun.xml.internal.stream.XMLInputFactoryImpl\",\n+    \"methods\":[{\"name\":\"<init>\",\"parameterTypes\":[] }]\n+  }\n+]\n+----\n+\n+Bind the above reflection-config.json to your build, via additions to the `application.properties`:\n+[source,properties]\n+----\n+quarkus.native.additional-build-args=-H:ReflectionConfigurationFiles=reflection-config.json\n+\n+quarkus.ssl.native=true\n+----\n+\n+You must force you AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS,\n+hence the inclusion of the SSL enabled property also.\n+\n+[source,java]\n+----\n+// select the appropriate client, in this case SQS, and\n+// insert your region, instead of XXXX, which also improves startup time over the default client\n+  client = SqsClient.builder().region(Region.XXXX).httpClient(software.amazon.awssdk.http.urlconnection.UrlConnectionHttpClient.builder().build()).build();\n+----\n+\n+For Maven, `add` the following to your `pom.xml`.\n+\n+[source,xml]\n+----\n+\n+    <properties>\n+        <aws.sdk2.version>2.10.69</aws.sdk2.version>\n+    </properties>\n+\n+    <dependencyManagement>\n+        <dependencies>\n+\n+            <dependency>\n+                <groupId>software.amazon.awssdk</groupId>\n+                <artifactId>bom</artifactId>\n+                <version>${aws.sdk2.version}</version>\n+                <type>pom</type>\n+                <scope>import</scope>\n+            </dependency>\n+\n+        </dependencies>\n+    </dependencyManagement>\n+    <dependencies>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>apache-client</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <!-- sqs/sns/s3 etc -->\n+            <artifactId>sqs</artifactId>\n+            <exclusions>\n+                <!-- exclude the apache-client and netty client -->\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>apache-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>software.amazon.awssdk</groupId>\n+                    <artifactId>netty-nio-client</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>commons-logging</groupId>\n+                    <artifactId>commons-logging</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.jboss.logging</groupId>\n+            <artifactId>commons-logging-jboss-logging</artifactId>\n+            <version>1.0.0.Final</version>\n+        </dependency>\n+    </dependencies>\n+----\n+\n+NOTE: if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM,\n+there is some additional work to bundle the function.zip, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].\n+\n+NOTE: If you have a Linux installation of GraalVM, you can reference the artifacts directly; if not, you will need to use Docker.\n+\n+To bundle the missing artifacts, we need to first extract them from the Docker image used to build the native image.\n+\n+We do this by starting up a Docker container, in the background, and attaching to that container to copy the artifacts.\n+\n+First, let's start the GraalVM container, noting the container id output.\n+[source, shell]\n+----\n+docker run -it -d --entrypoint bash quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java8\n+\n+# This will output a container id, like 6304eea6179522aff69acb38eca90bedfd4b970a5475aa37ccda3585bc2abdde\n+# Note this value as we will need it for the commands below\n+----\n+\n+First, libsunec.so, the C library used for the SSL implementation:\n+\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/amd64/libsunec.so src/main/resources/\n+----\n+\n+Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.\n+[source]\n+----\n+docker cp {container-id-from-above}:/opt/graalvm/jre/lib/security/cacerts src/main/resources/\n+----\n+\n+We then create a new function.zip that adds these artifacts.  As we now need to execute a bootstrap script,\n+we have to rename the Quarkus image to a new name, here `boostrap.bin`, and use the below script as `bootstrap`.\n+\n+[source, shell]\n+----\n+./bootstrap.bin \\\n+    -Djava.library.path=${LAMBDA_TASK_ROOT}/ssl \\\n+    -Djavax.net.ssl.trustStore=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustAnchors=${LAMBDA_TASK_ROOT}/ssl/cacerts \\\n+    -Djavax.net.ssl.trustStorePassword=changeit\n+----\n+\n+You final archive will look like this:\n+[source, shell]\n+----\n+jar tvf target/function.zip\n+\n+    bootstrap\n+    bootstrap.bin\n+    ssl/\n+    ssl/cacerts\n+    ssl/libsunec.so\n+----\n+\n+This can be automated with a new Maven assembly zip.xml, for a new profile, such function-zip.xml\n+\n+[source, xml]\n+----\n+<assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n+          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\">\n+    <id>function-package</id>\n+    <formats>\n+        <format>zip</format>\n+    </formats>\n+    <includeBaseDirectory>false</includeBaseDirectory>\n+    <files>\n+        <file>\n+            <source>${project.build.directory}${file.separator}${artifactId}-${version}-runner</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap.bin</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}cacerts</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>cacerts</destName>\n+            <fileMode>644</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}bootstrap</source>\n+            <outputDirectory>${file.separator}</outputDirectory>\n+            <destName>bootstrap</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+        <file>\n+            <source>${project.basedir}${file.separator}src${file.separator}main${file.separator}resources${file.separator}libsunec.so</source>\n+            <outputDirectory>${file.separator}ssl</outputDirectory>\n+            <destName>libsunec.so</destName>\n+            <fileMode>755</fileMode>\n+        </file>\n+    </files>\n+</assembly>\n+----\n+\n+Maven profile to execute the new function.zip:\n+\n+[source, xml]\n+----\n+        <profile>\n+            <id>zip</id>\n+            <activation>\n+                <property>\n+                    <name>zip</name>\n+                </property>\n+            </activation>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.apache.maven.plugins</groupId>\n+                        <artifactId>maven-assembly-plugin</artifactId>\n+                        <version>3.1.0</version>\n+                        <executions>\n+                            <execution>\n+                                <id>zip-assembly</id>\n+                                <phase>package</phase>\n+                                <goals>\n+                                    <goal>single</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <finalName>function</finalName>\n+                                    <descriptors>\n+                                        <descriptor>src/assembly/function-zip.xml</descriptor>\n+                                    </descriptors>\n+                                    <attach>false</attach>\n+                                    <appendAssemblyId>false</appendAssemblyId>\n+                                </configuration>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+        </profile>\n+----\n+\n+[[alexa]]\n+== Writing Skills with the Amazon Alexa ASK SDK v2\n+\n+The starting point for an Alexa Skill on AWS Lambda is typically via subclassing `SkillStreamHandler`,\n+which implements the RequestStreamHandler::requestHandler.  If you examine the source code for this class it is very simple,\n+and can be implemented directly without this helper base class.\n+\n+NOTE: Quarkus requires a direct implementation of the RequestStreamHandler, as the build process will scan only directly implemented interfaces,\n+inherited interfaces will not be seen.\n+\n+Specifically you add a requestHandler implementation as below.", "originalCommit": "295db65781057c5782ca86c40d8bc3f6ff475cff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "966e9117fc6d1eef05a32bacd52531d1b4e09816", "url": "https://github.com/quarkusio/quarkus/commit/966e9117fc6d1eef05a32bacd52531d1b4e09816", "message": "Include Gradle support, JUnit tests, AWS SDK Java v2, and AWS ASK SDK v2 (Alexa)", "committedDate": "2020-03-19T06:00:09Z", "type": "forcePushed"}, {"oid": "c57da383f54aac73e5e75b03d857073948aa2c22", "url": "https://github.com/quarkusio/quarkus/commit/c57da383f54aac73e5e75b03d857073948aa2c22", "message": "Include Gradle support, JUnit tests, AWS SDK Java v2, and AWS ASK SDK v2 (Alexa)", "committedDate": "2020-03-19T13:50:55Z", "type": "forcePushed"}, {"oid": "07db8c5f40310581002e32e71ccbf665a8095036", "url": "https://github.com/quarkusio/quarkus/commit/07db8c5f40310581002e32e71ccbf665a8095036", "message": "Include Gradle support, JUnit tests, AWS SDK Java v2", "committedDate": "2020-03-19T14:50:27Z", "type": "commit"}, {"oid": "07db8c5f40310581002e32e71ccbf665a8095036", "url": "https://github.com/quarkusio/quarkus/commit/07db8c5f40310581002e32e71ccbf665a8095036", "message": "Include Gradle support, JUnit tests, AWS SDK Java v2", "committedDate": "2020-03-19T14:50:27Z", "type": "forcePushed"}]}