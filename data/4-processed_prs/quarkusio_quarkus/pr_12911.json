{"pr_number": 12911, "pr_title": "Common dev mode launcher API for Maven and Gradle", "pr_createdAt": "2020-10-23T21:29:11Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/12911", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxMTQxMA==", "url": "https://github.com/quarkusio/quarkus/pull/12911#discussion_r511511410", "bodyText": "Should be Gradle here no?", "author": "glefloch", "createdAt": "2020-10-24T20:31:10Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusDev.java", "diffHunk": "@@ -194,205 +180,113 @@ public void startDev() {\n                     \"Does the project have any source files?\");\n         }\n \n-        DevModeContext context = new DevModeContext();\n-        context.setProjectDir(project.getProjectDir());\n-        for (Map.Entry<Object, Object> e : System.getProperties().entrySet()) {\n-            context.getSystemProperties().put(e.getKey().toString(), (String) e.getValue());\n+        try {\n+            QuarkusDevModeLauncher runner = newLauncher();\n+            project.exec(action -> {\n+                action.commandLine(runner.args()).workingDir(getWorkingDir());\n+                action.setStandardInput(System.in)\n+                        .setErrorOutput(System.out)\n+                        .setStandardOutput(System.out);\n+            });\n+\n+        } catch (Exception e) {\n+            throw new GradleException(\"Failed to run\", e);\n+        }\n+    }\n+\n+    private QuarkusDevModeLauncher newLauncher() throws Exception {\n+        final Project project = getProject();\n+        GradleDevModeLauncher.Builder builder = GradleDevModeLauncher.builder(getLogger())\n+                .preventnoverify(isPreventnoverify())\n+                .projectDir(project.getProjectDir())\n+                .buildDir(getBuildDir())\n+                .outputDir(getBuildDir())\n+                .debug(System.getProperty(\"debug\"))\n+                .suspend(System.getProperty(\"suspend\"));\n+\n+        if (getJvmArgs() != null) {\n+            builder.jvmArgs(getJvmArgs());\n         }\n+\n         for (Map.Entry<String, ?> e : project.getProperties().entrySet()) {\n             if (e.getValue() instanceof String) {\n-                context.getBuildSystemProperties().put(e.getKey(), e.getValue().toString());\n+                builder.buildSystemProperty(e.getKey(), e.getValue().toString());\n             }\n         }\n \n         //  this is a minor hack to allow ApplicationConfig to be populated with defaults\n-        context.getBuildSystemProperties().putIfAbsent(\"quarkus.application.name\", project.getName());\n+        builder.applicationName(project.getName());\n         if (project.getVersion() != null) {\n-            context.getBuildSystemProperties().putIfAbsent(\"quarkus.application.version\", project.getVersion().toString());\n-        }\n-\n-        context.setSourceEncoding(getSourceEncoding());\n-        try {\n-            List<String> args = new ArrayList<>();\n-            args.add(JavaBinFinder.findBin());\n-            final String debug = System.getProperty(\"debug\");\n-            final String suspend = System.getProperty(\"suspend\");\n-            String debugSuspend = \"n\";\n-            if (suspend != null) {\n-                switch (suspend.toLowerCase(Locale.ENGLISH)) {\n-                    case \"n\":\n-                    case \"false\": {\n-                        debugSuspend = \"n\";\n-                        break;\n-                    }\n-                    case \"\":\n-                    case \"y\":\n-                    case \"true\": {\n-                        debugSuspend = \"y\";\n-                        break;\n-                    }\n-                    default: {\n-                        System.err.println(\n-                                \"Ignoring invalid value \\\"\" + suspend + \"\\\" for \\\"suspend\\\" param and defaulting to \\\"n\\\"\");\n-                        break;\n-                    }\n-                }\n-            }\n-            if (debug == null) {\n-                // debug mode not specified\n-                // make sure 5005 is not used, we don't want to just fail if something else is using it\n-                try (Socket socket = new Socket(InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 }), 5005)) {\n-                    System.err.println(\"Port 5005 in use, not starting in debug mode\");\n-                } catch (IOException e) {\n-                    args.add(\"-Xdebug\");\n-                    args.add(\"-Xrunjdwp:transport=dt_socket,address=0.0.0.0:5005,server=y,suspend=\" + debugSuspend);\n-                }\n-            } else if (debug.toLowerCase().equals(\"client\")) {\n-                args.add(\"-Xdebug\");\n-                args.add(\"-Xrunjdwp:transport=dt_socket,address=localhost:5005,server=n,suspend=\" + debugSuspend);\n-            } else if (debug.toLowerCase().equals(\"true\") || debug.isEmpty()) {\n-                args.add(\"-Xdebug\");\n-                args.add(\"-Xrunjdwp:transport=dt_socket,address=0.0.0.0:5005,server=y,suspend=\" + debugSuspend);\n-            } else if (!debug.toLowerCase().equals(\"false\")) {\n-                try {\n-                    int port = Integer.parseInt(debug);\n-                    if (port <= 0) {\n-                        throw new GradleException(\"The specified debug port must be greater than 0\");\n-                    }\n-                    args.add(\"-Xdebug\");\n-                    args.add(\"-Xrunjdwp:transport=dt_socket,address=0.0.0.0:\" + port + \",server=y,suspend=\" + debugSuspend);\n-                } catch (NumberFormatException e) {\n-                    throw new GradleException(\n-                            \"Invalid value for debug parameter: \" + debug + \" must be true|false|client|{port}\");\n-                }\n-            }\n-            if (getJvmArgs() != null) {\n-                args.addAll(getJvmArgs());\n-            }\n-\n-            // the following flags reduce startup time and are acceptable only for dev purposes\n-            args.add(\"-XX:TieredStopAtLevel=1\");\n-            if (!isPreventnoverify()) {\n-                args.add(\"-Xverify:none\");\n-            }\n-\n-            //build a class-path string for the base platform\n-            //this stuff does not change\n-            // Do not include URIs in the manifest, because some JVMs do not like that\n-            StringBuilder classPathManifest = new StringBuilder();\n-\n-            final AppModel appModel;\n-            final AppModelResolver modelResolver = extension().getAppModelResolver(LaunchMode.DEVELOPMENT);\n-            try {\n-                final AppArtifact appArtifact = extension.getAppArtifact();\n-                appArtifact.setPaths(QuarkusGradleUtils.getOutputPaths(project));\n-                appModel = modelResolver.resolveModel(appArtifact);\n-            } catch (AppModelResolverException e) {\n-                throw new GradleException(\"Failed to resolve application model \" + extension.getAppArtifact() + \" dependencies\",\n-                        e);\n-            }\n+            builder.applicationVersion(project.getVersion().toString());\n \n-            args.add(\"-Djava.util.logging.manager=org.jboss.logmanager.LogManager\");\n-\n-            final Set<AppArtifactKey> projectDependencies = new HashSet<>();\n-            addSelfWithLocalDeps(project, context, new HashSet<>(), projectDependencies, true);\n+        }\n \n-            for (AppDependency appDependency : appModel.getFullDeploymentDeps()) {\n-                final AppArtifact appArtifact = appDependency.getArtifact();\n-                if (!projectDependencies.contains(new AppArtifactKey(appArtifact.getGroupId(), appArtifact.getArtifactId()))) {\n-                    appArtifact.getPaths().forEach(p -> {\n-                        if (Files.exists(p)) {\n-                            addToClassPaths(classPathManifest, p.toFile());\n-                        }\n-                    });\n-                }\n-            }\n+        builder.sourceEncoding(getSourceEncoding());\n \n-            //we also want to add the maven plugin jar to the class path\n-            //this allows us to just directly use classes, without messing around copying them\n-            //to the runner jar\n-            addGradlePluginDeps(classPathManifest, context);\n+        final AppModel appModel;\n+        final AppModelResolver modelResolver = extension().getAppModelResolver(LaunchMode.DEVELOPMENT);\n+        try {\n+            final AppArtifact appArtifact = extension().getAppArtifact();\n+            appArtifact.setPaths(QuarkusGradleUtils.getOutputPaths(project));\n+            appModel = modelResolver.resolveModel(appArtifact);\n+        } catch (AppModelResolverException e) {\n+            throw new GradleException(\"Failed to resolve application model \" + extension().getAppArtifact() + \" dependencies\",\n+                    e);\n+        }\n \n-            context.setCacheDir(new File(getBuildDir(), \"transformer-cache\").getAbsoluteFile());\n+        final Set<AppArtifactKey> projectDependencies = new HashSet<>();\n+        addSelfWithLocalDeps(project, builder, new HashSet<>(), projectDependencies, true);\n \n-            JavaPluginConvention javaPluginConvention = project.getConvention().findPlugin(JavaPluginConvention.class);\n-            if (javaPluginConvention != null) {\n-                context.setSourceJavaVersion(javaPluginConvention.getSourceCompatibility().toString());\n-                context.setTargetJvmVersion(javaPluginConvention.getTargetCompatibility().toString());\n-            }\n-\n-            if (getCompilerArgs().isEmpty()) {\n-                getJavaCompileTask()\n-                        .map(compileTask -> compileTask.getOptions().getCompilerArgs())\n-                        .ifPresent(context::setCompilerOptions);\n-            } else {\n-                context.setCompilerOptions(getCompilerArgs());\n+        for (AppDependency appDependency : appModel.getFullDeploymentDeps()) {\n+            final AppArtifact appArtifact = appDependency.getArtifact();\n+            if (!projectDependencies.contains(new AppArtifactKey(appArtifact.getGroupId(), appArtifact.getArtifactId()))) {\n+                appArtifact.getPaths().forEach(p -> {\n+                    if (Files.exists(p)) {\n+                        addToClassPaths(builder, p.toFile());\n+                    }\n+                });\n             }\n+        }\n \n-            // this is the jar file we will use to launch the dev mode main class\n-            final File tempFile = new File(getBuildDir(), extension.finalName() + \"-dev.jar\");\n-            tempFile.delete();\n-            tempFile.deleteOnExit();\n-\n-            context.setDevModeRunnerJarFile(tempFile);\n-            modifyDevModeContext(context);\n-            try (ZipOutputStream out = new ZipOutputStream(new FileOutputStream(tempFile))) {\n-                out.putNextEntry(new ZipEntry(\"META-INF/\"));\n-                Manifest manifest = new Manifest();\n-                manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n-                manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH, classPathManifest.toString());\n-                manifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS, DevModeMain.class.getName());\n-                out.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n-                manifest.write(out);\n-\n-                out.putNextEntry(new ZipEntry(DevModeMain.DEV_MODE_CONTEXT));\n-                ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n-                try (ObjectOutputStream obj = new ObjectOutputStream(new DataOutputStream(bytes))) {\n-                    obj.writeObject(context);\n-                }\n-                out.write(bytes.toByteArray());\n+        //we also want to add the maven plugin jar to the class path\n+        //this allows us to just directly use classes, without messing around copying them", "originalCommit": "4207ba025c88ea6a220df3735ea24639fa7ef163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNTk5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/12911#discussion_r511515999", "bodyText": "Ah, right, thanks. It's apparently been there before, I'll fix it.", "author": "aloubyansky", "createdAt": "2020-10-24T21:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxMTQxMA=="}], "type": "inlineReview"}, {"oid": "6dda6d1fc6524782ed46b7209799ab0f6335c27a", "url": "https://github.com/quarkusio/quarkus/commit/6dda6d1fc6524782ed46b7209799ab0f6335c27a", "message": "Common dev mode launcher API for Maven and Gradle", "committedDate": "2020-10-24T21:31:18Z", "type": "commit"}, {"oid": "6dda6d1fc6524782ed46b7209799ab0f6335c27a", "url": "https://github.com/quarkusio/quarkus/commit/6dda6d1fc6524782ed46b7209799ab0f6335c27a", "message": "Common dev mode launcher API for Maven and Gradle", "committedDate": "2020-10-24T21:31:18Z", "type": "forcePushed"}]}