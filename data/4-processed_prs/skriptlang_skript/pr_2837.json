{"pr_number": 2837, "pr_title": "Add Persistent Data Expression and Condition", "pr_createdAt": "2020-02-29T23:51:02Z", "pr_url": "https://github.com/SkriptLang/Skript/pull/2837", "timeline": [{"oid": "ca73fe40b10722792b5a9324873f8234767e26ce", "url": "https://github.com/SkriptLang/Skript/commit/ca73fe40b10722792b5a9324873f8234767e26ce", "message": "First Pass", "committedDate": "2020-02-29T23:42:44Z", "type": "commit"}, {"oid": "846d6f438f85730a72de24b24e5bb27cd0869015", "url": "https://github.com/SkriptLang/Skript/commit/846d6f438f85730a72de24b24e5bb27cd0869015", "message": "Add version checks", "committedDate": "2020-02-29T23:47:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2NDUzMQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r386064531", "bodyText": "docs should state that 1.14+ is required\nsame thing for ExprPersistentData", "author": "ShaneBeee", "createdAt": "2020-02-29T23:57:55Z", "path": "src/main/java/ch/njol/skript/conditions/CondHasPersistentData.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * This file is part of Skript.\n+ *\n+ * Skript is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Skript is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.conditions;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.conditions.base.PropertyCondition;\n+import ch.njol.skript.conditions.base.PropertyCondition.PropertyType;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.Condition;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.SkriptParser;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.util.Kleenean;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.event.Event;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+@Name(\"Has Persistent Data\")\n+@Description(\"Checks whether a persistent data holder has the specified value.\")\n+@Examples(\"if player has persistent data \\\"epic\\\":\")\n+@Since(\"INSERT VERSION\")\n+public class CondHasPersistentData extends Condition {", "originalCommit": "846d6f438f85730a72de24b24e5bb27cd0869015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2NDczNw==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r386064737", "bodyText": "This fails on versions that PersistentDataHolder is not available.", "author": "ShaneBeee", "createdAt": "2020-03-01T00:02:17Z", "path": "src/main/java/ch/njol/skript/classes/data/BukkitClasses.java", "diffHunk": "@@ -1719,6 +1720,13 @@ public String getVariableNamePattern() {\n \t\t\t\t\t})\n \t\t\t\t\t.serializer(new EnumSerializer<>(Cat.Type.class)));\n \t\t}\n+\n+\t\tClasses.registerClass(new ClassInfo<>(PersistentDataHolder.class, \"persistentdataholder\")", "originalCommit": "846d6f438f85730a72de24b24e5bb27cd0869015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2NTM4Nw==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r386065387", "bodyText": "Forgot about the class info... woops", "author": "APickledWalrus", "createdAt": "2020-03-01T00:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2NDczNw=="}], "type": "inlineReview"}, {"oid": "0340bb480f7439b8917cd150dbba165cf72396ac", "url": "https://github.com/SkriptLang/Skript/commit/0340bb480f7439b8917cd150dbba165cf72396ac", "message": "Fix issues", "committedDate": "2020-03-01T00:25:24Z", "type": "commit"}, {"oid": "0efdab5499a6d4fa38fb1ba236a8ea57d64db882", "url": "https://github.com/SkriptLang/Skript/commit/0efdab5499a6d4fa38fb1ba236a8ea57d64db882", "message": "More Fixes\n\n- Make it work with items and valid blocks\n- Add test\n- Add to documentation", "committedDate": "2020-03-01T17:19:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNDAzNA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r405514034", "bodyText": "how come the argument is called complex?", "author": "Pikachu920", "createdAt": "2020-04-08T13:13:38Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.BlockStateMeta;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.log.SkriptLogger;\n+\n+/**\n+ * @author APickledWalrus\n+ * 29th February, 2020\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Boolean> BOOLEAN = new PersistentDataUtils().new BooleanDataType();\n+\n+\tprivate final static PersistentDataType<?,?>[] types = new PersistentDataType<?,?>[]{\n+\t\tPersistentDataType.STRING,\n+\t\tPersistentDataType.LONG,\n+\t\tPersistentDataType.DOUBLE,\n+\t\tBOOLEAN\n+\t};\n+\n+\t/**\n+\t * @return All {@linkplain PersistentDataType}s usable within Skript.\n+\t */\n+\tpublic static PersistentDataType<?,?>[] getTypes() {\n+\t\treturn types;\n+\t}\n+\n+\t/**\n+\t * To make PersistentData work well with Skript, the holder is not limited to just {@linkplain PersistentDataHolder}s.\n+\t * A holder can also be a {@linkplain Block} or an {@linkplain ItemType}.\n+\t * This gets the actual holder from those types.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tpublic static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * This returns the value from the holder's persistent data container.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @return The value, or null if it was not found.\n+\t * @see PersistentDataUtils#getActualHolder(Object)\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static Object get(Object holder, String name) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn null;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\t\tObject get = null;\n+\n+\t\t// Try to guess the key type.\n+\t\tfor (PersistentDataType<?,?> type : types) {\n+\t\t\ttry {\n+\t\t\t\tget = realHolder.getPersistentDataContainer().get(key, type);\n+\t\t\t\tif (get != null)\n+\t\t\t\t\tbreak;\n+\t\t\t} catch (IllegalArgumentException e) {\n+\t\t\t\t// This is thrown if a value exists under the key, but can't be accessed using the given type\n+\t\t\t}\n+\t\t}\n+\t\treturn get;\n+\n+\t}\n+\n+\t/**\n+\t * Used to set persistent data. This is essentially for cleanliness in element files.\n+\t * @param holder The PersistentDataHolder {@linkplain PersistentDataHolder}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @param value The value of the persistent data.\n+\t * @return Whether the persistent data was set.\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn false;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\n+\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\tif (value instanceof Boolean) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, BOOLEAN, (Boolean) value);\n+\t\t} else if (value instanceof String) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.STRING, (String) value);\n+\t\t} else if (value instanceof Long) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.LONG, (Long) value);\n+\t\t} else if (value instanceof Double) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.DOUBLE, (Double) value);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t// This properly stores the data on ItemTypes and TileStates\n+\t\tif (holder instanceof ItemType) {\n+\t\t\t((ItemType) holder).setItemMeta((ItemMeta) realHolder);\n+\t\t} else if (realHolder instanceof TileState) {\n+\t\t\t((TileState) realHolder).update();\n+\t\t}\n+\n+\t\treturn true;\n+\n+\t}\n+\n+\t/**\n+\t * Removes a value from the persistent data container of the given holder.\n+\t * @param holder The PersistentDataHolder {@linkplain PersistentDataHolder}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\tpublic static boolean remove(Object holder, String name) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn false;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\t\tif (PersistentDataUtils.get(holder, name) == null)\n+\t\t\treturn false;\n+\t\trealHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t// This properly stores the data on ItemTypes and TileStates\n+\t\tif (holder instanceof ItemType) {\n+\t\t\t((ItemType) holder).setItemMeta((ItemMeta) realHolder);\n+\t\t} else if (realHolder instanceof TileState) {\n+\t\t\t((TileState) realHolder).update();\n+\t\t}\n+\n+\t\treturn true;\n+\n+\t}\n+\n+\n+\t/*\n+\t * Custom PersistentDataTypes\n+\t */\n+\n+\t/**\n+\t * Boolean type for {@linkplain PersistentDataType}.\n+\t * 1 = true, 0 = false\n+\t */\n+\tpublic class BooleanDataType implements PersistentDataType<byte[], Boolean> {\n+\n+\t\t@Override\n+\t\tpublic Class<byte[]> getPrimitiveType() {\n+\t\t\treturn byte[].class;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<Boolean> getComplexType() {\n+\t\t\treturn Boolean.class;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic byte[] toPrimitive(Boolean complex, PersistentDataAdapterContext context) {\n+\t\t\treturn new byte[]{(byte) (complex ? 1 : 0)};", "originalCommit": "0efdab5499a6d4fa38fb1ba236a8ea57d64db882", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNDM5MA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r405514390", "bodyText": "why a byte array? couldn't it be just a byte?", "author": "Pikachu920", "createdAt": "2020-04-08T13:14:07Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.BlockStateMeta;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.log.SkriptLogger;\n+\n+/**\n+ * @author APickledWalrus\n+ * 29th February, 2020\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Boolean> BOOLEAN = new PersistentDataUtils().new BooleanDataType();\n+\n+\tprivate final static PersistentDataType<?,?>[] types = new PersistentDataType<?,?>[]{\n+\t\tPersistentDataType.STRING,\n+\t\tPersistentDataType.LONG,\n+\t\tPersistentDataType.DOUBLE,\n+\t\tBOOLEAN\n+\t};\n+\n+\t/**\n+\t * @return All {@linkplain PersistentDataType}s usable within Skript.\n+\t */\n+\tpublic static PersistentDataType<?,?>[] getTypes() {\n+\t\treturn types;\n+\t}\n+\n+\t/**\n+\t * To make PersistentData work well with Skript, the holder is not limited to just {@linkplain PersistentDataHolder}s.\n+\t * A holder can also be a {@linkplain Block} or an {@linkplain ItemType}.\n+\t * This gets the actual holder from those types.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tpublic static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * This returns the value from the holder's persistent data container.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @return The value, or null if it was not found.\n+\t * @see PersistentDataUtils#getActualHolder(Object)\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static Object get(Object holder, String name) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn null;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\t\tObject get = null;\n+\n+\t\t// Try to guess the key type.\n+\t\tfor (PersistentDataType<?,?> type : types) {\n+\t\t\ttry {\n+\t\t\t\tget = realHolder.getPersistentDataContainer().get(key, type);\n+\t\t\t\tif (get != null)\n+\t\t\t\t\tbreak;\n+\t\t\t} catch (IllegalArgumentException e) {\n+\t\t\t\t// This is thrown if a value exists under the key, but can't be accessed using the given type\n+\t\t\t}\n+\t\t}\n+\t\treturn get;\n+\n+\t}\n+\n+\t/**\n+\t * Used to set persistent data. This is essentially for cleanliness in element files.\n+\t * @param holder The PersistentDataHolder {@linkplain PersistentDataHolder}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @param value The value of the persistent data.\n+\t * @return Whether the persistent data was set.\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn false;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\n+\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\tif (value instanceof Boolean) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, BOOLEAN, (Boolean) value);\n+\t\t} else if (value instanceof String) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.STRING, (String) value);\n+\t\t} else if (value instanceof Long) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.LONG, (Long) value);\n+\t\t} else if (value instanceof Double) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.DOUBLE, (Double) value);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t// This properly stores the data on ItemTypes and TileStates\n+\t\tif (holder instanceof ItemType) {\n+\t\t\t((ItemType) holder).setItemMeta((ItemMeta) realHolder);\n+\t\t} else if (realHolder instanceof TileState) {\n+\t\t\t((TileState) realHolder).update();\n+\t\t}\n+\n+\t\treturn true;\n+\n+\t}\n+\n+\t/**\n+\t * Removes a value from the persistent data container of the given holder.\n+\t * @param holder The PersistentDataHolder {@linkplain PersistentDataHolder}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\tpublic static boolean remove(Object holder, String name) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn false;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\t\tif (PersistentDataUtils.get(holder, name) == null)\n+\t\t\treturn false;\n+\t\trealHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t// This properly stores the data on ItemTypes and TileStates\n+\t\tif (holder instanceof ItemType) {\n+\t\t\t((ItemType) holder).setItemMeta((ItemMeta) realHolder);\n+\t\t} else if (realHolder instanceof TileState) {\n+\t\t\t((TileState) realHolder).update();\n+\t\t}\n+\n+\t\treturn true;\n+\n+\t}\n+\n+\n+\t/*\n+\t * Custom PersistentDataTypes\n+\t */\n+\n+\t/**\n+\t * Boolean type for {@linkplain PersistentDataType}.\n+\t * 1 = true, 0 = false\n+\t */\n+\tpublic class BooleanDataType implements PersistentDataType<byte[], Boolean> {", "originalCommit": "0efdab5499a6d4fa38fb1ba236a8ea57d64db882", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNjkwMw==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r405516903", "bodyText": "you support any ClassInfo with a registered serializer instead by utilizing Skript's already existing serialization system.", "author": "Pikachu920", "createdAt": "2020-04-08T13:17:49Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.BlockStateMeta;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.log.SkriptLogger;\n+\n+/**\n+ * @author APickledWalrus\n+ * 29th February, 2020\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Boolean> BOOLEAN = new PersistentDataUtils().new BooleanDataType();\n+\n+\tprivate final static PersistentDataType<?,?>[] types = new PersistentDataType<?,?>[]{", "originalCommit": "0efdab5499a6d4fa38fb1ba236a8ea57d64db882", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwMDQ5OA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r415900498", "bodyText": "I'm not 100% sure on what you mean. Do you mean having a ClassInfo type?", "author": "APickledWalrus", "createdAt": "2020-04-27T15:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNjkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyNTQwMA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r416625400", "bodyText": "Skript/src/main/java/ch/njol/skript/registrations/Classes.java\n    \n    \n         Line 677\n      in\n      3573260\n    \n    \n    \n    \n\n        \n          \n           public static SerializedVariable.Value serialize(@Nullable Object o) { \n        \n    \n  \n\n\nyou can use this method to support serialization of any Object with an associated serialized ClassData rather than just a couple types", "author": "Pikachu920", "createdAt": "2020-04-28T13:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNjkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNzY5OQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r405517699", "bodyText": "should be a static class", "author": "Pikachu920", "createdAt": "2020-04-08T13:18:51Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.BlockStateMeta;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.log.SkriptLogger;\n+\n+/**\n+ * @author APickledWalrus\n+ * 29th February, 2020\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Boolean> BOOLEAN = new PersistentDataUtils().new BooleanDataType();\n+\n+\tprivate final static PersistentDataType<?,?>[] types = new PersistentDataType<?,?>[]{\n+\t\tPersistentDataType.STRING,\n+\t\tPersistentDataType.LONG,\n+\t\tPersistentDataType.DOUBLE,\n+\t\tBOOLEAN\n+\t};\n+\n+\t/**\n+\t * @return All {@linkplain PersistentDataType}s usable within Skript.\n+\t */\n+\tpublic static PersistentDataType<?,?>[] getTypes() {\n+\t\treturn types;\n+\t}\n+\n+\t/**\n+\t * To make PersistentData work well with Skript, the holder is not limited to just {@linkplain PersistentDataHolder}s.\n+\t * A holder can also be a {@linkplain Block} or an {@linkplain ItemType}.\n+\t * This gets the actual holder from those types.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tpublic static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * This returns the value from the holder's persistent data container.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @return The value, or null if it was not found.\n+\t * @see PersistentDataUtils#getActualHolder(Object)\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static Object get(Object holder, String name) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn null;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\t\tObject get = null;\n+\n+\t\t// Try to guess the key type.\n+\t\tfor (PersistentDataType<?,?> type : types) {\n+\t\t\ttry {\n+\t\t\t\tget = realHolder.getPersistentDataContainer().get(key, type);\n+\t\t\t\tif (get != null)\n+\t\t\t\t\tbreak;\n+\t\t\t} catch (IllegalArgumentException e) {\n+\t\t\t\t// This is thrown if a value exists under the key, but can't be accessed using the given type\n+\t\t\t}\n+\t\t}\n+\t\treturn get;\n+\n+\t}\n+\n+\t/**\n+\t * Used to set persistent data. This is essentially for cleanliness in element files.\n+\t * @param holder The PersistentDataHolder {@linkplain PersistentDataHolder}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @param value The value of the persistent data.\n+\t * @return Whether the persistent data was set.\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn false;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\n+\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\tif (value instanceof Boolean) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, BOOLEAN, (Boolean) value);\n+\t\t} else if (value instanceof String) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.STRING, (String) value);\n+\t\t} else if (value instanceof Long) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.LONG, (Long) value);\n+\t\t} else if (value instanceof Double) {\n+\t\t\trealHolder.getPersistentDataContainer().set(key, PersistentDataType.DOUBLE, (Double) value);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t// This properly stores the data on ItemTypes and TileStates\n+\t\tif (holder instanceof ItemType) {\n+\t\t\t((ItemType) holder).setItemMeta((ItemMeta) realHolder);\n+\t\t} else if (realHolder instanceof TileState) {\n+\t\t\t((TileState) realHolder).update();\n+\t\t}\n+\n+\t\treturn true;\n+\n+\t}\n+\n+\t/**\n+\t * Removes a value from the persistent data container of the given holder.\n+\t * @param holder The PersistentDataHolder {@linkplain PersistentDataHolder}.\n+\t * @param name The {@linkplain NamespacedKey} name.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\tpublic static boolean remove(Object holder, String name) {\n+\n+\t\tPersistentDataHolder realHolder = getActualHolder(holder);\n+\t\tif (realHolder == null)\n+\t\t\treturn false;\n+\n+\t\tNamespacedKey key = new NamespacedKey(Skript.getInstance(), name);\n+\t\tif (PersistentDataUtils.get(holder, name) == null)\n+\t\t\treturn false;\n+\t\trealHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t// This properly stores the data on ItemTypes and TileStates\n+\t\tif (holder instanceof ItemType) {\n+\t\t\t((ItemType) holder).setItemMeta((ItemMeta) realHolder);\n+\t\t} else if (realHolder instanceof TileState) {\n+\t\t\t((TileState) realHolder).update();\n+\t\t}\n+\n+\t\treturn true;\n+\n+\t}\n+\n+\n+\t/*\n+\t * Custom PersistentDataTypes\n+\t */\n+\n+\t/**\n+\t * Boolean type for {@linkplain PersistentDataType}.\n+\t * 1 = true, 0 = false\n+\t */\n+\tpublic class BooleanDataType implements PersistentDataType<byte[], Boolean> {", "originalCommit": "0efdab5499a6d4fa38fb1ba236a8ea57d64db882", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxODIyNw==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r405518227", "bodyText": "once BooleanDataType is a static class it can be instantiated without an instance of the util class.\nwon't be necessary if this ends up getting converted to skript's serialization system instead.", "author": "Pikachu920", "createdAt": "2020-04-08T13:19:36Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.BlockStateMeta;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.log.SkriptLogger;\n+\n+/**\n+ * @author APickledWalrus\n+ * 29th February, 2020\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Boolean> BOOLEAN = new PersistentDataUtils().new BooleanDataType();", "originalCommit": "0efdab5499a6d4fa38fb1ba236a8ea57d64db882", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fee6369f9535e049caf5f3064fca408d8923f8ee", "url": "https://github.com/SkriptLang/Skript/commit/fee6369f9535e049caf5f3064fca408d8923f8ee", "message": "Merge branch 'master' into APickledWalrus-persistent-data", "committedDate": "2020-04-29T00:42:09Z", "type": "commit"}, {"oid": "c8f63cce050c89d69f93fa5c7fe36dffc9b60be9", "url": "https://github.com/SkriptLang/Skript/commit/c8f63cce050c89d69f93fa5c7fe36dffc9b60be9", "message": "Merge branch 'master' into APickledWalrus-persistent-data", "committedDate": "2020-05-12T19:05:43Z", "type": "commit"}, {"oid": "60f6f022144f72226ca59e348fddcd2db91980ce", "url": "https://github.com/SkriptLang/Skript/commit/60f6f022144f72226ca59e348fddcd2db91980ce", "message": "Improve PersistentDataType & Make Variable Change", "committedDate": "2020-05-12T19:32:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNTQzMQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r424015431", "bodyText": "instead of copying the pattern, why not just catch the exception thrown by the NamespacedKey constructor", "author": "Pikachu920", "createdAt": "2020-05-12T20:32:08Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.BlockStateMeta;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SKRIPT_TYPE = new SkriptDataType();\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(@Nullable Object holder) {\n+\t\tif (holder == null) {\n+\t\t\treturn null;\n+\t\t} else if (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * From:\n+\t * https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit/browse/src/main/java/org/bukkit/NamespacedKey.java#33\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\tprivate static final Pattern VALID_KEY = Pattern.compile(\"[a-z0-9/._-]+\");\n+\n+\tprivate static boolean isValidKey(String key) {", "originalCommit": "60f6f022144f72226ca59e348fddcd2db91980ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNDIxMg==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r424024212", "bodyText": "What do you think about it following this order:\nget/set/etc methods:\nmethod to get the namespaced key\ndo replacement stuff\ntry to construct namespaced key\nreturn the key if it's valid - if it isn't valid, catch the exception, print console warning, return null", "author": "APickledWalrus", "createdAt": "2020-05-12T20:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNTQzMQ=="}], "type": "inlineReview"}, {"oid": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "url": "https://github.com/SkriptLang/Skript/commit/e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "message": "List Support\n\ntook some time but it's here!\nreview is definitely needed.", "committedDate": "2020-05-19T04:43:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM0MjI0OA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427342248", "bodyText": "no need for the error, that's what docs are for", "author": "Pikachu920", "createdAt": "2020-05-19T14:23:32Z", "path": "src/main/java/ch/njol/skript/conditions/CondHasPersistentData.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * This file is part of Skript.\n+ *\n+ * Skript is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Skript is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+\n+package ch.njol.skript.conditions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.conditions.base.PropertyCondition;\n+import ch.njol.skript.conditions.base.PropertyCondition.PropertyType;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.Condition;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.util.Kleenean;\n+\n+@Name(\"Has Persistent Data\")\n+@Description({\"Checks whether a persistent data holder has the specified value.\",\n+\t\t\t\"This condition will return true if the value also exists under metadata.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\"})\n+@Examples(\"if player has persistent data \\\"epic\\\":\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@Since(\"INSERT VERSION\")\n+public class CondHasPersistentData extends Condition {\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerCondition(CondHasPersistentData.class,\n+\t\t\t\t\t\"%persistentdataholders/itemtypes/blocks% (has|have) persistent data [(value|tag)[s]] %objects%\",\n+\t\t\t\t\t\"%persistentdataholders/itemtypes/blocks% (doesn't|does not|do not|don't) have persistent data [(value|tag)[s]] %objects%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"null\")\n+\tprivate Expression<Object> holders;\n+\t@SuppressWarnings(\"null\")\n+\tprivate Expression<Object> varExpression;\n+\n+\t@SuppressWarnings(\"null\")\n+\tprivate Variable<?>[] variables;\n+\n+\t@Override\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tList<Variable<?>> vars = new ArrayList<>();\n+\t\tExpressionList<?> exprList = exprs[1] instanceof ExpressionList ? (ExpressionList<?>) exprs[1] : new ExpressionList<>(new Expression<?>[]{exprs[1]}, Object.class, false);\n+\t\tfor (Expression<?> expr : exprList.getExpressions()) {\n+\t\t\tif (expr instanceof Variable<?>) {\n+\t\t\t\tVariable<?> v = (Variable<?>) expr;\n+\t\t\t\tif (v.isLocal()) {\n+\t\t\t\t\tSkript.error(\"Using local variables in Persistent Data is not supported.\"\n+\t\t\t\t\t\t\t\t+ \" If you are trying to set a value temporarily, consider using Metadata\", ErrorQuality.SEMANTIC_ERROR\n+\t\t\t\t\t);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvars.add(v);\n+\t\t\t}\n+\t\t}\n+\t\tif (!vars.isEmpty()) {\n+\t\t\tsetNegated(matchedPattern == 1);\n+\t\t\tvariables = vars.toArray(new Variable<?>[0]);\n+\t\t\tvarExpression = (Expression<Object>) exprs[1];\n+\t\t\tholders = (Expression<Object>) exprs[0];\n+\t\t\treturn true;\n+\t\t}\n+\t\tSkript.error(\"Persistent Data values are formatted as variables (e.g. \\\"persistent data value {isAdmin}\\\")\" , ErrorQuality.SEMANTIC_ERROR);", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM0Nzc4MQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427347781", "bodyText": "gotta error if it isn't a variable otherwise persistent data {x}, player and 1 is valid", "author": "Pikachu920", "createdAt": "2020-05-19T14:29:38Z", "path": "src/main/java/ch/njol/skript/conditions/CondHasPersistentData.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * This file is part of Skript.\n+ *\n+ * Skript is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Skript is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+\n+package ch.njol.skript.conditions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.conditions.base.PropertyCondition;\n+import ch.njol.skript.conditions.base.PropertyCondition.PropertyType;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.Condition;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.util.Kleenean;\n+\n+@Name(\"Has Persistent Data\")\n+@Description({\"Checks whether a persistent data holder has the specified value.\",\n+\t\t\t\"This condition will return true if the value also exists under metadata.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\"})\n+@Examples(\"if player has persistent data \\\"epic\\\":\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@Since(\"INSERT VERSION\")\n+public class CondHasPersistentData extends Condition {\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerCondition(CondHasPersistentData.class,\n+\t\t\t\t\t\"%persistentdataholders/itemtypes/blocks% (has|have) persistent data [(value|tag)[s]] %objects%\",\n+\t\t\t\t\t\"%persistentdataholders/itemtypes/blocks% (doesn't|does not|do not|don't) have persistent data [(value|tag)[s]] %objects%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"null\")\n+\tprivate Expression<Object> holders;\n+\t@SuppressWarnings(\"null\")\n+\tprivate Expression<Object> varExpression;\n+\n+\t@SuppressWarnings(\"null\")\n+\tprivate Variable<?>[] variables;\n+\n+\t@Override\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tList<Variable<?>> vars = new ArrayList<>();\n+\t\tExpressionList<?> exprList = exprs[1] instanceof ExpressionList ? (ExpressionList<?>) exprs[1] : new ExpressionList<>(new Expression<?>[]{exprs[1]}, Object.class, false);\n+\t\tfor (Expression<?> expr : exprList.getExpressions()) {\n+\t\t\tif (expr instanceof Variable<?>) {\n+\t\t\t\tVariable<?> v = (Variable<?>) expr;\n+\t\t\t\tif (v.isLocal()) {\n+\t\t\t\t\tSkript.error(\"Using local variables in Persistent Data is not supported.\"\n+\t\t\t\t\t\t\t\t+ \" If you are trying to set a value temporarily, consider using Metadata\", ErrorQuality.SEMANTIC_ERROR\n+\t\t\t\t\t);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1NTcyMA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427355720", "bodyText": "you don't need to capitalize Persistent Data and Metadata", "author": "Pikachu920", "createdAt": "2020-05-19T14:39:30Z", "path": "src/main/java/ch/njol/skript/conditions/CondHasPersistentData.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * This file is part of Skript.\n+ *\n+ * Skript is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Skript is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+\n+package ch.njol.skript.conditions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.conditions.base.PropertyCondition;\n+import ch.njol.skript.conditions.base.PropertyCondition.PropertyType;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.Condition;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.util.Kleenean;\n+\n+@Name(\"Has Persistent Data\")\n+@Description({\"Checks whether a persistent data holder has the specified value.\",\n+\t\t\t\"This condition will return true if the value also exists under metadata.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\"})\n+@Examples(\"if player has persistent data \\\"epic\\\":\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@Since(\"INSERT VERSION\")\n+public class CondHasPersistentData extends Condition {\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerCondition(CondHasPersistentData.class,\n+\t\t\t\t\t\"%persistentdataholders/itemtypes/blocks% (has|have) persistent data [(value|tag)[s]] %objects%\",\n+\t\t\t\t\t\"%persistentdataholders/itemtypes/blocks% (doesn't|does not|do not|don't) have persistent data [(value|tag)[s]] %objects%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"null\")\n+\tprivate Expression<Object> holders;\n+\t@SuppressWarnings(\"null\")\n+\tprivate Expression<Object> varExpression;\n+\n+\t@SuppressWarnings(\"null\")\n+\tprivate Variable<?>[] variables;\n+\n+\t@Override\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tList<Variable<?>> vars = new ArrayList<>();\n+\t\tExpressionList<?> exprList = exprs[1] instanceof ExpressionList ? (ExpressionList<?>) exprs[1] : new ExpressionList<>(new Expression<?>[]{exprs[1]}, Object.class, false);\n+\t\tfor (Expression<?> expr : exprList.getExpressions()) {\n+\t\t\tif (expr instanceof Variable<?>) {\n+\t\t\t\tVariable<?> v = (Variable<?>) expr;\n+\t\t\t\tif (v.isLocal()) {\n+\t\t\t\t\tSkript.error(\"Using local variables in Persistent Data is not supported.\"", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1ODY0MQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427358641", "bodyText": "you don't really need to store variables separately, you can just use the array ExpressionList#getExpressions gives you after you ensure it only contains vars", "author": "Pikachu920", "createdAt": "2020-05-19T14:42:49Z", "path": "src/main/java/ch/njol/skript/conditions/CondHasPersistentData.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * This file is part of Skript.\n+ *\n+ * Skript is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Skript is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+\n+package ch.njol.skript.conditions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.conditions.base.PropertyCondition;\n+import ch.njol.skript.conditions.base.PropertyCondition.PropertyType;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.Condition;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.util.Kleenean;\n+\n+@Name(\"Has Persistent Data\")\n+@Description({\"Checks whether a persistent data holder has the specified value.\",\n+\t\t\t\"This condition will return true if the value also exists under metadata.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\"})\n+@Examples(\"if player has persistent data \\\"epic\\\":\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@Since(\"INSERT VERSION\")\n+public class CondHasPersistentData extends Condition {\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerCondition(CondHasPersistentData.class,\n+\t\t\t\t\t\"%persistentdataholders/itemtypes/blocks% (has|have) persistent data [(value|tag)[s]] %objects%\",\n+\t\t\t\t\t\"%persistentdataholders/itemtypes/blocks% (doesn't|does not|do not|don't) have persistent data [(value|tag)[s]] %objects%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"null\")\n+\tprivate Expression<Object> holders;\n+\t@SuppressWarnings(\"null\")\n+\tprivate Expression<Object> varExpression;\n+\n+\t@SuppressWarnings(\"null\")\n+\tprivate Variable<?>[] variables;\n+\n+\t@Override\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tList<Variable<?>> vars = new ArrayList<>();\n+\t\tExpressionList<?> exprList = exprs[1] instanceof ExpressionList ? (ExpressionList<?>) exprs[1] : new ExpressionList<>(new Expression<?>[]{exprs[1]}, Object.class, false);\n+\t\tfor (Expression<?> expr : exprList.getExpressions()) {\n+\t\t\tif (expr instanceof Variable<?>) {\n+\t\t\t\tVariable<?> v = (Variable<?>) expr;\n+\t\t\t\tif (v.isLocal()) {\n+\t\t\t\t\tSkript.error(\"Using local variables in Persistent Data is not supported.\"\n+\t\t\t\t\t\t\t\t+ \" If you are trying to set a value temporarily, consider using Metadata\", ErrorQuality.SEMANTIC_ERROR\n+\t\t\t\t\t);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvars.add(v);\n+\t\t\t}\n+\t\t}\n+\t\tif (!vars.isEmpty()) {\n+\t\t\tsetNegated(matchedPattern == 1);\n+\t\t\tvariables = vars.toArray(new Variable<?>[0]);", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NDIwNg==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427364206", "bodyText": "you could use Variable.SEPARATOR here instead", "author": "Pikachu920", "createdAt": "2020-05-19T14:49:56Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tmHolder.setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes a key/value from the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given key can't be found in the holder's PersistentDataContainer, this method will try to\n+\t * find it under the holder's Metadata if possible. If a value is found, then it will be removed.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean remove(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NTI4OQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427365289", "bodyText": "just use the field where you need it, it's no worth storing it a second time. if anything you could use a static import but those aren't anywhere in skript besides tests so I don't think those should be used", "author": "Pikachu920", "createdAt": "2020-05-19T14:51:10Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NjMxMA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427366310", "bodyText": "any instance of :: in your code should just be Variable.Separator - also, are colons not valid in keys?", "author": "Pikachu920", "createdAt": "2020-05-19T14:52:31Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2ODUxNQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427368515", "bodyText": "i wonder if it's viable to use the base64 of the index as the key instead, that way any key would be valid and scripters wouldn't have to worry about invalid chars", "author": "Pikachu920", "createdAt": "2020-05-19T14:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NjMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MTU2Nw==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427541567", "bodyText": "I forgot to change that part and will do. Unfortunately there aren\u2019t a lot of characters that are valid.", "author": "APickledWalrus", "createdAt": "2020-05-19T19:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NjMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0NDcwNw==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427544707", "bodyText": "are all of these? ABCDEFGHIJKLMNOPQRSTUVWXYZ, abcdefghijklmnopqrstuvwxyz, 0123456789, +/=", "author": "Pikachu920", "createdAt": "2020-05-19T19:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NjMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1MTUwNg==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427551506", "bodyText": "a-z 0-9 / . _ -\nThose are the valid characters for a key. The key is converted to all lowercase though.\nSource if you want to check it out:\nhttps://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit/browse/src/main/java/org/bukkit/NamespacedKey.java", "author": "APickledWalrus", "createdAt": "2020-05-19T19:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NjMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3MTI0OA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427371248", "bodyText": "can you just put these classes in their own file?", "author": "Pikachu920", "createdAt": "2020-05-19T14:58:37Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tmHolder.setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes a key/value from the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given key can't be found in the holder's PersistentDataContainer, this method will try to\n+\t * find it under the holder's Metadata if possible. If a value is found, then it will be removed.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean remove(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tif (values == null)\n+\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (!values.isEmpty()) { // Has values may be able to remove\n+\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\treturn true;\n+\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\tif (!values.containsKey(index))\n+\t\t\t\t\t\treturn false;\n+\n+\t\t\t\t\tvalues.remove(index);\n+\t\t\t\t\tif (values.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t} else { // The map is empty, so we should check Metadata\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\t\tif (!mHolder.hasMetadata(keyName))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\t\tif (!mMap.containsKey(index))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmMap.remove(index);\n+\t\t\t\t\t\tif (mMap.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) {\n+\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t\t\t// This is to update the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to remove Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tif (mHolder.hasMetadata(name)) {\n+\t\t\t\t\tmHolder.removeMetadata(name, Skript.getInstance());\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Whether or not the holder has a value under the key.\n+\t * <b>Note:</b> If the holder doesn't have this value in its PersistentDataContainer, then the holder's metadata will\n+\t * instead be checked. If a value is found under metadata, then this method will return true.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return True if the user has the key and false if they do not (or if a problem occurred e.g invalid holder, name).\n+\t */\n+\tpublic static boolean has(Object holder, String name) {\n+\t\t// Run the get method because of how much needs to be checked/done (avoid code repetition)\n+\t\tfor (Object object : get(holder, name)) {\n+\t\t\tif (object != null)\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/*\n+\t * Allow PersistentData to work with all Skript types that can be serialized.\n+\t */\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for single variables.\n+\t * The {@link NamespacedKey}'s key should be the variable's name.\n+\t * {hello} -> \"hello\" and the {@link Value} is the variable's serialized value.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class SingleVariableType implements PersistentDataType<byte[], Value> {", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3MTY2MQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427371661", "bodyText": "constructor isn't needed, every class has a no-arg constructor by default", "author": "Pikachu920", "createdAt": "2020-05-19T14:59:10Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tmHolder.setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes a key/value from the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given key can't be found in the holder's PersistentDataContainer, this method will try to\n+\t * find it under the holder's Metadata if possible. If a value is found, then it will be removed.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean remove(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tif (values == null)\n+\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (!values.isEmpty()) { // Has values may be able to remove\n+\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\treturn true;\n+\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\tif (!values.containsKey(index))\n+\t\t\t\t\t\treturn false;\n+\n+\t\t\t\t\tvalues.remove(index);\n+\t\t\t\t\tif (values.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t} else { // The map is empty, so we should check Metadata\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\t\tif (!mHolder.hasMetadata(keyName))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\t\tif (!mMap.containsKey(index))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmMap.remove(index);\n+\t\t\t\t\t\tif (mMap.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) {\n+\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t\t\t// This is to update the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to remove Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tif (mHolder.hasMetadata(name)) {\n+\t\t\t\t\tmHolder.removeMetadata(name, Skript.getInstance());\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Whether or not the holder has a value under the key.\n+\t * <b>Note:</b> If the holder doesn't have this value in its PersistentDataContainer, then the holder's metadata will\n+\t * instead be checked. If a value is found under metadata, then this method will return true.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return True if the user has the key and false if they do not (or if a problem occurred e.g invalid holder, name).\n+\t */\n+\tpublic static boolean has(Object holder, String name) {\n+\t\t// Run the get method because of how much needs to be checked/done (avoid code repetition)\n+\t\tfor (Object object : get(holder, name)) {\n+\t\t\tif (object != null)\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/*\n+\t * Allow PersistentData to work with all Skript types that can be serialized.\n+\t */\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for single variables.\n+\t * The {@link NamespacedKey}'s key should be the variable's name.\n+\t * {hello} -> \"hello\" and the {@link Value} is the variable's serialized value.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class SingleVariableType implements PersistentDataType<byte[], Value> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;\n+\n+\t\tpublic SingleVariableType() {}", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM4MjMxNA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427382314", "bodyText": "what about a name like totalLength instead of allocate", "author": "Pikachu920", "createdAt": "2020-05-19T15:13:10Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tmHolder.setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes a key/value from the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given key can't be found in the holder's PersistentDataContainer, this method will try to\n+\t * find it under the holder's Metadata if possible. If a value is found, then it will be removed.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean remove(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tif (values == null)\n+\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (!values.isEmpty()) { // Has values may be able to remove\n+\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\treturn true;\n+\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\tif (!values.containsKey(index))\n+\t\t\t\t\t\treturn false;\n+\n+\t\t\t\t\tvalues.remove(index);\n+\t\t\t\t\tif (values.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t} else { // The map is empty, so we should check Metadata\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\t\tif (!mHolder.hasMetadata(keyName))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\t\tif (!mMap.containsKey(index))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmMap.remove(index);\n+\t\t\t\t\t\tif (mMap.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) {\n+\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t\t\t// This is to update the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to remove Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tif (mHolder.hasMetadata(name)) {\n+\t\t\t\t\tmHolder.removeMetadata(name, Skript.getInstance());\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Whether or not the holder has a value under the key.\n+\t * <b>Note:</b> If the holder doesn't have this value in its PersistentDataContainer, then the holder's metadata will\n+\t * instead be checked. If a value is found under metadata, then this method will return true.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return True if the user has the key and false if they do not (or if a problem occurred e.g invalid holder, name).\n+\t */\n+\tpublic static boolean has(Object holder, String name) {\n+\t\t// Run the get method because of how much needs to be checked/done (avoid code repetition)\n+\t\tfor (Object object : get(holder, name)) {\n+\t\t\tif (object != null)\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/*\n+\t * Allow PersistentData to work with all Skript types that can be serialized.\n+\t */\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for single variables.\n+\t * The {@link NamespacedKey}'s key should be the variable's name.\n+\t * {hello} -> \"hello\" and the {@link Value} is the variable's serialized value.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class SingleVariableType implements PersistentDataType<byte[], Value> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;\n+\n+\t\tpublic SingleVariableType() {}\n+\n+\t\t@Override\n+\t\tpublic Class<byte[]> getPrimitiveType() {\n+\t\t\treturn byte[].class;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<Value> getComplexType() {\n+\t\t\treturn Value.class;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"null\")\n+\t\t@Override\n+\t\tpublic byte[] toPrimitive(Value complex, PersistentDataAdapterContext context) {\n+\t\t\tbyte[] type = complex.type.getBytes(STRING_CHARSET);\n+\n+\t\t\tByteBuffer bb = ByteBuffer.allocate(INT_LENGTH + type.length + complex.data.length);\n+\t\t\tbb.putInt(type.length);\n+\t\t\tbb.put(type);\n+\t\t\tbb.put(complex.data);\n+\n+\t\t\treturn bb.array();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Value fromPrimitive(byte[] primitive, PersistentDataAdapterContext context) {\n+\t\t\tByteBuffer bb = ByteBuffer.wrap(primitive);\n+\n+\t\t\tint typeLength = bb.getInt();\n+\t\t\tbyte[] typeBytes = new byte[typeLength];\n+\t\t\tbb.get(typeBytes, 0, typeLength);\n+\t\t\tString type = new String(typeBytes, STRING_CHARSET);\n+\n+\t\t\tbyte[] data = new byte[bb.remaining()];\n+\t\t\tbb.get(data);\n+\n+\t\t\treturn new Value(type, data);\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for list variables.\n+\t * In this case, a list variable is any variable containing \"::\" (the separator)\n+\t * The map's key is the variable's index and the map's value is the index's value.\n+\t * With this {@link PersistentDataType}, the NamespacedKey's key is the rest of the list variable.\n+\t * e.g. {one::two::three} where \"one//two\" would be the {@link NamespacedKey}'s key and \"three\" the key for the map.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class ListVariableType implements PersistentDataType<byte[], Map<String, Value>> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;\n+\n+\t\tpublic ListVariableType() {}\n+\n+\t\t@Override\n+\t\tpublic Class<byte[]> getPrimitiveType() {\n+\t\t\treturn byte[].class;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\t@Override\n+\t\tpublic Class<Map<String, Value>> getComplexType() {\n+\t\t\treturn (Class<Map<String, Value>>) (Class<?>) Map.class;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"null\")\n+\t\t@Override\n+\t\tpublic byte[] toPrimitive(Map<String, Value> complex, PersistentDataAdapterContext context) {\n+\t\t\tint allocate = 0;", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM4NzU0NA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427387544", "bodyText": "how about the name SERIALIZED_CHARSET instead to describe more what it's used for", "author": "Pikachu920", "createdAt": "2020-05-19T15:20:01Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tmHolder.setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes a key/value from the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given key can't be found in the holder's PersistentDataContainer, this method will try to\n+\t * find it under the holder's Metadata if possible. If a value is found, then it will be removed.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean remove(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tif (values == null)\n+\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (!values.isEmpty()) { // Has values may be able to remove\n+\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\treturn true;\n+\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\tif (!values.containsKey(index))\n+\t\t\t\t\t\treturn false;\n+\n+\t\t\t\t\tvalues.remove(index);\n+\t\t\t\t\tif (values.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t} else { // The map is empty, so we should check Metadata\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\t\tif (!mHolder.hasMetadata(keyName))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\t\tif (!mMap.containsKey(index))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmMap.remove(index);\n+\t\t\t\t\t\tif (mMap.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) {\n+\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t\t\t// This is to update the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to remove Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tif (mHolder.hasMetadata(name)) {\n+\t\t\t\t\tmHolder.removeMetadata(name, Skript.getInstance());\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Whether or not the holder has a value under the key.\n+\t * <b>Note:</b> If the holder doesn't have this value in its PersistentDataContainer, then the holder's metadata will\n+\t * instead be checked. If a value is found under metadata, then this method will return true.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return True if the user has the key and false if they do not (or if a problem occurred e.g invalid holder, name).\n+\t */\n+\tpublic static boolean has(Object holder, String name) {\n+\t\t// Run the get method because of how much needs to be checked/done (avoid code repetition)\n+\t\tfor (Object object : get(holder, name)) {\n+\t\t\tif (object != null)\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/*\n+\t * Allow PersistentData to work with all Skript types that can be serialized.\n+\t */\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for single variables.\n+\t * The {@link NamespacedKey}'s key should be the variable's name.\n+\t * {hello} -> \"hello\" and the {@link Value} is the variable's serialized value.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class SingleVariableType implements PersistentDataType<byte[], Value> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;\n+\n+\t\tpublic SingleVariableType() {}\n+\n+\t\t@Override\n+\t\tpublic Class<byte[]> getPrimitiveType() {\n+\t\t\treturn byte[].class;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<Value> getComplexType() {\n+\t\t\treturn Value.class;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"null\")\n+\t\t@Override\n+\t\tpublic byte[] toPrimitive(Value complex, PersistentDataAdapterContext context) {\n+\t\t\tbyte[] type = complex.type.getBytes(STRING_CHARSET);\n+\n+\t\t\tByteBuffer bb = ByteBuffer.allocate(INT_LENGTH + type.length + complex.data.length);\n+\t\t\tbb.putInt(type.length);\n+\t\t\tbb.put(type);\n+\t\t\tbb.put(complex.data);\n+\n+\t\t\treturn bb.array();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Value fromPrimitive(byte[] primitive, PersistentDataAdapterContext context) {\n+\t\t\tByteBuffer bb = ByteBuffer.wrap(primitive);\n+\n+\t\t\tint typeLength = bb.getInt();\n+\t\t\tbyte[] typeBytes = new byte[typeLength];\n+\t\t\tbb.get(typeBytes, 0, typeLength);\n+\t\t\tString type = new String(typeBytes, STRING_CHARSET);\n+\n+\t\t\tbyte[] data = new byte[bb.remaining()];\n+\t\t\tbb.get(data);\n+\n+\t\t\treturn new Value(type, data);\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for list variables.\n+\t * In this case, a list variable is any variable containing \"::\" (the separator)\n+\t * The map's key is the variable's index and the map's value is the index's value.\n+\t * With this {@link PersistentDataType}, the NamespacedKey's key is the rest of the list variable.\n+\t * e.g. {one::two::three} where \"one//two\" would be the {@link NamespacedKey}'s key and \"three\" the key for the map.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class ListVariableType implements PersistentDataType<byte[], Map<String, Value>> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwMTQyMg==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427401422", "bodyText": "you could use entrySet and then wouldn't need the get call", "author": "Pikachu920", "createdAt": "2020-05-19T15:38:57Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tmHolder.setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes a key/value from the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given key can't be found in the holder's PersistentDataContainer, this method will try to\n+\t * find it under the holder's Metadata if possible. If a value is found, then it will be removed.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean remove(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tif (values == null)\n+\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (!values.isEmpty()) { // Has values may be able to remove\n+\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\treturn true;\n+\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\tif (!values.containsKey(index))\n+\t\t\t\t\t\treturn false;\n+\n+\t\t\t\t\tvalues.remove(index);\n+\t\t\t\t\tif (values.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t} else { // The map is empty, so we should check Metadata\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\t\tif (!mHolder.hasMetadata(keyName))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\t\tif (!mMap.containsKey(index))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmMap.remove(index);\n+\t\t\t\t\t\tif (mMap.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) {\n+\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t\t\t// This is to update the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to remove Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tif (mHolder.hasMetadata(name)) {\n+\t\t\t\t\tmHolder.removeMetadata(name, Skript.getInstance());\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Whether or not the holder has a value under the key.\n+\t * <b>Note:</b> If the holder doesn't have this value in its PersistentDataContainer, then the holder's metadata will\n+\t * instead be checked. If a value is found under metadata, then this method will return true.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return True if the user has the key and false if they do not (or if a problem occurred e.g invalid holder, name).\n+\t */\n+\tpublic static boolean has(Object holder, String name) {\n+\t\t// Run the get method because of how much needs to be checked/done (avoid code repetition)\n+\t\tfor (Object object : get(holder, name)) {\n+\t\t\tif (object != null)\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/*\n+\t * Allow PersistentData to work with all Skript types that can be serialized.\n+\t */\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for single variables.\n+\t * The {@link NamespacedKey}'s key should be the variable's name.\n+\t * {hello} -> \"hello\" and the {@link Value} is the variable's serialized value.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class SingleVariableType implements PersistentDataType<byte[], Value> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;\n+\n+\t\tpublic SingleVariableType() {}\n+\n+\t\t@Override\n+\t\tpublic Class<byte[]> getPrimitiveType() {\n+\t\t\treturn byte[].class;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<Value> getComplexType() {\n+\t\t\treturn Value.class;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"null\")\n+\t\t@Override\n+\t\tpublic byte[] toPrimitive(Value complex, PersistentDataAdapterContext context) {\n+\t\t\tbyte[] type = complex.type.getBytes(STRING_CHARSET);\n+\n+\t\t\tByteBuffer bb = ByteBuffer.allocate(INT_LENGTH + type.length + complex.data.length);\n+\t\t\tbb.putInt(type.length);\n+\t\t\tbb.put(type);\n+\t\t\tbb.put(complex.data);\n+\n+\t\t\treturn bb.array();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Value fromPrimitive(byte[] primitive, PersistentDataAdapterContext context) {\n+\t\t\tByteBuffer bb = ByteBuffer.wrap(primitive);\n+\n+\t\t\tint typeLength = bb.getInt();\n+\t\t\tbyte[] typeBytes = new byte[typeLength];\n+\t\t\tbb.get(typeBytes, 0, typeLength);\n+\t\t\tString type = new String(typeBytes, STRING_CHARSET);\n+\n+\t\t\tbyte[] data = new byte[bb.remaining()];\n+\t\t\tbb.get(data);\n+\n+\t\t\treturn new Value(type, data);\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for list variables.\n+\t * In this case, a list variable is any variable containing \"::\" (the separator)\n+\t * The map's key is the variable's index and the map's value is the index's value.\n+\t * With this {@link PersistentDataType}, the NamespacedKey's key is the rest of the list variable.\n+\t * e.g. {one::two::three} where \"one//two\" would be the {@link NamespacedKey}'s key and \"three\" the key for the map.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class ListVariableType implements PersistentDataType<byte[], Map<String, Value>> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;\n+\n+\t\tpublic ListVariableType() {}\n+\n+\t\t@Override\n+\t\tpublic Class<byte[]> getPrimitiveType() {\n+\t\t\treturn byte[].class;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\t@Override\n+\t\tpublic Class<Map<String, Value>> getComplexType() {\n+\t\t\treturn (Class<Map<String, Value>>) (Class<?>) Map.class;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"null\")\n+\t\t@Override\n+\t\tpublic byte[] toPrimitive(Map<String, Value> complex, PersistentDataAdapterContext context) {\n+\t\t\tint allocate = 0;\n+\n+\t\t\tfor (String index : complex.keySet()) {", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyODU4OA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427428588", "bodyText": "no constructor needed", "author": "Pikachu920", "createdAt": "2020-05-19T16:16:50Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tmHolder.setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes a key/value from the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given key can't be found in the holder's PersistentDataContainer, this method will try to\n+\t * find it under the holder's Metadata if possible. If a value is found, then it will be removed.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean remove(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tif (values == null)\n+\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (!values.isEmpty()) { // Has values may be able to remove\n+\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\treturn true;\n+\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\tif (!values.containsKey(index))\n+\t\t\t\t\t\treturn false;\n+\n+\t\t\t\t\tvalues.remove(index);\n+\t\t\t\t\tif (values.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t} else { // The map is empty, so we should check Metadata\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\t\tif (!mHolder.hasMetadata(keyName))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\t\tif (!mMap.containsKey(index))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmMap.remove(index);\n+\t\t\t\t\t\tif (mMap.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) {\n+\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t\t\t// This is to update the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to remove Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tif (mHolder.hasMetadata(name)) {\n+\t\t\t\t\tmHolder.removeMetadata(name, Skript.getInstance());\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Whether or not the holder has a value under the key.\n+\t * <b>Note:</b> If the holder doesn't have this value in its PersistentDataContainer, then the holder's metadata will\n+\t * instead be checked. If a value is found under metadata, then this method will return true.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return True if the user has the key and false if they do not (or if a problem occurred e.g invalid holder, name).\n+\t */\n+\tpublic static boolean has(Object holder, String name) {\n+\t\t// Run the get method because of how much needs to be checked/done (avoid code repetition)\n+\t\tfor (Object object : get(holder, name)) {\n+\t\t\tif (object != null)\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/*\n+\t * Allow PersistentData to work with all Skript types that can be serialized.\n+\t */\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for single variables.\n+\t * The {@link NamespacedKey}'s key should be the variable's name.\n+\t * {hello} -> \"hello\" and the {@link Value} is the variable's serialized value.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class SingleVariableType implements PersistentDataType<byte[], Value> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;\n+\n+\t\tpublic SingleVariableType() {}\n+\n+\t\t@Override\n+\t\tpublic Class<byte[]> getPrimitiveType() {\n+\t\t\treturn byte[].class;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<Value> getComplexType() {\n+\t\t\treturn Value.class;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"null\")\n+\t\t@Override\n+\t\tpublic byte[] toPrimitive(Value complex, PersistentDataAdapterContext context) {\n+\t\t\tbyte[] type = complex.type.getBytes(STRING_CHARSET);\n+\n+\t\t\tByteBuffer bb = ByteBuffer.allocate(INT_LENGTH + type.length + complex.data.length);\n+\t\t\tbb.putInt(type.length);\n+\t\t\tbb.put(type);\n+\t\t\tbb.put(complex.data);\n+\n+\t\t\treturn bb.array();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Value fromPrimitive(byte[] primitive, PersistentDataAdapterContext context) {\n+\t\t\tByteBuffer bb = ByteBuffer.wrap(primitive);\n+\n+\t\t\tint typeLength = bb.getInt();\n+\t\t\tbyte[] typeBytes = new byte[typeLength];\n+\t\t\tbb.get(typeBytes, 0, typeLength);\n+\t\t\tString type = new String(typeBytes, STRING_CHARSET);\n+\n+\t\t\tbyte[] data = new byte[bb.remaining()];\n+\t\t\tbb.get(data);\n+\n+\t\t\treturn new Value(type, data);\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * This {@link PersistentDataType} is used for list variables.\n+\t * In this case, a list variable is any variable containing \"::\" (the separator)\n+\t * The map's key is the variable's index and the map's value is the index's value.\n+\t * With this {@link PersistentDataType}, the NamespacedKey's key is the rest of the list variable.\n+\t * e.g. {one::two::three} where \"one//two\" would be the {@link NamespacedKey}'s key and \"three\" the key for the map.\n+\t * @see PersistentDataUtils#getNamespacedKey(String) for conversion details.\n+\t */\n+\tprivate final static class ListVariableType implements PersistentDataType<byte[], Map<String, Value>> {\n+\n+\t\t// This is how many bytes an int is.\n+\t\tprivate final int INT_LENGTH = 4;\n+\n+\t\t// Charset used for converting bytes and Strings\n+\t\t@SuppressWarnings(\"null\")\n+\t\tprivate final Charset STRING_CHARSET = StandardCharsets.UTF_8;\n+\n+\t\tpublic ListVariableType() {}", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTExNA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427469114", "bodyText": "no need for the warning", "author": "Pikachu920", "createdAt": "2020-05-19T17:19:37Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTY3MA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427471670", "bodyText": "no need for the warning", "author": "Pikachu920", "createdAt": "2020-05-19T17:23:32Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNTk4OQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427535989", "bodyText": "it would probably be more efficient and more clear to have a method that gets the key name for an index, and then just use PersistentDataContainer#has so it doesn't have to deserialize just to check for existence", "author": "Pikachu920", "createdAt": "2020-05-19T19:08:23Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * @author APickledWalrus\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariableType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariableType();\n+\n+\tprivate final static String SEPARATOR = Variable.SEPARATOR;\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Tries to convert the input String to a valid key name.\n+\t * This method <b>will</b> print a warning to the console if the name couldn't be fully converted.\n+\t * @param name The name to convert\n+\t * @return The converted name or null if the name couldn't be fully converted.\n+\t * @see NamespacedKey\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\tif (name.contains(\" \"))\n+\t\t\tname = name.replace(\" \", \"\");\n+\t\tif (name.contains(\"::\"))\n+\t\t\tname = name.replace(\"::\", \"//\");\n+\t\ttry {\n+\t\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t\t} catch (IllegalArgumentException e) {\n+\t\t\tSkript.warning(\"Invalid characters were used in a Persistent Data variable, or the name is longer than 256 characters.\"\n+\t\t\t\t+ \" If you are trying to get it, it will not be returned.\"\n+\t\t\t\t+ \" If you are trying to change it, it will not be returned.\"\n+\t\t\t\t+ \" Valid characters are letters, numbers, periods, underscores, hyphens, and forward slashes.\"\n+\t\t\t\t+ \" If you believe this is a Skript issue, please create an issue with the appropriate details on GitHub.\"\n+\t\t\t);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Get, Set, Remove, Has Methods\n+\t */\n+\n+\t/**\n+\t * Gets a value from a key in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the object can't be found under PersistentData, the holder's metadata for\n+\t * the same value will be checked if possible. If a value is found, that value will be returned instead.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return The value, or null if it was not found.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static Object[] get(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn new Object[0];\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (values != null) {\n+\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\tfor (Value value : values.values())\n+\t\t\t\t\t\treturnObjects.add(Classes.deserialize(value.type, value.data));\n+\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t} else { // Return just one value\n+\t\t\t\t\tValue value = values.get(index);\n+\t\t\t\t\tif (value != null)\n+\t\t\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Try to get as Metadata instead.\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\treturn new Object[0];\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Return all values\n+\t\t\t\t\t\tList<Object> returnObjects = new ArrayList<>();\n+\t\t\t\t\t\tfor (Object object : mMap.values())\n+\t\t\t\t\t\t\treturnObjects.add(object);\n+\t\t\t\t\t\treturn returnObjects.toArray();\n+\t\t\t\t\t} else { // Return just one\n+\t\t\t\t\t\treturn new Object[]{mMap.get(index)};\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn new Object[0];\n+\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn new Object[]{Classes.deserialize(value.type, value.data)};\n+\n+\t\t\t// Try to get as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tList<MetadataValue> values = mHolder.getMetadata(name);\n+\t\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\t\treturn new Object[]{mv.value()};\n+\t\t\t\t}\n+\t\t\t\treturn new Object[0];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Object[0];\n+\t}\n+\n+\t/**\n+\t * Sets a key to a value in the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given value can't be serialized by Skript, the value will be set in Metadata instead if possible.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @param value The value for the key to be set to.\n+\t * @return Whether the key was set to the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean set(Object holder, String name, Object value) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tif (serialized != null) {  // Can be serialized, set as PersistentData\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\t\tif (values == null)\n+\t\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tvalues.clear();\n+\t\t\t\t\tvalues.put(\"1\", serialized);\n+\t\t\t\t} else {\n+\t\t\t\t\tvalues.put(index, serialized);\n+\t\t\t\t}\n+\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (mMap == null)\n+\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\t\t\t\tif (index.equals(\"*\")) { // Clear map and set value\n+\t\t\t\t\tmMap.clear();\n+\t\t\t\t\tmMap.put(\"1\", value);\n+\t\t\t\t} else {\n+\t\t\t\t\tmMap.put(index, value);\n+\t\t\t\t}\n+\n+\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tif (serialized != null) { // Can be serialized, set as PersistentData\n+\t\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\t\tif (key == null)\n+\t\t\t\t\treturn false;\n+\n+\t\t\t\t// Attempt to set the value based on the possible PersistentDataTypes.\n+\t\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to set as Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tSkript.warning(\"The variable '{\" + name + \"}' is not able to be set under Persistent Data.\"\n+\t\t\t\t\t\t+ \" However, the value will instead be set under Metadata and will clear on a restart.\"\n+\t\t\t\t\t\t+ \" It will still be accessible through the Persistent Data expression too.\"\n+\t\t\t\t);\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tmHolder.setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes a key/value from the holder's PersistentDataContainer.\n+\t * <b>Note:</b> If the given key can't be found in the holder's PersistentDataContainer, this method will try to\n+\t * find it under the holder's Metadata if possible. If a value is found, then it will be removed.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return Whether the value was removed. False returns mean that the holder does not have the value.\n+\t */\n+\t@SuppressWarnings({\"unchecked\", \"null\"})\n+\tpublic static boolean remove(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn false;\n+\n+\t\tif (name.contains(\"::\")) { // Check if it's a list variable.\n+\t\t\tString keyName = name.substring(0, name.lastIndexOf(SEPARATOR));\n+\t\t\tNamespacedKey key = getNamespacedKey(keyName);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tMap<String, Value> values = actualHolder.getPersistentDataContainer().get(key, LIST_VARIABLE_TYPE);\n+\t\t\tif (values == null)\n+\t\t\t\tvalues = new HashMap<>();\n+\n+\t\t\tString index = name.substring(name.lastIndexOf(SEPARATOR) + SEPARATOR.length());\n+\n+\t\t\tif (!values.isEmpty()) { // Has values may be able to remove\n+\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\treturn true;\n+\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\tif (!values.containsKey(index))\n+\t\t\t\t\t\treturn false;\n+\n+\t\t\t\t\tvalues.remove(index);\n+\t\t\t\t\tif (values.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tactualHolder.getPersistentDataContainer().set(key, LIST_VARIABLE_TYPE, values);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t} else { // The map is empty, so we should check Metadata\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\n+\t\t\t\tList<MetadataValue> mValues = mHolder.getMetadata(keyName);\n+\n+\t\t\t\tif (!mValues.isEmpty()) {\n+\n+\t\t\t\t\tMap<String, Object> mMap = null;\n+\t\t\t\t\tfor (MetadataValue mv : mValues) { // Get the latest value set by Skript\n+\t\t\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) {\n+\t\t\t\t\t\t\tmMap = (Map<String, Object>) mv.value();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (mMap == null)\n+\t\t\t\t\t\tmMap = new HashMap<>();\n+\n+\t\t\t\t\tif (index.equals(\"*\")) { // Remove ALL values\n+\t\t\t\t\t\tif (!mHolder.hasMetadata(keyName))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t} else { // Remove value and set again\n+\t\t\t\t\t\tif (!mMap.containsKey(index))\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tmMap.remove(index);\n+\t\t\t\t\t\tif (mMap.isEmpty()) { // No point in storing an empty map. The last value was removed.\n+\t\t\t\t\t\t\tmHolder.removeMetadata(keyName, Skript.getInstance());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmHolder.setMetadata(keyName, new FixedMetadataValue(Skript.getInstance(), mMap));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn false;\n+\n+\t\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) {\n+\t\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t\t\t// This is to update the data on the ItemType or TileState\n+\t\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t\t}\n+\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\t// Try to remove Metadata instead\n+\t\t\tif (holder instanceof Metadatable) {\n+\t\t\t\tMetadatable mHolder = (Metadatable) holder;\n+\t\t\t\tif (mHolder.hasMetadata(name)) {\n+\t\t\t\t\tmHolder.removeMetadata(name, Skript.getInstance());\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Whether or not the holder has a value under the key.\n+\t * <b>Note:</b> If the holder doesn't have this value in its PersistentDataContainer, then the holder's metadata will\n+\t * instead be checked. If a value is found under metadata, then this method will return true.\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @param name The key name in the PersistentDataContainer. It will go through conversion to replace some characters.\n+\t * @return True if the user has the key and false if they do not (or if a problem occurred e.g invalid holder, name).\n+\t */\n+\tpublic static boolean has(Object holder, String name) {\n+\t\t// Run the get method because of how much needs to be checked/done (avoid code repetition)\n+\t\tfor (Object object : get(holder, name)) {", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk4MDE3NQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427980175", "bodyText": "this class has all the same with storing the variables as the condition: just use the ExpressionList, and you should error if they use something that isn't  a varaible", "author": "Pikachu920", "createdAt": "2020-05-20T12:47:29Z", "path": "src/main/java/ch/njol/skript/expressions/ExprPersistentData.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.expressions;\n+\n+import java.util.List;\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.classes.Changer.ChangeMode;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.ExpressionType;\n+import ch.njol.skript.lang.util.SimpleExpression;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.registrations.Converters;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.skript.util.Utils;\n+import ch.njol.util.Kleenean;\n+import ch.njol.util.coll.CollectionUtils;\n+\n+@Name(\"Persistent Data\")\n+@Description({\"Persistent data is a way of storing data on entities, items, and some blocks.\",\n+\t\t\t\"Unlike metadata, it is not affected by server restarts.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\",\n+\t\t\t\"If the new value when changing a persistent data value can't be persistently stored in variables\",\n+\t\t\t\"(meaning it gets cleared on a restart), it will be set in metadata and a warning will be printed in console.\",\n+\t\t\t\"That value will still be accessible through this expression, but it will be from metadata.\"\n+\t\t\t})\n+@Examples(\"set persistent data value {isAdmin} of player to true\")\n+@Since(\"INSERT VERSION\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@SuppressWarnings({\"null\", \"unchecked\"})\n+public class ExprPersistentData<T> extends SimpleExpression<T> {\n+\n+\t// TODO implement other changer types: add, remove, remove all\n+\t// TODO you should be able to set multiple values - e.g. set persistent data {test::*} of player to \"me1\" and \"me2\"\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerExpression(ExprPersistentData.class, Object.class, ExpressionType.PROPERTY,\n+\t\t\t\t\t\"persistent data [(value|tag)[s]] %objects% of %persistentdataholders/itemtypes/blocks%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Persistent data is meant to <i>look</i> like variables\n+\t * <br>e.g. <b>set persistent data value {isCool} of player to true</b>\n+\t * <br>e.g. <b>set {_value} to persistent data value {isCool} of player</b>\n+\t */\n+\tprivate Variable<?>[] variables = new Variable<?>[]{};\n+\n+\tprivate Expression<Object> varExpression;\n+\tprivate Expression<Object> holders;\n+\n+\tprivate ExprPersistentData<?> source;\n+\tprivate Class<T> superType;\n+\n+\tpublic ExprPersistentData() {\n+\t\tthis(null, (Class<? extends T>) Object.class);\n+\t}\n+\n+\tprivate ExprPersistentData(ExprPersistentData<?> source, Class<? extends T>... types) {\n+\t\tthis.source = source;\n+\t\tif (source != null) {\n+\t\t\tthis.variables = source.variables;\n+\t\t\tthis.holders = source.holders;\n+\t\t}\n+\t\tthis.superType = (Class<T>) Utils.getSuperType(types);\n+\t}\n+\n+\t@Override\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tList<Variable<?>> vars = new ArrayList<>();", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk4MDcwMA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r427980700", "bodyText": "once you return false if it's not a variable, this isEmpty check won't be required anymore", "author": "Pikachu920", "createdAt": "2020-05-20T12:48:14Z", "path": "src/main/java/ch/njol/skript/expressions/ExprPersistentData.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.expressions;\n+\n+import java.util.List;\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.classes.Changer.ChangeMode;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.ExpressionType;\n+import ch.njol.skript.lang.util.SimpleExpression;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.registrations.Converters;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.skript.util.Utils;\n+import ch.njol.util.Kleenean;\n+import ch.njol.util.coll.CollectionUtils;\n+\n+@Name(\"Persistent Data\")\n+@Description({\"Persistent data is a way of storing data on entities, items, and some blocks.\",\n+\t\t\t\"Unlike metadata, it is not affected by server restarts.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\",\n+\t\t\t\"If the new value when changing a persistent data value can't be persistently stored in variables\",\n+\t\t\t\"(meaning it gets cleared on a restart), it will be set in metadata and a warning will be printed in console.\",\n+\t\t\t\"That value will still be accessible through this expression, but it will be from metadata.\"\n+\t\t\t})\n+@Examples(\"set persistent data value {isAdmin} of player to true\")\n+@Since(\"INSERT VERSION\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@SuppressWarnings({\"null\", \"unchecked\"})\n+public class ExprPersistentData<T> extends SimpleExpression<T> {\n+\n+\t// TODO implement other changer types: add, remove, remove all\n+\t// TODO you should be able to set multiple values - e.g. set persistent data {test::*} of player to \"me1\" and \"me2\"\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerExpression(ExprPersistentData.class, Object.class, ExpressionType.PROPERTY,\n+\t\t\t\t\t\"persistent data [(value|tag)[s]] %objects% of %persistentdataholders/itemtypes/blocks%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Persistent data is meant to <i>look</i> like variables\n+\t * <br>e.g. <b>set persistent data value {isCool} of player to true</b>\n+\t * <br>e.g. <b>set {_value} to persistent data value {isCool} of player</b>\n+\t */\n+\tprivate Variable<?>[] variables = new Variable<?>[]{};\n+\n+\tprivate Expression<Object> varExpression;\n+\tprivate Expression<Object> holders;\n+\n+\tprivate ExprPersistentData<?> source;\n+\tprivate Class<T> superType;\n+\n+\tpublic ExprPersistentData() {\n+\t\tthis(null, (Class<? extends T>) Object.class);\n+\t}\n+\n+\tprivate ExprPersistentData(ExprPersistentData<?> source, Class<? extends T>... types) {\n+\t\tthis.source = source;\n+\t\tif (source != null) {\n+\t\t\tthis.variables = source.variables;\n+\t\t\tthis.holders = source.holders;\n+\t\t}\n+\t\tthis.superType = (Class<T>) Utils.getSuperType(types);\n+\t}\n+\n+\t@Override\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tList<Variable<?>> vars = new ArrayList<>();\n+\t\tExpressionList<?> exprList = exprs[0] instanceof ExpressionList ? (ExpressionList<?>) exprs[0] : new ExpressionList<>(new Expression<?>[]{exprs[0]}, Object.class, false);\n+\t\tfor (Expression<?> expr : exprList.getExpressions()) {\n+\t\t\tif (expr instanceof Variable<?>) {\n+\t\t\t\tVariable<?> v = (Variable<?>) expr;\n+\t\t\t\tif (v.isLocal()) {\n+\t\t\t\t\tSkript.error(\"Using local variables in Persistent Data is not supported.\"\n+\t\t\t\t\t\t\t\t+ \" If you are trying to set a value temporarily, consider using Metadata\", ErrorQuality.SEMANTIC_ERROR\n+\t\t\t\t\t);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvars.add(v);\n+\t\t\t}\n+\t\t}\n+\t\tif (!vars.isEmpty()) {", "originalCommit": "e2b92b5ee33ec0481603c4c80b5dee7b17eb512a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f8c0b29dd41fcb7cea3c36b8af6d12b8017bddd6", "url": "https://github.com/SkriptLang/Skript/commit/f8c0b29dd41fcb7cea3c36b8af6d12b8017bddd6", "message": "Refactoring and More Changers and Tests\n\n- The custom persistent data types were moved to their own classes\n- The methods within the utility class have been split up into two categories: single var and list var\n- Two methods were added to get/set the list var map of a user\n- Added changers for add, remove, and remove all\n- The test has been expanded to support the new additions\n- The syntax files had there init methods cleaned up\n- New Javadoc for all methods and classes", "committedDate": "2020-06-30T05:45:47Z", "type": "commit"}, {"oid": "d79fa641a41f6df444c5bdac15ea93fc786e2df5", "url": "https://github.com/SkriptLang/Skript/commit/d79fa641a41f6df444c5bdac15ea93fc786e2df5", "message": "Merge branch 'master' into APickledWalrus-persistent-data", "committedDate": "2020-06-30T05:46:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExMTk2MQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r448111961", "bodyText": "Note to myself: This section needs reworked. varName should have the \"*\" replaced before the holder loop and this should still work even if varMap is null", "author": "APickledWalrus", "createdAt": "2020-07-01T04:43:48Z", "path": "src/main/java/ch/njol/skript/expressions/ExprPersistentData.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.expressions;\n+\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.classes.Changer.ChangeMode;\n+import ch.njol.skript.classes.ClassInfo;\n+import ch.njol.skript.classes.Comparator.Relation;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.ExpressionType;\n+import ch.njol.skript.lang.util.SimpleExpression;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.registrations.Comparators;\n+import ch.njol.skript.registrations.Converters;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.skript.util.Utils;\n+import ch.njol.util.Kleenean;\n+import ch.njol.util.coll.CollectionUtils;\n+\n+@Name(\"Persistent Data\")\n+@Description({\"Persistent data is a way of storing data on entities, items, and some blocks.\",\n+\t\t\t\"Unlike metadata, it is not affected by server restarts.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\",\n+\t\t\t\"If the new value when changing a persistent data value can't be persistently stored in variables\",\n+\t\t\t\"(meaning it gets cleared on a restart), it will be set in metadata and a warning will be printed in console.\",\n+\t\t\t\"That value will still be accessible through this expression, but it will be from metadata.\"\n+\t\t\t})\n+@Examples(\"set persistent data value {isAdmin} of player to true\")\n+@Since(\"INSERT VERSION\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@SuppressWarnings({\"null\", \"unchecked\"})\n+public class ExprPersistentData<T> extends SimpleExpression<T> {\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerExpression(ExprPersistentData.class, Object.class, ExpressionType.PROPERTY,\n+\t\t\t\t\t\"persistent data [(value|tag)[s]] %objects% of %persistentdataholders/itemtypes/blocks%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Persistent data is meant to <i>look</i> like variables\n+\t * <br>e.g. <b>set persistent data value {isCool} of player to true</b>\n+\t * <br>e.g. <b>set {_value} to persistent data value {isCool} of player</b>\n+\t */\n+\n+\tprivate ExpressionList<Variable<?>> variables;\n+\tprivate Expression<Object> holders;\n+\n+\tprivate ExprPersistentData<?> source;\n+\tprivate Class<T> superType;\n+\n+\tpublic ExprPersistentData() {\n+\t\tthis(null, (Class<? extends T>) Object.class);\n+\t}\n+\n+\tprivate ExprPersistentData(ExprPersistentData<?> source, Class<? extends T>... types) {\n+\t\tthis.source = source;\n+\t\tif (source != null) {\n+\t\t\tthis.variables = source.variables;\n+\t\t\tthis.holders = source.holders;\n+\t\t}\n+\t\tthis.superType = (Class<T>) Utils.getSuperType(types);\n+\t}\n+\n+\t@Override\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tExpressionList<?> exprList = exprs[0] instanceof ExpressionList ? (ExpressionList<?>) exprs[0] : new ExpressionList<>(new Expression<?>[]{exprs[0]}, Object.class, false);\n+\t\tfor (Expression<?> expr : exprList.getExpressions()) {\n+\t\t\tif (!(expr instanceof Variable<?>)) { // Input not a variable\n+\t\t\t\tSkript.error(\"Persistent Data values are formatted as variables (e.g. \\\"persistent data value {isAdmin}\\\")\" , ErrorQuality.SEMANTIC_ERROR);\n+\t\t\t\treturn false;\n+\t\t\t} else if (((Variable<?>) expr).isLocal()) { // Input is a variable, but it's local\n+\t\t\t\tSkript.error(\"Using local variables in persistent data is not supported.\"\n+\t\t\t\t\t\t+ \" If you are trying to set a value temporarily, consider using metadata\", ErrorQuality.SEMANTIC_ERROR\n+\t\t\t\t);\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\tvariables = (ExpressionList<Variable<?>>) exprList;\n+\t\tholders = (Expression<Object>) exprs[1];\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Nullable\n+\tpublic T[] get(Event e) {\n+\t\tList<Object> values = new ArrayList<>();\n+\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\tString varName = ((Variable<?>) expr).getName().toString(e);\n+\t\t\tif (varName.contains(Variable.SEPARATOR)) { // It's a list\n+\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\tfor (Object object : PersistentDataUtils.getList(holder, varName))\n+\t\t\t\t\t\tvalues.add(object);\n+\t\t\t\t}\n+\t\t\t} else { // It's a single variable\n+\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\tvalues.add(PersistentDataUtils.getSingle(holder, varName));\n+\t\t\t}\n+\t\t}\n+\t\ttry {\n+\t\t\treturn Converters.convertStrictly(values.toArray(), superType);\n+\t\t} catch (ClassCastException e1) {\n+\t\t\treturn (T[]) Array.newInstance(superType, 0);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\t@Nullable\n+\tpublic Class<?>[] acceptChange(ChangeMode mode) {\n+\t\tif (mode == ChangeMode.RESET)\n+\t\t\treturn null;\n+\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\tif (!((Variable<?>) expr).isList()) {\n+\t\t\t\tif (mode == ChangeMode.REMOVE_ALL)\n+\t\t\t\t\treturn null;\n+\t\t\t\treturn CollectionUtils.array(Object.class);\n+\t\t\t}\n+\t\t}\n+\t\treturn CollectionUtils.array(Object[].class);\n+\t}\n+\n+\t@Override\n+\tpublic void change(Event e, @Nullable Object[] delta, ChangeMode mode) {\n+\t\tif (delta == null && mode != ChangeMode.DELETE)\n+\t\t\treturn;\n+\t\tswitch (mode) {\n+\t\t\tcase SET:\n+\t\t\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\t\t\tVariable<?> var = (Variable<?>) expr;\n+\t\t\t\t\tString varName = var.getName().toString(e);\n+\t\t\t\t\tif (var.isList()) {\n+\t\t\t\t\t\tvarName = varName.replace(\"*\", \"\");\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\t\t\tfor (int i = 1; i <= delta.length; i++) {\n+\t\t\t\t\t\t\t\t// varName + i = var::i (e.g. exampleList::1, exampleList::2, etc.)\n+\t\t\t\t\t\t\t\tPersistentDataUtils.setList(holder, varName + i, delta[i - 1]);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (varName.contains(Variable.SEPARATOR)) { // Specific index of a list\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\t\t\tPersistentDataUtils.setList(holder, varName, delta[0]);\n+\t\t\t\t\t} else { // It's a single variable\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\t\t\tPersistentDataUtils.setSingle(holder, varName, delta[0]);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase DELETE:\n+\t\t\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\t\t\tString varName = ((Variable<?>) expr).getName().toString(e);\n+\t\t\t\t\tif (varName.contains(Variable.SEPARATOR)) { // It's a list\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\t\t\tPersistentDataUtils.removeList(holder, varName);\n+\t\t\t\t\t} else { // It's a single variable\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\t\t\tPersistentDataUtils.removeSingle(holder, varName);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase ADD:\n+\t\t\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\t\t\tVariable<?> var = (Variable<?>) expr;\n+\t\t\t\t\tString varName = var.getName().toString(e);\n+\t\t\t\t\tif (var.isList()) {\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\t\t\tMap<String, Object> varMap = PersistentDataUtils.getListMap(holder, varName);\n+\t\t\t\t\t\t\tif (varMap != null) {", "originalCommit": "d79fa641a41f6df444c5bdac15ea93fc786e2df5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMDE5MQ==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r449000191", "bodyText": "Collections.addAll(values, PDU.getList(holder, varName));", "author": "Pikachu920", "createdAt": "2020-07-02T13:26:26Z", "path": "src/main/java/ch/njol/skript/expressions/ExprPersistentData.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.expressions;\n+\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.classes.Changer.ChangeMode;\n+import ch.njol.skript.classes.ClassInfo;\n+import ch.njol.skript.classes.Comparator.Relation;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.ExpressionType;\n+import ch.njol.skript.lang.util.SimpleExpression;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.registrations.Comparators;\n+import ch.njol.skript.registrations.Converters;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.skript.util.Utils;\n+import ch.njol.util.Kleenean;\n+import ch.njol.util.coll.CollectionUtils;\n+\n+@Name(\"Persistent Data\")\n+@Description({\"Persistent data is a way of storing data on entities, items, and some blocks.\",\n+\t\t\t\"Unlike metadata, it is not affected by server restarts.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\",\n+\t\t\t\"If the new value when changing a persistent data value can't be persistently stored in variables\",\n+\t\t\t\"(meaning it gets cleared on a restart), it will be set in metadata and a warning will be printed in console.\",\n+\t\t\t\"That value will still be accessible through this expression, but it will be from metadata.\"\n+\t\t\t})\n+@Examples(\"set persistent data value {isAdmin} of player to true\")\n+@Since(\"INSERT VERSION\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@SuppressWarnings({\"null\", \"unchecked\"})\n+public class ExprPersistentData<T> extends SimpleExpression<T> {\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerExpression(ExprPersistentData.class, Object.class, ExpressionType.PROPERTY,\n+\t\t\t\t\t\"persistent data [(value|tag)[s]] %objects% of %persistentdataholders/itemtypes/blocks%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Persistent data is meant to <i>look</i> like variables\n+\t * <br>e.g. <b>set persistent data value {isCool} of player to true</b>\n+\t * <br>e.g. <b>set {_value} to persistent data value {isCool} of player</b>\n+\t */\n+\n+\tprivate ExpressionList<Variable<?>> variables;\n+\tprivate Expression<Object> holders;\n+\n+\tprivate ExprPersistentData<?> source;\n+\tprivate Class<T> superType;\n+\n+\tpublic ExprPersistentData() {\n+\t\tthis(null, (Class<? extends T>) Object.class);\n+\t}\n+\n+\tprivate ExprPersistentData(ExprPersistentData<?> source, Class<? extends T>... types) {\n+\t\tthis.source = source;\n+\t\tif (source != null) {\n+\t\t\tthis.variables = source.variables;\n+\t\t\tthis.holders = source.holders;\n+\t\t}\n+\t\tthis.superType = (Class<T>) Utils.getSuperType(types);\n+\t}\n+\n+\t@Override\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tExpressionList<?> exprList = exprs[0] instanceof ExpressionList ? (ExpressionList<?>) exprs[0] : new ExpressionList<>(new Expression<?>[]{exprs[0]}, Object.class, false);\n+\t\tfor (Expression<?> expr : exprList.getExpressions()) {\n+\t\t\tif (!(expr instanceof Variable<?>)) { // Input not a variable\n+\t\t\t\tSkript.error(\"Persistent Data values are formatted as variables (e.g. \\\"persistent data value {isAdmin}\\\")\" , ErrorQuality.SEMANTIC_ERROR);\n+\t\t\t\treturn false;\n+\t\t\t} else if (((Variable<?>) expr).isLocal()) { // Input is a variable, but it's local\n+\t\t\t\tSkript.error(\"Using local variables in persistent data is not supported.\"\n+\t\t\t\t\t\t+ \" If you are trying to set a value temporarily, consider using metadata\", ErrorQuality.SEMANTIC_ERROR\n+\t\t\t\t);\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\tvariables = (ExpressionList<Variable<?>>) exprList;\n+\t\tholders = (Expression<Object>) exprs[1];\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Nullable\n+\tpublic T[] get(Event e) {\n+\t\tList<Object> values = new ArrayList<>();\n+\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\tString varName = ((Variable<?>) expr).getName().toString(e);\n+\t\t\tif (varName.contains(Variable.SEPARATOR)) { // It's a list\n+\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\tfor (Object object : PersistentDataUtils.getList(holder, varName))", "originalCommit": "d79fa641a41f6df444c5bdac15ea93fc786e2df5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxMTA2Mw==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r449011063", "bodyText": "instead of creating a clone, you can use the entryset's iterator and then Iterator#remove to remove without the exception", "author": "Pikachu920", "createdAt": "2020-07-02T13:42:54Z", "path": "src/main/java/ch/njol/skript/expressions/ExprPersistentData.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.expressions;\n+\n+\n+import org.bukkit.event.Event;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.classes.Changer.ChangeMode;\n+import ch.njol.skript.classes.ClassInfo;\n+import ch.njol.skript.classes.Comparator.Relation;\n+import ch.njol.skript.doc.Description;\n+import ch.njol.skript.doc.Examples;\n+import ch.njol.skript.doc.Name;\n+import ch.njol.skript.doc.RequiredPlugins;\n+import ch.njol.skript.doc.Since;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.lang.Expression;\n+import ch.njol.skript.lang.ExpressionList;\n+import ch.njol.skript.lang.ExpressionType;\n+import ch.njol.skript.lang.util.SimpleExpression;\n+import ch.njol.skript.log.ErrorQuality;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.registrations.Comparators;\n+import ch.njol.skript.registrations.Converters;\n+import ch.njol.skript.util.PersistentDataUtils;\n+import ch.njol.skript.util.Utils;\n+import ch.njol.util.Kleenean;\n+import ch.njol.util.coll.CollectionUtils;\n+\n+@Name(\"Persistent Data\")\n+@Description({\"Persistent data is a way of storing data on entities, items, and some blocks.\",\n+\t\t\t\"Unlike metadata, it is not affected by server restarts.\",\n+\t\t\t\"See <a href='classes.html#persistentdataholder'>persistent data holder</a> for a list of all holders.\",\n+\t\t\t\"If the new value when changing a persistent data value can't be persistently stored in variables\",\n+\t\t\t\"(meaning it gets cleared on a restart), it will be set in metadata and a warning will be printed in console.\",\n+\t\t\t\"That value will still be accessible through this expression, but it will be from metadata.\"\n+\t\t\t})\n+@Examples(\"set persistent data value {isAdmin} of player to true\")\n+@Since(\"INSERT VERSION\")\n+@RequiredPlugins(\"1.14 or newer\")\n+@SuppressWarnings({\"null\", \"unchecked\"})\n+public class ExprPersistentData<T> extends SimpleExpression<T> {\n+\n+\tstatic {\n+\t\tif (Skript.isRunningMinecraft(1, 14)) {\n+\t\t\tSkript.registerExpression(ExprPersistentData.class, Object.class, ExpressionType.PROPERTY,\n+\t\t\t\t\t\"persistent data [(value|tag)[s]] %objects% of %persistentdataholders/itemtypes/blocks%\"\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Persistent data is meant to <i>look</i> like variables\n+\t * <br>e.g. <b>set persistent data value {isCool} of player to true</b>\n+\t * <br>e.g. <b>set {_value} to persistent data value {isCool} of player</b>\n+\t */\n+\n+\tprivate ExpressionList<Variable<?>> variables;\n+\tprivate Expression<Object> holders;\n+\n+\tprivate ExprPersistentData<?> source;\n+\tprivate Class<T> superType;\n+\n+\tpublic ExprPersistentData() {\n+\t\tthis(null, (Class<? extends T>) Object.class);\n+\t}\n+\n+\tprivate ExprPersistentData(ExprPersistentData<?> source, Class<? extends T>... types) {\n+\t\tthis.source = source;\n+\t\tif (source != null) {\n+\t\t\tthis.variables = source.variables;\n+\t\t\tthis.holders = source.holders;\n+\t\t}\n+\t\tthis.superType = (Class<T>) Utils.getSuperType(types);\n+\t}\n+\n+\t@Override\n+\tpublic boolean init(Expression<?>[] exprs, int matchedPattern, Kleenean isDelayed, ParseResult parseResult) {\n+\t\tExpressionList<?> exprList = exprs[0] instanceof ExpressionList ? (ExpressionList<?>) exprs[0] : new ExpressionList<>(new Expression<?>[]{exprs[0]}, Object.class, false);\n+\t\tfor (Expression<?> expr : exprList.getExpressions()) {\n+\t\t\tif (!(expr instanceof Variable<?>)) { // Input not a variable\n+\t\t\t\tSkript.error(\"Persistent Data values are formatted as variables (e.g. \\\"persistent data value {isAdmin}\\\")\" , ErrorQuality.SEMANTIC_ERROR);\n+\t\t\t\treturn false;\n+\t\t\t} else if (((Variable<?>) expr).isLocal()) { // Input is a variable, but it's local\n+\t\t\t\tSkript.error(\"Using local variables in persistent data is not supported.\"\n+\t\t\t\t\t\t+ \" If you are trying to set a value temporarily, consider using metadata\", ErrorQuality.SEMANTIC_ERROR\n+\t\t\t\t);\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\tvariables = (ExpressionList<Variable<?>>) exprList;\n+\t\tholders = (Expression<Object>) exprs[1];\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Nullable\n+\tpublic T[] get(Event e) {\n+\t\tList<Object> values = new ArrayList<>();\n+\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\tString varName = ((Variable<?>) expr).getName().toString(e);\n+\t\t\tif (varName.contains(Variable.SEPARATOR)) { // It's a list\n+\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\tfor (Object object : PersistentDataUtils.getList(holder, varName))\n+\t\t\t\t\t\tvalues.add(object);\n+\t\t\t\t}\n+\t\t\t} else { // It's a single variable\n+\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\tvalues.add(PersistentDataUtils.getSingle(holder, varName));\n+\t\t\t}\n+\t\t}\n+\t\ttry {\n+\t\t\treturn Converters.convertStrictly(values.toArray(), superType);\n+\t\t} catch (ClassCastException e1) {\n+\t\t\treturn (T[]) Array.newInstance(superType, 0);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\t@Nullable\n+\tpublic Class<?>[] acceptChange(ChangeMode mode) {\n+\t\tif (mode == ChangeMode.RESET)\n+\t\t\treturn null;\n+\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\tif (!((Variable<?>) expr).isList()) {\n+\t\t\t\tif (mode == ChangeMode.REMOVE_ALL)\n+\t\t\t\t\treturn null;\n+\t\t\t\treturn CollectionUtils.array(Object.class);\n+\t\t\t}\n+\t\t}\n+\t\treturn CollectionUtils.array(Object[].class);\n+\t}\n+\n+\t@Override\n+\tpublic void change(Event e, @Nullable Object[] delta, ChangeMode mode) {\n+\t\tif (delta == null && mode != ChangeMode.DELETE)\n+\t\t\treturn;\n+\t\tswitch (mode) {\n+\t\t\tcase SET:\n+\t\t\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\t\t\tVariable<?> var = (Variable<?>) expr;\n+\t\t\t\t\tString varName = var.getName().toString(e);\n+\t\t\t\t\tif (var.isList()) {\n+\t\t\t\t\t\tvarName = varName.replace(\"*\", \"\");\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\t\t\tfor (int i = 1; i <= delta.length; i++) {\n+\t\t\t\t\t\t\t\t// varName + i = var::i (e.g. exampleList::1, exampleList::2, etc.)\n+\t\t\t\t\t\t\t\tPersistentDataUtils.setList(holder, varName + i, delta[i - 1]);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (varName.contains(Variable.SEPARATOR)) { // Specific index of a list\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\t\t\tPersistentDataUtils.setList(holder, varName, delta[0]);\n+\t\t\t\t\t} else { // It's a single variable\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\t\t\tPersistentDataUtils.setSingle(holder, varName, delta[0]);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase DELETE:\n+\t\t\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\t\t\tString varName = ((Variable<?>) expr).getName().toString(e);\n+\t\t\t\t\tif (varName.contains(Variable.SEPARATOR)) { // It's a list\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\t\t\tPersistentDataUtils.removeList(holder, varName);\n+\t\t\t\t\t} else { // It's a single variable\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e))\n+\t\t\t\t\t\t\tPersistentDataUtils.removeSingle(holder, varName);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase ADD:\n+\t\t\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\t\t\tVariable<?> var = (Variable<?>) expr;\n+\t\t\t\t\tString varName = var.getName().toString(e);\n+\t\t\t\t\tif (var.isList()) {\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\t\t\tMap<String, Object> varMap = PersistentDataUtils.getListMap(holder, varName);\n+\t\t\t\t\t\t\tif (varMap != null) {\n+\t\t\t\t\t\t\t\tvarName = varName.replace(\"*\", \"\");\n+\t\t\t\t\t\t\t\tint start = 1;\n+\t\t\t\t\t\t\t\tfor (Object value : delta) {\n+\t\t\t\t\t\t\t\t\twhile (varMap.containsKey(String.valueOf(start)))\n+\t\t\t\t\t\t\t\t\t\tstart++;\n+\t\t\t\t\t\t\t\t\tPersistentDataUtils.setList(holder, varName + start, value);\n+\t\t\t\t\t\t\t\t\tstart++;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (delta[0] instanceof Number) {\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\t\t\tObject n = PersistentDataUtils.getSingle(holder, varName);\n+\t\t\t\t\t\t\tif (n instanceof Number)\n+\t\t\t\t\t\t\t\tPersistentDataUtils.setSingle(holder, varName, ((Number) n).doubleValue() + ((Number) delta[0]).doubleValue());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase REMOVE:\n+\t\t\tcase REMOVE_ALL:\n+\t\t\t\tfor (Expression<?> expr : variables.getExpressions()) {\n+\t\t\t\t\tVariable<?> var = (Variable<?>) expr;\n+\t\t\t\t\tString varName = var.getName().toString(e);\n+\t\t\t\t\tif (var.isList() || mode == ChangeMode.REMOVE_ALL) {\n+\t\t\t\t\t\tfor (Object holder : holders.getArray(e)) {\n+\t\t\t\t\t\t\tMap<String, Object> varMap = PersistentDataUtils.getListMap(holder, varName);\n+\t\t\t\t\t\t\tint sizeBefore = varMap.size();\n+\t\t\t\t\t\t\tif (varMap != null) {\n+\t\t\t\t\t\t\t\tfor (Object value : delta) {\n+\t\t\t\t\t\t\t\t\t// Create a clone to avoid a ConcurrentModificationException\n+\t\t\t\t\t\t\t\t\tfor (Entry<String, Object> entry : new HashMap<>(varMap).entrySet()) {", "originalCommit": "d79fa641a41f6df444c5bdac15ea93fc786e2df5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzOTgzOA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r449239838", "bodyText": "how come we replace the spaces with nothing? it shouldn't matter if we're b64 encoding it.\nalso maybe we can put the replacement characters in an immutable map and loop it elsewhere in case it's useful for someone else", "author": "Pikachu920", "createdAt": "2020-07-02T20:02:52Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * This class allows persistent data to work easily with Skript.\n+ * In Skript, Persistent Data is formatted like variables.\n+ * This looks like: <b>set persistent data {isAdmin} of player to true</b>\n+ * @author APickledWalrus\n+ * @see SingleVariablePersistentDataType\n+ * @see ListVariablePersistentDataType\n+ * @see ch.njol.skript.expressions.ExprPersistentData\n+ * @see ch.njol.skript.conditions.CondHasPersistentData\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariablePersistentDataType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariablePersistentDataType();\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * This returns a {@link NamespacedKey} from the provided name with Skript as the namespace being used.\n+\t * The name will be encoded in Base64 to make sure the key name is valid.\n+\t * @param name The name to convert\n+\t * @return The created {@link NamespacedKey}\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\t// Encode the name in Base64 to make sure the key name is valid\n+\t\tname = Base64.getEncoder().encodeToString(name.replace(\" \", \"\").getBytes(StandardCharsets.UTF_8)).replace('=', '_').replace('+', '.');", "originalCommit": "d79fa641a41f6df444c5bdac15ea93fc786e2df5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM1MDQ0OA==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r449350448", "bodyText": "why not consolidate getListMap and getList into one? you can always replicate this method with getListMap().values()", "author": "Pikachu920", "createdAt": "2020-07-03T02:49:27Z", "path": "src/main/java/ch/njol/skript/util/PersistentDataUtils.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.util;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.bukkit.NamespacedKey;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.TileState;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.metadata.MetadataValue;\n+import org.bukkit.metadata.Metadatable;\n+import org.bukkit.persistence.PersistentDataAdapterContext;\n+import org.bukkit.persistence.PersistentDataHolder;\n+import org.bukkit.persistence.PersistentDataType;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Variable;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.variables.SerializedVariable.Value;\n+\n+/**\n+ * This class allows persistent data to work easily with Skript.\n+ * In Skript, Persistent Data is formatted like variables.\n+ * This looks like: <b>set persistent data {isAdmin} of player to true</b>\n+ * @author APickledWalrus\n+ * @see SingleVariablePersistentDataType\n+ * @see ListVariablePersistentDataType\n+ * @see ch.njol.skript.expressions.ExprPersistentData\n+ * @see ch.njol.skript.conditions.CondHasPersistentData\n+ */\n+public class PersistentDataUtils {\n+\n+\tprivate final static PersistentDataType<byte[], Value> SINGLE_VARIABLE_TYPE = new SingleVariablePersistentDataType();\n+\tprivate final static PersistentDataType<byte[], Map<String, Value>> LIST_VARIABLE_TYPE = new ListVariablePersistentDataType();\n+\n+\t/*\n+\t * General Utility Methods\n+\t */\n+\n+\t/**\n+\t * For a {@linkplain Block} or an {@linkplain ItemType}, only parts of them are actually a {@linkplain PersistentDataHolder}.\n+\t * This gets the 'actual' holder from those types (e.g. ItemMeta or TileState).\n+\t * @param holder A {@linkplain PersistentDataHolder}, a {@linkplain Block}, or an {@linkplain ItemType}.\n+\t * @return The actual {@linkplain PersistentDataHolder}, or null if the object's actual holder can't be found.\n+\t */\n+\t@Nullable\n+\tprivate static PersistentDataHolder getActualHolder(Object holder) {\n+\t\tif (holder instanceof PersistentDataHolder) {\n+\t\t\treturn (PersistentDataHolder) holder;\n+\t\t} else if (holder instanceof ItemType) {\n+\t\t\treturn ((ItemType) holder).getItemMeta();\n+\t\t} else if (holder instanceof Block) {\n+\t\t\tif (((Block) holder).getState() instanceof TileState)\n+\t\t\t\treturn ((TileState) ((Block) holder).getState());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * This returns a {@link NamespacedKey} from the provided name with Skript as the namespace being used.\n+\t * The name will be encoded in Base64 to make sure the key name is valid.\n+\t * @param name The name to convert\n+\t * @return The created {@link NamespacedKey}\n+\t */\n+\t@SuppressWarnings(\"null\")\n+\t@Nullable\n+\tpublic static NamespacedKey getNamespacedKey(String name) {\n+\t\t// Encode the name in Base64 to make sure the key name is valid\n+\t\tname = Base64.getEncoder().encodeToString(name.replace(\" \", \"\").getBytes(StandardCharsets.UTF_8)).replace('=', '_').replace('+', '.');\n+\t\treturn new NamespacedKey(Skript.getInstance(), name);\n+\t}\n+\n+\t/*\n+\t * Single Variable Modification Methods\n+\t */\n+\n+\t/**\n+\t * Gets the Persistent Data Tag's value of the given single variable name from the given holder.\n+\t * If the value set was not serializable, it was set under Metadata and is retrieved from Metadata here.\n+\t * @param holder The holder of the Persistent Data Tag. See {@linkplain PersistentDataUtils#getActualHolder(Object)}\n+\t * @param name The name of the single variable (e.g. <b>\"myVariable\" from {myVariable}</b>)\n+\t * @return The Persistent Data Tag's value from the holder, or null if: \n+\t * the holder was invalid, the key was invalid, or if a value could not be found.\n+\t * @see PersistentDataUtils#setSingle(Object, String, Object)\n+\t * @see PersistentDataUtils#removeSingle(Object, String)\n+\t */\n+\t@Nullable\n+\tpublic static Object getSingle(Object holder, String name) {\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn null;\n+\n+\t\tif (name.contains(Variable.SEPARATOR)) // This is a list variable..\n+\t\t\treturn null;\n+\n+\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\tif (key == null)\n+\t\t\treturn null;\n+\n+\t\t// We need to check to avoid an IllegalArgumentException\n+\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) {\n+\t\t\tValue value = actualHolder.getPersistentDataContainer().get(key, SINGLE_VARIABLE_TYPE);\n+\t\t\tif (value != null)\n+\t\t\t\treturn Classes.deserialize(value.type, value.data);\n+\t\t}\n+\n+\t\t// Try to get as Metadata instead\n+\t\tif (holder instanceof Metadatable) {\n+\t\t\tList<MetadataValue> values = ((Metadatable) holder).getMetadata(name);\n+\t\t\tfor (MetadataValue mv : values) {\n+\t\t\t\tif (mv.getOwningPlugin() == Skript.getInstance()) // Get the latest value set by Skript\n+\t\t\t\t\treturn mv.value();\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Sets the Persistent Data Tag from the given name and value for the given holder.\n+\t * @param holder The holder of the Persistent Data Tag. See {@linkplain PersistentDataUtils#getActualHolder(Object)}\n+\t * @param name The name of the single variable (e.g. <b>\"myVariable\" from {myVariable}</b>)\n+\t * @param value The value for the Persistent Data Tag to be set to.\n+\t * If this value is not serializable (see {@linkplain Classes#serialize(Object)}), this value will be set under Metadata.\n+\t * @see PersistentDataUtils#getSingle(Object, String)\n+\t * @see PersistentDataUtils#removeSingle(Object, String)\n+\t */\n+\tpublic static void setSingle(Object holder, String name, Object value) {\n+\t\tif (name.contains(Variable.SEPARATOR)) // This is a list variable..\n+\t\t\treturn;\n+\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn;\n+\n+\t\tValue serialized = Classes.serialize(value);\n+\n+\t\tif (serialized != null) { // Can be serialized, set as Persistent Data\n+\t\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\t\tif (key == null)\n+\t\t\t\treturn;\n+\n+\t\t\tactualHolder.getPersistentDataContainer().set(key, SINGLE_VARIABLE_TYPE, serialized);\n+\n+\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t}\n+\t\t} else if (holder instanceof Metadatable) { // Set as Metadata instead\n+\t\t\t((Metadatable) holder).setMetadata(name, new FixedMetadataValue(Skript.getInstance(), value));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the Persistent Data Tag's value for the given holder from the given name and value.\n+\t * This method will check the holder's {@linkplain PersistentDataContainer} and Metadata.\n+\t * @param holder The holder of the Persistent Data Tag. See {@linkplain PersistentDataUtils#getActualHolder(Object)}\n+\t * @param name The name of the single variable (e.g. <b>\"myVariable\" from {myVariable}</b>)\n+\t * @see PersistentDataUtils#getSingle(Object, String)\n+\t * @see PersistentDataUtils#setSingle(Object, String, Object)\n+\t */\n+\tpublic static void removeSingle(Object holder, String name) {\n+\t\tif (name.contains(Variable.SEPARATOR)) // This is a list variable..\n+\t\t\treturn;\n+\n+\t\tPersistentDataHolder actualHolder = getActualHolder(holder);\n+\t\tif (actualHolder == null)\n+\t\t\treturn;\n+\n+\t\tNamespacedKey key = getNamespacedKey(name);\n+\t\tif (key == null)\n+\t\t\treturn;\n+\n+\t\tif (actualHolder.getPersistentDataContainer().has(key, SINGLE_VARIABLE_TYPE)) { // Can be serialized, try to remove Persistent Data\n+\t\t\tactualHolder.getPersistentDataContainer().remove(key);\n+\n+\t\t\t// This is to store the data on the ItemType or TileState\n+\t\t\tif (holder instanceof ItemType) {\n+\t\t\t\t((ItemType) holder).setItemMeta((ItemMeta) actualHolder);\n+\t\t\t} else if (actualHolder instanceof TileState) {\n+\t\t\t\t((TileState) actualHolder).update();\n+\t\t\t}\n+\t\t} else if (holder instanceof Metadatable) { // Try to remove Metadata instead\n+\t\t\t((Metadatable) holder).removeMetadata(name, Skript.getInstance());\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * List Variable Modification Methods\n+\t */\n+\n+\t/**\n+\t * Gets the Persistent Data Tag's value of the given list variable name from the given holder.\n+\t * This method may return a single value, or multiple, depending on the given name.\n+\t * If the value set was not serializable, it was set under Metadata and is retrieved from Metadata here.\n+\t * @param holder The holder of the Persistent Data Tag. See {@linkplain PersistentDataUtils#getActualHolder(Object)}\n+\t * @param name The name of the list variable (e.g. <b>\"myList::*\" from {myList::*}</b>)\n+\t * @return The Persistent Data Tag's value(s) from the holder, or an empty array if: \n+\t * the holder was invalid, the name was invalid, the key was invalid, or if no value(s) could be found.\n+\t * @see PersistentDataUtils#setList(Object, String, Object)\n+\t * @see PersistentDataUtils#removeList(Object, String)\n+\t * @see PersistentDataUtils#getListMap(Object, String)\n+\t */\n+\t@SuppressWarnings({\"null\", \"unchecked\"})\n+\tpublic static Object[] getList(Object holder, String name) {", "originalCommit": "d79fa641a41f6df444c5bdac15ea93fc786e2df5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODUyMw==", "url": "https://github.com/SkriptLang/Skript/pull/2837#discussion_r449678523", "bodyText": "well - not exactly\ngetListMap doesn't accept specific indexes, while getList does\nhowever, there is some some code repetition which could be removed, so I'll make some changes \ud83d\ude04", "author": "APickledWalrus", "createdAt": "2020-07-03T18:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM1MDQ0OA=="}], "type": "inlineReview"}, {"oid": "32692a37e0afc2ce82fb639cfc87352dd949a726", "url": "https://github.com/SkriptLang/Skript/commit/32692a37e0afc2ce82fb639cfc87352dd949a726", "message": "Make some changes & fix issues\n\n- The ADD changer has been reworked:\n    - avoid replacing \"*\" in varName multiple times\n    - can now ADD even when the varMap is null\n- use Collections#addAll instead of looping & adding\n- Removed pointless replacement in B64 conversion\n- Removed null checks for the NamespacedKey (it can't be null anymore)\n- Rework getList to use getListMap to avoid code repetition\n- Update the test\n- Fix a critical issue where {myTag::1} existing would result in {myTag} also existing in some cases (fixed by appending \"!!SINGLE!!\" and \"!!LIST!!\" where needed)\n- Updated the persistent data holder type description\n- Cleaned up imports", "committedDate": "2020-07-03T22:09:32Z", "type": "commit"}, {"oid": "9b30de648b8cc6a705834099b0261928272d523a", "url": "https://github.com/SkriptLang/Skript/commit/9b30de648b8cc6a705834099b0261928272d523a", "message": "Avoid unnecessary and/or repetitive serialization/deserialization\n\n- Make \"persistent data\" optional in the syntax\n- ADD no longer deserializes every value in the list\n- Most methods now take in multiple holders\n- Javadoc cleanup", "committedDate": "2020-07-18T03:44:11Z", "type": "commit"}, {"oid": "fc610e441b5fbbf2e18afc3b7b3a5b0327c70083", "url": "https://github.com/SkriptLang/Skript/commit/fc610e441b5fbbf2e18afc3b7b3a5b0327c70083", "message": "Merge branch 'master' into APickledWalrus-persistent-data", "committedDate": "2020-07-18T03:54:49Z", "type": "commit"}, {"oid": "afb72119bd8be64084d4ae6ddd7ffceca90578f3", "url": "https://github.com/SkriptLang/Skript/commit/afb72119bd8be64084d4ae6ddd7ffceca90578f3", "message": "Merge branch 'master' into APickledWalrus-persistent-data", "committedDate": "2020-07-20T20:03:03Z", "type": "commit"}]}