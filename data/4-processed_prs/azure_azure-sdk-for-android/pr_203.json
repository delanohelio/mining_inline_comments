{"pr_number": 203, "pr_title": "TransferInfo LiveData ", "pr_createdAt": "2020-02-26T02:51:01Z", "pr_url": "https://github.com/Azure/azure-sdk-for-android/pull/203", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1MzY1NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384853654", "bodyText": "How would you feel about just using androidx.work.impl.utils.SerialExecutor instead? It's public, but it's also in an impl package. However it does pretty much exactly the same thing as this class.", "author": "bsiegel", "createdAt": "2020-02-27T00:45:39Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/SerialExecutor.java", "diffHunk": "@@ -0,0 +1,103 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import androidx.annotation.NonNull;\n+import androidx.work.WorkManager;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.Executor;\n+\n+/**\n+ * Package private.\n+ *\n+ * An {@link Executor} that wrap and delegate work execution to another {@link Executor}.\n+ * SerialExecutor ensure that the submitted works are executed serially using\n+ * the wrapped executor.\n+ *\n+ * SerialExecutor is used by {@link TransferClient} for all its internal book keeping,\n+ * which includes creating DB entries for transfer workers, querying DB for status,\n+ * submitting transfer request to {@link WorkManager}.\n+ *\n+ * This is similar to a {@link android.os.Looper} that serially process messages from\n+ * it's message queue. The difference is while Looper hold a dedicated thread throughout\n+ * it lifetime, SerialExecutor delegate the work execution to another executor.\n+ *\n+ * @see <a href=\"https://developer.android.com/reference/java/util/concurrent/Executor\">Executor</a>\n+ */\n+final class SerialExecutor implements Executor {", "originalCommit": "896bd4e2183a50e8794cae392ac53f6569bc9fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzA5MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384857090", "bodyText": "The thing I'm worried about there is - using a type from their \"impl\" package which they can move around any time. Like we are allowed to do for public types in our \"implementation|internal\" namespace.", "author": "anuchandy", "createdAt": "2020-02-27T00:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1MzY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMwNzQ3Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385307473", "bodyText": "That's true - in practice I haven't seen that happen, but it's definitely a consideration. They wouldn't have to do a major version bump if they wanted to break compatibility with this class, and we don't want to pin to an exact version since we're a library.\nI guess my suggestion is probably to keep a copy of their version in our SDK and use the appropriate license + attribution, I see that your implementation and theirs are very similar but not quite identical.\nAlso, I know we do the same thing (put public classes not part of our public API in an impl package) - should we do the same for non-public classes? It feels like we should just so that all of that non-public-API code is in the same place.", "author": "bsiegel", "createdAt": "2020-02-27T18:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1MzY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyNjY5MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385326691", "bodyText": "Also I just noticed that for the public impl classes or public methods that are not part of our public API we can add @RestrictTo which is an IDE hint to not use those classes / methods. We can use LIBRARY or LIBRARY_GROUP as appropriate.", "author": "bsiegel", "createdAt": "2020-02-27T19:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1MzY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyNzg1NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385427854", "bodyText": "yes, I saw that androidx annotation used in jetpack libs.\nIf we've a \"customer consumable public type\" on which we have any \"public methods\" that we don't want customers to use then we should use this annotation. So far for the types in \"transfer namespace\", we haven't come across any cases yet.", "author": "anuchandy", "createdAt": "2020-02-27T23:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1MzY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NTgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385575819", "bodyText": "reg SerialExecutor: I referred the \"Serial\" Executor example in here as well https://developer.android.com/reference/java/util/concurrent/Executor. In a way androidx SerialExecutor is also very close to this.\nJust wondering should we wait a bit more before we include one more TPL to list, I mean wait for the cases where we really cannot avoid copy-pasting 3rd party code. Like 310 time types.", "author": "anuchandy", "createdAt": "2020-02-28T08:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1MzY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854043", "bodyText": "How would you feel about using WorkManager's Configuration.getTaskExecutor() here as the default? The docs say that this function \"Gets the Executor used by WorkManager for all its internal business logic\".", "author": "bsiegel", "createdAt": "2020-02-27T00:47:00Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -14,82 +17,189 @@\n import androidx.work.WorkManager;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n+     */\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // the network type required for transfers.\n+        private @TransferNetworkType int networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link TransferNetworkType} the device should be in\n+         * for running the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@TransferNetworkType int networkType) {\n+            this.networkType = networkType;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the {@link Executor} used by {@link TransferClient} for all its internal\n+         * book keeping, which includes creating DB entries for transfer workers, querying DB\n+         * for status, submitting transfer request to {@link WorkManager}.\n+         *\n+         * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.\n+         *\n+         * @param executor the serialBackgroundExecutor\n+         * @return Builder with provided serialBackgroundExecutor set\n+         */\n+        public Builder setBookKeepingExecutor(@NonNull Executor executor) {\n+            this.serialBackgroundExecutor = new SerialExecutor(executor);\n+            return this;\n+        }\n+\n+        /**\n+         * @return A {@link TransferClient} configured with settings applied through this builder\n+         */\n+        public TransferClient build() {\n+            if (this.storageBlobClient == null) {\n+                throw new IllegalArgumentException(\"storageBlobClient must be set.\");\n+            }\n+            Constraints.Builder constraintsBuilder = new Constraints.Builder();\n+            switch (this.networkType) {\n+                case TransferNetworkType.ANY:\n+                    constraintsBuilder.setRequiredNetworkType(NetworkType.CONNECTED);\n+                    break;\n+                case TransferNetworkType.UNMETERED:\n+                    constraintsBuilder.setRequiredNetworkType(NetworkType.UNMETERED);\n+                    break;\n+                case TransferNetworkType.METERED:\n+                    constraintsBuilder.setRequiredNetworkType(NetworkType.METERED);\n+                    break;\n+                case TransferNetworkType.NOT_ROAMING:\n+                    constraintsBuilder.setRequiredNetworkType(NetworkType.NOT_ROAMING);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"networkType must be set.\");\n+            }\n+            if (this.serialBackgroundExecutor == null) {\n+                this.serialBackgroundExecutor =  new SerialExecutor(Executors.newFixedThreadPool(2));", "originalCommit": "e6d7e9478828a30d61eb4fd0337900363dc7c19b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDE4OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384854189", "bodyText": "(We would still need to wrap it in a SerialExecutor)", "author": "bsiegel", "createdAt": "2020-02-27T00:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MTczMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384861732", "bodyText": "that sounds better, let me check Configuration.getTaskExecutor() is accessible in our scope.", "author": "anuchandy", "createdAt": "2020-02-27T01:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3NzU1MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384877551", "bodyText": "I don't see there is a way to access the current configuration of WorkManager, though it is settable during application bootstrap", "author": "anuchandy", "createdAt": "2020-02-27T02:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyODA0NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385328044", "bodyText": "Yeah, once again I see plenty of ways to do it but only if we cask to WorkManagerImpl. It's so frustrating that so many improvements could be made if just a few things were not hidden from the public API.", "author": "bsiegel", "createdAt": "2020-02-27T19:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyODE5OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385428199", "bodyText": "true, I felt the same for couple of androidx core types.", "author": "anuchandy", "createdAt": "2020-02-27T23:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1Njg1Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385956857", "bodyText": "Maybe it's best we just run on our own thread. But I'm wondering - if most of the bookkeeping is just interacting with Room, and room uses its own thread pool, do we actually need to have a task executor? It's not a rhetorical question - I honestly don't know. Is there much more to the bookkeeping than that?", "author": "bsiegel", "createdAt": "2020-02-28T22:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NTMyNQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385965325", "bodyText": "The upload method is called from UI thread, even though room may have it's own pool internally, still we're not allowed to make room queries from UI thread, room api throws if it find that query is initialed from main thread.\nThis means, we need to offload the work to a different thread. Question is,  should we spin up a new thread per transfer API call for bookkeeping vs should we hold a thread pool to do these bookkeeping.\nSpinning and tearing down short lived threads per transfer api call could add overhead, given thread creation is not cheap.\nHaving \"our own thread pool\" can save thread creation cost, but it still hold threads that is only used for bookkeeping purposes and not accessible for customers.\nHaving a delegated TaskExecutor, enables us to still do the bookkeeping, at the same time we leave an option for customers to share their executor with us that they also use for some their own work. We use it carefully, in the sense, we don't overwhelm it with too many works in parallel given there is a serialization.\nThere seems many trade-off here across options.", "author": "anuchandy", "createdAt": "2020-02-28T23:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2OTIwMQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385969201", "bodyText": "Seems so. I guess it's fine if we have our own small task executor, and if a customer wants to optimize they can create their own executor and pass it to both the configuration of WorkManager / Room and to our TransferClient.\nI still feel like the optimal solution is to get the current task executor from WorkManager (whether the default or the user-supplied one) and reuse it. There's just no way to do that with only their public API. For everything else I am good with things being sub-optimal if it means sticking with only the public API (e.g. duplicating the SerialExecutor class). However in this one case I do wonder if the tradeoff is worth it. Having an extra thread pool just for our own book keeping is certainly an overhead.", "author": "bsiegel", "createdAt": "2020-02-28T23:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3Mzc4NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385973785", "bodyText": "agree, I really wish we have a stable way to  retrieve WorkManager executor, which is optimal but so bad that they hide it.\nJust double checking, so do you agree with current sub-optimal soln?\n\nInternally we use SerialExecutor , we don't leak SerialExecutor  type through TransferClient public APIs.\nWe allow user to share their Executor with us, to which we serially delegate the bookkeeping work.\nIf user don't provide one then we internally create Executor and use for book keeping.", "author": "anuchandy", "createdAt": "2020-02-28T23:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NDQ5Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385974493", "bodyText": "#1 yes, I'm fine with us having our own copy of SerialExecutor to avoid having to use non-public API\n#2-3, what do you think of this proposal for TransferClient.build():\nif (this.serialBackgroundExecutor == null) {\n    try {\n        // Try to re-use the existing taskExecutor shared by WorkManager and Room\n        WorkManagerImpl wmImpl = (WorkManagerImpl)WorkManager.getInstance(context);\n        this.serialBackgroundExecutor = new SerialExecutor(wmImpl.getConfiguration().getTaskExecutor());\n    } catch (Exception ignored) {\n        // Create our own small ThreadPoolExecutor if we can't\n        this.serialBackgroundExecutor = new SerialExecutor(Executors.newFixedThreadPool(2));\n    }\n}\nIn the above, we're unsafely using the non-public API of WorkManager, but if it fails we catch any type of Exception (which I believe includes RuntimeExceptions) and create our own thread pool instead.", "author": "bsiegel", "createdAt": "2020-02-28T23:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3Njc4OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385976789", "bodyText": "cool, I'm fine with doing this best effort to avoid creating our own pool.\nSo if ever WM remove this accessor then as part of upgrading our libs to the new WM, we can adjust our code.\nIf customer override WM dependency in their application, such that the version they bring is different from the one we use and if their WM is missing this accessor, then it will be MethodNotFoundException which we catch here (as RuntimeException) and fall back to our own thread pool.", "author": "anuchandy", "createdAt": "2020-02-29T00:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NzUyNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385977524", "bodyText": "I could also imagine a future change causing ClassCastException or NullPointerException as well but all of those should be caught here. Just documenting for posterity :)", "author": "bsiegel", "createdAt": "2020-02-29T00:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NDA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384856595", "bodyText": "Just as a thought, we could perhaps allow customers to provide their own Constraints instance. It does leak out the WorkManager API surface but I'm not convinced that's necessarily a bad thing in this situation - wrapping the whole thing would be worse. We could just check and make sure it contains a network constraint when build() is called and add NetworkType.CONNECTED by default if not.", "author": "bsiegel", "createdAt": "2020-02-27T00:55:09Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -14,82 +17,189 @@\n import androidx.work.WorkManager;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n+     */\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // the network type required for transfers.\n+        private @TransferNetworkType int networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link TransferNetworkType} the device should be in\n+         * for running the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@TransferNetworkType int networkType) {", "originalCommit": "e6d7e9478828a30d61eb4fd0337900363dc7c19b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODMwMA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384868300", "bodyText": "I'm not opposed to taking Constraints instance directly. I think its good to honor additional constrains given those options make sense (like charging required, battery low).\nLooks like there is no nice way to create a new Constraints instance from an existing one along with mutation (like newBuilder() on Constraints). Looking into it.", "author": "anuchandy", "createdAt": "2020-02-27T01:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyNzM4Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385327383", "bodyText": "It might be odd, but maybe we can just accept a Constraints.Builder? There's also a public setRequiredNetworkType method on the configuration but it has an annotation to hint to the IDE that it's not meant to be part of their public API. We could consider suppressing that lint (though, same concerns as before - this can be brittle).", "author": "bsiegel", "createdAt": "2020-02-27T19:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyOTU1MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385429551", "bodyText": "I think we should do some exploration around, whether taking builder as a param is a pattern in community.\nWe can also think of taking Constraints instance and create a copy of it (by going through each property, bit verbose though) with required mutation applied.", "author": "anuchandy", "createdAt": "2020-02-27T23:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyOTcyOA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385429728", "bodyText": "what do you think?", "author": "anuchandy", "createdAt": "2020-02-27T23:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ0MDE5MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385440191", "bodyText": "I thought of just making a copy, but annoyingly there are not getters for every property that can be set by the builder. The addContentUriTrigger and all of the setTrigger... methods on the builder end up setting fields of the Constraints object which have no public getters :(\nI can't think of any use case where a customer would want to add / configure such a trigger for their transfer but if they did we would miss it. Maybe the best approach is to just lift the other four Constraints.Builder methods we care about into our TransferClient.Builder:\n\nsetRequiresBatteryNotLow\nsetRequiresCharging\nsetRequiresDeviceIdle\nsetRequiresStorageNotLow\n\nI guess the downside of lifting would be that if the Constraints type gains additional properties in the future, we would need to explicitly add code to support them.\nAlso I think I'd be fine if we changed this method to accept an androidx.work.NetworkType, I don't think I have a concern about leaking this type from WorkManager, we can assume customers are already reasonably familiar with this type or at least can look up the docs for it from Google. But I could be convinced either way, I just don't see a ton of value being provided by wrapping it with our own enum.", "author": "bsiegel", "createdAt": "2020-02-28T00:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3MDk4Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385570986", "bodyText": "hey @bsiegel thank you for doing all these investigations and adding lot of values while I'm heads down into immediate customer issue.\nExcept setRequiredNetworkType, all other setters you listed takes primitive boolean so only type we have to consider is androidx.work.NetworkType. I don't have any concern in exposing androidx.work.NetworkType directly. Let's go with that and during user study we can watch how users adapt to it and can adjust based on feedback, if any.\nIf app provide androidx.work.NetworkType.NOT_REQUIRED then I think we can just throw an IllegalArgumentException.", "author": "anuchandy", "createdAt": "2020-02-28T08:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDY3OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r385954679", "bodyText": "I'm onboard with that approach \ud83d\udc4d", "author": "bsiegel", "createdAt": "2020-02-28T22:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NjU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzQ5Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384857493", "bodyText": "Maybe call this setTaskExecutor ?? I think your name conveys more semantics, but WorkManager and Room both call this the \"task executor\" so maybe better to be consistent?", "author": "bsiegel", "createdAt": "2020-02-27T00:58:11Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -14,82 +17,189 @@\n import androidx.work.WorkManager;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n+     */\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // the network type required for transfers.\n+        private @TransferNetworkType int networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link TransferNetworkType} the device should be in\n+         * for running the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@TransferNetworkType int networkType) {\n+            this.networkType = networkType;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the {@link Executor} used by {@link TransferClient} for all its internal\n+         * book keeping, which includes creating DB entries for transfer workers, querying DB\n+         * for status, submitting transfer request to {@link WorkManager}.\n+         *\n+         * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.\n+         *\n+         * @param executor the serialBackgroundExecutor\n+         * @return Builder with provided serialBackgroundExecutor set\n+         */\n+        public Builder setBookKeepingExecutor(@NonNull Executor executor) {", "originalCommit": "e6d7e9478828a30d61eb4fd0337900363dc7c19b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MjA0Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384862047", "bodyText": "cool agree, let follow the same naming convention that room and WM follows.", "author": "anuchandy", "createdAt": "2020-02-27T01:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1OTE5Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384859192", "bodyText": "Just to clarify, the only reason we initialize this class with a LiveData<long> rather than just long is that we're using the LiveData as a communication channel, waiting for the transfer operation to be stored in the database so we can get its ID which happens in a callback. This implies that we only ever expect the transferIdLiveData to update once, right?\nIf my understanding is correct we should document this somewhere. It wasn't obvious until I stared at this for awhile why we were using a LiveData<long> at all.", "author": "bsiegel", "createdAt": "2020-02-27T01:04:08Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdMappedToTransferInfo.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.MainThread;\n+import androidx.annotation.NonNull;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MediatorLiveData;\n+import androidx.lifecycle.Transformations;\n+import androidx.work.Data;\n+import androidx.work.WorkInfo;\n+import androidx.work.WorkManager;\n+\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type to transform an input LiveData that emit a transfer id to an output LiveData that emit\n+ * a stream of {@link TransferInfo}.\n+ *\n+ * Each {@link TransferInfo} event from output LiveData describes current state of the transfer\n+ * identified by the transfer id.\n+ */\n+final class TransferIdMappedToTransferInfo {", "originalCommit": "e6d7e9478828a30d61eb4fd0337900363dc7c19b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NDM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r384864391", "bodyText": "you're right - we use LiveData<Long> as a communication channel, to receive the identifier that is not available at the time of creating TransferIdMappedToTransferInfo instance.\nRegarding once vs multi emission - it emits only once in the current code base, but I have a plan to extend it for resume, after user pause, in such cases it can emit multiple times. Yet to be designed.\nI will add reason for using  LiveData<Long> instead of long in the java-doc.", "author": "anuchandy", "createdAt": "2020-02-27T01:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1OTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1NzQ3Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r387957472", "bodyText": "Maybe we should just default this to CONNECTED if not specified. That seems like a reasonable default.", "author": "bsiegel", "createdAt": "2020-03-04T21:54:33Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -3,93 +3,274 @@\n \n package com.azure.android.storage.blob.transfer;\n \n+import android.annotation.SuppressLint;\n import android.content.Context;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MutableLiveData;\n import androidx.work.Constraints;\n import androidx.work.Data;\n import androidx.work.ExistingWorkPolicy;\n import androidx.work.NetworkType;\n import androidx.work.OneTimeWorkRequest;\n import androidx.work.WorkManager;\n+import androidx.work.impl.WorkManagerImpl;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n+     */\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // indicate whether the device should be charging for running the transfers.\n+        private boolean requiresCharging;\n+        // indicate whether the device should be idle for running the transfers.\n+        private boolean requiresDeviceIdle;\n+        // indicate whether the device battery should be at an acceptable level for running the transfers\n+        private boolean requiresBatteryNotLow;\n+        // indicate whether the device's available storage should be at an acceptable level for running\n+        // the transfers\n+        private boolean requiresStorageNotLow;\n+        // the network type required for transfers.\n+        private NetworkType networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device should be charging for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresCharging {@code true} if device must be charging for the transfer to run\n+         * @return Builder with provided charging requirement set\n+         */\n+        public Builder setRequiresCharging(boolean requiresCharging) {\n+            this.requiresCharging = requiresCharging;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device should be idle for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresDeviceIdle {@code true} if device must be idle for transfers to run\n+         * @return Builder with provided idle requirement set\n+         */\n+        @RequiresApi(23)\n+        public Builder setRequiresDeviceIdle(boolean requiresDeviceIdle) {\n+            this.requiresDeviceIdle = requiresDeviceIdle;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link NetworkType} the device should be in for running\n+         * the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@NonNull NetworkType networkType) {\n+            this.networkType = networkType;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device battery should be at an acceptable level for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresBatteryNotLow {@code true} if the battery should be at an acceptable level\n+         *                              for the transfers to run\n+         * @return Builder with provided battery requirement set\n+         */\n+        public Builder setRequiresBatteryNotLow(boolean requiresBatteryNotLow) {\n+            this.requiresBatteryNotLow = requiresBatteryNotLow;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether the device's available storage should be at an acceptable level for running\n+         * the transfers. The default value is {@code false}.\n+         *\n+         * @param requiresStorageNotLow {@code true} if the available storage should not be below a\n+         *                              a critical threshold for the transfer to run\n+         * @return Builder with provided storage requirement set\n+         */\n+        public Builder setRequiresStorageNotLow(boolean requiresStorageNotLow) {\n+            this.requiresStorageNotLow = requiresStorageNotLow;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the {@link Executor} used by {@link TransferClient} for all its internal\n+         * book keeping, which includes creating DB entries for transfer workers, querying DB\n+         * for status, submitting transfer request to {@link WorkManager}.\n+         *\n+         * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.\n+         *\n+         * @param executor the serialBackgroundExecutor\n+         * @return Builder with provided serialBackgroundExecutor set\n+         */\n+        public Builder setTaskExecutor(@NonNull Executor executor) {\n+            this.serialBackgroundExecutor = new SerialExecutor(executor);\n+            return this;\n+        }\n+\n+        /**\n+         * @return A {@link TransferClient} configured with settings applied through this builder\n+         */\n+        // Following annotation is added to suppress library restricted WorkManager\n+        // androidx.work.Configuration Object access\n+        @SuppressLint(\"RestrictedApi\")\n+        public TransferClient build() {\n+            if (this.storageBlobClient == null) {\n+                throw new IllegalArgumentException(\"storageBlobClient must be set.\");\n+            }\n+            final Constraints.Builder constraintsBuilder = new Constraints.Builder();\n+            constraintsBuilder.setRequiresCharging(this.requiresCharging);\n+            constraintsBuilder.setRequiresDeviceIdle(this.requiresDeviceIdle);\n+            if (this.networkType == null) {\n+                throw new IllegalArgumentException(\"networkType must be set.\");", "originalCommit": "c12a66e7d1ee617450d21ded222386e8030366dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2NzA1MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r387967050", "bodyText": "hmm, I thought of that a bit worried about it i.e. using a default that can \"incur charge/money\".", "author": "anuchandy", "createdAt": "2020-03-04T22:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1NzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNTAyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r388015027", "bodyText": "Definitely a good thought. I looked at what WorkManager itself does, and if no Constraints are supplied, the default value is Constraints.NONE: https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/work/workmanager/src/main/java/androidx/work/impl/model/WorkSpec.java#97\nI'd feel okay doing the same, for consistency. Though I do totally agree that the workmanager is a general framework, while we're using it specifically for network transfers and so the appropriate default might be different for our use case. Wondering if @adrianhall has an opinion here?", "author": "bsiegel", "createdAt": "2020-03-05T00:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1NzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAzMDg5Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r388030897", "bodyText": "Just checked what AWS is doing in this case, aws-lib uses ANY, equivalent that in WM is CONNECTED.", "author": "anuchandy", "createdAt": "2020-03-05T01:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1NzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MjU4NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r389792585", "bodyText": "Created an issue here: #213.", "author": "anuchandy", "createdAt": "2020-03-09T16:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1NzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg5NjUwNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r389896504", "bodyText": "Based on the response to the issue, we will go with CONNECTED as default which is already specified in the code. Marking it resolved.", "author": "anuchandy", "createdAt": "2020-03-09T18:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1NzQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1ODQxNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r387958417", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.\n          \n          \n            \n                     * TransferClient will enqueue a maximum of two commands to the taskExecutor at any time.\n          \n      \n    \n    \n  \n\nAlso for consistency it might be nice to rename the field to e.g. \"serialTaskExecutor\"", "author": "bsiegel", "createdAt": "2020-03-04T21:56:24Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -3,93 +3,274 @@\n \n package com.azure.android.storage.blob.transfer;\n \n+import android.annotation.SuppressLint;\n import android.content.Context;\n import android.util.Log;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MutableLiveData;\n import androidx.work.Constraints;\n import androidx.work.Data;\n import androidx.work.ExistingWorkPolicy;\n import androidx.work.NetworkType;\n import androidx.work.OneTimeWorkRequest;\n import androidx.work.WorkManager;\n+import androidx.work.impl.WorkManagerImpl;\n \n import com.azure.android.storage.blob.StorageBlobClient;\n-import com.azure.android.storage.blob.credentials.SasTokenCredential;\n-import com.azure.android.storage.blob.interceptor.SasTokenCredentialInterceptor;\n \n import java.io.File;\n import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n \n /**\n- * A type that exposes APIs for blob transfer.\n+ * A type that exposes blob transfer APIs.\n  */\n public class TransferClient {\n     private static final String TAG = TransferClient.class.getSimpleName();\n+    // the application context.\n     private final Context context;\n-    private final TransferDatabase db;\n+    // the default storage client for all transfers.\n     private final StorageBlobClient blobClient;\n+    // the constraints to meet to run the transfers.\n+    // currently hold the network type required for transfers.\n+    private final Constraints constraints;\n+    // the executor for internal book keeping.\n+    private SerialExecutor serialBackgroundExecutor;\n+    // reference to the database holding transfer entities.\n+    private final TransferDatabase db;\n \n     /**\n      * Creates a {@link TransferClient} that uses provided {@link StorageBlobClient}\n      * for transfers.\n      *\n      * @param context the context\n      * @param blobClient the blob storage client\n+     * @param constraints the constraints to meet to run transfers\n+     * @param serialExecutor the serialBackgroundExecutor for all internal booking keeping purposes\n      */\n-    public TransferClient(Context context, StorageBlobClient blobClient) {\n+    private TransferClient(Context context,\n+                           StorageBlobClient blobClient,\n+                           Constraints constraints,\n+                           SerialExecutor serialExecutor) {\n         this.context = context;\n-        this.db = TransferDatabase.get(context);\n         this.blobClient = blobClient;\n+        this.constraints = constraints;\n+        this.serialBackgroundExecutor = serialExecutor;\n+        this.db = TransferDatabase.get(context);\n     }\n \n     /**\n-     * Creates a {@link TransferClient} that uses provided blob storage endpoint and SAS token.\n+     * Upload a file.\n      *\n-     * @param context the context\n-     * @param storageUrl the blob storage url\n-     * @param sasToken the SAS token\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param file the local file to upload\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n-    public TransferClient(Context context, String storageUrl, String sasToken) {\n-        this(context,\n-            new StorageBlobClient.Builder()\n-                .setBlobServiceUrl(storageUrl)\n-                .setCredentialInterceptor(new SasTokenCredentialInterceptor(new SasTokenCredential(sasToken)))\n-                .build());\n+    public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n+        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        this.serialBackgroundExecutor.execute(() -> {\n+            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+            List<BlockUploadEntity> blocks\n+                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n+            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n+\n+            StorageBlobClientsMap.put(uploadId, blobClient);\n+\n+            Data inputData = new Data.Builder()\n+                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n+                .build();\n+            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                .Builder(UploadWorker.class)\n+                .setConstraints(constraints)\n+                .setInputData(inputData)\n+                .build();\n+\n+            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n+            WorkManager.getInstance(context)\n+                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n+                    ExistingWorkPolicy.KEEP,\n+                    uploadWorkRequest)\n+                .enqueue();\n+            transferIdLiveData.postValue(uploadId);\n+        });\n+        return new TransferIdMappedToTransferInfo()\n+            .getTransferInfoLiveData(context, transferIdLiveData);\n     }\n \n     /**\n-     * Upload a file.\n+     * Get the name for a unique transfer work.\n      *\n-     * @param containerName the container to upload the file to\n-     * @param blobName the name of the target blob holding uploaded file\n-     * @param file the local file to upload\n-     * @return the upload id\n+     * @param transferId the transfer id\n+     * @return name for the transfer work\n      */\n-    public long upload(String containerName, String blobName, File file) {\n-        BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-        List<BlockUploadEntity> blocks = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-        long uploadId = this.db.uploadDao().createUploadRecord(blob, blocks);\n-        Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-        StorageBlobClientsMap.put(uploadId, this.blobClient);\n-        Constraints constraints = new Constraints.Builder()\n-            .setRequiredNetworkType(NetworkType.CONNECTED)\n-            .build();\n-\n-       Data inputData = new Data.Builder()\n-            .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-            .build();\n-\n-        OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-            .Builder(UploadWorker.class)\n-            .setConstraints(constraints)\n-            .setInputData(inputData)\n-            .build();\n-        Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-        WorkManager.getInstance(this.context)\n-            .beginUniqueWork(\"file_upload_\" + uploadId, ExistingWorkPolicy.KEEP, uploadWorkRequest)\n-            .enqueue();\n-        return uploadId;\n+    static String toTransferUniqueWorkName(long transferId) {\n+        return \"azure_transfer_\" + transferId;\n+    }\n+\n+    /**\n+     * A builder to configure and build a {@link TransferClient}.\n+     */\n+    public static final class Builder {\n+        // the application context.\n+        private Context context;\n+        // the default storage client for all transfers.\n+        private StorageBlobClient storageBlobClient;\n+        // indicate whether the device should be charging for running the transfers.\n+        private boolean requiresCharging;\n+        // indicate whether the device should be idle for running the transfers.\n+        private boolean requiresDeviceIdle;\n+        // indicate whether the device battery should be at an acceptable level for running the transfers\n+        private boolean requiresBatteryNotLow;\n+        // indicate whether the device's available storage should be at an acceptable level for running\n+        // the transfers\n+        private boolean requiresStorageNotLow;\n+        // the network type required for transfers.\n+        private NetworkType networkType;\n+        // the executor for internal book keeping.\n+        private SerialExecutor serialBackgroundExecutor;\n+\n+        /**\n+         * Create a new {@link TransferClient} builder.\n+         */\n+        public Builder(@NonNull Context context) {\n+            this.context = context;\n+        }\n+\n+        /**\n+         * Set the storage blob client to use for all transfers.\n+         *\n+         * @param storageBlobClient the storage blob client\n+         * @return Builder with provided Storage Blob Client set\n+         */\n+        public Builder setStorageClient(@NonNull StorageBlobClient storageBlobClient) {\n+            this.storageBlobClient = storageBlobClient;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device should be charging for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresCharging {@code true} if device must be charging for the transfer to run\n+         * @return Builder with provided charging requirement set\n+         */\n+        public Builder setRequiresCharging(boolean requiresCharging) {\n+            this.requiresCharging = requiresCharging;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device should be idle for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresDeviceIdle {@code true} if device must be idle for transfers to run\n+         * @return Builder with provided idle requirement set\n+         */\n+        @RequiresApi(23)\n+        public Builder setRequiresDeviceIdle(boolean requiresDeviceIdle) {\n+            this.requiresDeviceIdle = requiresDeviceIdle;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the particular {@link NetworkType} the device should be in for running\n+         * the transfers.\n+         *\n+         * @param networkType The type of network required for transfers to run\n+         * @return Builder with provided network type set\n+         */\n+        public Builder setRequiredNetworkType(@NonNull NetworkType networkType) {\n+            this.networkType = networkType;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether device battery should be at an acceptable level for running the transfers.\n+         * The default value is {@code false}.\n+         *\n+         * @param requiresBatteryNotLow {@code true} if the battery should be at an acceptable level\n+         *                              for the transfers to run\n+         * @return Builder with provided battery requirement set\n+         */\n+        public Builder setRequiresBatteryNotLow(boolean requiresBatteryNotLow) {\n+            this.requiresBatteryNotLow = requiresBatteryNotLow;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether the device's available storage should be at an acceptable level for running\n+         * the transfers. The default value is {@code false}.\n+         *\n+         * @param requiresStorageNotLow {@code true} if the available storage should not be below a\n+         *                              a critical threshold for the transfer to run\n+         * @return Builder with provided storage requirement set\n+         */\n+        public Builder setRequiresStorageNotLow(boolean requiresStorageNotLow) {\n+            this.requiresStorageNotLow = requiresStorageNotLow;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the {@link Executor} used by {@link TransferClient} for all its internal\n+         * book keeping, which includes creating DB entries for transfer workers, querying DB\n+         * for status, submitting transfer request to {@link WorkManager}.\n+         *\n+         * TransferClient will enqueue maximum of two command to the serialBackgroundExecutor at any time.", "originalCommit": "c12a66e7d1ee617450d21ded222386e8030366dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNTUwNQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r388015505", "bodyText": "There are a few other comments referring to serialBackgroundExecutor that need to be updated as well. I can push a quick fixup or you can go through and take care of it, whichever you prefer.", "author": "bsiegel", "createdAt": "2020-03-05T00:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1ODQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjMzNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/203#discussion_r388016334", "bodyText": "sure please do, I won't say \"no\" to help :)", "author": "anuchandy", "createdAt": "2020-03-05T00:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1ODQxNw=="}], "type": "inlineReview"}, {"oid": "9646a17de62d674cc498d5e8ba1caba2c1c87049", "url": "https://github.com/Azure/azure-sdk-for-android/commit/9646a17de62d674cc498d5e8ba1caba2c1c87049", "message": "UploadDao: Correcting getUploadedBytesCount(blobKey) to only aggregate byes of completed blocks", "committedDate": "2020-03-09T16:36:08Z", "type": "commit"}, {"oid": "a3c770819be1809e685b7a867f1e9286e4de6dbd", "url": "https://github.com/Azure/azure-sdk-for-android/commit/a3c770819be1809e685b7a867f1e9286e4de6dbd", "message": "SerialExecutor: A facade Executor to serially delegate work to another Executor.", "committedDate": "2020-03-09T16:36:08Z", "type": "commit"}, {"oid": "77ac9e5aa5116a8862efe62ecaffffcb13257089", "url": "https://github.com/Azure/azure-sdk-for-android/commit/77ac9e5aa5116a8862efe62ecaffffcb13257089", "message": "TransferInfo LiveData: Defining TransferInfo event to describe the state of transfer, Adding mapping of WorkInfo to TransferInfo, Updating TransferClient::upload to use SerialExecutor and return LiveData of TransferInfo, adding minimal builder for TransferClient", "committedDate": "2020-03-09T16:36:09Z", "type": "commit"}]}