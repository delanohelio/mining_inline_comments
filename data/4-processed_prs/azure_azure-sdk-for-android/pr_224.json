{"pr_number": 224, "pr_title": "Error notification, TransferInfo LiveData sharing and pause, resume support", "pr_createdAt": "2020-04-13T18:30:43Z", "pr_url": "https://github.com/Azure/azure-sdk-for-android/pull/224", "timeline": [{"oid": "e3f433ea459b818fdb53952102dbebed53e033ea", "url": "https://github.com/Azure/azure-sdk-for-android/commit/e3f433ea459b818fdb53952102dbebed53e033ea", "message": "Promote background UploadWorker failure to foreground TransferInfo LiveData.", "committedDate": "2020-04-13T17:03:04Z", "type": "commit"}, {"oid": "7f18255f1119be4439ef13bd552a11bc07c23087", "url": "https://github.com/Azure/azure-sdk-for-android/commit/7f18255f1119be4439ef13bd552a11bc07c23087", "message": "Promote background TransferClient::serialExecutor failure to foreground TransferInfo LiveData.", "committedDate": "2020-04-13T17:36:23Z", "type": "commit"}, {"oid": "c128cad4582a3e4d782303aff662c54c20177486", "url": "https://github.com/Azure/azure-sdk-for-android/commit/c128cad4582a3e4d782303aff662c54c20177486", "message": "Moving TransferIdOrError LiveData ownership to TransferIdMappedToTransferInfo, so that both input TransferIdOrError LiveData and output TransferInfo LiveData are owned by the same type.", "committedDate": "2020-04-13T17:53:02Z", "type": "commit"}, {"oid": "d696b38f95e3b44981986e36910786ba97b6bc5f", "url": "https://github.com/Azure/azure-sdk-for-android/commit/d696b38f95e3b44981986e36910786ba97b6bc5f", "message": "Renaming TransferIdMappedToTransferInfo to TransferIdInfoLiveData.", "committedDate": "2020-04-13T17:56:25Z", "type": "commit"}, {"oid": "68ee38e04e403bc8a2fb3984ecc39e19c8c2d2d4", "url": "https://github.com/Azure/azure-sdk-for-android/commit/68ee38e04e403bc8a2fb3984ecc39e19c8c2d2d4", "message": "Adding TransferIdInfoLiveDataCache, a type to cache LiveData pair created from TransferIdInfoLiveData with weak reference to output TransferInfo LiveData", "committedDate": "2020-04-13T18:06:07Z", "type": "commit"}, {"oid": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "url": "https://github.com/Azure/azure-sdk-for-android/commit/189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "message": "Adding common types to support pause, resume transfer. Implementing them for upload transfer", "committedDate": "2020-04-13T18:15:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MDA0NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r407760044", "bodyText": "If there is a chance we can encounter more cases where we need to extract error messages from a specific type of exception, maybe it would be worth naming this something a bit more specific, like ExceptionUtil.", "author": "vcolin7", "createdAt": "2020-04-13T22:37:31Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/Util.java", "diffHunk": "@@ -0,0 +1,66 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import com.azure.android.core.internal.util.serializer.SerializerAdapter;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.BlobStorageException;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+\n+import java.util.Objects;\n+\n+final class Util {", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4OTQ2MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408489461", "bodyText": "My thought was to use Util as a place holder to add any more utility methods that we want to stay local to the package. If we come across more exception parsing scenarios then I was thinking of creating a type like ExceptionUtil specific for exception parsing. But I don't see any immediate use case to parse exceptions in any other format.", "author": "anuchandy", "createdAt": "2020-04-14T23:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MDA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzNzkyOA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408437928", "bodyText": "This may be a dumb question but why are we using a static method to create this instead of making init() not private and using it?", "author": "vcolin7", "createdAt": "2020-04-14T21:11:27Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdInfoLiveData.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.MainThread;\n+import androidx.annotation.NonNull;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MediatorLiveData;\n+import androidx.lifecycle.MutableLiveData;\n+import androidx.lifecycle.Transformations;\n+import androidx.work.Data;\n+import androidx.work.WorkInfo;\n+import androidx.work.WorkManager;\n+\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type to create the LiveData pair, a {@link TransferIdOrError} LiveData and associated {@link TransferInfo}\n+ * LiveData. Each transfer will have such a unique LiveData pair.\n+ *\n+ * When transfer id is set to TransferIdOrError LiveData then TransferInfo LiveData streams {@link TransferInfo}\n+ * events describing current state of the transfer identified by the transfer id. Internally the source of the\n+ * TransferInfo LiveData queries {@link WorkManager} for a LiveData that streams {@link WorkInfo} and transform\n+ * {@link WorkInfo} events to {@link TransferInfo} events.\n+ *\n+ * Same transfer id can be set multiple times in the TransferIdOrError LiveData. Each such set results in querying\n+ * {@link WorkManager} as described above. There can be active Observes for an original transfer when it is paused\n+ * and later resumed by a different Worker. When possible we share the same LiveData pair between original transfer\n+ * and it's resume. In such cases, the ability to set transfer id on the TransferIdOrError LiveData multiple times\n+ * enables to transparently switch the Worker and keep any existing Observers of the original transfer to continue\n+ * to receive the {@link TransferInfo} events.\n+ *\n+ * @see TransferIdInfoLiveDataCache (for LiveData pair sharing)\n+ */\n+final class TransferIdInfoLiveData {\n+    private static final String TAG = TransferIdInfoLiveData.class.getSimpleName();\n+    // the input LiveData that receives the transfer id or error.\n+    private final MutableLiveData<TransferIdOrError> transferIdOrErrorLiveData = new MutableLiveData<>();\n+    // the output TransferInfo LiveData.\n+    private final MediatorLiveData<TransferInfo> transferInfoLiveData = new MediatorLiveData<>();\n+    // the the object that TransferClient methods update any state that it want TransferInfo LiveData source\n+    // for a transfer to know.\n+    private final TransferFlags transferFlags = new TransferFlags();\n+    // the recent TransferIdOrError object emitted by the transferIdOrErrorLiveData object.\n+    private TransferIdOrError inputTransferIdOrError;\n+    // hold the state of the last WorkInfo received from Transfer Worker.\n+    private WorkInfo.State lastWorkInfoState;\n+    // flag to track whether current event about to emit from transferInfoLiveData is the first event.\n+    private boolean isFirstEvent = true;\n+    // flag to track whether the last emitted event from transferInfoLiveData was a pause event.\n+    private boolean wasPaused;\n+\n+    private TransferIdInfoLiveData() {}\n+\n+    @MainThread\n+    static TransferIdInfoLiveData.Result create(Context context) {\n+        TransferIdInfoLiveData transferIdInfoLiveData = new TransferIdInfoLiveData();", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MDkyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408490927", "bodyText": "Mainly for readability, the name create indicates it is factory method hence is static but init is initializing an already created object.", "author": "anuchandy", "createdAt": "2020-04-14T23:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzNzkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MTYxNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408451614", "bodyText": "Why is this reset when checking its value?", "author": "vcolin7", "createdAt": "2020-04-14T21:38:14Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdInfoLiveData.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.MainThread;\n+import androidx.annotation.NonNull;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MediatorLiveData;\n+import androidx.lifecycle.MutableLiveData;\n+import androidx.lifecycle.Transformations;\n+import androidx.work.Data;\n+import androidx.work.WorkInfo;\n+import androidx.work.WorkManager;\n+\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type to create the LiveData pair, a {@link TransferIdOrError} LiveData and associated {@link TransferInfo}\n+ * LiveData. Each transfer will have such a unique LiveData pair.\n+ *\n+ * When transfer id is set to TransferIdOrError LiveData then TransferInfo LiveData streams {@link TransferInfo}\n+ * events describing current state of the transfer identified by the transfer id. Internally the source of the\n+ * TransferInfo LiveData queries {@link WorkManager} for a LiveData that streams {@link WorkInfo} and transform\n+ * {@link WorkInfo} events to {@link TransferInfo} events.\n+ *\n+ * Same transfer id can be set multiple times in the TransferIdOrError LiveData. Each such set results in querying\n+ * {@link WorkManager} as described above. There can be active Observes for an original transfer when it is paused\n+ * and later resumed by a different Worker. When possible we share the same LiveData pair between original transfer\n+ * and it's resume. In such cases, the ability to set transfer id on the TransferIdOrError LiveData multiple times\n+ * enables to transparently switch the Worker and keep any existing Observers of the original transfer to continue\n+ * to receive the {@link TransferInfo} events.\n+ *\n+ * @see TransferIdInfoLiveDataCache (for LiveData pair sharing)\n+ */\n+final class TransferIdInfoLiveData {\n+    private static final String TAG = TransferIdInfoLiveData.class.getSimpleName();\n+    // the input LiveData that receives the transfer id or error.\n+    private final MutableLiveData<TransferIdOrError> transferIdOrErrorLiveData = new MutableLiveData<>();\n+    // the output TransferInfo LiveData.\n+    private final MediatorLiveData<TransferInfo> transferInfoLiveData = new MediatorLiveData<>();\n+    // the the object that TransferClient methods update any state that it want TransferInfo LiveData source\n+    // for a transfer to know.\n+    private final TransferFlags transferFlags = new TransferFlags();\n+    // the recent TransferIdOrError object emitted by the transferIdOrErrorLiveData object.\n+    private TransferIdOrError inputTransferIdOrError;\n+    // hold the state of the last WorkInfo received from Transfer Worker.\n+    private WorkInfo.State lastWorkInfoState;\n+    // flag to track whether current event about to emit from transferInfoLiveData is the first event.\n+    private boolean isFirstEvent = true;\n+    // flag to track whether the last emitted event from transferInfoLiveData was a pause event.\n+    private boolean wasPaused;\n+\n+    private TransferIdInfoLiveData() {}\n+\n+    @MainThread\n+    static TransferIdInfoLiveData.Result create(Context context) {\n+        TransferIdInfoLiveData transferIdInfoLiveData = new TransferIdInfoLiveData();\n+        return transferIdInfoLiveData.init(context);\n+    }\n+\n+    private TransferIdInfoLiveData.Result init(@NonNull Context context) {\n+        // 1. Register mapping of transferId to LiveData<WorkInfo>\n+        LiveData<WorkInfo> workInfoLiveData = this.mapInputTransferIdToWorkInfoLiveData(context);\n+        // 2. Register mapping of LiveData<WorkInfo> to LiveData<TransferInfo>\n+        this.transferInfoLiveData.addSource(workInfoLiveData, workInfo -> {\n+            if (this.inputTransferIdOrError.isError()) {\n+                mapErrorFromTransferClient();\n+                return;\n+            }\n+            if (workInfo == null) {\n+                Log.v(TAG, \"Skipping Null 'WorkInfo' from WorkManager.\");\n+                return;\n+            }\n+\n+            final WorkInfo.State lastWorkInfoState = getLastWorkInfoState();\n+            if (lastWorkInfoState != null) {\n+                if (lastWorkInfoState == WorkInfo.State.SUCCEEDED\n+                    || lastWorkInfoState == WorkInfo.State.FAILED\n+                    || (lastWorkInfoState == WorkInfo.State.CANCELLED && !this.wasPaused())) {\n+                    Log.e(TAG, \"Received an unexpected 'WorkInfo' from WorkManager after terminal state:\"\n+                        + workInfo.toString());\n+                    return;\n+                }\n+            }\n+\n+            WorkInfo.State currentWorkInfoState = workInfo.getState();\n+            if (currentWorkInfoState == null) {\n+                Log.v(TAG, \"Skipping the 'WorkInfo' from WorkManager with Null state.\");\n+                return;\n+            }\n+            final long transferId = this.inputTransferIdOrError.getId();\n+            this.setLastWorkInfoState(currentWorkInfoState);\n+            if (this.isFirstEvent()) {\n+                this.setDoneFirstEvent();\n+                this.setWasPaused(false);\n+                this.transferInfoLiveData.setValue(TransferInfo.createStarted(transferId));\n+                if (currentWorkInfoState == WorkInfo.State.ENQUEUED) {\n+                    // the worker state can be WorkInfo.State.ENQUEUED in two cases -\n+                    // 1. When work is scheduled for the first time.\n+                    // 2. When work is paused by the system (e.g. no network).\n+                    //\n+                    // The #1 is mapped to TransferInfo.State.STARTED\n+                    // and #2 is mapped to TransferInfo.State.SYSTEM_PAUSED\n+                    //\n+                    // The outer block handled #1 by sending TransferInfo.State.STARTED\n+                    // hence returning.\n+                    return;\n+                }\n+            }\n+            if (currentWorkInfoState == WorkInfo.State.RUNNING) {\n+                if (this.wasPaused()) {\n+                    this.transferInfoLiveData.setValue(TransferInfo.createResumed(transferId));\n+                }\n+                this.setWasPaused(false);\n+                TransferInfo.Progress progress = tryGetWorkerProgress(workInfo);\n+                if (progress != null) {\n+                    this.transferInfoLiveData.setValue(TransferInfo.createProgress(transferId, progress));\n+                }\n+                return;\n+            }\n+            if (currentWorkInfoState == WorkInfo.State.CANCELLED) {\n+                if (this.transferFlags.isUserPaused()) {\n+                    this.setWasPaused(true);\n+                    this.transferInfoLiveData.setValue(TransferInfo.createUserPaused(transferId));\n+                } else {\n+                    this.setWasPaused(false);\n+                    this.transferInfoLiveData.setValue(TransferInfo.createCancelled(transferId));\n+                }\n+                return;\n+            }\n+            this.setWasPaused(currentWorkInfoState == WorkInfo.State.ENQUEUED);\n+            if (currentWorkInfoState == WorkInfo.State.ENQUEUED) {\n+                this.transferInfoLiveData.setValue(TransferInfo.createSystemPaused(transferId));\n+                return;\n+            }\n+            if (currentWorkInfoState == WorkInfo.State.SUCCEEDED) {\n+                this.transferInfoLiveData.setValue(TransferInfo.createCompleted(transferId));\n+                return;\n+            }\n+            if (currentWorkInfoState == WorkInfo.State.FAILED) {\n+                this.transferInfoLiveData.setValue(TransferInfo.createFailed(transferId,\n+                    tryGetWorkerErrorMessage(workInfo)));\n+                return;\n+            }\n+            Log.e(TAG, \"Received Unexpected WorkInfo event from WorkManager:\" + workInfo.toString());\n+        });\n+        return new Result(this.transferIdOrErrorLiveData,\n+            this.transferInfoLiveData,\n+            this.transferFlags);\n+    }\n+\n+    /**\n+     * Store the transfer id or error received from TransferIdOrError LiveData.\n+     *\n+     * @param transferIdOrError the transfer id or error\n+     */\n+    private void setTransferIdOrError(TransferIdOrError transferIdOrError) {\n+        if (this.inputTransferIdOrError != null && !this.inputTransferIdOrError.isError()) {\n+            if (this.inputTransferIdOrError.getId() != transferIdOrError.getId()) {\n+                Log.e(TAG,\n+                    \"Cannot be associated to a different transferId.\"\n+                        + \" existing:\" + this.inputTransferIdOrError.getId()\n+                        + \" new:\" + transferIdOrError.getId());\n+            }\n+        }\n+        this.inputTransferIdOrError = transferIdOrError;\n+    }\n+\n+    /**\n+     * Check whether the current {@link TransferInfo} event about to send to the transfer\n+     * Observer is the first event.\n+     *\n+     * @return true for first event, false otherwise\n+     */\n+    private boolean isFirstEvent() {\n+        return this.isFirstEvent;\n+    }\n+\n+    /**\n+     * Mark that the current {@link TransferInfo} event about to send to the transfer\n+     * Observer is the first event.\n+     */\n+    private void setDoneFirstEvent() {\n+        this.isFirstEvent = false;\n+    }\n+\n+    /**\n+     * Check whether the last {@link TransferInfo} event sent to the transfer Observer was\n+     * a pause event i.e. {@link TransferInfo.State#SYSTEM_PAUSED} or {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @return true if the last event was a pause event, false otherwise.\n+     */\n+    private boolean wasPaused() {\n+        return this.wasPaused;\n+    }\n+\n+    /**\n+     * Set whether the current event about to send to the transfer Observer is a pause\n+     * event i.e. {@link TransferInfo.State#SYSTEM_PAUSED} or {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param wasPaused true for pause event, false for non-pause event\n+     */\n+    private void setWasPaused(boolean wasPaused) {\n+        this.wasPaused = wasPaused;\n+    }\n+\n+    /**\n+     * Get the {@link WorkInfo.State} of the last {@link WorkInfo} event received from\n+     * the transfer worker.\n+     *\n+     * @return the workinfo state\n+     */\n+    private WorkInfo.State getLastWorkInfoState() {\n+        return this.lastWorkInfoState;\n+    }\n+\n+    /**\n+     * Store the current {@link WorkInfo.State} so that if needed it can be used while\n+     * preparing to send next event to the transfer Observer.\n+     *\n+     * @param state the WorkInfo state\n+     */\n+    private void setLastWorkInfoState(WorkInfo.State state) {\n+        this.lastWorkInfoState = state;\n+    }\n+\n+    /**\n+     * Get the LiveData that stream {@link WorkInfo} of a transfer worker corresponding to the input transfer id.\n+     *\n+     * This method uses {@link WorkManager} API to retrieve the LiveData of a transfer worker\n+     * that is processing the transfer identified by the transfer id emitted by {@code inputTransferIdOrErrorLiveData}.\n+     *\n+     * @param context the context\n+     * @return a LiveData of {@link WorkInfo}\n+     */\n+    private LiveData<WorkInfo> mapInputTransferIdToWorkInfoLiveData(Context context) {\n+        LiveData<List<WorkInfo>> workInfoListLiveData = Transformations\n+            .switchMap(\n+                this.transferIdOrErrorLiveData,\n+                transferIdOrError -> {\n+                    setTransferIdOrError(transferIdOrError);\n+                    if (this.inputTransferIdOrError.isError()) {\n+                        // An error from TransferClient. To continue the LiveData pipeline it is required\n+                        // to return non-null LiveData. Null from switchMapFunction will cut the pipeline.\n+                        MutableLiveData<List<WorkInfo>> emptyWorkInfoList = new MutableLiveData<>();\n+                        emptyWorkInfoList.setValue(null);\n+                        return emptyWorkInfoList;\n+                    } else {\n+                        // No error from TransferClient i.e. transfer work may exists, get the underlying\n+                        // LiveData<WorkInfo> for the transfer work.\n+                        final long transferId = this.inputTransferIdOrError.getId();\n+                        return WorkManager.getInstance(context)\n+                            .getWorkInfosForUniqueWorkLiveData(TransferClient.toTransferUniqueWorkName(transferId));\n+                    }\n+                }\n+            );\n+        return Transformations.map(workInfoListLiveData, workInfoList -> {\n+            if (this.inputTransferIdOrError.isError()) {\n+                // An error from TransferClient then emit null WorkInfo. The downstream should check error before\n+                // start processing the WorkInfo.\n+                return null;\n+            } else {\n+                final long transferId = this.inputTransferIdOrError.getId();\n+                if (workInfoList == null || workInfoList.isEmpty()) {\n+                    Log.e(TAG, \"Received null or Empty WorkInfo list for the transfer '\" + transferId + \"' from WorkManager.\" );\n+                    return null;\n+                }\n+                if (workInfoList.size() > 1) {\n+                    Log.e(TAG, \"Received multiple WorkInfo for the transfer '\" + transferId + \"' from WorkManager.\" );\n+                }\n+                return workInfoList.get(0);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Map any error reported by TransferClient via inputTransferIdOrError to appropriate event\n+     * in output TransferInfo LiveData.\n+     */\n+    private void mapErrorFromTransferClient() {\n+        if (this.inputTransferIdOrError.isError()) {\n+            if (this.inputTransferIdOrError.getOperation() == TransferIdOrError.Operation.RESUME) {\n+                if (this.inputTransferIdOrError.isNotFoundError()) {\n+                    // Follow the same convention as WorkManager, i.e. if an Work is\n+                    // unknown then emit null. Here application provided transfer id was not\n+                    // identifying a transfer record.\n+                    this.transferInfoLiveData.setValue(null);\n+                    this.setLastWorkInfoState(WorkInfo.State.FAILED);\n+                    return;\n+                } else if (this.inputTransferIdOrError.isTerminatedError()) {\n+                    TransferIdOrError.TransferInTerminatedStateError tError = this.inputTransferIdOrError.getError();\n+                    if (tError.isCompleted()) {\n+                        this.transferInfoLiveData\n+                            .setValue(TransferInfo.createCompleted(this.inputTransferIdOrError.getId()));\n+                        this.setLastWorkInfoState(WorkInfo.State.SUCCEEDED);\n+                        return;\n+                    }\n+                }\n+                this.transferInfoLiveData.setValue(TransferInfo.createFailed(this.inputTransferIdOrError.getId(),\n+                    this.inputTransferIdOrError.getErrorMessage()));\n+                this.setLastWorkInfoState(WorkInfo.State.FAILED);\n+                return;\n+            } else {\n+                // TransferIdOrError.Operation.UPLOAD_DOWNLOAD\n+                this.transferInfoLiveData.setValue(TransferInfo.createFailed(this.inputTransferIdOrError.getId(),\n+                    this.inputTransferIdOrError.getErrorMessage()));\n+                this.setLastWorkInfoState(WorkInfo.State.FAILED);\n+                return;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Try to retrieve transfer progress from a {@link WorkInfo}.\n+     *\n+     * @param workInfo the work info from transfer Worker\n+     * @return the progress description, null if description is not available in the WorkInfo.\n+     */\n+    private static TransferInfo.Progress tryGetWorkerProgress(WorkInfo workInfo) {\n+        Data progress = workInfo.getProgress();\n+        if (progress == null) {\n+            return null;\n+        }\n+        long totalBytes = progress.getLong(UploadWorker.Constants.PROGRESS_TOTAL_BYTES, -1);\n+        if (totalBytes == -1) {\n+            return null;\n+        }\n+        long bytesTransferred = progress.getLong(UploadWorker.Constants.PROGRESS_BYTES_UPLOADED, -1);\n+        return new TransferInfo.Progress(totalBytes, bytesTransferred);\n+    }\n+\n+    /**\n+     * Try to retrieve transfer failure message from a {@link WorkInfo}.\n+     *\n+     * @param workInfo the work info object from transfer Worker\n+     * @return the error message, null if it is not available in the work info object.\n+     */\n+    private static String tryGetWorkerErrorMessage(WorkInfo workInfo) {\n+        Data data = workInfo.getOutputData();\n+        if (data == null) {\n+            return null;\n+        }\n+        return data.getString(UploadWorker.Constants.OUTPUT_ERROR_MESSAGE_KEY);\n+    }\n+\n+    /**\n+     * Type to hold a pair consisting of transferIdOrError LiveData and associated TransferInfo LiveData.\n+     */\n+    final static class LiveDataPair {\n+        private final MutableLiveData<TransferIdOrError> transferIdOrErrorLiveData;\n+        private final LiveData<TransferInfo> transferInfoLiveData;\n+\n+        /**\n+         * Creates LiveDataPair.\n+         *\n+         * @param transferIdOrErrorLiveData the TransferIdOrError LiveData that TransferClient notify transferId\n+         * @param transferInfoLiveData the TransferInfo LiveData streaming TransferInfo of a transfer to it's Observers\n+         */\n+        LiveDataPair(@NonNull MutableLiveData<TransferIdOrError> transferIdOrErrorLiveData,\n+                     @NonNull LiveData<TransferInfo> transferInfoLiveData) {\n+            this.transferIdOrErrorLiveData = transferIdOrErrorLiveData;\n+            this.transferInfoLiveData = transferInfoLiveData;\n+        }\n+\n+        /**\n+         * Get the TransferIdOrError LiveData to notify the transferId.\n+         *\n+         * When transferId is set in this LiveData then the TransferInfo LiveData streams\n+         * TransferInfo of the transfer identified by that transfer id.\n+         *\n+         * @return the TransferIdOrError LiveData\n+         */\n+        MutableLiveData<TransferIdOrError> getTransferIdOrErrorLiveData() {\n+            return transferIdOrErrorLiveData;\n+        }\n+\n+        /**\n+         * Get the TransferInfo LiveData.\n+         *\n+         * When a transferId is set in the TransferIdOrError LiveData then this LiveData streams\n+         * TransferInfo of the transfer identified by that transfer id.\n+         *\n+         * @return the TransferInfo LiveData\n+         */\n+        LiveData<TransferInfo> getTransferInfoLiveData() {\n+            return transferInfoLiveData;\n+        }\n+    }\n+\n+    /**\n+     * Type representing result of {@link TransferIdInfoLiveData#create(Context)} method.\n+     */\n+    final static class Result {\n+        private final LiveDataPair liveDataPair;\n+        private final TransferFlags transferFlags;\n+\n+        /**\n+         * Creates Result.\n+         *\n+         * @param transferIdOrErrorLiveData the TransferIdOrError LiveData that TransferClient sets transferId\n+         * @param transferInfoLiveData the TransferInfo LiveData streaming TransferInfo\n+         * @param transferFlags the object that TransferClient methods update any flag that it want\n+         *               TransferInfo LiveData source to know\n+         */\n+        private Result(@NonNull MutableLiveData<TransferIdOrError> transferIdOrErrorLiveData,\n+                       @NonNull LiveData<TransferInfo> transferInfoLiveData,\n+                       @NonNull TransferFlags transferFlags) {\n+            this.liveDataPair = new LiveDataPair(transferIdOrErrorLiveData, transferInfoLiveData);\n+            this.transferFlags = transferFlags;\n+        }\n+\n+        /**\n+         * Get the pair of holding transferIdOrError and TransferInfo LiveData.\n+         *\n+         * @return the LiveData pair\n+         */\n+        LiveDataPair getLiveDataPair() {\n+            return this.liveDataPair;\n+        }\n+\n+        /**\n+         * Get the shared object that the TransferInfo LiveData source check for any flag\n+         * set by TransferClient methods on this transfer.\n+         *\n+         * @return the object that TransferClient methods update any flag that it want\n+         * TransferInfo LiveData source to know\n+         */\n+        TransferFlags getTransferFlags() {\n+            return this.transferFlags;\n+        }\n+    }\n+\n+    /**\n+     * Instance of this type is used by TransferClient methods to set any flag that it want\n+     * TransferInfo LiveData source of the transfer to know.\n+     *\n+     * If a transfer has any 'active Observers' then that transfer's {@link TransferFlags}\n+     * and LiveData pair (TransferInfo and TransferIdOrError LiveData) will be tracked\n+     * in the {@link TransferIdInfoLiveDataCache} cache. By 'active Observers', we mean the\n+     * Observers of TransferInfo LiveData those are not GC-ed yet hence the corresponding cache entry.\n+     *\n+     * The cache is shared across all {@link TransferClient} instances within a application process.\n+     * This enables all Observers of a transfer [e.g. Observers of upload(tid: 1), Observers of\n+     * resume(tid: 1)] to share the same source TransferInfo LiveData. Because of TransferInfo LiveData\n+     * sharing, the effect of any flag set in {@link TransferFlags} by one {@link TransferClient} will be\n+     * visible to Observers of same transfer in a different {@link TransferClient}.\n+     */\n+    final static class TransferFlags {\n+        private volatile boolean userPaused;\n+\n+        /**\n+         * Set the flag indicating that user paused a transfer by calling {@link TransferClient#pause(long)}.\n+         */\n+        void setUserPaused() {\n+            this.userPaused = true;\n+        }\n+\n+        /**\n+         * Check whether the user paused the transfer in the current session.\n+         * Note: this method reset the flag once called.\n+         *\n+         * @return true if user paused the transfer, false otherwise.\n+         */\n+        @MainThread\n+        boolean isUserPaused() {\n+            boolean b = this.userPaused;\n+            this.userPaused = false;", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NzY0Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408487647", "bodyText": "No specific reasons just to view it as one time consumable value.", "author": "anuchandy", "createdAt": "2020-04-14T23:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MTYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MTUwNg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408491506", "bodyText": "and Nothing breaks if we remove it :)", "author": "anuchandy", "createdAt": "2020-04-14T23:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MTYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU1OTM2OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408559369", "bodyText": "now I remember why it is a one-time consumable value because if there is a cancellation after a pause, we don't want to treat that as a pause.", "author": "anuchandy", "createdAt": "2020-04-15T03:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MTYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMTUyOQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410521529", "bodyText": "Probably just add a clarifying comment. I'm sure this question will come up again in the future otherwise.", "author": "bsiegel", "createdAt": "2020-04-18T00:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MTYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MjM4MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408452381", "bodyText": "What is was the reasoning behind making this class public? It seems it is only used within this package. Is the decision related to how the GC works?", "author": "vcolin7", "createdAt": "2020-04-14T21:39:48Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdInfoLiveDataCache.java", "diffHunk": "@@ -0,0 +1,220 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.MainThread;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MutableLiveData;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.util.HashMap;\n+\n+import com.azure.android.storage.blob.transfer.TransferIdInfoLiveData.TransferFlags;\n+\n+/**\n+ * A Hash table based cache, with each entry has transferId as 'key' and 'value' as reference\n+ * to {@link TransferFlags}, {@link LiveData<TransferIdOrError>} and weak reference to\n+ * {@link LiveData<TransferInfo>}.\n+ *\n+ * The LiveData pair, i.e. TransferIdOrError LiveData and the TransferInfo LiveData\n+ * in a 'value' is related such that, when transferId set on TransferIdOrError LiveData\n+ * then transferInfo of corresponding transfer will start streaming from TransferInfo\n+ * LiveData.\n+ *\n+ * A cache entry will automatically be removed when the TransferInfo LiveData in\n+ * that entry's value is no longer in ordinary use. The presence of weak reference to it\n+ * in the cache entry will not prevent it being collected by the garbage collector.\n+ *\n+ * This cache is not synchronized explicitly but implicitly synchronized by enforcing its\n+ * methods to be accessible only from the main thread.\n+ *\n+ * The cache is designed to shared across all {@link TransferClient} instances within the\n+ * same application process. This enables all Observers of a transfer [e.g. Observers of\n+ * upload(tid: 1), Observers of resume(tid: 1)] to listen to same TransferInfo LiveData,\n+ * irrespective of the TransferClient they used to get the TransferInfo LiveData.\n+ *\n+ * The cache implementation assumes that the TransferIdOrError LiveData in the value\n+ * do not strongly refer to the TransferInfo LiveData in the same value either\n+ * directly or indirectly, since that will prevent the TransferIdOrError LiveData\n+ * from being collected.\n+ */\n+final public class TransferIdInfoLiveDataCache {", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NjAxNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408476014", "bodyText": "good catch! this must be a package-private, being public is a typo.", "author": "anuchandy", "createdAt": "2020-04-14T22:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1MjM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NjIzNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408456234", "bodyText": "Is it a convention to name MutableLiveData objects channels?", "author": "vcolin7", "createdAt": "2020-04-14T21:48:06Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -73,39 +76,133 @@ private TransferClient(Context context,\n      * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n      */\n     public LiveData<TransferInfo> upload(String containerName, String blobName, File file) {\n-        MutableLiveData<Long> transferIdLiveData = new MutableLiveData<>();\n+        // UI_Thread\n+        final MutableLiveData<TransferIdOrError> idOrErrorChannel = new MutableLiveData<>();\n         this.serialTaskExecutor.execute(() -> {\n-            BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n-            List<BlockUploadEntity> blocks\n-                = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n-            long uploadId = db.uploadDao().createUploadRecord(blob, blocks);\n-            Log.v(TAG, \"upload(): upload record created: \" + uploadId);\n-\n-            StorageBlobClientsMap.put(uploadId, blobClient);\n-\n-            Data inputData = new Data.Builder()\n-                .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, uploadId)\n-                .build();\n-            OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n-                .Builder(UploadWorker.class)\n-                .setConstraints(constraints)\n-                .setInputData(inputData)\n-                .build();\n-\n-            Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + uploadId);\n-            WorkManager.getInstance(context)\n-                .beginUniqueWork(toTransferUniqueWorkName(uploadId),\n-                    ExistingWorkPolicy.KEEP,\n-                    uploadWorkRequest)\n-                .enqueue();\n-            transferIdLiveData.postValue(uploadId);\n+            // BG_Thread\n+            try {\n+                BlobUploadEntity blob = new BlobUploadEntity(containerName, blobName, file);\n+                List<BlockUploadEntity> blocks\n+                    = BlockUploadEntity.createEntitiesForFile(file, Constants.DEFAULT_BLOCK_SIZE);\n+                long transferId = db.uploadDao().createUploadRecord(blob, blocks);\n+                Log.v(TAG, \"upload(): upload record created: \" + transferId);\n+\n+                StorageBlobClientsMap.put(transferId, blobClient);\n+\n+                Data inputData = new Data.Builder()\n+                    .putLong(UploadWorker.Constants.INPUT_BLOB_UPLOAD_ID_KEY, transferId)\n+                    .build();\n+                OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest\n+                    .Builder(UploadWorker.class)\n+                    .setConstraints(constraints)\n+                    .setInputData(inputData)\n+                    .build();\n+\n+                Log.v(TAG, \"upload(): enqueuing UploadWorker: \" + transferId);\n+                WorkManager.getInstance(context)\n+                    .beginUniqueWork(toTransferUniqueWorkName(transferId),\n+                        ExistingWorkPolicy.KEEP,\n+                        uploadWorkRequest)\n+                    .enqueue();\n+                idOrErrorChannel.postValue(TransferIdOrError.id(TransferIdOrError.Operation.UPLOAD_DOWNLOAD, transferId));\n+            } catch (Exception e) {\n+                idOrErrorChannel.postValue(TransferIdOrError.error(TransferIdOrError.Operation.UPLOAD_DOWNLOAD, e));\n+            }\n+        });\n+        // UI_Thread\n+        return toCachedTransferInfoLiveData(idOrErrorChannel, false);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer id. The pause operation\n+     * is a best-effort and it is possible that a transfer that is already executing\n+     * may continue to transfer.\n+     *\n+     * Upon successful scheduling of the pause, any observer observing on\n+     * {@link LiveData<TransferInfo>} for this transfer receives a {@link TransferInfo}\n+     * event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param transferId the transfer id identifies the transfer to pause.\n+     */\n+    // P2: Currently no return value, evaluate any possible return value later.\n+    public void pause(long transferId) {\n+        // UI_Thread\n+        final TransferIdInfoLiveData.TransferFlags transferFlags = TRANSFER_ID_INFO_CACHE.getTransferFlags(transferId);\n+        this.serialTaskExecutor.execute(() -> {\n+            // BG_Thread\n+            try {\n+                final PauseCheck pauseCheck = checkPauseable(transferId);\n+                if (pauseCheck.canPause) {\n+                    if (pauseCheck.isUpload) {\n+                        db.uploadDao().updateUploadInterruptState(transferId, UploadInterruptState.USER_PAUSED);\n+                    } else {\n+                        throw new RuntimeException(\"Download::pause() NotImplemented\");\n+                    }\n+                    if (transferFlags != null) {\n+                        transferFlags.setUserPaused();\n+                    }\n+                    WorkManager\n+                        .getInstance(context)\n+                        .cancelUniqueWork(toTransferUniqueWorkName(transferId));\n+                }\n+            } catch (Exception e) {\n+                Log.e(TAG, \"Unable to schedule pause for the transfer:\" + transferId, e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Resume a transfer that was paused.\n+     *\n+     * @param @param transferId the transfer id identifies the transfer to resume.\n+     * @return LiveData that streams {@link TransferInfo} describing current state of the transfer\n+     */\n+    public LiveData<TransferInfo> resume(long transferId) {\n+        // UI_Thread\n+        final MutableLiveData<TransferIdOrError> idOrErrorChannel = new MutableLiveData<>();", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NzA1Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408477052", "bodyText": "there is no convention like that, just my own convention, memories of Go :) We can remove that suffix.", "author": "anuchandy", "createdAt": "2020-04-14T22:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NjIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDc5Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410520796", "bodyText": "I like the channel nomenclature myself. It's easier for me to think of LiveDatas as just channels.", "author": "bsiegel", "createdAt": "2020-04-18T00:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NjIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2MDUwMw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408460503", "bodyText": "When would we get more than one WorkInfo? When the operation has been paused and resumed multiple times for example? If so, why do we only return the first one? Does that mean they all contain the same info?", "author": "vcolin7", "createdAt": "2020-04-14T21:57:36Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdInfoLiveData.java", "diffHunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.MainThread;\n+import androidx.annotation.NonNull;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MediatorLiveData;\n+import androidx.lifecycle.MutableLiveData;\n+import androidx.lifecycle.Transformations;\n+import androidx.work.Data;\n+import androidx.work.WorkInfo;\n+import androidx.work.WorkManager;\n+\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type to create the LiveData pair, a {@link TransferIdOrError} LiveData and associated {@link TransferInfo}\n+ * LiveData. Each transfer will have such a unique LiveData pair.\n+ *\n+ * When transfer id is set to TransferIdOrError LiveData then TransferInfo LiveData streams {@link TransferInfo}\n+ * events describing current state of the transfer identified by the transfer id. Internally the source of the\n+ * TransferInfo LiveData queries {@link WorkManager} for a LiveData that streams {@link WorkInfo} and transform\n+ * {@link WorkInfo} events to {@link TransferInfo} events.\n+ *\n+ * Same transfer id can be set multiple times in the TransferIdOrError LiveData. Each such set results in querying\n+ * {@link WorkManager} as described above. There can be active Observes for an original transfer when it is paused\n+ * and later resumed by a different Worker. When possible we share the same LiveData pair between original transfer\n+ * and it's resume. In such cases, the ability to set transfer id on the TransferIdOrError LiveData multiple times\n+ * enables to transparently switch the Worker and keep any existing Observers of the original transfer to continue\n+ * to receive the {@link TransferInfo} events.\n+ *\n+ * @see TransferIdInfoLiveDataCache (for LiveData pair sharing)\n+ */\n+final class TransferIdInfoLiveData {\n+    private static final String TAG = TransferIdInfoLiveData.class.getSimpleName();\n+    // the input LiveData that receives the transfer id or error.\n+    private final MutableLiveData<TransferIdOrError> transferIdOrErrorLiveData = new MutableLiveData<>();\n+    // the output TransferInfo LiveData.\n+    private final MediatorLiveData<TransferInfo> transferInfoLiveData = new MediatorLiveData<>();\n+    // the the object that TransferClient methods update any state that it want TransferInfo LiveData source\n+    // for a transfer to know.\n+    private final TransferFlags transferFlags = new TransferFlags();\n+    // the recent TransferIdOrError object emitted by the transferIdOrErrorLiveData object.\n+    private TransferIdOrError inputTransferIdOrError;\n+    // hold the state of the last WorkInfo received from Transfer Worker.\n+    private WorkInfo.State lastWorkInfoState;\n+    // flag to track whether current event about to emit from transferInfoLiveData is the first event.\n+    private boolean isFirstEvent = true;\n+    // flag to track whether the last emitted event from transferInfoLiveData was a pause event.\n+    private boolean wasPaused;\n+\n+    private TransferIdInfoLiveData() {}\n+\n+    @MainThread\n+    static TransferIdInfoLiveData.Result create(Context context) {\n+        TransferIdInfoLiveData transferIdInfoLiveData = new TransferIdInfoLiveData();\n+        return transferIdInfoLiveData.init(context);\n+    }\n+\n+    private TransferIdInfoLiveData.Result init(@NonNull Context context) {\n+        // 1. Register mapping of transferId to LiveData<WorkInfo>\n+        LiveData<WorkInfo> workInfoLiveData = this.mapInputTransferIdToWorkInfoLiveData(context);\n+        // 2. Register mapping of LiveData<WorkInfo> to LiveData<TransferInfo>\n+        this.transferInfoLiveData.addSource(workInfoLiveData, workInfo -> {\n+            if (this.inputTransferIdOrError.isError()) {\n+                mapErrorFromTransferClient();\n+                return;\n+            }\n+            if (workInfo == null) {\n+                Log.v(TAG, \"Skipping Null 'WorkInfo' from WorkManager.\");\n+                return;\n+            }\n+\n+            final WorkInfo.State lastWorkInfoState = getLastWorkInfoState();\n+            if (lastWorkInfoState != null) {\n+                if (lastWorkInfoState == WorkInfo.State.SUCCEEDED\n+                    || lastWorkInfoState == WorkInfo.State.FAILED\n+                    || (lastWorkInfoState == WorkInfo.State.CANCELLED && !this.wasPaused())) {\n+                    Log.e(TAG, \"Received an unexpected 'WorkInfo' from WorkManager after terminal state:\"\n+                        + workInfo.toString());\n+                    return;\n+                }\n+            }\n+\n+            WorkInfo.State currentWorkInfoState = workInfo.getState();\n+            if (currentWorkInfoState == null) {\n+                Log.v(TAG, \"Skipping the 'WorkInfo' from WorkManager with Null state.\");\n+                return;\n+            }\n+            final long transferId = this.inputTransferIdOrError.getId();\n+            this.setLastWorkInfoState(currentWorkInfoState);\n+            if (this.isFirstEvent()) {\n+                this.setDoneFirstEvent();\n+                this.setWasPaused(false);\n+                this.transferInfoLiveData.setValue(TransferInfo.createStarted(transferId));\n+                if (currentWorkInfoState == WorkInfo.State.ENQUEUED) {\n+                    // the worker state can be WorkInfo.State.ENQUEUED in two cases -\n+                    // 1. When work is scheduled for the first time.\n+                    // 2. When work is paused by the system (e.g. no network).\n+                    //\n+                    // The #1 is mapped to TransferInfo.State.STARTED\n+                    // and #2 is mapped to TransferInfo.State.SYSTEM_PAUSED\n+                    //\n+                    // The outer block handled #1 by sending TransferInfo.State.STARTED\n+                    // hence returning.\n+                    return;\n+                }\n+            }\n+            if (currentWorkInfoState == WorkInfo.State.RUNNING) {\n+                if (this.wasPaused()) {\n+                    this.transferInfoLiveData.setValue(TransferInfo.createResumed(transferId));\n+                }\n+                this.setWasPaused(false);\n+                TransferInfo.Progress progress = tryGetWorkerProgress(workInfo);\n+                if (progress != null) {\n+                    this.transferInfoLiveData.setValue(TransferInfo.createProgress(transferId, progress));\n+                }\n+                return;\n+            }\n+            if (currentWorkInfoState == WorkInfo.State.CANCELLED) {\n+                if (this.transferFlags.isUserPaused()) {\n+                    this.setWasPaused(true);\n+                    this.transferInfoLiveData.setValue(TransferInfo.createUserPaused(transferId));\n+                } else {\n+                    this.setWasPaused(false);\n+                    this.transferInfoLiveData.setValue(TransferInfo.createCancelled(transferId));\n+                }\n+                return;\n+            }\n+            this.setWasPaused(currentWorkInfoState == WorkInfo.State.ENQUEUED);\n+            if (currentWorkInfoState == WorkInfo.State.ENQUEUED) {\n+                this.transferInfoLiveData.setValue(TransferInfo.createSystemPaused(transferId));\n+                return;\n+            }\n+            if (currentWorkInfoState == WorkInfo.State.SUCCEEDED) {\n+                this.transferInfoLiveData.setValue(TransferInfo.createCompleted(transferId));\n+                return;\n+            }\n+            if (currentWorkInfoState == WorkInfo.State.FAILED) {\n+                this.transferInfoLiveData.setValue(TransferInfo.createFailed(transferId,\n+                    tryGetWorkerErrorMessage(workInfo)));\n+                return;\n+            }\n+            Log.e(TAG, \"Received Unexpected WorkInfo event from WorkManager:\" + workInfo.toString());\n+        });\n+        return new Result(this.transferIdOrErrorLiveData,\n+            this.transferInfoLiveData,\n+            this.transferFlags);\n+    }\n+\n+    /**\n+     * Store the transfer id or error received from TransferIdOrError LiveData.\n+     *\n+     * @param transferIdOrError the transfer id or error\n+     */\n+    private void setTransferIdOrError(TransferIdOrError transferIdOrError) {\n+        if (this.inputTransferIdOrError != null && !this.inputTransferIdOrError.isError()) {\n+            if (this.inputTransferIdOrError.getId() != transferIdOrError.getId()) {\n+                Log.e(TAG,\n+                    \"Cannot be associated to a different transferId.\"\n+                        + \" existing:\" + this.inputTransferIdOrError.getId()\n+                        + \" new:\" + transferIdOrError.getId());\n+            }\n+        }\n+        this.inputTransferIdOrError = transferIdOrError;\n+    }\n+\n+    /**\n+     * Check whether the current {@link TransferInfo} event about to send to the transfer\n+     * Observer is the first event.\n+     *\n+     * @return true for first event, false otherwise\n+     */\n+    private boolean isFirstEvent() {\n+        return this.isFirstEvent;\n+    }\n+\n+    /**\n+     * Mark that the current {@link TransferInfo} event about to send to the transfer\n+     * Observer is the first event.\n+     */\n+    private void setDoneFirstEvent() {\n+        this.isFirstEvent = false;\n+    }\n+\n+    /**\n+     * Check whether the last {@link TransferInfo} event sent to the transfer Observer was\n+     * a pause event i.e. {@link TransferInfo.State#SYSTEM_PAUSED} or {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @return true if the last event was a pause event, false otherwise.\n+     */\n+    private boolean wasPaused() {\n+        return this.wasPaused;\n+    }\n+\n+    /**\n+     * Set whether the current event about to send to the transfer Observer is a pause\n+     * event i.e. {@link TransferInfo.State#SYSTEM_PAUSED} or {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param wasPaused true for pause event, false for non-pause event\n+     */\n+    private void setWasPaused(boolean wasPaused) {\n+        this.wasPaused = wasPaused;\n+    }\n+\n+    /**\n+     * Get the {@link WorkInfo.State} of the last {@link WorkInfo} event received from\n+     * the transfer worker.\n+     *\n+     * @return the workinfo state\n+     */\n+    private WorkInfo.State getLastWorkInfoState() {\n+        return this.lastWorkInfoState;\n+    }\n+\n+    /**\n+     * Store the current {@link WorkInfo.State} so that if needed it can be used while\n+     * preparing to send next event to the transfer Observer.\n+     *\n+     * @param state the WorkInfo state\n+     */\n+    private void setLastWorkInfoState(WorkInfo.State state) {\n+        this.lastWorkInfoState = state;\n+    }\n+\n+    /**\n+     * Get the LiveData that stream {@link WorkInfo} of a transfer worker corresponding to the input transfer id.\n+     *\n+     * This method uses {@link WorkManager} API to retrieve the LiveData of a transfer worker\n+     * that is processing the transfer identified by the transfer id emitted by {@code inputTransferIdOrErrorLiveData}.\n+     *\n+     * @param context the context\n+     * @return a LiveData of {@link WorkInfo}\n+     */\n+    private LiveData<WorkInfo> mapInputTransferIdToWorkInfoLiveData(Context context) {\n+        LiveData<List<WorkInfo>> workInfoListLiveData = Transformations\n+            .switchMap(\n+                this.transferIdOrErrorLiveData,\n+                transferIdOrError -> {\n+                    setTransferIdOrError(transferIdOrError);\n+                    if (this.inputTransferIdOrError.isError()) {\n+                        // An error from TransferClient. To continue the LiveData pipeline it is required\n+                        // to return non-null LiveData. Null from switchMapFunction will cut the pipeline.\n+                        MutableLiveData<List<WorkInfo>> emptyWorkInfoList = new MutableLiveData<>();\n+                        emptyWorkInfoList.setValue(null);\n+                        return emptyWorkInfoList;\n+                    } else {\n+                        // No error from TransferClient i.e. transfer work may exists, get the underlying\n+                        // LiveData<WorkInfo> for the transfer work.\n+                        final long transferId = this.inputTransferIdOrError.getId();\n+                        return WorkManager.getInstance(context)\n+                            .getWorkInfosForUniqueWorkLiveData(TransferClient.toTransferUniqueWorkName(transferId));\n+                    }\n+                }\n+            );\n+        return Transformations.map(workInfoListLiveData, workInfoList -> {\n+            if (this.inputTransferIdOrError.isError()) {\n+                // An error from TransferClient then emit null WorkInfo. The downstream should check error before\n+                // start processing the WorkInfo.\n+                return null;\n+            } else {\n+                final long transferId = this.inputTransferIdOrError.getId();\n+                if (workInfoList == null || workInfoList.isEmpty()) {\n+                    Log.e(TAG, \"Received null or Empty WorkInfo list for the transfer '\" + transferId + \"' from WorkManager.\" );\n+                    return null;\n+                }\n+                if (workInfoList.size() > 1) {", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NzEyNg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r408487126", "bodyText": "WorkManager supports chaining of workers and assigning a name to the chain, in such cases this WorkManager API returns a List of WorkInfo. In our case chaining is not used and each transfer/work has a unique name.", "author": "anuchandy", "createdAt": "2020-04-14T23:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2MDUwMw=="}], "type": "inlineReview"}, {"oid": "8ad35992f0d349a3097ecd53080a7b2d75e1dfa8", "url": "https://github.com/Azure/azure-sdk-for-android/commit/8ad35992f0d349a3097ecd53080a7b2d75e1dfa8", "message": "Better javadoc, removing unneed public visibility in transfer types, removing 'channel' suffix for LiveData variables name.", "committedDate": "2020-04-15T03:36:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxODYyNQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410518625", "bodyText": "I feel like maybe we should just make a generic Result<TSuccess, TErr> type we can use instead of this. I discovered that this is somehow not a thing that Java includes itself.", "author": "bsiegel", "createdAt": "2020-04-17T23:54:29Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdOrError.java", "diffHunk": "@@ -0,0 +1,112 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import androidx.annotation.NonNull;\n+\n+/**\n+ * Package private.\n+ *\n+ * The type used by the methods in {@link TransferClient} (e.g. upload, download, resume) to\n+ * communicate data from background {@link SerialExecutor} to {@link TransferIdMappedToTransferInfo}.\n+ *\n+ * The data includes the operation type, the actual transfer id of a transfer or an error indicating\n+ * the failure detected by TransferClient. Note that this type is used only to channel the error that\n+ * TransferClient methods encountered or could detect, this type is not used to channel the real time\n+ * error happened in the background worker.\n+ */\n+public final class TransferIdOrError {", "originalCommit": "7f18255f1119be4439ef13bd552a11bc07c23087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjE3MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410522171", "bodyText": "Seeing the changes here later on. Still think we should make this a more generic name, but maybe not an actual generic type. Perhaps something like TransferOperationResult?", "author": "bsiegel", "createdAt": "2020-04-18T00:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxODYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzQ3Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410523472", "bodyText": "yes, I was thinking the same, generic type is something we can think if we encounter more scenarios where we need to pass value-error through LiveData. TransferOperationResult looks good to me.", "author": "anuchandy", "createdAt": "2020-04-18T00:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxODYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDIyMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410520222", "bodyText": "I don't understand this comment, can you maybe reword? It's not clear to me at this point what the TransferFlags are for. Maybe this encapsulates the different states a transfer can be in?", "author": "bsiegel", "createdAt": "2020-04-18T00:03:16Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdInfoLiveData.java", "diffHunk": "@@ -35,6 +35,9 @@\n     private final MutableLiveData<TransferIdOrError> transferIdOrErrorLiveData = new MutableLiveData<>();\n     // the output TransferInfo LiveData.\n     private final MediatorLiveData<TransferInfo> transferInfoLiveData = new MediatorLiveData<>();\n+    // the the object that TransferClient methods update any state that it want TransferInfo LiveData source", "originalCommit": "68ee38e04e403bc8a2fb3984ecc39e19c8c2d2d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDU0NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410520545", "bodyText": "Is this not just the same as a while loop? I'm fine with it but seeing this for-loop syntax is more confusing to me.", "author": "bsiegel", "createdAt": "2020-04-18T00:05:04Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdInfoLiveDataCache.java", "diffHunk": "@@ -0,0 +1,218 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.MainThread;\n+import androidx.lifecycle.LiveData;\n+import androidx.lifecycle.MutableLiveData;\n+\n+import com.azure.android.storage.blob.transfer.TransferIdInfoLiveData.TransferFlags;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.util.HashMap;\n+\n+/**\n+ * A Hash table based cache, with each entry has transferId as 'key' and 'value' as reference\n+ * to {@link TransferFlags}, {@link LiveData< TransferIdOrError >} and weak reference to\n+ * {@link LiveData< TransferInfo >}.\n+ *\n+ * The LiveData pair, i.e. TransferIdOrError LiveData and the TransferInfo LiveData\n+ * in a 'value' is related such that, when transferId set on TransferIdOrError LiveData\n+ * then transferInfo of corresponding transfer will start streaming from TransferInfo\n+ * LiveData.\n+ *\n+ * A cache entry will automatically be removed when the TransferInfo LiveData in\n+ * that entry's value is no longer in ordinary use. The presence of weak reference to it\n+ * in the cache entry will not prevent it being collected by the garbage collector.\n+ *\n+ * This cache is not synchronized explicitly but implicitly synchronized by enforcing its\n+ * methods to be accessible only from the main thread.\n+ *\n+ * The cache is designed to shared across all {@link TransferClient} instances within the\n+ * same application process.\n+ *\n+ * The cache implementation assumes that the TransferIdOrError LiveData in the value\n+ * do not strongly refer to the TransferInfo LiveData in the same value either\n+ * directly or indirectly, since that will prevent the TransferIdOrError LiveData\n+ * from being collected.\n+ */\n+final class TransferIdInfoLiveDataCache {\n+    private static final String TAG = TransferIdInfoLiveDataCache.class.getSimpleName();\n+    // the internal map with each Entry in the format\n+    //  {\n+    //    key: transferId,\n+    //    value: {\n+    //        weak-ref: LiveData<TransferInfo>,\n+    //        ref: LiveData<TransferIdOrError>,\n+    //        ref: transferFlags\n+    //    }\n+    //  }\n+    private final HashMap<Long, TransferInfoLiveDataWeakReference> map = new HashMap<>();\n+    // Reference queue that GC enqueues the map value holding collected weak-ref.\n+    private final ReferenceQueue<LiveData<TransferInfo>> queue = new ReferenceQueue<>();\n+\n+    /**\n+     * Create a TransferIdOrError LiveData and a TransferInfo LiveData, associate it\n+     * with given {@code transferId} parameter and store them in the cache. This method return these\n+     * two LiveData in a {@Link TransferIdInfoLiveData#Pair}.\n+     *\n+     * When a transferId is set to TransferIdOrError LiveData then the TransferInfo LiveData stream\n+     * TransferInfo of the Transfer identified by that transferId. When transferId is set to\n+     * the TransferIdOrError LiveData it must be same as the transferId parameter.\n+     *\n+     * @param transferId the transferId to use as the key to identify the created LiveData\n+     *                   instances.\n+     * @param context the context\n+     * @return the pair composing created {@code TransferIdOrError} LiveData and associated\n+     * {@code TransferInfo} LiveData\n+     */\n+    @MainThread\n+    public TransferIdInfoLiveData.LiveDataPair create(long transferId, Context context) {\n+        this.expunge();\n+        final TransferIdInfoLiveData.Result result = TransferIdInfoLiveData.create(context);\n+        final TransferIdInfoLiveData.LiveDataPair liveDataPair = result.getLiveDataPair();\n+        this.map.put(transferId,\n+            new TransferInfoLiveDataWeakReference(liveDataPair.getTransferInfoLiveData(),\n+                liveDataPair.getTransferIdOrErrorLiveData(),\n+                result.getTransferFlags(),\n+                transferId,\n+                this.queue));\n+        return liveDataPair;\n+    }\n+\n+    /**\n+     * Check whether the TransferIdOrError LiveData and the TransferInfo LiveData that is identified\n+     * by the given {@code transferId} key already exists in the cache, if it exists then return\n+     * the two LiveData in a {@Link TransferIdInfoLiveData#Pair}. If it does not exists then create,\n+     * store and return them, see {@link TransferIdInfoLiveDataCache#create(long, Context)}\n+     * for more details.\n+     *\n+     * @param transferId the transferId to use as the key to identify the LiveData instances.\n+     * @param context the context\n+     * @return the pair composing created TransferIdOrError LiveData and associated TransferInfo LiveData\n+     */\n+    @MainThread\n+    public TransferIdInfoLiveData.LiveDataPair getOrCreate(long transferId, Context context) {\n+        this.expunge();\n+        final TransferInfoLiveDataWeakReference ref = this.map.get(transferId);\n+        if (ref != null) {\n+            final LiveData<TransferInfo> transferInfoLiveData = ref.get();\n+            if (transferInfoLiveData != null) {\n+                return new TransferIdInfoLiveData.LiveDataPair(ref.getTransferIdLiveData(),\n+                    transferInfoLiveData);\n+            }\n+        }\n+        return create(transferId, context);\n+    }\n+\n+    /**\n+     * Get the Flag object that the TransferInfo LiveData source (that backs TransferInfo LiveData\n+     * in the weak reference) check for any flag set by TransferClient methods on the transfer.\n+     *\n+     * @param transferId the transferId identifies the {@link TransferFlags} for the transfer\n+     * @return the {@link TransferFlags}\n+     */\n+    @MainThread\n+    public TransferIdInfoLiveData.TransferFlags getTransferFlags(long transferId) {\n+        this.expunge();\n+        final TransferInfoLiveDataWeakReference ref = this.map.get(transferId);\n+        if (ref != null) {\n+            return ref.getTransferFlags();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Expunges stale entries (containing already GCed {@code TransferInfo} LiveData) from the map.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void expunge() {\n+        int cnt = 0;\n+        for (Reference<?> staledReference; (staledReference = this.queue.poll()) != null;) {", "originalCommit": "68ee38e04e403bc8a2fb3984ecc39e19c8c2d2d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkzOA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410522938", "bodyText": "I see, yea while is more cleaner/readable, will switch to it.", "author": "anuchandy", "createdAt": "2020-04-18T00:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDcyMA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410520720", "bodyText": "What causes the behavior described?", "author": "bsiegel", "createdAt": "2020-04-18T00:05:59Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -101,16 +104,105 @@ private TransferClient(Context context,\n                         ExistingWorkPolicy.KEEP,\n                         uploadWorkRequest)\n                     .enqueue();\n-                idOrErrorChannel.postValue(TransferIdOrError.id(transferId));\n+                idOrErrorChannel.postValue(TransferIdOrError.id(TransferIdOrError.Operation.UPLOAD_DOWNLOAD, transferId));\n             } catch (Exception e) {\n-                idOrErrorChannel.postValue(TransferIdOrError.error(e));\n+                idOrErrorChannel.postValue(TransferIdOrError.error(TransferIdOrError.Operation.UPLOAD_DOWNLOAD, e));\n             }\n         });\n-        return liveDataPair.getTransferInfoLiveData();\n+        // UI_Thread\n+        return toCachedTransferInfoLiveData(idOrErrorChannel, false);\n     }\n \n     /**\n-     * Get the name for a unique transfer work.\n+     * Pause a transfer identified by the given transfer id. The pause operation\n+     * is a best-effort and it is possible that a transfer that is already executing\n+     * may continue to transfer.", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410522819", "bodyText": "it's uplifted from WorkManager cancel API doc. WorkManager::Worker::cancel() is best effort.", "author": "anuchandy", "createdAt": "2020-04-18T00:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMTI4MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410521280", "bodyText": "\u2764\ufe0f", "author": "bsiegel", "createdAt": "2020-04-18T00:09:31Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdInfoLiveData.java", "diffHunk": "@@ -84,6 +101,15 @@ private TransferIdInfoLiveData() {}\n                 this.setWasPaused(false);\n                 this.transferInfoLiveData.setValue(TransferInfo.createStarted(transferId));\n                 if (currentWorkInfoState == WorkInfo.State.ENQUEUED) {\n+                    // the worker state can be WorkInfo.State.ENQUEUED in two cases -", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMTQ0OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410521449", "bodyText": "Unclear what this comment is for", "author": "bsiegel", "createdAt": "2020-04-18T00:10:21Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferIdInfoLiveData.java", "diffHunk": "@@ -241,20 +285,44 @@ private void setLastWorkInfoState(WorkInfo.State state) {\n      */\n     private void mapErrorFromTransferClient() {\n         if (this.inputTransferIdOrError.isError()) {\n-            this.transferInfoLiveData.setValue(TransferInfo.createFailed(this.inputTransferIdOrError.getId(),\n-                this.inputTransferIdOrError.getErrorMessage()));\n-            this.setLastWorkInfoState(WorkInfo.State.FAILED);\n-            return;\n+            if (this.inputTransferIdOrError.getOperation() == TransferIdOrError.Operation.RESUME) {\n+                if (this.inputTransferIdOrError.isNotFoundError()) {\n+                    // Follow the same convention as WorkManager, i.e. if an Work is\n+                    // unknown then emit null. Here application provided transfer id was not\n+                    // identifying a transfer record.\n+                    this.transferInfoLiveData.setValue(null);\n+                    this.setLastWorkInfoState(WorkInfo.State.FAILED);\n+                    return;\n+                } else if (this.inputTransferIdOrError.isTerminatedError()) {\n+                    TransferIdOrError.TransferInTerminatedStateError tError = this.inputTransferIdOrError.getError();\n+                    if (tError.isCompleted()) {\n+                        this.transferInfoLiveData\n+                            .setValue(TransferInfo.createCompleted(this.inputTransferIdOrError.getId()));\n+                        this.setLastWorkInfoState(WorkInfo.State.SUCCEEDED);\n+                        return;\n+                    }\n+                }\n+                this.transferInfoLiveData.setValue(TransferInfo.createFailed(this.inputTransferIdOrError.getId(),\n+                    this.inputTransferIdOrError.getErrorMessage()));\n+                this.setLastWorkInfoState(WorkInfo.State.FAILED);\n+                return;\n+            } else {\n+                // TransferIdOrError.Operation.UPLOAD_DOWNLOAD", "originalCommit": "189d1be3d051aa840ae3d5e9b228b7fb59050d6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzE2Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/224#discussion_r410523166", "bodyText": "I mean, this code path hit for upload or download not for resume. I will make it more clear in the doc instead of just putting enum.", "author": "anuchandy", "createdAt": "2020-04-18T00:21:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMTQ0OQ=="}], "type": "inlineReview"}, {"oid": "80ec42a8e32c58ff666dca2ad70dc7a96e560589", "url": "https://github.com/Azure/azure-sdk-for-android/commit/80ec42a8e32c58ff666dca2ad70dc7a96e560589", "message": "Renaming TransferIdOrError to TransferOperationResult, more javadoc", "committedDate": "2020-04-21T22:52:45Z", "type": "commit"}]}