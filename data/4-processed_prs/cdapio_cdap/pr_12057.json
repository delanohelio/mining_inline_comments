{"pr_number": 12057, "pr_title": "(CDAP-16521) Turn program start completely async", "pr_createdAt": "2020-04-14T07:34:50Z", "pr_url": "https://github.com/cdapio/cdap/pull/12057", "timeline": [{"oid": "60d87d928e20b85b81b52d652e217bd58b5eea14", "url": "https://github.com/cdapio/cdap/commit/60d87d928e20b85b81b52d652e217bd58b5eea14", "message": "(CDAP-16521) Turn program start completely async\n\n- Have a separate executor in the ProgramRuntimeService for program launching", "committedDate": "2020-04-14T07:35:43Z", "type": "forcePushed"}, {"oid": "c5e235f5024f9c7ca206c1b4b0e51fde342fa740", "url": "https://github.com/cdapio/cdap/commit/c5e235f5024f9c7ca206c1b4b0e51fde342fa740", "message": "(CDAP-16521) Turn program start completely async\n\n- Have a separate executor in the ProgramRuntimeService for program launching", "committedDate": "2020-04-14T09:33:43Z", "type": "forcePushed"}, {"oid": "baa7eaa5f7b55de5635352e68f85ff3f9c1f5b6f", "url": "https://github.com/cdapio/cdap/commit/baa7eaa5f7b55de5635352e68f85ff3f9c1f5b6f", "message": "(CDAP-16521) Turn program start completely async\n\n- Have a separate executor in the ProgramRuntimeService for program launching", "committedDate": "2020-04-14T09:52:50Z", "type": "forcePushed"}, {"oid": "9794576be3a2887a56b169de0ff5c5f9e4dec741", "url": "https://github.com/cdapio/cdap/commit/9794576be3a2887a56b169de0ff5c5f9e4dec741", "message": "(CDAP-16521) Turn program start completely async\n\n- Have a separate executor in the ProgramRuntimeService for program launching", "committedDate": "2020-04-14T18:01:20Z", "type": "commit"}, {"oid": "9794576be3a2887a56b169de0ff5c5f9e4dec741", "url": "https://github.com/cdapio/cdap/commit/9794576be3a2887a56b169de0ff5c5f9e4dec741", "message": "(CDAP-16521) Turn program start completely async\n\n- Have a separate executor in the ProgramRuntimeService for program launching", "committedDate": "2020-04-14T18:01:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MzM2OQ==", "url": "https://github.com/cdapio/cdap/pull/12057#discussion_r408353369", "bodyText": "nit: this can be moved to the line above", "author": "CuriousVini", "createdAt": "2020-04-14T18:38:38Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/runtime/DelayedProgramController.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.app.runtime;\n+\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.lang.Delegator;\n+import io.cdap.cdap.internal.app.runtime.AbstractProgramController;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.api.RunId;\n+import org.apache.twill.common.Cancellable;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.function.Function;\n+\n+/**\n+ * A {@link ProgramController} that delegates all methods to another {@link ProgramController}, in which can be\n+ * set later. All method calls on this instance should be non-blocking.\n+ */\n+public final class DelayedProgramController implements ProgramController, Delegator<ProgramController> {\n+\n+  private final ProgramRunId programRunId;\n+  private final RunId runId;\n+  private final CompletableFuture<ProgramController> delegateFuture;\n+\n+  DelayedProgramController(ProgramRunId programRunId) {\n+    this.programRunId = programRunId;\n+    this.runId = RunIds.fromString(programRunId.getRun());\n+    this.delegateFuture = new CompletableFuture<>();\n+  }\n+\n+  /**\n+   * Sets the delegate {@link ProgramController} to the one provided.\n+   */\n+  void setProgramController(ProgramController controller) {\n+    delegateFuture.complete(controller);\n+  }\n+\n+  /**\n+   * Force this program controller into ERROR state if the delegating program controller hasn't been set.\n+   */\n+  void failed(Throwable t) {\n+    delegateFuture.complete(new FailedProgramController(programRunId, t));\n+  }\n+\n+  /**\n+   * Returns the {@link ProgramController} being delegated to. This method will block until the delegates is available.\n+   */\n+  @Override\n+  public ProgramController getDelegate() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture);\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public ProgramRunId getProgramRunId() {\n+    return programRunId;\n+  }\n+\n+  @Override\n+  public RunId getRunId() {\n+    return runId;\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> suspend() {\n+    return callDelegate(ProgramController::suspend);\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> resume() {\n+    return callDelegate(ProgramController::resume);\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> stop() {\n+    return callDelegate(ProgramController::stop);\n+  }\n+\n+  @Override\n+  public State getState() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture).getState();\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public Throwable getFailureCause() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture).getFailureCause();\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public Cancellable addListener(Listener listener, Executor executor) {\n+    CompletableFuture<Cancellable> cancellableFuture = new CompletableFuture<>();\n+    delegateFuture.whenComplete((programController, throwable) -> {\n+      if (throwable == null) {\n+        cancellableFuture.complete(programController.addListener(listener, executor));\n+      } else {\n+        cancellableFuture.completeExceptionally(throwable);\n+      }\n+    });\n+    return () -> {\n+      try {\n+        Uninterruptibles.getUninterruptibly(cancellableFuture).cancel();\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> command(String name, Object value) {\n+    return callDelegate(controller -> controller.command(name, value));\n+  }\n+\n+  /**\n+   * Makes a method call on the delegating {@link ProgramController} when it is available.\n+   */\n+  private ListenableFuture<ProgramController> callDelegate(\n+    Function<ProgramController, ListenableFuture<ProgramController>> callFunc\n+  ) {", "originalCommit": "9794576be3a2887a56b169de0ff5c5f9e4dec741", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5ODk4Nw==", "url": "https://github.com/cdapio/cdap/pull/12057#discussion_r408398987", "bodyText": "I intentionally make a new line to have a clear separation between the argument and the method body.", "author": "chtyim", "createdAt": "2020-04-14T19:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MzM2OQ=="}], "type": "inlineReview"}]}