{"pr_number": 12822, "pr_title": "[CDAP-17288] Added Path rewrite for temporary Checkpoint file.", "pr_createdAt": "2020-10-24T00:40:54Z", "pr_url": "https://github.com/cdapio/cdap/pull/12822", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIzOTk2MA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511239960", "bodyText": "This should be an optional rewrite controlled by cdap-site.xml", "author": "chtyim", "createdAt": "2020-10-24T01:35:45Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +231,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName())) {", "originalCommit": "cc8ed4b218f543dbb169d7e43de4bd17d016628a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg4NjQzOA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512886438", "bodyText": "@chtyim Should this feature be enabled or disabled by default?", "author": "fernst", "createdAt": "2020-10-27T17:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIzOTk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg4OTA4NA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512889084", "bodyText": "disable", "author": "chtyim", "createdAt": "2020-10-27T17:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIzOTk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MDA3Nw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511240077", "bodyText": "No need to have final", "author": "chtyim", "createdAt": "2020-10-24T01:36:00Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);", "originalCommit": "cc8ed4b218f543dbb169d7e43de4bd17d016628a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MDU2OQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511240569", "bodyText": "Why need the full class name? It can be just String.class.", "author": "chtyim", "createdAt": "2020-10-24T01:36:49Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);", "originalCommit": "cc8ed4b218f543dbb169d7e43de4bd17d016628a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MDc5Mg==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511240792", "bodyText": "Same here. Can be just StringBuilder.class", "author": "chtyim", "createdAt": "2020-10-24T01:37:14Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);", "originalCommit": "cc8ed4b218f543dbb169d7e43de4bd17d016628a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MjM4Mw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511242383", "bodyText": "Should compare with the method signature.\nMethod method = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, StringType });\n...\nif (method.equals(new Method(name, desc))) {\n   // Matched\n}", "author": "chtyim", "createdAt": "2020-10-24T01:40:53Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              name.equals(\"<init>\") &&", "originalCommit": "cc8ed4b218f543dbb169d7e43de4bd17d016628a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0Mjg5MA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511242890", "bodyText": "Also, I would suggest check if the previous instruction was a LDC \"temp\". We don't want to rewrite if the second parameter is not the constant string \"temp\"", "author": "chtyim", "createdAt": "2020-10-24T01:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MjM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5NTUyNg==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512895526", "bodyText": "@chtyim I have added logic to check wether the previous instruction to the Path constructor call is the LDC \"temp\" instruction.", "author": "fernst", "createdAt": "2020-10-27T17:38:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MjM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MzcyNg==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511243726", "bodyText": "Use the checkpointTime field instead of System.currentTimeMillis.", "author": "chtyim", "createdAt": "2020-10-24T01:43:47Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              name.equals(\"<init>\") &&\n+              Type.getObjectType(owner).equals(hadoopPathType) &&\n+              Type.getArgumentTypes(desc).length == 2 &&\n+              stringType.equals(Type.getArgumentTypes(desc)[0]) &&\n+              stringType.equals(Type.getArgumentTypes(desc)[1])) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              super.visitInsn(Opcodes.POP);\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.", "originalCommit": "cc8ed4b218f543dbb169d7e43de4bd17d016628a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0NDIzMQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511244231", "bodyText": "For generating code, it's easier to use GeneratorAdapter instead of MethodVisitor directly.", "author": "chtyim", "createdAt": "2020-10-24T01:44:47Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {", "originalCommit": "cc8ed4b218f543dbb169d7e43de4bd17d016628a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MjUwNg==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512892506", "bodyText": "no need to have final", "author": "chtyim", "createdAt": "2020-10-27T17:34:54Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);", "originalCommit": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5Mjk0OA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512892948", "bodyText": "Move this as a simple boolean field in the returned inner class.", "author": "chtyim", "createdAt": "2020-10-27T17:35:23Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);", "originalCommit": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0NTIwMQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513045201", "bodyText": "Done.", "author": "fernst", "createdAt": "2020-10-27T21:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5Mjk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MzgxMw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512893813", "bodyText": "It is dangerous to pass the mv to two different MethodVisitor (one to the adapter above, one here). It is better to just return a new GeneratorAdapter here.", "author": "chtyim", "createdAt": "2020-10-27T17:36:26Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {", "originalCommit": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0NTE0OQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513045149", "bodyText": "Made some changes to return a new GeneratorAdapter.", "author": "fernst", "createdAt": "2020-10-27T21:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MzgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5ODIxOA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512898218", "bodyText": "The && should be on the next line. See https://www.oracle.com/java/technologies/javase/codeconventions-indentation.html#248", "author": "chtyim", "createdAt": "2020-10-27T17:42:00Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            if (\"temp\".equals(value)) {\n+              tempStringAddedToStack.set(true);\n+            }\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&", "originalCommit": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwOTk5Mw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512909993", "bodyText": "Should document how the source code looks like. The bytecode is already as part of the code down below, no need to repeat that.", "author": "chtyim", "createdAt": "2020-10-27T17:56:55Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            if (\"temp\".equals(value)) {\n+              tempStringAddedToStack.set(true);\n+            }\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              Type.getObjectType(owner).equals(hadoopPathType) &&\n+              constructor.equals(new Method(name, desc)) &&\n+              tempStringAddedToStack.get()) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              adapter.pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.\n+              //Bytecode is:", "originalCommit": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0NDk2Nw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513044967", "bodyText": "Done.", "author": "fernst", "createdAt": "2020-10-27T21:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwOTk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkxMTQ1OQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512911459", "bodyText": "You should reset it to false when the value is not \"temp\".", "author": "chtyim", "createdAt": "2020-10-27T17:58:45Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            if (\"temp\".equals(value)) {\n+              tempStringAddedToStack.set(true);", "originalCommit": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0NDg0Nw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513044847", "bodyText": "Done.", "author": "fernst", "createdAt": "2020-10-27T21:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkxMTQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMTgwMA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513111800", "bodyText": "Since these constants are only used in the Spark runtime, I would suggest moving them to the SparkRuntimeUtils class.", "author": "chtyim", "createdAt": "2020-10-28T00:35:50Z", "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "diffHunk": "@@ -1492,4 +1492,13 @@\n      */\n     public static final String UPDATE_ALLOWED = PREFIX + \"update.allowed\";\n   }\n+\n+  /**\n+   * Constants for streaming", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTU5MQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513629591", "bodyText": "Done!", "author": "fernst", "createdAt": "2020-10-28T17:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjE3MQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513112171", "bodyText": "Better get the CConfiguration instance once as a local variable and use it throughout this method.", "author": "chtyim", "createdAt": "2020-10-28T00:37:14Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkProgramRuntimeProvider.java", "diffHunk": "@@ -90,6 +90,10 @@ public ProgramRunner createProgramRunner(ProgramType type, Mode mode, Injector i\n     Preconditions.checkArgument(type == ProgramType.SPARK, \"Unsupported program type %s. Only %s is supported\",\n                                 type, ProgramType.SPARK);\n \n+    boolean rewriteCheckpointTempFileName = injector.getInstance(CConfiguration.class)", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTY0Mw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513629643", "bodyText": "Done!", "author": "fernst", "createdAt": "2020-10-28T17:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjk4NQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513112985", "bodyText": "I would check the boolean first for a faster short circuit", "author": "chtyim", "createdAt": "2020-10-28T00:40:00Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +234,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName()) && rewriteCheckpointTempFileName) {", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEyNjczNw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513126737", "bodyText": "Good point. I wanted to keep it consistent with https://github.com/cdapio/cdap/blob/develop/cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java#L188", "author": "fernst", "createdAt": "2020-10-28T01:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEyNzAxMw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513127013", "bodyText": "Maybe worth changing both places", "author": "chtyim", "createdAt": "2020-10-28T01:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTc0OA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513629748", "bodyText": "Done!", "author": "fernst", "createdAt": "2020-10-28T17:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzExNw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513113117", "bodyText": "typo: checkpoints", "author": "chtyim", "createdAt": "2020-10-28T00:40:28Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +234,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName()) && rewriteCheckpointTempFileName) {\n+      // Rewrite the Spark CheckpointWriteHandler to add a timestamp to the temporary file used for theckpoints.", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTg1OA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513629858", "bodyText": "Fixed,", "author": "fernst", "createdAt": "2020-10-28T17:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzM2Mw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513113363", "bodyText": "You are using the checkpoint time instead of the current timestamp, right?", "author": "chtyim", "createdAt": "2020-10-28T00:41:30Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMDA2Nw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513630067", "bodyText": "Correct. I've updated the comment.", "author": "fernst", "createdAt": "2020-10-28T17:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzc1Mg==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513113752", "bodyText": "You need to override the visitField  of the ClassWriter to make sure this class actually has this field. Otherwise you can result in cryptic classloading failure", "author": "chtyim", "createdAt": "2020-10-28T00:42:59Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL\n+              && Type.getObjectType(owner).equals(hadoopPathType)\n+              && hadoopPathConstructorMethod.equals(new Method(name, desc))\n+              && tempStringAddedToStack) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.\n+              //This function generates the following code:\n+              //  new StringBuilder().append(\"temp-\").append(checkpointTime.milliseconds()).toString();\n+              newInstance(stringBuilderType);\n+              dup();\n+              invokeConstructor(stringBuilderType, Methods.getMethod(void.class, \"<init>\"));\n+              push(\"temp-\");\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"append\", stringBuilderType, new Type[]{stringType}));\n+              loadThis();\n+              getField(CHECKPOINT_WRITE_HANDLER_TYPE, checkpointTimeFieldName, timeType);", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMDE0OQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513630149", "bodyText": "Done!", "author": "fernst", "createdAt": "2020-10-28T17:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDA0NQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513114045", "bodyText": "This class shouldn't reference Spark or Hadoop classes via .class. See https://github.com/cdapio/cdap/blob/develop/cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java#L80\nOnly classes from the bootstrap classloader (i.e JRE classes) can be referenced with .class.", "author": "chtyim", "createdAt": "2020-10-28T00:44:03Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMDI5MA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513630290", "bodyText": "Done!", "author": "fernst", "createdAt": "2020-10-28T17:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDM4Mg==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513114382", "bodyText": "Remove extra empty line", "author": "chtyim", "createdAt": "2020-10-28T00:45:13Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDY2MA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513114660", "bodyText": "Please update the comment. I think you are using checkpointTime.milliseconds(), right?", "author": "chtyim", "createdAt": "2020-10-28T00:46:17Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL\n+              && Type.getObjectType(owner).equals(hadoopPathType)\n+              && hadoopPathConstructorMethod.equals(new Method(name, desc))\n+              && tempStringAddedToStack) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDkzOA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513114938", "bodyText": "Remove empty line", "author": "chtyim", "createdAt": "2020-10-28T00:47:25Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL\n+              && Type.getObjectType(owner).equals(hadoopPathType)\n+              && hadoopPathConstructorMethod.equals(new Method(name, desc))\n+              && tempStringAddedToStack) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.\n+              //This function generates the following code:\n+              //  new StringBuilder().append(\"temp-\").append(checkpointTime.milliseconds()).toString();\n+              newInstance(stringBuilderType);\n+              dup();\n+              invokeConstructor(stringBuilderType, Methods.getMethod(void.class, \"<init>\"));\n+              push(\"temp-\");\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"append\", stringBuilderType, new Type[]{stringType}));\n+              loadThis();\n+              getField(CHECKPOINT_WRITE_HANDLER_TYPE, checkpointTimeFieldName, timeType);\n+              invokeVirtual(timeType, new Method(\"milliseconds\", Type.LONG_TYPE, EMPTY_ARGS));\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"append\", stringBuilderType, new Type[]{Type.LONG_TYPE}));\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"toString\", stringType, EMPTY_ARGS));\n+\n+              LOG.debug(\"Checkpoint temp file name rewriting is ENABLED\");\n+", "originalCommit": "2c513d3b7218d532aa3f821b33a4c08ddfb24487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525", "url": "https://github.com/cdapio/cdap/commit/d66a0cb5fe770530ff7692ef50fd8d1c42b98525", "message": "Added logic to check if the Checkpoint Time field exists before attemptiing to rewrite the class.", "committedDate": "2020-10-28T16:52:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNDc3OQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513634779", "bodyText": "Generally I prefer alignment like this:\nprivate synchronized SparkRunnerClassLoader createClassLoader(boolean filterScalaClasses,\n                                                              boolean rewriteYarnClient, \n                                                              boolean rewriteCheckpointFileName) throws IOException {\n  // Code\n}\n\nAs it gives a clearer separation between method signature and the method body.", "author": "chtyim", "createdAt": "2020-10-28T17:32:49Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkProgramRuntimeProvider.java", "diffHunk": "@@ -289,8 +294,10 @@ private ProgramRunner createSparkProgramRunner(Injector injector,\n   /**\n    * Returns an array of {@link URL} being used by the {@link ClassLoader} of this {@link Class}.\n    */\n-  private synchronized SparkRunnerClassLoader createClassLoader(boolean filterScalaClasses,\n-                                                                boolean rewriteYarnClient) throws IOException {\n+  private synchronized SparkRunnerClassLoader createClassLoader(\n+    boolean filterScalaClasses,", "originalCommit": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTUwMw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513635503", "bodyText": "If the last variable is too long, it's ok to use a shorter name since it is only local to the method.", "author": "chtyim", "createdAt": "2020-10-28T17:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNDc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513636725", "bodyText": "Why need two separate constants? Can we just have one? Also, since the constant is defined inside spark, it doesn't need to be so long. E.g. It can be just CHECKPOINT_REWRITE_ENABLED.", "author": "chtyim", "createdAt": "2020-10-28T17:35:48Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkRuntimeUtils.java", "diffHunk": "@@ -84,6 +84,10 @@\n   public static final String PYSPARK_PORT_FILE_NAME = \"cdap.py4j.gateway.port.txt\";\n   public static final String PYSPARK_SECRET_FILE_NAME = \"cdap.py4j.gateway.secret.txt\";\n \n+  public static final String STREAMING_CHECKPOINT_REWRITE_ENABLED = \"streaming.checkpoint.rewrite.enabled\";\n+  public static final String SPARK_STREAMING_CHECKPOINT_REWRITE_ENABLED =", "originalCommit": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NzY1OA==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513647658", "bodyText": "I made them separate as I use the STREAMING_CHECKPOINT_REWRITE_ENABLED variable for the Java options in https://github.com/cdapio/cdap/pull/12822/files#diff-25b96ab36cd957bb35aace06ff7a5befcc138b4900b04c2e1435951a252a51b6R532\nThe SPARK_STREAMING_CHECKPOINT_REWRITE_ENABLED just adds the spark. prefix and is used in the cdap-site.xml configuration file.", "author": "fernst", "createdAt": "2020-10-28T17:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0OTM5Mw==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513649393", "bodyText": "Seems like you can just use the same one?", "author": "chtyim", "createdAt": "2020-10-28T17:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NTcxOQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513655719", "bodyText": "I tried that and when I did, Spark complained that Spark configuration properties cannot be set using Java opts.\nI don't recall the exact text of the error message, I can reproduce it and paste it here if you'd like.", "author": "fernst", "createdAt": "2020-10-28T18:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY3NTA3Ng==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513675076", "bodyText": "I see. it's ok to keep this. Maybe good to add a code comment as to why it is needed.", "author": "chtyim", "createdAt": "2020-10-28T18:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzOTMyMg==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513639322", "bodyText": "You shouldn't be override this. This get called when a field is used inside a method. What I suggested earlier is to override the ClassVisitor.visitField method to make the field is defined in the class.", "author": "chtyim", "createdAt": "2020-10-28T17:39:38Z", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +675,104 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(checkpoint_time_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          boolean hasCheckpointTimeField = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {", "originalCommit": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0ODU4MQ==", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513648581", "bodyText": "Oh, I see what you mean now. I'll move this logic into the ClassVisitor instead", "author": "fernst", "createdAt": "2020-10-28T17:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzOTMyMg=="}], "type": "inlineReview"}, {"oid": "c4ea8371ade0e05d86a9fe41a1a8b504e2274710", "url": "https://github.com/cdapio/cdap/commit/c4ea8371ade0e05d86a9fe41a1a8b504e2274710", "message": "\u001b\n\nCDAP-17288 Added class rewriting logic to add a timestamp to the temporary file used by Spark when creating a checkpoint.\n\nThis prevents rate limit issues with streaming pipelines when using GCS for checkpoints.\n\nFixed typo with constructor.\n\nUpdated logic to use the Checkpoint Time as the unique identified for the temporary file.\n\nAdded generator adapter for convenience.\n\nUpdated structure to return a Generator Adapter.\n\nStyling fixes.\n\nAdded configuration option `spark.streaming.checkpoint.rewrite.enabled` to control behavior of the Checkpoint temp file name rewriting behavior.\n\nAdded a log line once the class rewrite is complete.\n\nComment fixes.\n\nAdded logic to check if the Checkpoint Time field exists before attemptiing to rewrite the class.\n\nMoved field visitor logic to the Class visitor.\n\nStyling changes.\n\nAdded comments explaining configuration keys for the rewrite checkpoint temp file behavior.", "committedDate": "2020-10-28T21:42:42Z", "type": "forcePushed"}, {"oid": "1281de7be655037f871c3aad421fa7bffe349ed0", "url": "https://github.com/cdapio/cdap/commit/1281de7be655037f871c3aad421fa7bffe349ed0", "message": "CDAP-17288 Added class rewriting logic to add a timestamp to the temporary file used by Spark when creating a checkpoint.\n\nThis prevents rate limit issues with streaming pipelines when using GCS for checkpoints.\n\nFixed typo with constructor.\n\nUpdated logic to use the Checkpoint Time as the unique identified for the temporary file.\n\nAdded generator adapter for convenience.\n\nUpdated structure to return a Generator Adapter.\n\nStyling fixes.\n\nAdded configuration option `spark.streaming.checkpoint.rewrite.enabled` to control behavior of the Checkpoint temp file name rewriting behavior.\n\nAdded a log line once the class rewrite is complete.\n\nComment fixes.\n\nAdded logic to check if the Checkpoint Time field exists before attemptiing to rewrite the class.\n\nMoved field visitor logic to the Class visitor.\n\nStyling changes.\n\nAdded comments explaining configuration keys for the rewrite checkpoint temp file behavior.", "committedDate": "2020-10-28T21:43:49Z", "type": "commit"}, {"oid": "1281de7be655037f871c3aad421fa7bffe349ed0", "url": "https://github.com/cdapio/cdap/commit/1281de7be655037f871c3aad421fa7bffe349ed0", "message": "CDAP-17288 Added class rewriting logic to add a timestamp to the temporary file used by Spark when creating a checkpoint.\n\nThis prevents rate limit issues with streaming pipelines when using GCS for checkpoints.\n\nFixed typo with constructor.\n\nUpdated logic to use the Checkpoint Time as the unique identified for the temporary file.\n\nAdded generator adapter for convenience.\n\nUpdated structure to return a Generator Adapter.\n\nStyling fixes.\n\nAdded configuration option `spark.streaming.checkpoint.rewrite.enabled` to control behavior of the Checkpoint temp file name rewriting behavior.\n\nAdded a log line once the class rewrite is complete.\n\nComment fixes.\n\nAdded logic to check if the Checkpoint Time field exists before attemptiing to rewrite the class.\n\nMoved field visitor logic to the Class visitor.\n\nStyling changes.\n\nAdded comments explaining configuration keys for the rewrite checkpoint temp file behavior.", "committedDate": "2020-10-28T21:43:49Z", "type": "forcePushed"}]}