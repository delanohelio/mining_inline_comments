{"pr_number": 12455, "pr_title": "[CDAP-16850] Adds unit tests to Schema Manager used by Schema Editor", "pr_createdAt": "2020-07-15T14:38:43Z", "pr_url": "https://github.com/cdapio/cdap/pull/12455", "timeline": [{"oid": "fc24b2165faffa9a1bb1375e6d18e365c5379ac4", "url": "https://github.com/cdapio/cdap/commit/fc24b2165faffa9a1bb1375e6d18e365c5379ac4", "message": "Adds basic unit tests for SchemaManager", "committedDate": "2020-07-18T05:52:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1NTE1Mw==", "url": "https://github.com/cdapio/cdap/pull/12455#discussion_r459055153", "bodyText": "Better description here? e.g. Should handle empty schema", "author": "njbriggs", "createdAt": "2020-07-22T20:12:38Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/__tests__/SchemaManager.tests.ts", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  SchemaManager,\n+  ISchemaManager,\n+  INode,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManager';\n+import {\n+  OperationTypesEnum,\n+  getDefaultEmptyAvroSchema,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import {\n+  schemaWithMap,\n+  schemaWithName,\n+  schemaWithModifiedType,\n+  simpleSchema,\n+  simpleSchema2,\n+  largeSchema,\n+  largeSchema2,\n+} from './schemas';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+\n+const childCountInTree = (tree) => {\n+  if (!tree || (tree && !tree.children)) {\n+    return 0;\n+  }\n+  return Object.keys(tree.children).filter((child) => child !== 'order').length;\n+};\n+\n+const getNthFieldIdInFlatSchema = (schemaManagerInstance: ISchemaManager, n) => {\n+  const list = schemaManagerInstance.getFlatSchema();\n+  const { id, ancestors } = list[n];\n+  const fieldId = { id, ancestors };\n+  return { fieldId, field: list[n] };\n+};\n+\n+describe('Unit tests for Schema Manager', () => {\n+  describe('Basic operations should work', () => {\n+    let schema;\n+    beforeEach(() => {\n+      schema = SchemaManager().getInstance();\n+    });\n+\n+    it('Should work', () => {", "originalCommit": "fc24b2165faffa9a1bb1375e6d18e365c5379ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1NjYzMw==", "url": "https://github.com/cdapio/cdap/pull/12455#discussion_r459056633", "bodyText": "Question, potentially for future work: Would it make sense for onChange to accept an array of change structures? Would batching changes lead to performance improvements down the line?", "author": "njbriggs", "createdAt": "2020-07-22T20:15:29Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/__tests__/SchemaManager.tests.ts", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  SchemaManager,\n+  ISchemaManager,\n+  INode,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManager';\n+import {\n+  OperationTypesEnum,\n+  getDefaultEmptyAvroSchema,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import {\n+  schemaWithMap,\n+  schemaWithName,\n+  schemaWithModifiedType,\n+  simpleSchema,\n+  simpleSchema2,\n+  largeSchema,\n+  largeSchema2,\n+} from './schemas';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+\n+const childCountInTree = (tree) => {\n+  if (!tree || (tree && !tree.children)) {\n+    return 0;\n+  }\n+  return Object.keys(tree.children).filter((child) => child !== 'order').length;\n+};\n+\n+const getNthFieldIdInFlatSchema = (schemaManagerInstance: ISchemaManager, n) => {\n+  const list = schemaManagerInstance.getFlatSchema();\n+  const { id, ancestors } = list[n];\n+  const fieldId = { id, ancestors };\n+  return { fieldId, field: list[n] };\n+};\n+\n+describe('Unit tests for Schema Manager', () => {\n+  describe('Basic operations should work', () => {\n+    let schema;\n+    beforeEach(() => {\n+      schema = SchemaManager().getInstance();\n+    });\n+\n+    it('Should work', () => {\n+      expect(schema).not.toBeNull();\n+      const tree = schema.getSchemaTree();\n+      const list = schema.getFlatSchema();\n+      expect(childCountInTree(tree)).toBe(1);\n+      expect(list.length).toBe(2); // top level schema + first empty record field.\n+      expect(list[1].name).toBe('');\n+    });\n+\n+    it('Should change \"name\" of a record field', () => {\n+      const list = schema.getFlatSchema();\n+      const { id, ancestors } = list[1];\n+      const fieldId = { id, ancestors };\n+      schema.onChange(fieldId, {\n+        property: 'name',\n+        value: 'new_field',\n+        type: 'update',\n+      });\n+      expect(schema.getFlatSchema().length).toBe(2);\n+      expect(list[1].name).toBe('new_field');\n+      expect(schema.getAvroSchema()).toEqual(schemaWithName);\n+    });\n+\n+    it('Should change the \"type\" of a record field', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, {\n+        property: 'name',\n+        value: 'new_field',\n+        type: OperationTypesEnum.UPDATE,\n+      });\n+      schema.onChange(fieldId, {\n+        property: 'type',\n+        value: 'boolean',\n+        type: OperationTypesEnum.UPDATE,\n+      });\n+      expect(schema.getFlatSchema()[1].type).toBe('boolean');\n+      expect(schema.getAvroSchema()).toEqual(schemaWithModifiedType);\n+    });\n+\n+    it('Should add a new record field', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, { type: OperationTypesEnum.ADD });\n+      expect(schema.getFlatSchema().length).toBe(3);\n+    });\n+\n+    it('Should remove a record field', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, { type: OperationTypesEnum.ADD });\n+      schema.onChange(fieldId, { type: OperationTypesEnum.REMOVE });\n+      expect(schema.getFlatSchema().length).toBe(2);\n+    });\n+\n+    it('Should change simple type to complex type', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, {", "originalCommit": "fc24b2165faffa9a1bb1375e6d18e365c5379ac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgzMTM0NA==", "url": "https://github.com/cdapio/cdap/pull/12455#discussion_r493831344", "bodyText": "Are you considering more of individual field changes or changes across fields? If for individual changes we already sort of isolate the change for performance but it would be a little bit challenging to do across fields.\nSay the user enters a new field, say field1, and then changes the type to be int and adds another field. If we were to batch this operation then we temporarily have to store the state somewhere before we update the SchemaManager which then reflects the presentation layer (DOM). I am happy to explore more on the topic.", "author": "ajainarayanan", "createdAt": "2020-09-23T19:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1NjYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1Njc1OA==", "url": "https://github.com/cdapio/cdap/pull/12455#discussion_r459056758", "bodyText": "This should verify the new field is correct", "author": "njbriggs", "createdAt": "2020-07-22T20:15:48Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/__tests__/SchemaManager.tests.ts", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  SchemaManager,\n+  ISchemaManager,\n+  INode,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManager';\n+import {\n+  OperationTypesEnum,\n+  getDefaultEmptyAvroSchema,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import {\n+  schemaWithMap,\n+  schemaWithName,\n+  schemaWithModifiedType,\n+  simpleSchema,\n+  simpleSchema2,\n+  largeSchema,\n+  largeSchema2,\n+} from './schemas';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+\n+const childCountInTree = (tree) => {\n+  if (!tree || (tree && !tree.children)) {\n+    return 0;\n+  }\n+  return Object.keys(tree.children).filter((child) => child !== 'order').length;\n+};\n+\n+const getNthFieldIdInFlatSchema = (schemaManagerInstance: ISchemaManager, n) => {\n+  const list = schemaManagerInstance.getFlatSchema();\n+  const { id, ancestors } = list[n];\n+  const fieldId = { id, ancestors };\n+  return { fieldId, field: list[n] };\n+};\n+\n+describe('Unit tests for Schema Manager', () => {\n+  describe('Basic operations should work', () => {\n+    let schema;\n+    beforeEach(() => {\n+      schema = SchemaManager().getInstance();\n+    });\n+\n+    it('Should work', () => {\n+      expect(schema).not.toBeNull();\n+      const tree = schema.getSchemaTree();\n+      const list = schema.getFlatSchema();\n+      expect(childCountInTree(tree)).toBe(1);\n+      expect(list.length).toBe(2); // top level schema + first empty record field.\n+      expect(list[1].name).toBe('');\n+    });\n+\n+    it('Should change \"name\" of a record field', () => {\n+      const list = schema.getFlatSchema();\n+      const { id, ancestors } = list[1];\n+      const fieldId = { id, ancestors };\n+      schema.onChange(fieldId, {\n+        property: 'name',\n+        value: 'new_field',\n+        type: 'update',\n+      });\n+      expect(schema.getFlatSchema().length).toBe(2);\n+      expect(list[1].name).toBe('new_field');\n+      expect(schema.getAvroSchema()).toEqual(schemaWithName);\n+    });\n+\n+    it('Should change the \"type\" of a record field', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, {\n+        property: 'name',\n+        value: 'new_field',\n+        type: OperationTypesEnum.UPDATE,\n+      });\n+      schema.onChange(fieldId, {\n+        property: 'type',\n+        value: 'boolean',\n+        type: OperationTypesEnum.UPDATE,\n+      });\n+      expect(schema.getFlatSchema()[1].type).toBe('boolean');\n+      expect(schema.getAvroSchema()).toEqual(schemaWithModifiedType);\n+    });\n+\n+    it('Should add a new record field', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, { type: OperationTypesEnum.ADD });\n+      expect(schema.getFlatSchema().length).toBe(3);", "originalCommit": "fc24b2165faffa9a1bb1375e6d18e365c5379ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1Njg3Mw==", "url": "https://github.com/cdapio/cdap/pull/12455#discussion_r459056873", "bodyText": "This should verify the correct field was removed", "author": "njbriggs", "createdAt": "2020-07-22T20:16:04Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/__tests__/SchemaManager.tests.ts", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  SchemaManager,\n+  ISchemaManager,\n+  INode,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManager';\n+import {\n+  OperationTypesEnum,\n+  getDefaultEmptyAvroSchema,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import {\n+  schemaWithMap,\n+  schemaWithName,\n+  schemaWithModifiedType,\n+  simpleSchema,\n+  simpleSchema2,\n+  largeSchema,\n+  largeSchema2,\n+} from './schemas';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+\n+const childCountInTree = (tree) => {\n+  if (!tree || (tree && !tree.children)) {\n+    return 0;\n+  }\n+  return Object.keys(tree.children).filter((child) => child !== 'order').length;\n+};\n+\n+const getNthFieldIdInFlatSchema = (schemaManagerInstance: ISchemaManager, n) => {\n+  const list = schemaManagerInstance.getFlatSchema();\n+  const { id, ancestors } = list[n];\n+  const fieldId = { id, ancestors };\n+  return { fieldId, field: list[n] };\n+};\n+\n+describe('Unit tests for Schema Manager', () => {\n+  describe('Basic operations should work', () => {\n+    let schema;\n+    beforeEach(() => {\n+      schema = SchemaManager().getInstance();\n+    });\n+\n+    it('Should work', () => {\n+      expect(schema).not.toBeNull();\n+      const tree = schema.getSchemaTree();\n+      const list = schema.getFlatSchema();\n+      expect(childCountInTree(tree)).toBe(1);\n+      expect(list.length).toBe(2); // top level schema + first empty record field.\n+      expect(list[1].name).toBe('');\n+    });\n+\n+    it('Should change \"name\" of a record field', () => {\n+      const list = schema.getFlatSchema();\n+      const { id, ancestors } = list[1];\n+      const fieldId = { id, ancestors };\n+      schema.onChange(fieldId, {\n+        property: 'name',\n+        value: 'new_field',\n+        type: 'update',\n+      });\n+      expect(schema.getFlatSchema().length).toBe(2);\n+      expect(list[1].name).toBe('new_field');\n+      expect(schema.getAvroSchema()).toEqual(schemaWithName);\n+    });\n+\n+    it('Should change the \"type\" of a record field', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, {\n+        property: 'name',\n+        value: 'new_field',\n+        type: OperationTypesEnum.UPDATE,\n+      });\n+      schema.onChange(fieldId, {\n+        property: 'type',\n+        value: 'boolean',\n+        type: OperationTypesEnum.UPDATE,\n+      });\n+      expect(schema.getFlatSchema()[1].type).toBe('boolean');\n+      expect(schema.getAvroSchema()).toEqual(schemaWithModifiedType);\n+    });\n+\n+    it('Should add a new record field', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, { type: OperationTypesEnum.ADD });\n+      expect(schema.getFlatSchema().length).toBe(3);\n+    });\n+\n+    it('Should remove a record field', () => {\n+      const { fieldId } = getNthFieldIdInFlatSchema(schema, 1);\n+      schema.onChange(fieldId, { type: OperationTypesEnum.ADD });\n+      schema.onChange(fieldId, { type: OperationTypesEnum.REMOVE });\n+      expect(schema.getFlatSchema().length).toBe(2);", "originalCommit": "fc24b2165faffa9a1bb1375e6d18e365c5379ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff4f104311c14fb4ba56046410f964b861a5231e", "url": "https://github.com/cdapio/cdap/commit/ff4f104311c14fb4ba56046410f964b861a5231e", "message": "Adds basic unit tests for SchemaManager", "committedDate": "2020-09-21T17:51:41Z", "type": "forcePushed"}, {"oid": "80b5bf4ec15c6456cf363d079f8a42794c01ed9f", "url": "https://github.com/cdapio/cdap/commit/80b5bf4ec15c6456cf363d079f8a42794c01ed9f", "message": "Fixes PluginJSONCreator unit test to mock right modules (since automock is now set to false)", "committedDate": "2020-09-23T18:03:13Z", "type": "forcePushed"}, {"oid": "410cf2175e1695f125ef9175acc786aec4d2559e", "url": "https://github.com/cdapio/cdap/commit/410cf2175e1695f125ef9175acc786aec4d2559e", "message": "Adds unit tests for SchemaManager in SchemaEditor used in pipelines\n\n - Adds jest css transform module while running unit tests\n - Adds minor safety check for accessing proxyBaseUrl in WindowManager\n - Fixes jest config to remove automock to be false. This prevents from jest mocking all possible modules which causes other side effects\n - Fixes PluginJSONCreator unit test to mock right modules (since automock is now set to false)", "committedDate": "2020-10-27T22:47:47Z", "type": "forcePushed"}, {"oid": "b22ac1f47c6bbeb5e9efaa66433efe5045d5272c", "url": "https://github.com/cdapio/cdap/commit/b22ac1f47c6bbeb5e9efaa66433efe5045d5272c", "message": "Adds unit tests for SchemaManager in SchemaEditor used in pipelines\n\n - Adds jest css transform module while running unit tests\n - Adds minor safety check for accessing proxyBaseUrl in WindowManager\n - Fixes jest config to remove automock to be false. This prevents from jest mocking all possible modules which causes other side effects\n - Fixes PluginJSONCreator unit test to mock right modules (since automock is now set to false)", "committedDate": "2020-10-28T05:01:41Z", "type": "commit"}, {"oid": "b22ac1f47c6bbeb5e9efaa66433efe5045d5272c", "url": "https://github.com/cdapio/cdap/commit/b22ac1f47c6bbeb5e9efaa66433efe5045d5272c", "message": "Adds unit tests for SchemaManager in SchemaEditor used in pipelines\n\n - Adds jest css transform module while running unit tests\n - Adds minor safety check for accessing proxyBaseUrl in WindowManager\n - Fixes jest config to remove automock to be false. This prevents from jest mocking all possible modules which causes other side effects\n - Fixes PluginJSONCreator unit test to mock right modules (since automock is now set to false)", "committedDate": "2020-10-28T05:01:41Z", "type": "forcePushed"}]}