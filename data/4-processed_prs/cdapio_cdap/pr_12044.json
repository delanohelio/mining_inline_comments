{"pr_number": 12044, "pr_title": "(CDAP-16369) Introduce new runtime service", "pr_createdAt": "2020-04-09T09:20:36Z", "pr_url": "https://github.com/cdapio/cdap/pull/12044", "timeline": [{"oid": "6e6d01eae1ab58560559e9b26708b82f932a85ac", "url": "https://github.com/cdapio/cdap/commit/6e6d01eae1ab58560559e9b26708b82f932a85ac", "message": "(CDAP-16369) Simplifies Guice bindings for k8s services", "committedDate": "2020-04-09T08:24:45Z", "type": "commit"}, {"oid": "f2426fe8aceefcdf26b92fca42928cbe19c9cda7", "url": "https://github.com/cdapio/cdap/commit/f2426fe8aceefcdf26b92fca42928cbe19c9cda7", "message": "(CDAP-16369) Use RemoteExecutionLogProcessor to process logs from remote runtime", "committedDate": "2020-04-09T08:24:45Z", "type": "commit"}, {"oid": "fb6564cf986497945be117f09bbfc2e6b9b09236", "url": "https://github.com/cdapio/cdap/commit/fb6564cf986497945be117f09bbfc2e6b9b09236", "message": "Refactor methods from RuntimeMonitor into util class", "committedDate": "2020-04-09T08:24:45Z", "type": "commit"}, {"oid": "96659c516b2098ba8385c5a541407cd3e1503f45", "url": "https://github.com/cdapio/cdap/commit/96659c516b2098ba8385c5a541407cd3e1503f45", "message": "(CDAP-16369) Adds DirectRuntimeRequestValidator\n\n- An implementation that reads from underlying store directly", "committedDate": "2020-04-09T08:24:45Z", "type": "commit"}, {"oid": "d51add93b010e434eada65b8b0fb9fcd28fd6e1a", "url": "https://github.com/cdapio/cdap/commit/d51add93b010e434eada65b8b0fb9fcd28fd6e1a", "message": "(CDAP-16369) Added RuntimeClientService\n\nFor periodically sending data to runtime server", "committedDate": "2020-04-09T08:24:46Z", "type": "commit"}, {"oid": "5c285cec5afdd78ba8b75c2fafa16438a774b82f", "url": "https://github.com/cdapio/cdap/commit/5c285cec5afdd78ba8b75c2fafa16438a774b82f", "message": "(CDAP-16369) Added RuntimeServiceMain and tests\n\n- This is for running RuntimeServer in a separate process", "committedDate": "2020-04-09T18:11:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406371480", "bodyText": "I think we should refactor this method and separate this part out. isValid method is doing more than validation - such as mutating state in local store.", "author": "CuriousVini", "createdAt": "2020-04-09T17:45:16Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);\n+      runRecord = runRecordFetcher.getRunRecordMeta(programRunId);\n+      // Try to update the local store\n+      insertRunRecord(programRunId, runRecord);", "originalCommit": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NTczMg==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406455732", "bodyText": "Separate this part out means the caller to this method to do it?? But the information about that it is fetching remotely doesn't go out of this method.", "author": "chtyim", "createdAt": "2020-04-09T20:23:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2MzcwMQ==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406463701", "bodyText": "Would it be a good idea to throw NotFoundException in isValid when program is not present and do insertion logic in the caller.", "author": "CuriousVini", "createdAt": "2020-04-09T20:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NTE2NQ==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406465165", "bodyText": "No. It is intentional to populate the cache with a false so that we don't need to keep making remote call in case someone is calling this with a program run that is not runnning.", "author": "chtyim", "createdAt": "2020-04-09T20:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NjExOQ==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406466119", "bodyText": "I see.", "author": "CuriousVini", "createdAt": "2020-04-09T20:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4MDY4MA==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406380680", "bodyText": "Remotely fetching program run details for {}", "author": "CuriousVini", "createdAt": "2020-04-09T18:01:18Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);", "originalCommit": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjEzOQ==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406456139", "bodyText": "Fixed", "author": "chtyim", "createdAt": "2020-04-09T20:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4MDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMzk2NA==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406403964", "bodyText": "what exception will be caught by this outer catch?", "author": "CuriousVini", "createdAt": "2020-04-09T18:42:30Z", "path": "cdap-common/src/main/java/io/cdap/cdap/common/service/AbstractRetryableScheduledService.java", "diffHunk": "@@ -149,28 +152,35 @@ protected long handleRetriesExhausted(Exception e) throws Exception {\n   @Override\n   protected final void runOneIteration() throws Exception {\n     try {\n-      if (nonFailureStartTime == 0L) {\n-        nonFailureStartTime = System.currentTimeMillis();\n-      }\n+      try {\n+        if (nonFailureStartTime == 0L) {\n+          nonFailureStartTime = System.currentTimeMillis();\n+        }\n \n-      delayMillis = runTask();\n-      nonFailureStartTime = 0L;\n-      failureCount = 0;\n-    } catch (Exception e) {\n-      if (!shouldRetry(e)) {\n-        throw e;\n-      }\n-\n-      long delayMillis = retryStrategy.nextRetry(++failureCount, nonFailureStartTime);\n-      if (delayMillis < 0) {\n-        e.addSuppressed(new RetriesExhaustedException(String.format(\"Retries exhausted after %d failures and %d ms.\",\n-                                                                    failureCount,\n-                                                                    System.currentTimeMillis() - nonFailureStartTime)));\n-        delayMillis = Math.max(0L, handleRetriesExhausted(e));\n+        delayMillis = runTask();\n         nonFailureStartTime = 0L;\n         failureCount = 0;\n+      } catch (Exception e) {\n+        OUTAGE_LOG.warn(\"Failed to execute task for scheduled service {}\", getServiceName(), e);\n+        if (!shouldRetry(e)) {\n+          throw e;\n+        }\n+\n+        long delayMillis = retryStrategy.nextRetry(++failureCount, nonFailureStartTime);\n+        if (delayMillis < 0) {\n+          e.addSuppressed(\n+            new RetriesExhaustedException(String.format(\"Retries exhausted after %d failures and %d ms.\",\n+                                                        failureCount,\n+                                                        System.currentTimeMillis() - nonFailureStartTime)));\n+          delayMillis = Math.max(0L, handleRetriesExhausted(e));\n+          nonFailureStartTime = 0L;\n+          failureCount = 0;\n+        }\n+        this.delayMillis = delayMillis;\n       }\n-      this.delayMillis = delayMillis;\n+    } catch (Exception e) {", "originalCommit": "5c285cec5afdd78ba8b75c2fafa16438a774b82f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NzY1MQ==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406457651", "bodyText": "The one thrown in line 166. It is just for logging that when a service is giving up retry due to shouldRetry(e) returning false.", "author": "chtyim", "createdAt": "2020-04-09T20:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMzk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTg2NA==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406405864", "bodyText": "unused?", "author": "CuriousVini", "createdAt": "2020-04-09T18:45:55Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/RuntimeProgramStatusSubscriberService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.program.ProgramDescriptor;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.runtime.ProgramOptionConstants;\n+import io.cdap.cdap.internal.app.services.AbstractNotificationSubscriberService;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.proto.Notification;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableAdmin;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A TMS subscriber service to replicate program status from the\n+ * {@link Constants.AppFabric#PROGRAM_STATUS_RECORD_EVENT_TOPIC} to a local storage.\n+ * It is for the {@link DirectRuntimeRequestValidator} to validate incoming requests that it is coming from\n+ * a running program.\n+ */\n+public class RuntimeProgramStatusSubscriberService extends AbstractNotificationSubscriberService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeProgramStatusSubscriberService.class);\n+  private static final Gson GSON = new Gson();\n+\n+  @Inject\n+  RuntimeProgramStatusSubscriberService(CConfiguration cConf, MessagingService messagingService,\n+                                        DiscoveryServiceClient discoveryServiceClient,", "originalCommit": "5c285cec5afdd78ba8b75c2fafa16438a774b82f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjUyOQ==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406456529", "bodyText": "Removed", "author": "chtyim", "createdAt": "2020-04-09T20:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTkxOQ==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406405919", "bodyText": "unused?", "author": "CuriousVini", "createdAt": "2020-04-09T18:46:01Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/RuntimeProgramStatusSubscriberService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.program.ProgramDescriptor;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.runtime.ProgramOptionConstants;\n+import io.cdap.cdap.internal.app.services.AbstractNotificationSubscriberService;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.proto.Notification;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableAdmin;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A TMS subscriber service to replicate program status from the\n+ * {@link Constants.AppFabric#PROGRAM_STATUS_RECORD_EVENT_TOPIC} to a local storage.\n+ * It is for the {@link DirectRuntimeRequestValidator} to validate incoming requests that it is coming from\n+ * a running program.\n+ */\n+public class RuntimeProgramStatusSubscriberService extends AbstractNotificationSubscriberService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeProgramStatusSubscriberService.class);\n+  private static final Gson GSON = new Gson();\n+\n+  @Inject\n+  RuntimeProgramStatusSubscriberService(CConfiguration cConf, MessagingService messagingService,\n+                                        DiscoveryServiceClient discoveryServiceClient,\n+                                        MetricsCollectionService metricsCollectionService,\n+                                        TransactionRunner transactionRunner,\n+                                        StructuredTableAdmin structuredTableAdmin) {", "originalCommit": "5c285cec5afdd78ba8b75c2fafa16438a774b82f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjU4OQ==", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406456589", "bodyText": "Removed", "author": "chtyim", "createdAt": "2020-04-09T20:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTkxOQ=="}], "type": "inlineReview"}, {"oid": "bf8f9b0da111d464ca41c5b1650ad81dc9182372", "url": "https://github.com/cdapio/cdap/commit/bf8f9b0da111d464ca41c5b1650ad81dc9182372", "message": "(CDAP-16369) Added RuntimeServiceMain and tests\n\n- This is for running RuntimeServer in a separate process", "committedDate": "2020-04-09T20:47:11Z", "type": "commit"}, {"oid": "bf8f9b0da111d464ca41c5b1650ad81dc9182372", "url": "https://github.com/cdapio/cdap/commit/bf8f9b0da111d464ca41c5b1650ad81dc9182372", "message": "(CDAP-16369) Added RuntimeServiceMain and tests\n\n- This is for running RuntimeServer in a separate process", "committedDate": "2020-04-09T20:47:11Z", "type": "forcePushed"}]}