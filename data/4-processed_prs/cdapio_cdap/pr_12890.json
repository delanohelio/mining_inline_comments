{"pr_number": 12890, "pr_title": "System program management service to ensure system programs are working as expected", "pr_createdAt": "2020-12-08T21:43:57Z", "pr_url": "https://github.com/cdapio/cdap/pull/12890", "timeline": [{"oid": "d45a28d54818961cebffaef70009ceca55fc68a5", "url": "https://github.com/cdapio/cdap/commit/d45a28d54818961cebffaef70009ceca55fc68a5", "message": "System program management service to ensure system programs are working as expected", "committedDate": "2020-12-08T23:03:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NDQzOQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r538954439", "bodyText": "Usually the unit is in the config name. E.g. system.program.scan.interval.seconds", "author": "chtyim", "createdAt": "2020-12-09T02:21:31Z", "path": "cdap-common/src/main/resources/cdap-default.xml", "diffHunk": "@@ -4136,4 +4136,12 @@\n     </description>\n   </property>\n \n+  <property>\n+    <name>system.program.scan.interval</name>", "originalCommit": "3e8e672f05b4cd6d94dad6ee2c87f286c3e00810", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5MTU3Nw==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r538991577", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T04:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NDQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNTU5NA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539035594", "bodyText": "Please override the executor() method to use daemon thread and the shutdown method for executor termination.\nAlternative, you can extend from the AbstractRetryableScheduledService instead. It uses daemon thread, and handle failure retries and logging.", "author": "chtyim", "createdAt": "2020-12-09T06:09:39Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {", "originalCommit": "4bb974cff883b5e877d8ec4e4f8dcb98ccf0af35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDI4Ng==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539560286", "bodyText": "Going with first option. Since we run this service very frequently, are retries required on each iteration?", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T18:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNTU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MjU3NQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539562575", "bodyText": "The retry strategy simply provide a different delay than the regular one for the next iteration to run. E.g. if it runs regularly at 10 seconds interval, upon failure, you can do an exponential increase of the interval (e.g. 1, 2, 4, 8) till a max depending on the failure type.", "author": "chtyim", "createdAt": "2020-12-09T18:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNTU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwODEzNw==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539608137", "bodyText": "Got it, thanks.", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T20:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNjU5NQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539036595", "bodyText": "Is the Map<String, String> the runtime arguments? If it is, you need to copy the map as well. Better yet, use the Arguments interface.", "author": "chtyim", "createdAt": "2020-12-09T06:12:23Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Map<String, String>>> programsEnabled;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Map<String, String>> programsEnabled) {", "originalCommit": "4bb974cff883b5e877d8ec4e4f8dcb98ccf0af35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1ODc0NA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539558744", "bodyText": "Using Arguments.", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T18:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNjU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNzAwNA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539037004", "bodyText": "No need to copy again since in the set method you always replace with a new Map copy.", "author": "chtyim", "createdAt": "2020-12-09T06:13:35Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Map<String, String>>> programsEnabled;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Map<String, String>> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception ex) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", ex);\n+    }\n+  }\n+\n+  private void reconcileServices() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.programsEnabled.get());", "originalCommit": "4bb974cff883b5e877d8ec4e4f8dcb98ccf0af35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1ODYzOQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539558639", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T18:47:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNzAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNzIyOQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539037229", "bodyText": "You can just keep a Set<ProgramRunId> for programRunsToStop.", "author": "chtyim", "createdAt": "2020-12-09T06:14:19Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Map<String, String>>> programsEnabled;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Map<String, String>> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception ex) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", ex);\n+    }\n+  }\n+\n+  private void reconcileServices() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.programsEnabled.get());\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    Set<ProgramId> servicesToStop = new HashSet<>();", "originalCommit": "4bb974cff883b5e877d8ec4e4f8dcb98ccf0af35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1ODQ5Mg==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539558492", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T18:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNzIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNzU2Nw==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539037567", "bodyText": "It is better to list all program types instead of hardcoded to SERVICE.", "author": "chtyim", "createdAt": "2020-12-09T06:15:15Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Map<String, String>>> programsEnabled;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Map<String, String>> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception ex) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", ex);\n+    }\n+  }\n+\n+  private void reconcileServices() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.programsEnabled.get());\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    Set<ProgramId> servicesToStop = new HashSet<>();\n+    Set<ProgramId> servicesRunning = new HashSet<>();\n+    Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap = new HashMap<>();\n+    Map<ProgramId, RunRecordDetail> programLatestRunMap = new HashMap<>();\n+    //Get all current runs\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);", "originalCommit": "4bb974cff883b5e877d8ec4e4f8dcb98ccf0af35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1ODMyOA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539558328", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T18:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzNzU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzODI1OA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539038258", "bodyText": "All similar method should use program instead of service (e.g. stopProgram)", "author": "chtyim", "createdAt": "2020-12-09T06:17:01Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Map<String, String>>> programsEnabled;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Map<String, String>> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception ex) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", ex);\n+    }\n+  }\n+\n+  private void reconcileServices() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.programsEnabled.get());\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    Set<ProgramId> servicesToStop = new HashSet<>();\n+    Set<ProgramId> servicesRunning = new HashSet<>();\n+    Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap = new HashMap<>();\n+    Map<ProgramId, RunRecordDetail> programLatestRunMap = new HashMap<>();\n+    //Get all current runs\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);\n+    //Find services to delete and already running services\n+    for (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {\n+      ProgramId programId = runtimeInfo.getProgramId();\n+      if (!programId.getNamespaceId().equals(NamespaceId.SYSTEM)) {\n+        //We care only about system services\n+        continue;\n+      }\n+      if (!enabledServices.contains(programId)) {\n+        servicesToStop.add(programId);\n+      } else {\n+        servicesRunning.add(programId);\n+        //gather run records to stop extra runs for each program\n+        gatherRunRecords(programRunsMap, programLatestRunMap, runtimeInfo, programId);\n+      }\n+    }\n+    //find services to start\n+    Set<ProgramId> servicesToStart = enabledServices.stream()\n+      .filter(programId -> !servicesRunning.contains(programId))\n+      .collect(Collectors.toSet());\n+    //start services\n+    startServices(servicesToStart, enabledServicesMap);\n+    //stop services\n+    servicesToStop.forEach(this::stopService);\n+    //stop extra runs for enabled services\n+    pruneRuns(programRunsMap, programLatestRunMap);\n+  }\n+\n+  private void gatherRunRecords(Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap,\n+                                Map<ProgramId, RunRecordDetail> programLastRunMap,\n+                                ProgramRuntimeService.RuntimeInfo runtimeInfo, ProgramId programId) throws Exception {\n+    programRunsMap.putIfAbsent(programId, new ArrayList<>());\n+    programRunsMap.get(programId).add(runtimeInfo);\n+    //Gather the latest run as we go\n+    RunRecordDetail runRecordMeta = programLifecycleService\n+      .getRunRecordMeta(runtimeInfo.getController().getProgramRunId());\n+    programLastRunMap.putIfAbsent(programId, runRecordMeta);\n+    programLastRunMap.put(programId, getLatestRunRecord(programLastRunMap.get(programId), runRecordMeta));\n+  }\n+\n+  private void startServices(Set<ProgramId> servicesToStart, Map<ProgramId, Map<String, String>> enabledServicesMap) {\n+    for (ProgramId programId : servicesToStart) {\n+      Map<String, String> overrides = enabledServicesMap.get(programId);\n+      LOG.debug(\"Starting program {} with args {}\", programId, overrides);\n+      try {\n+        programLifecycleService.start(programId, overrides, false);\n+      } catch (Exception ex) {\n+        LOG.error(\"Could not start program\", ex);\n+      }\n+    }\n+  }\n+\n+  private void stopService(ProgramId programId) {", "originalCommit": "4bb974cff883b5e877d8ec4e4f8dcb98ccf0af35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1ODIwOA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539558208", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T18:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzODI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzODg3Nw==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539038877", "bodyText": "Please log with more context. E.g. \"LOG.warn(Could not stop program {}. Will be retried\", programId, ex).\nAlso, it should be logged as warning since it is not a fatal error and it will get retried.", "author": "chtyim", "createdAt": "2020-12-09T06:18:41Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring services are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Map<String, String>>> programsEnabled;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of services that are currently enabled along with their runtime args.\n+   * The services that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Map<String, String>> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Services to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcileServices();\n+    } catch (Exception ex) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in reconciling services\", ex);\n+    }\n+  }\n+\n+  private void reconcileServices() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Map<String, String>> enabledServicesMap = new HashMap<>(this.programsEnabled.get());\n+    Set<ProgramId> enabledServices = enabledServicesMap.keySet();\n+    Set<ProgramId> servicesToStop = new HashSet<>();\n+    Set<ProgramId> servicesRunning = new HashSet<>();\n+    Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap = new HashMap<>();\n+    Map<ProgramId, RunRecordDetail> programLatestRunMap = new HashMap<>();\n+    //Get all current runs\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.SERVICE);\n+    //Find services to delete and already running services\n+    for (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {\n+      ProgramId programId = runtimeInfo.getProgramId();\n+      if (!programId.getNamespaceId().equals(NamespaceId.SYSTEM)) {\n+        //We care only about system services\n+        continue;\n+      }\n+      if (!enabledServices.contains(programId)) {\n+        servicesToStop.add(programId);\n+      } else {\n+        servicesRunning.add(programId);\n+        //gather run records to stop extra runs for each program\n+        gatherRunRecords(programRunsMap, programLatestRunMap, runtimeInfo, programId);\n+      }\n+    }\n+    //find services to start\n+    Set<ProgramId> servicesToStart = enabledServices.stream()\n+      .filter(programId -> !servicesRunning.contains(programId))\n+      .collect(Collectors.toSet());\n+    //start services\n+    startServices(servicesToStart, enabledServicesMap);\n+    //stop services\n+    servicesToStop.forEach(this::stopService);\n+    //stop extra runs for enabled services\n+    pruneRuns(programRunsMap, programLatestRunMap);\n+  }\n+\n+  private void gatherRunRecords(Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap,\n+                                Map<ProgramId, RunRecordDetail> programLastRunMap,\n+                                ProgramRuntimeService.RuntimeInfo runtimeInfo, ProgramId programId) throws Exception {\n+    programRunsMap.putIfAbsent(programId, new ArrayList<>());\n+    programRunsMap.get(programId).add(runtimeInfo);\n+    //Gather the latest run as we go\n+    RunRecordDetail runRecordMeta = programLifecycleService\n+      .getRunRecordMeta(runtimeInfo.getController().getProgramRunId());\n+    programLastRunMap.putIfAbsent(programId, runRecordMeta);\n+    programLastRunMap.put(programId, getLatestRunRecord(programLastRunMap.get(programId), runRecordMeta));\n+  }\n+\n+  private void startServices(Set<ProgramId> servicesToStart, Map<ProgramId, Map<String, String>> enabledServicesMap) {\n+    for (ProgramId programId : servicesToStart) {\n+      Map<String, String> overrides = enabledServicesMap.get(programId);\n+      LOG.debug(\"Starting program {} with args {}\", programId, overrides);\n+      try {\n+        programLifecycleService.start(programId, overrides, false);\n+      } catch (Exception ex) {\n+        LOG.error(\"Could not start program\", ex);\n+      }\n+    }\n+  }\n+\n+  private void stopService(ProgramId programId) {\n+    LOG.debug(\"Stopping program {} \", programId);\n+    try {\n+      programLifecycleService.stop(programId);\n+    } catch (Exception ex) {\n+      LOG.error(\"Could not stop program\", ex);", "originalCommit": "4bb974cff883b5e877d8ec4e4f8dcb98ccf0af35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1ODExNg==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539558116", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T18:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAzODg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MDA3MQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539570071", "bodyText": "These two lines can be combined as:\nprogramRunsMap.computeIfAbsent(programId, k -> new ArrayList<>()).add(runtimeInfo);", "author": "chtyim", "createdAt": "2020-12-09T19:04:58Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.common.Threads;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring programs are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Arguments>> programsEnabled;\n+  private ScheduledExecutorService executor;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of programs that are currently enabled along with their runtime args.\n+   * The programs that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Arguments> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Programs to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcilePrograms();\n+    } catch (Exception ex) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in iteration of reconciling programs\", ex);\n+    }\n+  }\n+\n+  @Override\n+  protected ScheduledExecutorService executor() {\n+    executor = Executors\n+      .newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(this.getClass().getSimpleName()));\n+    return executor;\n+  }\n+\n+  @Override\n+  protected void shutDown() throws Exception {\n+    if (executor != null) {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  private void reconcilePrograms() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Arguments> enabledProgramsMap = this.programsEnabled.get();\n+    Set<ProgramId> enabledPrograms = enabledProgramsMap.keySet();\n+    Set<ProgramRunId> programsToStop = new HashSet<>();\n+    Set<ProgramId> programsRunning = new HashSet<>();\n+    Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap = new HashMap<>();\n+    Map<ProgramId, RunRecordDetail> programLatestRunMap = new HashMap<>();\n+    //Get all current runs\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.values());\n+    //Find programs to delete and already running programs\n+    for (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {\n+      ProgramId programId = runtimeInfo.getProgramId();\n+      if (!programId.getNamespaceId().equals(NamespaceId.SYSTEM)) {\n+        //We care only about system programs\n+        continue;\n+      }\n+      if (!enabledPrograms.contains(programId)) {\n+        programsToStop.add(runtimeInfo.getController().getProgramRunId());\n+      } else {\n+        programsRunning.add(programId);\n+        //gather run records to stop extra runs for each program\n+        gatherRunRecords(programRunsMap, programLatestRunMap, runtimeInfo, programId);\n+      }\n+    }\n+    //find programs to start\n+    Set<ProgramId> programsToStart = enabledPrograms.stream()\n+      .filter(programId -> !programsRunning.contains(programId))\n+      .collect(Collectors.toSet());\n+    //start programs\n+    startPrograms(programsToStart, enabledProgramsMap);\n+    //stop programs\n+    programsToStop.forEach(this::stopProgram);\n+    //stop extra runs for enabled programs\n+    pruneRuns(programRunsMap, programLatestRunMap);\n+  }\n+\n+  private void gatherRunRecords(Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap,\n+                                Map<ProgramId, RunRecordDetail> programLastRunMap,\n+                                ProgramRuntimeService.RuntimeInfo runtimeInfo, ProgramId programId) throws Exception {\n+    programRunsMap.putIfAbsent(programId, new ArrayList<>());\n+    programRunsMap.get(programId).add(runtimeInfo);", "originalCommit": "46bc6926d4eef0b6c84fdf78eabc4f0d88c67ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwODI1Mg==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539608252", "bodyText": "Done", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T20:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MDA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MDk5NQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539570995", "bodyText": "Why need to load the run record? The runId has time encoded in it. You can simply order the runs by timestamp. See RunIds.getTime() method.", "author": "chtyim", "createdAt": "2020-12-09T19:06:30Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.common.Threads;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring programs are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Arguments>> programsEnabled;\n+  private ScheduledExecutorService executor;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of programs that are currently enabled along with their runtime args.\n+   * The programs that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Arguments> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected void runOneIteration() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Programs to run not yet set\");\n+      return;\n+    }\n+    try {\n+      reconcilePrograms();\n+    } catch (Exception ex) {\n+      //catch here so a single iteration doesn't stop the service\n+      LOG.error(\"Error in iteration of reconciling programs\", ex);\n+    }\n+  }\n+\n+  @Override\n+  protected ScheduledExecutorService executor() {\n+    executor = Executors\n+      .newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(this.getClass().getSimpleName()));\n+    return executor;\n+  }\n+\n+  @Override\n+  protected void shutDown() throws Exception {\n+    if (executor != null) {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  private void reconcilePrograms() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Arguments> enabledProgramsMap = this.programsEnabled.get();\n+    Set<ProgramId> enabledPrograms = enabledProgramsMap.keySet();\n+    Set<ProgramRunId> programsToStop = new HashSet<>();\n+    Set<ProgramId> programsRunning = new HashSet<>();\n+    Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap = new HashMap<>();\n+    Map<ProgramId, RunRecordDetail> programLatestRunMap = new HashMap<>();\n+    //Get all current runs\n+    List<ProgramRuntimeService.RuntimeInfo> runtimeInfos = programRuntimeService.listAll(ProgramType.values());\n+    //Find programs to delete and already running programs\n+    for (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {\n+      ProgramId programId = runtimeInfo.getProgramId();\n+      if (!programId.getNamespaceId().equals(NamespaceId.SYSTEM)) {\n+        //We care only about system programs\n+        continue;\n+      }\n+      if (!enabledPrograms.contains(programId)) {\n+        programsToStop.add(runtimeInfo.getController().getProgramRunId());\n+      } else {\n+        programsRunning.add(programId);\n+        //gather run records to stop extra runs for each program\n+        gatherRunRecords(programRunsMap, programLatestRunMap, runtimeInfo, programId);\n+      }\n+    }\n+    //find programs to start\n+    Set<ProgramId> programsToStart = enabledPrograms.stream()\n+      .filter(programId -> !programsRunning.contains(programId))\n+      .collect(Collectors.toSet());\n+    //start programs\n+    startPrograms(programsToStart, enabledProgramsMap);\n+    //stop programs\n+    programsToStop.forEach(this::stopProgram);\n+    //stop extra runs for enabled programs\n+    pruneRuns(programRunsMap, programLatestRunMap);\n+  }\n+\n+  private void gatherRunRecords(Map<ProgramId, List<ProgramRuntimeService.RuntimeInfo>> programRunsMap,\n+                                Map<ProgramId, RunRecordDetail> programLastRunMap,\n+                                ProgramRuntimeService.RuntimeInfo runtimeInfo, ProgramId programId) throws Exception {\n+    programRunsMap.putIfAbsent(programId, new ArrayList<>());\n+    programRunsMap.get(programId).add(runtimeInfo);\n+    //Gather the latest run as we go\n+    RunRecordDetail runRecordMeta = programLifecycleService", "originalCommit": "46bc6926d4eef0b6c84fdf78eabc4f0d88c67ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwODcwMg==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539608702", "bodyText": "Thanks, this makes it simpler.", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T20:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MDk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMzM4NQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539703385", "bodyText": "You don't need this. Just do a enabledProgramsMap.contains(programId) check", "author": "chtyim", "createdAt": "2020-12-09T22:42:26Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.common.Threads;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring programs are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Arguments>> programsEnabled;\n+  private ScheduledExecutorService executor;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    super(RetryStrategies.fixDelay(cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL), TimeUnit.SECONDS));\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of programs that are currently enabled along with their runtime args.\n+   * The programs that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Arguments> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected long runTask() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Programs to run not yet set, will be retried.\");\n+      return scheduleInterval;\n+    }\n+    reconcilePrograms();\n+    return scheduleInterval;\n+  }\n+\n+  @Override\n+  protected ScheduledExecutorService executor() {\n+    executor = Executors\n+      .newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(this.getClass().getSimpleName()));\n+    return executor;\n+  }\n+\n+  private void reconcilePrograms() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Arguments> enabledProgramsMap = this.programsEnabled.get();\n+    Set<ProgramId> enabledPrograms = enabledProgramsMap.keySet();", "originalCommit": "bde668f0886a6c1be2335978d16ba76f66dd4687", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxMDIwOQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539710209", "bodyText": "I think you can simplify these couple maps and sets into this:\nMap<ProgramId, Arguments> programsEnabled = new HashMap<>(this.programsEnabled.get());\nSet<ProgramRunId> programRunsToStop = new HashSet<>();\n\nList<ProgramRuntimeService.RuntimeInfo> runtimeInfos = new ArrayList<>(programRuntimeService.listAll(ProgramType.values()));\n// Sort by descending order of runId time.\nruntimeInfos.sort((o1, o2) -> Long.compare(RunIds.getTime(o2.getController().getRunId(), TimeUnit.MILLISECONDS), \n                                           RunIds.getTime(o1.getController().getRunId(), TimeUnit.MILLISECONDS)));\n\nfor (ProgramRuntimeService.RuntimeInfo runtimeInfo : runtimeInfos) {\n  ProgramId programId = runtimeInfo.getProgramId();\n  if (!programId.getNamespaceId().equals(NamespaceId.SYSTEM)) {\n    continue;\n  }\n  // Remove the enabled program if it already running.\n  // If the program is not in the map, it means this particular run shouldn't be running (either not enabled or have multiple copies running)\n  if (programsEnabled.remove(programId) == null) {\n    programRunsToStop.add(programId.run(runtimeInfo.getController().getRunId());\n  }\n}\n\nstartAllPrograms(programsEnabled);\nstopAllProgramRuns(programRunsToStop);", "author": "chtyim", "createdAt": "2020-12-09T22:56:28Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.common.Threads;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * System program management service for ensuring programs are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Arguments>> programsEnabled;\n+  private ScheduledExecutorService executor;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    super(RetryStrategies.fixDelay(cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL), TimeUnit.SECONDS));\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of programs that are currently enabled along with their runtime args.\n+   * The programs that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Arguments> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected long runTask() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Programs to run not yet set, will be retried.\");\n+      return scheduleInterval;\n+    }\n+    reconcilePrograms();\n+    return scheduleInterval;\n+  }\n+\n+  @Override\n+  protected ScheduledExecutorService executor() {\n+    executor = Executors\n+      .newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(this.getClass().getSimpleName()));\n+    return executor;\n+  }\n+\n+  private void reconcilePrograms() throws Exception {\n+    //take a copy\n+    Map<ProgramId, Arguments> enabledProgramsMap = this.programsEnabled.get();\n+    Set<ProgramId> enabledPrograms = enabledProgramsMap.keySet();\n+    Set<ProgramId> programsRunning = new HashSet<>();\n+    Set<ProgramRunId> programsToStop = new HashSet<>();\n+    Map<ProgramId, SortedSet<ProgramRunId>> programRunsMap = new HashMap<>();", "originalCommit": "bde668f0886a6c1be2335978d16ba76f66dd4687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyODQ1NA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539728454", "bodyText": "Thanks, cleaned up.", "author": "greeshmaswaminathan", "createdAt": "2020-12-09T23:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxMDIwOQ=="}], "type": "inlineReview"}, {"oid": "45ee879cd15486ef28ed8bb9b0064cd084a70d74", "url": "https://github.com/cdapio/cdap/commit/45ee879cd15486ef28ed8bb9b0064cd084a70d74", "message": "System program management service to ensure system programs are working as expected", "committedDate": "2020-12-09T23:34:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNzc2OQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539737769", "bodyText": "No need to override this method.", "author": "chtyim", "createdAt": "2020-12-09T23:55:25Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.common.Threads;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * System program management service for ensuring programs are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Arguments>> programsEnabled;\n+  private ScheduledExecutorService executor;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    super(RetryStrategies.fixDelay(cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL), TimeUnit.SECONDS));\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of programs that are currently enabled along with their runtime args.\n+   * The programs that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Arguments> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected long runTask() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Programs to run not yet set, will be retried.\");\n+      return scheduleInterval;\n+    }\n+    reconcilePrograms();\n+    return scheduleInterval;\n+  }\n+\n+  @Override\n+  protected ScheduledExecutorService executor() {", "originalCommit": "45ee879cd15486ef28ed8bb9b0064cd084a70d74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NTIxMA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539755210", "bodyText": "Removed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-10T00:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNzc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczODMwNQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539738305", "bodyText": "Need to make a copy of the map from the atomic reference since we are removing entries from it below", "author": "chtyim", "createdAt": "2020-12-09T23:56:46Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.common.Threads;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * System program management service for ensuring programs are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Arguments>> programsEnabled;\n+  private ScheduledExecutorService executor;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    super(RetryStrategies.fixDelay(cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL), TimeUnit.SECONDS));\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of programs that are currently enabled along with their runtime args.\n+   * The programs that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Arguments> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected long runTask() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Programs to run not yet set, will be retried.\");\n+      return scheduleInterval;\n+    }\n+    reconcilePrograms();\n+    return scheduleInterval;\n+  }\n+\n+  @Override\n+  protected ScheduledExecutorService executor() {\n+    executor = Executors\n+      .newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(this.getClass().getSimpleName()));\n+    return executor;\n+  }\n+\n+  private void reconcilePrograms() throws Exception {\n+    Map<ProgramId, Arguments> enabledProgramsMap = this.programsEnabled.get();", "originalCommit": "45ee879cd15486ef28ed8bb9b0064cd084a70d74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NTI3OQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539755279", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-12-10T00:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczODMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczODk5MQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539738991", "bodyText": "call the variable SYSTEM_PROGRAM_SCAN_INTERVAL_SECONDS", "author": "chtyim", "createdAt": "2020-12-09T23:58:31Z", "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "diffHunk": "@@ -299,6 +299,11 @@\n      */\n     public static final String PROGRAM_STATUS_RECORD_EVENT_TOPIC = \"program.status.record.event.topic\";\n \n+    /**\n+     * Interval at which system programs are monitored\n+     */\n+    public static final String PROGRAM_SCAN_INTERVAL = \"system.program.scan.interval.seconds\";", "originalCommit": "45ee879cd15486ef28ed8bb9b0064cd084a70d74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NTM1OA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539755358", "bodyText": "Changed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-10T00:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczODk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTU3Nw==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539739577", "bodyText": "I think the parent class expects the time returned is in milliseconds, while this interval is in seconds. You should do the conversion in the constructor. Generally it is good to carry the unit in the variable name. E.g. scheduleIntervalMillis.", "author": "chtyim", "createdAt": "2020-12-09T23:59:58Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.common.Threads;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * System program management service for ensuring programs are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleInterval;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Arguments>> programsEnabled;\n+  private ScheduledExecutorService executor;\n+\n+  @Inject\n+  SystemProgramManagementService(CConfiguration cConf, ProgramRuntimeService programRuntimeService,\n+                                 ProgramLifecycleService programLifecycleService) {\n+    super(RetryStrategies.fixDelay(cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL), TimeUnit.SECONDS));\n+    this.cConf = cConf;\n+    this.scheduleInterval = cConf.getLong(Constants.AppFabric.PROGRAM_SCAN_INTERVAL);\n+    this.programRuntimeService = programRuntimeService;\n+    this.programLifecycleService = programLifecycleService;\n+    this.programsEnabled = new AtomicReference<>();\n+  }\n+\n+  /**\n+   * Sets the map of programs that are currently enabled along with their runtime args.\n+   * The programs that are not present in map will be stopped during the next run of the service.\n+   *\n+   * @param programsEnabled\n+   */\n+  public void setProgramsEnabled(Map<ProgramId, Arguments> programsEnabled) {\n+    this.programsEnabled.set(new HashMap<>(programsEnabled));\n+  }\n+\n+  @Override\n+  protected long runTask() throws Exception {\n+    if (programsEnabled.get() == null) {\n+      LOG.debug(\"Programs to run not yet set, will be retried.\");\n+      return scheduleInterval;", "originalCommit": "45ee879cd15486ef28ed8bb9b0064cd084a70d74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NTQyMQ==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539755421", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-12-10T00:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTU3Nw=="}], "type": "inlineReview"}, {"oid": "115c3fdd83100e893a4d5c3ef6a9e465f2629b03", "url": "https://github.com/cdapio/cdap/commit/115c3fdd83100e893a4d5c3ef6a9e465f2629b03", "message": "System program management service to ensure system programs are working as expected", "committedDate": "2020-12-10T00:37:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1OTU1MA==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539759550", "bodyText": "Unused field?", "author": "chtyim", "createdAt": "2020-12-10T00:49:39Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/SystemProgramManagementService.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.services;\n+\n+import com.google.inject.Inject;\n+import io.cdap.cdap.app.runtime.Arguments;\n+import io.cdap.cdap.app.runtime.ProgramRuntimeService;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.AbstractRetryableScheduledService;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.proto.ProgramType;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * System program management service for ensuring programs are running/stopped as expected\n+ */\n+public class SystemProgramManagementService extends AbstractRetryableScheduledService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(SystemProgramManagementService.class);\n+\n+  private final long scheduleIntervalInMillis;\n+  private final CConfiguration cConf;\n+  private final ProgramRuntimeService programRuntimeService;\n+  private final ProgramLifecycleService programLifecycleService;\n+  private final AtomicReference<Map<ProgramId, Arguments>> programsEnabled;\n+  private ScheduledExecutorService executor;", "originalCommit": "115c3fdd83100e893a4d5c3ef6a9e465f2629b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3MDU2Mg==", "url": "https://github.com/cdapio/cdap/pull/12890#discussion_r539770562", "bodyText": "Removed.", "author": "greeshmaswaminathan", "createdAt": "2020-12-10T01:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1OTU1MA=="}], "type": "inlineReview"}, {"oid": "86281dfc3d1123186347ca2a7273afead3ecbe22", "url": "https://github.com/cdapio/cdap/commit/86281dfc3d1123186347ca2a7273afead3ecbe22", "message": "System program management service to ensure system programs are working as expected", "committedDate": "2020-12-10T01:16:38Z", "type": "commit"}, {"oid": "86281dfc3d1123186347ca2a7273afead3ecbe22", "url": "https://github.com/cdapio/cdap/commit/86281dfc3d1123186347ca2a7273afead3ecbe22", "message": "System program management service to ensure system programs are working as expected", "committedDate": "2020-12-10T01:16:38Z", "type": "forcePushed"}]}