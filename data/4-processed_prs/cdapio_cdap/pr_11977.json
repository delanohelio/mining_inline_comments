{"pr_number": 11977, "pr_title": "Adding implementation for Twill Runner Service", "pr_createdAt": "2020-03-18T21:34:27Z", "pr_url": "https://github.com/cdapio/cdap/pull/11977", "timeline": [{"oid": "89c74851a04e064c0b06d27806608d403b8edeea", "url": "https://github.com/cdapio/cdap/commit/89c74851a04e064c0b06d27806608d403b8edeea", "message": "[CDAP-16420]  Add twill runner service for job manager", "committedDate": "2020-03-19T00:42:37Z", "type": "forcePushed"}, {"oid": "b20cb8440301b932ea2b055a6efd48ada50e97ae", "url": "https://github.com/cdapio/cdap/commit/b20cb8440301b932ea2b055a6efd48ada50e97ae", "message": "[CDAP-16420]  Add twill runner service for job manager", "committedDate": "2020-03-19T21:35:15Z", "type": "forcePushed"}, {"oid": "f82b08b6787952ce96430169d903f245ff9486bb", "url": "https://github.com/cdapio/cdap/commit/f82b08b6787952ce96430169d903f245ff9486bb", "message": "[CDAP-16420]  Add twill runner service for job manager", "committedDate": "2020-03-20T01:01:35Z", "type": "forcePushed"}, {"oid": "15920ccf01607c9b97da506cc9daeccda886ec0a", "url": "https://github.com/cdapio/cdap/commit/15920ccf01607c9b97da506cc9daeccda886ec0a", "message": "[CDAP-16420]  Add twill runner service for job manager", "committedDate": "2020-03-20T01:04:02Z", "type": "forcePushed"}, {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "url": "https://github.com/cdapio/cdap/commit/3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "message": "[CDAP-16420]  Add twill runner service for job manager", "committedDate": "2020-03-20T01:06:03Z", "type": "forcePushed"}, {"oid": "41537d8cd3a75a74445fc6a915c1257fd8e14cf1", "url": "https://github.com/cdapio/cdap/commit/41537d8cd3a75a74445fc6a915c1257fd8e14cf1", "message": "[CDAP-16420]  Add twill runner service for job manager", "committedDate": "2020-03-23T07:53:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzODE0Ng==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395438146", "bodyText": "It seems strange to use the localDir to determine using artifact.jar file or not. The logic could be easier to understand by\nFile pluginDir = new File(systemArgs.getOption(ProgramOptionConstants.PLUGIN_DIR));\nFile pluginArchiveFile = new File(\"artifacts_archive.jar\");\nif (!pluginArchiveFile.exists()) {\n  if (!pluginDir.isDirectory()) {\n    // this shouldn't happen, throw exception\n    throw new IllegalStateException(...);\n  }\n  // Archive the plugin directory content locally\n  pluginArchiveFile = new File(tempDir, \"artifacts_archive.jar\");\n  BundleJarUtil.createJar(localDir, pluginArchiveFile);\n}\n\n// Localize all plugins to the program containers.\n// We localize to two target paths, one get expanded to a \"artifacts\" directory, \n// and one keep it as jar \"artifacts_archive.jar\" for further localization to other containers in YARN\nlocalizeResources.put(\"artifacts\", new LocalizeResource(pluginArchiveFile, true));\nlocalizeResources.put(\"artifacts_archive.jar\", new LocalizeResource(pluginArchiveFile, false));\n\nnewSystemArgs.put(ProgramOptionConstants.PLUGIN_DIR, \"artifacts\");\nnewSystemArgs.put(ProgramOptionConstants.PLUGIN_ARCHIVE, \"artifacts_archive.jar\");", "author": "chtyim", "createdAt": "2020-03-20T04:49:28Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/DistributedProgramRunner.java", "diffHunk": "@@ -508,11 +508,20 @@ private ProgramOptions updateProgramOptions(ProgramOptions options,\n     if (systemArgs.hasOption(ProgramOptionConstants.PLUGIN_DIR)) {\n       File localDir = new File(systemArgs.getOption(ProgramOptionConstants.PLUGIN_DIR));\n       File archiveFile = new File(tempDir, \"artifacts.jar\");\n-      BundleJarUtil.createJar(localDir, archiveFile);\n \n-      // Localize plugins to two files, one expanded into a directory, one not.\n-      localizeResources.put(\"artifacts\", new LocalizeResource(archiveFile, true));\n-      localizeResources.put(\"artifacts_archive.jar\", new LocalizeResource(archiveFile, false));\n+      if (!localDir.exists()) {", "originalCommit": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMjYwNw==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r397302607", "bodyText": "stale comment? This check is not applicable anymore.\nAs we discussed offline, I have modified it as below, we rely on the fact that program options are updated with PLUGIN_ARCHIVE option:\nif (systemArgs.hasOption(ProgramOptionConstants.PLUGIN_ARCHIVE)) {\n      archiveFile = new File(artifactArchiveJarName);\n      // Localize plugins to two files, one expanded into a directory, one not.\n      localizeResources.put(artifactDirName, new LocalizeResource(archiveFile, true));\n      localizeResources.put(artifactArchiveJarName, new LocalizeResource(archiveFile, false));\n    } else {\n      File localDir = new File(systemArgs.getOption(ProgramOptionConstants.PLUGIN_DIR));\n      archiveFile = new File(tempDir, artifactDirName + \".jar\");\n      BundleJarUtil.createJar(localDir, archiveFile);\n      // Localize plugins to two files, one expanded into a directory, one not.\n      localizeResources.put(artifactDirName, new LocalizeResource(archiveFile, true));\n      localizeResources.put(artifactArchiveJarName, new LocalizeResource(archiveFile, false));\n    }", "author": "CuriousVini", "createdAt": "2020-03-24T16:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzODE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzODU5NQ==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395438595", "bodyText": "Wrong link?", "author": "chtyim", "createdAt": "2020-03-20T04:52:05Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/DefaultRuntimeInfo.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+/**\n+ * Default implementation of {@link RuntimeLocalFile}.", "originalCommit": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzODk3Mg==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395438972", "bodyText": "Suggest to take (ProgramRunId programRunId, Collection<? extends RuntimeLocalFile> localizeFiles). This would make the caller code cleaner.", "author": "chtyim", "createdAt": "2020-03-20T04:54:15Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/DefaultRuntimeInfo.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+/**\n+ * Default implementation of {@link RuntimeLocalFile}.\n+ */\n+public class DefaultRuntimeInfo implements RuntimeJobInfo {\n+  private final Collection<? extends RuntimeLocalFile> files;\n+  private final ProgramRunInfo info;\n+\n+  DefaultRuntimeInfo(Collection<? extends RuntimeLocalFile> files, ProgramRunInfo info) {", "originalCommit": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzOTUzOQ==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395439539", "bodyText": "The comment is at the wrong place. The next if is for the startup successful case", "author": "chtyim", "createdAt": "2020-03-20T04:58:05Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import org.apache.twill.api.Command;\n+import org.apache.twill.api.ResourceReport;\n+import org.apache.twill.api.RunId;\n+import org.apache.twill.api.ServiceController;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.discovery.ServiceDiscovered;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of {@link TwillController} that uses {@link RuntimeJobManager} to monitor and\n+ * control a running program.\n+ */\n+class RuntimeJobTwillController implements TwillController {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillController.class);\n+\n+  private final RunId runId;\n+  private final ProgramRunId programRunId;\n+  private final RuntimeJobManager jobManager;\n+  private final CompletableFuture<RuntimeJobTwillController> started;\n+  private final CompletableFuture<RuntimeJobTwillController> completion;\n+  private final AtomicBoolean terminateCalled;\n+\n+  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId) {\n+    this.programRunId = programRunId;\n+    this.runId = RunIds.fromString(programRunId.getRun());\n+    this.jobManager = jobManager;\n+    this.started = new CompletableFuture<>();\n+    this.completion = new CompletableFuture<>();\n+    this.terminateCalled = new AtomicBoolean();\n+  }\n+\n+  RuntimeJobManager getJobManager() {\n+    return jobManager;\n+  }\n+\n+  void start(CompletableFuture<Void> startupTaskCompletion) {\n+    startupTaskCompletion.whenComplete((res, throwable) -> {\n+      // terminate this controller with fail state", "originalCommit": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxMTA5OA==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r397311098", "bodyText": "I added it for the whole if..else block, but moved it closer to the else", "author": "CuriousVini", "createdAt": "2020-03-24T16:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzOTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MDMzNw==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395440337", "bodyText": "Why not call the jobManager.kill?", "author": "chtyim", "createdAt": "2020-03-20T05:03:14Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import org.apache.twill.api.Command;\n+import org.apache.twill.api.ResourceReport;\n+import org.apache.twill.api.RunId;\n+import org.apache.twill.api.ServiceController;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.discovery.ServiceDiscovered;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of {@link TwillController} that uses {@link RuntimeJobManager} to monitor and\n+ * control a running program.\n+ */\n+class RuntimeJobTwillController implements TwillController {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillController.class);\n+\n+  private final RunId runId;\n+  private final ProgramRunId programRunId;\n+  private final RuntimeJobManager jobManager;\n+  private final CompletableFuture<RuntimeJobTwillController> started;\n+  private final CompletableFuture<RuntimeJobTwillController> completion;\n+  private final AtomicBoolean terminateCalled;\n+\n+  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId) {\n+    this.programRunId = programRunId;\n+    this.runId = RunIds.fromString(programRunId.getRun());\n+    this.jobManager = jobManager;\n+    this.started = new CompletableFuture<>();\n+    this.completion = new CompletableFuture<>();\n+    this.terminateCalled = new AtomicBoolean();\n+  }\n+\n+  RuntimeJobManager getJobManager() {\n+    return jobManager;\n+  }\n+\n+  void start(CompletableFuture<Void> startupTaskCompletion) {\n+    startupTaskCompletion.whenComplete((res, throwable) -> {\n+      // terminate this controller with fail state\n+      if (throwable == null) {\n+        started.complete(this);\n+      } else {\n+        completion.completeExceptionally(throwable);\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public void addLogHandler(LogHandler handler) {\n+    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n+  }\n+\n+  @Override\n+  public ServiceDiscovered discoverService(String serviceName) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<Integer> changeInstances(String runnable, int newCount) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Nullable\n+  @Override\n+  public ResourceReport getResourceReport() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Future<String> restartAllInstances(String runnable) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<Set<String>> restartInstances(Map<String, ? extends Set<Integer>> runnableToInstanceIds) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<String> restartInstances(String runnable, int instanceId, int... moreInstanceIds) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<String> restartInstances(String runnable, Set<Integer> instanceIds) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<Map<String, LogEntry.Level>> updateLogLevels(Map<String, LogEntry.Level> logLevels) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n+  }\n+\n+  @Override\n+  public Future<Map<String, LogEntry.Level>> updateLogLevels(String runnableName,\n+                                                             Map<String, LogEntry.Level> logLevelsForRunnable) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n+  }\n+\n+  @Override\n+  public Future<String[]> resetLogLevels(String... loggerNames) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetLogLevels is not supported\"));\n+  }\n+\n+  @Override\n+  public Future<String[]> resetRunnableLogLevels(String runnableName, String... loggerNames) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetRunnableLogLevels is not supported\"));\n+  }\n+\n+  @Override\n+  public RunId getRunId() {\n+    return runId;\n+  }\n+\n+  @Override\n+  public Future<Command> sendCommand(Command command) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n+  }\n+\n+  @Override\n+  public Future<Command> sendCommand(String runnableName, Command command) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n+  }\n+\n+  @Override\n+  public void onRunning(Runnable runnable, Executor executor) {\n+    started.thenRunAsync(runnable, executor);\n+  }\n+\n+  @Override\n+  public void onTerminated(Runnable runnable, Executor executor) {\n+    completion.whenCompleteAsync((remoteExecutionTwillController, throwable) -> runnable.run(), executor);\n+  }\n+\n+  @Override\n+  public void awaitTerminated() throws ExecutionException {\n+    Uninterruptibles.getUninterruptibly(completion);\n+  }\n+\n+  @Override\n+  public void awaitTerminated(long timeout, TimeUnit timeoutUnit) throws TimeoutException, ExecutionException {\n+    Uninterruptibles.getUninterruptibly(completion, timeout, timeoutUnit);\n+  }\n+\n+  @Override\n+  public Future<? extends ServiceController> terminate() {\n+    if (terminateCalled.compareAndSet(false, true)) {\n+      try {\n+        // stop the job\n+        jobManager.stop(new ProgramRunInfo.Builder()\n+                          .setNamespace(programRunId.getNamespace())\n+                          .setApplication(programRunId.getApplication())\n+                          .setProgram(programRunId.getProgram())\n+                          .setProgramType(programRunId.getType().getPrettyName())\n+                          .setRun(programRunId.getRun()).build());\n+        // mark completion as completed\n+        completion.complete(this);\n+      } catch (Exception e) {\n+        completion.completeExceptionally(e);\n+      }\n+    }\n+    return completion;\n+  }\n+\n+  @Override\n+  public void kill() {\n+    try {\n+      terminate().get();", "originalCommit": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzU4Mg==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395443582", "bodyText": "If this callable throw exception, who is calling jobManager.destroy()? Probably better to have a try-catch block to call destroy and rethrow the exception", "author": "chtyim", "createdAt": "2020-03-20T05:22:39Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillPreparer.java", "diffHunk": "@@ -0,0 +1,678 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.ListMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.hash.Hasher;\n+import com.google.common.hash.Hashing;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.io.Locations;\n+import io.cdap.cdap.common.logging.LoggingContext;\n+import io.cdap.cdap.common.logging.LoggingContextAccessor;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.runtime.distributed.runtime.TwillControllerFactory;\n+import io.cdap.cdap.logging.context.LoggingContextHelper;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.twill.api.ClassAcceptor;\n+import org.apache.twill.api.EventHandlerSpecification;\n+import org.apache.twill.api.LocalFile;\n+import org.apache.twill.api.RuntimeSpecification;\n+import org.apache.twill.api.SecureStore;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.TwillPreparer;\n+import org.apache.twill.api.TwillRunnable;\n+import org.apache.twill.api.TwillSpecification;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.common.Cancellable;\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.ApplicationBundler;\n+import org.apache.twill.internal.Arguments;\n+import org.apache.twill.internal.Constants;\n+import org.apache.twill.internal.DefaultLocalFile;\n+import org.apache.twill.internal.DefaultRuntimeSpecification;\n+import org.apache.twill.internal.DefaultTwillSpecification;\n+import org.apache.twill.internal.LogOnlyEventHandler;\n+import org.apache.twill.internal.TwillRuntimeSpecification;\n+import org.apache.twill.internal.io.LocationCache;\n+import org.apache.twill.internal.json.ArgumentsCodec;\n+import org.apache.twill.internal.json.TwillRuntimeSpecificationAdapter;\n+import org.apache.twill.internal.utils.Paths;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+\n+/**\n+ *  A {@link TwillPreparer} implementation that uses runtime job manager to launch a single {@link TwillRunnable}.\n+ */\n+public class RuntimeJobTwillPreparer implements TwillPreparer {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillPreparer.class);\n+\n+  private final CConfiguration cConf;\n+  private final Configuration hConf;\n+  private final TwillSpecification twillSpec;\n+  private final ProgramRunId programRunId;\n+  private final ProgramOptions programOptions;\n+\n+  private final List<String> arguments = new ArrayList<>();\n+  private final Set<Class<?>> dependencies = Sets.newIdentityHashSet();\n+  private final List<URI> resources = new ArrayList<>();\n+  private final List<String> classPaths = new ArrayList<>();\n+  private final ListMultimap<String, String> runnableArgs = ArrayListMultimap.create();\n+  private final Map<String, Map<String, String>> environments = new HashMap<>();\n+  private final List<String> applicationClassPaths = new ArrayList<>();\n+  private final Map<String, Map<String, String>> logLevels = new HashMap<>();\n+  private final LocationCache locationCache;\n+  private final Map<String, Integer> maxRetries = new HashMap<>();\n+  private final Map<String, Map<String, String>> runnableConfigs = new HashMap<>();\n+  private final LocationFactory locationFactory;\n+  private final TwillControllerFactory controllerFactory;\n+  private final RuntimeJobManager jobManager;\n+\n+  private ClassAcceptor classAcceptor;\n+\n+  RuntimeJobTwillPreparer(CConfiguration cConf, Configuration hConf,\n+                          TwillSpecification twillSpec, ProgramRunId programRunId,\n+                          ProgramOptions programOptions, LocationCache locationCache,\n+                          LocationFactory locationFactory, TwillControllerFactory controllerFactory,\n+                          RuntimeJobManager jobManager) {\n+    // Check to prevent future mistake\n+    if (twillSpec.getRunnables().size() != 1) {\n+      throw new IllegalArgumentException(\"Only one TwillRunnable is supported\");\n+    }\n+\n+    this.cConf = cConf;\n+    this.hConf = hConf;\n+    this.twillSpec = twillSpec;\n+    this.programRunId = programRunId;\n+    this.programOptions = programOptions;\n+    this.classAcceptor = new ClassAcceptor();\n+    this.locationCache = locationCache;\n+    this.locationFactory = locationFactory;\n+    this.controllerFactory = controllerFactory;\n+    this.jobManager = jobManager;\n+  }\n+\n+  private void confirmRunnableName(String runnableName) {\n+    Preconditions.checkNotNull(runnableName);\n+    Preconditions.checkArgument(twillSpec.getRunnables().containsKey(runnableName),\n+                                \"Runnable %s is not defined in the application.\", runnableName);\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(Map<String, String> config) {\n+    config.forEach(hConf::set);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(String runnableName, Map<String, String> config) {\n+    confirmRunnableName(runnableName);\n+    runnableConfigs.put(runnableName, Maps.newHashMap(config));\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addLogHandler(LogHandler handler) {\n+    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setUser(String user) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setSchedulerQueue(String name) {\n+    LOG.trace(\"Scheduler queue is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String runnableName, String options) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(String... runnables) {\n+    return enableDebugging(false, runnables);\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(boolean doSuspend, String... runnables) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(String... args) {\n+    return withApplicationArguments(Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(Iterable<String> args) {\n+    Iterables.addAll(arguments, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, String... args) {\n+    return withArguments(runnableName, Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, Iterable<String> args) {\n+    confirmRunnableName(runnableName);\n+    runnableArgs.putAll(runnableName, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Class<?>... classes) {\n+    return withDependencies(Arrays.asList(classes));\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Iterable<Class<?>> classes) {\n+    Iterables.addAll(dependencies, classes);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(URI... resources) {\n+    return withResources(Arrays.asList(resources));\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(Iterable<URI> resources) {\n+    Iterables.addAll(this.resources, resources);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(String... classPaths) {\n+    return withClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.classPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(Map<String, String> env) {\n+    // Add the given environments to all runnables\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      setEnv(runnableName, env, false);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(String runnableName, Map<String, String> env) {\n+    confirmRunnableName(runnableName);\n+    setEnv(runnableName, env, true);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(String... classPaths) {\n+    return withApplicationClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.applicationClassPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withBundlerClassAcceptor(ClassAcceptor classAcceptor) {\n+    this.classAcceptor = classAcceptor;\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withMaxRetries(String runnableName, int maxRetries) {\n+    confirmRunnableName(runnableName);\n+    this.maxRetries.put(runnableName, maxRetries);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addSecureStore(SecureStore secureStore) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevel(LogEntry.Level logLevel) {\n+    return setLogLevels(Collections.singletonMap(Logger.ROOT_LOGGER_NAME, logLevel));\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(Map<String, LogEntry.Level> logLevels) {\n+    Preconditions.checkNotNull(logLevels);\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      saveLogLevels(runnableName, logLevels);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(String runnableName, Map<String, LogEntry.Level> runnableLogLevels) {\n+    confirmRunnableName(runnableName);\n+    Preconditions.checkNotNull(runnableLogLevels);\n+    Preconditions.checkArgument(!(logLevels.containsKey(Logger.ROOT_LOGGER_NAME)\n+      && logLevels.get(Logger.ROOT_LOGGER_NAME) == null));\n+    saveLogLevels(runnableName, runnableLogLevels);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setClassLoader(String classLoaderClassName) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillController start() {\n+    return start(Constants.APPLICATION_MAX_START_SECONDS, TimeUnit.SECONDS);\n+  }\n+\n+  @Override\n+  public TwillController start(long timeout, TimeUnit timeoutUnit) {\n+    long startTime = System.currentTimeMillis();\n+\n+    Callable<Void> startupTask = () -> {\n+      jobManager.initialize();", "originalCommit": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwODc2Mg==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r397308762", "bodyText": "That logic is handled here: https://github.com/cdapio/cdap/pull/11977/files#diff-b118a2e8f9a139c00287cbcbbf734ea7R300", "author": "CuriousVini", "createdAt": "2020-03-24T16:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0NjA2MQ==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395446061", "bodyText": "We shouldn't handle it differently.", "author": "chtyim", "createdAt": "2020-03-20T05:36:07Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillPreparer.java", "diffHunk": "@@ -0,0 +1,678 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.ListMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.hash.Hasher;\n+import com.google.common.hash.Hashing;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.io.Locations;\n+import io.cdap.cdap.common.logging.LoggingContext;\n+import io.cdap.cdap.common.logging.LoggingContextAccessor;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.runtime.distributed.runtime.TwillControllerFactory;\n+import io.cdap.cdap.logging.context.LoggingContextHelper;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.twill.api.ClassAcceptor;\n+import org.apache.twill.api.EventHandlerSpecification;\n+import org.apache.twill.api.LocalFile;\n+import org.apache.twill.api.RuntimeSpecification;\n+import org.apache.twill.api.SecureStore;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.TwillPreparer;\n+import org.apache.twill.api.TwillRunnable;\n+import org.apache.twill.api.TwillSpecification;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.common.Cancellable;\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.ApplicationBundler;\n+import org.apache.twill.internal.Arguments;\n+import org.apache.twill.internal.Constants;\n+import org.apache.twill.internal.DefaultLocalFile;\n+import org.apache.twill.internal.DefaultRuntimeSpecification;\n+import org.apache.twill.internal.DefaultTwillSpecification;\n+import org.apache.twill.internal.LogOnlyEventHandler;\n+import org.apache.twill.internal.TwillRuntimeSpecification;\n+import org.apache.twill.internal.io.LocationCache;\n+import org.apache.twill.internal.json.ArgumentsCodec;\n+import org.apache.twill.internal.json.TwillRuntimeSpecificationAdapter;\n+import org.apache.twill.internal.utils.Paths;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+\n+/**\n+ *  A {@link TwillPreparer} implementation that uses runtime job manager to launch a single {@link TwillRunnable}.\n+ */\n+public class RuntimeJobTwillPreparer implements TwillPreparer {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillPreparer.class);\n+\n+  private final CConfiguration cConf;\n+  private final Configuration hConf;\n+  private final TwillSpecification twillSpec;\n+  private final ProgramRunId programRunId;\n+  private final ProgramOptions programOptions;\n+\n+  private final List<String> arguments = new ArrayList<>();\n+  private final Set<Class<?>> dependencies = Sets.newIdentityHashSet();\n+  private final List<URI> resources = new ArrayList<>();\n+  private final List<String> classPaths = new ArrayList<>();\n+  private final ListMultimap<String, String> runnableArgs = ArrayListMultimap.create();\n+  private final Map<String, Map<String, String>> environments = new HashMap<>();\n+  private final List<String> applicationClassPaths = new ArrayList<>();\n+  private final Map<String, Map<String, String>> logLevels = new HashMap<>();\n+  private final LocationCache locationCache;\n+  private final Map<String, Integer> maxRetries = new HashMap<>();\n+  private final Map<String, Map<String, String>> runnableConfigs = new HashMap<>();\n+  private final LocationFactory locationFactory;\n+  private final TwillControllerFactory controllerFactory;\n+  private final RuntimeJobManager jobManager;\n+\n+  private ClassAcceptor classAcceptor;\n+\n+  RuntimeJobTwillPreparer(CConfiguration cConf, Configuration hConf,\n+                          TwillSpecification twillSpec, ProgramRunId programRunId,\n+                          ProgramOptions programOptions, LocationCache locationCache,\n+                          LocationFactory locationFactory, TwillControllerFactory controllerFactory,\n+                          RuntimeJobManager jobManager) {\n+    // Check to prevent future mistake\n+    if (twillSpec.getRunnables().size() != 1) {\n+      throw new IllegalArgumentException(\"Only one TwillRunnable is supported\");\n+    }\n+\n+    this.cConf = cConf;\n+    this.hConf = hConf;\n+    this.twillSpec = twillSpec;\n+    this.programRunId = programRunId;\n+    this.programOptions = programOptions;\n+    this.classAcceptor = new ClassAcceptor();\n+    this.locationCache = locationCache;\n+    this.locationFactory = locationFactory;\n+    this.controllerFactory = controllerFactory;\n+    this.jobManager = jobManager;\n+  }\n+\n+  private void confirmRunnableName(String runnableName) {\n+    Preconditions.checkNotNull(runnableName);\n+    Preconditions.checkArgument(twillSpec.getRunnables().containsKey(runnableName),\n+                                \"Runnable %s is not defined in the application.\", runnableName);\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(Map<String, String> config) {\n+    config.forEach(hConf::set);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(String runnableName, Map<String, String> config) {\n+    confirmRunnableName(runnableName);\n+    runnableConfigs.put(runnableName, Maps.newHashMap(config));\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addLogHandler(LogHandler handler) {\n+    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setUser(String user) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setSchedulerQueue(String name) {\n+    LOG.trace(\"Scheduler queue is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String runnableName, String options) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(String... runnables) {\n+    return enableDebugging(false, runnables);\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(boolean doSuspend, String... runnables) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(String... args) {\n+    return withApplicationArguments(Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(Iterable<String> args) {\n+    Iterables.addAll(arguments, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, String... args) {\n+    return withArguments(runnableName, Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, Iterable<String> args) {\n+    confirmRunnableName(runnableName);\n+    runnableArgs.putAll(runnableName, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Class<?>... classes) {\n+    return withDependencies(Arrays.asList(classes));\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Iterable<Class<?>> classes) {\n+    Iterables.addAll(dependencies, classes);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(URI... resources) {\n+    return withResources(Arrays.asList(resources));\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(Iterable<URI> resources) {\n+    Iterables.addAll(this.resources, resources);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(String... classPaths) {\n+    return withClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.classPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(Map<String, String> env) {\n+    // Add the given environments to all runnables\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      setEnv(runnableName, env, false);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(String runnableName, Map<String, String> env) {\n+    confirmRunnableName(runnableName);\n+    setEnv(runnableName, env, true);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(String... classPaths) {\n+    return withApplicationClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.applicationClassPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withBundlerClassAcceptor(ClassAcceptor classAcceptor) {\n+    this.classAcceptor = classAcceptor;\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withMaxRetries(String runnableName, int maxRetries) {\n+    confirmRunnableName(runnableName);\n+    this.maxRetries.put(runnableName, maxRetries);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addSecureStore(SecureStore secureStore) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevel(LogEntry.Level logLevel) {\n+    return setLogLevels(Collections.singletonMap(Logger.ROOT_LOGGER_NAME, logLevel));\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(Map<String, LogEntry.Level> logLevels) {\n+    Preconditions.checkNotNull(logLevels);\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      saveLogLevels(runnableName, logLevels);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(String runnableName, Map<String, LogEntry.Level> runnableLogLevels) {\n+    confirmRunnableName(runnableName);\n+    Preconditions.checkNotNull(runnableLogLevels);\n+    Preconditions.checkArgument(!(logLevels.containsKey(Logger.ROOT_LOGGER_NAME)\n+      && logLevels.get(Logger.ROOT_LOGGER_NAME) == null));\n+    saveLogLevels(runnableName, runnableLogLevels);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setClassLoader(String classLoaderClassName) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillController start() {\n+    return start(Constants.APPLICATION_MAX_START_SECONDS, TimeUnit.SECONDS);\n+  }\n+\n+  @Override\n+  public TwillController start(long timeout, TimeUnit timeoutUnit) {\n+    long startTime = System.currentTimeMillis();\n+\n+    Callable<Void> startupTask = () -> {\n+      jobManager.initialize();\n+\n+      Path tempDir = java.nio.file.Paths.get(\n+        cConf.get(io.cdap.cdap.common.conf.Constants.CFG_LOCAL_DATA_DIR),\n+        cConf.get(io.cdap.cdap.common.conf.Constants.AppFabric.TEMP_DIR)).toAbsolutePath();\n+      Path stagingDir = Files.createTempDirectory(tempDir, programRunId.getRun());\n+\n+      LoggingContext loggingContext = LoggingContextHelper.getLoggingContextWithRunId(\n+        programRunId, programOptions.getArguments().asMap());\n+      Cancellable cancelLoggingContext = LoggingContextAccessor.setLoggingContext(loggingContext);\n+\n+      try {\n+        Map<String, LocalFile> localFiles = new HashMap<>();\n+        createApplicationJar(createBundler(classAcceptor, stagingDir), localFiles);\n+        createResourcesJar(createBundler(classAcceptor, stagingDir), localFiles, stagingDir);\n+\n+        throwIfTimeout(startTime, timeout, timeoutUnit);\n+\n+        TwillRuntimeSpecification twillRuntimeSpec;\n+        Path runtimeConfigDir = Files.createTempDirectory(stagingDir, Constants.Files.RUNTIME_CONFIG_JAR);\n+        twillRuntimeSpec = saveSpecification(twillSpec,\n+                                             runtimeConfigDir.resolve(Constants.Files.TWILL_SPEC), stagingDir);\n+        RuntimeSpecification runtimeSpec = twillRuntimeSpec.getTwillSpecification().getRunnables().values()\n+          .stream().findFirst().orElseThrow(IllegalStateException::new);\n+        saveLogback(runtimeConfigDir.resolve(Constants.Files.LOGBACK_TEMPLATE));\n+        saveClassPaths(runtimeConfigDir);\n+        saveArguments(new Arguments(arguments, runnableArgs), runtimeConfigDir.resolve(Constants.Files.ARGUMENTS));\n+        createRuntimeConfigJar(runtimeConfigDir, localFiles, stagingDir);\n+        Paths.deleteRecursively(runtimeConfigDir);\n+\n+        throwIfTimeout(startTime, timeout, timeoutUnit);\n+        List<LocalFile> launcherFiles = new ArrayList<>();\n+\n+        for (Map.Entry<String, LocalFile> entry : localFiles.entrySet()) {\n+          launcherFiles.add(entry.getValue());\n+        }\n+\n+        for (LocalFile file : runtimeSpec.getLocalFiles()) {\n+          if (file.getName().equals(\"artifacts\")) {\n+            launcherFiles.add(new DefaultLocalFile(\"artifacts.jar\", file.getURI(), file.getLastModified(),\n+                                                   file.getSize(), file.isArchive(), file.getPattern()));\n+            continue;\n+          }\n+          if (file.getName().equals(\"artifacts_archive.jar\")) {", "originalCommit": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwODk1MQ==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r397308951", "bodyText": "stale comment? this is not applicable any more.", "author": "CuriousVini", "createdAt": "2020-03-24T16:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0NjA2MQ=="}], "type": "inlineReview"}, {"oid": "52752b9ccd655b42f801d6a795c83182432954fb", "url": "https://github.com/cdapio/cdap/commit/52752b9ccd655b42f801d6a795c83182432954fb", "message": "Error handling", "committedDate": "2020-03-25T00:34:03Z", "type": "forcePushed"}, {"oid": "8ccf11404c240580df3bcbc127b73a2db9961d27", "url": "https://github.com/cdapio/cdap/commit/8ccf11404c240580df3bcbc127b73a2db9961d27", "message": "minor cleanup", "committedDate": "2020-03-27T01:18:59Z", "type": "forcePushed"}, {"oid": "384bd82b64ab67c8ed3e3e8997250b55fe1fef51", "url": "https://github.com/cdapio/cdap/commit/384bd82b64ab67c8ed3e3e8997250b55fe1fef51", "message": "Addressing comments", "committedDate": "2020-03-27T02:06:42Z", "type": "forcePushed"}, {"oid": "a6462be614de3a5c68cc2ab377cd027a0823cda9", "url": "https://github.com/cdapio/cdap/commit/a6462be614de3a5c68cc2ab377cd027a0823cda9", "message": "Addressing comments", "committedDate": "2020-04-01T19:59:30Z", "type": "forcePushed"}, {"oid": "ebea49ea2135ccd14c1474cc081445412a2d9ed4", "url": "https://github.com/cdapio/cdap/commit/ebea49ea2135ccd14c1474cc081445412a2d9ed4", "message": "Fix logappender extension. Start log extension service", "committedDate": "2020-04-01T19:59:15Z", "type": "forcePushed"}, {"oid": "d7dc8e77b5698bd9c67916c707b80afb2ca85cb7", "url": "https://github.com/cdapio/cdap/commit/d7dc8e77b5698bd9c67916c707b80afb2ca85cb7", "message": "Fix logappender extension. Start log extension service", "committedDate": "2020-04-01T20:40:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5OTE3Mg==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r401899172", "bodyText": "who is responsible for calling jobManager.kill?", "author": "CuriousVini", "createdAt": "2020-04-01T20:46:55Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "diffHunk": "@@ -16,222 +16,66 @@\n \n package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n \n-import com.google.common.base.Throwables;\n-import com.google.common.util.concurrent.Futures;\n-import com.google.common.util.concurrent.Uninterruptibles;\n-import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.internal.app.runtime.distributed.AbstractRuntimeTwillController;\n import io.cdap.cdap.proto.id.ProgramRunId;\n import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n-import org.apache.twill.api.Command;\n-import org.apache.twill.api.ResourceReport;\n-import org.apache.twill.api.RunId;\n import org.apache.twill.api.ServiceController;\n import org.apache.twill.api.TwillController;\n-import org.apache.twill.api.logging.LogEntry;\n-import org.apache.twill.api.logging.LogHandler;\n-import org.apache.twill.discovery.ServiceDiscovered;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executor;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import javax.annotation.Nullable;\n \n /**\n  * Implementation of {@link TwillController} that uses {@link RuntimeJobManager} to monitor and\n  * control a running program.\n  */\n-class RuntimeJobTwillController implements TwillController {\n-  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillController.class);\n+class RuntimeJobTwillController extends AbstractRuntimeTwillController {\n \n-  private final RunId runId;\n-  private final ProgramRunId programRunId;\n   private final RuntimeJobManager jobManager;\n-  private final CompletableFuture<RuntimeJobTwillController> started;\n-  private final CompletableFuture<RuntimeJobTwillController> completion;\n-  private final AtomicBoolean terminateCalled;\n+  private final ExecutorService executor;\n+  private final ProgramRunInfo programRunInfo;\n \n-  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId) {\n-    this.programRunId = programRunId;\n-    this.runId = RunIds.fromString(programRunId.getRun());\n+  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId,\n+                            CompletionStage<?> startupCompletionStage, ExecutorService executor) {\n+    super(programRunId, startupCompletionStage);\n     this.jobManager = jobManager;\n-    this.started = new CompletableFuture<>();\n-    this.completion = new CompletableFuture<>();\n-    this.terminateCalled = new AtomicBoolean();\n+    this.executor = executor;\n+    this.programRunInfo = new ProgramRunInfo.Builder()\n+      .setNamespace(programRunId.getNamespace())\n+      .setApplication(programRunId.getApplication())\n+      .setProgram(programRunId.getProgram())\n+      .setProgramType(programRunId.getType().getPrettyName())\n+      .setRun(programRunId.getRun()).build();\n   }\n \n   RuntimeJobManager getJobManager() {\n     return jobManager;\n   }\n \n-  void start(CompletableFuture<Void> startupTaskCompletion) {\n-    startupTaskCompletion.whenComplete((res, throwable) -> {\n-      if (throwable == null) {\n-        started.complete(this);\n-      } else {\n-        // terminate this controller with fail state\n-        completion.completeExceptionally(throwable);\n-      }\n-    });\n-  }\n-\n-  @Override\n-  public void addLogHandler(LogHandler handler) {\n-    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n-  }\n-\n-  @Override\n-  public ServiceDiscovered discoverService(String serviceName) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Integer> changeInstances(String runnable, int newCount) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Nullable\n-  @Override\n-  public ResourceReport getResourceReport() {\n-    return null;\n-  }\n-\n-  @Override\n-  public Future<String> restartAllInstances(String runnable) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Set<String>> restartInstances(Map<String, ? extends Set<Integer>> runnableToInstanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<String> restartInstances(String runnable, int instanceId, int... moreInstanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<String> restartInstances(String runnable, Set<Integer> instanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Map<String, LogEntry.Level>> updateLogLevels(Map<String, LogEntry.Level> logLevels) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<Map<String, LogEntry.Level>> updateLogLevels(String runnableName,\n-                                                             Map<String, LogEntry.Level> logLevelsForRunnable) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<String[]> resetLogLevels(String... loggerNames) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<String[]> resetRunnableLogLevels(String runnableName, String... loggerNames) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetRunnableLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public RunId getRunId() {\n-    return runId;\n-  }\n-\n-  @Override\n-  public Future<Command> sendCommand(Command command) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<Command> sendCommand(String runnableName, Command command) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n-  }\n-\n-  @Override\n-  public void onRunning(Runnable runnable, Executor executor) {\n-    started.thenRunAsync(runnable, executor);\n-  }\n-\n-  @Override\n-  public void onTerminated(Runnable runnable, Executor executor) {\n-    completion.whenCompleteAsync((remoteExecutionTwillController, throwable) -> runnable.run(), executor);\n-  }\n-\n-  @Override\n-  public void awaitTerminated() throws ExecutionException {\n-    Uninterruptibles.getUninterruptibly(completion);\n-  }\n-\n-  @Override\n-  public void awaitTerminated(long timeout, TimeUnit timeoutUnit) throws TimeoutException, ExecutionException {\n-    Uninterruptibles.getUninterruptibly(completion, timeout, timeoutUnit);\n-  }\n-\n   @Override\n   public Future<? extends ServiceController> terminate() {\n-    if (terminateCalled.compareAndSet(false, true)) {\n-      try {\n-        // stop the job\n-        jobManager.stop(new ProgramRunInfo.Builder()\n-                          .setNamespace(programRunId.getNamespace())\n-                          .setApplication(programRunId.getApplication())\n-                          .setProgram(programRunId.getProgram())\n-                          .setProgramType(programRunId.getType().getPrettyName())\n-                          .setRun(programRunId.getRun()).build());\n-        // mark completion as completed\n-        completion.complete(this);\n-      } catch (Exception e) {\n-        completion.completeExceptionally(e);\n-      }\n+    if (getTerminationFuture().isDone()) {\n+      return CompletableFuture.completedFuture(this);\n     }\n-    return completion;\n-  }\n \n-  @Override\n-  public void kill() {\n-    if (terminateCalled.compareAndSet(false, true)) {\n+    CompletableFuture<TwillController> result = getTerminationFuture().thenApply(r -> r);\n+    executor.execute(() -> {\n       try {\n-        // stop the job\n-        jobManager.kill(new ProgramRunInfo.Builder()\n-                          .setNamespace(programRunId.getNamespace())\n-                          .setApplication(programRunId.getApplication())\n-                          .setProgram(programRunId.getProgram())\n-                          .setProgramType(programRunId.getType().getPrettyName())\n-                          .setRun(programRunId.getRun()).build());\n-        // mark completion as completed\n-        completion.complete(this);\n+        if (jobManager.getDetail(programRunInfo).isPresent()) {\n+          // stop the job\n+          jobManager.stop(programRunInfo);", "originalCommit": "00db1497e9dc80ba381271df92cb0b9f54da92ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMDUyNw==", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r401900527", "bodyText": "oh right. Missed that during refactoring", "author": "chtyim", "createdAt": "2020-04-01T20:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5OTE3Mg=="}], "type": "inlineReview"}, {"oid": "e48fdadd92eeae34da885d75ea970d9084a1d8ed", "url": "https://github.com/cdapio/cdap/commit/e48fdadd92eeae34da885d75ea970d9084a1d8ed", "message": "[CDAP-16420]  Add twill runner service for job manager", "committedDate": "2020-04-01T21:10:49Z", "type": "commit"}, {"oid": "e48fdadd92eeae34da885d75ea970d9084a1d8ed", "url": "https://github.com/cdapio/cdap/commit/e48fdadd92eeae34da885d75ea970d9084a1d8ed", "message": "[CDAP-16420]  Add twill runner service for job manager", "committedDate": "2020-04-01T21:10:49Z", "type": "forcePushed"}]}