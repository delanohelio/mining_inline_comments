{"pr_number": 12450, "pr_title": "[CDAP-16850] Revamp schema editor", "pr_createdAt": "2020-07-13T15:26:21Z", "pr_url": "https://github.com/cdapio/cdap/pull/12450", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODIxNQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455448215", "bodyText": "I've noticed some types are in string form, should we define them in enum instead?", "author": "jennac3", "createdAt": "2020-07-16T00:57:41Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc0NTU4OA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456745588", "bodyText": "This is a valid point. I am making this in a separate PR. Will address this in that.", "author": "ajainarayanan", "createdAt": "2020-07-18T04:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODYwMQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455448601", "bodyText": "nit: I believe if (typeProperties.symbol && typeProperties.symbol.length > 0) may be less confusing, but this may be my biased opinion.", "author": "jennac3", "createdAt": "2020-07-16T00:59:09Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',\n+    items: null,\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type: childType, nullable: isArrayTypeNullable } = currentChild;\n+    const isArrayTypeComplex = isDisplayTypeComplex({ type: childType });\n+    if (!isArrayTypeComplex) {\n+      finalType.items = isArrayTypeNullable ? [childType, 'null'] : childType;\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(\n+      childType,\n+      currentChild,\n+      currentChild.nullable\n+    );\n+    if (complexType) {\n+      finalType.items = complexType;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateMapType(children: IOrderedChildren, nullable) {\n+  const finalType = {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type, nullable: isCurrentChildNullable, internalType } = currentChild;\n+    const isMapChildComplexType = isDisplayTypeComplex({ type });\n+    if (!isMapChildComplexType) {\n+      if (internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE) {\n+        finalType.keys = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      if (internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE) {\n+        finalType.values = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(type, currentChild, isCurrentChildNullable);\n+    if (internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT) {\n+      finalType.keys = complexType as any;\n+    }\n+    if (internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT) {\n+      finalType.values = complexType as any;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateEnumType(children: IOrderedChildren, currentNode: INode, nullable) {\n+  const finalType: IEnumFieldBase = {\n+    type: 'enum',\n+    symbols: [],\n+  };\n+  const { typeProperties: currentTypeProperties = {} } = currentNode;\n+  if (currentTypeProperties.doc) {\n+    finalType.doc = currentTypeProperties.doc;\n+  }\n+  if (currentTypeProperties.aliases) {\n+    finalType.aliases = currentTypeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { typeProperties } = currentChild;\n+      if (typeProperties.symbol && typeProperties.symbol !== '') {", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc0NTczNA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456745734", "bodyText": "Stating typeProperties.symbol !== '' is explicit. Checking for length could also mean it is an array.", "author": "ajainarayanan", "createdAt": "2020-07-18T04:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0OTEzOA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455449138", "bodyText": "I believe if (!name) will suffice since this will check for empty string as well.", "author": "jennac3", "createdAt": "2020-07-16T01:00:56Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',\n+    items: null,\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type: childType, nullable: isArrayTypeNullable } = currentChild;\n+    const isArrayTypeComplex = isDisplayTypeComplex({ type: childType });\n+    if (!isArrayTypeComplex) {\n+      finalType.items = isArrayTypeNullable ? [childType, 'null'] : childType;\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(\n+      childType,\n+      currentChild,\n+      currentChild.nullable\n+    );\n+    if (complexType) {\n+      finalType.items = complexType;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateMapType(children: IOrderedChildren, nullable) {\n+  const finalType = {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type, nullable: isCurrentChildNullable, internalType } = currentChild;\n+    const isMapChildComplexType = isDisplayTypeComplex({ type });\n+    if (!isMapChildComplexType) {\n+      if (internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE) {\n+        finalType.keys = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      if (internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE) {\n+        finalType.values = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(type, currentChild, isCurrentChildNullable);\n+    if (internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT) {\n+      finalType.keys = complexType as any;\n+    }\n+    if (internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT) {\n+      finalType.values = complexType as any;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateEnumType(children: IOrderedChildren, currentNode: INode, nullable) {\n+  const finalType: IEnumFieldBase = {\n+    type: 'enum',\n+    symbols: [],\n+  };\n+  const { typeProperties: currentTypeProperties = {} } = currentNode;\n+  if (currentTypeProperties.doc) {\n+    finalType.doc = currentTypeProperties.doc;\n+  }\n+  if (currentTypeProperties.aliases) {\n+    finalType.aliases = currentTypeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { typeProperties } = currentChild;\n+      if (typeProperties.symbol && typeProperties.symbol !== '') {\n+        finalType.symbols.push(typeProperties.symbol);\n+      }\n+      if (typeProperties.doc) {\n+        finalType.doc = typeProperties.doc;\n+      }\n+      if (typeProperties.aliases) {\n+        finalType.aliases = typeProperties.aliases;\n+      }\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateRecordType(children: IOrderedChildren, currentNode: INode, nullable: boolean) {\n+  const finalType: IRecordField = {\n+    type: 'record',\n+    name: currentNode.name || `name-${uuidV4()}`,\n+    fields: [],\n+  };\n+  const { typeProperties = {} } = currentNode;\n+  if (typeProperties.doc) {\n+    finalType.doc = typeProperties.doc;\n+  }\n+  if (typeProperties.aliases) {\n+    finalType.aliases = typeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { name, type, nullable: isFiledNullable } = currentChild;\n+      if (!name || name === '') {", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0OTc1NQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455449755", "bodyText": "I believe if (!name) will suffice since this will check for empty string as well.", "author": "jennac3", "createdAt": "2020-07-16T01:03:26Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',\n+    items: null,\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type: childType, nullable: isArrayTypeNullable } = currentChild;\n+    const isArrayTypeComplex = isDisplayTypeComplex({ type: childType });\n+    if (!isArrayTypeComplex) {\n+      finalType.items = isArrayTypeNullable ? [childType, 'null'] : childType;\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(\n+      childType,\n+      currentChild,\n+      currentChild.nullable\n+    );\n+    if (complexType) {\n+      finalType.items = complexType;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateMapType(children: IOrderedChildren, nullable) {\n+  const finalType = {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type, nullable: isCurrentChildNullable, internalType } = currentChild;\n+    const isMapChildComplexType = isDisplayTypeComplex({ type });\n+    if (!isMapChildComplexType) {\n+      if (internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE) {\n+        finalType.keys = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      if (internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE) {\n+        finalType.values = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(type, currentChild, isCurrentChildNullable);\n+    if (internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT) {\n+      finalType.keys = complexType as any;\n+    }\n+    if (internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT) {\n+      finalType.values = complexType as any;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateEnumType(children: IOrderedChildren, currentNode: INode, nullable) {\n+  const finalType: IEnumFieldBase = {\n+    type: 'enum',\n+    symbols: [],\n+  };\n+  const { typeProperties: currentTypeProperties = {} } = currentNode;\n+  if (currentTypeProperties.doc) {\n+    finalType.doc = currentTypeProperties.doc;\n+  }\n+  if (currentTypeProperties.aliases) {\n+    finalType.aliases = currentTypeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { typeProperties } = currentChild;\n+      if (typeProperties.symbol && typeProperties.symbol !== '') {\n+        finalType.symbols.push(typeProperties.symbol);\n+      }\n+      if (typeProperties.doc) {\n+        finalType.doc = typeProperties.doc;\n+      }\n+      if (typeProperties.aliases) {\n+        finalType.aliases = typeProperties.aliases;\n+      }\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateRecordType(children: IOrderedChildren, currentNode: INode, nullable: boolean) {\n+  const finalType: IRecordField = {\n+    type: 'record',\n+    name: currentNode.name || `name-${uuidV4()}`,\n+    fields: [],\n+  };\n+  const { typeProperties = {} } = currentNode;\n+  if (typeProperties.doc) {\n+    finalType.doc = typeProperties.doc;\n+  }\n+  if (typeProperties.aliases) {\n+    finalType.aliases = typeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { name, type, nullable: isFiledNullable } = currentChild;\n+      if (!name || name === '') {\n+        continue;\n+      }\n+      const isFieldTypeComplex = isDisplayTypeComplex({ type });\n+      if (!isFieldTypeComplex) {\n+        finalType.fields.push({\n+          name,\n+          type: isFiledNullable ? [type, 'null'] : type,\n+        });\n+      } else {\n+        finalType.fields.push({\n+          name,\n+          type: generateSchemaFromComplexType(\n+            currentChild.type,\n+            currentChild,\n+            currentChild.nullable\n+          ),\n+        });\n+      }\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateUnionType(children: IOrderedChildren) {\n+  const finalType = [];\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { type } = currentChild;\n+      const isUnionTypeComplex = isDisplayTypeComplex({ type });\n+      if (!isUnionTypeComplex) {\n+        finalType.push(type);\n+        continue;\n+      }\n+      finalType.push(generateSchemaFromComplexType(type, currentChild, false));\n+    }\n+  }\n+  return finalType;\n+}\n+\n+function generateLogicalType(child) {\n+  const { typeProperties, nullable } = child;\n+  return nullable ? [typeProperties, 'null'] : typeProperties;\n+}\n+\n+function generateSchemaFromComplexType(type: string, currentChild, nullable: boolean) {\n+  const complexTypeChildren: IOrderedChildren = currentChild.children;\n+  switch (type) {\n+    case 'array':\n+      return generateArrayType(complexTypeChildren, nullable);\n+    case 'map':\n+      return generateMapType(complexTypeChildren, nullable);\n+    case 'enum':\n+      return generateEnumType(complexTypeChildren, currentChild, nullable);\n+    case 'union':\n+      return generateUnionType(complexTypeChildren);\n+    case 'record':\n+      return generateRecordType(complexTypeChildren, currentChild, nullable);\n+    case 'time':\n+    case 'timestamp':\n+    case 'decimal':\n+    case 'date':\n+      return generateLogicalType(currentChild);\n+    default:\n+      return type;\n+  }\n+}\n+\n+/**\n+ * Utility to convert the entire schema tree to a valid avro schema JSON.\n+ * @param schemaTree Schema tree to convert to avro schema JSON.\n+ */\n+function SchemaGenerator(schemaTree: INode) {\n+  const avroSchema: ISchemaType = getDefaultEmptyAvroSchema();\n+  if (!schemaTree) {\n+    return avroSchema;\n+  }\n+  // Top level record fields.\n+  const { order } = schemaTree.children;\n+  if (Array.isArray(order)) {\n+    for (const id of order) {\n+      const currentField = schemaTree.children[id];\n+      const { name, type, nullable } = currentField;\n+      // Skip the newly added rows.\n+      if (!name || name === '') {", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MDU4Mg==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455450582", "bodyText": "this can be just '96px'", "author": "jennac3", "createdAt": "2020-07-16T01:06:42Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/FieldWrapper/index.tsx", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import Box from '@material-ui/core/Box';\n+import Paper from '@material-ui/core/Paper';\n+import isObject from 'lodash/isObject';\n+import withStyles from '@material-ui/core/styles/withStyles';\n+import If from 'components/If';\n+import { SiblingCommunicationConsumer } from 'components/AbstractWidget/SchemaEditor/FieldWrapper/SiblingCommunicationContext';\n+import { SchemaValidatorConsumer } from '../SchemaValidator';\n+import isNil from 'lodash/isNil';\n+import { SiblingLine } from 'components/AbstractWidget/SchemaEditor/FieldWrapper/SiblingLine';\n+import {\n+  INDENTATION_SPACING,\n+  rowHeight,\n+  rowMarginTop,\n+} from 'components/AbstractWidget/SchemaEditor/FieldWrapper/FieldWrapperConstants';\n+\n+interface IFieldWrapperProps {\n+  ancestors: string[];\n+  children?: React.ReactNode;\n+  style?: any;\n+  className?: any;\n+}\n+\n+const CustomizedPaper = withStyles(() => {\n+  return {\n+    root: {\n+      padding: '2px 10px 2px 0px',\n+      display: 'grid',\n+      marginTop: `${rowMarginTop}px`,\n+      gridTemplateRows: `${rowHeight}px`,\n+      position: 'relative',\n+    },\n+  };\n+})(Paper);\n+\n+const SiblingsWrapper = withStyles(() => {\n+  return {\n+    root: {\n+      position: 'absolute',\n+      left: 0,\n+      top: 0,\n+    },\n+  };\n+})(Box);\n+\n+const FieldWrapperBase = ({\n+  ancestors = [],\n+  children,\n+  style = {},\n+  className,\n+}: IFieldWrapperProps) => {\n+  /**\n+   * Based on the number of ancestors we indent the row accordingly. Each ancestor will\n+   * have a line indicating hierarchy and a horizontal line with immediate parent\n+   *\n+   * The design is to have a grid base row\n+   * - There is a single column wrapper (for unions and arrays) which is implemented by SingleColumnWrapper\n+   * - There is a two column layout for field name/type (or label and type for maps) and the\n+   * other for the row buttons. This helps us maintain the vertical alignment for row buttons\n+   * no matter what the indentation is.\n+   *\n+   * The width of the wrapper is reduced based on the indentation.\n+   */\n+  const spacing = ancestors.length * INDENTATION_SPACING;\n+  const firstColumn = '20px';\n+  const thirdColumn = `96px`;", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MDg3NA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455450874", "bodyText": "nit: are these console.log necessary?", "author": "jennac3", "createdAt": "2020-07-16T01:08:00Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SampleTypeFieldChecker.ts", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/**\n+ * This is purely a playground to play around and get an understanding on the\n+ * schema types. Not used anywhere.\n+ */\n+import {\n+  IArrayField,\n+  IArrayFieldNullable,\n+  IUnionField,\n+  IEnumField,\n+  IRecordField,\n+  IMapFieldBase,\n+  IMapField,\n+  IComplexType,\n+  ISimpleType,\n+  IComplexTypeFieldNullable,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+\n+const mapfield: IMapField = {\n+  name: 'map1',\n+  type: {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  },\n+};\n+// tslint:disable-next-line: no-console\n+console.log(mapfield.type.keys);\n+\n+const arrayField: IArrayField = {\n+  name: 'arr',\n+  type: {\n+    type: 'array',\n+    items: 'string',\n+  },\n+};\n+// tslint:disable-next-line: no-console\n+console.log(!Array.isArray(arrayField.type) ? arrayField.type.items : arrayField.type[0]);\n+\n+const unionField: IUnionField = {\n+  name: 'something',\n+  type: ['long', 'string'],\n+};\n+// tslint:disable-next-line: no-console\n+console.log(unionField.type[1]);\n+\n+const enumField: IEnumField = {\n+  name: 'enum1',\n+  type: {\n+    type: 'enum',\n+    symbols: ['something', 'somethingelse', 'nothing', 'maybesomething'],\n+  },\n+};\n+// tslint:disable-next-line: no-console\n+// tslint:disable-next-line: no-console\n+console.log(enumField.type.symbols);\n+\n+const recordField: IRecordField = {\n+  type: 'record',\n+  name: 'record1',\n+  fields: [\n+    {\n+      name: 'name',\n+      type: 'string',\n+    },\n+    {\n+      name: 'email',\n+      type: 'string',\n+    },\n+  ],\n+};\n+// tslint:disable-next-line: no-console\n+// tslint:disable-next-line: no-console\n+console.log(recordField.fields);\n+\n+const complexArrField2: IArrayFieldNullable = {\n+  name: 'arr1',\n+  type: [\n+    {\n+      type: 'array',\n+      items: 'string',\n+    },\n+    'null',\n+  ],\n+};\n+// tslint:disable-next-line: no-console\n+console.log(\n+  Array.isArray(complexArrField2.type)\n+    ? complexArrField2.type.find((t) => t !== 'null' && typeof t.items !== 'undefined')\n+    : complexArrField2.type\n+);\n+\n+const isNullable = (type) => Array.isArray(type) && type.find((t) => t === 'null');\n+const complexArrayField: IArrayFieldNullable = {\n+  name: 'complexArray',\n+  type: [\n+    {\n+      type: 'array',\n+      items: [\n+        {\n+          type: 'record',\n+          name: 'ad5bddf76ef2743218d79d3905f0f8e4f',\n+          fields: [\n+            {\n+              name: 'name',\n+              type: 'string',\n+            },\n+            {\n+              name: 'email',\n+              type: 'string',\n+            },\n+          ],\n+        },\n+        'null',\n+      ],\n+    },\n+    'null',\n+  ],\n+};\n+\n+if (Array.isArray(complexArrayField.type)) {\n+  const a1 = complexArrayField.type.find((t) => t !== 'null' && t.type === 'array');\n+  // tslint:disable-next-line: no-console\n+  console.log(a1 !== 'null' && a1.items);\n+  if (isNullable(complexArrayField.type)) {\n+    // tslint:disable-next-line: no-console\n+    console.log('nullable is true');\n+  }\n+}\n+\n+const complexUnionField: IUnionField = {\n+  name: 'something',\n+  type: [\n+    'long',\n+    {\n+      type: 'map',\n+      keys: {\n+        type: 'record',\n+        name: 'a64d56b7343854e81801874b77b536802',\n+        fields: [\n+          {\n+            name: 'sdfsd',\n+            type: 'string',\n+          },\n+          {\n+            name: 'sdfsdsdfsdf',\n+            type: 'string',\n+          },\n+        ],\n+      },\n+      values: 'string',\n+    },\n+    {\n+      type: 'record',\n+      name: 'record1',\n+      fields: [\n+        {\n+          name: 'name',\n+          type: 'string',\n+        },\n+        {\n+          name: 'email',\n+          type: 'string',\n+        },\n+      ],\n+    },\n+  ],\n+};\n+const isSimpleType = (type: ISimpleType | IComplexTypeFieldNullable) =>\n+  typeof type === 'string' &&\n+  [\n+    'boolean',\n+    'bytes',\n+    'date',\n+    'decimal',\n+    'double',\n+    'float',\n+    'int',\n+    'long',\n+    'number',\n+    'string',\n+    'time',\n+  ].indexOf(type) !== -1;\n+if (Array.isArray(complexUnionField.type)) {\n+  const map1 = complexUnionField.type\n+    .filter((t) => typeof t !== 'string')\n+    .find((t: IComplexType) => !Array.isArray(t.type) && t.type === 'map') as IMapFieldBase;\n+  let fieldsInRecords;\n+  if (!Array.isArray(map1.keys) && typeof map1.keys === 'object' && map1.keys.type === 'record') {\n+    fieldsInRecords = (map1.keys as IRecordField).fields;\n+  }\n+  // tslint:disable-next-line: no-console\n+  console.log(map1, fieldsInRecords);", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc0NTg1Mg==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456745852", "bodyText": "This file is not being used anywhere.. This is to playaround with schema and typescript types. We can safely ignore this file.", "author": "ajainarayanan", "createdAt": "2020-07-18T04:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MDg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MTM5MQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455451391", "bodyText": "this if (!invisible) can be moved outside so that it can be less nested.", "author": "jennac3", "createdAt": "2020-07-16T01:09:58Z", "path": "cdap-ui/app/cdap/components/If/index.tsx", "diffHunk": "@@ -14,15 +14,34 @@\n  * the License.\n  */\n import * as React from 'react';\n+import Box from '@material-ui/core/Box';\n+import withStyles from '@material-ui/core/styles/withStyles';\n \n interface IIfComponentProps {\n   condition: boolean;\n   children: React.ReactNode;\n+  invisible?: boolean;\n+  HiddenContainer?: React.ReactNode;\n }\n \n-const If: React.FC<IIfComponentProps> = ({ condition, children }) => {\n+const If: React.FC<IIfComponentProps> = ({\n+  condition,\n+  children,\n+  invisible = false,\n+  HiddenContainer,\n+}) => {\n   if (!condition) {\n-    return null;\n+    if (!invisible) {", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc0NjMxMg==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456746312", "bodyText": "Hhmm if we flatten it out we ideally check for invisible twice but I agree a flat if check is easier to read. Have changed it.", "author": "ajainarayanan", "createdAt": "2020-07-18T04:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MTM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MTY0MA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455451640", "bodyText": "can we just return result in try block?", "author": "jennac3", "createdAt": "2020-07-16T01:10:55Z", "path": "cdap-ui/app/cdap/services/helpers.js", "diffHunk": "@@ -490,6 +490,16 @@ function connectWithStore(store, WrappedComponent, ...args) {\n   };\n }\n \n+function dumbestClone(jsonObj) {\n+  let result;", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxNDQ1Nw==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455414457", "bodyText": "instead of importing the color, does it work if the function being passed to withStyles have the theme object?", "author": "elfenheart", "createdAt": "2020-07-15T23:05:13Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/FormInputs/Select/index.tsx", "diffHunk": "@@ -21,35 +21,59 @@ import { IWidgetProps } from 'components/AbstractWidget';\n import { objectQuery } from 'services/helpers';\n import { WIDGET_PROPTYPES } from 'components/AbstractWidget/constants';\n import withStyles from '@material-ui/core/styles/withStyles';\n-\n+import { blue } from 'components/ThemeWrapper/colors';", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MDA3OA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456750078", "bodyText": "Technically we should be able to use Theme since at some point we wrap this in ThemeWrapper for the theme to be passed down the context. But our definition of colors in the theme is not right. Palette in material-ui is not defined to have colors the way we define.\nSince I am still using the color used in the theme file, and even if we decide to change the color this directly gets affected. For now I would suggest let us have this. We need to fix the way we define colors in material-ui so that we could use the color we define directly from the theme without any hacks. Right now if I have to use the blue from the theme I have to type alias it to any (outline: '1px solid ${(theme.palette as any).blue[100]}')", "author": "ajainarayanan", "createdAt": "2020-07-18T05:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxNDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxNzUwNA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455417504", "bodyText": "combine the two if statements?", "author": "elfenheart", "createdAt": "2020-07-15T23:14:20Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/ArrayType/index.tsx", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import { schemaTypes } from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { SingleColumnWrapper } from 'components/AbstractWidget/SchemaEditor/SingleColumnWrapper';\n+import Select from 'components/AbstractWidget/FormInputs/Select';\n+import { IFieldTypeBaseProps } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import { RowButtons } from 'components/AbstractWidget/SchemaEditor/RowButtons';\n+\n+const ArrayTypeBase = ({\n+  type,\n+  nullable,\n+  onChange,\n+  autoFocus,\n+  typeProperties,\n+}: IFieldTypeBaseProps) => {\n+  const [fieldType, setFieldType] = React.useState(type);\n+  const [fieldNullable, setFieldNullable] = React.useState(nullable);\n+  const [fieldTypeProperties, setFieldTypeProperties] = React.useState(typeProperties || {});\n+\n+  const onTypePropertiesChangeHandler = (property, value) => {\n+    if (property === 'typeProperties') {\n+      setFieldTypeProperties(value);\n+    }\n+    onChange(property, value);\n+  };\n+  const inputEle = React.useRef(null);\n+  React.useEffect(() => {\n+    if (autoFocus) {\n+      if (inputEle.current) {", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxODU1OA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455418558", "bodyText": "should we extract the types of properties that can be updated into an Enum?", "author": "elfenheart", "createdAt": "2020-07-15T23:17:27Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/ArrayType/index.tsx", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import { schemaTypes } from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { SingleColumnWrapper } from 'components/AbstractWidget/SchemaEditor/SingleColumnWrapper';\n+import Select from 'components/AbstractWidget/FormInputs/Select';\n+import { IFieldTypeBaseProps } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import { RowButtons } from 'components/AbstractWidget/SchemaEditor/RowButtons';\n+\n+const ArrayTypeBase = ({\n+  type,\n+  nullable,\n+  onChange,\n+  autoFocus,\n+  typeProperties,\n+}: IFieldTypeBaseProps) => {\n+  const [fieldType, setFieldType] = React.useState(type);\n+  const [fieldNullable, setFieldNullable] = React.useState(nullable);\n+  const [fieldTypeProperties, setFieldTypeProperties] = React.useState(typeProperties || {});\n+\n+  const onTypePropertiesChangeHandler = (property, value) => {\n+    if (property === 'typeProperties') {", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MDQ2Ng==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456750466", "bodyText": "Yeah should have done that from the beginning. I am extracting the strings like type names and will do this as well in a separate PR. It looks like I repeat strings in a lot of places that can be an enum.", "author": "ajainarayanan", "createdAt": "2020-07-18T05:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxODU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ2ODQ5Mg==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455468492", "bodyText": "nit: unnecessary {}", "author": "elfenheart", "createdAt": "2020-07-16T02:13:18Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaManagerUtilities.ts", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  parseUnionType,\n+  parseArrayType,\n+  parseEnumType,\n+  parseMapType,\n+  IOrderedChildren,\n+  parseComplexType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  logicalTypes,\n+  defaultTimeStampTypeProperties,\n+  defaultDecimalTypeProperties,\n+  defaultTimeTypeProperties,\n+  defaultDateTypeProperties,\n+  defaultArrayType,\n+  defaultEnumType,\n+  defaultMapType,\n+  defaultRecordType,\n+  defaultUnionType,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import isEmpty from 'lodash/isEmpty';\n+\n+function getInternalType(tree: INode) {\n+  const hasChildren = tree.children ? Object.keys(tree.children).length : 0;\n+  if (tree.internalType === InternalTypesEnum.RECORD_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.RECORD_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.RECORD_COMPLEX_TYPE_ROOT && !hasChildren) {\n+    return InternalTypesEnum.RECORD_SIMPLE_TYPE;\n+  }\n+  if (tree.internalType === InternalTypesEnum.UNION_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.UNION_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.UNION_COMPLEX_TYPE_ROOT && !hasChildren) {\n+    return InternalTypesEnum.UNION_SIMPLE_TYPE;\n+  }\n+  if (tree.internalType === InternalTypesEnum.ARRAY_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.ARRAY_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.ARRAY_COMPLEX_TYPE_ROOT && !hasChildren) {\n+    return InternalTypesEnum.ARRAY_SIMPLE_TYPE;\n+  }\n+  if (tree.internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT && hasChildren) {\n+    return InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE;\n+  }\n+  if (tree.internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT && hasChildren) {\n+    return InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE;\n+  }\n+  return tree.internalType;\n+}\n+\n+const branchCount = (tree: INode): number => {\n+  let count = 0;\n+  if (tree && !isEmpty(tree.children) && Object.keys(tree.children).length) {\n+    // skip 'order' array which is under children.\n+    const children = Object.values(tree.children).filter((child) => !Array.isArray(child));\n+    count += children.length;\n+    children.forEach((child: INode) => {\n+      count += branchCount(child);\n+    });\n+  }\n+  return count;\n+};\n+\n+const initChildren = (type): IOrderedChildren => {\n+  switch (type) {\n+    case 'array':\n+      return parseArrayType(defaultArrayType);\n+    case 'enum':\n+      return parseEnumType(defaultEnumType);\n+    case 'map':\n+      return parseMapType(defaultMapType);\n+    case 'record': {\n+      return parseComplexType(defaultRecordType);\n+    }", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ2OTA5MA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455469090", "bodyText": "nit: remove {}", "author": "elfenheart", "createdAt": "2020-07-16T02:15:40Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaParser.ts", "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+import { IInternalFieldType } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import {\n+  ISchemaType,\n+  IDisplayType,\n+  IFieldType,\n+  IFieldTypeNullable,\n+  ILogicalTypeBase,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import {\n+  getComplexTypeName,\n+  isNullable,\n+  isComplexType,\n+  getNonNullableType,\n+  getSimpleType,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+import uuidV4 from 'uuid/v4';\n+import { InternalTypesEnum } from '../SchemaConstants';\n+\n+type ITypeProperties = Record<string, any>;\n+\n+/**\n+ * A generic node of the tree.\n+ * name, id, nullable and type - directly translate to the avro schema\n+ * children - is a map of child-id and the child node. In cases like records and enums\n+ * where the order of children needs to be maintained, the map will have a static\n+ * 'order' array.\n+ * internalType - purely used for presentation.\n+ * typeProperties - Defines the properties of the type. Right now this takes in\n+ * symbols in the enum and precision, scale in decimal types.\n+ */\n+interface INode {\n+  name?: string;\n+  children?: IOrderedChildren;\n+  id: string;\n+  internalType: IInternalFieldType;\n+  nullable?: boolean;\n+  type?: IDisplayType;\n+  typeProperties?: ITypeProperties;\n+}\n+\n+type IOrderedChildren = Record<string, INode> | Record<'order', string[]>;\n+\n+/**\n+ * {\n+ *  [child-id1]: {\n+ *    id: child-id1,\n+ *    internalType: 'union-simple-type',\n+ *    type: 'string'\n+ *  }\n+ * }\n+ * @param type avro union type\n+ * ['string']\n+ */\n+function parseUnionType(type): IOrderedChildren {\n+  const result: IOrderedChildren = {\n+    order: [],\n+  };\n+  for (const subType of type) {\n+    const id = uuidV4();\n+    result.order.push(id);\n+    if (isComplexType(subType)) {\n+      const typeName = getComplexTypeName(subType);\n+      result[id] = {\n+        id,\n+        type: typeName,\n+        internalType: InternalTypesEnum.UNION_COMPLEX_TYPE_ROOT,\n+        children: parseComplexType(subType),\n+      };\n+    } else {\n+      result[id] = {\n+        id,\n+        type: subType,\n+        nullable: false,\n+        internalType: InternalTypesEnum.UNION_SIMPLE_TYPE,\n+      };\n+    }\n+  }\n+  return result;\n+}\n+/**\n+ * @returns\n+ * {\n+ *  [child-id1]: {\n+ *    internalType: 'array-simple-type',\n+ *    type: 'string'\n+ *  }\n+ * }\n+ * @param type avro array type\n+ * {\n+ *  type: 'array',\n+ *  items: 'string'\n+ * }\n+ */\n+function parseArrayType(type): IOrderedChildren {\n+  const nullable = isNullable(type);\n+  const t = getNonNullableType(type);\n+  const id = uuidV4();\n+  if (t.items && !isComplexType(t.items)) {\n+    return {\n+      [id]: {\n+        internalType: InternalTypesEnum.ARRAY_SIMPLE_TYPE,\n+        id,\n+        nullable: isNullable(t.items),\n+        type: getNonNullableType(t.items),\n+      },\n+    };\n+  }\n+  return {\n+    [id]: {\n+      internalType: InternalTypesEnum.ARRAY_COMPLEX_TYPE_ROOT,\n+      id,\n+      nullable,\n+      type: getComplexTypeName(t.items),\n+      children: parseComplexType(t.items),\n+    },\n+  };\n+}\n+\n+/**\n+ * @returns\n+ * {\n+ *  order: [child-id1, child-id2,...]\n+ *  [child-id1]: {\n+ *    id: child-id1,\n+ *    internalType: 'enum-symbol',\n+ *    typeProperties: {\n+ *      symbol: 'symbol1'\n+ *    }\n+ *  },\n+ *  [child-id2]: {\n+ *    id: child-id2,\n+ *    internalType: 'enum-symbol',\n+ *    typeProperties: {\n+ *      symbol: 'symbol2'\n+ *    }\n+ *  }\n+ * }\n+ * @param type avro enum type\n+ * {\n+ *  type: 'enum',\n+ *  symbols: ['symbol1', 'symbol2', ....]\n+ * }\n+ */\n+function parseEnumType(type): IOrderedChildren {\n+  const nullable = isNullable(type);\n+  const t = getNonNullableType(type);\n+  const result = {\n+    order: [],\n+  };\n+  for (const symbol of t.symbols) {\n+    const id = uuidV4();\n+    result.order.push(id);\n+    result[id] = {\n+      id,\n+      internalType: InternalTypesEnum.ENUM_SYMBOL,\n+      nullable,\n+      typeProperties: {\n+        symbol,\n+      },\n+    };\n+  }\n+  return result;\n+}\n+\n+function getMapSubType(type, internalTypeName): INode {\n+  const id = uuidV4();\n+  if (!isComplexType(type)) {\n+    return {\n+      id,\n+      internalType: internalTypeName.simpleType,\n+      nullable: isNullable(type),\n+      type: getNonNullableType(type),\n+    };\n+  } else {\n+    const complexType = getComplexTypeName(type);\n+    const nullable = isNullable(type);\n+    return {\n+      children: parseComplexType(type),\n+      id,\n+      internalType: internalTypeName.complexType,\n+      type: complexType,\n+      nullable,\n+    };\n+  }\n+}\n+/**\n+ * @returns\n+ * {\n+ *   [child-id1]: {\n+ *    \"id\": child-id1,\n+ *    \"internalType\": \"map-keys-simple-type\",\n+ *    \"type\": \"string\"\n+ *  },\n+ *   [child-id2] {\n+ *    \"id\": child-id2,\n+ *    \"internalType\": \"map-values-simple-type\",\n+ *    \"nullable\": false,\n+ *    \"type\": \"string\"\n+ *   }\n+ * }\n+ * @param type avro map type\n+ * {\n+ *  type: {\n+ *    keys: 'string',\n+ *    values: 'string',\n+ *  }\n+ * }\n+ */\n+function parseMapType(type): IOrderedChildren {\n+  const t = getNonNullableType(type);\n+  const keysType = t.keys;\n+  const valuesType = t.values;\n+  const result: Record<string, INode> = {};\n+  const mapKeysSubType = getMapSubType(keysType, {\n+    simpleType: InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE,\n+    complexType: InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT,\n+  });\n+  const mapValuesSubType = getMapSubType(valuesType, {\n+    simpleType: InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE,\n+    complexType: InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT,\n+  });\n+  result[mapKeysSubType.id] = mapKeysSubType;\n+  result[mapValuesSubType.id] = mapValuesSubType;\n+  return result;\n+}\n+/**\n+ * @returns -\n+ * {\n+ *  [child-id1]:{\n+ *    id: child-id1,\n+ *    internalType: 'record-field-simple-type',\n+ *    type: 'string',\n+ *  },\n+ *  order: [child-id1]\n+ * }\n+ * @param type - avro record type\n+ * {\n+ *  name: 'record-name',\n+ *  type: 'record',\n+ *  fields: [ field1, field2 ...]\n+ * }\n+ */\n+function parseRecordType(type): IOrderedChildren {\n+  const t = getNonNullableType(type);\n+  const result = {\n+    order: [],\n+  };\n+  for (const field of t.fields) {\n+    const child = parseSubTree(field);\n+    result.order.push(child.id);\n+    result[child.id] = child;\n+  }\n+  return result;\n+}\n+\n+function parseComplexType(type): IOrderedChildren {\n+  const complexTypeName = getComplexTypeName(type);\n+  let record: IOrderedChildren = {};\n+  switch (complexTypeName) {\n+    case 'enum':\n+      record = parseEnumType(type);\n+      break;\n+    case 'array':\n+      record = parseArrayType(type);\n+      break;\n+    case 'record': {\n+      record = parseRecordType(type);\n+      break;\n+    }", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ2OTY2MA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455469660", "bodyText": "do these need to be exposed here? can these value just be inside the getMapSubType?", "author": "elfenheart", "createdAt": "2020-07-16T02:17:52Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaParser.ts", "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+import { IInternalFieldType } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import {\n+  ISchemaType,\n+  IDisplayType,\n+  IFieldType,\n+  IFieldTypeNullable,\n+  ILogicalTypeBase,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import {\n+  getComplexTypeName,\n+  isNullable,\n+  isComplexType,\n+  getNonNullableType,\n+  getSimpleType,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+import uuidV4 from 'uuid/v4';\n+import { InternalTypesEnum } from '../SchemaConstants';\n+\n+type ITypeProperties = Record<string, any>;\n+\n+/**\n+ * A generic node of the tree.\n+ * name, id, nullable and type - directly translate to the avro schema\n+ * children - is a map of child-id and the child node. In cases like records and enums\n+ * where the order of children needs to be maintained, the map will have a static\n+ * 'order' array.\n+ * internalType - purely used for presentation.\n+ * typeProperties - Defines the properties of the type. Right now this takes in\n+ * symbols in the enum and precision, scale in decimal types.\n+ */\n+interface INode {\n+  name?: string;\n+  children?: IOrderedChildren;\n+  id: string;\n+  internalType: IInternalFieldType;\n+  nullable?: boolean;\n+  type?: IDisplayType;\n+  typeProperties?: ITypeProperties;\n+}\n+\n+type IOrderedChildren = Record<string, INode> | Record<'order', string[]>;\n+\n+/**\n+ * {\n+ *  [child-id1]: {\n+ *    id: child-id1,\n+ *    internalType: 'union-simple-type',\n+ *    type: 'string'\n+ *  }\n+ * }\n+ * @param type avro union type\n+ * ['string']\n+ */\n+function parseUnionType(type): IOrderedChildren {\n+  const result: IOrderedChildren = {\n+    order: [],\n+  };\n+  for (const subType of type) {\n+    const id = uuidV4();\n+    result.order.push(id);\n+    if (isComplexType(subType)) {\n+      const typeName = getComplexTypeName(subType);\n+      result[id] = {\n+        id,\n+        type: typeName,\n+        internalType: InternalTypesEnum.UNION_COMPLEX_TYPE_ROOT,\n+        children: parseComplexType(subType),\n+      };\n+    } else {\n+      result[id] = {\n+        id,\n+        type: subType,\n+        nullable: false,\n+        internalType: InternalTypesEnum.UNION_SIMPLE_TYPE,\n+      };\n+    }\n+  }\n+  return result;\n+}\n+/**\n+ * @returns\n+ * {\n+ *  [child-id1]: {\n+ *    internalType: 'array-simple-type',\n+ *    type: 'string'\n+ *  }\n+ * }\n+ * @param type avro array type\n+ * {\n+ *  type: 'array',\n+ *  items: 'string'\n+ * }\n+ */\n+function parseArrayType(type): IOrderedChildren {\n+  const nullable = isNullable(type);\n+  const t = getNonNullableType(type);\n+  const id = uuidV4();\n+  if (t.items && !isComplexType(t.items)) {\n+    return {\n+      [id]: {\n+        internalType: InternalTypesEnum.ARRAY_SIMPLE_TYPE,\n+        id,\n+        nullable: isNullable(t.items),\n+        type: getNonNullableType(t.items),\n+      },\n+    };\n+  }\n+  return {\n+    [id]: {\n+      internalType: InternalTypesEnum.ARRAY_COMPLEX_TYPE_ROOT,\n+      id,\n+      nullable,\n+      type: getComplexTypeName(t.items),\n+      children: parseComplexType(t.items),\n+    },\n+  };\n+}\n+\n+/**\n+ * @returns\n+ * {\n+ *  order: [child-id1, child-id2,...]\n+ *  [child-id1]: {\n+ *    id: child-id1,\n+ *    internalType: 'enum-symbol',\n+ *    typeProperties: {\n+ *      symbol: 'symbol1'\n+ *    }\n+ *  },\n+ *  [child-id2]: {\n+ *    id: child-id2,\n+ *    internalType: 'enum-symbol',\n+ *    typeProperties: {\n+ *      symbol: 'symbol2'\n+ *    }\n+ *  }\n+ * }\n+ * @param type avro enum type\n+ * {\n+ *  type: 'enum',\n+ *  symbols: ['symbol1', 'symbol2', ....]\n+ * }\n+ */\n+function parseEnumType(type): IOrderedChildren {\n+  const nullable = isNullable(type);\n+  const t = getNonNullableType(type);\n+  const result = {\n+    order: [],\n+  };\n+  for (const symbol of t.symbols) {\n+    const id = uuidV4();\n+    result.order.push(id);\n+    result[id] = {\n+      id,\n+      internalType: InternalTypesEnum.ENUM_SYMBOL,\n+      nullable,\n+      typeProperties: {\n+        symbol,\n+      },\n+    };\n+  }\n+  return result;\n+}\n+\n+function getMapSubType(type, internalTypeName): INode {\n+  const id = uuidV4();\n+  if (!isComplexType(type)) {\n+    return {\n+      id,\n+      internalType: internalTypeName.simpleType,\n+      nullable: isNullable(type),\n+      type: getNonNullableType(type),\n+    };\n+  } else {\n+    const complexType = getComplexTypeName(type);\n+    const nullable = isNullable(type);\n+    return {\n+      children: parseComplexType(type),\n+      id,\n+      internalType: internalTypeName.complexType,\n+      type: complexType,\n+      nullable,\n+    };\n+  }\n+}\n+/**\n+ * @returns\n+ * {\n+ *   [child-id1]: {\n+ *    \"id\": child-id1,\n+ *    \"internalType\": \"map-keys-simple-type\",\n+ *    \"type\": \"string\"\n+ *  },\n+ *   [child-id2] {\n+ *    \"id\": child-id2,\n+ *    \"internalType\": \"map-values-simple-type\",\n+ *    \"nullable\": false,\n+ *    \"type\": \"string\"\n+ *   }\n+ * }\n+ * @param type avro map type\n+ * {\n+ *  type: {\n+ *    keys: 'string',\n+ *    values: 'string',\n+ *  }\n+ * }\n+ */\n+function parseMapType(type): IOrderedChildren {\n+  const t = getNonNullableType(type);\n+  const keysType = t.keys;\n+  const valuesType = t.values;\n+  const result: Record<string, INode> = {};\n+  const mapKeysSubType = getMapSubType(keysType, {\n+    simpleType: InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE,\n+    complexType: InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT,\n+  });\n+  const mapValuesSubType = getMapSubType(valuesType, {\n+    simpleType: InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE,\n+    complexType: InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT,", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MDYyMw==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456750623", "bodyText": "I am using it for both keys and values type. Depending on the usage the simpleType and complexType differs. Do you recommend anything specific we can do here?", "author": "ajainarayanan", "createdAt": "2020-07-18T05:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ2OTY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3MDk2Ng==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455470966", "bodyText": "this style seemed to be the same across a few places. Does it make sense to extract?", "author": "elfenheart", "createdAt": "2020-07-16T02:22:58Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/RowButtons/FieldAttributes/RecordEnumAttributes.tsx", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import WidgetWrapper from 'components/ConfigurationGroup/WidgetWrapper';\n+import Button from '@material-ui/core/Button';\n+import makeStyles from '@material-ui/core/styles/makeStyles';\n+import { IAttributesComponentProps } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+\n+const useStyles = makeStyles({\n+  root: {\n+    marginTop: '15px',\n+    maxHeight: '250px',\n+    overflowY: 'auto',\n+    '& >div': {\n+      margin: '10px 0',\n+    },\n+  },\n+});", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3MjkzMw==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455472933", "bodyText": "minor optimization, should we just cloneDeep here instead of at the beginning of the function? It seems like only this part requires the cloned type object", "author": "elfenheart", "createdAt": "2020-07-16T02:30:21Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SchemaHelpers.ts", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  IComplexTypeNames,\n+  ISimpleType,\n+  ILogicalTypeNames,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import { logicalTypeToSimpleTypeMap } from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import cloneDeep from 'lodash/cloneDeep';\n+\n+const displayTypes: Array<ISimpleType | IComplexTypeNames | ILogicalTypeNames> = [\n+  'array',\n+  'enum',\n+  'map',\n+  'record',\n+  'union',\n+  'boolean',\n+  'bytes',\n+  'date',\n+  'decimal',\n+  'double',\n+  'float',\n+  'int',\n+  'long',\n+  'number',\n+  'string',\n+  'time',\n+  'timestamp-micros',\n+  'date',\n+  'time-micros',\n+  'decimal',\n+];\n+\n+/**\n+ * Checks if the current avro type is nullable.\n+ * @param type any avro type (simple/complex types).\n+ */\n+const isNullable = (type) => {\n+  if (Array.isArray(type)) {\n+    return type.find((t) => t === 'null') === 'null';\n+  }\n+  return false;\n+};\n+\n+const isUnion = (type) => {\n+  return Array.isArray(type) && !isNullable(type);\n+};\n+/**\n+ * If the type is nullable get the non-null type for further processing.\n+ * @param type any valid avro type\n+ */\n+const getNonNullableType = (type) => {\n+  if (Array.isArray(type) && !isUnion(type)) {\n+    const nonNullTypes = type.filter((t) => t !== 'null');\n+    if (nonNullTypes.length === 1 && type.length - 1 === nonNullTypes.length) {\n+      return nonNullTypes[0];\n+    }\n+  }\n+  return type;\n+};\n+/**\n+ * Helps in getting the simple type or underlying type in a logical type.\n+ * @param type valid simple/logical avro type\n+ */\n+const getSimpleType = (type) => {\n+  if (typeof type === 'string') {\n+    return type;\n+  }\n+  if (type && type.logicalType) {\n+    return logicalTypeToSimpleTypeMap[type.logicalType];\n+  }\n+  return type;\n+};\n+/**\n+ * Utility to check if the current type is a complex type to tranverse further\n+ * into the schema tree.\n+ * @param complexType any valid complex avro type. (map, array, record, union and enum)\n+ */\n+const isComplexType = (complexType) => {\n+  const nullable = isNullable(complexType);\n+  let type = complexType;\n+  if (nullable) {\n+    type = complexType.filter((t) => t !== 'null').pop();\n+  }\n+  if (typeof type === 'string') {\n+    return false;\n+  }\n+  switch (type.type) {\n+    case 'record':\n+    case 'enum':\n+    case 'array':\n+    case 'map':\n+      return true;\n+    default:\n+      return isUnion(complexType) ? true : false;\n+  }\n+};\n+\n+const isDisplayTypeLogical = ({ type }) => {\n+  switch (type) {\n+    case 'decimal':\n+    case 'date':\n+    case 'time':\n+    case 'timestamp':\n+      return true;\n+    default:\n+      return false;\n+  }\n+};\n+\n+const isDisplayTypeComplex = ({ type }) => {\n+  switch (type) {\n+    case 'record':\n+    case 'enum':\n+    case 'union':\n+    case 'map':\n+    case 'array':\n+      return true;\n+    default:\n+      return isDisplayTypeLogical({ type }) || false;\n+  }\n+};\n+\n+/**\n+ * Utility function to get the complex type names.\n+ * @param complexType any valid complex avro type.\n+ */\n+const getComplexTypeName = (complexType): IComplexTypeNames => {\n+  const c = cloneDeep(complexType);\n+  let type;\n+  if (isNullable(complexType)) {\n+    type = complexType.filter((t) => t !== 'null').pop();\n+    type = type.type;\n+  } else {\n+    type = c.type;", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3NDMyOQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455474329", "bodyText": "I think for this particular case, we can use the getDerivedStateFromProps lifecycle and memoizing it since you need to update the state based on props change. Might future-proof this since componentWillReceiveProps is being deprecated", "author": "elfenheart", "createdAt": "2020-07-16T02:35:41Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/index.tsx", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import withStyles, { WithStyles, StyleRules } from '@material-ui/styles/withStyles';\n+import ThemeWrapper from 'components/ThemeWrapper';\n+import {\n+  SchemaManager,\n+  INode,\n+  ISchemaManager,\n+  IOnChangeReturnType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManager';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import {\n+  IFlattenRowType,\n+  IFieldIdentifier,\n+  IOnChangePayload,\n+} from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import { FieldsList } from 'components/AbstractWidget/SchemaEditor/FieldsList';\n+import {\n+  SchemaValidatorConsumer,\n+  SchemaValidatorProvider,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaValidator';\n+import { dumbestClone as cloneDeep } from 'services/helpers';\n+\n+const styles = (): StyleRules => {\n+  return {\n+    schemaContainer: {\n+      width: '100%',\n+      height: '100%',\n+    },\n+  };\n+};\n+\n+interface ISchemaEditorProps extends WithStyles<typeof styles> {\n+  schema: ISchemaType;\n+  onChange: (props: {\n+    tree: INode;\n+    flat: IFlattenRowType[];\n+    avroSchema: ISchemaType;\n+  }) => IOnChangeReturnType;\n+}\n+\n+interface ISchemaEditorState {\n+  tree: INode;\n+  flat: IFlattenRowType[];\n+}\n+\n+class SchemaEditorBase extends React.Component<ISchemaEditorProps, ISchemaEditorState> {\n+  private schema: ISchemaManager = null;\n+  constructor(props) {\n+    super(props);\n+    const { options } = props;\n+    this.schema = SchemaManager(this.props.schema, options).getInstance();\n+    this.state = {\n+      flat: cloneDeep(this.schema.getFlatSchema()),\n+      tree: cloneDeep(this.schema.getSchemaTree()),\n+    };\n+  }\n+\n+  public componentWillReceiveProps(nextProps) {", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MTk0Ng==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456751946", "bodyText": "In a future PR I am getting rid of this function. Any component that needs to update the schemaeditor with new schema has to reload the component. It became a hassle when integrating with the plugins.", "author": "ajainarayanan", "createdAt": "2020-07-18T05:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3NDMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3NTQwMg==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455475402", "bodyText": "can we use this just as dumbestClone and not alias it with cloneDeep? Might be easier to detect if we need to refactor later simply through search", "author": "elfenheart", "createdAt": "2020-07-16T02:39:58Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/index.tsx", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import withStyles, { WithStyles, StyleRules } from '@material-ui/styles/withStyles';\n+import ThemeWrapper from 'components/ThemeWrapper';\n+import {\n+  SchemaManager,\n+  INode,\n+  ISchemaManager,\n+  IOnChangeReturnType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManager';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import {\n+  IFlattenRowType,\n+  IFieldIdentifier,\n+  IOnChangePayload,\n+} from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import { FieldsList } from 'components/AbstractWidget/SchemaEditor/FieldsList';\n+import {\n+  SchemaValidatorConsumer,\n+  SchemaValidatorProvider,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaValidator';\n+import { dumbestClone as cloneDeep } from 'services/helpers';", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MTk4Nw==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456751987", "bodyText": "When renaming the function for some reason typescript created the alias here instead of the helpers. Have changed.", "author": "ajainarayanan", "createdAt": "2020-07-18T05:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3NTQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU0MTIzOA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456541238", "bodyText": "I don't see \"isFiledNullable\" defined anywhere - should this just be \"nullable\"? (same for line 145)", "author": "yukiej", "createdAt": "2020-07-17T16:16:22Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',\n+    items: null,\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type: childType, nullable: isArrayTypeNullable } = currentChild;\n+    const isArrayTypeComplex = isDisplayTypeComplex({ type: childType });\n+    if (!isArrayTypeComplex) {\n+      finalType.items = isArrayTypeNullable ? [childType, 'null'] : childType;\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(\n+      childType,\n+      currentChild,\n+      currentChild.nullable\n+    );\n+    if (complexType) {\n+      finalType.items = complexType;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateMapType(children: IOrderedChildren, nullable) {\n+  const finalType = {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type, nullable: isCurrentChildNullable, internalType } = currentChild;\n+    const isMapChildComplexType = isDisplayTypeComplex({ type });\n+    if (!isMapChildComplexType) {\n+      if (internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE) {\n+        finalType.keys = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      if (internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE) {\n+        finalType.values = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(type, currentChild, isCurrentChildNullable);\n+    if (internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT) {\n+      finalType.keys = complexType as any;\n+    }\n+    if (internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT) {\n+      finalType.values = complexType as any;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateEnumType(children: IOrderedChildren, currentNode: INode, nullable) {\n+  const finalType: IEnumFieldBase = {\n+    type: 'enum',\n+    symbols: [],\n+  };\n+  const { typeProperties: currentTypeProperties = {} } = currentNode;\n+  if (currentTypeProperties.doc) {\n+    finalType.doc = currentTypeProperties.doc;\n+  }\n+  if (currentTypeProperties.aliases) {\n+    finalType.aliases = currentTypeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { typeProperties } = currentChild;\n+      if (typeProperties.symbol && typeProperties.symbol !== '') {\n+        finalType.symbols.push(typeProperties.symbol);\n+      }\n+      if (typeProperties.doc) {\n+        finalType.doc = typeProperties.doc;\n+      }\n+      if (typeProperties.aliases) {\n+        finalType.aliases = typeProperties.aliases;\n+      }\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateRecordType(children: IOrderedChildren, currentNode: INode, nullable: boolean) {\n+  const finalType: IRecordField = {\n+    type: 'record',\n+    name: currentNode.name || `name-${uuidV4()}`,\n+    fields: [],\n+  };\n+  const { typeProperties = {} } = currentNode;\n+  if (typeProperties.doc) {\n+    finalType.doc = typeProperties.doc;\n+  }\n+  if (typeProperties.aliases) {\n+    finalType.aliases = typeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { name, type, nullable: isFiledNullable } = currentChild;", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MjUwOQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456652509", "bodyText": "Should this be isFieldNullable?", "author": "njbriggs", "createdAt": "2020-07-17T20:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU0MTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU0NDMxMQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456544311", "bodyText": "nit: The naming of this (currently numeric) variable sounds like it is a boolean, and it looks like it is being used as a boolean value. Maybe it can be modified slightly to have a boolean value.", "author": "yukiej", "createdAt": "2020-07-17T16:22:52Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaManagerUtilities.ts", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  parseUnionType,\n+  parseArrayType,\n+  parseEnumType,\n+  parseMapType,\n+  IOrderedChildren,\n+  parseComplexType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  logicalTypes,\n+  defaultTimeStampTypeProperties,\n+  defaultDecimalTypeProperties,\n+  defaultTimeTypeProperties,\n+  defaultDateTypeProperties,\n+  defaultArrayType,\n+  defaultEnumType,\n+  defaultMapType,\n+  defaultRecordType,\n+  defaultUnionType,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import isEmpty from 'lodash/isEmpty';\n+\n+function getInternalType(tree: INode) {\n+  const hasChildren = tree.children ? Object.keys(tree.children).length : 0;", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3Njk1OQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456576959", "bodyText": "Nit: Should this be capitalized for consistency?", "author": "yukiej", "createdAt": "2020-07-17T17:28:19Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/RowButtons/FieldAttributes/RecordEnumAttributes.tsx", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import WidgetWrapper from 'components/ConfigurationGroup/WidgetWrapper';\n+import Button from '@material-ui/core/Button';\n+import makeStyles from '@material-ui/core/styles/makeStyles';\n+import { IAttributesComponentProps } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+\n+const useStyles = makeStyles({\n+  root: {\n+    marginTop: '15px',\n+    maxHeight: '250px',\n+    overflowY: 'auto',\n+    '& >div': {\n+      margin: '10px 0',\n+    },\n+  },\n+});\n+\n+function RecordEnumTypeAttributes({\n+  typeProperties,\n+  onChange,\n+  handleClose,\n+}: IAttributesComponentProps) {\n+  const [doc, setDoc] = React.useState(typeProperties.doc || '');\n+  const [aliases, setAlias] = React.useState(typeProperties.aliases || []);\n+  const classes = useStyles();\n+\n+  const onChangeHandler = () => {\n+    onChange('typeProperties', {\n+      doc,\n+      aliases,\n+    });\n+    handleClose();\n+  };\n+  return (\n+    <React.Fragment>\n+      <div className={classes.root}>\n+        <WidgetWrapper\n+          pluginProperty={{\n+            name: 'doc',\n+            macroSupported: false,\n+            description: 'doc for the record',", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MjM3NA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456752374", "bodyText": "I actually got feedback for this even before creating the PR and yet missed this one \ud83d\ude44 . Thanks for catching this!.", "author": "ajainarayanan", "createdAt": "2020-07-18T05:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3Njk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4MzE2NQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456583165", "bodyText": "Should this be null (without the single quotes)?", "author": "yukiej", "createdAt": "2020-07-17T17:40:59Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SchemaTypes.ts", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/**\n+ * Contains types used in parsing an avro schema.\n+ * TODO: This is a work in progress. We don't use these types yet fully\n+ * in the schema parser yet.\n+ */\n+type IComplexTypeNames = 'array' | 'enum' | 'map' | 'record' | 'union';\n+type ISimpleType =\n+  | 'boolean'\n+  | 'bytes'\n+  | 'date'\n+  | 'decimal'\n+  | 'double'\n+  | 'float'\n+  | 'int'\n+  | 'long'\n+  | 'number'\n+  | 'string'\n+  | 'time'\n+  | 'timestamp';\n+type ILogicalTypeNames = 'timestamp-micros' | 'date' | 'time-micros' | 'decimal';\n+\n+type IDisplayType = ISimpleType | IComplexTypeNames;\n+\n+type ISimpleTypeNullable = Array<ISimpleType | 'null'>;", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MjQ2Ng==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456752466", "bodyText": "No. 'null' should be a string. 'null' in avro is actually a valid type. We treat it as auxillary information for any type because it makes user experience much simpler.", "author": "ajainarayanan", "createdAt": "2020-07-18T05:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4MzE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4Mzg1Nw==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456583857", "bodyText": "Do we know for sure that the error is always in e.message?", "author": "yukiej", "createdAt": "2020-07-17T17:42:23Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SchemaValidator/index.tsx", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import cdapavsc from 'services/cdapavscwrapper';\n+import {\n+  SchemaGenerator,\n+  generateSchemaFromComplexType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaGenerator';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import { IFlattenRowType } from '../EditorTypes';\n+import { isNilOrEmpty } from 'services/helpers';\n+\n+/**\n+ * Schema validator is independent of the schema editor. It takes in a schema tree\n+ * and converts to an avro schema and parses the schema through the avsc library\n+ *\n+ * The context provides a way to broadcast the error to appropriate row\n+ *\n+ * We cannot pin point the error to a specific row as avsc library doesn't\n+ * provide details on the place of failure. We right now surface the error\n+ * to the parent to show the error under a tree.\n+ *\n+ * This is separate in an effort to push this processing to a web worker in the future.\n+ * If we are not able write our own avro schema parser we won't be able to pinpoint\n+ * the error to a specific row. In which we have to recurrsively parse each node\n+ * in the schema tree to identify specific row of issue. This kind of processing\n+ * will bring the UI down which is when we will move this to the web worker.\n+ */\n+interface ISchemaValidatorProviderBaseState {\n+  id: string;\n+  time: number;\n+  error: string;\n+}\n+interface ISchemaValidatorContext {\n+  validate: (id: string, avroSchema: ISchemaType) => ISchemaValidatorProviderBaseState;\n+  errorMap: Record<string, ISchemaValidatorProviderBaseState>;\n+}\n+const SchemaValidatorContext = React.createContext<ISchemaValidatorContext>({\n+  validate: null,\n+  errorMap: {},\n+});\n+const SchemaValidatorConsumer = SchemaValidatorContext.Consumer;\n+\n+class SchemaValidatorProvider extends React.Component {\n+  public defaultState = {\n+    errorMap: {},\n+  };\n+\n+  /**\n+   * The subtree validation takes in a flat field, its ancestors\n+   * and navigates to the appropriate child in the schema tree and parses\n+   * the subtree. If it is valid nothing happens. If it is invalid we add the\n+   * error to the validator context with the id of the immediate parent of the field\n+   *\n+   * The error validation consumer is used per row and whichever row is added\n+   * to the error map gets highlighted with error.\n+   *\n+   * The sibliling line connection gets highlighted when parent is higlighted with an\n+   * error.\n+   * @param field Current flat row updated by user\n+   * @param schemaTree schema tree to validate against.\n+   */\n+  private isSubTreeValidAvroSchema = (field: IFlattenRowType, schemaTree) => {\n+    const { ancestors } = field;\n+    if (!ancestors || (Array.isArray(ancestors) && !ancestors.length)) {\n+      return;\n+    }\n+    if (ancestors.length === 1) {\n+      try {\n+        const entireSchema = SchemaGenerator(schemaTree);\n+        cdapavsc.parse(entireSchema.schema, { wrapUnions: true });\n+      } catch (e) {\n+        return { error: e.message, fieldIdToShowError: ancestors[0] };", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MjUzMA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456752530", "bodyText": "Yeah this is the standard javascript error thrown from within the library.", "author": "ajainarayanan", "createdAt": "2020-07-18T05:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4Mzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4NDM0Ng==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456584346", "bodyText": "Nit: these numbers don't add up to 132", "author": "yukiej", "createdAt": "2020-07-17T17:43:23Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SingleColumnWrapper/index.tsx", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import withStyles from '@material-ui/core/styles/withStyles';\n+import Box from '@material-ui/core/Box';\n+/**\n+ * Row wrapper used for unions and array type rows.\n+ */\n+const SingleColumnWrapper = withStyles(() => {\n+  return {\n+    root: {\n+      width: '132px', // 50 + 100 + 10 from the mapwrapper", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxNjI0MQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456716241", "bodyText": "This has a leading |. I don't know if it matters though.", "author": "njbriggs", "createdAt": "2020-07-17T23:41:20Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/EditorTypes.ts", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/**\n+ * Contains types used only by the editor for presentation.\n+ */\n+import { ISimpleType, IComplexTypeNames } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import { ITypeProperties } from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import { OperationTypesEnum } from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+\n+type IInternalFieldType =\n+  | 'schema'\n+  | 'record-field-simple-type'\n+  | 'record-field-complex-type-root'\n+  | 'array-simple-type'\n+  | 'array-complex-type'\n+  | 'array-complex-type-root'\n+  | 'enum-symbol'\n+  | 'map-keys-complex-type-root'\n+  | 'map-keys-simple-type'\n+  | 'map-values-complex-type-root'\n+  | 'map-values-simple-type'\n+  | 'union-simple-type'\n+  | 'union-complex-type-root';\n+\n+/**\n+ * Type of flattened row for rendering.\n+ * Contains context for that specific row. We have 'ancestors' here to show the\n+ * indentation for complex types.\n+ *\n+ * Every row will have a hidden flag. Potentially every row can be hidden\n+ * when the user collapses.\n+ *\n+ * Rows that has children will have a boolean collapsed.\n+ */\n+interface IFlattenRowType {\n+  id: string;\n+  name?: string;\n+  type?: ISimpleType | IComplexTypeNames;\n+  internalType: IInternalFieldType;\n+  nullable?: boolean;\n+  ancestors: string[];\n+  typeProperties?: ITypeProperties;\n+  collapsed?: boolean;\n+  hidden?: boolean;\n+}\n+\n+interface IFieldIdentifier {\n+  id: string;\n+  ancestors: string[];\n+}\n+type IOnchangeHandler = (property: string, value?: string | boolean | ITypeProperties) => void;\n+type IRowOnChangeHandler = (id: IFieldIdentifier, payload: IOnChangePayload) => void;\n+interface IFieldTypeBaseProps {\n+  name?: string;\n+  type?: ISimpleType | IComplexTypeNames;\n+  nullable?: boolean;\n+  internalType?: IInternalFieldType;\n+  typeProperties?: ITypeProperties;\n+  onChange: IOnchangeHandler;\n+  onAdd: () => void;\n+  onRemove: () => void;\n+  autoFocus?: boolean;\n+}\n+\n+interface IOnChangePayload {\n+  property?: string;\n+  value?: string | ITypeProperties;\n+  type:\n+    | OperationTypesEnum.UPDATE", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MjY2Mg==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456752662", "bodyText": "So apparently this seems to be a valid typescript syntax. This is done by prettier's auto format.", "author": "ajainarayanan", "createdAt": "2020-07-18T05:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxNjI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTk3NA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456725974", "bodyText": "Seems odd to import IconWrapper from RemoveRowButton?", "author": "njbriggs", "createdAt": "2020-07-18T00:37:08Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/RowButtons/AddRowButton.tsx", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import AddIcon from '@material-ui/icons/Add';\n+import { IconWrapper } from 'components/AbstractWidget/SchemaEditor/RowButtons/RemoveRowButton';", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNzk2OQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456727969", "bodyText": "Do we want to add this to If or create a new Hidden component? If seems like it should stay a one-purpose component.", "author": "njbriggs", "createdAt": "2020-07-18T00:50:18Z", "path": "cdap-ui/app/cdap/components/If/index.tsx", "diffHunk": "@@ -14,15 +14,34 @@\n  * the License.\n  */\n import * as React from 'react';\n+import Box from '@material-ui/core/Box';\n+import withStyles from '@material-ui/core/styles/withStyles';\n \n interface IIfComponentProps {\n   condition: boolean;\n   children: React.ReactNode;\n+  invisible?: boolean;\n+  HiddenContainer?: React.ReactNode;\n }\n \n-const If: React.FC<IIfComponentProps> = ({ condition, children }) => {\n+const If: React.FC<IIfComponentProps> = ({\n+  condition,\n+  children,\n+  invisible = false,", "originalCommit": "44b101ef4258df00e88aab3e9723150a26184af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1MzIyMA==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456753220", "bodyText": "The thought process was if the condition is false the children under the If doesn't get rendered. We can choose to make it invisible (occupying the space) or set it to display none there by avoiding browser to paint anything.\nIf you feel we should have this as a separate component I can make it but it will still do the same thing done by If except set the visibility to hidden instead of display none.", "author": "ajainarayanan", "createdAt": "2020-07-18T05:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNzk2OQ=="}], "type": "inlineReview"}, {"oid": "795ab020a36d3a8af39c7ef0486cd963dc859b2a", "url": "https://github.com/cdapio/cdap/commit/795ab020a36d3a8af39c7ef0486cd963dc859b2a", "message": "Addresses review comments", "committedDate": "2020-07-18T05:47:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNDI3MQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r457804271", "bodyText": "Is exporting INode here a typo? Since we imported it from SchemaParser", "author": "yukiej", "createdAt": "2020-07-21T02:48:47Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaManager.ts", "diffHunk": "@@ -0,0 +1,596 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  IFlattenRowType,\n+  IFieldIdentifier,\n+  IOnChangePayload,\n+} from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import uuidV4 from 'uuid/v4';\n+import isEmpty from 'lodash/isEmpty';\n+import { INode, parseSchema } from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import { FlatSchema } from 'components/AbstractWidget/SchemaEditor/Context/FlatSchema';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import { SchemaGenerator } from 'components/AbstractWidget/SchemaEditor/Context/SchemaGenerator';\n+import isObject from 'lodash/isObject';\n+import {\n+  branchCount,\n+  initChildren,\n+  getInternalType,\n+  initTypeProperties,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManagerUtilities';\n+import { isNilOrEmpty } from 'services/helpers';\n+import {\n+  InternalTypesEnum,\n+  OperationTypesEnum,\n+  getDefaultEmptyAvroSchema,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+\n+interface ISchemaManagerOptions {\n+  collapseAll: boolean;\n+}\n+\n+/**\n+ * Interface that defines the schema data structure.\n+ */\n+interface ISchemaManager {\n+  getSchemaTree: () => INode;\n+  getFlatSchema: () => IFlattenRowType[];\n+  getAvroSchema: () => ISchemaType;\n+  onChange: (fieldId: IFieldIdentifier, onChangePayload: IOnChangePayload) => IOnChangeReturnType;\n+}\n+\n+interface IOnChangeReturnType {\n+  fieldIdToFocus?: string;\n+  fieldIndex?: number;\n+  nodeDepth?: number;\n+}\n+\n+/**\n+ * The Schema Manager is the central place to manage the entire schema\n+ *\n+ * Internally it has two data-structures,\n+ * 1. A tree to convert the JSON avro schema to a representation that we can\n+ * process a little bit faster.\n+ * 2. A flat array for presentation purpose.\n+ *\n+ * The tree is used for adding/removing/deleting fields in an avro schema.\n+ * It is a basic tree with id, name, type and children.\n+ *\n+ * The children is usually a map of id to the child node. In specific cases (records and enums)\n+ * we need to maintain the order. So in those cases the children map will have a static 'order'\n+ * array which maintains the order of the children.\n+ *\n+ * The flatten array is derived from the tree. It is nothing but a DFS traversal of the tree\n+ *\n+ * We need two representations because we need one for processing and the other for display purposes.\n+ * Flattening the tree as aray helps us with using virtual scroll which improves performance.\n+ */\n+class SchemaManagerBase implements ISchemaManager {\n+  private schemaTree: INode;\n+  private flatTree: IFlattenRowType[];\n+  private options: ISchemaManagerOptions;\n+  constructor(avroSchema, options: ISchemaManagerOptions) {\n+    this.schemaTree = parseSchema(avroSchema);\n+    this.flatTree = FlatSchema(this.schemaTree, options);\n+    this.options = options;\n+  }\n+\n+  public getSchemaTree = () => this.schemaTree;\n+  public getFlatSchema = () => this.flatTree;\n+  public getAvroSchema = () => SchemaGenerator(this.schemaTree);\n+\n+  // Generic function to insert the newly created child id into the order array\n+  // to maintain order of fields.\n+  private insertNewIdToOrder = (order = [], referenceId) => {\n+    const id = uuidV4();\n+    // +1 to add next to the current element.\n+    const currentIndexOfChild = order.findIndex((c) => c === referenceId) + 1;\n+    order = [...order.slice(0, currentIndexOfChild), id, ...order.slice(currentIndexOfChild)];\n+    return { id, order };\n+  };\n+\n+  private addNewEnumSymbol = (tree: INode, fieldId: IFieldIdentifier) => {\n+    if (!tree.children || (tree.children && !Array.isArray(tree.children.order))) {\n+      return { tree, newTree: undefined, currentField: undefined };\n+    }\n+    const { id = uuidV4(), order = [] } = this.insertNewIdToOrder(\n+      tree.children.order as string[],\n+      fieldId.id\n+    );\n+    tree.children.order = order;\n+    const newlyAddedField = {\n+      id,\n+      internalType: InternalTypesEnum.ENUM_SYMBOL,\n+      typeProperties: {\n+        symbol: '',\n+      },\n+    };\n+    tree.children[id] = newlyAddedField;\n+    return {\n+      tree,\n+      newTree: tree.children[id],\n+      currentField: tree.children[fieldId.id],\n+      newlyAddedField,\n+    };\n+  };\n+\n+  private addNewFieldType = (tree: INode, fieldId: IFieldIdentifier) => {\n+    if (!tree.children || (tree.children && !Array.isArray(tree.children.order))) {\n+      return { tree, newTree: undefined, currentField: undefined };\n+    }\n+    const { id = uuidV4(), order = [] } = this.insertNewIdToOrder(\n+      tree.children.order as string[],\n+      fieldId.id\n+    );\n+    tree.children.order = order;\n+    const newlyAddedField = {\n+      id,\n+      internalType: InternalTypesEnum.RECORD_SIMPLE_TYPE,\n+      nullable: false,\n+      type: 'string',\n+      name: '',\n+    };\n+    tree.children[id] = newlyAddedField;\n+    return {\n+      tree,\n+      newTree: tree.children[id],\n+      currentField: tree.children[fieldId.id],\n+      newlyAddedField,\n+    };\n+  };\n+\n+  private addNewUnionType = (tree: INode, fieldId: IFieldIdentifier) => {\n+    if (!tree.children || (tree.children && !Array.isArray(tree.children.order))) {\n+      return { tree, newTree: undefined, currentField: undefined };\n+    }\n+    const { id = uuidV4(), order = [] } = this.insertNewIdToOrder(\n+      tree.children.order as string[],\n+      fieldId.id\n+    );\n+    tree.children.order = order;\n+    const newlyAddedField = {\n+      id,\n+      internalType: InternalTypesEnum.UNION_SIMPLE_TYPE,\n+      nullable: false,\n+      type: 'string',\n+    };\n+    tree.children[id] = newlyAddedField;\n+    return {\n+      tree,\n+      newTree: tree.children[id],\n+      currentField: tree.children[fieldId.id],\n+      newlyAddedField,\n+    };\n+  };\n+\n+  private addSpecificTypesToTree = (tree: INode, fieldId: IFieldIdentifier) => {\n+    switch (tree.type) {\n+      case 'enum':\n+        return this.addNewEnumSymbol(tree, fieldId);\n+      case 'record':\n+        return this.addNewFieldType(tree, fieldId);\n+      case 'union':\n+        return this.addNewUnionType(tree, fieldId);\n+      default:\n+        return { tree: undefined, newTree: undefined, currentField: undefined };\n+    }\n+  };\n+\n+  private addToTree = (\n+    tree: INode,\n+    fieldId: IFieldIdentifier\n+  ): {\n+    tree: INode;\n+    newTree: INode;\n+    currentField: INode;\n+  } => {\n+    if (!tree) {\n+      return { tree: undefined, newTree: undefined, currentField: undefined };\n+    }\n+    // Only the top level record fields will have one ancestors. So just add the specific type.\n+    if (fieldId.ancestors.length === 1) {\n+      return this.addSpecificTypesToTree(tree, fieldId);\n+    }\n+    // Traverse to the specific child tree in the main schema tree.\n+    const { tree: child, newTree, currentField } = this.addToTree(\n+      tree.children[fieldId.ancestors[1]],\n+      { id: fieldId.id, ancestors: fieldId.ancestors.slice(1) }\n+    );\n+    // Mutates the main schema tree. This a performance optimization that we need to\n+    // to avoid generating huge JSONs on every mutation of the schema.\n+    return {\n+      tree: {\n+        ...tree,\n+        children: {\n+          ...tree.children,\n+          [child.id]: child,\n+        },\n+      },\n+      newTree,\n+      currentField,\n+    };\n+  };\n+\n+  /**\n+   * Add a new field to the current index. This could mean,\n+   *  - Add a new field in record schema\n+   *  - Add a new Symbol to enum\n+   *  - Add a new union type\n+   * The results of addition are,\n+   *  - Modifying the schema tree to add the new field (tree)\n+   *  - Newly added tree\n+   *  - Current field to focus on\n+   * We don't re-flatten the entire schema tree all the time. We calculate only the newly\n+   * added field, it could be a single field or a tree in case of union or map or enum,\n+   * and then flatten that sub tree and insert into our flattened array.\n+   *\n+   * @param fieldId ID of the current row being updated.\n+   */\n+  private add = (fieldId: IFieldIdentifier): IOnChangeReturnType => {\n+    const currentIndex = this.flatTree.findIndex((f) => f.id === fieldId.id);\n+    const matchingEntry = this.flatTree[currentIndex];\n+    let result: { tree: INode; newTree: INode; currentField: INode };\n+    let newFlatSubTree: IFlattenRowType[];\n+    const idObj = { id: matchingEntry.id, ancestors: matchingEntry.ancestors };\n+    // The result is the newly modified tree, the newly added tree and the current field\n+    // The modified tree is the entire schema tree that we maintain\n+    // The new tree is for flattening and inserting it into the flattened array\n+    // The current field is then passed on to the schema editor for presentation (focus on that specific row)\n+    result = this.addToTree(this.schemaTree, idObj);\n+    const customOptions = {\n+      ...this.options,\n+      collapseAll: false,\n+    };\n+    newFlatSubTree = FlatSchema(result.newTree, customOptions, matchingEntry.ancestors);\n+    this.schemaTree = result.tree;\n+    const currentFieldBranchCount = branchCount(result.currentField);\n+    this.flatTree = [\n+      ...this.flatTree.slice(0, currentIndex + currentFieldBranchCount + 1),\n+      ...newFlatSubTree,\n+      ...this.flatTree.slice(currentIndex + currentFieldBranchCount + 1),\n+    ];\n+    return {\n+      fieldIdToFocus: this.flatTree[currentIndex + currentFieldBranchCount + 1].id,\n+      fieldIndex: currentIndex + currentFieldBranchCount + 1,\n+    };\n+  };\n+\n+  private removeFromTree = (tree: INode, fieldId) => {\n+    if (!tree) {\n+      return { tree: undefined };\n+    }\n+    if (fieldId.ancestors.length === 1) {\n+      const field = { ...tree.children[fieldId.id] };\n+      let newField;\n+      if (Array.isArray(tree.children.order) && Object.keys(tree.children).length === 2) {\n+        const {\n+          tree: treeWithDefaultChild,\n+          newlyAddedField: defaultNewField,\n+        } = this.addSpecificTypesToTree(tree, fieldId);\n+        newField = defaultNewField;\n+        tree = treeWithDefaultChild;\n+      }\n+      if (Array.isArray(tree.children.order)) {\n+        tree.children.order = tree.children.order.filter((id) => id !== fieldId.id);\n+      }\n+      delete tree.children[fieldId.id];\n+      return { tree, removedField: field, newlyAddedField: newField };\n+    }\n+    const { tree: newTree, removedField, newlyAddedField } = this.removeFromTree(\n+      tree.children[fieldId.ancestors[1]],\n+      {\n+        id: fieldId.id,\n+        ancestors: fieldId.ancestors.slice(1),\n+      }\n+    );\n+    return {\n+      tree: {\n+        ...tree,\n+        children: {\n+          ...tree.children,\n+          ...newTree,\n+        },\n+      },\n+      removedField,\n+      newlyAddedField,\n+    };\n+  };\n+\n+  /**\n+   * Remove a field from the schema. This could be a simple type of row\n+   * or a complex type.\n+   * There is also a need for us to add a new row as part of removal.\n+   *\n+   * For instance: This comes up when users delete all the fields in\n+   * a record type. We can't have all the fields deleted. Upon the\n+   * deleting the final field we still need to add a new field for\n+   * the user to be able to keep the record type.\n+   * @param fieldId ID of the current row being updated.\n+   */\n+  private remove = (fieldId: IFieldIdentifier): IOnChangeReturnType => {\n+    const currentIndex = this.flatTree.findIndex((f) => f.id === fieldId.id);\n+    const matchingEntry = this.flatTree[currentIndex];\n+    const idObj = { id: matchingEntry.id, ancestors: matchingEntry.ancestors };\n+    const { tree, removedField, newlyAddedField } = this.removeFromTree(this.schemaTree, idObj);\n+    this.schemaTree = tree;\n+    // branch count to determine the slice in the flattened array.\n+    // If the user removed a complex type we need to remove the row\n+    // and all of its children.\n+    const childrenInBranch = branchCount(removedField);\n+    let newFlatSubTree = [];\n+    // Newly added row in case we need to maintain the structure of say, a record or an enum.\n+    if (newlyAddedField) {\n+      const customOptions = {\n+        ...this.options,\n+        collapseAll: false,\n+      };\n+      newFlatSubTree = FlatSchema(newlyAddedField, customOptions, matchingEntry.ancestors);\n+    }\n+    this.flatTree = [\n+      ...this.flatTree.slice(0, currentIndex),\n+      ...newFlatSubTree,\n+      ...this.flatTree.slice(currentIndex + 1 + childrenInBranch), // remove current row along with its children.\n+    ];\n+    return {\n+      fieldIdToFocus: this.flatTree[currentIndex - 1].id,\n+      fieldIndex: currentIndex - 1,\n+    };\n+  };\n+\n+  private updateTree = (\n+    tree: INode,\n+    fieldId: IFieldIdentifier,\n+    { property, value }: Partial<IOnChangePayload>\n+  ): {\n+    tree: INode;\n+    childrenCount: number;\n+    newTree: INode;\n+  } => {\n+    if (!tree) {\n+      return { childrenCount: undefined, tree: undefined, newTree: undefined };\n+    }\n+    if (fieldId.ancestors.length === 1 && !isEmpty(tree.children[fieldId.id])) {\n+      if (property === 'typeProperties' && typeof value === 'object') {\n+        tree.children[fieldId.id][property] = {\n+          ...tree.children[fieldId.id][property],\n+          ...value,\n+        };\n+      } else {\n+        tree.children[fieldId.id][property] = value;\n+      }\n+      let childrenInBranch = 0;\n+      let newChildTree: INode;\n+      if (property === 'type') {\n+        childrenInBranch = branchCount(tree.children[fieldId.id]);\n+        tree.children[fieldId.id].children = initChildren(value);\n+        newChildTree = tree.children[fieldId.id];\n+        tree.children[fieldId.id].internalType = getInternalType(tree.children[fieldId.id]);\n+        tree.children[fieldId.id].typeProperties = initTypeProperties(tree.children[fieldId.id]);\n+      }\n+      return {\n+        tree,\n+        childrenCount: childrenInBranch,\n+        newTree: newChildTree,\n+      };\n+    }\n+\n+    const { tree: child, childrenCount, newTree } = this.updateTree(\n+      tree.children[fieldId.ancestors[1]],\n+      { id: fieldId.id, ancestors: fieldId.ancestors.slice(1) },\n+      { property, value }\n+    );\n+    return {\n+      tree: {\n+        ...tree,\n+        children: {\n+          ...tree.children,\n+          [child.id]: child,\n+        },\n+      },\n+      childrenCount,\n+      newTree,\n+    };\n+  };\n+\n+  /**\n+   * Updating a field could be changing the 'name' or the 'type'.\n+   *\n+   * Updating 'name' is pretty straight forward and involves no complicated steps.\n+   * Updating 'type' involves changing from a simple type to a complex type or vice-versa.\n+   *\n+   * This again involves addition or removal of nodes in the schema.\n+   * @param fieldId ID of the current row being updated.\n+   * @param onChangePayload - { property, value } - payload for updating.\n+   */\n+  private update = (\n+    fieldId: IFieldIdentifier,\n+    { property, value }: Partial<IOnChangePayload>\n+  ): IOnChangeReturnType => {\n+    const index = this.flatTree.findIndex((f) => f.id === fieldId.id);\n+    if (property === 'typeProperties' && typeof value === 'object') {\n+      this.flatTree[index][property] = {\n+        ...this.flatTree[index][property],\n+        ...value,\n+      };\n+    } else {\n+      this.flatTree[index][property] = value;\n+    }\n+    const matchingEntry = this.flatTree[index];\n+    let result: { tree: INode; childrenCount: number; newTree: INode };\n+    let newFlatSubTree: IFlattenRowType[];\n+    const idObj = { id: matchingEntry.id, ancestors: matchingEntry.ancestors };\n+    result = this.updateTree(this.schemaTree, idObj, { property, value });\n+    this.schemaTree = result.tree;\n+    // If user changed a complex type to a simple type or to another complex type we need\n+    // to remove the complex type children first\n+    this.flatTree = [\n+      ...this.flatTree.slice(0, index),\n+      ...this.flatTree.slice(index + result.childrenCount + (!result.newTree ? 0 : 1)),\n+    ];\n+    const customOptions = {\n+      ...this.options,\n+      collapseAll: false,\n+    };\n+    // And then add the newly updated complex type children to the flattened array.\n+    if (result.newTree) {\n+      newFlatSubTree = FlatSchema(result.newTree, customOptions, matchingEntry.ancestors);\n+      this.flatTree = [\n+        ...this.flatTree.slice(0, index),\n+        ...newFlatSubTree,\n+        ...this.flatTree.slice(index),\n+      ];\n+    }\n+    // newFlatSubTree will be of length 1 for simple type changes.\n+    if (Array.isArray(newFlatSubTree) && newFlatSubTree.length > 1) {\n+      return {\n+        fieldIdToFocus: this.flatTree[index + 1].id,\n+        fieldIndex: index + 1,\n+      };\n+    }\n+    return {};\n+  };\n+\n+  /**\n+   * This is to identify the root tree from the flattened object.\n+   * @param fieldObj - id of the flattened row\n+   * @param schemaTree - Tree to find the root node.\n+   */\n+  private getFieldObjFromTree = (fieldObj, schemaTree: INode): INode => {\n+    if (fieldObj.id === schemaTree.id) {\n+      return schemaTree;\n+    }\n+    if (fieldObj.ancestors.length === 1) {\n+      return schemaTree.children[fieldObj.id];\n+    }\n+    return this.getFieldObjFromTree(\n+      { id: fieldObj.id, ancestors: fieldObj.ancestors.slice(1) },\n+      schemaTree.children[fieldObj.ancestors[1]]\n+    );\n+  };\n+\n+  /**\n+   * Function to collapse/expand a tree.\n+   * @param fieldId - id of the field for which the children needs to be\n+   * collapsed or expanded.\n+   */\n+  private collapse = (fieldId: IFieldIdentifier): IOnChangeReturnType => {\n+    const matchingIndex = this.flatTree.findIndex((row) => row.id === fieldId.id);\n+    const matchingEntry = this.flatTree[matchingIndex];\n+    if (!matchingEntry) {\n+      return {};\n+    }\n+    const idObj = { id: matchingEntry.id, ancestors: matchingEntry.ancestors };\n+    const fieldObj = this.getFieldObjFromTree(idObj, this.getSchemaTree());\n+    this.flatTree[matchingIndex].collapsed = !this.flatTree[matchingIndex].collapsed;\n+    const nodeDepth = this.calculateNodeDepthMap(fieldObj);\n+    for (let i = 1; i <= nodeDepth; i++) {\n+      const currentRow = this.flatTree[matchingIndex + i];\n+      const { collapsed } = currentRow;\n+      if (typeof collapsed === 'boolean') {\n+        if (collapsed === true) {\n+          const childTreeDepth = this.calculateNodeDepthMap(\n+            this.getFieldObjFromTree(currentRow, this.getSchemaTree())\n+          );\n+          this.flatTree[matchingIndex + i].hidden = this.flatTree[matchingIndex].collapsed;\n+          i += childTreeDepth;\n+          continue;\n+        } else {\n+          this.flatTree[matchingIndex + i].collapsed = this.flatTree[matchingIndex].collapsed;\n+        }\n+      }\n+      this.flatTree[matchingIndex + i].hidden = this.flatTree[matchingIndex].collapsed;\n+    }\n+    return {};\n+  };\n+\n+  /**\n+   * Identify the depth of a parent node. Depth here defines all the immediate children and all\n+   * the children of childrens and so on and so forth. We need to calculate this depth because\n+   * we do a DFS of our tree to flatten. Now if we need to collapse a subtree we need all the children\n+   * (both direct and indirect) because in a flattened array the children comes first before the sibling.\n+   * @param tree - Root node to find the depth.\n+   */\n+  private calculateNodeDepthMap = (tree: INode): number => {\n+    let totalDepth = 0;\n+    if (isObject(tree.children) && Object.keys(tree.children).length) {\n+      totalDepth += Object.keys(tree.children).filter((c) => c !== 'order').length;\n+      for (const childId of Object.keys(tree.children)) {\n+        if (childId === 'order') {\n+          continue;\n+        }\n+        const childCount = this.calculateNodeDepthMap(tree.children[childId]);\n+        totalDepth += childCount;\n+      }\n+    }\n+    return totalDepth;\n+  };\n+\n+  /**\n+   * The generic onChange is supposed to handle all types of mutation to the schema.\n+   * This onChange is the handler for any changes that happen in the schema (not to be confused with\n+   * the onChange in the schemaEditor).\n+   * @param fieldId - unique id to identify every field in the schema tree.\n+   * @param onChangePayload {type, property, value} - Every onchange call will have the type of\n+   * change, the property and the value. The type could be 'add', 'update', 'remove' and property could be\n+   * 'name' or 'typeProperties'\n+   */\n+  public onChange = (\n+    fieldId: IFieldIdentifier,\n+    { type, property, value }: IOnChangePayload\n+  ): IOnChangeReturnType => {\n+    if (isNilOrEmpty(fieldId)) {\n+      return;\n+    }\n+    switch (type) {\n+      case OperationTypesEnum.UPDATE:\n+        return this.update(fieldId, { property, value });\n+      case OperationTypesEnum.ADD:\n+        return this.add(fieldId);\n+      case OperationTypesEnum.REMOVE:\n+        return this.remove(fieldId);\n+      case OperationTypesEnum.COLLAPSE:\n+        return this.collapse(fieldId);\n+    }\n+  };\n+}\n+\n+/**\n+ * Default options for the schema manager. This as of now only has collapseAll.\n+ * Will expand to restricting schema types.\n+ */\n+const defaultOptions: ISchemaManagerOptions = {\n+  collapseAll: true,\n+};\n+\n+function SchemaManager(\n+  avroSchema = getDefaultEmptyAvroSchema(),\n+  options: ISchemaManagerOptions = defaultOptions\n+) {\n+  if (!options) {\n+    options = defaultOptions;\n+  } else {\n+    options = {\n+      ...defaultOptions,\n+      ...options,\n+    };\n+  }\n+  const schemaTreeInstance = new SchemaManagerBase(avroSchema, options);\n+  return {\n+    getInstance: () => schemaTreeInstance,\n+  };\n+}\n+export { SchemaManager, INode, ISchemaManager, IOnChangeReturnType, ISchemaManagerOptions };", "originalCommit": "afc9a67c8553341708b3902970ac2f1751dda93f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNjU0NQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r458106545", "bodyText": "we can use theme in withStyles I believe.\nwithStyles((theme))", "author": "jennac3", "createdAt": "2020-07-21T13:43:25Z", "path": "cdap-ui/app/cdap/components/AbstractWidget/FormInputs/Select/index.tsx", "diffHunk": "@@ -21,35 +21,59 @@ import { IWidgetProps } from 'components/AbstractWidget';\n import { objectQuery } from 'services/helpers';\n import { WIDGET_PROPTYPES } from 'components/AbstractWidget/constants';\n import withStyles from '@material-ui/core/styles/withStyles';\n-\n+import { blue } from 'components/ThemeWrapper/colors';\n const CustomizedInput = withStyles(() => {\n   return {\n     input: {\n       padding: '7px 18px 7px 12px',\n       '&:focus': {\n         backgroundColor: 'transparent',\n+        outline: `1px solid ${blue[100]}`,", "originalCommit": "afc9a67c8553341708b3902970ac2f1751dda93f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMyNDk3NQ==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r458324975", "bodyText": "#12450 (comment)", "author": "ajainarayanan", "createdAt": "2020-07-21T19:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNjU0NQ=="}], "type": "inlineReview"}, {"oid": "887b507714a645701be4d58db5b91c87d55db220", "url": "https://github.com/cdapio/cdap/commit/887b507714a645701be4d58db5b91c87d55db220", "message": "[CDAP-16850] Adds new Schema Editor. It is a complete rewrite from scratch.\n\n**Context**\n- This is a complete rewrite of schema editor.\n- The goal of the schema to be more scalable and accommodate for editing attributes of certain avro schema types.\n\n**Design**\n- The schema editor design can be split into three parts,\n  - Presentation - Editor\n  - State management - Schema Manager\n  - Validator - Schema Validator to validate schema\n- Editor represents the visual part of the schema editor. At the core, it renders a list + manages changes to the schema (crud operation)\n- Schema Manager is the underlying state management for any operation happening in the Editor. Internally it maintains a tree and a flat list each representing the same avro schema. Tree - for faster manipulation and Flat list - for easier rendering\n- Validator is the module used to validate the schema after each operation. We use customized version of [avsc library](https://github.com/cdapio/ui-schema-parser) to suit our needs\n\n**Implementation**\n\n_Schema Manager_\n- For any avro schema generates a tree and a flat array\n- For each operation (add/remove/update) the Schema Manager mutates the tree. This results in either adding a new subtree, removing a new subtree or modifying the existing subtree.\n- This subtree is then flattened and inserted at appropriate position to the existing flat array.\n- Tree is a direct tree representation of the avro schema\n- List is a DFS traversed list generated from the above tree.\n\n_Editor_\n- List contains each node in the avro schema\n- Each node in the list is identified by a unique id\n- Each node contains a reference to #of ancestors\n- Each row is either a two column (unions or maps) or three column like record field with name(or label), type and action buttons\n\n**Other component changes**\n- Modified `VirtualScroll` to include a `childrenUnderFoldScroll`. This is to increase the rendered child count on scroll to avoid showing empty white space. This is a common occurrence when using a virtual scroll as browser cannot catch up with scroll and rendering the underlying component quick enough.\n- Modified `Select` dropdown to have a dense option to reduce padding.\n- Modified `TextboxOnValium` to accept a ref prop to be able to pass on the underlying input element to the parent.\n- Modified `If` to accept an additional `invisible` property to set `visibility: hidden` to children. This is to render empty space in place where the component needs to be showed.", "committedDate": "2020-07-22T16:16:03Z", "type": "commit"}, {"oid": "887b507714a645701be4d58db5b91c87d55db220", "url": "https://github.com/cdapio/cdap/commit/887b507714a645701be4d58db5b91c87d55db220", "message": "[CDAP-16850] Adds new Schema Editor. It is a complete rewrite from scratch.\n\n**Context**\n- This is a complete rewrite of schema editor.\n- The goal of the schema to be more scalable and accommodate for editing attributes of certain avro schema types.\n\n**Design**\n- The schema editor design can be split into three parts,\n  - Presentation - Editor\n  - State management - Schema Manager\n  - Validator - Schema Validator to validate schema\n- Editor represents the visual part of the schema editor. At the core, it renders a list + manages changes to the schema (crud operation)\n- Schema Manager is the underlying state management for any operation happening in the Editor. Internally it maintains a tree and a flat list each representing the same avro schema. Tree - for faster manipulation and Flat list - for easier rendering\n- Validator is the module used to validate the schema after each operation. We use customized version of [avsc library](https://github.com/cdapio/ui-schema-parser) to suit our needs\n\n**Implementation**\n\n_Schema Manager_\n- For any avro schema generates a tree and a flat array\n- For each operation (add/remove/update) the Schema Manager mutates the tree. This results in either adding a new subtree, removing a new subtree or modifying the existing subtree.\n- This subtree is then flattened and inserted at appropriate position to the existing flat array.\n- Tree is a direct tree representation of the avro schema\n- List is a DFS traversed list generated from the above tree.\n\n_Editor_\n- List contains each node in the avro schema\n- Each node in the list is identified by a unique id\n- Each node contains a reference to #of ancestors\n- Each row is either a two column (unions or maps) or three column like record field with name(or label), type and action buttons\n\n**Other component changes**\n- Modified `VirtualScroll` to include a `childrenUnderFoldScroll`. This is to increase the rendered child count on scroll to avoid showing empty white space. This is a common occurrence when using a virtual scroll as browser cannot catch up with scroll and rendering the underlying component quick enough.\n- Modified `Select` dropdown to have a dense option to reduce padding.\n- Modified `TextboxOnValium` to accept a ref prop to be able to pass on the underlying input element to the parent.\n- Modified `If` to accept an additional `invisible` property to set `visibility: hidden` to children. This is to render empty space in place where the component needs to be showed.", "committedDate": "2020-07-22T16:16:03Z", "type": "forcePushed"}, {"oid": "7a02c36f1b58ff8831547154710f9ae70b133f56", "url": "https://github.com/cdapio/cdap/commit/7a02c36f1b58ff8831547154710f9ae70b133f56", "message": "Integrates new Schema Editor to pipeline plugins\n\n**Approach**\n- Compose `SchemaEditor` into a new component named `PluginSchemaEditor` along with other `Actions` available on the schema.\n- Have retained the logic to enable/disable the schema actions in angular for the most part.\n- Some of the logic, like export, are still in react. We use the same event based system for import/export/clear\n- PluginSchemaEditor will also determine the height of the container to determine the number of rows that needs to be rendered (required by the virtual scroll)\n- Changes avro schema types from string to enum\n- Fixes `SchemaManager` to handle logical types for all complex types\n- Adds validation on import of schema\n- Adds the ability to set `disabled` for the schema editor to become non-editable.\n\n**Note**\n- This change achieves feature parity with existing schema editor.\n- However at any point if the user thinks they are experiencing any regressions they can switch off the experiment which will enable them to use the older schema editor\n- The experiment will be on by default.\n- All the changes to angular side are additive and does not remove any existing functionality.", "committedDate": "2020-07-23T19:49:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNjYzMw==", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r459736633", "bodyText": "nit: perhaps remove the Demo for part from this description since this lab is not for the demo page anymore?", "author": "elfenheart", "createdAt": "2020-07-23T21:24:37Z", "path": "cdap-ui/app/cdap/components/Lab/experiment-list.tsx", "diffHunk": "@@ -35,6 +35,6 @@ export default [\n       'Demo for new SchemaEditor. Includes complete rewrite in React + perf improvements',", "originalCommit": "502263be6da76f8f2c7f98b8fb5c40cbdd484ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ad2c6561ca957c119cacd5f9d3b45c2e795d7fa0", "url": "https://github.com/cdapio/cdap/commit/ad2c6561ca957c119cacd5f9d3b45c2e795d7fa0", "message": "Load default experiments to localStorage on initial load + sets new schema editor experiment to true by default", "committedDate": "2020-07-23T22:35:12Z", "type": "commit"}, {"oid": "ad2c6561ca957c119cacd5f9d3b45c2e795d7fa0", "url": "https://github.com/cdapio/cdap/commit/ad2c6561ca957c119cacd5f9d3b45c2e795d7fa0", "message": "Load default experiments to localStorage on initial load + sets new schema editor experiment to true by default", "committedDate": "2020-07-23T22:35:12Z", "type": "forcePushed"}]}