{"pr_number": 3615, "pr_title": "Add nearby presenter unit tests ", "pr_createdAt": "2020-04-01T15:52:15Z", "pr_url": "https://github.com/commons-app/apps-android-commons/pull/3615", "timeline": [{"oid": "2fc55e19b083e47e33b1cc6c8ed0e364a4428049", "url": "https://github.com/commons-app/apps-android-commons/commit/2fc55e19b083e47e33b1cc6c8ed0e364a4428049", "message": "init the test file", "committedDate": "2020-04-01T10:56:05Z", "type": "commit"}, {"oid": "8b1d62cdb1cccf74c7649071f63b83722e0ff150", "url": "https://github.com/commons-app/apps-android-commons/commit/8b1d62cdb1cccf74c7649071f63b83722e0ff150", "message": "Add tests to check if searchthisarea button action and checkbox actions are added after initialize test", "committedDate": "2020-04-01T12:32:18Z", "type": "commit"}, {"oid": "2f395169daa824ca99b3b36fd1eaea6ce21936bb", "url": "https://github.com/commons-app/apps-android-commons/commit/2f395169daa824ca99b3b36fd1eaea6ce21936bb", "message": "Add tests to locked unlocked nearby cases", "committedDate": "2020-04-01T12:42:09Z", "type": "commit"}, {"oid": "8a743348eca782fe1317c7921f301226b9c77981", "url": "https://github.com/commons-app/apps-android-commons/commit/8a743348eca782fe1317c7921f301226b9c77981", "message": "Add tests for null cases in updateMapAndList method", "committedDate": "2020-04-01T13:19:31Z", "type": "commit"}, {"oid": "bb4e8e0c467b0b7ee6be39ae0ae7cc91fd4cf0f9", "url": "https://github.com/commons-app/apps-android-commons/commit/bb4e8e0c467b0b7ee6be39ae0ae7cc91fd4cf0f9", "message": "Add test to check which locations are used to populate places, depending to LocationChangeType", "committedDate": "2020-04-01T13:34:24Z", "type": "commit"}, {"oid": "f0fef8ae5bbc78d1959555f5503a2d2c265374bf", "url": "https://github.com/commons-app/apps-android-commons/commit/f0fef8ae5bbc78d1959555f5503a2d2c265374bf", "message": "Add tests to test users position is not followed if blue dot (current location marker) is not visible", "committedDate": "2020-04-01T14:23:44Z", "type": "commit"}, {"oid": "5300c6fa6697d68cabadeebcc9a4e368e69affb7", "url": "https://github.com/commons-app/apps-android-commons/commit/5300c6fa6697d68cabadeebcc9a4e368e69affb7", "message": "Add tests to decide search this area method visibility on camera move", "committedDate": "2020-04-02T10:37:07Z", "type": "commit"}, {"oid": "677126f7f9482bf3df86514b1232a344ccf13fc7", "url": "https://github.com/commons-app/apps-android-commons/commit/677126f7f9482bf3df86514b1232a344ccf13fc7", "message": "Add tests for multi filteirng of placetypes", "committedDate": "2020-04-02T11:03:44Z", "type": "commit"}, {"oid": "c597ea5b0f7bbe4c7768dd6e935a006d6de560e5", "url": "https://github.com/commons-app/apps-android-commons/commit/c597ea5b0f7bbe4c7768dd6e935a006d6de560e5", "message": "add tests for single place type selection too", "committedDate": "2020-04-02T11:31:04Z", "type": "commit"}, {"oid": "ec37b1e294fb92efddc2a0b63c2746c81ef6e47c", "url": "https://github.com/commons-app/apps-android-commons/commit/ec37b1e294fb92efddc2a0b63c2746c81ef6e47c", "message": "Add tests to tests search view focus gain and bottom sheet visibilities", "committedDate": "2020-04-02T12:07:20Z", "type": "commit"}, {"oid": "d66c7be7cff34035be2611a9202e65148f822cf6", "url": "https://github.com/commons-app/apps-android-commons/commit/d66c7be7cff34035be2611a9202e65148f822cf6", "message": "Add tests for SearchCloseToCurrentLocation", "committedDate": "2020-04-02T13:17:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3MzU0Mg==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r403973542", "bodyText": "Do we need to be spying?", "author": "macgills", "createdAt": "2020-04-06T10:04:48Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,320 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.Assert.*\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var latestLocationSpy: LatLng\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = Mockito.spy(NearbyParentFragmentPresenter(bookmarkLocationsDao))", "originalCommit": "d66c7be7cff34035be2611a9202e65148f822cf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA1NzExNQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404057115", "bodyText": "Do you mean using a mock and \"callRealMethod\" instead?", "author": "neslihanturan", "createdAt": "2020-04-06T12:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3MzU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA2MjA2MQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404062061", "bodyText": "NearbyFragmentPresenter should be fine to be instantiated here, we don't need to wrap it in a spy I would think, it is the class under test", "author": "macgills", "createdAt": "2020-04-06T12:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3MzU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NTk3MA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r403975970", "bodyText": "I know we add javadocs to classes but to tests? that seems extreme to me especially when you can have kotlin test functions enclosed in backticks to be named arbitrarily. For example the name of this test could be\nfun `Tests nearby operations are initialized`()", "author": "macgills", "createdAt": "2020-04-06T10:09:08Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,320 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.Assert.*\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var latestLocationSpy: LatLng\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = Mockito.spy(NearbyParentFragmentPresenter(bookmarkLocationsDao))\n+        nearbyPresenter.attachView(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Tests nearby operations are initialized\n+     */\n+    @Test\n+    fun testInitializeNearbyMapOperations() {", "originalCommit": "d66c7be7cff34035be2611a9202e65148f822cf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA3Mjk5OA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404072998", "bodyText": "I actually followed the style from other .kt files in our repository. If you see ContributionsPresenterTest.kt a similar style is followed.\n    /**\n     * Test fetch contributions\n     */\n    @Test\n    fun testFetchContributions(){\n\nPlease let me know if you still think that the style should be changed:)", "author": "neslihanturan", "createdAt": "2020-04-06T13:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA3NzcxNA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404077714", "bodyText": "@misaochan @ashishkumar0207 @maskaravivek thoughts?\nOne of Javadocs main usefulness is when trying to use the methods of a class you get the quick documentation without having to visit the class. Nobody should be directly using test methods.\nI would say if the title of a test can be written clearly then repeating it in a javadoc is just busy work. For sufficiently complicated and/or confusing tests I would support commenting them at discretion or request.", "author": "macgills", "createdAt": "2020-04-06T13:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1NDcwNA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404154704", "bodyText": "I think adding it for all of them can prevent relativity of complexity. If we don't add them for all, we can find out some complex tests written without javadocs. So I see no harm adding them, with as much as details we could add.", "author": "neslihanturan", "createdAt": "2020-04-06T14:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNDI4NQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404214285", "bodyText": "I'm in support of continuing to require that they be added, mostly because it creates a lot of grey area otherwise (it may be difficult for contributors to agree on which tests are \"complex enough to require javadocs\" and which ones are not).", "author": "misaochan", "createdAt": "2020-04-06T16:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1Mjg5MA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404652890", "bodyText": "To me tests are already documentation, documenting them again feels redundant. If ye are happy to proceed though then thats that.", "author": "macgills", "createdAt": "2020-04-07T09:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NTk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3ODExMw==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r403978113", "bodyText": "Exposing code for test is a code smell. The option is to rewrite or use the nasty @VisibleForTesting annotation.\nI'd say rewrite because lockUnlockNearby sets it quite easily for you.", "author": "macgills", "createdAt": "2020-04-06T10:13:00Z", "path": "app/src/main/java/fr/free/nrw/commons/nearby/presenter/NearbyParentFragmentPresenter.java", "diffHunk": "@@ -373,4 +373,12 @@ public boolean areLocationsClose(LatLng cameraTarget, LatLng lastKnownLocation)\n             return true;\n         }\n     }\n+\n+    public boolean isNearbyLocked() {", "originalCommit": "d66c7be7cff34035be2611a9202e65148f822cf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA0Nzk4Mg==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404047982", "bodyText": "I didn't know about the annotation will do! Thanks:)", "author": "neslihanturan", "createdAt": "2020-04-06T12:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3ODExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA2NDA5OQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404064099", "bodyText": "I meant for you to rewrite the test, @VisibleForTesting is an ugly bandaid and should only be used in extreme scenarios", "author": "macgills", "createdAt": "2020-04-06T12:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3ODExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3OTM5OQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r403979399", "bodyText": "where is MapUpdated?", "author": "macgills", "createdAt": "2020-04-06T10:15:19Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,320 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.Assert.*\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var latestLocationSpy: LatLng\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = Mockito.spy(NearbyParentFragmentPresenter(bookmarkLocationsDao))\n+        nearbyPresenter.attachView(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Tests nearby operations are initialized\n+     */\n+    @Test\n+    fun testInitializeNearbyMapOperations() {\n+        nearbyPresenter.initializeMapOperations()\n+        verify(nearbyParentFragmentView).addSearchThisAreaButtonAction()\n+        verify(nearbyParentFragmentView).setCheckBoxAction()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to lock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForLocked() {\n+        nearbyPresenter.lockUnlockNearby(true)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to unlock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForUnlocked() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when location is locked\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLocationLocked() {\n+        nearbyPresenter.setNearbyLocked(true)\n+        nearbyPresenter.updateMapAndList(null)\n+        verifyZeroInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when network connection\n+     * is not established\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenNoNetworkConnection() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(false)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when last location is null\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLastLocationIsNull() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(null)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verify(nearbyParentFragmentView).getLastLocation()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with latest location of user\n+     * at significant location change\n+     */\n+    @Test\n+    fun testPlacesPopulatedForLatestLocationWhenLocationSignificantlyChanged() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(latestLocation)\n+        nearbyPresenter.updateMapAndList(LocationServiceManager.LocationChangeType.LOCATION_SIGNIFICANTLY_CHANGED)", "originalCommit": "d66c7be7cff34035be2611a9202e65148f822cf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1NTQyNA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404155424", "bodyText": "added:)", "author": "neslihanturan", "createdAt": "2020-04-06T14:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3OTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MTM2MA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r403981360", "bodyText": "why are they spied? mocks or just the objects themselves would do I think", "author": "macgills", "createdAt": "2020-04-06T10:18:46Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,320 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.Assert.*\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var latestLocationSpy: LatLng\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = Mockito.spy(NearbyParentFragmentPresenter(bookmarkLocationsDao))\n+        nearbyPresenter.attachView(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Tests nearby operations are initialized\n+     */\n+    @Test\n+    fun testInitializeNearbyMapOperations() {\n+        nearbyPresenter.initializeMapOperations()\n+        verify(nearbyParentFragmentView).addSearchThisAreaButtonAction()\n+        verify(nearbyParentFragmentView).setCheckBoxAction()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to lock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForLocked() {\n+        nearbyPresenter.lockUnlockNearby(true)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to unlock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForUnlocked() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when location is locked\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLocationLocked() {\n+        nearbyPresenter.setNearbyLocked(true)\n+        nearbyPresenter.updateMapAndList(null)\n+        verifyZeroInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when network connection\n+     * is not established\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenNoNetworkConnection() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(false)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when last location is null\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLastLocationIsNull() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(null)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verify(nearbyParentFragmentView).getLastLocation()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with latest location of user\n+     * at significant location change\n+     */\n+    @Test\n+    fun testPlacesPopulatedForLatestLocationWhenLocationSignificantlyChanged() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(latestLocation)\n+        nearbyPresenter.updateMapAndList(LocationServiceManager.LocationChangeType.LOCATION_SIGNIFICANTLY_CHANGED)\n+        verify(nearbyParentFragmentView).populatePlaces(latestLocation)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with camera target location\n+     * at search custom area mode\n+     */\n+    @Test\n+    fun testPlacesPopulatedForCameraTargetLocationWhenSearchCustomArea() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(latestLocation)\n+        whenever(nearbyParentFragmentView.getCameraTarget()).thenReturn(cameraTarget)\n+        nearbyPresenter.updateMapAndList(LocationServiceManager.LocationChangeType.SEARCH_CUSTOM_AREA)\n+        verify(nearbyParentFragmentView).populatePlaces(cameraTarget)\n+    }\n+\n+    /**\n+     * Test testUpdateMapAndList tracks users location if current location marker is visible and\n+     * location is slightly changed\n+     */\n+    @Test\n+    fun testUserTrackedWhenCurrentLocationMarkerVisible() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(latestLocation)\n+        whenever(nearbyParentFragmentView.isCurrentLocationMarkerVisible()).thenReturn(true)\n+        nearbyPresenter.updateMapAndList(LocationServiceManager.LocationChangeType.LOCATION_SLIGHTLY_CHANGED)\n+        verify(nearbyParentFragmentView).recenterMap(latestLocation)\n+    }\n+\n+    /**\n+     * Test testUpdateMapAndList doesn't track users location if current location marker is\n+     * invisible and location is slightly changed\n+     */\n+    @Test\n+    fun testUserNotTrackedWhenCurrentLocationMarkerInvisible() {\n+        nearbyPresenter.setNearbyLocked(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(latestLocation)\n+        whenever(nearbyParentFragmentView.isCurrentLocationMarkerVisible()).thenReturn(false)\n+        nearbyPresenter.updateMapAndList(LocationServiceManager.LocationChangeType.LOCATION_SLIGHTLY_CHANGED)\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verify(nearbyParentFragmentView).getLastLocation()\n+        verify(nearbyParentFragmentView).isCurrentLocationMarkerVisible()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test search this area button became visible after user moved the camera target to far\n+     * away from current target. Distance between these two point is 111.19 km, so our camera target\n+     * is at outside of previously searched region if we set latestSearchRadius below 111.19. Thus,\n+     * setSearchThisAreaButtonVisibility(true) should be verified.\n+     */\n+    @Test\n+    fun testSearchThisAreaButtonVisibleWhenMoveToFarPosition() {\n+        NearbyController.latestSearchLocation = Mockito.spy(LatLng(2.0,1.0,0.0F))", "originalCommit": "d66c7be7cff34035be2611a9202e65148f822cf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE2Mjc4Mw==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404162783", "bodyText": "Solved", "author": "neslihanturan", "createdAt": "2020-04-06T15:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mzk5Mw==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404663993", "bodyText": "They are still spied?", "author": "macgills", "createdAt": "2020-04-07T09:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjQzOA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r403982438", "bodyText": "no verification for\n        lockUnlockNearby(false);\n        updateMapAndList(LOCATION_SIGNIFICANTLY_CHANGED);", "author": "macgills", "createdAt": "2020-04-06T10:20:32Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,320 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.Assert.*\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var latestLocationSpy: LatLng\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = Mockito.spy(NearbyParentFragmentPresenter(bookmarkLocationsDao))\n+        nearbyPresenter.attachView(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Tests nearby operations are initialized\n+     */\n+    @Test\n+    fun testInitializeNearbyMapOperations() {\n+        nearbyPresenter.initializeMapOperations()\n+        verify(nearbyParentFragmentView).addSearchThisAreaButtonAction()\n+        verify(nearbyParentFragmentView).setCheckBoxAction()", "originalCommit": "d66c7be7cff34035be2611a9202e65148f822cf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4Mzg1MQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r403983851", "bodyText": "and initializeMapOperations should be a private function, only invoked by onMapReady", "author": "macgills", "createdAt": "2020-04-06T10:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4MDg5Mg==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404080892", "bodyText": "no verification for\n        lockUnlockNearby(false);\n        updateMapAndList(LOCATION_SIGNIFICANTLY_CHANGED);\n\n\nAdding them", "author": "neslihanturan", "createdAt": "2020-04-06T13:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjQzOA=="}], "type": "inlineReview"}, {"oid": "fe1f1b8c80d8a8031013a096ea3c3451acfde90f", "url": "https://github.com/commons-app/apps-android-commons/commit/fe1f1b8c80d8a8031013a096ea3c3451acfde90f", "message": "Remove two unneeded getter and setter for isNearbyLocked, use @VisibleForTesting annotation instead", "committedDate": "2020-04-06T12:33:34Z", "type": "commit"}, {"oid": "0178f3c74d84f618b1251a5b2ae77ea16fc03c20", "url": "https://github.com/commons-app/apps-android-commons/commit/0178f3c74d84f618b1251a5b2ae77ea16fc03c20", "message": "Add VisibleForTesting annotation to initializeNearbyOperations method so that it will be private by default", "committedDate": "2020-04-06T13:08:13Z", "type": "commit"}, {"oid": "6ba4ef691ff7cdd9cff77602b5f5860bffd90e84", "url": "https://github.com/commons-app/apps-android-commons/commit/6ba4ef691ff7cdd9cff77602b5f5860bffd90e84", "message": "Add missing tests", "committedDate": "2020-04-06T13:15:06Z", "type": "commit"}, {"oid": "53abcace89bf8a94380d79c4aa17bc314b33dd21", "url": "https://github.com/commons-app/apps-android-commons/commit/53abcace89bf8a94380d79c4aa17bc314b33dd21", "message": "Add tests for map updated case and add missing lines those are being tested", "committedDate": "2020-04-06T13:33:39Z", "type": "commit"}, {"oid": "ca775b9eb5dc03c59752c21f36a513ce71d95dcd", "url": "https://github.com/commons-app/apps-android-commons/commit/ca775b9eb5dc03c59752c21f36a513ce71d95dcd", "message": "Add some missind method verifications", "committedDate": "2020-04-06T14:49:39Z", "type": "commit"}, {"oid": "f691149eeff24a5caca1abd5650025a6dc7e8d9a", "url": "https://github.com/commons-app/apps-android-commons/commit/f691149eeff24a5caca1abd5650025a6dc7e8d9a", "message": "Create real latlang objects isntead of spying them", "committedDate": "2020-04-06T15:02:35Z", "type": "commit"}, {"oid": "98fc8a0c294e097f398e315ad227f89ea483b5ba", "url": "https://github.com/commons-app/apps-android-commons/commit/98fc8a0c294e097f398e315ad227f89ea483b5ba", "message": "Use a real presenter object instead of a spy", "committedDate": "2020-04-06T15:36:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE5MTE5OQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404191199", "bodyText": "I am not sure about this line. @macgills can you guide me? When nearbyFragmentPresenter was a spy, this line was\n       verify(nearbyPresenter).updateMapAndList(LocationChangeType.LOCATION_SIGNIFICANTLY_CHANGED)\n\nNow I changed it to this way, but doesn't seem like a best practice.", "author": "neslihanturan", "createdAt": "2020-04-06T15:40:21Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,342 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager\n+import fr.free.nrw.commons.location.LocationServiceManager.LocationChangeType\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Assert.assertFalse\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = NearbyParentFragmentPresenter(bookmarkLocationsDao)\n+        nearbyPresenter.attachView(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Tests nearby operations are initialized\n+     */\n+    @Test\n+    fun testInitializeNearbyMapOperations() {\n+        nearbyPresenter.initializeMapOperations()\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        testPlacesPopulatedForLatestLocationWhenLocationSignificantlyChanged()\n+        verify(nearbyParentFragmentView).addSearchThisAreaButtonAction()", "originalCommit": "98fc8a0c294e097f398e315ad227f89ea483b5ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1OTYxOA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404659618", "bodyText": "You shouldn't generally be calling another test method but you can make this DRY\nwhenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(latestLocation)\n        whenever(nearbyParentFragmentView.isCurrentLocationMarkerVisible()).thenReturn(false)\n\nextract this to a function expectMapAndListUpdate\nand then this should be the only place you are verifying\n        if (locationChangeType.equals(LOCATION_SIGNIFICANTLY_CHANGED)\n                || locationChangeType.equals(MAP_UPDATED)) {\n            Timber.d(\"LOCATION_SIGNIFICANTLY_CHANGED\");\n            lockUnlockNearby(true);\n            nearbyParentFragmentView.setProgressBarVisibility(true);\n            nearbyParentFragmentView.populatePlaces(lastLocation);\n\nfor LOCATION_SIGNIFICANTLY_CHANGED but seeing as you have to verify this functionality for MAP_UPDATED as well you would also want to extract a method for this verification", "author": "macgills", "createdAt": "2020-04-07T09:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE5MTE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2MzM0OA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r411463348", "bodyText": "I reduced code repetitions, but still calling the test method directly instead of repeating it seemed to me like a cleaner way. So I still keep this line.\ntestPlacesPopulatedForLatestLocationWhenLocationSignificantlyChanged \nYour suggestion is changing this line with the content of the method:\n        expectMapAndListUpdate()\n        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SIGNIFICANTLY_CHANGED)\n        verify(nearbyParentFragmentView).disableFABRecenter();\n        verify(nearbyParentFragmentView).setProgressBarVisibility(true)\n        verify(nearbyParentFragmentView).populatePlaces(latestLocation)\n\nif I am not mistaken, right?", "author": "neslihanturan", "createdAt": "2020-04-20T15:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE5MTE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NjMyNg==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r411466326", "bodyText": "Well, now I used the method content instead. Please ignore my previous message.", "author": "neslihanturan", "createdAt": "2020-04-20T15:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE5MTE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1MzgzMQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404653831", "bodyText": "As per the thread where I first mentioned this annotation\n\nI meant for you to rewrite the test, @VisibleForTesting is an ugly bandaid and should only be used in extreme scenarios", "author": "macgills", "createdAt": "2020-04-07T09:06:04Z", "path": "app/src/main/java/fr/free/nrw/commons/nearby/presenter/NearbyParentFragmentPresenter.java", "diffHunk": "@@ -2,6 +2,7 @@\n \n import android.view.View;\n \n+import androidx.annotation.VisibleForTesting;", "originalCommit": "98fc8a0c294e097f398e315ad227f89ea483b5ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mjk0NA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404662944", "bodyText": "I would rename all these test title to be in backticks so they can be an english sentence eg When nearby is locked do not update view or updateMapAndList when locked does nothing just something that expresses it well so that if somebody reads this in a failed test report they will instantly know what went wrong", "author": "macgills", "createdAt": "2020-04-07T09:20:38Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,342 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager\n+import fr.free.nrw.commons.location.LocationServiceManager.LocationChangeType\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Assert.assertFalse\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = NearbyParentFragmentPresenter(bookmarkLocationsDao)\n+        nearbyPresenter.attachView(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Tests nearby operations are initialized\n+     */\n+    @Test\n+    fun testInitializeNearbyMapOperations() {\n+        nearbyPresenter.initializeMapOperations()\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        testPlacesPopulatedForLatestLocationWhenLocationSignificantlyChanged()\n+        verify(nearbyParentFragmentView).addSearchThisAreaButtonAction()\n+        verify(nearbyParentFragmentView).setCheckBoxAction()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to lock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForLocked() {\n+        nearbyPresenter.lockUnlockNearby(true)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to unlock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForUnlocked() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when location is locked\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLocationLocked() {", "originalCommit": "98fc8a0c294e097f398e315ad227f89ea483b5ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODM1MA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404728350", "bodyText": "Here again I decided to rely on our previous test namings.", "author": "neslihanturan", "createdAt": "2020-04-07T11:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mjk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc0OTMxNQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404749315", "bodyText": "The previous conversation was about documentation. I guess we should have another one on test naming style.\nI personally think it is a fantastic feature that we can write test names in backticks eg\nfun `given some state produce this result`(){}\n\nas opposed to\nfun givenSomeStateProduceThisResult(){}\n\n@misaochan @ashishkumar468 @maskaravivek", "author": "macgills", "createdAt": "2020-04-07T11:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mjk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MjI3MA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r404872270", "bodyText": "Although the backticks style does seem reasonable, but before we impose anything like that, we should discuss and agree to it. Contributors who are willing to use the same are more than welcome, but before we have all agreed to impose it, IMO we can accept PR's which use the existing naming conventions", "author": "ashishkumar468", "createdAt": "2020-04-07T14:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mjk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQyMjkxNQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r405422915", "bodyText": "We didn't all unanimously agree to use\nwhenever\n\ninstead of\nMockito.`when`\n\nbut it looks a lot better so everyone did. We didn't have to update a bible or mark all previous usages as wrong, just commit to doing the better thing going forward which is a perfectly fine and organic method of disseminating information to me.\nIf needs must I will create an issue.", "author": "macgills", "createdAt": "2020-04-08T10:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mjk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyOTUzNQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r406329535", "bodyText": "Yes, please create an issue, so that we can discuss it and update the docs if we all agree. :) If everything else is OK with this PR we can merge, renaming could  be a good first issue for a new contributor later on, no need to force it now.", "author": "misaochan", "createdAt": "2020-04-09T16:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mjk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY3ODI2MQ==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r406678261", "bodyText": "There is nothing to update as there is no test style document I saw\nAnyway #3638 created", "author": "macgills", "createdAt": "2020-04-10T09:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mjk0NA=="}], "type": "inlineReview"}, {"oid": "c6c5796c12e3f33b9b09c5201d498df757dccd2d", "url": "https://github.com/commons-app/apps-android-commons/commit/c6c5796c12e3f33b9b09c5201d498df757dccd2d", "message": "Merge remote-tracking branch 'upstream/master' into addNearbyTests", "committedDate": "2020-04-20T11:16:08Z", "type": "commit"}, {"oid": "0ab622523c583d577d857ebbd7314d7c75d3f8c1", "url": "https://github.com/commons-app/apps-android-commons/commit/0ab622523c583d577d857ebbd7314d7c75d3f8c1", "message": "Revert nonneeded @VisibleForTest annotations, instead reach via lockUnlock method", "committedDate": "2020-04-20T11:31:22Z", "type": "commit"}, {"oid": "86a0a93ceb7a9239f15916c8fe7d1e9e72bc0a7c", "url": "https://github.com/commons-app/apps-android-commons/commit/86a0a93ceb7a9239f15916c8fe7d1e9e72bc0a7c", "message": "Reduce code repetitions", "committedDate": "2020-04-20T15:12:15Z", "type": "commit"}, {"oid": "cd0b1609f3f848812d0beb05c18387d8315b0aba", "url": "https://github.com/commons-app/apps-android-commons/commit/cd0b1609f3f848812d0beb05c18387d8315b0aba", "message": "Do not call a test from another test method", "committedDate": "2020-04-20T15:20:17Z", "type": "commit"}, {"oid": "002ccda44b8f5fb31a459eedfff385684d7a13e9", "url": "https://github.com/commons-app/apps-android-commons/commit/002ccda44b8f5fb31a459eedfff385684d7a13e9", "message": "Add some more tests", "committedDate": "2020-04-29T20:24:25Z", "type": "commit"}, {"oid": "e3347e514ae1921ae6428bd67343f93b2f766312", "url": "https://github.com/commons-app/apps-android-commons/commit/e3347e514ae1921ae6428bd67343f93b2f766312", "message": "Fix minor issues", "committedDate": "2020-04-29T20:49:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMTEyMA==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r420031120", "bodyText": "These tests still miss a lot of this method. You can use argument captors like\nval captor = ArgumentCaptor.for(View.OnCLickListener::class.java)\nverify(nearbyParentFragmentView).setFABPlusAction(captor.capture())\ncaptor.value.onClick(null)\n\nYou can also use annotations to declare an ArgumentCaptor but I wouldn't do that unless the argument captor is used in many tests", "author": "macgills", "createdAt": "2020-05-05T11:11:58Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,444 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.mapbox.mapboxsdk.annotations.Marker\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager.LocationChangeType\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Assert.assertFalse\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+    @Mock\n+    internal lateinit var marker: Marker\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = NearbyParentFragmentPresenter(bookmarkLocationsDao)\n+        nearbyPresenter.attachView(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Tests nearby operations are initialized\n+     */\n+    @Test\n+    fun testInitializeNearbyMapOperations() {\n+        nearbyPresenter.initializeMapOperations()\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        expectMapAndListUpdate()\n+        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SIGNIFICANTLY_CHANGED)\n+        verify(nearbyParentFragmentView).disableFABRecenter();\n+        verify(nearbyParentFragmentView).setProgressBarVisibility(true)\n+        verify(nearbyParentFragmentView).populatePlaces(latestLocation)\n+        verify(nearbyParentFragmentView).addSearchThisAreaButtonAction()\n+        verify(nearbyParentFragmentView).setCheckBoxAction()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to lock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForLocked() {\n+        nearbyPresenter.lockUnlockNearby(true)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to unlock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForUnlocked() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when location is locked\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLocationLocked() {\n+        nearbyPresenter.lockUnlockNearby(true)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+        verifyZeroInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when network connection\n+     * is not established\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenNoNetworkConnection() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(false)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when last location is null\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLastLocationIsNull() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(null)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verify(nearbyParentFragmentView).getLastLocation()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with latest location of user\n+     * at significant location change\n+     */\n+    @Test\n+    fun testPlacesPopulatedForLatestLocationWhenLocationSignificantlyChanged() {\n+        expectMapAndListUpdate()\n+        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SIGNIFICANTLY_CHANGED)\n+        updateMapSignificantly()\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with latest location of user\n+     * at map is updated location change type\n+     */\n+    @Test\n+    fun testPlacesPopulatedForLatestLocationWhenLocationMapUpdated() {\n+        expectMapAndListUpdate()\n+        nearbyPresenter.updateMapAndList(LocationChangeType.MAP_UPDATED)\n+        updateMapSignificantly()\n+    }\n+\n+    fun updateMapSignificantly() {\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+        verify(nearbyParentFragmentView).setProgressBarVisibility(true)\n+        verify(nearbyParentFragmentView).populatePlaces(latestLocation)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with camera target location\n+     * at search custom area mode\n+     */\n+    @Test\n+    fun testPlacesPopulatedForCameraTargetLocationWhenSearchCustomArea() {\n+        expectMapAndListUpdate()\n+        whenever(nearbyParentFragmentView.getCameraTarget()).thenReturn(cameraTarget)\n+        nearbyPresenter.updateMapAndList(LocationChangeType.SEARCH_CUSTOM_AREA)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+        verify(nearbyParentFragmentView).setProgressBarVisibility(true)\n+        verify(nearbyParentFragmentView).populatePlaces(cameraTarget)\n+    }\n+\n+    /**\n+     * Test testUpdateMapAndList tracks users location if current location marker is visible and\n+     * location is slightly changed\n+     */\n+    @Test\n+    fun testUserTrackedWhenCurrentLocationMarkerVisible() {\n+        expectMapAndListUpdate()\n+        whenever(nearbyParentFragmentView.isCurrentLocationMarkerVisible()).thenReturn(true)\n+        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SLIGHTLY_CHANGED)\n+        verify(nearbyParentFragmentView).recenterMap(latestLocation)\n+    }\n+\n+    /**\n+     * Test testUpdateMapAndList doesn't track users location if current location marker is\n+     * invisible and location is slightly changed\n+     */\n+    @Test\n+    fun testUserNotTrackedWhenCurrentLocationMarkerInvisible() {\n+        expectMapAndListUpdate()\n+        whenever(nearbyParentFragmentView.isCurrentLocationMarkerVisible()).thenReturn(false)\n+        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SLIGHTLY_CHANGED)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verify(nearbyParentFragmentView).getLastLocation()\n+        verify(nearbyParentFragmentView).isCurrentLocationMarkerVisible()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test search this area button became visible after user moved the camera target to far\n+     * away from current target. Distance between these two point is 111.19 km, so our camera target\n+     * is at outside of previously searched region if we set latestSearchRadius below 111.19. Thus,\n+     * setSearchThisAreaButtonVisibility(true) should be verified.\n+     */\n+    @Test\n+    fun testSearchThisAreaButtonVisibleWhenMoveToFarPosition() {\n+        NearbyController.latestSearchLocation = Mockito.spy(LatLng(2.0,1.0,0.0F))\n+        mapboxCameraTarget = Mockito.spy(com.mapbox.mapboxsdk.geometry.LatLng(1.0,1.0,0.0))\n+        // Distance between these two point is 111.19 km\n+        NearbyController.latestSearchRadius = 111.0*1000 // To meter\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        nearbyPresenter.onCameraMove(mapboxCameraTarget)\n+        verify(nearbyParentFragmentView).setSearchThisAreaButtonVisibility(true)\n+    }\n+\n+    /**\n+     * Test search this area button became visible after user moved the camera target to far\n+     * away from current target. Distance between these two point is 111.19 km, so our camera target\n+     * is at inside of previously searched region if we set latestSearchRadius above 111.19. Thus,\n+     * setSearchThisAreaButtonVisibility(false) should be verified.\n+     */\n+    @Test\n+    fun testSearchThisAreaButtonInvisibleWhenMoveToClosePosition() {\n+        NearbyController.latestSearchLocation = Mockito.spy(LatLng(2.0,1.0,0.0F))\n+        mapboxCameraTarget = Mockito.spy(com.mapbox.mapboxsdk.geometry.LatLng(1.0,1.0,0.0))\n+        // Distance between these two point is 111.19 km\n+        NearbyController.latestSearchRadius = 112.0*1000 // To meter\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        nearbyPresenter.onCameraMove(mapboxCameraTarget)\n+        verify(nearbyParentFragmentView).setSearchThisAreaButtonVisibility(false)\n+    }\n+\n+    /**\n+     * Multi selection should overwrite single selection of marker types. Ie. when user choose\n+     *\"parks\", then they multi select to display all or none, we overwrite previous \"park\" filter.\n+     *\n+     * We expect zero interaction from view when state is UNKNOWN\n+     */\n+    @Test\n+    fun testFilterByMarkerTypeMultiSelectUNKNOWN() {\n+        val state = CheckBoxTriStates.UNKNOWN\n+        nearbyPresenter.filterByMarkerType(selectedLabels,state,false,true)\n+        verifyZeroInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Multi selection should overwrite single selection of marker types. Ie. when user choose\n+     *\"parks\", then they multi select to display all or none, we overwrite previous \"park\" filter.\n+     *\n+     * We expect just filterOutAllMarkers and setRecyclerViewAdapterItemsGreyedOut is called when\n+     * the state is UNCHECKED\n+     */\n+    @Test\n+    fun testFilterByMarkerTypeMultiSelectUNCHECKED() {\n+        val state = CheckBoxTriStates.UNCHECKED\n+        nearbyPresenter.filterByMarkerType(selectedLabels,state,false,true)\n+        verify(nearbyParentFragmentView).filterOutAllMarkers()\n+        verify(nearbyParentFragmentView).setRecyclerViewAdapterItemsGreyedOut()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Multi selection should overwrite single selection of marker types. Ie. when user choose\n+     *\"parks\", then they multi select to display all or none, we overwrite previous \"park\" filter.\n+     *\n+     * We expect just displayAllMarkers and setRecyclerViewAdapterAllSelected is called when\n+     * the state is CHECKED\n+     */\n+    @Test\n+    fun testFilterByMarkerTypeMultiSelectCHECKED() {\n+        val state = CheckBoxTriStates.CHECKED\n+        nearbyPresenter.filterByMarkerType(selectedLabels, state, false,true)\n+        verify(nearbyParentFragmentView).displayAllMarkers()\n+        verify(nearbyParentFragmentView).setRecyclerViewAdapterAllSelected()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * We expect just filterMarkersByLabels is called when filterForAllNoneType is false\n+     */\n+    @Test\n+    fun testFilterByMarkerTypeSingleSelect() {\n+        nearbyPresenter.filterByMarkerType(selectedLabels, 0, true,false)\n+        verify(nearbyParentFragmentView).filterMarkersByLabels(any(), any(), any(), any(), any());\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test if bottom sheet gets hidden after search view gained focus\n+     */\n+    @Test\n+    fun testSearchViewFocusWhenBottomSheetExpanded() {\n+        whenever(nearbyParentFragmentView.isListBottomSheetExpanded()).thenReturn(true)\n+        nearbyPresenter.searchViewGainedFocus()\n+        verify(nearbyParentFragmentView).hideBottomSheet()\n+    }\n+\n+    /**\n+     * Test if bottom details sheet gets hidden after search view gained focus\n+     */\n+    @Test\n+    fun testSearchViewFocusWhenDetailsBottomSheetVisible() {\n+        whenever(nearbyParentFragmentView.isListBottomSheetExpanded()).thenReturn(false)\n+        whenever(nearbyParentFragmentView.isDetailsBottomSheetVisible()).thenReturn(true)\n+        nearbyPresenter.searchViewGainedFocus()\n+        verify(nearbyParentFragmentView).hideBottomDetailsSheet()\n+    }\n+\n+    /**\n+     * Test if the search is close to current location, when last location is null we expect it to\n+     * return true\n+     */\n+    @Test\n+    fun testSearchCloseToCurrentLocationNullLastLocation() {\n+        whenever(nearbyParentFragmentView.getLastFocusLocation()).thenReturn(null)\n+        val isClose = nearbyPresenter?.searchCloseToCurrentLocation()\n+        assertTrue(isClose!!)\n+    }\n+\n+    /**\n+     * Test if the search is close to current location, when far\n+     */\n+    @Test\n+    fun testSearchCloseToCurrentLocationWhenFar() {\n+        whenever(nearbyParentFragmentView.getLastFocusLocation()).\n+            thenReturn(com.mapbox.mapboxsdk.geometry.LatLng(1.0,1.0,0.0))\n+        whenever(nearbyParentFragmentView.getCameraTarget()).\n+                thenReturn(LatLng(2.0,1.0,0.0F))\n+        //111.19 km real distance, return false if 148306.444306 >  currentLocationSearchRadius\n+        NearbyController.currentLocationSearchRadius = 148306.0\n+        val isClose = nearbyPresenter?.searchCloseToCurrentLocation()\n+        assertFalse(isClose!!)\n+    }\n+\n+    /**\n+     * Test if the search is close to current location, when close\n+     */\n+    @Test\n+    fun testSearchCloseToCurrentLocationWhenClose() {\n+        whenever(nearbyParentFragmentView.getLastFocusLocation()).\n+            thenReturn(com.mapbox.mapboxsdk.geometry.LatLng(1.0,1.0,0.0))\n+        whenever(nearbyParentFragmentView.getCameraTarget()).\n+            thenReturn(LatLng(2.0,1.0,0.0F))\n+        //111.19 km real distance, return false if 148253.333 >  currentLocationSearchRadius\n+        NearbyController.currentLocationSearchRadius = 148307.0\n+        val isClose = nearbyPresenter?.searchCloseToCurrentLocation()\n+        assertTrue(isClose!!)\n+    }\n+\n+    fun expectMapAndListUpdate() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(latestLocation)\n+    }\n+\n+    @Test\n+    fun testSetActionListeners() {\n+        nearbyPresenter.setActionListeners(any())\n+        verify(nearbyParentFragmentView).setFABPlusAction(any())", "originalCommit": "e3347e514ae1921ae6428bd67343f93b2f766312", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNDE5Ng==", "url": "https://github.com/commons-app/apps-android-commons/pull/3615#discussion_r420034196", "bodyText": "you would need to set your expectations first.\nIt is weird that this test calls 2 methods on nearbyPresenter when onWikidataEditSuccessful already calls updateMapAndList\nThis goes for the following tests too", "author": "macgills", "createdAt": "2020-05-05T11:18:29Z", "path": "app/src/test/kotlin/fr/free/nrw/commons/nearby/NearbyParentFragmentPresenterTest.kt", "diffHunk": "@@ -0,0 +1,444 @@\n+package fr.free.nrw.commons.nearby\n+\n+import com.mapbox.mapboxsdk.annotations.Marker\n+import com.nhaarman.mockitokotlin2.*\n+import fr.free.nrw.commons.bookmarks.locations.BookmarkLocationsDao\n+import fr.free.nrw.commons.location.LatLng\n+import fr.free.nrw.commons.location.LocationServiceManager.LocationChangeType\n+import fr.free.nrw.commons.nearby.contract.NearbyParentFragmentContract\n+import fr.free.nrw.commons.nearby.presenter.NearbyParentFragmentPresenter\n+import org.junit.Assert.assertFalse\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+import org.mockito.Mock\n+import org.mockito.Mockito\n+import org.mockito.MockitoAnnotations\n+\n+/**\n+ * The unit test class for NearbyParentFragmentPresenter\n+ */\n+class NearbyParentFragmentPresenterTest {\n+    @Mock\n+    internal lateinit var nearbyParentFragmentView: NearbyParentFragmentContract.View\n+    @Mock\n+    internal lateinit var bookmarkLocationsDao: BookmarkLocationsDao\n+    @Mock\n+    internal lateinit var latestLocation: LatLng\n+    @Mock\n+    internal lateinit var cameraTarget: LatLng\n+    @Mock\n+    internal lateinit var selectedLabels: List<Label>\n+    @Mock\n+    internal lateinit var marker: Marker\n+\n+    private lateinit var nearbyPresenter: NearbyParentFragmentPresenter\n+    private lateinit var mapboxCameraTarget: com.mapbox.mapboxsdk.geometry.LatLng\n+\n+    /**\n+     * initial setup\n+     */\n+    @Before\n+    @Throws(Exception::class)\n+    fun setUp() {\n+        MockitoAnnotations.initMocks(this)\n+        nearbyPresenter = NearbyParentFragmentPresenter(bookmarkLocationsDao)\n+        nearbyPresenter.attachView(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Tests nearby operations are initialized\n+     */\n+    @Test\n+    fun testInitializeNearbyMapOperations() {\n+        nearbyPresenter.initializeMapOperations()\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        expectMapAndListUpdate()\n+        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SIGNIFICANTLY_CHANGED)\n+        verify(nearbyParentFragmentView).disableFABRecenter();\n+        verify(nearbyParentFragmentView).setProgressBarVisibility(true)\n+        verify(nearbyParentFragmentView).populatePlaces(latestLocation)\n+        verify(nearbyParentFragmentView).addSearchThisAreaButtonAction()\n+        verify(nearbyParentFragmentView).setCheckBoxAction()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to lock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForLocked() {\n+        nearbyPresenter.lockUnlockNearby(true)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+    }\n+\n+    /**\n+     * Test lockUnlockNearby method to unlock nearby case\n+     */\n+    @Test\n+    fun testLockUnlockNearbyForUnlocked() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when location is locked\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLocationLocked() {\n+        nearbyPresenter.lockUnlockNearby(true)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+        verifyZeroInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when network connection\n+     * is not established\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenNoNetworkConnection() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(false)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method returns with zero interactions when last location is null\n+     */\n+    @Test\n+    fun testUpdateMapAndListWhenLastLocationIsNull() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(null)\n+        nearbyPresenter.updateMapAndList(null)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verify(nearbyParentFragmentView).getLastLocation()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with latest location of user\n+     * at significant location change\n+     */\n+    @Test\n+    fun testPlacesPopulatedForLatestLocationWhenLocationSignificantlyChanged() {\n+        expectMapAndListUpdate()\n+        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SIGNIFICANTLY_CHANGED)\n+        updateMapSignificantly()\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with latest location of user\n+     * at map is updated location change type\n+     */\n+    @Test\n+    fun testPlacesPopulatedForLatestLocationWhenLocationMapUpdated() {\n+        expectMapAndListUpdate()\n+        nearbyPresenter.updateMapAndList(LocationChangeType.MAP_UPDATED)\n+        updateMapSignificantly()\n+    }\n+\n+    fun updateMapSignificantly() {\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+        verify(nearbyParentFragmentView).setProgressBarVisibility(true)\n+        verify(nearbyParentFragmentView).populatePlaces(latestLocation)\n+    }\n+\n+    /**\n+     * Test updateMapAndList method updates parent fragment view with camera target location\n+     * at search custom area mode\n+     */\n+    @Test\n+    fun testPlacesPopulatedForCameraTargetLocationWhenSearchCustomArea() {\n+        expectMapAndListUpdate()\n+        whenever(nearbyParentFragmentView.getCameraTarget()).thenReturn(cameraTarget)\n+        nearbyPresenter.updateMapAndList(LocationChangeType.SEARCH_CUSTOM_AREA)\n+        verify(nearbyParentFragmentView).disableFABRecenter()\n+        verify(nearbyParentFragmentView).setProgressBarVisibility(true)\n+        verify(nearbyParentFragmentView).populatePlaces(cameraTarget)\n+    }\n+\n+    /**\n+     * Test testUpdateMapAndList tracks users location if current location marker is visible and\n+     * location is slightly changed\n+     */\n+    @Test\n+    fun testUserTrackedWhenCurrentLocationMarkerVisible() {\n+        expectMapAndListUpdate()\n+        whenever(nearbyParentFragmentView.isCurrentLocationMarkerVisible()).thenReturn(true)\n+        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SLIGHTLY_CHANGED)\n+        verify(nearbyParentFragmentView).recenterMap(latestLocation)\n+    }\n+\n+    /**\n+     * Test testUpdateMapAndList doesn't track users location if current location marker is\n+     * invisible and location is slightly changed\n+     */\n+    @Test\n+    fun testUserNotTrackedWhenCurrentLocationMarkerInvisible() {\n+        expectMapAndListUpdate()\n+        whenever(nearbyParentFragmentView.isCurrentLocationMarkerVisible()).thenReturn(false)\n+        nearbyPresenter.updateMapAndList(LocationChangeType.LOCATION_SLIGHTLY_CHANGED)\n+        verify(nearbyParentFragmentView).enableFABRecenter()\n+        verify(nearbyParentFragmentView).isNetworkConnectionEstablished()\n+        verify(nearbyParentFragmentView).getLastLocation()\n+        verify(nearbyParentFragmentView).isCurrentLocationMarkerVisible()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test search this area button became visible after user moved the camera target to far\n+     * away from current target. Distance between these two point is 111.19 km, so our camera target\n+     * is at outside of previously searched region if we set latestSearchRadius below 111.19. Thus,\n+     * setSearchThisAreaButtonVisibility(true) should be verified.\n+     */\n+    @Test\n+    fun testSearchThisAreaButtonVisibleWhenMoveToFarPosition() {\n+        NearbyController.latestSearchLocation = Mockito.spy(LatLng(2.0,1.0,0.0F))\n+        mapboxCameraTarget = Mockito.spy(com.mapbox.mapboxsdk.geometry.LatLng(1.0,1.0,0.0))\n+        // Distance between these two point is 111.19 km\n+        NearbyController.latestSearchRadius = 111.0*1000 // To meter\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        nearbyPresenter.onCameraMove(mapboxCameraTarget)\n+        verify(nearbyParentFragmentView).setSearchThisAreaButtonVisibility(true)\n+    }\n+\n+    /**\n+     * Test search this area button became visible after user moved the camera target to far\n+     * away from current target. Distance between these two point is 111.19 km, so our camera target\n+     * is at inside of previously searched region if we set latestSearchRadius above 111.19. Thus,\n+     * setSearchThisAreaButtonVisibility(false) should be verified.\n+     */\n+    @Test\n+    fun testSearchThisAreaButtonInvisibleWhenMoveToClosePosition() {\n+        NearbyController.latestSearchLocation = Mockito.spy(LatLng(2.0,1.0,0.0F))\n+        mapboxCameraTarget = Mockito.spy(com.mapbox.mapboxsdk.geometry.LatLng(1.0,1.0,0.0))\n+        // Distance between these two point is 111.19 km\n+        NearbyController.latestSearchRadius = 112.0*1000 // To meter\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        nearbyPresenter.onCameraMove(mapboxCameraTarget)\n+        verify(nearbyParentFragmentView).setSearchThisAreaButtonVisibility(false)\n+    }\n+\n+    /**\n+     * Multi selection should overwrite single selection of marker types. Ie. when user choose\n+     *\"parks\", then they multi select to display all or none, we overwrite previous \"park\" filter.\n+     *\n+     * We expect zero interaction from view when state is UNKNOWN\n+     */\n+    @Test\n+    fun testFilterByMarkerTypeMultiSelectUNKNOWN() {\n+        val state = CheckBoxTriStates.UNKNOWN\n+        nearbyPresenter.filterByMarkerType(selectedLabels,state,false,true)\n+        verifyZeroInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Multi selection should overwrite single selection of marker types. Ie. when user choose\n+     *\"parks\", then they multi select to display all or none, we overwrite previous \"park\" filter.\n+     *\n+     * We expect just filterOutAllMarkers and setRecyclerViewAdapterItemsGreyedOut is called when\n+     * the state is UNCHECKED\n+     */\n+    @Test\n+    fun testFilterByMarkerTypeMultiSelectUNCHECKED() {\n+        val state = CheckBoxTriStates.UNCHECKED\n+        nearbyPresenter.filterByMarkerType(selectedLabels,state,false,true)\n+        verify(nearbyParentFragmentView).filterOutAllMarkers()\n+        verify(nearbyParentFragmentView).setRecyclerViewAdapterItemsGreyedOut()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Multi selection should overwrite single selection of marker types. Ie. when user choose\n+     *\"parks\", then they multi select to display all or none, we overwrite previous \"park\" filter.\n+     *\n+     * We expect just displayAllMarkers and setRecyclerViewAdapterAllSelected is called when\n+     * the state is CHECKED\n+     */\n+    @Test\n+    fun testFilterByMarkerTypeMultiSelectCHECKED() {\n+        val state = CheckBoxTriStates.CHECKED\n+        nearbyPresenter.filterByMarkerType(selectedLabels, state, false,true)\n+        verify(nearbyParentFragmentView).displayAllMarkers()\n+        verify(nearbyParentFragmentView).setRecyclerViewAdapterAllSelected()\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * We expect just filterMarkersByLabels is called when filterForAllNoneType is false\n+     */\n+    @Test\n+    fun testFilterByMarkerTypeSingleSelect() {\n+        nearbyPresenter.filterByMarkerType(selectedLabels, 0, true,false)\n+        verify(nearbyParentFragmentView).filterMarkersByLabels(any(), any(), any(), any(), any());\n+        verifyNoMoreInteractions(nearbyParentFragmentView)\n+    }\n+\n+    /**\n+     * Test if bottom sheet gets hidden after search view gained focus\n+     */\n+    @Test\n+    fun testSearchViewFocusWhenBottomSheetExpanded() {\n+        whenever(nearbyParentFragmentView.isListBottomSheetExpanded()).thenReturn(true)\n+        nearbyPresenter.searchViewGainedFocus()\n+        verify(nearbyParentFragmentView).hideBottomSheet()\n+    }\n+\n+    /**\n+     * Test if bottom details sheet gets hidden after search view gained focus\n+     */\n+    @Test\n+    fun testSearchViewFocusWhenDetailsBottomSheetVisible() {\n+        whenever(nearbyParentFragmentView.isListBottomSheetExpanded()).thenReturn(false)\n+        whenever(nearbyParentFragmentView.isDetailsBottomSheetVisible()).thenReturn(true)\n+        nearbyPresenter.searchViewGainedFocus()\n+        verify(nearbyParentFragmentView).hideBottomDetailsSheet()\n+    }\n+\n+    /**\n+     * Test if the search is close to current location, when last location is null we expect it to\n+     * return true\n+     */\n+    @Test\n+    fun testSearchCloseToCurrentLocationNullLastLocation() {\n+        whenever(nearbyParentFragmentView.getLastFocusLocation()).thenReturn(null)\n+        val isClose = nearbyPresenter?.searchCloseToCurrentLocation()\n+        assertTrue(isClose!!)\n+    }\n+\n+    /**\n+     * Test if the search is close to current location, when far\n+     */\n+    @Test\n+    fun testSearchCloseToCurrentLocationWhenFar() {\n+        whenever(nearbyParentFragmentView.getLastFocusLocation()).\n+            thenReturn(com.mapbox.mapboxsdk.geometry.LatLng(1.0,1.0,0.0))\n+        whenever(nearbyParentFragmentView.getCameraTarget()).\n+                thenReturn(LatLng(2.0,1.0,0.0F))\n+        //111.19 km real distance, return false if 148306.444306 >  currentLocationSearchRadius\n+        NearbyController.currentLocationSearchRadius = 148306.0\n+        val isClose = nearbyPresenter?.searchCloseToCurrentLocation()\n+        assertFalse(isClose!!)\n+    }\n+\n+    /**\n+     * Test if the search is close to current location, when close\n+     */\n+    @Test\n+    fun testSearchCloseToCurrentLocationWhenClose() {\n+        whenever(nearbyParentFragmentView.getLastFocusLocation()).\n+            thenReturn(com.mapbox.mapboxsdk.geometry.LatLng(1.0,1.0,0.0))\n+        whenever(nearbyParentFragmentView.getCameraTarget()).\n+            thenReturn(LatLng(2.0,1.0,0.0F))\n+        //111.19 km real distance, return false if 148253.333 >  currentLocationSearchRadius\n+        NearbyController.currentLocationSearchRadius = 148307.0\n+        val isClose = nearbyPresenter?.searchCloseToCurrentLocation()\n+        assertTrue(isClose!!)\n+    }\n+\n+    fun expectMapAndListUpdate() {\n+        nearbyPresenter.lockUnlockNearby(false)\n+        whenever(nearbyParentFragmentView.isNetworkConnectionEstablished()).thenReturn(true)\n+        whenever(nearbyParentFragmentView.getLastLocation()).thenReturn(latestLocation)\n+    }\n+\n+    @Test\n+    fun testSetActionListeners() {\n+        nearbyPresenter.setActionListeners(any())\n+        verify(nearbyParentFragmentView).setFABPlusAction(any())\n+        verify(nearbyParentFragmentView).setFABRecenterAction(any())\n+    }\n+\n+    @Test\n+    fun testBackButtonClickedWhenBottomSheetExpanded() {\n+        whenever(nearbyParentFragmentView.isListBottomSheetExpanded()).thenReturn(true)\n+        nearbyPresenter.backButtonClicked()\n+        verify(nearbyParentFragmentView).listOptionMenuItemClicked()\n+    }\n+\n+    @Test\n+    fun testBackButtonClickedWhenDetailsBottomSheetVisible() {\n+        whenever(nearbyParentFragmentView.isListBottomSheetExpanded()).thenReturn(false)\n+        whenever(nearbyParentFragmentView.isDetailsBottomSheetVisible()).thenReturn(true)\n+        nearbyPresenter.backButtonClicked()\n+        verify(nearbyParentFragmentView).setBottomSheetDetailsSmaller()\n+    }\n+\n+    @Test\n+    fun testBackButtonClickedWhenNoSheetVisible() {\n+        whenever(nearbyParentFragmentView.isListBottomSheetExpanded()).thenReturn(false)\n+        whenever(nearbyParentFragmentView.isDetailsBottomSheetVisible()).thenReturn(false)\n+        nearbyPresenter.backButtonClicked()\n+        verify(nearbyParentFragmentView).setTabItemContributions()\n+    }\n+\n+    @Test\n+    fun testMarkerUnselected() {\n+        nearbyPresenter.markerUnselected()\n+        verify(nearbyParentFragmentView).hideBottomSheet();\n+    }\n+\n+    @Test\n+    fun testMarkerSelected() {\n+        nearbyPresenter.markerSelected(marker)\n+        verify(nearbyParentFragmentView).displayBottomSheetWithInfo(marker)\n+    }\n+\n+    @Test\n+    fun testOnWikidataEditSuccessful() {\n+        nearbyPresenter.onWikidataEditSuccessful()", "originalCommit": "e3347e514ae1921ae6428bd67343f93b2f766312", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}