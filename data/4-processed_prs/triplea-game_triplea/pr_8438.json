{"pr_number": 8438, "pr_title": "Create HistoryChange objects for killing and transforming units", "pr_createdAt": "2020-12-15T03:53:04Z", "pr_url": "https://github.com/triplea-game/triplea/pull/8438", "timeline": [{"oid": "3875525bf7e22222e9aaee8e02c6229aaab47bce", "url": "https://github.com/triplea-game/triplea/commit/3875525bf7e22222e9aaee8e02c6229aaab47bce", "message": "Create HistoryChange objects for killing and transforming units\n\nThe HistoryChange objects will group the calls to add a history child\nevent and calls to add change objects. This will creating these objects\nwithout the need for the bridge and then returning them to callers where\nthe bridge is available.\n\nKillUnit object has been used in many of the places in the battle code\nthat removes units. In most of those places, transformation wasn't being\ndone, so this fixes that.\n\nKillUnit also makes it explicit that transported and unloaded units are\nkilled when it is killed. There is still some code (such as\nAbstractBattle#unitsLostInPrecedingBattle) which does some of this work,\nthough.\n\nRework how units are killed and transformed in MustFightBattle. The\noriginal logic went like:\n1. Create a change object to kill a unit\n2. Detect if the unit needs to transform when it dies\n3. Create a change object to also set its damage to the maximum\n - At this point, there is a change object to kill it and one to set its\n damage\n4. Add the units to a list of killed units during the round\n5. Execute the change objects\n6. Later, during the clearCasualty steps, go through the units hit as\n well as the units that were previously killed in step 4\n7. Transform them\n\nIf the change object in 3 doesn't happen, then the unit won't transform\nbecause its damage won't match the settings.\nIf the unit isn't added to the list in 4, then the unit won't transform\nbecause it won't be seen in step 6.\n\nThe new logic now has the code to kill units moved to the KillUnits\nHistoryChange object. This object will call TransformUnits if needed.\nSo the new logic looks like this:\n1. Create KillUnits object\n2. This creates change objects to kill the units\n3. This creates a TransformUnits object that creates change objects to\n transform the units.\n4. Later, during the clearCasualty step, only the units that have been\nhit get passed into a TransformUnits object. The killed units from 1-3\nno longer need to be worried about.\n\nBecause of save compatibility reasons, the old killedDuringCurrentRound\nvariable is still around and is still being used in step 4. But it is no\nlonger being populated so it will only actually be used if the save is\nin the middle of a battle and has already populated it.", "committedDate": "2020-12-15T03:28:55Z", "type": "commit"}, {"oid": "e09b57eb20ce78afa0fe6dbb789c626f223af424", "url": "https://github.com/triplea-game/triplea/commit/e09b57eb20ce78afa0fe6dbb789c626f223af424", "message": "Remove unused constructor", "committedDate": "2020-12-15T04:01:13Z", "type": "commit"}, {"oid": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "url": "https://github.com/triplea-game/triplea/commit/87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "message": "Don't call the unused constructor either", "committedDate": "2020-12-15T04:06:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTI0MQ==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546431241", "bodyText": "Any thoughts if 'kill' might be a confused with battle casualties? In battle, a unit when 'killed' is sent to the casualty bucket before being removed.\nSuggestion: Perhaps \"RemoveUnits\" might be a more flexible and clear name.", "author": "DanVanAtta", "createdAt": "2020-12-20T20:20:10Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location\n+ *\n+ * <p>Adds a history event for the killing\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformUnits}\n+ */\n+@Value\n+public class KillUnits implements HistoryChange {", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTM4Nw==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546431387", "bodyText": "Is the 'allArgsConstructor' of '@value' being used?\nAs-is, it looks like there are a lot of constructors for this object, enough so it might be hard to reason about how it is instantiated, which makes reasoning about the object state difficult and depend on tracing down call flows.\nIf we do not use the 'all args constructor', removing that can help the above problem and just replace this with 'getter, setter, and equalsAndHashcode'.", "author": "DanVanAtta", "createdAt": "2020-12-20T20:21:55Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location\n+ *\n+ * <p>Adds a history event for the killing\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformUnits}\n+ */\n+@Value", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTQ3MA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546431470", "bodyText": "Nit, comment can be condensed:\nAdds a history event for the removing units in a territory", "author": "DanVanAtta", "createdAt": "2020-12-20T20:22:38Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTc4Nw==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546431787", "bodyText": "Does this assume that transported units are always killed? Could we instead make this logic the responsibility of the caller?\nKnowing that transported units are killed is a game-rule detail. This history object therefor not only tracks the history transformation, but it also encodes the rule that transported units are killed. If the caller were to handle this detail, and pass the list of transported units into the killed list, then this class would no longer be aware of that rule detail.", "author": "DanVanAtta", "createdAt": "2020-12-20T20:25:28Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location\n+ *\n+ * <p>Adds a history event for the killing\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformUnits}\n+ */\n+@Value\n+public class KillUnits implements HistoryChange {\n+\n+  Territory location;\n+  Collection<Unit> killedUnits;\n+  Map<Territory, Collection<Unit>> unloadedUnits = new HashMap<>();\n+  TransformUnits transformUnits;\n+  String messageTemplate;\n+  /** Units that were killed */\n+  Collection<Unit> oldUnits = new ArrayList<>();\n+  /** The units that were created after a transformation */\n+  Collection<Unit> newUnits = new ArrayList<>();\n+\n+  public KillUnits(final Territory location, final Collection<Unit> killedUnits) {\n+    this(location, killedUnits, \"${units} lost in ${territory}\");\n+  }\n+\n+  /** @param messageTemplate ${units} and ${territory} will be replaced in this template */\n+  public KillUnits(\n+      final Territory location, final Collection<Unit> killedUnits, final String messageTemplate) {\n+    this.location = location;\n+    this.messageTemplate = messageTemplate;\n+\n+    // temporarily give the unit maximum damage so that TransformUnits will be able to\n+    // recognize units that need to be transformed when they are killed\n+    final IntegerMap<Unit> originalHits = new IntegerMap<>();\n+    killedUnits.forEach(\n+        unit -> {\n+          originalHits.add(unit, unit.getHits());\n+          unit.setHits(unit.getUnitAttachment().getHitPoints());\n+        });\n+\n+    transformUnits = new TransformUnits(location, killedUnits);\n+\n+    killedUnits.forEach(\n+        unit -> {\n+          unit.setHits(originalHits.getInt(unit));\n+        });\n+\n+    oldUnits.addAll(killedUnits);\n+    // ensure that any units that are being transported are also killed", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ0MjI2NQ==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546442265", "bodyText": "Yes, it assumes that transported units are always killed.  There is currently no way to prevent that from happening in the engine.\nI don't want the caller to handle this detail.  Because currently, it handles it incorrectly.  Some parts of the battle code that kills units will correctly remove their transported units.  Other parts of the battle code leaves the units floating in the ocean and luckily some other part of the code much later happens to clear them up.  By hiding this detail from the caller, it makes the code easier to read.\nAs for allowing the map to control whether this should be killed or not, that is the work I'm doing with the translate object code where transported items can be copied from one unit to another unit.", "author": "trevan", "createdAt": "2020-12-20T22:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMTc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjAyOQ==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432029", "bodyText": "nit, the collection copy and then 'removalAll' can be be avoided, EG:\nthis.killedUnits = oldUnits.stream().filter(oldUnit -> transformedUnits.getOldUnits().contains(oldUnit)).collect(...);", "author": "DanVanAtta", "createdAt": "2020-12-20T20:27:10Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/KillUnits.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Kills a set of units in a location\n+ *\n+ * <p>Adds a history event for the killing\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformUnits}\n+ */\n+@Value\n+public class KillUnits implements HistoryChange {\n+\n+  Territory location;\n+  Collection<Unit> killedUnits;\n+  Map<Territory, Collection<Unit>> unloadedUnits = new HashMap<>();\n+  TransformUnits transformUnits;\n+  String messageTemplate;\n+  /** Units that were killed */\n+  Collection<Unit> oldUnits = new ArrayList<>();\n+  /** The units that were created after a transformation */\n+  Collection<Unit> newUnits = new ArrayList<>();\n+\n+  public KillUnits(final Territory location, final Collection<Unit> killedUnits) {\n+    this(location, killedUnits, \"${units} lost in ${territory}\");\n+  }\n+\n+  /** @param messageTemplate ${units} and ${territory} will be replaced in this template */\n+  public KillUnits(\n+      final Territory location, final Collection<Unit> killedUnits, final String messageTemplate) {\n+    this.location = location;\n+    this.messageTemplate = messageTemplate;\n+\n+    // temporarily give the unit maximum damage so that TransformUnits will be able to\n+    // recognize units that need to be transformed when they are killed\n+    final IntegerMap<Unit> originalHits = new IntegerMap<>();\n+    killedUnits.forEach(\n+        unit -> {\n+          originalHits.add(unit, unit.getHits());\n+          unit.setHits(unit.getUnitAttachment().getHitPoints());\n+        });\n+\n+    transformUnits = new TransformUnits(location, killedUnits);\n+\n+    killedUnits.forEach(\n+        unit -> {\n+          unit.setHits(originalHits.getInt(unit));\n+        });\n+\n+    oldUnits.addAll(killedUnits);\n+    // ensure that any units that are being transported are also killed\n+    killedUnits.stream()\n+        .map(unit -> unit.getTransporting(location))\n+        .flatMap(Collection::stream)\n+        .forEach(oldUnits::add);\n+    // any unit that was unloaded during combat phase needs to be removed but it needs to be removed\n+    // from the territory it unloaded to\n+    killedUnits.stream()\n+        .map(Unit::getUnloaded)\n+        .flatMap(Collection::stream)\n+        .forEach(\n+            unloadedUnit -> {\n+              unloadedUnits\n+                  .computeIfAbsent(unloadedUnit.getUnloadedTo(), k -> new ArrayList<>())\n+                  .add(unloadedUnit);\n+              oldUnits.add(unloadedUnit);\n+            });\n+\n+    newUnits.addAll(transformUnits.getNewUnits());\n+\n+    this.killedUnits = new ArrayList<>(oldUnits);", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjMzMQ==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432331", "bodyText": "TransformUnits is possibly too generic of a name. Perhaps we can clarify this by getting the 'Damaged' word in there.\nSuggestions:\n\nDamagedUnitTransformation\nChangeDamagedUnitType", "author": "DanVanAtta", "createdAt": "2020-12-20T20:30:13Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformUnits.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@Value\n+public class TransformUnits implements HistoryChange {", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjM3NA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432374", "bodyText": "nit, this could use a quick leading comment to summarize what we are doing in this block, help make it easier to understand.\nThat could potentially be done by assigning the variable transformingUnits in this constructor, in which case the helper method would carry that information, eg:\ntransformingUnits = computeUnitTransformations(transformUnits);", "author": "DanVanAtta", "createdAt": "2020-12-20T20:30:46Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformUnits.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@Value\n+public class TransformUnits implements HistoryChange {\n+\n+  Territory location;\n+  /** Map of old unit -> new unit */\n+  Map<Unit, Unit> transformingUnits = new HashMap<>();\n+\n+  CompositeChange attributeChanges = new CompositeChange();\n+\n+  public TransformUnits(final Territory location, final Collection<Unit> transformUnits) {\n+    this.location = location;\n+\n+    for (final Unit unit : transformUnits) {", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjU5Nw==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432597", "bodyText": "It seems that transformUnits is conditional and not all the units passed in will be transformed. Named transformUnits,it sounds to me as if all the units would be transforming or already have transformed.\nIs this the list of damaged units? In that case, for consideration, damagedUnits could be a more descriptive name.", "author": "DanVanAtta", "createdAt": "2020-12-20T20:33:16Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformUnits.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@Value\n+public class TransformUnits implements HistoryChange {\n+\n+  Territory location;\n+  /** Map of old unit -> new unit */\n+  Map<Unit, Unit> transformingUnits = new HashMap<>();\n+\n+  CompositeChange attributeChanges = new CompositeChange();\n+\n+  public TransformUnits(final Territory location, final Collection<Unit> transformUnits) {", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjcxNA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432714", "bodyText": "There is a lot going on in this block. Would you mind taking a second look to see if you can make this easier to understand? Let me know if you'd like suggestions or thoughts on how to achieve that, I'll be happy to help.", "author": "DanVanAtta", "createdAt": "2020-12-20T20:34:09Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformUnits.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@Value\n+public class TransformUnits implements HistoryChange {\n+\n+  Territory location;\n+  /** Map of old unit -> new unit */\n+  Map<Unit, Unit> transformingUnits = new HashMap<>();\n+\n+  CompositeChange attributeChanges = new CompositeChange();\n+\n+  public TransformUnits(final Territory location, final Collection<Unit> transformUnits) {\n+    this.location = location;\n+\n+    for (final Unit unit : transformUnits) {\n+\n+      final Map<Integer, Tuple<Boolean, UnitType>> map =\n+          unit.getUnitAttachment().getWhenHitPointsDamagedChangesInto();\n+      if (map.containsKey(unit.getHits())) {\n+        final boolean translateAttributes = map.get(unit.getHits()).getFirst();\n+        final UnitType unitType = map.get(unit.getHits()).getSecond();\n+        final List<Unit> toAdd = unitType.create(1, unit.getOwner());\n+        if (translateAttributes) {\n+          attributeChanges.add(UnitUtils.translateAttributesToOtherUnits(unit, toAdd, location));\n+        }\n+        transformingUnits.put(unit, toAdd.get(0));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void perform(final IDelegateBridge bridge) {\n+    if (transformingUnits.isEmpty()) {\n+      return;\n+    }\n+\n+    bridge.addChange(\n+        new CompositeChange(\n+            ChangeFactory.addUnits(location, getNewUnits()),\n+            ChangeFactory.removeUnits(location, getOldUnits()),\n+            attributeChanges));\n+\n+    // to reduce the amount of history text, group the transforming units by both the original and\n+    // new unit type\n+    transformingUnits.entrySet().stream()", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjg2NA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546432864", "bodyText": "nit, unnecessary intermediate variable. Can be a single line\nnew KillUnits(battleSite, killed).perform(bridge);\n\nSide-note: I think the above does reveal a code smell where the bridge should be in control of when the change happens. EG:\nbridge.addChange(new KillUnits(battleSite, killed);", "author": "DanVanAtta", "createdAt": "2020-12-20T20:35:31Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/AirBattle.java", "diffHunk": "@@ -910,11 +911,9 @@ private void remove(\n       return;\n     }\n     final Collection<Unit> killed = getUnitsWithDependents(killedUnits);\n-    final Change killedChange = ChangeFactory.removeUnits(battleSite, killed);\n-    final String transcriptText =\n-        MyFormatter.unitsToText(killed) + \" lost in \" + battleSite.getName();\n-    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList<>(killed));\n-    bridge.addChange(killedChange);\n+    final KillUnits killUnits = new KillUnits(battleSite, killed);", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ0ODU3NQ==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546448575", "bodyText": "The plan is to return these history change objects to the caller so that they can then pass it to the bridge.  So, there is still a bit of code smell because this is a partial step.", "author": "trevan", "createdAt": "2020-12-20T22:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMjg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMzI0OA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546433248", "bodyText": "The formatting of the message pattern being a responsibility of the caller is concerning to me. This creates a coupling between the data and the formatting strings used internally by 'killUnits' and the caller. The caller must be aware of the string type. It does seem like the formatted string could become an implementation detail of KillUnits by adding a third constructor, eg:\nnew KillUnits(battleSite, killed, currentTypeAa)\nAt that point too I'd recommend to add a @Builder on that constructor so that the meaning of the parameters is more clear when reading the calling context.\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-12-20T20:38:25Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/StrategicBombingRaidBattle.java", "diffHunk": "@@ -663,18 +658,13 @@ private void removeAaHits(\n       final IDelegateBridge bridge, final CasualtyDetails casualties, final String currentTypeAa) {\n     final List<Unit> killed = casualties.getKilled();\n     if (!killed.isEmpty()) {\n-      bridge\n-          .getHistoryWriter()\n-          .addChildToEvent(\n-              MyFormatter.unitsToTextNoOwner(killed) + \" killed by \" + currentTypeAa,\n-              new ArrayList<>(killed));\n       final IntegerMap<UnitType> costs = TuvUtils.getCostsForTuv(attacker, gameData);\n       final int tuvLostAttacker = TuvUtils.getTuv(killed, attacker, costs, gameData);\n       attackerLostTuv += tuvLostAttacker;\n       // attackingUnits.removeAll(casualties);\n       removeAttackers(killed, false);\n-      final Change remove = ChangeFactory.removeUnits(battleSite, killed);\n-      bridge.addChange(remove);\n+      new KillUnits(battleSite, killed, \"${units} killed by \" + currentTypeAa + \" in ${territory}\")", "originalCommit": "87b7a9ebba72ade584e2b76ddf5d625184dd3cfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ0NjM2NA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546446364", "bodyText": "KillUnits has a constructor that is already Territory, Collection<Unit>, String so I can't add this third constructor.  I could remove the existing one but there might be another caller that will have a different string to be used and then I'll be back to the same problem.\nI like the idea of hiding the string as an implementation detail.  I guess I could create a child class of KillUnits that is KillAaCasualtyUnits (or something like that) and then it can have this special constructor.  Are you ok with that?", "author": "trevan", "createdAt": "2020-12-20T22:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMzI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ0NzA3Ng==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r546447076", "bodyText": "Multiple constructors with the same signature usually calls for a factory pattern. In that case just create static methods that create the new object and they can be different in their naming. Would that work?", "author": "DanVanAtta", "createdAt": "2020-12-20T22:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQzMzI0OA=="}], "type": "inlineReview"}, {"oid": "7e5d98854918d1d95af01b7bb78dc3cc6ed24aa0", "url": "https://github.com/triplea-game/triplea/commit/7e5d98854918d1d95af01b7bb78dc3cc6ed24aa0", "message": "Rename classes, add better comments, cleanup code\n\nAdded HistoryChangeFactory to create the history change objects.  This\nis similar to the ChangeFactory.", "committedDate": "2020-12-20T22:55:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA3MjQ2OQ==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r547072469", "bodyText": "A quick javadoc could perhaps be useful to explain what constitutes a history change.\nI wonder though, wouldn't almost any change be eligible for the history? Is there a (ideally) a 1:1 correspondence between history change objects and game state changes? Are we going to have \"peer\" change objects in this manner?", "author": "DanVanAtta", "createdAt": "2020-12-22T05:15:30Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/HistoryChange.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package games.strategy.engine.history.change;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+\n+public interface HistoryChange {", "originalCommit": "7e5d98854918d1d95af01b7bb78dc3cc6ed24aa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA4NTk2OA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r547085968", "bodyText": "When you say \"game state changes\", I'm assuming you are talking about the Change objects.\nThere will not be a 1:1 correspondence between history change objects and game state changes.  A history change object can comprise of 1 or more game state changes.  Take for example TransformDamagedUnits.  It creates at minimum an AddUnits and a RemoveUnits change object.  It also can create many more depending on if attribute translation is asked for and depending on which attributes need to be translated.\nI see the HistoryChange as more of a higher level object than the Change object.  It maps to what the user sees and to what is listed in the history.  The Change object is the low level changes that must be done to keep the game state in sync.\nOne possible benefit of the HistoryChange is that if it was stored in the game data history, then it would actually be possible to undo each history entry because the changes are truly grouped together per history entry.\nI do plan to add more HistoryChange objects.", "author": "trevan", "createdAt": "2020-12-22T06:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA3MjQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEyMDcwMg==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r547120702", "bodyText": "Since they are related, I wonder if instead there is a way to map the history changes from game state changes. Otherwise it seems we are duplicating information about changes to the game state via another change object mechanism.", "author": "DanVanAtta", "createdAt": "2020-12-22T07:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA3MjQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM4NzI2Mg==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r547387262", "bodyText": "I wouldn't say this is \"duplicating information\".  I'd say this is grouping information and actually mapping history changes with their underlying game state changes.  Because a history change (and I'm not talking about the history change objects in this PR) might incorporate multiple game state changes.", "author": "trevan", "createdAt": "2020-12-22T16:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA3MjQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM5Mzc3Nw==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r547393777", "bodyText": "A relationship of many:1 for game state to history changes is interesting. I wonder if that relationship could also be viewed as [0|1] : 1\nThe reason I am focusing on this is to see if we can simplify how the history is rendered and displayed relative to game state. If we have both a stack of history objects, and a stack of game state objects, how do we easily \"point\" the game state to an arbitrary location in that game state stack and easily then recreate the history? Or from another point of view, what if the current game is \"pointed\" to an arbitrary location in history, how do we easily then unwind the game state to that location?\nIf there is a link (likely bidirectional)  between history objects and state changes, this I think becomes much easier. If such a link is bidirectional, is it potentially actually part of the same data entity? Would it make sense to even just have an API on game state changes like Optional<HistoryChange> getHistoryElement", "author": "DanVanAtta", "createdAt": "2020-12-22T17:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA3MjQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQwNjE1MA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r547406150", "bodyText": "As I mentioned, if HistoryChange was stored in the history, then it could keep track of all of the Changes that occur during that history.  And then if you revert a HistoryChange (which this PR doesn't include), it would revert all of the Change objects that were part of the history event.\nThe current mechanism that tracks history items with change objects is done in games.strategy.engine.history.History.  I believe how that works is that at some point in the game flow, a call to HistoryWriter.startEvent will be called.  This adds a new node to History.  When bridge.addChanges is called, the changes are stored in a big list inside of History.  The nodes created by startEvent store the index in the changes list when they are added.  When you traverse the history, it looks up the index of the history node, computes a delta of changes from the big list of changes and then undoes those changes.\nThat logic feels really convoluted.  I'm not entirely sure I understand it completely.  These HistoryChanges, though, could simplify that.  Instead of storing indices into a list of changes and assigning them to each node, the history node would actually store the list of changes that it performed.  And each change object would be attached to a history node, where as now, it looks like you can have change objects that aren't attached to history nodes.", "author": "trevan", "createdAt": "2020-12-22T17:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA3MjQ2OQ=="}], "type": "inlineReview"}, {"oid": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659", "url": "https://github.com/triplea-game/triplea/commit/62b6c468a031c43dba57d58a9f6a52ad1b0c1659", "message": "Add an invert method to HistoryChange", "committedDate": "2020-12-22T23:04:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NzU1MA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r548797550", "bodyText": "What other history change objects do you foresee? How many might we have total and will a single factory for them all scale well?", "author": "DanVanAtta", "createdAt": "2020-12-25T04:26:22Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/HistoryChangeFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package games.strategy.engine.history.change;\n+\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.history.change.units.RemoveUnits;\n+import games.strategy.engine.history.change.units.TransformDamagedUnits;\n+import java.util.Collection;\n+import lombok.experimental.UtilityClass;\n+\n+@UtilityClass\n+public class HistoryChangeFactory {", "originalCommit": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTAyMTE1Nw==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r549021157", "bodyText": "I patterned this off of the existing ChangeFactory.  I could imagine one history change class per type of line in the history.", "author": "trevan", "createdAt": "2020-12-26T19:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NzU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA0NDYzMg==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r549044632", "bodyText": "Okay. If it grows to be overwhelming we can probably deal with it.", "author": "DanVanAtta", "createdAt": "2020-12-27T00:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NzU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5Nzg2Mw==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r548797863", "bodyText": "side-note, we're trying to kill Tuple and replace it with value objects. For example TotalPowerAndRolls used to be a Tuple<Integer,Integer>,that conversion certainly lead to more legible code. In this case, the Boolean is very cryptic, it's kinda hard to know what the represents at first glance.", "author": "DanVanAtta", "createdAt": "2020-12-25T04:28:38Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/TransformDamagedUnits.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.UnitUtils;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.AccessLevel;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Value;\n+import lombok.experimental.FieldDefaults;\n+import org.triplea.util.Tuple;\n+\n+/**\n+ * Transforms units into other unit types as determined by {@link\n+ * UnitAttachment#getWhenHitPointsDamagedChangesInto()}\n+ */\n+@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n+@Getter\n+@EqualsAndHashCode\n+public class TransformDamagedUnits implements HistoryChange {\n+\n+  CompositeChange change = new CompositeChange();\n+  Territory location;\n+  /** Map of old unit -> new unit */\n+  Map<Unit, Unit> transformingUnits = new HashMap<>();\n+\n+  CompositeChange attributeChanges = new CompositeChange();\n+\n+  public TransformDamagedUnits(final Territory location, final Collection<Unit> damagedUnits) {\n+    this.location = location;\n+\n+    // check if each of the damaged units are supposed to change when they take damage\n+    // if it is supposed to change, create the new unit and translate attributes from the old unit\n+    // to the new unit\n+    for (final Unit unit : damagedUnits) {\n+      final Map<Integer, Tuple<Boolean, UnitType>> map =", "originalCommit": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5ODE1Mg==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r548798152", "bodyText": "I do wonder if these objects should be suffixed with HistoryChange so that they are not quite so context dependent. WDYT @trevan ?", "author": "DanVanAtta", "createdAt": "2020-12-25T04:31:03Z", "path": "game-core/src/main/java/games/strategy/engine/history/change/units/RemoveUnits.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package games.strategy.engine.history.change.units;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.history.change.HistoryChange;\n+import games.strategy.triplea.formatter.MyFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.experimental.FieldDefaults;\n+import org.apache.commons.text.StringSubstitutor;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Removes a set of units in a location and adds a history event\n+ *\n+ * <p>Transforms units to other units if needed. See {@link TransformDamagedUnits}\n+ */\n+@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n+@Getter\n+@EqualsAndHashCode\n+public class RemoveUnits implements HistoryChange {", "originalCommit": "62b6c468a031c43dba57d58a9f6a52ad1b0c1659", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTAyMTI4NA==", "url": "https://github.com/triplea-game/triplea/pull/8438#discussion_r549021284", "bodyText": "Sounds good.  I've renamed them @DanVanAtta", "author": "trevan", "createdAt": "2020-12-26T19:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5ODE1Mg=="}], "type": "inlineReview"}, {"oid": "d7834a450aed8a873f66f3cc44d8e1c3af3f002a", "url": "https://github.com/triplea-game/triplea/commit/d7834a450aed8a873f66f3cc44d8e1c3af3f002a", "message": "Add HistoryChange suffix to classes", "committedDate": "2020-12-26T19:03:17Z", "type": "commit"}]}