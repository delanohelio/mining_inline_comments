{"pr_number": 6330, "pr_title": "Store lobby chat messages in database", "pr_createdAt": "2020-04-25T22:01:11Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6330", "timeline": [{"oid": "5dfe9f4ff0f38a7cd3ae4b5f770362e87c8a3f16", "url": "https://github.com/triplea-game/triplea/commit/5dfe9f4ff0f38a7cd3ae4b5f770362e87c8a3f16", "message": "Store lobby chat messages in database\n\n- Adds a table to store lobby chat messages\n- Adds a DAO to execute insert statements\n- Updates http-server chat message listener to store\n  messages via DAO.\n\nNotes:\n- Most of the updates here involve wiring API-Key ID\n  to API-key lookup so that we can then store the API-Key\n  ID in database. When chatters join, we look up their\n  API key, to be able to later store their API-Key ID,\n  we attach the API-Key ID to their chatter session where\n  later it is available when we store chat messages.\n- We use a background threadpool to store chat messages\n  to avoid any kind of extra latency when issuing a chat\n  message response.", "committedDate": "2020-04-25T21:58:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1MzY1Nw==", "url": "https://github.com/triplea-game/triplea/pull/6330#discussion_r415153657", "bodyText": "Method givenResults has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T22:03:18Z", "path": "http-server/src/test/java/org/triplea/db/dao/api/key/ApiKeyLookupRecordTest.java", "diffHunk": "@@ -22,36 +22,44 @@\n class ApiKeyLookupRecordTest {\n   private static final String ROLE = UserRole.PLAYER;\n   private static final int USER_ID = 55;\n+  private static final int API_KEY_ID = 99;\n+\n   private static final String NAME = \"player-name\";\n   private static final String CHAT_ID = \"chat-id\";\n \n   @Mock private ResultSet resultSet;\n \n   @Test\n   void buildResultMapper() throws Exception {\n-    givenResults(USER_ID, CHAT_ID, ROLE, NAME);\n+    givenResults(USER_ID, API_KEY_ID, CHAT_ID, ROLE, NAME);\n \n     final ApiKeyLookupRecord result = ApiKeyLookupRecord.buildResultMapper().map(resultSet, null);\n \n     assertThat(result.getUserId(), is(USER_ID));\n+    assertThat(result.getApiKeyId(), is(API_KEY_ID));\n     assertThat(result.getRole(), is(UserRole.PLAYER));\n     assertThat(result.getUsername(), is(NAME));\n     assertThat(result.getPlayerChatId(), is(CHAT_ID));\n   }\n \n   @SuppressWarnings(\"SameParameterValue\")\n   private void givenResults(\n-      final int userId, final String chatId, final String role, final String name)\n+      final int userId,", "originalCommit": "5dfe9f4ff0f38a7cd3ae4b5f770362e87c8a3f16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NzgxMg==", "url": "https://github.com/triplea-game/triplea/pull/6330#discussion_r415177812", "bodyText": "This is probably one of the best additions to our backend code.\nThis way to write SQL is so clean \ud83d\udc4d", "author": "RoiEXLab", "createdAt": "2020-04-26T00:40:20Z", "path": "http-server/src/main/java/org/triplea/db/dao/chat/history/LobbyChatHistoryDao.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.triplea.db.dao.chat.history;\n+\n+import com.google.common.base.Ascii;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+import org.triplea.http.client.web.socket.messages.envelopes.chat.ChatReceivedMessage;\n+\n+/** Lobby chat history records lobby chat messages. */\n+public interface LobbyChatHistoryDao {\n+  int MESSAGE_COLUMN_LENGTH = 240;\n+\n+  default void recordMessage(ChatReceivedMessage chatReceivedMessage, int apiKeyId) {\n+    insertMessage(\n+        chatReceivedMessage.getSender().getValue(),\n+        apiKeyId,\n+        Ascii.truncate(chatReceivedMessage.getMessage(), MESSAGE_COLUMN_LENGTH, \"\"));\n+  }\n+\n+  /**\n+   * Stores a chat message record to database.\n+   *\n+   * @param username The name of the user that sent the chat message.\n+   * @param apiKeyId The ID of the API key the user used to sign in to the lobby. This is useful for\n+   *     cross-referencing to know the users IP and system-id.\n+   * @param message The chat message contents.\n+   */\n+  @SqlUpdate(\n+      \"insert into lobby_chat_history (username, lobby_api_key_id, message) \"\n+          + \"values(:username, :apiKeyId, :message)\")\n+  void insertMessage(\n+      @Bind(\"username\") String username,\n+      @Bind(\"apiKeyId\") int apiKeyId,\n+      @Bind(\"message\") String message);", "originalCommit": "5dfe9f4ff0f38a7cd3ae4b5f770362e87c8a3f16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3ODQ1Nw==", "url": "https://github.com/triplea-game/triplea/pull/6330#discussion_r415178457", "bodyText": "Not really important, but in most test cases we statically import Mockito#when", "author": "RoiEXLab", "createdAt": "2020-04-26T00:44:40Z", "path": "http-server/src/test/java/org/triplea/modules/chat/ChatMessagingServiceTest.java", "diffHunk": "@@ -4,22 +4,29 @@\n import static org.mockito.Mockito.atLeastOnce;\n import static org.mockito.Mockito.verify;\n \n+import org.jdbi.v3.core.Jdbi;\n import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.mockito.Mock;\n+import org.mockito.Mockito;\n import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.db.dao.chat.history.LobbyChatHistoryDao;\n import org.triplea.web.socket.WebSocketMessagingBus;\n \n @ExtendWith(MockitoExtension.class)\n class ChatMessagingServiceTest {\n   @Mock private Chatters chatters;\n+  @Mock private Jdbi jdbi;\n+  @Mock private LobbyChatHistoryDao lobbyChatHistoryDao;\n   @Mock private WebSocketMessagingBus webSocketMessagingBus;\n \n   @Test\n   @DisplayName(\"Verify that we add listeners to messaging bus when configure is called\")\n   void configureAddsListeners() {\n-    ChatMessagingService.build(chatters).configure(webSocketMessagingBus);\n+    Mockito.when(jdbi.onDemand(LobbyChatHistoryDao.class)).thenReturn(lobbyChatHistoryDao);", "originalCommit": "5dfe9f4ff0f38a7cd3ae4b5f770362e87c8a3f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4OTEyMQ==", "url": "https://github.com/triplea-game/triplea/pull/6330#discussion_r415189121", "bodyText": "I try to replace them with the static import, missed this one. Updated: 5b801bf\nI'll see to adding this to our custom convention checks.", "author": "DanVanAtta", "createdAt": "2020-04-26T01:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3ODQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3OTAyNQ==", "url": "https://github.com/triplea-game/triplea/pull/6330#discussion_r415179025", "bodyText": "Is there a specific reason to use this threadpool rather than the default one provided by the single argument overload of this method?", "author": "RoiEXLab", "createdAt": "2020-04-26T00:48:19Z", "path": "http-server/src/main/java/org/triplea/modules/chat/event/processing/ChatMessageListener.java", "diffHunk": "@@ -1,30 +1,65 @@\n package org.triplea.modules.chat.event.processing;\n \n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.function.Consumer;\n-import lombok.AllArgsConstructor;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jdbi.v3.core.Jdbi;\n+import org.triplea.db.dao.chat.history.LobbyChatHistoryDao;\n import org.triplea.domain.data.ChatParticipant;\n import org.triplea.http.client.web.socket.messages.envelopes.chat.ChatReceivedMessage;\n import org.triplea.http.client.web.socket.messages.envelopes.chat.ChatSentMessage;\n import org.triplea.modules.chat.Chatters;\n+import org.triplea.modules.chat.Chatters.ChatterSession;\n import org.triplea.web.socket.WebSocketMessageContext;\n \n-@AllArgsConstructor\n+@Builder\n+@Slf4j\n public class ChatMessageListener implements Consumer<WebSocketMessageContext<ChatSentMessage>> {\n \n-  private final Chatters chatters;\n+  @Nonnull private final Chatters chatters;\n+  @Nonnull private final LobbyChatHistoryDao lobbyChatHistoryDao;\n+  private final ExecutorService threadpool = Executors.newCachedThreadPool();\n+\n+  public static ChatMessageListener build(final Chatters chatters, final Jdbi jdbi) {\n+    return ChatMessageListener.builder()\n+        .chatters(chatters)\n+        .lobbyChatHistoryDao(jdbi.onDemand(LobbyChatHistoryDao.class))\n+        .build();\n+  }\n \n   @Override\n   public void accept(final WebSocketMessageContext<ChatSentMessage> messageContext) {\n     chatters\n         .lookupPlayerBySession(messageContext.getSenderSession())\n-        .ifPresent(sender -> broadcastChatMessage(messageContext, sender));\n+        .ifPresent(session -> recordAndSendMessage(session, messageContext));\n   }\n \n-  private static void broadcastChatMessage(\n-      final WebSocketMessageContext<ChatSentMessage> messageContext, final ChatParticipant sender) {\n+  private void recordAndSendMessage(\n+      final ChatterSession session, final WebSocketMessageContext<ChatSentMessage> messageContext) {\n+    final var chatReceivedMessage =\n+        convertMessage(session.getChatParticipant(), messageContext.getMessage().getChatMessage());\n+    recordInHistory(chatReceivedMessage, session);\n+    messageContext.broadcastMessage(chatReceivedMessage);\n+  }\n+\n+  private static ChatReceivedMessage convertMessage(\n+      final ChatParticipant sender, final String message) {\n+    return new ChatReceivedMessage(sender.getUserName(), message);\n+  }\n \n-    messageContext.broadcastMessage(\n-        new ChatReceivedMessage(\n-            sender.getUserName(), messageContext.getMessage().getChatMessage()));\n+  private void recordInHistory(\n+      final ChatReceivedMessage chatReceivedMessage, final ChatterSession session) {\n+    CompletableFuture.runAsync(\n+            () -> lobbyChatHistoryDao.recordMessage(chatReceivedMessage, session.getApiKeyId()),\n+            threadpool)", "originalCommit": "5dfe9f4ff0f38a7cd3ae4b5f770362e87c8a3f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4OTMxNg==", "url": "https://github.com/triplea-game/triplea/pull/6330#discussion_r415189316", "bodyText": "Interesting, I was not aware that there was a default threadpool used. It is good to know.\nI updated this and removed the threadpool in: be2450b", "author": "DanVanAtta", "createdAt": "2020-04-26T01:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3OTAyNQ=="}], "type": "inlineReview"}, {"oid": "5b801bf1639181521d6b11d9b3c589a92b276873", "url": "https://github.com/triplea-game/triplea/commit/5b801bf1639181521d6b11d9b3c589a92b276873", "message": "Use a static import for Mockito.when", "committedDate": "2020-04-26T01:56:45Z", "type": "commit"}, {"oid": "be2450b426e676f2e8740f9cdf8fe402c3614b57", "url": "https://github.com/triplea-game/triplea/commit/be2450b426e676f2e8740f9cdf8fe402c3614b57", "message": "Remove explicit threadpool in favor of default", "committedDate": "2020-04-26T01:57:47Z", "type": "commit"}]}