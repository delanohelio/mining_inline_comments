{"pr_number": 6696, "pr_title": "Replace BattleStep#valid with BattleStep#getOrder", "pr_createdAt": "2020-06-15T05:49:10Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6696", "timeline": [{"oid": "867e26e6429b1fa64a16acd3eedf94e324dd87a8", "url": "https://github.com/triplea-game/triplea/commit/867e26e6429b1fa64a16acd3eedf94e324dd87a8", "message": "Replace BattleStep#valid with BattleStep#getOrder", "committedDate": "2020-06-15T05:36:34Z", "type": "commit"}, {"oid": "f524e9819a292c6c3bfde535c7f4d90bb94088ca", "url": "https://github.com/triplea-game/triplea/commit/f524e9819a292c6c3bfde535c7f4d90bb94088ca", "message": "Rename SKIP to NOT_APPLICABLE", "committedDate": "2020-06-16T17:48:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441211572", "bodyText": "I think there might be something of a feature envy code smell here. Notably we query an object for its state, then depending on that state we query the same object again for more state. The feature envy is on BattleSteps with respect to the state of offensiveAaStep. In practical sense this indicates a lack of data encapsulation.\nThis could potentially be fixed by moving the getOrder() concern to offensiveAaStep. In such a case there would be no conditional in BattleSteps. In other words, offensiveAaStep would evaluate its own order, if not applicable it would return an empty getNames() list, otherwise it would return some values.\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-06-17T00:19:39Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -71,9 +71,12 @@\n     final BattleStep airDefendVsNonSubs = new AirDefendVsNonSubsStep(this);\n \n     final List<String> steps = new ArrayList<>();\n-    steps.addAll(offensiveAaStep.getNames());\n-\n-    steps.addAll(defensiveAaStep.getNames());\n+    if (offensiveAaStep.getOrder() != BattleStep.Order.NOT_APPLICABLE) {\n+      steps.addAll(offensiveAaStep.getNames());", "originalCommit": "f524e9819a292c6c3bfde535c7f4d90bb94088ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxODc2NA==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441218764", "bodyText": "I agree with the code smell but that is because this is an intermediate state.  There are steps that will return different values for getOrder depending on their situation.  Once all of the steps are converted, I can grab the list of steps with code like:\nList<BattleStep> steps = new ArrayList<>();\nsteps.add(new OffensiveAaFire(this, battleActions));\nsteps.add(new DefensiveAaFire(this, battleActions));\nsteps.add(new ...);\nsteps.add(new ...);\n\nList<String> stepNames = steps.stream()\n        .filter(step -> step.getOrder() != BattleStep.Order.NOT_APPLICABLE)\n        .sorted(Comparator.comparing(BattleStep::getOrder))\n        .flatMap(step -> step.getNames().stream())\n        .collect(Collectors.toList());\n\nAnother idea, is that instead of allowing a step to have different positions in the battle order, I could just create duplicate steps.  They could inherit from the same parent class where all the main logic is and then override a method that determines whether getName or executable should be run.\nThen the code to get the steps would look more like:\nList<BattleStep> steps = new ArrayList<>();\nsteps.add(New OffensiveAaFire(this, battleActions));\nsteps.add(new SubRetreatBeforeBattle(this, battleActions));\nsteps.add(...<some other step>);\nsteps.add(new SubRetreatAfterBattle(this, battleActions));\nsteps.add(...<other steps>);\n\nList<String> stepNames = steps.stream()\n        .flatMap(step -> step.getNames().stream())\n        .collect(Collectors.toList());\n\nIn that case, both SubRetreatBeforeBattle and SubRetreatAfterBattle would extend SubRetreat but the first class would check for getSubRetreatBeforeBattle() == true while the second class would check if getSubRetreatBeforeBattle() == false.\nWhat would you prefer?  More classes or less classes?  Or maybe you have another idea on how to handle steps that don't have a static position in the order but can change depending on the state at the beginning of the round.", "author": "trevan", "createdAt": "2020-06-17T00:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODY1Nw==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441898657", "bodyText": "@trevan\nI was thinking this:\n\nList<String> stepNames = steps.stream()\n        .sorted(Comparator.comparing(BattleStep::getOrder))\n        .flatMap(step -> step.getNames().stream())\n        .collect(Collectors.toList());\n\nIf you make BattleStep implement Comparable, perhaps could get even go simpler:\npublic interface BattleStep extends IExecutable, Comparable<BattleStep> {\n :\n :\n  @Override\n  default int compareTo(BattleStep rhs) {\n    return Integer.compare(getOrder().ordinal(), rhs.getOrder().ordinal());\n  }\n\nList<String> stepNames = steps.stream()\n        .sorted()\n        .flatMap(step -> step.getNames().stream())\n        .collect(Collectors.toList());", "author": "DanVanAtta", "createdAt": "2020-06-18T00:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNzIxMA==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441907210", "bodyText": "@DanVanAtta so no pre filtering?  I'll try that out.  The existing code does do pre-filtering on the IExecutables that are added and I was trying to allow that with the NOT_APPLICABLE order but that might just be a relic.", "author": "trevan", "createdAt": "2020-06-18T00:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwODM3NQ==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441908375", "bodyText": "Basically the filtering would be internalized to each BattleStep. Each one would be responsible to know if it applies and if so generating any necessary step names.", "author": "DanVanAtta", "createdAt": "2020-06-18T00:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMTY1Nw==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441921657", "bodyText": "@DanVanAtta , I'm not just talking about step names but the executable part as well.  I'm worried about the lines such as:\n\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1105\n      in\n      f524e98\n    \n    \n    \n    \n\n        \n          \n           if (offensiveAaStep.getOrder() != BattleStep.Order.NOT_APPLICABLE) { \n        \n    \n  \n\n\n\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1118\n      in\n      f524e98\n    \n    \n    \n    \n\n        \n          \n           if (defensiveAaStep.getOrder() != BattleStep.Order.NOT_APPLICABLE) { \n        \n    \n  \n\n\n\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1131\n      in\n      f524e98\n    \n    \n    \n    \n\n        \n          \n           if (offensiveAa || defendingAa) { \n        \n    \n  \n\n\n\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1475\n      in\n      f524e98\n    \n    \n    \n    \n\n        \n          \n           if (Properties.getTransportCasualtiesRestricted(gameData)) { \n        \n    \n  \n\n\nI'm not entirely sure why the check for those steps is outside of the executable.  A check outside of the executable happens at the start of the round while the checks inside of the executable happen when the step actually happens.  So the checks are being done on different data.  Most of the executables have all their checks inside of them or the checks outside of them are just determining the order of the step.\nIt might be that I can move all of those checks inside of the executable so that they run when the step occurrs but I'm not positive at this moment in time and so the getOrder() != NOT_APPLICABLE was mainly for those steps.  I guess I can remove the NOT_APPLICABLE order and when I get to converting those steps, figure out if I need NOT_APPLICABLE or not.", "author": "trevan", "createdAt": "2020-06-18T01:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyMjAzNg==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441922036", "bodyText": "Oh, in addition, by not adding the step to the stack, they don't get saved in saved games.  That is another thing that I have to look into when I convert them.  By not having the getOrder() != NOT_APPLICABLE check, all of the steps will be added to the saved game, including ones that were previously not added.", "author": "trevan", "createdAt": "2020-06-18T01:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyOTk1NA==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441929954", "bodyText": "@DanVanAtta I've made the change.  I've also tested a scenario that would originally have had just offensive AA steps in the save and no defensive AA steps in the save.  I created a save with master and with this branch and then loaded both saves in this branch.  It loaded fine and it looks like it played out the rest of the round without issues.", "author": "trevan", "createdAt": "2020-06-18T02:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk3MjI5MQ==", "url": "https://github.com/triplea-game/triplea/pull/6696#discussion_r441972291", "bodyText": "Interesting context, thank you. Sounds as though we should err on the side of caution.", "author": "DanVanAtta", "createdAt": "2020-06-18T05:13:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTU3Mg=="}], "type": "inlineReview"}, {"oid": "2e5380d49069b83936499d8fa1943113c0718787", "url": "https://github.com/triplea-game/triplea/commit/2e5380d49069b83936499d8fa1943113c0718787", "message": "Remove NOT_APPLICABLE order enum and do all validation internally", "committedDate": "2020-06-18T01:55:58Z", "type": "commit"}, {"oid": "6dd9e0c574bcc0821c4565673ebc3cc2cdbe7f66", "url": "https://github.com/triplea-game/triplea/commit/6dd9e0c574bcc0821c4565673ebc3cc2cdbe7f66", "message": "Fix some test names to match what it originally was", "committedDate": "2020-06-18T02:17:26Z", "type": "commit"}, {"oid": "c287c16e696a40775be5115a60bcedf2c51902f0", "url": "https://github.com/triplea-game/triplea/commit/c287c16e696a40775be5115a60bcedf2c51902f0", "message": "Fix tests now that aa steps are always added", "committedDate": "2020-06-18T02:49:52Z", "type": "commit"}, {"oid": "9a67048b28d98789cc4a0163863e152863186e3c", "url": "https://github.com/triplea-game/triplea/commit/9a67048b28d98789cc4a0163863e152863186e3c", "message": "Auto-Formatting", "committedDate": "2020-06-18T02:52:13Z", "type": "commit"}]}