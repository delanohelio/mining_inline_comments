{"pr_number": 7859, "pr_title": "Add unittests for TotalPowerAndTotalRolls", "pr_createdAt": "2020-10-08T04:49:01Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7859", "timeline": [{"oid": "4ede1a9583b0b5d1b3976b5dd9310c1d10ab9eb6", "url": "https://github.com/triplea-game/triplea/commit/4ede1a9583b0b5d1b3976b5dd9310c1d10ab9eb6", "message": "Add unittests for TotalPowerAndTotalRolls", "committedDate": "2020-10-08T04:48:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0ODMzMQ==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501448331", "bodyText": "I think maintainers will wonder - why is this value expected to be 5?\nWDYT of spelling this out as a comment or in the assertion text? That would look something like this:\n assertThat(\n   \"Expecting total power of 5 given unit1 with 1 offense power * 2 rolls, plus unit2 with 1 offense power * 3 rolls\",\n\nOr perhaps something like:\nassertThat(\n   \"Power 1 * 2 rolls + power 1 * 3 rolls => 5 attacks\"\n\nIf the power was increased by one, would we expect the number of attacks to increase? I think I may have just realized that it's only the roll count that matters. Is that the case? I believe these questions should have pretty obvious answers from the tests along, or else it's a sign that the tests are not self-describing and a person would have to reverse engineer the code under a test (which becomes a problem when the test fails!)", "author": "DanVanAtta", "createdAt": "2020-10-08T04:57:43Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRollsTest.java", "diffHunk": "@@ -92,62 +782,2542 @@ void testDefending() {\n     }\n   }\n \n-  @Test\n-  void testGetTotalPowerForSupportBonusTypeCount() {\n-    final GameData twwGameData = TestMapGameData.TWW.getGameData();\n-\n-    // Move regular units\n-    final GamePlayer germans = GameDataTestUtil.germany(twwGameData);\n-    final Territory berlin = territory(\"Berlin\", twwGameData);\n-    final List<Unit> attackers = new ArrayList<>();\n-\n-    attackers.addAll(GameDataTestUtil.germanInfantry(twwGameData).create(1, germans));\n-    attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n-    int attackPower =\n-        TotalPowerAndTotalRolls.getTotalPower(\n-            TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n-                attackers,\n-                new ArrayList<>(),\n-                attackers,\n-                false,\n-                twwGameData,\n-                berlin,\n-                new ArrayList<>()),\n-            twwGameData);\n-    assertEquals(attackPower, 6, \"1 artillery should provide +1 support to the infantry\");\n-\n-    attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n-    attackPower =\n-        TotalPowerAndTotalRolls.getTotalPower(\n-            TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n-                attackers,\n-                new ArrayList<>(),\n-                attackers,\n-                false,\n-                twwGameData,\n-                berlin,\n-                new ArrayList<>()),\n-            twwGameData);\n-    assertEquals(\n-        attackPower,\n-        10,\n-        \"2 artillery should provide +2 support to the infantry as stack count is 2\");\n-\n-    attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n-    attackPower =\n-        TotalPowerAndTotalRolls.getTotalPower(\n-            TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n-                attackers,\n-                new ArrayList<>(),\n-                attackers,\n-                false,\n-                twwGameData,\n-                berlin,\n-                new ArrayList<>()),\n-            twwGameData);\n-    assertEquals(\n-        attackPower,\n-        13,\n-        \"3 artillery should provide +2 support to the infantry as can't provide more than 2\");\n+  @Nested\n+  class GetMaxAaAttackAndDiceSides {\n+\n+    @Test\n+    void singleUnitWithNoCustomDiceAndNoPowerRollsMap()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 2, 1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(List.of(unit), gameData, false);\n+\n+      assertThat(maxAttackAndDice, is(Tuple.of(2, 6)));\n+    }\n+\n+    @Test\n+    void singleDefensiveUnitWithNoCustomDiceAndNoPowerRollsMap()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, DEFENSE, 2, 1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(List.of(unit), gameData, true);\n+\n+      assertThat(maxAttackAndDice, is(Tuple.of(2, 6)));\n+    }\n+\n+    @Test\n+    void singleUnitWithCustomDiceAndNoPowerRollsMap() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 2, 1);\n+      final UnitAttachment unitAttachment =\n+          (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+      unitAttachment.getPropertyOrThrow(OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES).setValue(8);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(List.of(unit), gameData, false);\n+\n+      assertThat(\"Dice comes from the unitAttachment\", maxAttackAndDice, is(Tuple.of(2, 8)));\n+    }\n+\n+    @Test\n+    void singleDefensiveUnitWithCustomDiceAndNoPowerRollsMap()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, DEFENSE, 2, 1);\n+      final UnitAttachment unitAttachment =\n+          (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+      unitAttachment.getPropertyOrThrow(ATTACK_AA_MAX_DIE_SIDES).setValue(8);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(List.of(unit), gameData, true);\n+\n+      assertThat(\"Dice comes from the unitAttachment\", maxAttackAndDice, is(Tuple.of(2, 8)));\n+    }\n+\n+    @Test\n+    void singleUnitWithPowerRollsMap() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 2, 1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit),\n+              gameData,\n+              false,\n+              Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(2).build()));\n+\n+      assertThat(\n+          \"Value from totalPowerAndTotalRolls is used\", maxAttackAndDice, is(Tuple.of(3, 6)));\n+    }\n+\n+    @Test\n+    void singleDefensiveUnitWithPowerRollsMap() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, DEFENSE, 2, 1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit),\n+              gameData,\n+              true,\n+              Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(2).build()));\n+\n+      assertThat(\n+          \"Value from totalPowerAndTotalRolls is used\", maxAttackAndDice, is(Tuple.of(3, 6)));\n+    }\n+\n+    @Test\n+    void limitAttackToDiceSides() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 2, 1);\n+      final UnitAttachment unitAttachment =\n+          (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+      unitAttachment.getPropertyOrThrow(OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES).setValue(4);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit),\n+              gameData,\n+              false,\n+              Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(6).totalRolls(2).build()));\n+\n+      assertThat(\n+          \"UnitAttachment dice sides is the max allowed\", maxAttackAndDice, is(Tuple.of(4, 4)));\n+    }\n+\n+    @Test\n+    void multipleUnitsWithSameDice() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 2, 1);\n+      final Unit unit2 = givenUnit(\"test2\", BattleType.AA, gameData, OFFENSE, 3, 1);\n+      final Unit unit3 = givenUnit(\"test3\", BattleType.AA, gameData, OFFENSE, 4, 1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit, unit2, unit3), gameData, false);\n+\n+      assertThat(\n+          \"UnitAttachment dice sides is the max allowed\", maxAttackAndDice, is(Tuple.of(4, 6)));\n+    }\n+\n+    @Test\n+    void multipleUnitsWithDifferentDice() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 2, 1);\n+      unit.getType()\n+          .getAttachment(UNIT_ATTACHMENT_NAME)\n+          .getPropertyOrThrow(OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES)\n+          .setValue(6);\n+      final Unit unit2 = givenUnit(\"test2\", BattleType.AA, gameData, OFFENSE, 3, 1);\n+      unit2\n+          .getType()\n+          .getAttachment(UNIT_ATTACHMENT_NAME)\n+          .getPropertyOrThrow(OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES)\n+          .setValue(5);\n+      final Unit unit3 = givenUnit(\"test3\", BattleType.AA, gameData, OFFENSE, 4, 1);\n+      unit3\n+          .getType()\n+          .getAttachment(UNIT_ATTACHMENT_NAME)\n+          .getPropertyOrThrow(OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES)\n+          .setValue(4);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit, unit2, unit3), gameData, false);\n+\n+      assertThat(\"4 of 4 is better than 2 of 6 and 3 of 5\", maxAttackAndDice, is(Tuple.of(4, 4)));\n+    }\n+\n+    @Test\n+    void multipleUnitsWithDifferentDice2() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 3, 1);\n+      unit.getType()\n+          .getAttachment(UNIT_ATTACHMENT_NAME)\n+          .getPropertyOrThrow(OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES)\n+          .setValue(8);\n+      final Unit unit2 = givenUnit(\"test2\", BattleType.AA, gameData, OFFENSE, 3, 1);\n+      unit2\n+          .getType()\n+          .getAttachment(UNIT_ATTACHMENT_NAME)\n+          .getPropertyOrThrow(OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES)\n+          .setValue(7);\n+      final Unit unit3 = givenUnit(\"test3\", BattleType.AA, gameData, OFFENSE, 3, 1);\n+      unit3\n+          .getType()\n+          .getAttachment(UNIT_ATTACHMENT_NAME)\n+          .getPropertyOrThrow(OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES)\n+          .setValue(6);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit, unit2, unit3), gameData, false);\n+\n+      assertThat(\"3 of 6 is better than 3 of 7 and 3 of 8\", maxAttackAndDice, is(Tuple.of(3, 6)));\n+    }\n+  }\n+\n+  @Nested\n+  class GetAaUnitPowerAndRollsForNormalBattles {\n+\n+    @Test\n+    void attackUnitWithNoSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 1, 1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void defenseUnitWithNoSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, DEFENSE, 1, 1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void unitWithZeroRollsAlwaysGetsZeroPower() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 1, 0);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void unitWithZeroPowerAlwaysGetsZeroRolls() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 0, 1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneStrengthSupportFromFriendly()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 1, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneRollSupportFromFriendly() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 1, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAroll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(2).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneStrengthSupportFromEnemy() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 1, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength\", -1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, SupportCalculationResult.EMPTY_RESULT, false, gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneRollSupportFromEnemy() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 1, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAroll\", -1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, SupportCalculationResult.EMPTY_RESULT, false, gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneSupportForBothRollAndStrength()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 1, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength:AAroll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build()));\n+    }\n+\n+    @Test\n+    void twoAttackUnitsWithOnlyOneSupportAvailable() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.AA, OFFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.AA, OFFENSE, 1, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength:AAroll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          \"The non supported unit should not get any bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+    }\n+\n+    @Test\n+    void threeAttackUnitsWithOneSupportAvailableThatAffectsTwo()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.AA, OFFENSE, 1, 1);\n+      final Unit otherSupportedUnit = givenUnit(unitType, BattleType.AA, OFFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.AA, OFFENSE, 1, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength:AAroll\", 1, 2);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 2));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 2));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          \"The non supported unit should not get any bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  otherSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+    }\n+\n+    @Test\n+    void attackUnitsWithMultipleSupportUnits() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.AA, OFFENSE, 1, 1);\n+      final Unit otherSupportedUnit = givenUnit(unitType, BattleType.AA, OFFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.AA, OFFENSE, 1, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength:AAroll\", 1, 2);\n+      final Unit supportUnit2 = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment2 =\n+          givenUnitSupportAttachment(gameData, \"test2\", unit.getType(), \"AAstrength:AAroll\", 1, 1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment), List.of(unitSupportAttachment2)))\n+              .supportUnits(\n+                  Map.of(\n+                      unitSupportAttachment,\n+                      new IntegerMap<>(Map.of(supportUnit, 2)),\n+                      unitSupportAttachment2,\n+                      new IntegerMap<>(Map.of(supportUnit2, 1))))\n+              .supportLeft(\n+                  new IntegerMap<>(Map.of(unitSupportAttachment, 2, unitSupportAttachment2, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          \"First should have both support, second should have one support, \"\n+              + \"last should have no support\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(3).build(),\n+                  otherSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+    }\n+\n+    @Test\n+    void maxPowerIsDiceSidesAfterAllSupports() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 4, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength\", 4, 1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(6).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void minPowerIsZeroAfterAllSupports() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 4, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength\", -8, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, SupportCalculationResult.EMPTY_RESULT, false, gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void strongestAaGetsSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit strongUnit = givenUnit(\"strong\", BattleType.AA, gameData, OFFENSE, 4, 1);\n+      final Unit weakUnit = givenUnit(\"weak\", BattleType.AA, gameData, OFFENSE, 2, 1);\n+      final Unit lessWeakUnit = givenUnit(\"lessWeak\", BattleType.AA, gameData, OFFENSE, 3, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData,\n+              \"test\",\n+              Set.of(strongUnit.getType(), weakUnit.getType(), lessWeakUnit.getType()),\n+              \"AAstrength:AAroll\",\n+              1,\n+              1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(weakUnit, strongUnit, lessWeakUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result,\n+          is(\n+              Map.of(\n+                  strongUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(5).totalRolls(2).build(),\n+                  lessWeakUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(1).build(),\n+                  weakUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build())));\n+    }\n+\n+    @Test\n+    void infiniteRollIgnoresSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 4, -1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"AAstrength:AAroll\", 2, 2);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Unit enemyUnit = mock(Unit.class);\n+      final UnitSupportAttachment enemyUnitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"AAstrength:AAroll\", -1, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(enemyUnitSupportAttachment)))\n+              .supportUnits(\n+                  Map.of(enemyUnitSupportAttachment, new IntegerMap<>(Map.of(enemyUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(enemyUnitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, friendlySupport, false, gameData);\n+\n+      assertThat(\n+          \"Infinite rolls isn't affected by the support\",\n+          result,\n+          is(Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(5).totalRolls(-1).build())));\n+    }\n+\n+    @Test\n+    void minRollsIsZero() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.AA, gameData, OFFENSE, 4, 1);\n+\n+      final Unit enemyUnit = mock(Unit.class);\n+      final UnitSupportAttachment enemyUnitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"AAstrength:AAroll\", -2, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(enemyUnitSupportAttachment)))\n+              .supportUnits(\n+                  Map.of(enemyUnitSupportAttachment, new IntegerMap<>(Map.of(enemyUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(enemyUnitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, SupportCalculationResult.EMPTY_RESULT, false, gameData);\n+\n+      assertThat(\n+          \"The support should take rolls to -1 but the min is 0\",\n+          result,\n+          is(Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build())));\n+    }\n+  }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  class GetUnitPowerAndRollsForNormalBattles {\n+\n+    @Test\n+    void attackUnitWithNoSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void defenseUnitWithNoSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void attackMarineWithNoSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+      unit.getPropertyOrThrow(Unit.UNLOADED_AMPHIBIOUS).setValue(true);\n+      unit.getUnitAttachment().getPropertyOrThrow(UnitAttachment.IS_MARINE).setValue(1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          \"Offense adds marine bonus for amphibious assaults\",\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build()));\n+    }\n+\n+    // defenders should actually never have UNLOADED_AMPHIBIOUS set to true but this tests\n+    // that even if it happens, the marine bonus is not added\n+    @Test\n+    void defenseMarineWithNoSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+      unit.getPropertyOrThrow(Unit.UNLOADED_AMPHIBIOUS).setValue(true);\n+      unit.getUnitAttachment().getPropertyOrThrow(UnitAttachment.IS_MARINE).setValue(1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          \"Defense doesn't use marine bonus\",\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void attackBombardmentWithNoSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+      unit.getUnitAttachment().getPropertyOrThrow(UnitAttachment.BOMBARD).setValue(3);\n+      unit.getUnitAttachment().getPropertyOrThrow(UnitAttachment.IS_SEA).setValue(true);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          \"Offense uses bombardment when it is a sea unit in a land battle\",\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void defenseBombardmentWithNoSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+      unit.getUnitAttachment().getPropertyOrThrow(UnitAttachment.BOMBARD).setValue(3);\n+      unit.getUnitAttachment().getPropertyOrThrow(UnitAttachment.IS_SEA).setValue(true);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          \"Defense doesn't use the bombardment value\",\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void unitWithZeroRollsAlwaysGetsZeroPower() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 0);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void unitWithZeroPowerAlwaysGetsZeroRolls() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 0, 1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneStrengthSupportFromFriendly()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build()));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(unitSupportRollsMap, is(Map.of()));\n+    }\n+\n+    @Test\n+    void defenseUnitWithOneStrengthSupportFromFriendly()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build()));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(unitSupportRollsMap, is(Map.of()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneRollSupportFromFriendly() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"roll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(2).build()));\n+\n+      assertThat(unitSupportPowerMap, is(Map.of()));\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void defenseUnitWithOneRollSupportFromFriendly() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"roll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(2).build()));\n+\n+      assertThat(unitSupportPowerMap, is(Map.of()));\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneStrengthSupportFromEnemy() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength\", -1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              enemySupport,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, -1)))));\n+      assertThat(unitSupportRollsMap, is(Map.of()));\n+    }\n+\n+    @Test\n+    void defenseUnitWithOneStrengthSupportFromEnemy() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength\", -1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              enemySupport,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, -1)))));\n+      assertThat(unitSupportRollsMap, is(Map.of()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneRollSupportFromEnemy() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"roll\", -1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              enemySupport,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+\n+      assertThat(unitSupportPowerMap, is(Map.of()));\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, -1)))));\n+    }\n+\n+    @Test\n+    void defenseUnitWithOneRollSupportFromEnemy() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"roll\", -1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              enemySupport,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+\n+      assertThat(unitSupportPowerMap, is(Map.of()));\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, -1)))));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneSupportForBothRollAndStrength()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build()));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void defenseUnitWithOneSupportForBothRollAndStrength()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build()));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void twoAttackUnitsWithOnlyOneSupportAvailable() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"The non supported unit should not get any bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void twoDefenseUnitsWithOnlyOneSupportAvailable() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.NORMAL, DEFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.NORMAL, DEFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"The non supported unit should not get any bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(\n+          \"The support unit gave 1 bonus to the unit\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void threeAttackUnitsWithOneSupportAvailableThatAffectsTwo()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+      final Unit otherSupportedUnit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 2);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 2));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 2));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"The non supported unit should not get any bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  otherSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to both units\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1, otherSupportedUnit, 1)))));\n+      assertThat(\n+          \"The support unit gave 1 bonus to both units\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1, otherSupportedUnit, 1)))));\n+    }\n+\n+    @Test\n+    void threeDefenseUnitsWithOneSupportThatAffectsTwo()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.NORMAL, DEFENSE, 1, 1);\n+      final Unit otherSupportedUnit = givenUnit(unitType, BattleType.NORMAL, DEFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.NORMAL, DEFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 2);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 2));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 2));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"The non supported unit should not get any bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  otherSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+\n+      assertThat(\n+          \"The support unit gave 1 bonus to both units\",\n+          unitSupportPowerMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1, otherSupportedUnit, 1)))));\n+      assertThat(\n+          \"The support unit gave 1 bonus to both units\",\n+          unitSupportRollsMap,\n+          is(Map.of(supportUnit, new IntegerMap<>(Map.of(unit, 1, otherSupportedUnit, 1)))));\n+    }\n+\n+    @Test\n+    void attackUnitsWithMultipleSupportUnits() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+      final Unit otherSupportedUnit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 2);\n+      final Unit supportUnit2 = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment2 =\n+          givenUnitSupportAttachment(gameData, \"test2\", unit.getType(), \"strength:roll\", 1, 1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment), List.of(unitSupportAttachment2)))\n+              .supportUnits(\n+                  Map.of(\n+                      unitSupportAttachment,\n+                      new IntegerMap<>(Map.of(supportUnit, 2)),\n+                      unitSupportAttachment2,\n+                      new IntegerMap<>(Map.of(supportUnit2, 1))))\n+              .supportLeft(\n+                  new IntegerMap<>(Map.of(unitSupportAttachment, 2, unitSupportAttachment2, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"First should have both support, second should have one support, \"\n+              + \"last should have no support\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(3).build(),\n+                  otherSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+\n+      assertThat(\n+          \"First support unit supported two, the second supported one\",\n+          unitSupportPowerMap,\n+          is(\n+              Map.of(\n+                  supportUnit,\n+                  new IntegerMap<>(Map.of(unit, 1, otherSupportedUnit, 1)),\n+                  supportUnit2,\n+                  new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(\n+          \"First support unit supported two, the second supported one\",\n+          unitSupportRollsMap,\n+          is(\n+              Map.of(\n+                  supportUnit, new IntegerMap<>(Map.of(unit, 1, otherSupportedUnit, 1)),\n+                  supportUnit2, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void defenseUnitsWithMultipleSupportUnits() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.NORMAL, DEFENSE, 1, 1);\n+      final Unit otherSupportedUnit = givenUnit(unitType, BattleType.NORMAL, DEFENSE, 1, 1);\n+      final Unit nonSupportedUnit = givenUnit(unitType, BattleType.NORMAL, DEFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 2);\n+      final Unit supportUnit2 = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment2 =\n+          givenUnitSupportAttachment(gameData, \"test2\", unit.getType(), \"strength:roll\", 1, 1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment), List.of(unitSupportAttachment2)))\n+              .supportUnits(\n+                  Map.of(\n+                      unitSupportAttachment,\n+                      new IntegerMap<>(Map.of(supportUnit, 2)),\n+                      unitSupportAttachment2,\n+                      new IntegerMap<>(Map.of(supportUnit2, 1))))\n+              .supportLeft(\n+                  new IntegerMap<>(Map.of(unitSupportAttachment, 2, unitSupportAttachment2, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"First should have both support, second should have one support, \"\n+              + \"last should have no support\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(3).build(),\n+                  otherSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+\n+      assertThat(\n+          \"First support unit supported two, the second supported one\",\n+          unitSupportPowerMap,\n+          is(\n+              Map.of(\n+                  supportUnit,\n+                  new IntegerMap<>(Map.of(unit, 1, otherSupportedUnit, 1)),\n+                  supportUnit2,\n+                  new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(\n+          \"First support unit supported two, the second supported one\",\n+          unitSupportRollsMap,\n+          is(\n+              Map.of(\n+                  supportUnit, new IntegerMap<>(Map.of(unit, 1, otherSupportedUnit, 1)),\n+                  supportUnit2, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void offenseUnitsWithSupportThatHasTwoAttachmentsAndBonusCountOf1()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+      final Unit otherSupportedUnit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"strength:roll\", 1, 1, \"same\");\n+      final Unit supportUnit2 = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment2 =\n+          givenUnitSupportAttachment(\n+              gameData, \"test2\", Set.of(unit.getType()), \"strength:roll\", 1, 1, \"same\");\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment, unitSupportAttachment2)))\n+              .supportUnits(\n+                  Map.of(\n+                      unitSupportAttachment,\n+                      new IntegerMap<>(Map.of(supportUnit, 1)),\n+                      unitSupportAttachment2,\n+                      new IntegerMap<>(Map.of(supportUnit2, 1))))\n+              .supportLeft(\n+                  new IntegerMap<>(Map.of(unitSupportAttachment, 1, unitSupportAttachment2, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"No stack on the same unit so both units get the bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  otherSupportedUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build())));\n+\n+      assertThat(\n+          \"No stack on the same unit so both units get the bonus\",\n+          unitSupportPowerMap,\n+          is(\n+              Map.of(\n+                  supportUnit,\n+                  new IntegerMap<>(Map.of(unit, 1)),\n+                  supportUnit2,\n+                  new IntegerMap<>(Map.of(otherSupportedUnit, 1)))));\n+      assertThat(\n+          \"No stack on the same unit so both units get the bonus\",\n+          unitSupportRollsMap,\n+          is(\n+              Map.of(\n+                  supportUnit,\n+                  new IntegerMap<>(Map.of(unit, 1)),\n+                  supportUnit2,\n+                  new IntegerMap<>(Map.of(otherSupportedUnit, 1)))));\n+    }\n+\n+    @Test\n+    void offenseUnitsWithSupportThatHasTwoAttachmentsAndBonusCountOf2()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+      final Unit otherSupportedUnit = givenUnit(unitType, BattleType.NORMAL, OFFENSE, 1, 1);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"strength:roll\", 1, 2, \"same\");\n+      final Unit supportUnit2 = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment2 =\n+          givenUnitSupportAttachment(\n+              gameData, \"test2\", Set.of(unit.getType()), \"strength:roll\", 1, 2, \"same\");\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment, unitSupportAttachment2)))\n+              .supportUnits(\n+                  Map.of(\n+                      unitSupportAttachment,\n+                      new IntegerMap<>(Map.of(supportUnit, 1)),\n+                      unitSupportAttachment2,\n+                      new IntegerMap<>(Map.of(supportUnit2, 1))))\n+              .supportLeft(\n+                  new IntegerMap<>(Map.of(unitSupportAttachment, 1, unitSupportAttachment2, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"The first unit gets all the bonus because bonus count is 2\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(3).build(),\n+                  otherSupportedUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+\n+      assertThat(\n+          \"The first unit gets all the bonus because bonus count is 2\",\n+          unitSupportPowerMap,\n+          is(\n+              Map.of(\n+                  supportUnit,\n+                  new IntegerMap<>(Map.of(unit, 1)),\n+                  supportUnit2,\n+                  new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(\n+          \"The first unit gets all the bonus because bonus count is 2\",\n+          unitSupportRollsMap,\n+          is(\n+              Map.of(\n+                  supportUnit,\n+                  new IntegerMap<>(Map.of(unit, 1)),\n+                  supportUnit2,\n+                  new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void attackShouldNotHaveFirstTurnLimiting() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 3, 3);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"First turn limiting should not happen\",\n+          result,\n+          is(Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(3).build())));\n+\n+      // since the code is never called, adding mocks to return the correct values will throw errors\n+      // unless lenient() is added.  So just check that the call is never made.\n+      verify(\n+              gameData,\n+              never()\n+                  .description(\n+                      \"Game sequence should only be called for first turn limiting check \"\n+                          + \"and attackers don't get limited\"))\n+          .getSequence();\n+\n+      assertThat(unitSupportPowerMap, is(Map.of()));\n+      assertThat(unitSupportRollsMap, is(Map.of()));\n+    }\n+\n+    @Test\n+    void defenseWithFirstTurnLimited() throws MutableProperty.InvalidValueException {\n+      final GamePlayer attacker = mock(GamePlayer.class);\n+      final RulesAttachment rulesAttachment = mock(RulesAttachment.class);\n+      when(rulesAttachment.getDominatingFirstRoundAttack()).thenReturn(true);\n+      when(attacker.getAttachment(RULES_ATTACHMENT_NAME)).thenReturn(rulesAttachment);\n+\n+      final GameData gameData = givenGameData().withDiceSides(6).withRound(1, attacker).build();\n+\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 3, 3);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"First turn limiting should reduce power to 1\",\n+          result,\n+          is(Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(3).build())));\n+\n+      assertThat(unitSupportPowerMap, is(Map.of()));\n+      assertThat(unitSupportRollsMap, is(Map.of()));\n+    }\n+\n+    @Test\n+    void defenseWithFirstTurnLimitedWithSupport() throws MutableProperty.InvalidValueException {\n+      final GamePlayer attacker = mock(GamePlayer.class);\n+      final RulesAttachment rulesAttachment = mock(RulesAttachment.class);\n+      when(rulesAttachment.getDominatingFirstRoundAttack()).thenReturn(true);\n+      when(attacker.getAttachment(RULES_ATTACHMENT_NAME)).thenReturn(rulesAttachment);\n+\n+      final GameData gameData = givenGameData().withDiceSides(6).withRound(1, attacker).build();\n+\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 3, 3);\n+\n+      final Map<Unit, IntegerMap<Unit>> unitSupportPowerMap = new HashMap<>();\n+      final Map<Unit, IntegerMap<Unit>> unitSupportRollsMap = new HashMap<>();\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength:roll\", 1, 1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Unit enemySupportUnit = mock(Unit.class);\n+      // use a bonus of 1 for the enemy support to ensure that the value doesn't go to 0 and the\n+      // support can be detected\n+      final UnitSupportAttachment enemyUnitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test2\", unit.getType(), \"strength:roll\", 1, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(enemyUnitSupportAttachment)))\n+              .supportUnits(\n+                  Map.of(enemyUnitSupportAttachment, new IntegerMap<>(Map.of(enemySupportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(enemyUnitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              enemySupport,\n+              friendlySupport,\n+              true,\n+              gameData,\n+              true,\n+              List.of(),\n+              unitSupportPowerMap,\n+              unitSupportRollsMap);\n+\n+      assertThat(\n+          \"First turn limiting should reduce power to 1 and enemy support should increase it to 2\",\n+          result,\n+          is(Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(5).build())));\n+\n+      assertThat(\n+          \"Enemy support unit should be the only one giving support\",\n+          unitSupportPowerMap,\n+          is(Map.of(enemySupportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+      assertThat(\n+          \"Both support units give support for roll\",\n+          unitSupportRollsMap,\n+          is(\n+              Map.of(\n+                  enemySupportUnit, new IntegerMap<>(Map.of(unit, 1)),\n+                  supportUnit, new IntegerMap<>(Map.of(unit, 1)))));\n+    }\n+\n+    @Test\n+    void attackUnitWithTerritoryEffects() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1);\n+\n+      final TerritoryEffect territoryEffect = new TerritoryEffect(\"test\", gameData);\n+      final TerritoryEffectAttachment territoryEffectAttachment =\n+          new TerritoryEffectAttachment(\"test\", territoryEffect, gameData);\n+      territoryEffect.addAttachment(TERRITORYEFFECT_ATTACHMENT_NAME, territoryEffectAttachment);\n+      territoryEffectAttachment\n+          .getPropertyOrThrow(COMBAT_OFFENSE_EFFECT)\n+          .setValue(new IntegerMap<>(Map.of(unit.getType(), 1)));\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(territoryEffect),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void defenseUnitWithTerritoryEffects() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, DEFENSE, 1, 1);\n+\n+      final TerritoryEffect territoryEffect = new TerritoryEffect(\"test\", gameData);\n+      final TerritoryEffectAttachment territoryEffectAttachment =\n+          new TerritoryEffectAttachment(\"test\", territoryEffect, gameData);\n+      territoryEffect.addAttachment(TERRITORYEFFECT_ATTACHMENT_NAME, territoryEffectAttachment);\n+      territoryEffectAttachment\n+          .getPropertyOrThrow(COMBAT_DEFENSE_EFFECT)\n+          .setValue(new IntegerMap<>(Map.of(unit.getType(), 1)));\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData,\n+              true,\n+              List.of(territoryEffect),\n+              Map.of(),\n+              Map.of());\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void maxPowerIsDiceSidesAfterAllSupports() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 3, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength\", 3, 1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final TerritoryEffect territoryEffect = new TerritoryEffect(\"test\", gameData);\n+      final TerritoryEffectAttachment territoryEffectAttachment =\n+          new TerritoryEffectAttachment(\"test\", territoryEffect, gameData);\n+      territoryEffect.addAttachment(TERRITORYEFFECT_ATTACHMENT_NAME, territoryEffectAttachment);\n+      territoryEffectAttachment\n+          .getPropertyOrThrow(COMBAT_OFFENSE_EFFECT)\n+          .setValue(new IntegerMap<>(Map.of(unit.getType(), 3)));\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData,\n+              true,\n+              List.of(territoryEffect),\n+              new HashMap<>(),\n+              new HashMap<>());\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(6).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void minPowerIsZeroAfterAllSupports() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 3, 1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"strength\", -3, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final TerritoryEffect territoryEffect = new TerritoryEffect(\"test\", gameData);\n+      final TerritoryEffectAttachment territoryEffectAttachment =\n+          new TerritoryEffectAttachment(\"test\", territoryEffect, gameData);\n+      territoryEffect.addAttachment(TERRITORYEFFECT_ATTACHMENT_NAME, territoryEffectAttachment);\n+      territoryEffectAttachment\n+          .getPropertyOrThrow(COMBAT_OFFENSE_EFFECT)\n+          .setValue(new IntegerMap<>(Map.of(unit.getType(), -3)));\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              enemySupport,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(territoryEffect),\n+              new HashMap<>(),\n+              new HashMap<>());\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void minRollsIsZero() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 4, 1);\n+\n+      final Unit enemyUnit = mock(Unit.class);\n+      final UnitSupportAttachment enemyUnitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"strength:roll\", -2, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(enemyUnitSupportAttachment)))\n+              .supportUnits(\n+                  Map.of(enemyUnitSupportAttachment, new IntegerMap<>(Map.of(enemyUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(enemyUnitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              enemySupport,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData,\n+              true,\n+              List.of(),\n+              new HashMap<>(),\n+              new HashMap<>());\n+\n+      assertThat(\n+          \"The support should take rolls to -1 but the minimum is 0\",\n+          result,\n+          is(Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build())));\n+    }\n+\n+    @Test\n+    void testGetTotalPowerForSupportBonusTypeCount() {\n+      final GameData twwGameData = TestMapGameData.TWW.getGameData();\n+\n+      // Move regular units\n+      final GamePlayer germans = GameDataTestUtil.germany(twwGameData);\n+      final Territory berlin = territory(\"Berlin\", twwGameData);\n+      final List<Unit> attackers = new ArrayList<>();\n+\n+      attackers.addAll(GameDataTestUtil.germanInfantry(twwGameData).create(1, germans));\n+      attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n+      int attackPower =\n+          TotalPowerAndTotalRolls.getTotalPower(\n+              TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+                  attackers,\n+                  new ArrayList<>(),\n+                  attackers,\n+                  false,\n+                  twwGameData,\n+                  berlin,\n+                  new ArrayList<>()),\n+              twwGameData);\n+      assertThat(\"1 artillery should provide +1 support to the infantry\", attackPower, is(6));\n+\n+      attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n+      attackPower =\n+          TotalPowerAndTotalRolls.getTotalPower(\n+              TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+                  attackers,\n+                  new ArrayList<>(),\n+                  attackers,\n+                  false,\n+                  twwGameData,\n+                  berlin,\n+                  new ArrayList<>()),\n+              twwGameData);\n+      assertThat(\n+          \"2 artillery should provide +2 support to the infantry as stack count is 2\",\n+          attackPower,\n+          is(10));\n+\n+      attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n+      attackPower =\n+          TotalPowerAndTotalRolls.getTotalPower(\n+              TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n+                  attackers,\n+                  new ArrayList<>(),\n+                  attackers,\n+                  false,\n+                  twwGameData,\n+                  berlin,\n+                  new ArrayList<>()),\n+              twwGameData);\n+      assertThat(\n+          \"3 artillery should provide +2 support to the infantry as can't provide more than 2\",\n+          attackPower,\n+          is(13));\n+    }\n+  }\n+\n+  @TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+  @Nested\n+  class GetTotalPowerAndRolls {\n+\n+    @Test\n+    @DisplayName(\"If either power or rolls is 0, then don't add the other value if it is not 0\")\n+    void noPowerOrRollsIsZeroTotalPowerAndRolls() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalPowerAndRolls(\n+              Map.of(\n+                  mock(Unit.class),\n+                  TotalPowerAndTotalRolls.builder().totalPower(10).totalRolls(0).build(),\n+                  mock(Unit.class),\n+                  TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(10).build()),\n+              gameData),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void rollOfOneJustAddsPowerAndRolls() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalPowerAndRolls(\n+              Map.of(\n+                  mock(Unit.class),\n+                  TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(1).build(),\n+                  mock(Unit.class),\n+                  TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build()),\n+              gameData),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(5).totalRolls(2).build()));\n+    }\n+\n+    @Test\n+    void rollIsMultipliedWithPower() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalPowerAndRolls(\n+              Map.of(\n+                  givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 3, 2),\n+                  TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(2).build(),\n+                  givenUnit(\"test2\", BattleType.NORMAL, gameData, OFFENSE, 2, 2),\n+                  TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build()),\n+              gameData),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(10).totalRolls(4).build()));\n+    }\n+\n+    @Test\n+    @DisplayName(\"If the power is more than the dice sides, then dice sides will be used\")\n+    void individualPowerIsLimitedToDiceSides() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalPowerAndRolls(\n+              Map.of(\n+                  givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 8, 2),\n+                  TotalPowerAndTotalRolls.builder().totalPower(8).totalRolls(2).build()),\n+              gameData),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(12).totalRolls(2).build()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"bestRollSimulated\")\n+    void lhtrIsSimulatedWithALittleExtraPower(\n+        final int power,\n+        final int rolls,\n+        final int diceSides,\n+        final int expectedPower,\n+        final int expectedRolls)\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData =\n+          givenGameData().withDiceSides(diceSides).withLhtrHeavyBombers(true).build();\n+\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalPowerAndRolls(\n+              Map.of(\n+                  givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, power, rolls),\n+                  TotalPowerAndTotalRolls.builder().totalPower(power).totalRolls(rolls).build()),\n+              gameData),\n+          is(\n+              TotalPowerAndTotalRolls.builder()\n+                  .totalPower(expectedPower)\n+                  .totalRolls(expectedRolls)\n+                  .build()));\n+    }\n+\n+    List<Arguments> bestRollSimulated() {\n+      // expectedPower = power + ((6 / dice) * (rolls - 1))\n+      return List.of(\n+          Arguments.of(3, 2, 6, 4, 2), // 3 + (6/6) * (2-1) = 4\n+          Arguments.of(4, 2, 6, 5, 2), // 4 + (6/6) * (2-1) = 5\n+          Arguments.of(3, 3, 6, 5, 3), // 3 + (6/6) * (3-1) = 5\n+          Arguments.of(3, 2, 12, 5, 2), // 3 + (12/6) * (2-1) = 5\n+          Arguments.of(3, 3, 12, 7, 3) // 3 + (12/6) * (3-1) = 7\n+          );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"bestRollSimulated\")\n+    void chooseBestRollIsSimulatedWithALittleExtraPower(\n+        final int power,\n+        final int rolls,\n+        final int diceSides,\n+        final int expectedPower,\n+        final int expectedRolls)\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(diceSides).build();\n+\n+      final Unit unit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, power, rolls);\n+      unit.getUnitAttachment().getPropertyOrThrow(CHOOSE_BEST_ROLL).setValue(true);\n+\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalPowerAndRolls(\n+              Map.of(\n+                  unit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(power).totalRolls(rolls).build()),\n+              gameData),\n+          is(\n+              TotalPowerAndTotalRolls.builder()\n+                  .totalPower(expectedPower)\n+                  .totalRolls(expectedRolls)\n+                  .build()));\n+    }\n+  }\n+\n+  @Nested\n+  class GetTotalAaAttacks {\n+\n+    @Test\n+    void emptyPowerMapIsZeroAttacks() {\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(Map.of(), List.of(mock(Unit.class))), is(0));\n+    }\n+\n+    @Test\n+    void emptyUnitCollectionIsZeroAttacks() {\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(\n+              Map.of(\n+                  mock(Unit.class),\n+                  TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()),\n+              List.of()),\n+          is(0));\n+    }\n+\n+    @Test\n+    void powerMapWithNoPowerOrRollsIsZeroAttacks() {\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(\n+              Map.of(\n+                  mock(Unit.class),\n+                  TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(10).build(),\n+                  mock(Unit.class),\n+                  TotalPowerAndTotalRolls.builder().totalPower(10).totalRolls(0).build()),\n+              List.of(mock(Unit.class))),\n+          is(0));\n+    }\n+\n+    @Test\n+    void unitWithInfiniteRollsMeansAttacksEqualToTarget()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().build();\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(\n+              Map.of(\n+                  givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, -1),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(-1).build()),\n+              List.of(mock(Unit.class), mock(Unit.class), mock(Unit.class))),\n+          is(3));\n+    }\n+\n+    @Test\n+    void multipleUnitsWithInfiniteRollsMeansAttacksEqualToTarget()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().build();\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(\n+              Map.of(\n+                  givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, -1),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(-1).build(),\n+                  givenUnit(\"test2\", BattleType.NORMAL, gameData, OFFENSE, 1, -1),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(-1).build()),\n+              List.of(mock(Unit.class), mock(Unit.class), mock(Unit.class))),\n+          is(3));\n+    }\n+\n+    @Test\n+    void infiniteUnitAndNonInfiniteUnitMeansAttacksEqualsToTarget()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().build();\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(\n+              Map.of(\n+                  givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, -1),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(-1).build(),\n+                  givenUnit(\"test2\", BattleType.NORMAL, gameData, OFFENSE, 1, 10),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(10).build()),\n+              List.of(mock(Unit.class), mock(Unit.class), mock(Unit.class))),\n+          is(3));\n+    }\n+\n+    @Test\n+    void rollsOfNonInfiniteUnitEqualsAttack() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().build();\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(\n+              Map.of(\n+                  givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 1),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()),\n+              List.of(mock(Unit.class), mock(Unit.class), mock(Unit.class))),\n+          is(1));\n+    }\n+\n+    @Test\n+    void rollsOfNonInfiniteUnitGreaterThanTargetCountMeansAttackEqualsTarget()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().build();\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(\n+              Map.of(\n+                  givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 2),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(2).build(),\n+                  givenUnit(\"test2\", BattleType.NORMAL, gameData, OFFENSE, 1, 2),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(2).build()),\n+              List.of(mock(Unit.class), mock(Unit.class), mock(Unit.class))),\n+          is(3));\n+    }\n+\n+    @Test\n+    void overstackUnitCanCauseAttackToGoOverTargetCount()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().build();\n+      final Unit overstackUnit = givenUnit(\"test\", BattleType.NORMAL, gameData, OFFENSE, 1, 3);\n+      overstackUnit.getUnitAttachment().getPropertyOrThrow(MAY_OVERSTACK_AA).setValue(true);\n+\n+      assertThat(\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(\n+              Map.of(\n+                  overstackUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(2).build(),\n+                  givenUnit(\"test2\", BattleType.NORMAL, gameData, OFFENSE, 1, 3),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(3).build(),\n+                  givenUnit(\"test3\", BattleType.NORMAL, gameData, OFFENSE, 1, -1),\n+                  TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(-1).build()),\n+              List.of(mock(Unit.class), mock(Unit.class), mock(Unit.class))),\n+          is(5));", "originalCommit": "d4db9cc7be6b5b1d1de348a92dae9137f28d8af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ1NjcwMw==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501456703", "bodyText": "Yeah, it is dealing with rolls only.  I added some description.  I thought the name of the method would be ok but I think that the terminology is wrong.  There is \"rolls\", \"power\", \"strength\", \"attacks\", etc.  I think \"rolls\" always means \"rolls\" and the others all mean the same, except when \"attacks\" means \"rolls\" (such as \"maxAAattacks\" and this method \"getTotalAaAttacks\").  What is the current term: \"power\", \"strength\", \"attacks\", or something else?", "author": "trevan", "createdAt": "2020-10-08T05:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0ODMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwNTk1Mw==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501505953", "bodyText": "IMO always err on making tests stupid simple to understand and spell out explicitly what is being tested. Humbly the test name here did not inform me it is about rolls. Also like javadocs and any other commentary, remember it's not the ritual that is helpful, so the commentary/description can stay very terse, does not have to be full sentences - the audience are future developers that either are hunting down a bug and looking for a test gap, or just fixed a bug and are fixing broken tests, or changed the code and now are looking to fix a number of broken tests.\nThank you for adding the description. I'll take a look in more detail I hope soon.\nRe: terms\npower -> typically this is strength times number of rolls.\nstrength -> the value on the die to hit\nattacks -> inconsistent name for 'number of rolls'\nSo, a bomber has power and strength 4 with 1 roll, with heavy bomber tech the power goes up to 8, strength stays the same. With LHTR heavy bomber, it's less defined, power is mostly used by AI to approximate unit capability, so the LHTR power would probably be 5.28   ((1 - (2/6 * 2/6))*6)   (Inverse of the odds of not hitting times number of sides on dice)", "author": "DanVanAtta", "createdAt": "2020-10-08T07:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0ODMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NjQ5Ng==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502086496", "bodyText": "power -> typically this is strength times number of rolls.\nstrength -> the value on the die to hit\nattacks -> inconsistent name for 'number of rolls'\n\nThen these files are all misnamed.  TotalPowerAndTotalRolls should be renamed to TotalStrengthAndTotalRolls since the \"power\" that it is calculated is the value on the die to hit.  getTotalAaAttacks should be getTotalAaRolls, getMaxAaAttackAndDiceSides should be getMaxAaStrengthAndDiceSides, etc.", "author": "trevan", "createdAt": "2020-10-09T00:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0ODMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE1NjAwNQ==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502156005", "bodyText": "Hmm, good point. My understanding might have been inconsistent, or it's perhaps just not consistent. I'd recommend doing a survey of the terms and how they are typically used. This is something that would do well to be added to the glossary", "author": "DanVanAtta", "createdAt": "2020-10-09T02:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0ODMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0ODY5NQ==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501448695", "bodyText": "The 'int' 'int' params side-by-side is a bit difficult on the reader, could also suffer from parameter swapping bug where the two parameters are mistakenly swapped. Any thoughts to convert the parameters to a parameter object and use a builder?", "author": "DanVanAtta", "createdAt": "2020-10-08T04:58:56Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRollsTest.java", "diffHunk": "@@ -1,33 +1,723 @@\n package games.strategy.triplea.delegate.power.calculator;\n \n+import static games.strategy.triplea.Constants.RULES_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.SUPPORT_ATTACHMENT_PREFIX;\n+import static games.strategy.triplea.Constants.TERRITORYEFFECT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_DEFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_OFFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.UnitAttachment.ATTACK_AA_MAX_DIE_SIDES;\n+import static games.strategy.triplea.attachments.UnitAttachment.CHOOSE_BEST_ROLL;\n+import static games.strategy.triplea.attachments.UnitAttachment.MAY_OVERSTACK_AA;\n+import static games.strategy.triplea.attachments.UnitAttachment.OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS_TYPE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.DICE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.UNIT_TYPE;\n import static games.strategy.triplea.delegate.GameDataTestUtil.territory;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import games.strategy.engine.data.GameData;\n import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.TerritoryEffect;\n import games.strategy.engine.data.Unit;\n import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.RulesAttachment;\n+import games.strategy.triplea.attachments.TerritoryEffectAttachment;\n import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import games.strategy.triplea.delegate.Die;\n import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.delegate.battle.BattleState;\n import games.strategy.triplea.xml.TestMapGameData;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.util.Triple;\n+import org.triplea.util.Tuple;\n \n+@ExtendWith(MockitoExtension.class)\n class TotalPowerAndTotalRollsTest {\n \n+  enum BattleType {\n+    NORMAL,\n+    AA,\n+  }\n+\n+  @Mock GamePlayer owner;\n+\n+  private Unit givenUnit(", "originalCommit": "d4db9cc7be6b5b1d1de348a92dae9137f28d8af4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0OTQ1NQ==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501449455", "bodyText": "The logic in the test setup code jumps out at me. I'd look for ways to avoid this and make the test setup more direct.\nIt looks like we might be able to do that by using a map. WDYT?\nFor example:\ngivenUnit(UnitType, Map<String, Integer>)\n ....\n \n)\n\nUsage:\n Map.of(UnitAttachment.DEFENSE_STRENGTH, power, UnitAttachment.DEFENSE_ROLL, roll);\n\n```", "author": "DanVanAtta", "createdAt": "2020-10-08T05:01:45Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRollsTest.java", "diffHunk": "@@ -1,33 +1,723 @@\n package games.strategy.triplea.delegate.power.calculator;\n \n+import static games.strategy.triplea.Constants.RULES_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.SUPPORT_ATTACHMENT_PREFIX;\n+import static games.strategy.triplea.Constants.TERRITORYEFFECT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_DEFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_OFFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.UnitAttachment.ATTACK_AA_MAX_DIE_SIDES;\n+import static games.strategy.triplea.attachments.UnitAttachment.CHOOSE_BEST_ROLL;\n+import static games.strategy.triplea.attachments.UnitAttachment.MAY_OVERSTACK_AA;\n+import static games.strategy.triplea.attachments.UnitAttachment.OFFENSIVE_ATTACK_AA_MAX_DIE_SIDES;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS_TYPE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.DICE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.UNIT_TYPE;\n import static games.strategy.triplea.delegate.GameDataTestUtil.territory;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import games.strategy.engine.data.GameData;\n import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.TerritoryEffect;\n import games.strategy.engine.data.Unit;\n import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.RulesAttachment;\n+import games.strategy.triplea.attachments.TerritoryEffectAttachment;\n import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import games.strategy.triplea.delegate.Die;\n import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.delegate.battle.BattleState;\n import games.strategy.triplea.xml.TestMapGameData;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.util.Triple;\n+import org.triplea.util.Tuple;\n \n+@ExtendWith(MockitoExtension.class)\n class TotalPowerAndTotalRollsTest {\n \n+  enum BattleType {\n+    NORMAL,\n+    AA,\n+  }\n+\n+  @Mock GamePlayer owner;\n+\n+  private Unit givenUnit(\n+      final String name,\n+      final BattleType type,\n+      final GameData gameData,\n+      final BattleState.Side side,\n+      final int power,\n+      final int roll)\n+      throws MutableProperty.InvalidValueException {\n+    return givenUnit(givenUnitType(name, gameData), type, side, power, roll);\n+  }\n+\n+  private Unit givenUnit(\n+      final UnitType unitType,\n+      final BattleType type,\n+      final BattleState.Side side,\n+      final int power,\n+      final int roll)\n+      throws MutableProperty.InvalidValueException {\n+    final Unit unit = unitType.create(1, owner, true).get(0);\n+    if (type == BattleType.NORMAL) {", "originalCommit": "d4db9cc7be6b5b1d1de348a92dae9137f28d8af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ1NDE0Ng==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501454146", "bodyText": "In that case, I would just go back to how I had it before:\nUnit unit = givenUnit(unitType);\nunit.getUnitAttachment().getPropertyOrThrow(DEFENSE_STRENGTH).setValue(power);\nunit.getUnitAttachment().getPropertyOrThrow(DEFENSE_ROLL).setValue(power);\n\nI switched to the current way because it made the tests more concise and easier to read (at least for me).  But if you want it more verbose, I can go back.", "author": "trevan", "createdAt": "2020-10-08T05:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0OTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMTIyMQ==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501501221", "bodyText": "That does seem kinda clunky.\nUnit unit = givenUnit(unitType, Map.of(DEFENSE_STRENGTH, power, DEFENSE_ROLL, power);\n\nUnit unit = givenUnit(UnitParameters.builder()\n    .type(unitType)\n    .defenseStrength(power)\n     .defenseRolls(power)\n     .build());\n\nLooking at the source code that we are using, notably:\nunit.getUnitAttachment().getPropertyOrThrow(DEFENSE_STRENGTH).setValue(power);\n\nThat is already very clunky (and a violation of the law of demeter). Seemingly it could be as simple as:\nunit.setDefenseStrength(power);\n\nThe above has encapsulation, and notably hides the magic string property values. We may want to really think about going to that level of change before jumping there. A 4th alternative would be to add the setter method to unit attachment:\nunit.getUnitAttachment().setProperty(DEFENSE_STRENGTH, power);\n\nAnd that is still clunky (notably the 'orThrow' is there because we have a string parameter), so a 5th option is:\nunit.getUnitAttachment().setDefenseStrength(power);\n\n\nBut if you want it more verbose\n\nIt's not verbosity, two goals:\n\ntest being self contained and understandable as much as possible by reading just the single test\navoiding logic in the tests (arguably that should also be tested!)", "author": "DanVanAtta", "createdAt": "2020-10-08T07:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0OTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MDA0NA==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501860044", "bodyText": "UnitAttachment already has setters.  They are all private, for some reason.  I've made a few public and marked them with @VisibleForTesting and also changed them to return this so that I can call them in a fluid manner.  I've updated the tests to use the setters instead of getPropertyOrThrow().setValue.", "author": "trevan", "createdAt": "2020-10-08T16:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0OTQ1NQ=="}], "type": "inlineReview"}, {"oid": "042e71591b75a688e1e03438b9eeb9ec3720d051", "url": "https://github.com/triplea-game/triplea/commit/042e71591b75a688e1e03438b9eeb9ec3720d051", "message": "Add some test descriptions and fix some broken tests", "committedDate": "2020-10-08T05:25:29Z", "type": "commit"}, {"oid": "042e71591b75a688e1e03438b9eeb9ec3720d051", "url": "https://github.com/triplea-game/triplea/commit/042e71591b75a688e1e03438b9eeb9ec3720d051", "message": "Add some test descriptions and fix some broken tests", "committedDate": "2020-10-08T05:25:29Z", "type": "forcePushed"}, {"oid": "018492dbc9c45f8ba07187dd7cb6b8e66766c7a1", "url": "https://github.com/triplea-game/triplea/commit/018492dbc9c45f8ba07187dd7cb6b8e66766c7a1", "message": "Exposes setters in UnitAttachment and use them in the tests", "committedDate": "2020-10-08T16:36:01Z", "type": "commit"}, {"oid": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "url": "https://github.com/triplea-game/triplea/commit/a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "message": "Fix line length and remove unused 'throws' statements", "committedDate": "2020-10-08T16:51:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3MTMwMg==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501871302", "bodyText": "Codacy found an issue: Avoid really long methods.", "author": "DanVanAtta", "createdAt": "2020-10-08T16:56:58Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRolls.java", "diffHunk": "@@ -466,6 +475,38 @@ static void sortAaHighToLow(\n             data.getUnitTypeList().getSupportRules(),\n             !defending,\n             false);\n+\n+    return getUnitPowerAndRollsForNormalBattles(\n+        unitsGettingPowerFor,\n+        enemySupport,\n+        friendlySupport,\n+        defending,\n+        data,\n+        Matches.territoryIsLand().test(location),\n+        territoryEffects,\n+        unitSupportPowerMap,\n+        unitSupportRollsMap);\n+  }\n+\n+  @VisibleForTesting\n+  static Map<Unit, TotalPowerAndTotalRolls> getUnitPowerAndRollsForNormalBattles(", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3MTMxNA==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501871314", "bodyText": "Codacy found an issue: The method 'getUnitPowerAndRollsForNormalBattles(Collection, SupportCalculationResult, SupportCalculationResult, boolean, GameData, boolean, Collection, Map, Map)' has an NPath complexity of 224, current threshold is 200", "author": "DanVanAtta", "createdAt": "2020-10-08T16:56:59Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRolls.java", "diffHunk": "@@ -466,6 +475,38 @@ static void sortAaHighToLow(\n             data.getUnitTypeList().getSupportRules(),\n             !defending,\n             false);\n+\n+    return getUnitPowerAndRollsForNormalBattles(\n+        unitsGettingPowerFor,\n+        enemySupport,\n+        friendlySupport,\n+        defending,\n+        data,\n+        Matches.territoryIsLand().test(location),\n+        territoryEffects,\n+        unitSupportPowerMap,\n+        unitSupportRollsMap);\n+  }\n+\n+  @VisibleForTesting\n+  static Map<Unit, TotalPowerAndTotalRolls> getUnitPowerAndRollsForNormalBattles(", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3MTMyOQ==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501871329", "bodyText": "Codacy found an issue: Avoid really long methods.", "author": "DanVanAtta", "createdAt": "2020-10-08T16:57:00Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRolls.java", "diffHunk": "@@ -310,6 +304,24 @@ static void sortAaHighToLow(\n             !defending,\n             false);\n \n+    return getAaUnitPowerAndRollsForNormalBattles(\n+        aaUnits, enemySupports, friendlySupports, defending, data);\n+  }\n+\n+  @VisibleForTesting\n+  static Map<Unit, TotalPowerAndTotalRolls> getAaUnitPowerAndRollsForNormalBattles(", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3MTM0Mw==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r501871343", "bodyText": "Codacy found an issue: Avoid really long classes.", "author": "DanVanAtta", "createdAt": "2020-10-08T16:57:01Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRollsTest.java", "diffHunk": "@@ -92,62 +749,2645 @@ void testDefending() {\n     }\n   }\n \n-  @Test\n-  void testGetTotalPowerForSupportBonusTypeCount() {\n-    final GameData twwGameData = TestMapGameData.TWW.getGameData();\n-\n-    // Move regular units\n-    final GamePlayer germans = GameDataTestUtil.germany(twwGameData);\n-    final Territory berlin = territory(\"Berlin\", twwGameData);\n-    final List<Unit> attackers = new ArrayList<>();\n-\n-    attackers.addAll(GameDataTestUtil.germanInfantry(twwGameData).create(1, germans));\n-    attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n-    int attackPower =\n-        TotalPowerAndTotalRolls.getTotalPower(\n-            TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n-                attackers,\n-                new ArrayList<>(),\n-                attackers,\n-                false,\n-                twwGameData,\n-                berlin,\n-                new ArrayList<>()),\n-            twwGameData);\n-    assertEquals(attackPower, 6, \"1 artillery should provide +1 support to the infantry\");\n-\n-    attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n-    attackPower =\n-        TotalPowerAndTotalRolls.getTotalPower(\n-            TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n-                attackers,\n-                new ArrayList<>(),\n-                attackers,\n-                false,\n-                twwGameData,\n-                berlin,\n-                new ArrayList<>()),\n-            twwGameData);\n-    assertEquals(\n-        attackPower,\n-        10,\n-        \"2 artillery should provide +2 support to the infantry as stack count is 2\");\n-\n-    attackers.addAll(GameDataTestUtil.germanArtillery(twwGameData).create(1, germans));\n-    attackPower =\n-        TotalPowerAndTotalRolls.getTotalPower(\n-            TotalPowerAndTotalRolls.getUnitPowerAndRollsForNormalBattles(\n-                attackers,\n-                new ArrayList<>(),\n-                attackers,\n-                false,\n-                twwGameData,\n-                berlin,\n-                new ArrayList<>()),\n-            twwGameData);\n-    assertEquals(\n-        attackPower,\n-        13,\n-        \"3 artillery should provide +2 support to the infantry as can't provide more than 2\");\n+  @Nested\n+  class GetMaxAaAttackAndDiceSides {\n+\n+    @Test\n+    void singleUnitWithNoCustomDiceAndNoPowerRollsMap() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(List.of(unit), gameData, false);\n+\n+      assertThat(maxAttackAndDice, is(Tuple.of(2, 6)));\n+    }\n+\n+    @Test\n+    void singleDefensiveUnitWithNoCustomDiceAndNoPowerRollsMap() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setAttackAa(2).setMaxAaAttacks(1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(List.of(unit), gameData, true);\n+\n+      assertThat(maxAttackAndDice, is(Tuple.of(2, 6)));\n+    }\n+\n+    @Test\n+    void singleUnitWithCustomDiceAndNoPowerRollsMap() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment()\n+          .setOffensiveAttackAa(2)\n+          .setMaxAaAttacks(1)\n+          .setOffensiveAttackAaMaxDieSides(8);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(List.of(unit), gameData, false);\n+\n+      assertThat(\"Dice comes from the unitAttachment\", maxAttackAndDice, is(Tuple.of(2, 8)));\n+    }\n+\n+    @Test\n+    void singleDefensiveUnitWithCustomDiceAndNoPowerRollsMap() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setAttackAa(2).setMaxAaAttacks(1).setAttackAaMaxDieSides(8);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(List.of(unit), gameData, true);\n+\n+      assertThat(\"Dice comes from the unitAttachment\", maxAttackAndDice, is(Tuple.of(2, 8)));\n+    }\n+\n+    @Test\n+    void singleUnitWithPowerRollsMap() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit),\n+              gameData,\n+              false,\n+              Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(2).build()));\n+\n+      assertThat(\n+          \"Value from totalPowerAndTotalRolls is used\", maxAttackAndDice, is(Tuple.of(3, 6)));\n+    }\n+\n+    @Test\n+    void singleDefensiveUnitWithPowerRollsMap() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setAttackAa(2).setMaxAaAttacks(1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit),\n+              gameData,\n+              true,\n+              Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(2).build()));\n+\n+      assertThat(\n+          \"Value from totalPowerAndTotalRolls is used\", maxAttackAndDice, is(Tuple.of(3, 6)));\n+    }\n+\n+    @Test\n+    void limitAttackToDiceSides() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment()\n+          .setOffensiveAttackAa(2)\n+          .setMaxAaAttacks(1)\n+          .setOffensiveAttackAaMaxDieSides(4);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit),\n+              gameData,\n+              false,\n+              Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(6).totalRolls(2).build()));\n+\n+      assertThat(\n+          \"UnitAttachment dice sides is the max allowed\", maxAttackAndDice, is(Tuple.of(4, 4)));\n+    }\n+\n+    @Test\n+    void multipleUnitsWithSameDice() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(1);\n+      final Unit unit3 = givenUnit(\"test3\", gameData);\n+      unit3.getUnitAttachment().setOffensiveAttackAa(4).setMaxAaAttacks(1);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit, unit2, unit3), gameData, false);\n+\n+      assertThat(\n+          \"UnitAttachment dice sides is the max allowed\", maxAttackAndDice, is(Tuple.of(4, 6)));\n+    }\n+\n+    @Test\n+    void multipleUnitsWithDifferentDice() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment()\n+          .setOffensiveAttackAa(2)\n+          .setMaxAaAttacks(1)\n+          .setOffensiveAttackAaMaxDieSides(6);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2\n+          .getUnitAttachment()\n+          .setOffensiveAttackAa(3)\n+          .setMaxAaAttacks(1)\n+          .setOffensiveAttackAaMaxDieSides(5);\n+      final Unit unit3 = givenUnit(\"test3\", gameData);\n+      unit3\n+          .getUnitAttachment()\n+          .setOffensiveAttackAa(4)\n+          .setMaxAaAttacks(1)\n+          .setOffensiveAttackAaMaxDieSides(4);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit, unit2, unit3), gameData, false);\n+\n+      assertThat(\"4 of 4 is better than 2 of 6 and 3 of 5\", maxAttackAndDice, is(Tuple.of(4, 4)));\n+    }\n+\n+    @Test\n+    void multipleUnitsWithDifferentDice2() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment()\n+          .setOffensiveAttackAa(3)\n+          .setMaxAaAttacks(1)\n+          .setOffensiveAttackAaMaxDieSides(8);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2\n+          .getUnitAttachment()\n+          .setOffensiveAttackAa(3)\n+          .setMaxAaAttacks(1)\n+          .setOffensiveAttackAaMaxDieSides(7);\n+      final Unit unit3 = givenUnit(\"test3\", gameData);\n+      unit3\n+          .getUnitAttachment()\n+          .setOffensiveAttackAa(3)\n+          .setMaxAaAttacks(1)\n+          .setOffensiveAttackAaMaxDieSides(6);\n+\n+      final Tuple<Integer, Integer> maxAttackAndDice =\n+          TotalPowerAndTotalRolls.getMaxAaAttackAndDiceSides(\n+              List.of(unit, unit2, unit3), gameData, false);\n+\n+      assertThat(\"3 of 6 is better than 3 of 7 and 3 of 8\", maxAttackAndDice, is(Tuple.of(3, 6)));\n+    }\n+  }\n+\n+  @Nested\n+  class GetAaUnitPowerAndRollsForNormalBattles {\n+\n+    @Test\n+    void attackUnitWithNoSupport() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void defenseUnitWithNoSupport() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              true,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void unitWithZeroRollsAlwaysGetsZeroPower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(0);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void unitWithZeroPowerAlwaysGetsZeroRolls() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(0).setMaxAaAttacks(1);\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneStrengthSupportFromFriendly()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneRollSupportFromFriendly() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAroll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(2).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneStrengthSupportFromEnemy() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength\", -1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, SupportCalculationResult.EMPTY_RESULT, false, gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneRollSupportFromEnemy() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAroll\", -1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, SupportCalculationResult.EMPTY_RESULT, false, gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void attackUnitWithOneSupportForBothRollAndStrength()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength:AAroll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build()));\n+    }\n+\n+    @Test\n+    void twoAttackUnitsWithOnlyOneSupportAvailable() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+      final Unit nonSupportedUnit = givenUnit(unitType);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength:AAroll\", 1, 1);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 1));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 1));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          \"The non supported unit should not get any bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+    }\n+\n+    @Test\n+    void threeAttackUnitsWithOneSupportAvailableThatAffectsTwo()\n+        throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+      final Unit otherSupportedUnit = givenUnit(unitType);\n+      otherSupportedUnit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+      final Unit nonSupportedUnit = givenUnit(unitType);\n+      nonSupportedUnit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength:AAroll\", 1, 2);\n+\n+      final IntegerMap<Unit> supportUnits = new IntegerMap<>(Map.of(supportUnit, 2));\n+      final IntegerMap<UnitSupportAttachment> supportLeft =\n+          new IntegerMap<>(Map.of(unitSupportAttachment, 2));\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, supportUnits))\n+              .supportLeft(supportLeft)\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          \"The non supported unit should not get any bonus\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  otherSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+    }\n+\n+    @Test\n+    void attackUnitsWithMultipleSupportUnits() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final UnitType unitType = givenUnitType(\"test\", gameData);\n+      final Unit unit = givenUnit(unitType);\n+      unit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+      final Unit otherSupportedUnit = givenUnit(unitType);\n+      otherSupportedUnit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+      final Unit nonSupportedUnit = givenUnit(unitType);\n+      nonSupportedUnit.getUnitAttachment().setOffensiveAttackAa(1).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength:AAroll\", 1, 2);\n+      final Unit supportUnit2 = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment2 =\n+          givenUnitSupportAttachment(gameData, \"test2\", unit.getType(), \"AAstrength:AAroll\", 1, 1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment), List.of(unitSupportAttachment2)))\n+              .supportUnits(\n+                  Map.of(\n+                      unitSupportAttachment,\n+                      new IntegerMap<>(Map.of(supportUnit, 2)),\n+                      unitSupportAttachment2,\n+                      new IntegerMap<>(Map.of(supportUnit2, 1))))\n+              .supportLeft(\n+                  new IntegerMap<>(Map.of(unitSupportAttachment, 2, unitSupportAttachment2, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit, otherSupportedUnit, nonSupportedUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          \"First should have both support, second should have one support, \"\n+              + \"last should have no support\",\n+          result,\n+          is(\n+              Map.of(\n+                  unit, TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(3).build(),\n+                  otherSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(2).build(),\n+                  nonSupportedUnit,\n+                      TotalPowerAndTotalRolls.builder().totalPower(1).totalRolls(1).build())));\n+    }\n+\n+    @Test\n+    void maxPowerIsDiceSidesAfterAllSupports() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(4).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength\", 4, 1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(6).totalRolls(1).build()));\n+    }\n+\n+    @Test\n+    void minPowerIsZeroAfterAllSupports() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(4).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(gameData, \"test\", unit.getType(), \"AAstrength\", -8, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, SupportCalculationResult.EMPTY_RESULT, false, gameData);\n+\n+      assertThat(\n+          result.get(unit),\n+          is(TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build()));\n+    }\n+\n+    @Test\n+    void strongestAaGetsSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit strongUnit = givenUnit(\"strong\", gameData);\n+      strongUnit.getUnitAttachment().setOffensiveAttackAa(4).setMaxAaAttacks(1);\n+      final Unit weakUnit = givenUnit(\"weak\", gameData);\n+      weakUnit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit lessWeakUnit = givenUnit(\"lessWeak\", gameData);\n+      lessWeakUnit.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData,\n+              \"test\",\n+              Set.of(strongUnit.getType(), weakUnit.getType(), lessWeakUnit.getType()),\n+              \"AAstrength:AAroll\",\n+              1,\n+              1);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(weakUnit, strongUnit, lessWeakUnit),\n+              SupportCalculationResult.EMPTY_RESULT,\n+              friendlySupport,\n+              false,\n+              gameData);\n+\n+      assertThat(\n+          result,\n+          is(\n+              Map.of(\n+                  strongUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(5).totalRolls(2).build(),\n+                  lessWeakUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(3).totalRolls(1).build(),\n+                  weakUnit,\n+                  TotalPowerAndTotalRolls.builder().totalPower(2).totalRolls(1).build())));\n+    }\n+\n+    @Test\n+    void infiniteRollIgnoresSupport() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(4).setMaxAaAttacks(-1);\n+\n+      final Unit supportUnit = mock(Unit.class);\n+      final UnitSupportAttachment unitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"AAstrength:AAroll\", 2, 2);\n+\n+      final SupportCalculationResult friendlySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(unitSupportAttachment)))\n+              .supportUnits(Map.of(unitSupportAttachment, new IntegerMap<>(Map.of(supportUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(unitSupportAttachment, 1)))\n+              .build();\n+\n+      final Unit enemyUnit = mock(Unit.class);\n+      final UnitSupportAttachment enemyUnitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"AAstrength:AAroll\", -1, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(enemyUnitSupportAttachment)))\n+              .supportUnits(\n+                  Map.of(enemyUnitSupportAttachment, new IntegerMap<>(Map.of(enemyUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(enemyUnitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, friendlySupport, false, gameData);\n+\n+      assertThat(\n+          \"Infinite rolls isn't affected by the support\",\n+          result,\n+          is(Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(5).totalRolls(-1).build())));\n+    }\n+\n+    @Test\n+    void minRollsIsZero() throws MutableProperty.InvalidValueException {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(4).setMaxAaAttacks(1);\n+\n+      final Unit enemyUnit = mock(Unit.class);\n+      final UnitSupportAttachment enemyUnitSupportAttachment =\n+          givenUnitSupportAttachment(\n+              gameData, \"test\", Set.of(unit.getType()), \"AAstrength:AAroll\", -2, 1);\n+\n+      final SupportCalculationResult enemySupport =\n+          SupportCalculationResult.builder()\n+              .supportRules(Set.of(List.of(enemyUnitSupportAttachment)))\n+              .supportUnits(\n+                  Map.of(enemyUnitSupportAttachment, new IntegerMap<>(Map.of(enemyUnit, 1))))\n+              .supportLeft(new IntegerMap<>(Map.of(enemyUnitSupportAttachment, 1)))\n+              .build();\n+\n+      final Map<Unit, TotalPowerAndTotalRolls> result =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              List.of(unit), enemySupport, SupportCalculationResult.EMPTY_RESULT, false, gameData);\n+\n+      assertThat(\n+          \"The support should take rolls to -1 but the min is 0\",\n+          result,\n+          is(Map.of(unit, TotalPowerAndTotalRolls.builder().totalPower(0).totalRolls(0).build())));\n+    }\n+  }\n+\n+  @Nested\n+  @ExtendWith(MockitoExtension.class)\n+  class GetUnitPowerAndRollsForNormalBattles {", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMDkwNQ==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502820905", "bodyText": "Breaking up methods for testing is a risky thing to do. Notably whenever I see @VisibileForTesting on a method I wonder if that method should instead be replaced by a strategy object. One benefit of doing that is the test becomes more decoupled from implementation and you have a better chance to test the caller method since you can inject mocked behavior.\nWhat are your thoughts to create an object out of this method here?", "author": "DanVanAtta", "createdAt": "2020-10-10T18:55:20Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRolls.java", "diffHunk": "@@ -310,6 +304,24 @@ static void sortAaHighToLow(\n             !defending,\n             false);\n \n+    return getAaUnitPowerAndRollsForNormalBattles(\n+        aaUnits, enemySupports, friendlySupports, defending, data);\n+  }\n+\n+  @VisibleForTesting\n+  static Map<Unit, TotalPowerAndTotalRolls> getAaUnitPowerAndRollsForNormalBattles(", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMDk5MA==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502820990", "bodyText": "Ditto for the \"getUnitPowerAndRollsForNormalBattles\"", "author": "DanVanAtta", "createdAt": "2020-10-10T18:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMDkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMTAyNA==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502821024", "bodyText": "Would doing the above extraction help reduce the number of test permutations & setups and make the tests simpler?", "author": "DanVanAtta", "createdAt": "2020-10-10T18:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMDkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMTMxNA==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502821314", "bodyText": "FYI, Tuple and Triple are classes we are trying to kill. Instead of them one should favor using value objects. The problem with Tuple and Triple is that they are essentially structs and lead to hard to understand and procedural code. For example, on line 50 in a method, what does tuple.getFirst() represent? In this example here, what do the first and second integers represent? The TotalPowerAndTotalRolls is actually an example where a tuple was replaced by totalPower and total rolls and instead of 'getFirst' being power, it was instead 'getPower'. This made a lot of usages a lot easier to understand. My concern here is that we're baking in the usage of tuple and triple into the tests, but I could see argument for this also making it easier to replace them..", "author": "DanVanAtta", "createdAt": "2020-10-10T18:59:48Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRollsTest.java", "diffHunk": "@@ -1,33 +1,690 @@\n package games.strategy.triplea.delegate.power.calculator;\n \n+import static games.strategy.triplea.Constants.RULES_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.SUPPORT_ATTACHMENT_PREFIX;\n+import static games.strategy.triplea.Constants.TERRITORYEFFECT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_DEFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_OFFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS_TYPE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.DICE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.UNIT_TYPE;\n import static games.strategy.triplea.delegate.GameDataTestUtil.territory;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import games.strategy.engine.data.GameData;\n import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.TerritoryEffect;\n import games.strategy.engine.data.Unit;\n import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.RulesAttachment;\n+import games.strategy.triplea.attachments.TerritoryEffectAttachment;\n import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import games.strategy.triplea.delegate.Die;\n import games.strategy.triplea.delegate.GameDataTestUtil;\n import games.strategy.triplea.xml.TestMapGameData;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.util.Triple;\n+import org.triplea.util.Tuple;\n \n+@ExtendWith(MockitoExtension.class)\n class TotalPowerAndTotalRollsTest {\n \n+  @Mock GamePlayer owner;\n+\n+  private Unit givenUnit(final String name, final GameData gameData) {\n+    return givenUnit(givenUnitType(name, gameData));\n+  }\n+\n+  private Unit givenUnit(final UnitType unitType) {\n+    return unitType.create(1, owner, true).get(0);\n+  }\n+\n+  private UnitType givenUnitType(final String name, final GameData gameData) {\n+    final UnitType unitType = new UnitType(name + \"Type\", gameData);\n+    final UnitAttachment unitAttachment =\n+        new UnitAttachment(name + \"Attachment\", unitType, gameData);\n+    unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+    return unitType;\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final UnitType unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount)\n+      throws MutableProperty.InvalidValueException {\n+    return givenUnitSupportAttachment(\n+        gameData, name, Set.of(unitType), rollType, bonusAmount, bonusCount);\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final Set<UnitType> unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount)\n+      throws MutableProperty.InvalidValueException {\n+\n+    return givenUnitSupportAttachment(\n+        gameData, name, unitType, rollType, bonusAmount, bonusCount, name);\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final Set<UnitType> unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount,\n+      final String bonusName)\n+      throws MutableProperty.InvalidValueException {\n+    final UnitSupportAttachment unitSupportAttachment =\n+        new UnitSupportAttachment(\n+            SUPPORT_ATTACHMENT_PREFIX + name, unitType.iterator().next(), gameData);\n+    unitSupportAttachment.getPropertyOrThrow(BONUS).setValue(bonusAmount);\n+    unitSupportAttachment\n+        .getPropertyOrThrow(BONUS_TYPE)\n+        .setValue(new UnitSupportAttachment.BonusType(\"bonus\" + bonusName, bonusCount));\n+    unitSupportAttachment.getPropertyOrThrow(DICE).setValue(rollType);\n+    unitSupportAttachment.getPropertyOrThrow(UNIT_TYPE).setValue(unitType);\n+    return unitSupportAttachment;\n+  }\n+\n+  @Nested\n+  class GetTotalAaPowerThenHitsAndFillSortedDiceThenIfAllUseSameAttack {\n+\n+    @Test\n+    void singleAaWithOneRoll() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(2, 1, true)));\n+      assertThat(sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    private Triple<Integer, Integer, Boolean> whenGetPowerHitsResult(\n+        final GameData gameData,\n+        final List<Unit> units,\n+        final List<Die> sortedDie,\n+        final int dieHit,\n+        final int numValidTargets) {\n+      final Map<Unit, TotalPowerAndTotalRolls> unitPowerAndRollsMap =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              units,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      final List<Unit> validTargets =\n+          IntStream.rangeClosed(1, numValidTargets)\n+              .mapToObj(num -> mock(Unit.class))\n+              .collect(Collectors.toList());\n+      final int totalAttacks =\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(unitPowerAndRollsMap, validTargets);\n+      final int[] dice = new int[totalAttacks];\n+      for (int i = 0; i < totalAttacks; i++) {\n+        dice[i] = dieHit;\n+      }\n+\n+      return TotalPowerAndTotalRolls.getTotalAaPowerThenHitsAndFillSortedDiceThenIfAllUseSameAttack(\n+          dice, sortedDie, false, unitPowerAndRollsMap, validTargets, gameData, true);\n+    }\n+\n+    @Test\n+    void singleAaWithOneRollNoHit() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 6, 4);\n+\n+      assertThat(result, is(Triple.of(2, 0, true)));\n+      assertThat(sortedDie, is(List.of(new Die(6, 2, Die.DieType.MISS))));\n+    }\n+\n+    @Test\n+    void singleAaWithTwoRoll() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(2);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithSamePower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithDifferentPower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(1);\n+\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(5, 2, false)));", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMTYzNg==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502821636", "bodyText": "Out parameter here : (\nThis is something for us to remove and refactor. The support code is in part because it uses out parameters. Out parameters are certainly a C'ism and/or code written during java 1.4 when creating value objects was expensive. It is certainly more favored to now write a value object. As-is, the method under test is returning 4 different values, a Triple, and mutating this list parameter. One simplification we should strive to do is to remove the out parameters completely and have them be returned as values.", "author": "DanVanAtta", "createdAt": "2020-10-10T19:02:57Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRollsTest.java", "diffHunk": "@@ -1,33 +1,690 @@\n package games.strategy.triplea.delegate.power.calculator;\n \n+import static games.strategy.triplea.Constants.RULES_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.SUPPORT_ATTACHMENT_PREFIX;\n+import static games.strategy.triplea.Constants.TERRITORYEFFECT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_DEFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_OFFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS_TYPE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.DICE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.UNIT_TYPE;\n import static games.strategy.triplea.delegate.GameDataTestUtil.territory;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import games.strategy.engine.data.GameData;\n import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.TerritoryEffect;\n import games.strategy.engine.data.Unit;\n import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.RulesAttachment;\n+import games.strategy.triplea.attachments.TerritoryEffectAttachment;\n import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import games.strategy.triplea.delegate.Die;\n import games.strategy.triplea.delegate.GameDataTestUtil;\n import games.strategy.triplea.xml.TestMapGameData;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.util.Triple;\n+import org.triplea.util.Tuple;\n \n+@ExtendWith(MockitoExtension.class)\n class TotalPowerAndTotalRollsTest {\n \n+  @Mock GamePlayer owner;\n+\n+  private Unit givenUnit(final String name, final GameData gameData) {\n+    return givenUnit(givenUnitType(name, gameData));\n+  }\n+\n+  private Unit givenUnit(final UnitType unitType) {\n+    return unitType.create(1, owner, true).get(0);\n+  }\n+\n+  private UnitType givenUnitType(final String name, final GameData gameData) {\n+    final UnitType unitType = new UnitType(name + \"Type\", gameData);\n+    final UnitAttachment unitAttachment =\n+        new UnitAttachment(name + \"Attachment\", unitType, gameData);\n+    unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+    return unitType;\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final UnitType unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount)\n+      throws MutableProperty.InvalidValueException {\n+    return givenUnitSupportAttachment(\n+        gameData, name, Set.of(unitType), rollType, bonusAmount, bonusCount);\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final Set<UnitType> unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount)\n+      throws MutableProperty.InvalidValueException {\n+\n+    return givenUnitSupportAttachment(\n+        gameData, name, unitType, rollType, bonusAmount, bonusCount, name);\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final Set<UnitType> unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount,\n+      final String bonusName)\n+      throws MutableProperty.InvalidValueException {\n+    final UnitSupportAttachment unitSupportAttachment =\n+        new UnitSupportAttachment(\n+            SUPPORT_ATTACHMENT_PREFIX + name, unitType.iterator().next(), gameData);\n+    unitSupportAttachment.getPropertyOrThrow(BONUS).setValue(bonusAmount);\n+    unitSupportAttachment\n+        .getPropertyOrThrow(BONUS_TYPE)\n+        .setValue(new UnitSupportAttachment.BonusType(\"bonus\" + bonusName, bonusCount));\n+    unitSupportAttachment.getPropertyOrThrow(DICE).setValue(rollType);\n+    unitSupportAttachment.getPropertyOrThrow(UNIT_TYPE).setValue(unitType);\n+    return unitSupportAttachment;\n+  }\n+\n+  @Nested\n+  class GetTotalAaPowerThenHitsAndFillSortedDiceThenIfAllUseSameAttack {\n+\n+    @Test\n+    void singleAaWithOneRoll() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(2, 1, true)));\n+      assertThat(sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    private Triple<Integer, Integer, Boolean> whenGetPowerHitsResult(\n+        final GameData gameData,\n+        final List<Unit> units,\n+        final List<Die> sortedDie,\n+        final int dieHit,\n+        final int numValidTargets) {\n+      final Map<Unit, TotalPowerAndTotalRolls> unitPowerAndRollsMap =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              units,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      final List<Unit> validTargets =\n+          IntStream.rangeClosed(1, numValidTargets)\n+              .mapToObj(num -> mock(Unit.class))\n+              .collect(Collectors.toList());\n+      final int totalAttacks =\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(unitPowerAndRollsMap, validTargets);\n+      final int[] dice = new int[totalAttacks];\n+      for (int i = 0; i < totalAttacks; i++) {\n+        dice[i] = dieHit;\n+      }\n+\n+      return TotalPowerAndTotalRolls.getTotalAaPowerThenHitsAndFillSortedDiceThenIfAllUseSameAttack(\n+          dice, sortedDie, false, unitPowerAndRollsMap, validTargets, gameData, true);\n+    }\n+\n+    @Test\n+    void singleAaWithOneRollNoHit() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 6, 4);\n+\n+      assertThat(result, is(Triple.of(2, 0, true)));\n+      assertThat(sortedDie, is(List.of(new Die(6, 2, Die.DieType.MISS))));\n+    }\n+\n+    @Test\n+    void singleAaWithTwoRoll() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(2);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithSamePower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithDifferentPower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(1);\n+\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMTY0MA==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502821640", "bodyText": "FYI there is a matcher to check list elements, I believe it is IsIterableContaining", "author": "DanVanAtta", "createdAt": "2020-10-10T19:03:03Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRollsTest.java", "diffHunk": "@@ -1,33 +1,690 @@\n package games.strategy.triplea.delegate.power.calculator;\n \n+import static games.strategy.triplea.Constants.RULES_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.SUPPORT_ATTACHMENT_PREFIX;\n+import static games.strategy.triplea.Constants.TERRITORYEFFECT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_DEFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_OFFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS_TYPE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.DICE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.UNIT_TYPE;\n import static games.strategy.triplea.delegate.GameDataTestUtil.territory;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import games.strategy.engine.data.GameData;\n import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.TerritoryEffect;\n import games.strategy.engine.data.Unit;\n import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.RulesAttachment;\n+import games.strategy.triplea.attachments.TerritoryEffectAttachment;\n import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import games.strategy.triplea.delegate.Die;\n import games.strategy.triplea.delegate.GameDataTestUtil;\n import games.strategy.triplea.xml.TestMapGameData;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.util.Triple;\n+import org.triplea.util.Tuple;\n \n+@ExtendWith(MockitoExtension.class)\n class TotalPowerAndTotalRollsTest {\n \n+  @Mock GamePlayer owner;\n+\n+  private Unit givenUnit(final String name, final GameData gameData) {\n+    return givenUnit(givenUnitType(name, gameData));\n+  }\n+\n+  private Unit givenUnit(final UnitType unitType) {\n+    return unitType.create(1, owner, true).get(0);\n+  }\n+\n+  private UnitType givenUnitType(final String name, final GameData gameData) {\n+    final UnitType unitType = new UnitType(name + \"Type\", gameData);\n+    final UnitAttachment unitAttachment =\n+        new UnitAttachment(name + \"Attachment\", unitType, gameData);\n+    unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+    return unitType;\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final UnitType unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount)\n+      throws MutableProperty.InvalidValueException {\n+    return givenUnitSupportAttachment(\n+        gameData, name, Set.of(unitType), rollType, bonusAmount, bonusCount);\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final Set<UnitType> unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount)\n+      throws MutableProperty.InvalidValueException {\n+\n+    return givenUnitSupportAttachment(\n+        gameData, name, unitType, rollType, bonusAmount, bonusCount, name);\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final Set<UnitType> unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount,\n+      final String bonusName)\n+      throws MutableProperty.InvalidValueException {\n+    final UnitSupportAttachment unitSupportAttachment =\n+        new UnitSupportAttachment(\n+            SUPPORT_ATTACHMENT_PREFIX + name, unitType.iterator().next(), gameData);\n+    unitSupportAttachment.getPropertyOrThrow(BONUS).setValue(bonusAmount);\n+    unitSupportAttachment\n+        .getPropertyOrThrow(BONUS_TYPE)\n+        .setValue(new UnitSupportAttachment.BonusType(\"bonus\" + bonusName, bonusCount));\n+    unitSupportAttachment.getPropertyOrThrow(DICE).setValue(rollType);\n+    unitSupportAttachment.getPropertyOrThrow(UNIT_TYPE).setValue(unitType);\n+    return unitSupportAttachment;\n+  }\n+\n+  @Nested\n+  class GetTotalAaPowerThenHitsAndFillSortedDiceThenIfAllUseSameAttack {\n+\n+    @Test\n+    void singleAaWithOneRoll() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(2, 1, true)));\n+      assertThat(sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    private Triple<Integer, Integer, Boolean> whenGetPowerHitsResult(\n+        final GameData gameData,\n+        final List<Unit> units,\n+        final List<Die> sortedDie,\n+        final int dieHit,\n+        final int numValidTargets) {\n+      final Map<Unit, TotalPowerAndTotalRolls> unitPowerAndRollsMap =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              units,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      final List<Unit> validTargets =\n+          IntStream.rangeClosed(1, numValidTargets)\n+              .mapToObj(num -> mock(Unit.class))\n+              .collect(Collectors.toList());\n+      final int totalAttacks =\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(unitPowerAndRollsMap, validTargets);\n+      final int[] dice = new int[totalAttacks];\n+      for (int i = 0; i < totalAttacks; i++) {\n+        dice[i] = dieHit;\n+      }\n+\n+      return TotalPowerAndTotalRolls.getTotalAaPowerThenHitsAndFillSortedDiceThenIfAllUseSameAttack(\n+          dice, sortedDie, false, unitPowerAndRollsMap, validTargets, gameData, true);\n+    }\n+\n+    @Test\n+    void singleAaWithOneRollNoHit() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 6, 4);\n+\n+      assertThat(result, is(Triple.of(2, 0, true)));\n+      assertThat(sortedDie, is(List.of(new Die(6, 2, Die.DieType.MISS))));\n+    }\n+\n+    @Test\n+    void singleAaWithTwoRoll() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(2);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithSamePower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithDifferentPower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(1);\n+\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(5, 2, false)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 3, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMjExMg==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502822112", "bodyText": "assertion comments giving the math behind the '8' and '4' I think would be of help.\nIt might even make sense to assert one value at a time. That would help make it simpler per assertion and better adhere to the principle for assertions to have only one thing they are checking, one reason for them to ever fail. For example:\nassertThat(\"4 rolls * 2 attack power = 8 total power\", result.getFirst(), is(8));", "author": "DanVanAtta", "createdAt": "2020-10-10T19:08:16Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/power/calculator/TotalPowerAndTotalRollsTest.java", "diffHunk": "@@ -1,33 +1,690 @@\n package games.strategy.triplea.delegate.power.calculator;\n \n+import static games.strategy.triplea.Constants.RULES_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.SUPPORT_ATTACHMENT_PREFIX;\n+import static games.strategy.triplea.Constants.TERRITORYEFFECT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_DEFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.TerritoryEffectAttachment.COMBAT_OFFENSE_EFFECT;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.BONUS_TYPE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.DICE;\n+import static games.strategy.triplea.attachments.UnitSupportAttachment.UNIT_TYPE;\n import static games.strategy.triplea.delegate.GameDataTestUtil.territory;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import games.strategy.engine.data.GameData;\n import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.TerritoryEffect;\n import games.strategy.engine.data.Unit;\n import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.RulesAttachment;\n+import games.strategy.triplea.attachments.TerritoryEffectAttachment;\n import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import games.strategy.triplea.delegate.Die;\n import games.strategy.triplea.delegate.GameDataTestUtil;\n import games.strategy.triplea.xml.TestMapGameData;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.collections.IntegerMap;\n+import org.triplea.util.Triple;\n+import org.triplea.util.Tuple;\n \n+@ExtendWith(MockitoExtension.class)\n class TotalPowerAndTotalRollsTest {\n \n+  @Mock GamePlayer owner;\n+\n+  private Unit givenUnit(final String name, final GameData gameData) {\n+    return givenUnit(givenUnitType(name, gameData));\n+  }\n+\n+  private Unit givenUnit(final UnitType unitType) {\n+    return unitType.create(1, owner, true).get(0);\n+  }\n+\n+  private UnitType givenUnitType(final String name, final GameData gameData) {\n+    final UnitType unitType = new UnitType(name + \"Type\", gameData);\n+    final UnitAttachment unitAttachment =\n+        new UnitAttachment(name + \"Attachment\", unitType, gameData);\n+    unitType.addAttachment(UNIT_ATTACHMENT_NAME, unitAttachment);\n+    return unitType;\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final UnitType unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount)\n+      throws MutableProperty.InvalidValueException {\n+    return givenUnitSupportAttachment(\n+        gameData, name, Set.of(unitType), rollType, bonusAmount, bonusCount);\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final Set<UnitType> unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount)\n+      throws MutableProperty.InvalidValueException {\n+\n+    return givenUnitSupportAttachment(\n+        gameData, name, unitType, rollType, bonusAmount, bonusCount, name);\n+  }\n+\n+  private UnitSupportAttachment givenUnitSupportAttachment(\n+      final GameData gameData,\n+      final String name,\n+      final Set<UnitType> unitType,\n+      final String rollType,\n+      final int bonusAmount,\n+      final int bonusCount,\n+      final String bonusName)\n+      throws MutableProperty.InvalidValueException {\n+    final UnitSupportAttachment unitSupportAttachment =\n+        new UnitSupportAttachment(\n+            SUPPORT_ATTACHMENT_PREFIX + name, unitType.iterator().next(), gameData);\n+    unitSupportAttachment.getPropertyOrThrow(BONUS).setValue(bonusAmount);\n+    unitSupportAttachment\n+        .getPropertyOrThrow(BONUS_TYPE)\n+        .setValue(new UnitSupportAttachment.BonusType(\"bonus\" + bonusName, bonusCount));\n+    unitSupportAttachment.getPropertyOrThrow(DICE).setValue(rollType);\n+    unitSupportAttachment.getPropertyOrThrow(UNIT_TYPE).setValue(unitType);\n+    return unitSupportAttachment;\n+  }\n+\n+  @Nested\n+  class GetTotalAaPowerThenHitsAndFillSortedDiceThenIfAllUseSameAttack {\n+\n+    @Test\n+    void singleAaWithOneRoll() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(2, 1, true)));\n+      assertThat(sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    private Triple<Integer, Integer, Boolean> whenGetPowerHitsResult(\n+        final GameData gameData,\n+        final List<Unit> units,\n+        final List<Die> sortedDie,\n+        final int dieHit,\n+        final int numValidTargets) {\n+      final Map<Unit, TotalPowerAndTotalRolls> unitPowerAndRollsMap =\n+          TotalPowerAndTotalRolls.getAaUnitPowerAndRollsForNormalBattles(\n+              units,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              SupportCalculationResult.EMPTY_RESULT,\n+              false,\n+              gameData);\n+\n+      final List<Unit> validTargets =\n+          IntStream.rangeClosed(1, numValidTargets)\n+              .mapToObj(num -> mock(Unit.class))\n+              .collect(Collectors.toList());\n+      final int totalAttacks =\n+          TotalPowerAndTotalRolls.getTotalAaAttacks(unitPowerAndRollsMap, validTargets);\n+      final int[] dice = new int[totalAttacks];\n+      for (int i = 0; i < totalAttacks; i++) {\n+        dice[i] = dieHit;\n+      }\n+\n+      return TotalPowerAndTotalRolls.getTotalAaPowerThenHitsAndFillSortedDiceThenIfAllUseSameAttack(\n+          dice, sortedDie, false, unitPowerAndRollsMap, validTargets, gameData, true);\n+    }\n+\n+    @Test\n+    void singleAaWithOneRollNoHit() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 6, 4);\n+\n+      assertThat(result, is(Triple.of(2, 0, true)));\n+      assertThat(sortedDie, is(List.of(new Die(6, 2, Die.DieType.MISS))));\n+    }\n+\n+    @Test\n+    void singleAaWithTwoRoll() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(2);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithSamePower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithDifferentPower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(1);\n+\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(5, 2, false)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 3, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithDifferentPowerAndOnlyOneHit() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 2, 4);\n+\n+      assertThat(result, is(Triple.of(5, 1, false)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(2, 3, Die.DieType.HIT), new Die(2, 2, Die.DieType.MISS))));\n+    }\n+\n+    @Test\n+    void oneAaWithInfinite() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(-1);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(8, 4, true)));\n+      assertThat(\n+          sortedDie,\n+          is(\n+              List.of(\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithInfiniteWithSamePower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(-1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(-1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(8, 4, true)));\n+      assertThat(\n+          sortedDie,\n+          is(\n+              List.of(\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithInfiniteWithDifferentPower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(-1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(-1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(12, 4, true)));\n+      assertThat(\n+          sortedDie,\n+          is(\n+              List.of(\n+                  new Die(1, 3, Die.DieType.HIT),\n+                  new Die(1, 3, Die.DieType.HIT),\n+                  new Die(1, 3, Die.DieType.HIT),\n+                  new Die(1, 3, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithInfiniteWithDifferentDice() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment()\n+          .setOffensiveAttackAa(2)\n+          .setMaxAaAttacks(-1)\n+          .setOffensiveAttackAaMaxDieSides(4);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2\n+          .getUnitAttachment()\n+          .setOffensiveAttackAa(3)\n+          .setMaxAaAttacks(-1)\n+          .setOffensiveAttackAaMaxDieSides(8);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(8, 4, true)));\n+      assertThat(\n+          \"2 of 4 is better than 3 of 8 so that is used for attack\",\n+          sortedDie,\n+          is(\n+              List.of(\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithOneRollAndInfiniteSamePower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(-1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(8, 4, true)));\n+      assertThat(\n+          sortedDie,\n+          is(\n+              List.of(\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithOneRollAndInfiniteWhereInfiniteIsHigher() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(-1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(12, 4, true)));\n+      assertThat(\n+          \"The non infinite attack is never used\",\n+          sortedDie,\n+          is(\n+              List.of(\n+                  new Die(1, 3, Die.DieType.HIT),\n+                  new Die(1, 3, Die.DieType.HIT),\n+                  new Die(1, 3, Die.DieType.HIT),\n+                  new Die(1, 3, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void twoAaWithOneRollAndInfiniteWhereInfiniteIsLower() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(3).setMaxAaAttacks(1);\n+      final Unit unit2 = givenUnit(\"test2\", gameData);\n+      unit2.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(-1);\n+      final List<Unit> units = List.of(unit, unit2);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(9, 4, false)));\n+      assertThat(\n+          \"The non infinite attack is used first\",\n+          sortedDie,\n+          is(\n+              List.of(\n+                  new Die(1, 3, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void oneAaWithOverStack() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(2).setMayOverStackAa(true);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(4, 2, true)));\n+      assertThat(\n+          sortedDie, is(List.of(new Die(1, 2, Die.DieType.HIT), new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void oneAaWithOverStackAndMoreRollsThanTargets() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(5).setMayOverStackAa(true);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(10, 5, true)));\n+      assertThat(\n+          sortedDie,\n+          is(\n+              List.of(\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT),\n+                  new Die(1, 2, Die.DieType.HIT))));\n+    }\n+\n+    @Test\n+    void oneAaWithOverstackAndInfinite() {\n+      final GameData gameData = givenGameData().withDiceSides(6).build();\n+      final Unit unit = givenUnit(\"test\", gameData);\n+      unit.getUnitAttachment().setOffensiveAttackAa(2).setMaxAaAttacks(-1).setMayOverStackAa(true);\n+      final List<Unit> units = List.of(unit);\n+      final List<Die> sortedDie = new ArrayList<>();\n+\n+      final Triple<Integer, Integer, Boolean> result =\n+          whenGetPowerHitsResult(gameData, units, sortedDie, 1, 4);\n+\n+      assertThat(result, is(Triple.of(8, 4, true)));", "originalCommit": "a031c9f76c49258ac8bfbaaf042e84a4aed6d744", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjkzNDE5Nw==", "url": "https://github.com/triplea-game/triplea/pull/7859#discussion_r502934197", "bodyText": "@trevan  bump ^", "author": "DanVanAtta", "createdAt": "2020-10-11T16:02:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMjExMg=="}], "type": "inlineReview"}]}