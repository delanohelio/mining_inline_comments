{"pr_number": 7596, "pr_title": "Update: convert game parser to use xml-reader and map-data (StAX based parser)", "pr_createdAt": "2020-09-10T05:36:14Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7596", "timeline": [{"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2", "url": "https://github.com/triplea-game/triplea/commit/62bcddd25e634e7c735c48521db605016e4fc7e2", "message": "Update: convert game parser to use xml-reader and map-data (StAX based parser)\n\n- Changes GameParser over to use xml-reader & map-data\n This conversion allows for more flexibility when parsing as we can more\n easily get the same different from different locations.\n\n- Game parsing no longer requires or uses a DTD\n This gives us flexibility going forward if change tags, an old or new map\n that does not conform to such a standard would not get a DTD failure\n and we can help migrate the compatibility in code. DTD is still\n useful for validation and we should see about building a map validation\n tool that would use it.\n\n- GameParsing becomes simpler, it now assembles a GameData instead of\n parsing XML. The details of XML parsing are removed and things like\n checking for child nodes is removed and we get native java types\n that are already converted to for example integers or booleans.", "committedDate": "2020-09-10T05:42:06Z", "type": "commit"}, {"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2", "url": "https://github.com/triplea-game/triplea/commit/62bcddd25e634e7c735c48521db605016e4fc7e2", "message": "Update: convert game parser to use xml-reader and map-data (StAX based parser)\n\n- Changes GameParser over to use xml-reader & map-data\n This conversion allows for more flexibility when parsing as we can more\n easily get the same different from different locations.\n\n- Game parsing no longer requires or uses a DTD\n This gives us flexibility going forward if change tags, an old or new map\n that does not conform to such a standard would not get a DTD failure\n and we can help migrate the compatibility in code. DTD is still\n useful for validation and we should see about building a map validation\n tool that would use it.\n\n- GameParsing becomes simpler, it now assembles a GameData instead of\n parsing XML. The details of XML parsing are removed and things like\n checking for child nodes is removed and we get native java types\n that are already converted to for example integers or booleans.", "committedDate": "2020-09-10T05:42:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NTQyOA==", "url": "https://github.com/triplea-game/triplea/pull/7596#discussion_r486085428", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-09-10T06:04:13Z", "path": "game-core/src/main/java/games/strategy/engine/data/gameparser/GameParser.java", "diffHunk": "@@ -618,216 +554,204 @@ private void parseDelegates(final List<Element> delegateList) throws GameParseEx\n     }\n   }\n \n-  private void parseSequence(final Node sequence) throws GameParseException {\n-    parseSteps(getChildren(\"step\", sequence));\n-  }\n-\n-  private void parseSteps(final List<Element> stepList) throws GameParseException {\n-    for (final Element current : stepList) {\n-      final IDelegate delegate = getDelegate(current.getAttribute(\"delegate\"));\n-      final GamePlayer player = getPlayerIdOptional(current.getAttribute(\"player\")).orElse(null);\n-      final String name = current.getAttribute(\"name\");\n+  private void parseSteps(final List<GamePlay.Sequence.Step> stepList) throws GameParseException {\n+    for (final GamePlay.Sequence.Step current : stepList) {\n+      final IDelegate delegate = getDelegate(current.getDelegate());\n+      final GamePlayer player = getPlayerIdOptional(current.getPlayer()).orElse(null);\n+      final String name = current.getName();\n       String displayName = null;\n-      final List<Element> propertyElements = getChildren(\"stepProperty\", current);\n-      final Properties stepProperties = parseStepProperties(propertyElements);\n-      if (current.hasAttribute(\"display\")) {\n-        displayName = current.getAttribute(\"display\");\n+      final Properties stepProperties = parseStepProperties(current.getStepProperties());\n+      if (!current.getDisplay().isBlank()) {\n+        displayName = current.getDisplay();\n       }\n       final GameStep step = new GameStep(name, displayName, player, delegate, data, stepProperties);\n-      if (current.hasAttribute(\"maxRunCount\")) {\n-        final int runCount = Integer.parseInt(current.getAttribute(\"maxRunCount\"));\n-        if (runCount <= 0) {\n-          throw new GameParseException(\"maxRunCount must be positive\");\n-        }\n-        step.setMaxRunCount(runCount);\n+      if (current.getMaxRunCount() > 0) {\n+        step.setMaxRunCount(current.getMaxRunCount());\n       }\n       data.getSequence().addStep(step);\n     }\n   }\n \n-  private static Properties parseStepProperties(final List<Element> properties) {\n+  private static Properties parseStepProperties(\n+      final List<GamePlay.Sequence.Step.StepProperty> properties) {\n     final Properties stepProperties = new Properties();\n-    for (final Element stepProperty : properties) {\n-      final String name = stepProperty.getAttribute(\"name\");\n-      final String value = stepProperty.getAttribute(\"value\");\n-      stepProperties.setProperty(name, value);\n-    }\n+    properties.forEach(\n+        stepProperty ->\n+            stepProperties.setProperty(stepProperty.getName(), stepProperty.getValue()));\n     return stepProperties;\n   }\n \n-  private void parseProduction(final Node root) throws GameParseException {\n-    parseProductionRules(getChildren(\"productionRule\", root));\n-    parseProductionFrontiers(getChildren(\"productionFrontier\", root));\n-    parsePlayerProduction(getChildren(\"playerProduction\", root));\n-    parseRepairRules(getChildren(\"repairRule\", root));\n-    parseRepairFrontiers(getChildren(\"repairFrontier\", root));\n-    parsePlayerRepair(getChildren(\"playerRepair\", root));\n-  }\n-\n-  private void parseTechnology(final Node root) throws GameParseException {\n-    parseTechnologies(getSingleChildOptional(\"technologies\", root).orElse(null));\n-    parsePlayerTech(getChildren(\"playerTech\", root));\n-  }\n-\n-  private void parseProductionRules(final List<Element> elements) throws GameParseException {\n-    for (final Element current : elements) {\n-      final String name = current.getAttribute(\"name\");\n+  private void parseProductionRules(final List<Production.ProductionRule> elements)\n+      throws GameParseException {\n+    for (final Production.ProductionRule current : elements) {\n+      final String name = current.getName();\n       final ProductionRule rule = new ProductionRule(name, data);\n-      parseCosts(rule, getChildren(\"cost\", current));\n-      parseResults(rule, getChildren(\"result\", current));\n+      parseCosts(rule, current.getCosts());\n+      parseResults(rule, current.getResults());\n       data.getProductionRuleList().addProductionRule(rule);\n     }\n   }\n \n-  private void parseRepairRules(final List<Element> elements) throws GameParseException {\n-    for (final Element current : elements) {\n-      final String name = current.getAttribute(\"name\");\n-      final RepairRule rule = new RepairRule(name, data);\n-      parseRepairCosts(rule, getChildren(\"cost\", current));\n-      parseRepairResults(rule, getChildren(\"result\", current));\n+  private void parseRepairRules(final List<Production.RepairRule> elements)\n+      throws GameParseException {\n+    for (final Production.RepairRule current : elements) {\n+      final RepairRule rule = new RepairRule(current.getName(), data);\n+      parseRepairCosts(rule, current.getCosts());\n+      parseRepairResults(rule, current.getResults());\n       data.getRepairRules().addRepairRule(rule);\n     }\n   }\n \n-  private void parseCosts(final ProductionRule rule, final List<Element> elements)\n+  private void parseCosts(\n+      final ProductionRule rule, final List<Production.ProductionRule.Cost> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no costs  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n-      final Resource resource = getResource(current.getAttribute(\"resource\"));\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+    for (final Production.ProductionRule.Cost current : elements) {\n+      final Resource resource = getResource(current.getResource());\n+      final int quantity = current.getQuantity();\n       rule.addCost(resource, quantity);\n     }\n   }\n \n-  private void parseRepairCosts(final RepairRule rule, final List<Element> elements)\n+  private void parseRepairCosts(\n+      final RepairRule rule, final List<Production.ProductionRule.Cost> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no costs  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n-      final Resource resource = getResource(current.getAttribute(\"resource\"));\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+    for (final Production.ProductionRule.Cost current : elements) {\n+      final Resource resource = getResource(current.getResource());\n+      final int quantity = current.getQuantity();\n       rule.addCost(resource, quantity);\n     }\n   }\n \n-  private void parseResults(final ProductionRule rule, final List<Element> elements)\n+  private void parseResults(", "originalCommit": "62bcddd25e634e7c735c48521db605016e4fc7e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NTQzMA==", "url": "https://github.com/triplea-game/triplea/pull/7596#discussion_r486085430", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-09-10T06:04:13Z", "path": "game-core/src/main/java/games/strategy/engine/data/gameparser/GameParser.java", "diffHunk": "@@ -618,216 +554,204 @@ private void parseDelegates(final List<Element> delegateList) throws GameParseEx\n     }\n   }\n \n-  private void parseSequence(final Node sequence) throws GameParseException {\n-    parseSteps(getChildren(\"step\", sequence));\n-  }\n-\n-  private void parseSteps(final List<Element> stepList) throws GameParseException {\n-    for (final Element current : stepList) {\n-      final IDelegate delegate = getDelegate(current.getAttribute(\"delegate\"));\n-      final GamePlayer player = getPlayerIdOptional(current.getAttribute(\"player\")).orElse(null);\n-      final String name = current.getAttribute(\"name\");\n+  private void parseSteps(final List<GamePlay.Sequence.Step> stepList) throws GameParseException {\n+    for (final GamePlay.Sequence.Step current : stepList) {\n+      final IDelegate delegate = getDelegate(current.getDelegate());\n+      final GamePlayer player = getPlayerIdOptional(current.getPlayer()).orElse(null);\n+      final String name = current.getName();\n       String displayName = null;\n-      final List<Element> propertyElements = getChildren(\"stepProperty\", current);\n-      final Properties stepProperties = parseStepProperties(propertyElements);\n-      if (current.hasAttribute(\"display\")) {\n-        displayName = current.getAttribute(\"display\");\n+      final Properties stepProperties = parseStepProperties(current.getStepProperties());\n+      if (!current.getDisplay().isBlank()) {\n+        displayName = current.getDisplay();\n       }\n       final GameStep step = new GameStep(name, displayName, player, delegate, data, stepProperties);\n-      if (current.hasAttribute(\"maxRunCount\")) {\n-        final int runCount = Integer.parseInt(current.getAttribute(\"maxRunCount\"));\n-        if (runCount <= 0) {\n-          throw new GameParseException(\"maxRunCount must be positive\");\n-        }\n-        step.setMaxRunCount(runCount);\n+      if (current.getMaxRunCount() > 0) {\n+        step.setMaxRunCount(current.getMaxRunCount());\n       }\n       data.getSequence().addStep(step);\n     }\n   }\n \n-  private static Properties parseStepProperties(final List<Element> properties) {\n+  private static Properties parseStepProperties(\n+      final List<GamePlay.Sequence.Step.StepProperty> properties) {\n     final Properties stepProperties = new Properties();\n-    for (final Element stepProperty : properties) {\n-      final String name = stepProperty.getAttribute(\"name\");\n-      final String value = stepProperty.getAttribute(\"value\");\n-      stepProperties.setProperty(name, value);\n-    }\n+    properties.forEach(\n+        stepProperty ->\n+            stepProperties.setProperty(stepProperty.getName(), stepProperty.getValue()));\n     return stepProperties;\n   }\n \n-  private void parseProduction(final Node root) throws GameParseException {\n-    parseProductionRules(getChildren(\"productionRule\", root));\n-    parseProductionFrontiers(getChildren(\"productionFrontier\", root));\n-    parsePlayerProduction(getChildren(\"playerProduction\", root));\n-    parseRepairRules(getChildren(\"repairRule\", root));\n-    parseRepairFrontiers(getChildren(\"repairFrontier\", root));\n-    parsePlayerRepair(getChildren(\"playerRepair\", root));\n-  }\n-\n-  private void parseTechnology(final Node root) throws GameParseException {\n-    parseTechnologies(getSingleChildOptional(\"technologies\", root).orElse(null));\n-    parsePlayerTech(getChildren(\"playerTech\", root));\n-  }\n-\n-  private void parseProductionRules(final List<Element> elements) throws GameParseException {\n-    for (final Element current : elements) {\n-      final String name = current.getAttribute(\"name\");\n+  private void parseProductionRules(final List<Production.ProductionRule> elements)\n+      throws GameParseException {\n+    for (final Production.ProductionRule current : elements) {\n+      final String name = current.getName();\n       final ProductionRule rule = new ProductionRule(name, data);\n-      parseCosts(rule, getChildren(\"cost\", current));\n-      parseResults(rule, getChildren(\"result\", current));\n+      parseCosts(rule, current.getCosts());\n+      parseResults(rule, current.getResults());\n       data.getProductionRuleList().addProductionRule(rule);\n     }\n   }\n \n-  private void parseRepairRules(final List<Element> elements) throws GameParseException {\n-    for (final Element current : elements) {\n-      final String name = current.getAttribute(\"name\");\n-      final RepairRule rule = new RepairRule(name, data);\n-      parseRepairCosts(rule, getChildren(\"cost\", current));\n-      parseRepairResults(rule, getChildren(\"result\", current));\n+  private void parseRepairRules(final List<Production.RepairRule> elements)\n+      throws GameParseException {\n+    for (final Production.RepairRule current : elements) {\n+      final RepairRule rule = new RepairRule(current.getName(), data);\n+      parseRepairCosts(rule, current.getCosts());\n+      parseRepairResults(rule, current.getResults());\n       data.getRepairRules().addRepairRule(rule);\n     }\n   }\n \n-  private void parseCosts(final ProductionRule rule, final List<Element> elements)\n+  private void parseCosts(\n+      final ProductionRule rule, final List<Production.ProductionRule.Cost> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no costs  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n-      final Resource resource = getResource(current.getAttribute(\"resource\"));\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+    for (final Production.ProductionRule.Cost current : elements) {\n+      final Resource resource = getResource(current.getResource());\n+      final int quantity = current.getQuantity();\n       rule.addCost(resource, quantity);\n     }\n   }\n \n-  private void parseRepairCosts(final RepairRule rule, final List<Element> elements)\n+  private void parseRepairCosts(\n+      final RepairRule rule, final List<Production.ProductionRule.Cost> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no costs  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n-      final Resource resource = getResource(current.getAttribute(\"resource\"));\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+    for (final Production.ProductionRule.Cost current : elements) {\n+      final Resource resource = getResource(current.getResource());\n+      final int quantity = current.getQuantity();\n       rule.addCost(resource, quantity);\n     }\n   }\n \n-  private void parseResults(final ProductionRule rule, final List<Element> elements)\n+  private void parseResults(\n+      final ProductionRule rule, final List<Production.ProductionRule.Result> elements)\n       throws GameParseException {\n     if (elements.isEmpty()) {\n       throw new GameParseException(\"no results  for rule:\" + rule.getName());\n     }\n-    for (final Element current : elements) {\n+    for (final Production.ProductionRule.Result current : elements) {\n       // must find either a resource or a unit with the given name\n-      NamedAttachable result =\n-          getResourceOptional(current.getAttribute(\"resourceOrUnit\")).orElse(null);\n+      NamedAttachable result = getResourceOptional(current.getResourceOrUnit()).orElse(null);\n       if (result == null) {\n-        result = getUnitTypeOptional(current.getAttribute(\"resourceOrUnit\")).orElse(null);\n+        result = getUnitTypeOptional(current.getResourceOrUnit()).orElse(null);\n       }\n       if (result == null) {\n         throw new GameParseException(\n-            \"Could not find resource or unit\" + current.getAttribute(\"resourceOrUnit\"));\n+            \"Could not find resource or unit\" + current.getResourceOrUnit());\n       }\n-      final int quantity = Integer.parseInt(current.getAttribute(\"quantity\"));\n+      final int quantity = current.getQuantity();\n       rule.addResult(result, quantity);\n     }\n   }\n \n-  private void parseRepairResults(final RepairRule rule, final List<Element> elements)\n+  private void parseRepairResults(", "originalCommit": "62bcddd25e634e7c735c48521db605016e4fc7e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7becf1eec61d342f6fc3717dd604b8677c67b017", "url": "https://github.com/triplea-game/triplea/commit/7becf1eec61d342f6fc3717dd604b8677c67b017", "message": "Install a newer version of Java in Travis\n\nGetting an odd parse error within CDATA of an XML.\nThe java version on travis is a bit dated, trying\na newer JDK to resolve.", "committedDate": "2020-09-10T07:33:20Z", "type": "forcePushed"}, {"oid": "62bcddd25e634e7c735c48521db605016e4fc7e2", "url": "https://github.com/triplea-game/triplea/commit/62bcddd25e634e7c735c48521db605016e4fc7e2", "message": "Update: convert game parser to use xml-reader and map-data (StAX based parser)\n\n- Changes GameParser over to use xml-reader & map-data\n This conversion allows for more flexibility when parsing as we can more\n easily get the same different from different locations.\n\n- Game parsing no longer requires or uses a DTD\n This gives us flexibility going forward if change tags, an old or new map\n that does not conform to such a standard would not get a DTD failure\n and we can help migrate the compatibility in code. DTD is still\n useful for validation and we should see about building a map validation\n tool that would use it.\n\n- GameParsing becomes simpler, it now assembles a GameData instead of\n parsing XML. The details of XML parsing are removed and things like\n checking for child nodes is removed and we get native java types\n that are already converted to for example integers or booleans.", "committedDate": "2020-09-10T05:42:06Z", "type": "forcePushed"}, {"oid": "4dfa3ee5a62649cbfe5caa6927b50eca3b48b8cb", "url": "https://github.com/triplea-game/triplea/commit/4dfa3ee5a62649cbfe5caa6927b50eca3b48b8cb", "message": "Keep parse exceptions at severe level.\n\nWhile this could create noise with error reports, knowing the frequency\nand why players hit parse exceptions can be useful. For example\notherwise we would have not known about the continued prevelance\nof 'attatchment' parse errors.", "committedDate": "2020-09-11T03:23:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzYwNjkwMw==", "url": "https://github.com/triplea-game/triplea/pull/7596#discussion_r487606903", "bodyText": "I wonder where this check comes from. If the list is empty the for loop shouldn't iterate a single time and getRelationShipTracker doesn't look like it would throw an exception", "author": "RoiEXLab", "createdAt": "2020-09-14T01:23:04Z", "path": "game-core/src/main/java/games/strategy/engine/data/gameparser/GameParser.java", "diffHunk": "@@ -395,149 +371,118 @@ private void parseResources(final Element root) throws GameParseException {\n     return players;\n   }\n \n-  private void parseRelationshipTypes(final Element root) {\n-    getChildren(\"relationshipType\", root).stream()\n-        .map(e -> e.getAttribute(\"name\"))\n+  private void parseRelationshipTypes(final RelationshipTypes relationshipTypes) {\n+    relationshipTypes.getRelationshipTypes().stream()\n+        .map(RelationshipTypes.RelationshipType::getName)\n         .map(name -> new RelationshipType(name, data))\n         .forEach(data.getRelationshipTypeList()::addRelationshipType);\n   }\n \n-  private void parseTerritoryEffects(final Element root) {\n-    getChildren(\"territoryEffect\", root).stream()\n-        .map(e -> e.getAttribute(\"name\"))\n+  private void parseTerritoryEffects(final TerritoryEffectList territoryEffectList) {\n+    territoryEffectList.getTerritoryEffects().stream()\n+        .map(TerritoryEffectList.TerritoryEffect::getName)\n         .forEach(name -> data.getTerritoryEffectList().put(name, new TerritoryEffect(name, data)));\n   }\n \n-  private void parseUnits(final Element root) {\n-    getChildren(\"unit\", root).stream()\n-        .map(e -> e.getAttribute(\"name\"))\n+  private void parseUnits(final UnitList unitList) {\n+    unitList.getUnits().stream()\n+        .map(UnitList.Unit::getName)\n         .map(name -> new UnitType(name, data))\n         .forEach(data.getUnitTypeList()::addUnitType);\n   }\n \n-  private void parsePlayerList(final Element root) {\n-    final PlayerList playerList = data.getPlayerList();\n-    for (final Element current : getChildren(\"player\", root)) {\n-      final String name = current.getAttribute(\"name\");\n-      final boolean isOptional = current.getAttribute(\"optional\").equals(\"true\");\n-      final boolean canBeDisabled = current.getAttribute(\"canBeDisabled\").equals(\"true\");\n-      final String defaultType = current.getAttribute(\"defaultType\");\n-      final boolean isHidden = current.getAttribute(\"isHidden\").equals(\"true\");\n-      final GamePlayer newPlayer =\n-          new GamePlayer(name, isOptional, canBeDisabled, defaultType, isHidden, data);\n-      playerList.addPlayerId(newPlayer);\n-    }\n-  }\n-\n-  private void parseAlliances(final Element root) throws GameParseException {\n+  private void parsePlayerList(final PlayerList playerListData) {\n+    playerListData\n+        .getPlayers()\n+        .forEach(\n+            current ->\n+                data.getPlayerList()\n+                    .addPlayerId(\n+                        new GamePlayer(\n+                            current.getName(),\n+                            current.isOptional(),\n+                            current.isCanBeDisabled(),\n+                            current.getDefaultType(),\n+                            current.isHidden(),\n+                            data)));\n+  }\n+\n+  private void parseAlliances(final Game game) throws GameParseException {\n     final AllianceTracker allianceTracker = data.getAllianceTracker();\n     final Collection<GamePlayer> players = data.getPlayerList().getPlayers();\n-    for (final Element current : getChildren(\"alliance\", root)) {\n-      final GamePlayer p1 = getPlayerId(current.getAttribute(\"player\"));\n-      final String alliance = current.getAttribute(\"alliance\");\n+\n+    for (final PlayerList.Alliance current : game.getPlayerList().getAlliances()) {\n+      final GamePlayer p1 = getPlayerId(current.getPlayer());\n+      final String alliance = current.getAlliance();\n       allianceTracker.addToAlliance(p1, alliance);\n     }\n-    // if relationships aren't initialized based on relationshipInitialize we use the alliances to\n-    // set the relationships\n-    if (getSingleChildOptional(\"relationshipInitialize\", root).orElse(null) == null) {\n-      final RelationshipTracker relationshipTracker = data.getRelationshipTracker();\n-      final RelationshipTypeList relationshipTypeList = data.getRelationshipTypeList();\n-      // iterate through all players to get known allies and enemies\n-      for (final GamePlayer currentPlayer : players) {\n-        // start with all players as enemies\n-        // start with no players as allies\n-        final Set<GamePlayer> allies = allianceTracker.getAllies(currentPlayer);\n-        final Set<GamePlayer> enemies = new HashSet<>(players);\n-        enemies.removeAll(allies);\n-\n-        // remove self from enemies list (in case of free-for-all)\n-        enemies.remove(currentPlayer);\n-        // remove self from allies list (in case you are a member of an alliance)\n-        allies.remove(currentPlayer);\n-        // At this point enemies and allies should be set for this player.\n-        for (final GamePlayer alliedPLayer : allies) {\n-          relationshipTracker.setRelationship(\n-              currentPlayer, alliedPLayer, relationshipTypeList.getDefaultAlliedRelationship());\n-        }\n-        for (final GamePlayer enemyPlayer : enemies) {\n-          relationshipTracker.setRelationship(\n-              currentPlayer, enemyPlayer, relationshipTypeList.getDefaultWarRelationship());\n-        }\n+    final RelationshipTracker relationshipTracker = data.getRelationshipTracker();\n+    final RelationshipTypeList relationshipTypeList = data.getRelationshipTypeList();\n+    // iterate through all players to get known allies and enemies\n+    for (final GamePlayer currentPlayer : players) {\n+      // start with all players as enemies\n+      // start with no players as allies\n+      final Set<GamePlayer> allies = allianceTracker.getAllies(currentPlayer);\n+      final Set<GamePlayer> enemies = new HashSet<>(players);\n+      enemies.removeAll(allies);\n+\n+      // remove self from enemies list (in case of free-for-all)\n+      enemies.remove(currentPlayer);\n+      // remove self from allies list (in case you are a member of an alliance)\n+      allies.remove(currentPlayer);\n+      // At this point enemies and allies should be set for this player.\n+      for (final GamePlayer alliedPLayer : allies) {\n+        relationshipTracker.setRelationship(\n+            currentPlayer, alliedPLayer, relationshipTypeList.getDefaultAlliedRelationship());\n+      }\n+      for (final GamePlayer enemyPlayer : enemies) {\n+        relationshipTracker.setRelationship(\n+            currentPlayer, enemyPlayer, relationshipTypeList.getDefaultWarRelationship());\n       }\n     }\n   }\n \n-  private void parseRelationInitialize(final List<Element> relations) throws GameParseException {\n-    if (!relations.isEmpty()) {\n+  private void parseRelationInitialize(final Initialize.RelationshipInitialize relations)\n+      throws GameParseException {\n+    if (!relations.getRelationships().isEmpty()) {", "originalCommit": "4dfa3ee5a62649cbfe5caa6927b50eca3b48b8cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}