{"pr_number": 6719, "pr_title": "Create OffensiveSubsRetreat step", "pr_createdAt": "2020-06-19T02:02:33Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6719", "timeline": [{"oid": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "url": "https://github.com/triplea-game/triplea/commit/7ee6bce0e081196f6d91dab82b0f52dcde09890a", "message": "Create OffensiveSubsRetreat step", "committedDate": "2020-06-19T01:22:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5MjYyNg==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442592626", "bodyText": "I couldn't use @Getter because isOver is a Boolean and not a boolean.  @Getter will create a is function only for boolean.  I could change isOver to be a boolean and then I can't have the @NonNull.", "author": "trevan", "createdAt": "2020-06-19T02:05:05Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -51,24 +55,49 @@\n   final @NonNull Collection<Unit> defendingUnits;\n \n   final @NonNull Collection<Unit> attackingWaitingToDie;\n+\n+  @Getter(onMethod = @__({@Override}))\n   final @NonNull Collection<Unit> defendingWaitingToDie;\n+\n   final @NonNull Territory battleSite;\n+\n+  @Getter(onMethod = @__({@Override}))\n   final @NonNull GameData gameData;\n+\n   final @NonNull Collection<Unit> bombardingUnits;\n   final @NonNull Function<Collection<Unit>, Collection<Unit>> getDependentUnits;\n   final @NonNull Boolean isBattleSiteWater;\n+\n   final @NonNull Boolean isAmphibious;\n   final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n   final @NonNull Function<Collection<Unit>, Collection<Territory>> getEmptyOrFriendlySeaNeighbors;\n   final @NonNull BattleActions battleActions;\n \n+  final @NonNull Boolean isOver;\n+\n+  @Override\n+  public Collection<Territory> getAttackerRetreatTerritories() {\n+    return getAttackerRetreatTerritories.get();\n+  }\n+\n+  @Override\n+  public boolean isOver() {", "originalCommit": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5MzYwMA==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442593600", "bodyText": "I figured out why destroyers weren't being checked and it was correct.  The else after this (where it calls canAttackerRetreatSubs) shouldn't have been checking for destroyers either.  I was able to trigger an error in the UI in that else case.", "author": "trevan", "createdAt": "2020-06-19T02:09:22Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -185,22 +214,8 @@\n     // remove casualties\n     steps.add(REMOVE_CASUALTIES);\n     // retreat attacking subs\n-    if (attackingUnits.stream().anyMatch(Matches.unitCanEvade())) {\n-      if (Properties.getSubmersibleSubs(gameData)) {\n-        // TODO: BUG? Should the presence of destroyers be checked?", "originalCommit": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMyOA==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442594328", "bodyText": "I'm not sure about keeping this logic.  It only works as long as nothing can kill the destroyer before the sub has a chance to retreat.  Since the sub can retreat at the beginning of the battle, the only thing that fires before its retreat is AA guns.  And if a map has an AA gun that can target destroyers, then an error could occur.\nWould you expect AA guns that can target destroyers?  I could either remove this logic or change it to go through all of the units, figure out if there are any AA guns and determine if they can target all of the destroyers in the defenders side.  I lean towards removing the logic.  It'll mean that the withdraw/submerge step will show up more often in the UI then it did previously.", "author": "trevan", "createdAt": "2020-06-19T02:12:25Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreat.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_SUBMERGE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBS_WITHDRAW;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStep.Order.SUB_OFFENSIVE_RETREAT_AFTER_BATTLE;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStep.Order.SUB_OFFENSIVE_RETREAT_BEFORE_BATTLE;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.RetreatType;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+@AllArgsConstructor\n+public class OffensiveSubsRetreat implements BattleStep {\n+\n+  private static final long serialVersionUID = -244024585102561887L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    if (!isEvaderPresent() || !isRetreatPossible()) {\n+      return List.of();\n+    }\n+\n+    if (getOrder() == SUB_OFFENSIVE_RETREAT_BEFORE_BATTLE && isDestroyerPresent()) {", "originalCommit": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3ODYyNg==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443278626", "bodyText": "It seems a bit questionable either way. Not sure I have a strong opinion to remove it. I'd opt personally to leave as-is for now. If changed, would be good to have it be a change on its own and a complete analysis of what we're updating (how often we see the display when we don't need to).\nI think the real fix is to make the concepts more generic and check for those.\nIE: firstStrikeUnit and firstStrikeCounterUnit. You then have a 'first strike' label present and it's neutralized if you have a counter unit. We also need to keep in mind that the rulesets can vary as well and that we may need to make whether that happens or not completely configurable.", "author": "DanVanAtta", "createdAt": "2020-06-22T01:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI4MzQxOQ==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443283419", "bodyText": "Even if the concepts become more generic, the problem still exists.  The main reasons are:\n\nA battle has up to 3 places where casualties are removed and can't fire back.  This is after the AA battle, the sub battle, and bombardment.\nThe collection of steps to show to the user happen at the very beginning of a round before any steps actually occur.\n\nSo if there is a firstStrikeUnit and a firstStrikeCounterUnit, you would normally think that the firstStrikeWithdrawStep would not happen since there is a counter unit.  But if the AA part happens before the firstStrikeWithdrawStep and the firstStrikeCounterUnit is killed, it is removed from the battle and no longer prevents the firstStrikeWithdrawStep.  So you would actually need to show the firstStrikeWithdrawStep.\nBut I'll leave the check here since it was how it was originally.", "author": "trevan", "createdAt": "2020-06-22T01:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI4OTg3NA==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443289874", "bodyText": "If a step is valid at the beginning of combat, and then is removed, that could be fine. Perhaps nicer to visualize that it no longer applied. Overall, AFAIK, the number one requested feature for combat phases is the ability to \"walk back in time\" by clicking the phases to see what happened during that phase - very similar to how the history mode works.\nFWIW, keeping as-is for now seems prudent, keeping this just to a refactor update.  \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-06-22T02:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDY1NQ==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442594655", "bodyText": "All of these tests have been moved to the OffensiveSubsRetreat tests.", "author": "trevan", "createdAt": "2020-06-19T02:13:52Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -448,240 +444,6 @@ void offensiveAndDefensiveAaFire() {\n         is(2));\n   }\n \n-  @Test", "originalCommit": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NTE3Ng==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r442595176", "bodyText": "What do you think of this class?  I was wanting a fluent way to generate a mock GameData.", "author": "trevan", "createdAt": "2020-06-19T02:16:19Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {", "originalCommit": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzIwMA==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443277200", "bodyText": "Not too shabby \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-06-22T01:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NTE3Ng=="}], "type": "inlineReview"}, {"oid": "a56a4eb695009814f21fcd42d532d884444c6028", "url": "https://github.com/triplea-game/triplea/commit/a56a4eb695009814f21fcd42d532d884444c6028", "message": "Fix checkstyle", "committedDate": "2020-06-19T02:19:20Z", "type": "commit"}, {"oid": "b427ccf74fd2d539b4ed13a2af93f270bc8caee7", "url": "https://github.com/triplea-game/triplea/commit/b427ccf74fd2d539b4ed13a2af93f270bc8caee7", "message": "Correct the location of the test file", "committedDate": "2020-06-19T02:45:16Z", "type": "commit"}, {"oid": "c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c", "url": "https://github.com/triplea-game/triplea/commit/c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c", "message": "Auto-Formatting", "committedDate": "2020-06-19T02:47:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjE0Mg==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443276142", "bodyText": "nit, if you have to parameterize the display name, I think we might be parameterizing 'wrong'\nThe display name should likely be a constant for any test, the only thing that is changing are just values under test.\nFor example, if you are testing a 'sine' function, the input and expected outputs are parameterized, but in all cases we are testing a sine function. In part as well, JUnit will automatically print out the test parameters as part of the display.\nTo resolve, a comment on the test data could be sufficient. You could also consider passing in as parameters the components for a Battlestate and then constructing the battle state in the test.", "author": "DanVanAtta", "createdAt": "2020-06-22T01:01:22Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {", "originalCommit": "c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3OTk4MA==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443279980", "bodyText": "I tried your later idea (passing in parameters) but I couldn't build out a decent display name with the passed in parameters.\nThis does fit parameterizing, but the parameters are extremely complicated so building a human visible display name out of it is not workable.  I'll probably flip it so that the retreatHappens is just a helper then function and split out the parameterization into separate methods that call this then function.", "author": "trevan", "createdAt": "2020-06-22T01:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI5ODE2MQ==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443298161", "bodyText": "Codacity doesn't like what I did.  It is complaining that none of the test methods have assert or fail.  I can \"fix\" this by inlining the then methods or moving the verify calls from the then methods to the test methods.\nOr, I could move back to the parameterized code and add a comment as you originally suggested.\n@DanVanAtta , thoughts?", "author": "trevan", "createdAt": "2020-06-22T03:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNTM0Nw==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443715347", "bodyText": "I inlined the methods.  The then method was only three lines long.", "author": "trevan", "createdAt": "2020-06-22T17:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjMxMQ==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443276311", "bodyText": "I think I might be missing something. A defending destroyer prevents submerge, why does it prevent retreat?", "author": "DanVanAtta", "createdAt": "2020-06-22T01:02:50Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",", "originalCommit": "c0b673ee6fa8bbf68f10c66c30beeb3d72a3b76c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI4MTIxNw==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443281217", "bodyText": "The special sub submerge/retreat step is separate from the main retreat step.  This special step will either allow submerging or retreating depending on a gameData parameter (getSubmersibleSubs).", "author": "trevan", "createdAt": "2020-06-22T01:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3Njk0OA==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443276948", "bodyText": "Can this mock instantiation be inlined and a constructor avoided?\nI think our general convention is to favor inlining declarations and only declare what you must in a constructor.", "author": "DanVanAtta", "createdAt": "2020-06-22T01:07:34Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {\n+    private final GameData gameData;\n+    private final GameProperties gameProperties;\n+    private boolean propertiesSetup = false;\n+\n+    private MockGameData() {\n+      gameData = mock(GameData.class);", "originalCommit": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzA3Mg==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443277072", "bodyText": "Is this if check here to avoid strict mocking checks?\nIt might be a case where we can use lenient. IMO using lenient is going to be better than having lazy instantiation of a mock expectation.", "author": "DanVanAtta", "createdAt": "2020-06-22T01:08:32Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {\n+    private final GameData gameData;\n+    private final GameProperties gameProperties;\n+    private boolean propertiesSetup = false;\n+\n+    private MockGameData() {\n+      gameData = mock(GameData.class);\n+      gameProperties = mock(GameProperties.class);\n+    }\n+\n+    static MockGameData givenGameData() {\n+      return new MockGameData();\n+    }\n+\n+    GameData build() {\n+      return gameData;\n+    }\n+\n+    MockGameData withTransportCasualtiesRestricted(final boolean value) {\n+      setupProperties();\n+      when(gameProperties.get(TRANSPORT_CASUALTIES_RESTRICTED, false)).thenReturn(value);\n+      return this;\n+    }\n+\n+    private void setupProperties() {\n+      if (!propertiesSetup) {", "originalCommit": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI4MTYxNA==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443281614", "bodyText": "Yes, it is to avoid strict mocking checks.", "author": "trevan", "createdAt": "2020-06-22T01:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI4ODM0Mg==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443288342", "bodyText": "Do you have objection to using a lenient? It seems like a pretty good case for it. Avoiding state in test scaffolding is generally a very good thing.", "author": "DanVanAtta", "createdAt": "2020-06-22T02:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI4ODY2Mw==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443288663", "bodyText": "I'm fine with lenient.", "author": "trevan", "createdAt": "2020-06-22T02:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzEzOQ==", "url": "https://github.com/triplea-game/triplea/pull/6719#discussion_r443277139", "bodyText": "I like this method \ud83d\udc4d\nI tend to think this indicates we should aggregate more of this kind of logic in GameData itself so you could have method on game data to turn this property on.", "author": "DanVanAtta", "createdAt": "2020-06-22T01:09:03Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/sub/OffensiveSubsRetreatTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package games.strategy.triplea.delegate.battle.steps.sub;\n+\n+import static games.strategy.triplea.Constants.SUBMERSIBLE_SUBS;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanEvade;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.retreat.OffensiveSubsRetreat;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveSubsRetreatTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatHappens(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions)\n+        .queryRetreat(eq(false), eq(MustFightBattle.RetreatType.SUBS), eq(delegateBridge), any());\n+  }\n+\n+  static List<Arguments> retreatHappens() {\n+    return List.of(\n+        Arguments.of(\n+            \"Can not submerge but has retreat territories\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Has no retreat territories but can submerge\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(false)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()),\n+        Arguments.of(\n+            \"Transports with other units on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport(), givenAnyUnit()))\n+                .build()));\n+  }\n+\n+  @ParameterizedTest(name = \"[{index}] {0}\")\n+  @MethodSource\n+  void retreatDoesNotHappen(final String displayName, final BattleState battleState) {\n+    final OffensiveSubsRetreat offensiveSubsRetreat =\n+        new OffensiveSubsRetreat(battleState, battleActions);\n+\n+    offensiveSubsRetreat.execute(executionStack, delegateBridge);\n+\n+    verify(battleActions, never()).queryRetreat(anyBoolean(), any(), any(), any());\n+  }\n+\n+  static List<Arguments> retreatDoesNotHappen() {\n+    return List.of(\n+        Arguments.of(\n+            \"Battle is over\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .over(true)\n+                .build()),\n+        Arguments.of(\n+            \"Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingUnits(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Waiting to Die Defending Destroyer exists\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .defendingWaitingToDie(List.of(givenUnitDestroyer()))\n+                .build()),\n+        Arguments.of(\n+            \"Amphibious assault\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .amphibious(true)\n+                .build()),\n+        Arguments.of(\n+            \"Can withdraw but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(false)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .attackerRetreatTerritories(List.of(mock(Territory.class)))\n+                .build()),\n+        Arguments.of(\n+            \"Can submerge but only defenseless transports on the defense\",\n+            givenBattleStateBuilder()\n+                .attackingUnits(List.of(givenUnitCanEvade()))\n+                .gameData(\n+                    MockGameData.givenGameData()\n+                        .withTransportCasualtiesRestricted(true)\n+                        .withSubmersibleSubs(true)\n+                        .build())\n+                .defendingUnits(List.of(givenUnitTransport()))\n+                .build()),\n+        Arguments.of(\n+            \"No retreat territories and can not submerge\",\n+            givenBattleStateBuilder()\n+                .gameData(\n+                    MockGameData.givenGameData().withTransportCasualtiesRestricted(false).build())\n+                .attackerRetreatTerritories(List.of())\n+                .build()));\n+  }\n+\n+  static class MockGameData {\n+    private final GameData gameData;\n+    private final GameProperties gameProperties;\n+    private boolean propertiesSetup = false;\n+\n+    private MockGameData() {\n+      gameData = mock(GameData.class);\n+      gameProperties = mock(GameProperties.class);\n+    }\n+\n+    static MockGameData givenGameData() {\n+      return new MockGameData();\n+    }\n+\n+    GameData build() {\n+      return gameData;\n+    }\n+\n+    MockGameData withTransportCasualtiesRestricted(final boolean value) {", "originalCommit": "7ee6bce0e081196f6d91dab82b0f52dcde09890a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2a2b1fabf1948612ab43fd4bd4f2f2105fb4f944", "url": "https://github.com/triplea-game/triplea/commit/2a2b1fabf1948612ab43fd4bd4f2f2105fb4f944", "message": "Rework tests to not be parameterized", "committedDate": "2020-06-22T02:38:03Z", "type": "commit"}, {"oid": "650dad477cbb0a02e8de72b83814a3daed3e7e2d", "url": "https://github.com/triplea-game/triplea/commit/650dad477cbb0a02e8de72b83814a3daed3e7e2d", "message": "Merge remote-tracking branch 'upstream/master' into offensive-subs-retreat-step", "committedDate": "2020-06-22T02:45:28Z", "type": "commit"}, {"oid": "28a74403a1bf3ce2e5670ed2c3a8f78727e1bc12", "url": "https://github.com/triplea-game/triplea/commit/28a74403a1bf3ce2e5670ed2c3a8f78727e1bc12", "message": "Inline then test helper", "committedDate": "2020-06-22T14:33:33Z", "type": "commit"}]}