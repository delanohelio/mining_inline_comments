{"pr_number": 6647, "pr_title": "Convert Offensive/Defensive AA Fire Steps", "pr_createdAt": "2020-06-08T06:05:34Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6647", "timeline": [{"oid": "ff4ebc89bab7d3333e99e0eb4b260102b390ff74", "url": "https://github.com/triplea-game/triplea/commit/ff4ebc89bab7d3333e99e0eb4b260102b390ff74", "message": "Move Offensive/Defensive Aa to BattleStep", "committedDate": "2020-06-08T05:28:53Z", "type": "commit"}, {"oid": "9cfc5a7fad11bab7ff94c5ccb1edd4030d524aaf", "url": "https://github.com/triplea-game/triplea/commit/9cfc5a7fad11bab7ff94c5ccb1edd4030d524aaf", "message": "Ensure the step object is created for old steps", "committedDate": "2020-06-08T05:51:35Z", "type": "commit"}, {"oid": "d6851bef4561e6ce9dc721567cb209560d10c439", "url": "https://github.com/triplea-game/triplea/commit/d6851bef4561e6ce9dc721567cb209560d10c439", "message": "Make sure valid is called as needed", "committedDate": "2020-06-08T05:58:07Z", "type": "commit"}, {"oid": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "url": "https://github.com/triplea-game/triplea/commit/92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "message": "Fix tests", "committedDate": "2020-06-08T06:05:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzYyNQ==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r436473625", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-06-08T06:07:12Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/OffensiveAaFire.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzYyNg==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r436473626", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-06-08T06:07:12Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/DefensiveAaFire.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzYyOA==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r436473628", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-06-08T06:07:13Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1086,28 +1088,38 @@ private void pushFightLoopOnStack(final boolean firstRun) {\n   private void addFightStartSteps(final boolean firstRun, final List<IExecutable> steps) {\n     final boolean offensiveAa = canFireOffensiveAa();\n     final boolean defendingAa = canFireDefendingAa();\n-    if (offensiveAa) {\n-      steps.add(\n-          new FireOffensiveAaGuns() {\n-            private static final long serialVersionUID = 3802352588499530533L;\n-\n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireOffensiveAaGuns();\n-            }\n-          });\n+    final BattleStep offensiveAaStep = new OffensiveAaFire(this, this);\n+    final BattleStep defensiveAaStep = new DefensiveAaFire(this, this);\n+    if (offensiveAaStep.valid()) {\n+      steps.add(offensiveAaStep);\n     }\n-    if (defendingAa) {\n-      steps.add(\n-          new FireDefensiveAaGuns() {\n-            private static final long serialVersionUID = -1370090785540214199L;\n+    // see Save Game Compatibility Note on getBattleExecutables\n+    new IExecutable() {", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODQzOQ==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437848439", "bodyText": "This side effect is striking since getter methods tend to not mutate state. It could also be surprising if one caller were to use this class, and then we add another caller that then calls getOffensiveAa and that would change the state in a way the first caller might not be expecting.\nMaking the side-effect of setting the value of offensiveAa generally helps. IE:\noffensiveAa = computeRemainingOffensiveAaUnits();\nreturn offensiveAa;\n\nThat is still odd though, which makes me wonder if instead this problem would be solved by removing all side effects and instead calling the method something like computeRemainingOffensiveAaUnits(). In that case, any place where we call the getter and need those side effects, then we call the method instead. Perhaps this would lead to the offensiveAa variable to no longer be needed at all.\nWhat are your thoughts?", "author": "DanVanAtta", "createdAt": "2020-06-10T04:08:29Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -398,6 +380,18 @@ void addDependentUnits(final Map<Unit, Collection<Unit>> dependencies) {\n     return new ArrayList<>(remaining);\n   }\n \n+  @Override\n+  public List<Unit> getOffensiveAa() {\n+    updateOffensiveAaUnits();", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2MjIyNg==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437862226", "bodyText": "I agree it is surprising.  I had actually introduced a bug when I first started this because I assumed that offensiveAa was the value I wanted but it just so happened that updateOffensiveAaUnits was called earlier in the caller tree.  When I did some refactoring, my new code was called before updateOffensiveAaUnits and so I had the wrong set of aa units compared to the old code.\nUnfortunately, updateOffensiveAaUnits actually updates 2 private values: offensiveAa and offensiveAaTypes.  And, as far as I can tell, they both need to stay in sync.\nWhat I could do is to find the place early enough in the call chain where offensiveAa and offensiveAaTypes need to be initialized.  And then call updateOffensiveAaUnits there.  Then getOffensiveAa would just return the value.\nAnother method that has this side effect of updating offensiveAa is canFireOffensiveAa, by the way.  I hope to have remove that method when I convert the aa casualty removal step.", "author": "trevan", "createdAt": "2020-06-10T05:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NDg0NQ==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437874845", "bodyText": "Going over the code more, I think by calling updateOffensiveAaUnits every time getOffensiveAa is called might actually introduce a bug.  I think the offensiveAa variable should only be updated at the start of each battle round and then stay constant through the round.  So using a computeRemainingOffensiveAaUnits() might also introduce a bug.\nI've explicitly called updateOffensiveAaUnits in all the places where it was implicitly being called originally so now it should be a little more obvious that it is being updated there.  At some future point, we can refactor it to be less brittle.", "author": "trevan", "createdAt": "2020-06-10T05:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTYzMA==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437849630", "bodyText": "Given we already have the detailed comment above about save-game compatibility, do we very much need the 'if this gets' comment?\nI suspect we could delete it. The 'new' BattleStep mention is also very notable as it makes sense when looking at this diff, but a future maintainer looking at the post-merged code will not necessarily know have context to see the difference between 'new' and 'old'.", "author": "DanVanAtta", "createdAt": "2020-06-10T04:13:27Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1086,28 +1088,38 @@ private void pushFightLoopOnStack(final boolean firstRun) {\n   private void addFightStartSteps(final boolean firstRun, final List<IExecutable> steps) {\n     final boolean offensiveAa = canFireOffensiveAa();\n     final boolean defendingAa = canFireDefendingAa();\n-    if (offensiveAa) {\n-      steps.add(\n-          new FireOffensiveAaGuns() {\n-            private static final long serialVersionUID = 3802352588499530533L;\n-\n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireOffensiveAaGuns();\n-            }\n-          });\n+    final BattleStep offensiveAaStep = new OffensiveAaFire(this, this);\n+    final BattleStep defensiveAaStep = new DefensiveAaFire(this, this);\n+    if (offensiveAaStep.valid()) {\n+      steps.add(offensiveAaStep);\n     }\n-    if (defendingAa) {\n-      steps.add(\n-          new FireDefensiveAaGuns() {\n-            private static final long serialVersionUID = -1370090785540214199L;\n+    // see Save Game Compatibility Note on getBattleExecutables\n+    new IExecutable() {\n+      private static final long serialVersionUID = 3802352588499530533L;\n \n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireDefensiveAaGuns();\n-            }\n-          });\n+      @Override\n+      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+        // if this gets deserialized, then forward the work to the new BattleStep", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTk4Ng==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437849986", "bodyText": "Ditto, we may not need this comment. Someone modifying a method should be aware of the method contract, which implies they would have at least read the method javadoc. Removing this comment could reduce future maintenance burden (less stuff to keep in sync, code and comments need to always be verified and kept in sync).", "author": "DanVanAtta", "createdAt": "2020-06-10T04:15:03Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1086,28 +1088,38 @@ private void pushFightLoopOnStack(final boolean firstRun) {\n   private void addFightStartSteps(final boolean firstRun, final List<IExecutable> steps) {\n     final boolean offensiveAa = canFireOffensiveAa();\n     final boolean defendingAa = canFireDefendingAa();\n-    if (offensiveAa) {\n-      steps.add(\n-          new FireOffensiveAaGuns() {\n-            private static final long serialVersionUID = 3802352588499530533L;\n-\n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireOffensiveAaGuns();\n-            }\n-          });\n+    final BattleStep offensiveAaStep = new OffensiveAaFire(this, this);\n+    final BattleStep defensiveAaStep = new DefensiveAaFire(this, this);\n+    if (offensiveAaStep.valid()) {\n+      steps.add(offensiveAaStep);\n     }\n-    if (defendingAa) {\n-      steps.add(\n-          new FireDefensiveAaGuns() {\n-            private static final long serialVersionUID = -1370090785540214199L;\n+    // see Save Game Compatibility Note on getBattleExecutables\n+    new IExecutable() {\n+      private static final long serialVersionUID = 3802352588499530533L;\n \n-            @Override\n-            public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-              fireDefensiveAaGuns();\n-            }\n-          });\n+      @Override\n+      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+        // if this gets deserialized, then forward the work to the new BattleStep\n+        final BattleStep offensiveAaStep =\n+            new OffensiveAaFire(MustFightBattle.this, MustFightBattle.this);\n+        offensiveAaStep.execute(stack, bridge);\n+      }\n+    };\n+    if (defensiveAaStep.valid()) {\n+      steps.add(defensiveAaStep);\n     }\n+    // see Save Game Compatibility Note on getBattleExecutables", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDM4NQ==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437864385", "bodyText": "My only fear is that these old steps are inside of methods that are called by getBattleExecutables.  So if you go to the top of just this method, you won't see the note about save compatibility.  But I'll remove the note.", "author": "trevan", "createdAt": "2020-06-10T05:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MDc4Nw==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437850787", "bodyText": "nit, it's a novel contention to name the 'test object' as underTest. Other conventions are sut, testObj, etc..\nFor the most part I think our latest convention is just to use 'natural naming'. IE: DefensiveAaFire defensiveAaFire. A benefit of this naming is you can see an example of how code would read when actually used. IE:\ndefensiveAaFire.isValid()\n\nvs\nunderTest.isValid()\n\nThe latter does not give as good of an indication if methods are well named. As well underTest is not necessarily easy to follow in test.\nDo you have any strong objection to renaming the test variable?", "author": "DanVanAtta", "createdAt": "2020-06-10T04:18:34Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/aa/DefensiveAaFireTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitWithTypeAa;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DefensiveAaFireTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final DefensiveAaFire underTest = new DefensiveAaFire(battleState, battleActions);", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDQ1NA==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437864454", "bodyText": "I can rename it.", "author": "trevan", "createdAt": "2020-06-10T05:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MDc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MTk1MQ==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437851951", "bodyText": "Have a second look at the parameterization if you would. I think it's a clear win if we have ballpark 5 or more variations. With just two, particularly with boolean logic, it might be more straight forward just enumerating the different test cases with individual test blocks. I think in big part parameterized tests should not have if blocks, that indicates really that you have multiple test methods (essentially one is testing too many things at once), secondarily data that changes how a test method behaves I think is arguably a test code-smell. WDYT?", "author": "DanVanAtta", "createdAt": "2020-06-10T04:23:20Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/aa/DefensiveAaFireTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitWithTypeAa;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DefensiveAaFireTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3MjAyOQ==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437872029", "bodyText": "I could get rid of the if statement by adding another argument that has the number of names to expect.  So I don't think if is that big of a code smell.  I didn't add an extra argument because it was easy to determine what the number of names is based on the expected value.\nBut having multiple asserts that are tangentially related (valid and names) is more of a code smell in doing to much in the test.  I'll split them up.\nAirAttackVsNonSubsStepTest, AirDefendVsNonSubsStepTest, and SubmergeSubsVsOnlyAirStepTest are all like this.  Should I change them as well?", "author": "trevan", "createdAt": "2020-06-10T05:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MjUwMg==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437852502", "bodyText": "What do you think of re-grouping this test case with a nested test class to improve the test method naming?\nEG:\n@Nested\nclass IsValid {\n   \n   @Test\n    void notValidWithNoOffensiveAa() {\n\n    }\n\n    @Test\n    void validWithOffensiveAa() {\n\n     }\n\n}", "author": "DanVanAtta", "createdAt": "2020-06-10T04:25:35Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/aa/OffensiveAaFireTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitWithTypeAa;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveAaFireTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3MjE1Nw==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437872157", "bodyText": "I'm fine with it.  I don't have a preference any way.", "author": "trevan", "createdAt": "2020-06-10T05:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MzE3MQ==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437853171", "bodyText": "Will we call execute of this action if valid() were ever false? Asked in another way, do we only call execute when valid() is true?", "author": "DanVanAtta", "createdAt": "2020-06-10T04:28:32Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/OffensiveAaFire.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.Collection;\n+\n+/** Offensive Aa units can fire and the player can select their casualties */\n+public class OffensiveAaFire extends AaFireAndCasualtyStep {\n+  private static final long serialVersionUID = 5843852442617511691L;\n+\n+  public OffensiveAaFire(final BattleState battleState, final BattleActions battleActions) {\n+    super(battleState, battleActions);\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    if (valid()) {", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NjI5NA==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437866294", "bodyText": "For steps in general, we will call execute when valid() is false.  For this specific step, I don't think so.  So I could remove it here.  But I've been trying to give each step the same \"structure\" to help reduce my cognitive load.", "author": "trevan", "createdAt": "2020-06-10T05:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4NzUwMA==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437887500", "bodyText": "If you expect valid() to always be true, perhaps better to assert it being true:\nPreconditions.assertState(valid())\n\nThis way:\n\nIt becomes a documented expectation and readers can learn of this assumption\nIf the condition is violated while we are doing any kind of demo/testing, we'll have found a bug", "author": "DanVanAtta", "createdAt": "2020-06-10T06:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE1ODM3MQ==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r438158371", "bodyText": "No, I don't expect valid() to always be true.  The steps are created and added to the execution stack at the beginning of the round.  At this point, steps might be valid (such as defender retreat subs).  But by the time the step is actually executed, the step is no longer possible (e.g. all subs are destroyed).  So valid() can return false.\nI'd like to always have an if (valid()) check before each of the executes so that I don't accidentally introduce a bug because of incorrectly assuming valid() is always true for a step when in fact, it turns out it isn't.  This is one of the reasons I had the parent class.  It did the valid() check so that the children classes didn't have to duplicate it.\nOnce I've moved all of the steps, they can be further investigated to figure out of if valid() is needed.  Or, we can change the step generation from a \"once at the start of each round\" to \"calculate the next valid step after the current one\".  I like the later because then we aren't saving steps in the execution stack during saves.", "author": "trevan", "createdAt": "2020-06-10T14:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MzE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NDQyMg==", "url": "https://github.com/triplea-game/triplea/pull/6647#discussion_r437854422", "bodyText": "nit: test prefix is a bit of an old convention (IIRC Junit3 required test methods to begin with 'test'). Latest convention is to focus on describing what is being verified. IE: verifyFireOffensiveAaGunActionInvoked. The example I think also demonstrates a question of \"under which conditions should that be true?\"\nShould there be a second test case, or do we legitimately again assume that isValid() is invoked first? EG:\n@Nested\nclass ExecuteOffensiveAaFire {\n   @Test\n    @DisplayName(\"Execute will not invoke fire Offensive Aa Guns when no offensive AA Exist\")\n   void noOffensiveAa {\n\n   }\n\n   @Test\n    @DisplayName(\"Execute will invoke fire Offensive Aa Guns When Exists Offensive Aa\")\n   void hasOffensiveAa() {\n\n   }\n}\n\n(side-note, reading the display name, and or a un-camel-cased list of the test methods and display names in a test class should practically form a complete spec for the class under test,  eg:\n\nnot valid with no offensive Aa\nvalid with offensive aa\nexecute will not invoke fire Offensive Aa Guns when no offensive AA exist\nexecute will invoke fire Offensive Aa Guns When Exists Offensive Aa\n)", "author": "DanVanAtta", "createdAt": "2020-06-10T04:33:36Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/aa/OffensiveAaFireTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitWithTypeAa;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OffensiveAaFireTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final OffensiveAaFire underTest = new OffensiveAaFire(battleState, battleActions);\n+    assertThat(underTest.valid(), is(expected));\n+    if (expected) {\n+      assertThat(underTest.getNames(), hasSize(3));\n+    } else {\n+      assertThat(underTest.getNames(), hasSize(0));\n+    }\n+  }\n+\n+  static List<Arguments> testWhatIsValid() {\n+    return List.of(\n+        Arguments.of(\n+            \"No Offensive Aa\", givenBattleStateBuilder().offensiveAa(List.of()).build(), false),\n+        Arguments.of(\n+            \"Some Offensive Aa\",\n+            givenBattleStateBuilder().offensiveAa(List.of(givenUnitWithTypeAa())).build(),\n+            true));\n+  }\n+\n+  @Test\n+  void testFiringAaGuns() {", "originalCommit": "92d20cf669c7a01b4dc11c63d7e8587ab1a7c2ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "918e5ebe8c9e42d8050042e55d8a0cbba41b66c0", "url": "https://github.com/triplea-game/triplea/commit/918e5ebe8c9e42d8050042e55d8a0cbba41b66c0", "message": "Update aa units explicitly where they were implicitly updated before", "committedDate": "2020-06-10T05:08:43Z", "type": "commit"}, {"oid": "444a108bcac523e2d63e53b9fd571e82a3c82f9b", "url": "https://github.com/triplea-game/triplea/commit/444a108bcac523e2d63e53b9fd571e82a3c82f9b", "message": "Remove redundant comments", "committedDate": "2020-06-10T05:15:46Z", "type": "commit"}, {"oid": "b1c3d7809702562bc6905167940fea23fb0c5de2", "url": "https://github.com/triplea-game/triplea/commit/b1c3d7809702562bc6905167940fea23fb0c5de2", "message": "Rename underTest to more natural name", "committedDate": "2020-06-10T05:15:57Z", "type": "commit"}, {"oid": "8c9d21a6d9513d60093606ba33dccabb2d040075", "url": "https://github.com/triplea-game/triplea/commit/8c9d21a6d9513d60093606ba33dccabb2d040075", "message": "Remove parameterization and group tests in @Nested tests", "committedDate": "2020-06-10T05:44:09Z", "type": "commit"}, {"oid": "bc6691e00a716f3844dd21cfb71be77368ede709", "url": "https://github.com/triplea-game/triplea/commit/bc6691e00a716f3844dd21cfb71be77368ede709", "message": "Auto-Formatting", "committedDate": "2020-06-10T05:48:59Z", "type": "commit"}]}