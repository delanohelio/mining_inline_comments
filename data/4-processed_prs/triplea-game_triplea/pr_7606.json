{"pr_number": 7606, "pr_title": "Convert unprotected units step", "pr_createdAt": "2020-09-10T19:22:13Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7606", "timeline": [{"oid": "d1896f92811cc5341e710c34beef236bfb2d095f", "url": "https://github.com/triplea-game/triplea/commit/d1896f92811cc5341e710c34beef236bfb2d095f", "message": "Convert undefended transports step\n\nActually check that enemy units are present when detecting undefended\ntransports.  Previously, it just assumed that if one side had\ntransports, then any unit with an attack must be on the other side.\n\nAlways check TRANSPORT_CASUALTIES_RESTRICTED for removing units that\nhave no more rolls (aka unprotected units)", "committedDate": "2020-09-10T19:21:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MjE3OA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486752178", "bodyText": "Is it inconsistent to have 'removeUndefendedUnits' and 'removeUnprotectedUnits'?", "author": "DanVanAtta", "createdAt": "2020-09-11T03:29:16Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -168,13 +181,7 @@ public boolean isAmphibious() {\n     if (defensiveSubsSubmerge.getOrder() == SUB_DEFENSIVE_RETREAT_BEFORE_BATTLE) {\n       steps.addAll(defensiveSubsSubmerge.getNames());\n     }\n-    // See if there any unescorted transports\n-    if (isBattleSiteWater\n-        && Properties.getTransportCasualtiesRestricted(gameData)\n-        && (attackingUnits.stream().anyMatch(Matches.unitIsTransport())\n-            || defendingUnits.stream().anyMatch(Matches.unitIsTransport()))) {\n-      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n-    }\n+    steps.addAll(removeUndefendedUnits.getNames());", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2NzU5OQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486767599", "bodyText": "I changed the name of this class multiple times.  I thought I had updated all of the places with the latest name but it looks like I missed one :)", "author": "trevan", "createdAt": "2020-09-11T04:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MjE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MjU4Nw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486752587", "bodyText": "Do these class variables have to be 'protected', can they be private?\nHaving child classes modify parent state is a bad form of coupling. It makes program flow very hard to reason about as you have to know the program state to know what will execute and how. Having class variables be uniformly private helps with this and avoiding inheritance.", "author": "DanVanAtta", "createdAt": "2020-09-11T03:30:59Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2ODEyMg==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486768122", "bodyText": "They can be private.  Leaving them as protected just makes accessing them easier in the child classes.  This will just change the code from this.battleState.getUnits() to this.getBattleState().getUnits() so I'm not sure how useful it is to make them private.", "author": "trevan", "createdAt": "2020-09-11T04:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MjU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2OTYwOQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486769609", "bodyText": "Oops, ignore my comment.  I was thinking that this class had children classes but it doesn't.  I'll change them to private.", "author": "trevan", "createdAt": "2020-09-11T04:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MjU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1Mjc2NQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486752765", "bodyText": "Nit: Have you considered using a ternary here? Avoiding intermediate variables is often a good thing.", "author": "DanVanAtta", "createdAt": "2020-09-11T03:31:41Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2ODQ5NQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486768495", "bodyText": "I don't prefer ternary operations when the condition is multiple lines.  I'll get rid of the intermediate variables by just returning a new List in each return.", "author": "trevan", "createdAt": "2020-09-11T04:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1Mjc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MjUxNw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487342517", "bodyText": "Fair enough, something to consider though. Having a method lead with return is  a powerful clue to a reader. Otherwise with an 'if' and 'otherwise' block here, it's arguably cognitively more complex. Specifically until you've scanned the whole method do you realize that all it is is a condition and a return statement based on that (and the simplest form of that is a ternary which leads with the keyword 'return' to help tell a reader that information immediately)", "author": "DanVanAtta", "createdAt": "2020-09-12T00:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1Mjc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MzI0NA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486753244", "bodyText": "This being a potential no-op if kinda concerning. I'm also wondering exactly what is meant by 'check', makes for a difficult public API.  Will this method ever be invoked if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) is false? Can we perhaps make it so that this step is never added to begin with? In that case you could assert that state to be true here", "author": "DanVanAtta", "createdAt": "2020-09-11T03:33:53Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2OTQxNg==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486769416", "bodyText": "Yes, it will be invoked if getTransportCasualtiesRestricted is false.  This method checkAndRemoveUnits is called from another step (see https://github.com/triplea-game/triplea/pull/7606/files#diff-009c223dfe7c716d07dc90f27899c933R1651).\nThe \"check\" is talking about the inner checks, not the getTransportCasualtiesRestricted.  It is checking for which units need to be removed.  Sometimes, units should be removed but most of the time, none are.\nAnd the way that steps are now being created, they will always be added.  So we have to do all of the checks within the execute method or methods that it calls.", "author": "trevan", "createdAt": "2020-09-11T04:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI3MTI5Mg==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487271292", "bodyText": "Fair enough, could we rename this perhaps to something more direct like \"removeUnprotectedUnits\" and leave the fact that perhaps no units will be removed as an implementation detail. The API already does not expose any status flags that something was removed and we are purely modifying internal state of the class. Come to think about it, this is actually a code smell, some other class knows when this should be called, knows that this class needs to mutate its state rather than that being managed by this class itself. I think that is a bigger and more important issue, but perhaps a bit much to tackle now, I'd be happy if we can document the side-effects that happen and perhaps improve the name of the method.", "author": "DanVanAtta", "createdAt": "2020-09-11T20:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNzMxMg==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487317312", "bodyText": "The removal of unprotected units and undefended transports is done in two different places.  I didn't want to duplicate the code so I have the code in this step and the other step calls this code as well.  I could create a helper class that does all this work as well and then have both steps call that helper class, if you'd like.\nI'll rename it, though.", "author": "trevan", "createdAt": "2020-09-11T22:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MzI5Mw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486753293", "bodyText": "nit, obvious comment, mostly restates the code. IMO this one can be removed.", "author": "DanVanAtta", "createdAt": "2020-09-11T03:34:07Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    // If no transports, just return", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1Mzg0NQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486753845", "bodyText": "nit, deeply nested functional chain. Consider decomposing this a bit with helper methods. EG:\nreturn battleState.getUnits(EnumSet.of(side)).stream()\n  .anyMatch(unitIsActive(BattleState.side.OFFENSE));\n\nI believe you can also get rid of the intermediate variable as well and just return the result directly as well.", "author": "DanVanAtta", "createdAt": "2020-09-11T03:36:20Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    // If no transports, just return\n+    if (alliedTransports.isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> alliedUnits = getAlliedUnits(player);\n+    // If transports are unescorted, check opposing forces to see if the Trns die automatically\n+    if (alliedTransports.size() == alliedUnits.size()) {\n+      final Collection<Unit> enemyUnits = getEnemyUnitsThatCanFire(player);\n+      // If there are attackers set their movement to 0 and kill the transports\n+      if (!enemyUnits.isEmpty()) {\n+        final Change change =\n+            ChangeFactory.markNoMovementChange(\n+                CollectionUtils.getMatches(enemyUnits, Matches.unitIsSea()));\n+        bridge.addChange(change);\n+        battleActions.remove(\n+            alliedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+      }\n+    }\n+  }\n+\n+  private boolean attackerHasRetreat(final BattleState.Side side) {\n+    return side == BattleState.Side.OFFENSE\n+        && (!battleState.getAttackerRetreatTerritories().isEmpty()\n+            || battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsAir()));\n+  }\n+\n+  private List<Unit> getAlliedTransports(final GamePlayer player) {\n+    final Predicate<Unit> matchAllied =\n+        Matches.unitIsTransport()\n+            .and(Matches.unitIsNotCombatTransport())\n+            .and(Matches.isUnitAllied(player, battleState.getGameData()))\n+            .and(Matches.unitIsSea());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), matchAllied);\n+  }\n+\n+  private Collection<Unit> getAlliedUnits(final GamePlayer player) {\n+    final Predicate<Unit> alliedUnitsMatch =\n+        Matches.isUnitAllied(player, battleState.getGameData())\n+            .and(Matches.unitIsNotLand())\n+            .and(Matches.unitIsSubmerged().negate());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), alliedUnitsMatch);\n+  }\n+\n+  private Collection<Unit> getEnemyUnitsThatCanFire(final GamePlayer player) {\n+    final Predicate<Unit> enemyUnitsMatch =\n+        Matches.unitIsNotLand()\n+            .and(Matches.enemyUnit(player, battleState.getGameData()))\n+            .and(Matches.unitIsSubmerged().negate())\n+            .and(Matches.unitCanAttack(player));\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), enemyUnitsMatch);\n+  }\n+\n+  private void checkUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    if (battleState\n+        .getUnits(EnumSet.of(BattleState.Side.OFFENSE, BattleState.Side.DEFENSE))\n+        .isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> unprotectedUnits = getUnprotectedUnits(side);\n+    final boolean hasUnitsThatCanRollLeft = areFightingOrSupportingUnitsLeft(side);\n+    final boolean enemyHasUnitsThatCanRollLeft =\n+        areFightingOrSupportingUnitsLeft(side.getOpposite());\n+    if (!hasUnitsThatCanRollLeft && enemyHasUnitsThatCanRollLeft) {\n+      battleActions.remove(\n+          unprotectedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+    }\n+  }\n+\n+  private boolean areFightingOrSupportingUnitsLeft(final BattleState.Side side) {\n+    final boolean hasUnitsThatCanRollLeft;\n+    hasUnitsThatCanRollLeft =\n+        battleState.getUnits(EnumSet.of(side)).stream()\n+            .anyMatch(", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDE2NA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486754164", "bodyText": "This is perhaps too much information for a step class to have, to know exactly when a unit is active. I suspect having unit have a method for this would maybe be more appropriate, but failing that, would it make sense to create a Matches for this condition?", "author": "DanVanAtta", "createdAt": "2020-09-11T03:37:31Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    // If no transports, just return\n+    if (alliedTransports.isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> alliedUnits = getAlliedUnits(player);\n+    // If transports are unescorted, check opposing forces to see if the Trns die automatically\n+    if (alliedTransports.size() == alliedUnits.size()) {\n+      final Collection<Unit> enemyUnits = getEnemyUnitsThatCanFire(player);\n+      // If there are attackers set their movement to 0 and kill the transports\n+      if (!enemyUnits.isEmpty()) {\n+        final Change change =\n+            ChangeFactory.markNoMovementChange(\n+                CollectionUtils.getMatches(enemyUnits, Matches.unitIsSea()));\n+        bridge.addChange(change);\n+        battleActions.remove(\n+            alliedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+      }\n+    }\n+  }\n+\n+  private boolean attackerHasRetreat(final BattleState.Side side) {\n+    return side == BattleState.Side.OFFENSE\n+        && (!battleState.getAttackerRetreatTerritories().isEmpty()\n+            || battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsAir()));\n+  }\n+\n+  private List<Unit> getAlliedTransports(final GamePlayer player) {\n+    final Predicate<Unit> matchAllied =\n+        Matches.unitIsTransport()\n+            .and(Matches.unitIsNotCombatTransport())\n+            .and(Matches.isUnitAllied(player, battleState.getGameData()))\n+            .and(Matches.unitIsSea());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), matchAllied);\n+  }\n+\n+  private Collection<Unit> getAlliedUnits(final GamePlayer player) {\n+    final Predicate<Unit> alliedUnitsMatch =\n+        Matches.isUnitAllied(player, battleState.getGameData())\n+            .and(Matches.unitIsNotLand())\n+            .and(Matches.unitIsSubmerged().negate());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), alliedUnitsMatch);\n+  }\n+\n+  private Collection<Unit> getEnemyUnitsThatCanFire(final GamePlayer player) {\n+    final Predicate<Unit> enemyUnitsMatch =\n+        Matches.unitIsNotLand()\n+            .and(Matches.enemyUnit(player, battleState.getGameData()))\n+            .and(Matches.unitIsSubmerged().negate())\n+            .and(Matches.unitCanAttack(player));\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), enemyUnitsMatch);\n+  }\n+\n+  private void checkUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    if (battleState\n+        .getUnits(EnumSet.of(BattleState.Side.OFFENSE, BattleState.Side.DEFENSE))\n+        .isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> unprotectedUnits = getUnprotectedUnits(side);\n+    final boolean hasUnitsThatCanRollLeft = areFightingOrSupportingUnitsLeft(side);\n+    final boolean enemyHasUnitsThatCanRollLeft =\n+        areFightingOrSupportingUnitsLeft(side.getOpposite());\n+    if (!hasUnitsThatCanRollLeft && enemyHasUnitsThatCanRollLeft) {\n+      battleActions.remove(\n+          unprotectedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+    }\n+  }\n+\n+  private boolean areFightingOrSupportingUnitsLeft(final BattleState.Side side) {\n+    final boolean hasUnitsThatCanRollLeft;\n+    hasUnitsThatCanRollLeft =\n+        battleState.getUnits(EnumSet.of(side)).stream()\n+            .anyMatch(\n+                getActiveUnits()\n+                    .and(\n+                        Matches.unitIsSupporterOrHasCombatAbility(\n+                            side == BattleState.Side.OFFENSE)));\n+    return hasUnitsThatCanRollLeft;\n+  }\n+\n+  private Predicate<Unit> getActiveUnits() {", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3MTAzNA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486771034", "bodyText": "Moving to Matches is a good idea but I'm not sure about the name.  The original code called this match notSubmergedAndType.  I didn't like that name and thought it looked more like active units.  But if it is going to be in Matches it probably needs a better name.", "author": "trevan", "createdAt": "2020-09-11T04:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzMTkyOA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487331928", "bodyText": "I've created a new Matches.unitIsActiveInTerritory", "author": "trevan", "createdAt": "2020-09-11T23:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDIzOQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486754239", "bodyText": "Ditto on direct return, can avoid the intermediate variable.", "author": "DanVanAtta", "createdAt": "2020-09-11T03:37:49Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  protected final BattleState battleState;\n+\n+  protected final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    final List<String> steps = new ArrayList<>();\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      steps.add(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return steps;\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    checkAndRemoveUnits(bridge, BattleState.Side.DEFENSE);\n+    checkAndRemoveUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void checkAndRemoveUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    // If no transports, just return\n+    if (alliedTransports.isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> alliedUnits = getAlliedUnits(player);\n+    // If transports are unescorted, check opposing forces to see if the Trns die automatically\n+    if (alliedTransports.size() == alliedUnits.size()) {\n+      final Collection<Unit> enemyUnits = getEnemyUnitsThatCanFire(player);\n+      // If there are attackers set their movement to 0 and kill the transports\n+      if (!enemyUnits.isEmpty()) {\n+        final Change change =\n+            ChangeFactory.markNoMovementChange(\n+                CollectionUtils.getMatches(enemyUnits, Matches.unitIsSea()));\n+        bridge.addChange(change);\n+        battleActions.remove(\n+            alliedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+      }\n+    }\n+  }\n+\n+  private boolean attackerHasRetreat(final BattleState.Side side) {\n+    return side == BattleState.Side.OFFENSE\n+        && (!battleState.getAttackerRetreatTerritories().isEmpty()\n+            || battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsAir()));\n+  }\n+\n+  private List<Unit> getAlliedTransports(final GamePlayer player) {\n+    final Predicate<Unit> matchAllied =\n+        Matches.unitIsTransport()\n+            .and(Matches.unitIsNotCombatTransport())\n+            .and(Matches.isUnitAllied(player, battleState.getGameData()))\n+            .and(Matches.unitIsSea());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), matchAllied);\n+  }\n+\n+  private Collection<Unit> getAlliedUnits(final GamePlayer player) {\n+    final Predicate<Unit> alliedUnitsMatch =\n+        Matches.isUnitAllied(player, battleState.getGameData())\n+            .and(Matches.unitIsNotLand())\n+            .and(Matches.unitIsSubmerged().negate());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), alliedUnitsMatch);\n+  }\n+\n+  private Collection<Unit> getEnemyUnitsThatCanFire(final GamePlayer player) {\n+    final Predicate<Unit> enemyUnitsMatch =\n+        Matches.unitIsNotLand()\n+            .and(Matches.enemyUnit(player, battleState.getGameData()))\n+            .and(Matches.unitIsSubmerged().negate())\n+            .and(Matches.unitCanAttack(player));\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), enemyUnitsMatch);\n+  }\n+\n+  private void checkUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    if (battleState\n+        .getUnits(EnumSet.of(BattleState.Side.OFFENSE, BattleState.Side.DEFENSE))\n+        .isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> unprotectedUnits = getUnprotectedUnits(side);\n+    final boolean hasUnitsThatCanRollLeft = areFightingOrSupportingUnitsLeft(side);\n+    final boolean enemyHasUnitsThatCanRollLeft =\n+        areFightingOrSupportingUnitsLeft(side.getOpposite());\n+    if (!hasUnitsThatCanRollLeft && enemyHasUnitsThatCanRollLeft) {\n+      battleActions.remove(\n+          unprotectedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+    }\n+  }\n+\n+  private boolean areFightingOrSupportingUnitsLeft(final BattleState.Side side) {\n+    final boolean hasUnitsThatCanRollLeft;\n+    hasUnitsThatCanRollLeft =\n+        battleState.getUnits(EnumSet.of(side)).stream()\n+            .anyMatch(\n+                getActiveUnits()\n+                    .and(\n+                        Matches.unitIsSupporterOrHasCombatAbility(\n+                            side == BattleState.Side.OFFENSE)));\n+    return hasUnitsThatCanRollLeft;\n+  }\n+\n+  private Predicate<Unit> getActiveUnits() {\n+    return Matches.unitIsSubmerged()\n+        .negate()\n+        .and(\n+            Matches.territoryIsLand().test(battleState.getBattleSite())\n+                ? Matches.unitIsSea().negate()\n+                : Matches.unitIsLand().negate());\n+  }\n+\n+  private Collection<Unit> getUnprotectedUnits(final BattleState.Side side) {\n+    final Collection<Unit> unitsToKill;\n+    unitsToKill =\n+        CollectionUtils.getMatches(\n+            battleState.getUnits(EnumSet.of(side)),\n+            getActiveUnits().and(Matches.unitIsNotInfrastructure()));\n+    return unitsToKill;", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDUzMw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486754533", "bodyText": "Seeing this same code 3 times is raising real questions \ud83d\ude01\nWhy does FakeBattleState need to have this implementation? Can we avoid it and perhaps use a true mock? This is kinda concerning code as our test code has implementation that arguably should have a test of its own.\nAre there options where we can remove this method and/or class?", "author": "DanVanAtta", "createdAt": "2020-09-11T03:39:12Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/FakeBattleState.java", "diffHunk": "@@ -82,6 +82,18 @@\n     return dependentUnits;\n   }\n \n+  @Override\n+  public Collection<Unit> getUnits(final EnumSet<Side> sides) {\n+    final Collection<Unit> units = new ArrayList<>();", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3Mjc5OQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486772799", "bodyText": "I created FakeBattleState so that I didn't have to mock as many things.  Instead of having to specify all the required states, I can just use this real object that has default values and then override those defaults as needed.\nI can't remove the method because it is part of the BattleState interface and this implements that interface.\nAs for code in 3 places, it is looking more and more like I'll be deleting BattleSteps.  There's 2-5 more steps that need to be converted but then the code for BattleSteps will basically be a list of objects that are sorted.  At that point, I'm thinking I just need a helper class to build the list of objects and then MustFightBattle can grab those objects, sort them, and then map them to their step names.  That will remove one of the BattleState implementations.", "author": "trevan", "createdAt": "2020-09-11T04:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI3MjgyMw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487272823", "bodyText": "I'll certainly say that mocks are a testing smell and need to be used strategically. Mocking input can be good (though still it's better to use value objects for input),  injecting mock implementations is generally bad.\nFakes are certainly a class of test object of their own, similar to stubs, but often one would want a very simplified implementation and not a real implementation. I think we probably would want to get rid of FakeBattleState in the medium term. I think we can see how this evolves knowing that there are still some smells lingering around.", "author": "DanVanAtta", "createdAt": "2020-09-11T20:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NDgwNA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r486754804", "bodyText": "nit, favor using the IsEmptyCollection matcher instead of checking size == 0 for collections.", "author": "DanVanAtta", "createdAt": "2020-09-11T03:40:18Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnitsTest.java", "diffHunk": "@@ -0,0 +1,508 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsSea;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class RemoveUnprotectedUnitsTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+  @Mock Territory battleSite;\n+\n+  @Nested\n+  class GetNames {\n+\n+    @Test\n+    void noNameIfNotWater() {\n+      when(battleSite.isWater()).thenReturn(false);\n+      final BattleState battleState = givenBattleStateBuilder().battleSite(battleSite).build();\n+      final RemoveUnprotectedUnits removeUnprotectedUnits =\n+          new RemoveUnprotectedUnits(battleState, battleActions);\n+      assertThat(removeUnprotectedUnits.getNames(), hasSize(0));", "originalCommit": "d1896f92811cc5341e710c34beef236bfb2d095f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e770bc21990d8dfa13f1d7433200c4b5e96f605", "url": "https://github.com/triplea-game/triplea/commit/9e770bc21990d8dfa13f1d7433200c4b5e96f605", "message": "Review feedback", "committedDate": "2020-09-11T04:56:20Z", "type": "commit"}, {"oid": "75ac427e4b993e85cbce7809180972cec6dd59c1", "url": "https://github.com/triplea-game/triplea/commit/75ac427e4b993e85cbce7809180972cec6dd59c1", "message": "Change names and move some matchers to Matches", "committedDate": "2020-09-11T23:28:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487341193", "bodyText": "nit, any consideration to make the API generic and allow for EnumSet to passed in as an implementation detail?\nFor example, if I had a Set<Side>, should I really be forced to convert it to an EnumSet to call this method? Is the runtime difference of forcing a collection copy enough that the EnumSet is that much more efficient?", "author": "DanVanAtta", "createdAt": "2020-09-12T00:18:47Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -21,10 +29,12 @@\n \n   Collection<Unit> getAttackingUnits();\n \n-  Collection<Unit> getAttackingWaitingToDie();\n-\n   Collection<Unit> getDefendingUnits();\n \n+  Collection<Unit> getUnits(EnumSet<Side> sides);", "originalCommit": "75ac427e4b993e85cbce7809180972cec6dd59c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTY3NQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487341675", "bodyText": "Perhaps even better, perhaps a vararg for this? In such a case a caller would not have to create a collection at all. WDYT?", "author": "DanVanAtta", "createdAt": "2020-09-12T00:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTkyNQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487341925", "bodyText": "For yet more consideration, any thought to making this a default method?\nIt looks like these methods would give you the data access needed:\n\n  @Override\n  public Collection<Unit> getDefendingUnits() {\n    return Collections.unmodifiableCollection(defendingUnits);\n  }\n\n  @Override\n  public Collection<Unit> getRemainingAttackingUnits() {\n    return Collections.unmodifiableCollection(attackingUnits);\n  }", "author": "DanVanAtta", "createdAt": "2020-09-12T00:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MjAzOA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487342038", "bodyText": "Still more questions.. Should the above two methods be replaced by usages of this getUnits(...) method? Reducing the API surface of such a class would be a good thing, particularly removal of simple getter API methods.", "author": "DanVanAtta", "createdAt": "2020-09-12T00:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM1ODk3Mw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487358973", "bodyText": "I hadn't thought of the vararg idea but I like it.  I'll make that change.\nI've thought of replacing the getAttackingUnits and getDefendingUnits with just getUnits(...) but didn't want to make that change in this PR.  I've got one more step conversion PR in the process and then after that one, I'll do a clean up PR.  There's some tests that are now redundant that I can remove and the steps creation in MustFightBattle#addFightSteps will be ready for simplification.", "author": "trevan", "createdAt": "2020-09-12T03:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MTI0Nw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487341247", "bodyText": "nit, have you considered using a ternary here?", "author": "DanVanAtta", "createdAt": "2020-09-12T00:19:04Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -12,7 +12,15 @@\n \n   enum Side {\n     OFFENSE,\n-    DEFENSE,\n+    DEFENSE;\n+\n+    public Side getOpposite() {\n+      if (this == OFFENSE) {", "originalCommit": "75ac427e4b993e85cbce7809180972cec6dd59c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDA5Mg==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487344092", "bodyText": "What do you think about something that is more like:\nif(!attackerCanRetreat(side)) {\n   removeUnprotectedUnits(side);\n}\n\n\nHaving control flow at the outer layers is generally a good thing. A series of void method calls is not a great abstraction, it's cognitively equivalent to adding comments and inlining the methods. A reader being able to skip sections of code because they are tracing control flow is on the other hand very valuable beyond demonstrating the flow of control at the outset. That pattern is called \"imperative shell, functional core\".\nI also suggest that as it took quite a bit of 'groking' to determine that this method is largely just a lot of conditionals then we do the remove operation. I think there is also a mixing of layers of abstraction code smell here too, eg:\n- high level boolean check\n- low level boolean check\n- low level boolean check\n- high level fetch of unit collection\n- low level removal of units\n\nWith the above you keep the high level boolean check and the control flow is extracted, and you can also potentially inline getUnprotectedUnits into removeUnprotectedUnits which I think then makes a lot of sense and keeps the abstractions at a consistent level (and there are just as many methods, but each one is more focused in what they do).", "author": "DanVanAtta", "createdAt": "2020-09-12T00:36:39Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_UNESCORTED_TRANSPORTS;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.AllArgsConstructor;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class RemoveUnprotectedUnits implements BattleStep {\n+\n+  private static final long serialVersionUID = 4357860848979564096L;\n+\n+  private final BattleState battleState;\n+\n+  private final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    if (battleState.getBattleSite().isWater()\n+        && Properties.getTransportCasualtiesRestricted(battleState.getGameData())\n+        && (battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsTransport())\n+            || battleState.getDefendingUnits().stream().anyMatch(Matches.unitIsTransport()))) {\n+      return List.of(REMOVE_UNESCORTED_TRANSPORTS);\n+    }\n+    return List.of();\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    removeUnprotectedUnits(bridge, BattleState.Side.DEFENSE);\n+    removeUnprotectedUnits(bridge, BattleState.Side.OFFENSE);\n+  }\n+\n+  public void removeUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      checkUndefendedTransports(bridge, side);\n+      checkUnprotectedUnits(bridge, side);\n+    }\n+  }\n+\n+  private void checkUndefendedTransports(\n+      final IDelegateBridge bridge, final BattleState.Side side) {\n+    final GamePlayer player =\n+        side == BattleState.Side.OFFENSE ? battleState.getAttacker() : battleState.getDefender();\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    final List<Unit> alliedTransports = getAlliedTransports(player);\n+    if (alliedTransports.isEmpty()) {\n+      return;\n+    }\n+    final Collection<Unit> alliedUnits = getAlliedUnits(player);\n+    // If transports are unescorted, check opposing forces to see if the Trns die automatically\n+    if (alliedTransports.size() == alliedUnits.size()) {\n+      final Collection<Unit> enemyUnits = getEnemyUnitsThatCanFire(player);\n+      // If there are attackers set their movement to 0 and kill the transports\n+      if (!enemyUnits.isEmpty()) {\n+        final Change change =\n+            ChangeFactory.markNoMovementChange(\n+                CollectionUtils.getMatches(enemyUnits, Matches.unitIsSea()));\n+        bridge.addChange(change);\n+        battleActions.remove(\n+            alliedUnits, bridge, battleState.getBattleSite(), side == BattleState.Side.DEFENSE);\n+      }\n+    }\n+  }\n+\n+  private boolean attackerHasRetreat(final BattleState.Side side) {\n+    return side == BattleState.Side.OFFENSE\n+        && (!battleState.getAttackerRetreatTerritories().isEmpty()\n+            || battleState.getAttackingUnits().stream().anyMatch(Matches.unitIsAir()));\n+  }\n+\n+  private List<Unit> getAlliedTransports(final GamePlayer player) {\n+    final Predicate<Unit> matchAllied =\n+        Matches.unitIsTransport()\n+            .and(Matches.unitIsNotCombatTransport())\n+            .and(Matches.isUnitAllied(player, battleState.getGameData()))\n+            .and(Matches.unitIsSea());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), matchAllied);\n+  }\n+\n+  private Collection<Unit> getAlliedUnits(final GamePlayer player) {\n+    final Predicate<Unit> alliedUnitsMatch =\n+        Matches.isUnitAllied(player, battleState.getGameData())\n+            .and(Matches.unitIsNotLand())\n+            .and(Matches.unitIsSubmerged().negate());\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), alliedUnitsMatch);\n+  }\n+\n+  private Collection<Unit> getEnemyUnitsThatCanFire(final GamePlayer player) {\n+    final Predicate<Unit> enemyUnitsMatch =\n+        Matches.unitIsNotLand()\n+            .and(Matches.enemyUnit(player, battleState.getGameData()))\n+            .and(Matches.unitIsSubmerged().negate())\n+            .and(Matches.unitCanAttack(player));\n+    return CollectionUtils.getMatches(battleState.getBattleSite().getUnits(), enemyUnitsMatch);\n+  }\n+\n+  private void checkUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {", "originalCommit": "75ac427e4b993e85cbce7809180972cec6dd59c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM2MjMwNw==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487362307", "bodyText": "I had basically copied the original code and extracted out larger pieces so that it was more readable but you are right, it is still hard to read.  So, I've restructured the code to follow the return early pattern.", "author": "trevan", "createdAt": "2020-09-12T03:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTAxOA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487345018", "bodyText": "At a first glance this is a bit confusing to have a boolean parameter that negates the whole thing. For consideration, boolean parameters automatically violate SRP, the method by definition then does multiple things (so long as the parameter is used).\nPerhaps the underlying code should get the relationship type instead of using the 'isAllied' and 'isAtWar' methods?\nIn that case you could have withRelationship(Player1, Player2, RelationshipType)", "author": "DanVanAtta", "createdAt": "2020-09-12T00:43:17Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/MockGameData.java", "diffHunk": "@@ -29,6 +33,18 @@ public GameData build() {\n     return gameData;\n   }\n \n+  public MockGameData withAlliedRelationship(\n+      final GamePlayer player1, final GamePlayer player2, final boolean value) {\n+    when(relationshipTracker.isAllied(player1, player2)).thenReturn(value);\n+    return this;\n+  }\n+\n+  public MockGameData withWarRelationship(", "originalCommit": "75ac427e4b993e85cbce7809180972cec6dd59c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM1ODUxNQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487358515", "bodyText": "I would have to make the mocks lenient.  Because making a player be at war with another requires that the allied be false and the war true.  But both of those mocked calls will not be executed during the test and the test will fail.\nAlso, this is really just a wrapper around the isAtWar and isAllied methods to make give it a fluent api.  So, if you mocked the relationship outside of this wrapper, you'd still have the same problems you mentioned.", "author": "trevan", "createdAt": "2020-09-12T02:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTI3MQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487345271", "bodyText": "A @DisplayName on this one could be useful IMO to explain why there is no name expected if land. It would be good to see this made clear up front why we expect this situation to be true. I mention that because without context, it's not clear why 'unprotected units' is an invalid step for land, 'land' can have protected or unprotected units, hence there is context here into the production code needed to understand the test, which is a test code maintenance scaling problem.", "author": "DanVanAtta", "createdAt": "2020-09-12T00:45:04Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnitsTest.java", "diffHunk": "@@ -0,0 +1,510 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsSea;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitTransport;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class RemoveUnprotectedUnitsTest {\n+\n+  @Mock ExecutionStack executionStack;\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock BattleActions battleActions;\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+  @Mock Territory battleSite;\n+\n+  @Nested\n+  class GetNames {\n+\n+    @Test", "originalCommit": "75ac427e4b993e85cbce7809180972cec6dd59c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTQ2MA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487345460", "bodyText": "This makes me wonder if the rule should be named more directly \"RemoveUnprotectedCasualtyRestrictedTransports\", WDYT?", "author": "DanVanAtta", "createdAt": "2020-09-12T00:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM1Nzg1OA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487357858", "bodyText": "Do you mean rename the step?  Or the test?\nAnd I agree that the getNames condition on water vs land is weird but that is the relic of the original code.  I'm not confident in changing at this point.  I actually think that this step should be split in 2 steps, one for the undefended transports and one for the unprotected units.  But with the discussion we had in the forum about the \"auto-kill\" logic, I think this step will need to be reworked completely.  So, I'd rather leave the original logic alone and test it.", "author": "trevan", "createdAt": "2020-09-12T02:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ1MzYyOA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487453628", "bodyText": "I was more suggesting to rename the  class under test.", "author": "DanVanAtta", "createdAt": "2020-09-12T22:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTI3MQ=="}], "type": "inlineReview"}, {"oid": "ee228b289af9e72b8c93aa359d68a9102c5477b5", "url": "https://github.com/triplea-game/triplea/commit/ee228b289af9e72b8c93aa359d68a9102c5477b5", "message": "Review fixes: return early methods and vararg arguments", "committedDate": "2020-09-12T03:36:30Z", "type": "commit"}, {"oid": "3d2aa493d6c815ff75ff610fa300963c9888dff1", "url": "https://github.com/triplea-game/triplea/commit/3d2aa493d6c815ff75ff610fa300963c9888dff1", "message": "Unify the attackerHasRetreat early return", "committedDate": "2020-09-12T13:31:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ1MzMxMA==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487453310", "bodyText": "Personally I would not have preserved this comment, it makes sense with some context but otherwise is actually not that helpful and is arguably more cheeky than informative. It does leave me with more questions than answers.\nIs there any reason otherwise to not combine the two if statements?", "author": "DanVanAtta", "createdAt": "2020-09-12T22:06:14Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -51,20 +51,27 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n   }\n \n   public void removeUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n-    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n-      checkUndefendedTransports(bridge, side);\n-      checkUnprotectedUnits(bridge, side);\n+    if (!Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      return;\n     }\n+    // if we are the attacker, we can retreat instead of dying", "originalCommit": "3d2aa493d6c815ff75ff610fa300963c9888dff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ1MzQ5OQ==", "url": "https://github.com/triplea-game/triplea/pull/7606#discussion_r487453499", "bodyText": "Having the early return in this method is much better \ud83d\udc4d\nEarly return is a pattern I like, I do prefer:\nvoid method()  {\n  if(something) {\n     return;\n  }\n}\n\nOver:\nvoid method() {\n  if(!something) {\n    // do stuff\n\n  }\n  return;\n\n}\n\n\nBut, if a method is going to be a no-op, I generally prefer for it just not to be invoked. It's always a bit frustrating to read through code to realize that method calls are no-ops. Methods generally are called so that something can happen. For example, if a method no-ops because of null input, presumably the caller called it for something to happen, did the caller realize that they even provided a null input? IN such a case, I see something like:\nvoid method(Sringg arg) {\n  if(arg == null) {\n     return; // << this is a silent failure, a BUG. Did the caller know they provided a null arg and were just doing a no-op?\n  }\n}", "author": "DanVanAtta", "createdAt": "2020-09-12T22:09:13Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -51,20 +51,27 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n   }\n \n   public void removeUnprotectedUnits(final IDelegateBridge bridge, final BattleState.Side side) {\n-    if (Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n-      checkUndefendedTransports(bridge, side);\n-      checkUnprotectedUnits(bridge, side);\n+    if (!Properties.getTransportCasualtiesRestricted(battleState.getGameData())) {\n+      return;\n     }\n+    // if we are the attacker, we can retreat instead of dying\n+    if (attackerHasRetreat(side)) {\n+      return;\n+    }\n+    checkUndefendedTransports(bridge, side);", "originalCommit": "3d2aa493d6c815ff75ff610fa300963c9888dff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}