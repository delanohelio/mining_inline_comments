{"pr_number": 7796, "pr_title": "Move the LandParatrooper and MarkNoMovement logic to their steps", "pr_createdAt": "2020-09-27T14:21:52Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7796", "timeline": [{"oid": "85bbd63e069f66b9e22e95324d7a0d0b906c6773", "url": "https://github.com/triplea-game/triplea/commit/85bbd63e069f66b9e22e95324d7a0d0b906c6773", "message": "Move the LandParatrooper and MarkNoMovement logic to their steps", "committedDate": "2020-09-27T14:21:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3ODM4Nw==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r495578387", "bodyText": "There's now 3 methods dealing with dependents (getDependentUnits, removeDependentUnits, and getTransportDependents).  I'm looking into if I can simplify the api around dependent units.  I expect getTransportDependents and getDependentUnits can be combined somehow.  I also think that they might be combined with filterUnits by adding a new status TRANSPORTING.  But that will be a different PR.", "author": "trevan", "createdAt": "2020-09-27T14:24:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -102,6 +102,8 @@ public boolean isFirstRound() {\n \n   Collection<Unit> getDependentUnits(Collection<Unit> units);\n \n+  void removeDependentUnits(Collection<Unit> units);", "originalCommit": "85bbd63e069f66b9e22e95324d7a0d0b906c6773", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5NzM0OQ==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r495597349", "bodyText": "The change object is the interesting thing, right? The structure and data of the change object we do expect to be in a certain way, that defines correctness? For example, if it were null, I think this test might still pass.\nA captor could be used to grab the change object and then verify it. We are then pretty tied to implementation and we have another code smell where the code could change, still be correct, and the tests are breaking because they were testing implementation and not behavior.\nSo, captor is an option, another option is to have the execute method return the change object. In that case the test code would get a reference to it directly. IF we are limited by compatibility concerns (we might not be), but if we are, then the existing code could be converted to a facade and invokes a method that is visible to testing that does return a change object.\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-09-27T17:47:54Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java", "diffHunk": "@@ -22,24 +35,84 @@\n   @Mock BattleActions battleActions;\n \n   @Test\n-  void runsOnFirstRound() {\n-    final BattleState battleState = givenBattleStateBuilder().battleRound(1).build();\n+  void doesNotRunOnFirstRoundAndHeadless() {\n+    final BattleState battleState = givenBattleStateBuilder().battleRound(1).headless(true).build();\n     final MarkNoMovementLeft markNoMovementLeft =\n         new MarkNoMovementLeft(battleState, battleActions);\n \n     markNoMovementLeft.execute(executionStack, delegateBridge);\n \n-    verify(battleActions).markNoMovementLeft(eq(delegateBridge));\n+    verify(delegateBridge, never()).addChange(any());\n   }\n \n   @Test\n   void doesNotRunOnSecondRound() {\n-    final BattleState battleState = givenBattleStateBuilder().battleRound(2).build();\n+    final BattleState battleState =\n+        givenBattleStateBuilder().battleRound(2).headless(false).build();\n     final MarkNoMovementLeft markNoMovementLeft =\n         new MarkNoMovementLeft(battleState, battleActions);\n \n     markNoMovementLeft.execute(executionStack, delegateBridge);\n \n-    verify(battleActions, never()).markNoMovementLeft(eq(delegateBridge));\n+    verify(delegateBridge, never()).addChange(any());\n+  }\n+\n+  @Test\n+  void nonAirWithMovementLeftAreMarkedAsMoved() {\n+    final BattleState battleState =\n+        givenBattleStateBuilder()\n+            .battleRound(1)\n+            .headless(false)\n+            .attackingUnits(List.of(givenNonAirUnitWithMovementLeft(BigDecimal.ONE)))\n+            .build();\n+    final MarkNoMovementLeft markNoMovementLeft =\n+        new MarkNoMovementLeft(battleState, battleActions);\n+\n+    markNoMovementLeft.execute(executionStack, delegateBridge);\n+\n+    verify(delegateBridge).addChange(any());", "originalCommit": "85bbd63e069f66b9e22e95324d7a0d0b906c6773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMDUyOA==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r495600528", "bodyText": "I changed the code to use any(Change.class).  That prevents null.\nAs for actually verifying the change object, I think that might get really tied to the implementation.  This particular change object is a CompositeChange with multiple ObjectPropertyChange changes in it.  So the test would have to check that it is a CompositeChange and then grab the inner changes, cast them to ObjectPropertyChange, and then verify that they are setting the correct property (ALREADY_MOVED) and that the new value and the old value (which currently have no getters) are what is expected.  Is there already a change matcher somewhere in the code base that would do this?\nAnother idea is to just compare the toString result of the change object.  Then the code would be something like:\n    verify(delegateBridge).addChange(argThat(hasToString(\"CompositeChange <[Property change, unit:null owned by null property:alreadyMoved newValue:1 oldValue:0]>\")));", "author": "trevan", "createdAt": "2020-09-27T18:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5NzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MzYzMg==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r495643632", "bodyText": "Indeed, it sounds like the check is if the expected property and perhaps expected value are present anywhere in the change object. A matcher would be pretty slick since you could do an iterative search through the change object. 'toString' is a bit brittle as you rely on the the toString method, but it would work too. IMO the matcher is probably the more robust way to go. AFAIK there is no such matcher.", "author": "DanVanAtta", "createdAt": "2020-09-28T01:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5NzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI4MzYwMg==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r496283602", "bodyText": "I've made a custom matcher for ObjectPropertyChange and CompositeChange.  As more Change objects are used, the matcher can be expanded.", "author": "trevan", "createdAt": "2020-09-28T23:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5NzM0OQ=="}], "type": "inlineReview"}, {"oid": "3cfd4f1e1bf9491e223367bee9ddfb2a5728b5b5", "url": "https://github.com/triplea-game/triplea/commit/3cfd4f1e1bf9491e223367bee9ddfb2a5728b5b5", "message": "Ensure a change object is passed", "committedDate": "2020-09-27T18:11:40Z", "type": "commit"}, {"oid": "a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "url": "https://github.com/triplea-game/triplea/commit/a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "message": "Custom hamcrest matcher for changes", "committedDate": "2020-09-28T23:06:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwMTU5NA==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r496301594", "bodyText": "nit, would you mind extracting 'altreadyMoved' to a constant? Is that possible? The idea there being the test will automatically update with the constant and it makes it clear as well where that value is coming from for any maintainers that are potentially looking at a failing test.\nSecond nit, by convention tests use static imports for most everything matcher related (I don't always like that one, but it is a relatively consistent convention)", "author": "DanVanAtta", "createdAt": "2020-09-29T00:07:34Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/change/MarkNoMovementLeftTest.java", "diffHunk": "@@ -71,7 +73,12 @@ void nonAirWithMovementLeftAreMarkedAsMoved() {\n \n     markNoMovementLeft.execute(executionStack, delegateBridge);\n \n-    verify(delegateBridge).addChange(any(Change.class));\n+    verify(delegateBridge)\n+        .addChange(\n+            argThat(\n+                CompositeChangeMatcher.compositeChangeContains(\n+                    ObjectPropertyChangeMatcher.propertyChange(\n+                        \"alreadyMoved\", BigDecimal.ONE, BigDecimal.ZERO))));", "originalCommit": "a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwMTkzNg==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r496301936", "bodyText": "Any nullity concerns here?\nWhat if the new value or old value were null, and we were matching for a null value?", "author": "DanVanAtta", "createdAt": "2020-09-29T00:08:44Z", "path": "game-core/src/test/java/games/strategy/engine/data/changefactory/ObjectPropertyChangeMatcher.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package games.strategy.engine.data.changefactory;\n+\n+import games.strategy.engine.data.ChangeMatcher;\n+import lombok.AllArgsConstructor;\n+import org.hamcrest.Description;\n+\n+@AllArgsConstructor\n+public class ObjectPropertyChangeMatcher extends ChangeMatcher<ObjectPropertyChange> {\n+\n+  private final String property;\n+\n+  private final Object newValue;\n+\n+  private final Object oldValue;\n+\n+  @Override\n+  protected boolean matchesSafely(final ObjectPropertyChange item) {\n+    return item.getProperty().equals(property)\n+        && item.getNewValue().equals(newValue)", "originalCommit": "a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwMzA5Mg==", "url": "https://github.com/triplea-game/triplea/pull/7796#discussion_r496303092", "bodyText": "When we get checkstyle upgraded to 8.3x, type javadocs will I think become required again. Probably best to try and add them proactively so we don't have to do as much to migrate.\nBeyond checkstyle, a javadoc here with some example usages I think would be really helpful. Some sample code on how to use this would make it really easy if someone were want to pick this up, they could copy/paste it and modify it to fit their needs.", "author": "DanVanAtta", "createdAt": "2020-09-29T00:12:55Z", "path": "game-core/src/test/java/games/strategy/engine/data/CompositeChangeMatcher.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package games.strategy.engine.data;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+\n+@AllArgsConstructor\n+public class CompositeChangeMatcher extends ChangeMatcher<CompositeChange> {", "originalCommit": "a5ffe08306e499d4e3a5788b335e1507ae27ae5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ed42400061a7b4e714a3d9a6ff23790c75ba0be3", "url": "https://github.com/triplea-game/triplea/commit/ed42400061a7b4e714a3d9a6ff23790c75ba0be3", "message": "Add some documentation, handle null case, use the constant", "committedDate": "2020-09-29T01:26:05Z", "type": "commit"}, {"oid": "b779405821202df2b47af8e273e113b27a6880e1", "url": "https://github.com/triplea-game/triplea/commit/b779405821202df2b47af8e273e113b27a6880e1", "message": "Add @param javadoc", "committedDate": "2020-09-29T02:22:56Z", "type": "commit"}]}