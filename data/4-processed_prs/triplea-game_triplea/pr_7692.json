{"pr_number": 7692, "pr_title": "Convert end game checks battle step", "pr_createdAt": "2020-09-18T03:29:04Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7692", "timeline": [{"oid": "93e67358be54a428330cbd2d7a4030d44bef237e", "url": "https://github.com/triplea-game/triplea/commit/93e67358be54a428330cbd2d7a4030d44bef237e", "message": "Convert end game checks battle step", "committedDate": "2020-09-18T03:24:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY4MTM5NQ==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r490681395", "bodyText": "This step is, currently, the only step that needs access to logic from another battle step.  I'm undecided in how best to access that logic.  I've three thoughts:\n\nInstantiate the steps and call the public method right when it is needed (aka new RemoveUnprotectedUnits(battleState, battleActions).removeUnprotectedUnits(bridge, BattleState.Side.DEFENSE))\nPass in the the step to the constructor of CheckGeneralBattleEnd and then call the public method when it is needed.\nPass in a lambda of the public method and call the lambda.\n\nI've currently coded up 3.\nI don't like 2 because it will cause the other battle steps to be saved with this battle step and would make future changes harder to do.\nI've tried 1 and it makes testing a little harder.\n@DanVanAtta , what are your thoughts?", "author": "trevan", "createdAt": "2020-09-18T03:37:37Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEnd.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import lombok.AllArgsConstructor;\n+\n+@AllArgsConstructor\n+public class CheckGeneralBattleEnd implements BattleStep {\n+  private static final long serialVersionUID = 5172121497955756220L;\n+\n+  private final BattleState battleState;\n+\n+  private final BattleActions battleActions;\n+\n+  private final BiConsumer<IDelegateBridge, BattleState.Side> removeUnprotectedUnits;\n+\n+  private final Consumer<IDelegateBridge> retreatUnits;\n+\n+  @Override\n+  public List<String> getNames() {\n+    return List.of();\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.GENERAL_BATTLE_END_CHECK;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    if (hasSideLost(BattleState.Side.OFFENSE)) {\n+      battleActions.endBattle(bridge);\n+      battleActions.defenderWins(bridge);\n+\n+    } else if (hasSideLost(BattleState.Side.DEFENSE)) {\n+      removeUnprotectedUnits.accept(bridge, BattleState.Side.DEFENSE);", "originalCommit": "93e67358be54a428330cbd2d7a4030d44bef237e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "702e11051b38c80dbaf0d4ab6e60221236bea324", "url": "https://github.com/triplea-game/triplea/commit/702e11051b38c80dbaf0d4ab6e60221236bea324", "message": "Remove code that was moved to CheckGeneralBattleEnd", "committedDate": "2020-09-18T03:40:00Z", "type": "commit"}, {"oid": "a3a0409b6cf1e0545cbd0169c95c33436cbdcc20", "url": "https://github.com/triplea-game/triplea/commit/a3a0409b6cf1e0545cbd0169c95c33436cbdcc20", "message": "Break up CheckGeneralBattleEnd to separate steps", "committedDate": "2020-09-18T22:54:07Z", "type": "commit"}, {"oid": "ce9b481b26d7b50a8b7fd2d31d4e0ed49afa4f75", "url": "https://github.com/triplea-game/triplea/commit/ce9b481b26d7b50a8b7fd2d31d4e0ed49afa4f75", "message": "Merge nested conditional statements", "committedDate": "2020-09-18T23:08:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjk0NA==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491232944", "bodyText": "The \"xxWins\" seems to be an enumeration of the ' WhoWon' enum. WDYT if we parameterized the API instead?\nEG:\nbattleComplete(IDelegateBridge bridge,  WhoWon battleResult);", "author": "DanVanAtta", "createdAt": "2020-09-18T23:22:01Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleActions.java", "diffHunk": "@@ -39,6 +39,10 @@ void landParatroopers(\n \n   void attackerWins(IDelegateBridge bridge);\n \n+  void defenderWins(IDelegateBridge bridge);\n+\n+  void nobodyWins(IDelegateBridge bridge);", "originalCommit": "ce9b481b26d7b50a8b7fd2d31d4e0ed49afa4f75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI1OTc4Mw==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491259783", "bodyText": "Yup, one of the things I plan to work on after this is done.", "author": "trevan", "createdAt": "2020-09-19T02:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzEzMw==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491233133", "bodyText": "While thinking about parameterizing APIs, should we parameterize this as well? Should this even be an API method come to think of it?\nWhat if the caller were to do the filtering it needed on its own leaving the API to be simply \"getAttackers()\".", "author": "DanVanAtta", "createdAt": "2020-09-18T23:23:12Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -35,6 +40,8 @@ public Side getOpposite() {\n \n   Collection<Unit> getBombardingUnits();\n \n+  Collection<Unit> getAmphibiousLandAttackers();", "originalCommit": "ce9b481b26d7b50a8b7fd2d31d4e0ed49afa4f75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2MTYzNg==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491261636", "bodyText": "I thought about doing that as part of this PR but discovered that the amphibiousLandAttackers list was being generated in a manner that didn't lend to allowing the caller to generate.  I need to do more investigation and see why it is being done that way and if I can change it without causing problems.", "author": "trevan", "createdAt": "2020-09-19T03:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzUyOA==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491233528", "bodyText": "I think we might be seeing a data clump code-smell here with getMaxBattleRounds & getBattleRounds().\nExtract object is the refactoring pattern to fix that, in this case that would be a BattleRound object.\nThen for example this code would be:\nreturn battleState.getBattleRound().hasMoreRounds() || (getPower ...)\n\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-09-18T23:25:05Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/CheckGeneralBattleEnd.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AllArgsConstructor;\n+\n+@AllArgsConstructor\n+public class CheckGeneralBattleEnd implements BattleStep {\n+  private static final long serialVersionUID = 5172121497955756220L;\n+\n+  private final BattleState battleState;\n+\n+  private final BattleActions battleActions;\n+\n+  protected BattleActions getBattleActions() {\n+    return battleActions;\n+  }\n+\n+  protected BattleState getBattleState() {\n+    return battleState;\n+  }\n+\n+  @Override\n+  public List<String> getNames() {\n+    return List.of();\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.GENERAL_BATTLE_END_CHECK;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    if (hasSideLost(BattleState.Side.OFFENSE)) {\n+      battleActions.endBattle(bridge);\n+      battleActions.defenderWins(bridge);\n+\n+    } else if (hasSideLost(BattleState.Side.DEFENSE)) {\n+      battleActions.endBattle(bridge);\n+      battleActions.attackerWins(bridge);\n+\n+    } else if (isStalemate() && !canAttackerRetreatInStalemate()) {\n+      battleActions.endBattle(bridge);\n+      battleActions.nobodyWins(bridge);\n+    }\n+  }\n+\n+  protected boolean hasSideLost(final BattleState.Side side) {\n+    return battleState.getUnits(side).stream().noneMatch(Matches.unitIsNotInfrastructure());\n+  }\n+\n+  protected boolean isStalemate() {\n+    return (battleState.getMaxBattleRounds() > 0", "originalCommit": "ce9b481b26d7b50a8b7fd2d31d4e0ed49afa4f75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2MjQyMQ==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491262421", "bodyText": "getBattleRound() is already used and has an int return value.  So I used getBattleRoundState() unless you have a better name idea.", "author": "trevan", "createdAt": "2020-09-19T03:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MDk1Nw==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491280957", "bodyText": "I'm suggesting that getBattleRound() should return a BattleRound object. I''m not really suggesting to rename. The code smell is that we are always using both 'max rounds' and 'current rounds' together, that is the data clump (https://martinfowler.com/bliki/DataClump.html)", "author": "DanVanAtta", "createdAt": "2020-09-19T05:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQzNjcyOQ==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491436729", "bodyText": "I understand that.  But getBattleRound() already exists outside of the BattleState interface and is used by other classes that aren't battle steps.  So, to prevent having to change those classes, I modified BattleState to not expose getBattleRound() but to instead expose getBattleRoundState() and that returns the BattleRound object.", "author": "trevan", "createdAt": "2020-09-19T13:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ5Nzc4NA==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491497784", "bodyText": "Ah, understood. I wonder then if we actually have a true data clump if those other locations only need the current round.", "author": "DanVanAtta", "createdAt": "2020-09-19T19:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNDA1Nw==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491234057", "bodyText": "\ud83d\udc4d\nThis looks good. We've had issues of marking changes that needed to happen on the next major release and have missed some or come across them and were then unsure of what to change exactly. It looks like this annotation is working out, I'm much more confident on next major we'll catch & fix these types of things.", "author": "DanVanAtta", "createdAt": "2020-09-18T23:27:35Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnits.java", "diffHunk": "@@ -52,6 +53,7 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n     removeUnprotectedUnits(bridge, BattleState.Side.OFFENSE);\n   }\n \n+  @RemoveOnNextMajorRelease(\"This doesn't need to be public in the next major release\")", "originalCommit": "ce9b481b26d7b50a8b7fd2d31d4e0ed49afa4f75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNDY1MA==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491234650", "bodyText": "It does not look like there is much implementation here and this is mostly a configuration class.\nWhat do you think of creating a more generic variant of this class? It looks like all we would need to do it to parameterize the 'getOrder()' value as a constructor arg, and then we could simply return it. Can we potentially reduce the inheritance tree even and have the super class do some of this work, particularly if it had a constructor that accepted the getNames() and getOrder() values? Since those are constants, it seems like we probably could new-up the parent directly.", "author": "DanVanAtta", "createdAt": "2020-09-18T23:30:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/change/RemoveUnprotectedUnitsGeneral.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package games.strategy.triplea.delegate.battle.steps.change;\n+\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+\n+public class RemoveUnprotectedUnitsGeneral extends RemoveUnprotectedUnits {\n+  public RemoveUnprotectedUnitsGeneral(\n+      final BattleState battleState, final BattleActions battleActions) {\n+    super(battleState, battleActions);\n+  }\n+\n+  @Override\n+  public List<String> getNames() {\n+    return List.of();\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_UNPROTECTED_UNITS_GENERAL;", "originalCommit": "ce9b481b26d7b50a8b7fd2d31d4e0ed49afa4f75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNjA0OQ==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491236049", "bodyText": "Looking at this a bit more, I do think we should avoid the inheritance tree and see if we can flatten this. A rule of thumb is to never override methods that have implementations. It generally makes code hard to understand, test, and inheritance is the strongest form of coupling. Instead just make the parent method abstract, convert the parent class into two, one that is abstract and a second that has the original implementation from the parent. Then this class would become a second child.\nWhat that would look like is:\n\nBut, the differences between the child classes are just constants, configuration, not behavior. In this case I'd flatten it more so you would just new up the BattleStep via a factory type of pattern and inject the right configurations and some behavior for the execution, EG:\nBattleStep RemoveUnprotectedUnits = BattleStepFactory.builder()\n    .names( ... )\n    .order( ...)\n    .executable( removeUnprotectedUnitsExecutable(bridge))\n    .build()\n    .toBattleStep();\n\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-09-18T23:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNDY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI2OTc1MQ==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491269751", "bodyText": "The problem is save compatibility.  RemoveUnprotectedUnits is part of the saved file and so it has to be able to deserialize correctly.  I can add a parent to it but I can't move the two private variables.  That would mean that I would need to add abstract getBattleState and getBattleActions methods to the parent class and then have the two child classes overload them to make the variables available to the parent methods.  That just feels weird.\nAs for the builder idea, that means that now the configuration is part of the saved file and it makes it even harder to change code in the future.  I would much rather keep it in classes with as little class state as possible.", "author": "trevan", "createdAt": "2020-09-19T04:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNDY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ5NzUwMA==", "url": "https://github.com/triplea-game/triplea/pull/7692#discussion_r491497500", "bodyText": "I kinda suspect there might be some ways around the serialization issue, though perhaps not.. It is of course frustrating that serialization concerns really impacts our code design (and in this case, forces inheritance. I wonder a bit how many \"Java inheritance now considered harmful\" articles there are by now).", "author": "DanVanAtta", "createdAt": "2020-09-19T19:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNDY1MA=="}], "type": "inlineReview"}, {"oid": "e72f52c95e18f67e8df33115308a5f79022f0354", "url": "https://github.com/triplea-game/triplea/commit/e72f52c95e18f67e8df33115308a5f79022f0354", "message": "Create a BattleRound value object to track first and last rounds", "committedDate": "2020-09-19T03:23:14Z", "type": "commit"}]}