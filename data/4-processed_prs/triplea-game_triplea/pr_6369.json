{"pr_number": 6369, "pr_title": "Consider left over run count for BattleCalc", "pr_createdAt": "2020-05-02T23:15:45Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6369", "timeline": [{"oid": "83254c8ae280622d88837dd465a79d5a1354fa9e", "url": "https://github.com/triplea-game/triplea/commit/83254c8ae280622d88837dd465a79d5a1354fa9e", "message": "Consider overflow calculations", "committedDate": "2020-05-02T23:10:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAyMDEzNA==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419020134", "bodyText": "tbh I'm not quite sure if we actually need this.\nIf something is wrong with the data we should get an exception at some point, but IMO this doesn't add anything to potential error handling", "author": "RoiEXLab", "createdAt": "2020-05-02T23:17:22Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -223,44 +224,43 @@ public AggregateResults calculate(\n       final Collection<Unit> bombarding,\n       final Collection<TerritoryEffect> territoryEffects,\n       final boolean retreatWhenOnlyAirLeft,\n-      final int initialRunCount)\n+      final int runCount)\n       throws IllegalStateException {\n     synchronized (mutexCalcIsRunning) {\n       awaitLatch();\n       final long start = System.currentTimeMillis();\n+      final AtomicBoolean overflowRunsAvailable = new AtomicBoolean(true);\n       // Create worker thread pool and start all workers\n-      int totalRunCount = 0;\n-      int runCount = initialRunCount;\n-      final int workerNum = workers.size();\n-      final int workerRunCount = Math.max(1, (runCount / Math.max(1, workerNum)));\n-      final List<Future<AggregateResults>> list = new ArrayList<>();\n-      for (final BattleCalculator worker : workers) {\n-        if (!getIsReady()) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort with null data\n-          return new AggregateResults(0);\n-        }\n-        final int currentWorkedRunCount = (runCount <= 0 ? 0 : workerRunCount);\n-        if (currentWorkedRunCount > 0) {\n-          totalRunCount += currentWorkedRunCount;\n-          list.add(\n-              executor.submit(\n-                  () ->\n-                      worker.calculate(\n-                          attacker,\n-                          defender,\n-                          location,\n-                          attacking,\n-                          defending,\n-                          bombarding,\n-                          territoryEffects,\n-                          retreatWhenOnlyAirLeft,\n-                          currentWorkedRunCount)));\n-        }\n-        runCount -= workerRunCount;\n+      final int runsPerWorker = runCount / workers.size();\n+      final List<Future<AggregateResults>> list =\n+          workers.stream()\n+              .map(\n+                  worker ->\n+                      executor.submit(\n+                          () ->\n+                              worker.calculate(\n+                                  attacker,\n+                                  defender,\n+                                  location,\n+                                  attacking,\n+                                  defending,\n+                                  bombarding,\n+                                  territoryEffects,\n+                                  retreatWhenOnlyAirLeft,\n+                                  // Ensure that we always achieve the target run count even if\n+                                  // the number is not dividable by workers.size()\n+                                  (overflowRunsAvailable.getAndSet(false)\n+                                          ? runCount % workers.size()\n+                                          : 0)\n+                                      + runsPerWorker)))\n+              .collect(Collectors.toList());\n+      if (!getIsReady()) {\n+        // we could have attempted to set a new game data, while the old one was still being set,\n+        // causing it to abort with null data\n+        return new AggregateResults(0);", "originalCommit": "83254c8ae280622d88837dd465a79d5a1354fa9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f3b64ca0410c1f089727559c2d4e9672b7c8591", "url": "https://github.com/triplea-game/triplea/commit/3f3b64ca0410c1f089727559c2d4e9672b7c8591", "message": "Divide overflow more evenly over different threads", "committedDate": "2020-05-02T23:26:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MDIwMQ==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419040201", "bodyText": "Question: I wonder if there is a way to make this a bit faster/easier to understand?\nSuggestion: Have you considered extracting this bit of logic to a method perhaps? In that case the bit of logic could be labelled and perhaps be commented.", "author": "DanVanAtta", "createdAt": "2020-05-03T03:22:11Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -223,44 +223,41 @@ public AggregateResults calculate(\n       final Collection<Unit> bombarding,\n       final Collection<TerritoryEffect> territoryEffects,\n       final boolean retreatWhenOnlyAirLeft,\n-      final int initialRunCount)\n+      final int runCount)\n       throws IllegalStateException {\n     synchronized (mutexCalcIsRunning) {\n       awaitLatch();\n       final long start = System.currentTimeMillis();\n+      final AtomicInteger overflowRunsAvailable = new AtomicInteger(runCount % workers.size());\n       // Create worker thread pool and start all workers\n-      int totalRunCount = 0;\n-      int runCount = initialRunCount;\n-      final int workerNum = workers.size();\n-      final int workerRunCount = Math.max(1, (runCount / Math.max(1, workerNum)));\n-      final List<Future<AggregateResults>> list = new ArrayList<>();\n-      for (final BattleCalculator worker : workers) {\n-        if (!getIsReady()) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort with null data\n-          return new AggregateResults(0);\n-        }\n-        final int currentWorkedRunCount = (runCount <= 0 ? 0 : workerRunCount);\n-        if (currentWorkedRunCount > 0) {\n-          totalRunCount += currentWorkedRunCount;\n-          list.add(\n-              executor.submit(\n-                  () ->\n-                      worker.calculate(\n-                          attacker,\n-                          defender,\n-                          location,\n-                          attacking,\n-                          defending,\n-                          bombarding,\n-                          territoryEffects,\n-                          retreatWhenOnlyAirLeft,\n-                          currentWorkedRunCount)));\n-        }\n-        runCount -= workerRunCount;\n+      final int runsPerWorker = runCount / workers.size();\n+      final List<Future<AggregateResults>> list =\n+          workers.stream()\n+              .map(\n+                  worker ->\n+                      executor.submit(\n+                          () ->\n+                              worker.calculate(\n+                                  attacker,\n+                                  defender,\n+                                  location,\n+                                  attacking,\n+                                  defending,\n+                                  bombarding,\n+                                  territoryEffects,\n+                                  retreatWhenOnlyAirLeft,\n+                                  // Ensure that we always achieve the target run count even if\n+                                  // the number is not dividable by workers.size()\n+                                  (overflowRunsAvailable.getAndDecrement() > 0 ? 1 : 0)", "originalCommit": "3f3b64ca0410c1f089727559c2d4e9672b7c8591", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA4NjQxNw==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419086417", "bodyText": "I have thought about extracting the logic into a method, but you'd still have to pass an AtomicInteger instance to the method because it has to be shared for the same call.\nHowever I think extracting this \"distribution\" to an object and adding unit tests for that could be an elegant abstraction.\nI won't have the time to do this today, this will have to wait a couple of days.", "author": "RoiEXLab", "createdAt": "2020-05-03T11:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MDIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MDI0OQ==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419040249", "bodyText": "suggestion: What are your thoughts to add a postcondition here to check that sum of aggregated results is equal to the run count?", "author": "DanVanAtta", "createdAt": "2020-05-03T03:23:04Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -223,44 +223,41 @@ public AggregateResults calculate(\n       final Collection<Unit> bombarding,\n       final Collection<TerritoryEffect> territoryEffects,\n       final boolean retreatWhenOnlyAirLeft,\n-      final int initialRunCount)\n+      final int runCount)\n       throws IllegalStateException {\n     synchronized (mutexCalcIsRunning) {\n       awaitLatch();\n       final long start = System.currentTimeMillis();\n+      final AtomicInteger overflowRunsAvailable = new AtomicInteger(runCount % workers.size());\n       // Create worker thread pool and start all workers\n-      int totalRunCount = 0;\n-      int runCount = initialRunCount;\n-      final int workerNum = workers.size();\n-      final int workerRunCount = Math.max(1, (runCount / Math.max(1, workerNum)));\n-      final List<Future<AggregateResults>> list = new ArrayList<>();\n-      for (final BattleCalculator worker : workers) {\n-        if (!getIsReady()) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort with null data\n-          return new AggregateResults(0);\n-        }\n-        final int currentWorkedRunCount = (runCount <= 0 ? 0 : workerRunCount);\n-        if (currentWorkedRunCount > 0) {\n-          totalRunCount += currentWorkedRunCount;\n-          list.add(\n-              executor.submit(\n-                  () ->\n-                      worker.calculate(\n-                          attacker,\n-                          defender,\n-                          location,\n-                          attacking,\n-                          defending,\n-                          bombarding,\n-                          territoryEffects,\n-                          retreatWhenOnlyAirLeft,\n-                          currentWorkedRunCount)));\n-        }\n-        runCount -= workerRunCount;\n+      final int runsPerWorker = runCount / workers.size();\n+      final List<Future<AggregateResults>> list =\n+          workers.stream()\n+              .map(\n+                  worker ->\n+                      executor.submit(\n+                          () ->\n+                              worker.calculate(\n+                                  attacker,\n+                                  defender,\n+                                  location,\n+                                  attacking,\n+                                  defending,\n+                                  bombarding,\n+                                  territoryEffects,\n+                                  retreatWhenOnlyAirLeft,\n+                                  // Ensure that we always achieve the target run count even if\n+                                  // the number is not dividable by workers.size()\n+                                  (overflowRunsAvailable.getAndDecrement() > 0 ? 1 : 0)\n+                                      + runsPerWorker)))\n+              .collect(Collectors.toList());", "originalCommit": "3f3b64ca0410c1f089727559c2d4e9672b7c8591", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA4NzE2Mw==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419087163", "bodyText": "Not quite sure if that would make sense.\nI mean in the end it doesn't really matter if we get exactly the number of runs we required or just something that's very similar. The only \"real\" reason that would cause a significant difference in runs would be if a worker got an exception, which should be caught by our error handling later anyways.\nSo in the end if I make the \"distribution logic\" its own stateful object that distributes run counts evenly we could just add unit tests for that and that should make any potential post-condition redundant", "author": "RoiEXLab", "createdAt": "2020-05-03T11:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MDI0OQ=="}], "type": "inlineReview"}, {"oid": "21a683d5cd8964bc0c80414ab0267131c1ba9beb", "url": "https://github.com/triplea-game/triplea/commit/21a683d5cd8964bc0c80414ab0267131c1ba9beb", "message": "Extract counting logic to dedicated class", "committedDate": "2020-05-04T16:08:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDU1MQ==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419554551", "bodyText": "I'm actually not sure if we need this strict behaviour.\nIf we drop this exception we could also drop the field targetLeftover", "author": "RoiEXLab", "createdAt": "2020-05-04T16:14:04Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/RunCountDistributor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package games.strategy.triplea.odds.calculator;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Helper class to divide any integer into smaller integers that are the original integer when\n+ * summed up.\n+ */\n+@ThreadSafe\n+class RunCountDistributor {\n+  private final int runsPerWorker;\n+  private final int targetLeftover;\n+  private final AtomicInteger leftoverRuns;\n+\n+  /**\n+   * Creates a new RunCountDistributorInstance.\n+   *\n+   * @param runCount What all of the individual run-counts should sum up to\n+   * @param parallelism How many times {@link #nextRunCount()} will get called.\n+   */\n+  RunCountDistributor(final int runCount, final int parallelism) {\n+    Preconditions.checkState(parallelism > 0, \"The parallelism level has to be positive!\");\n+\n+    runsPerWorker = runCount / parallelism;\n+    leftoverRuns = new AtomicInteger(runCount % parallelism);\n+    targetLeftover = leftoverRuns.get() - parallelism;\n+  }\n+\n+  /**\n+   * Returns the next run-count.\n+   *\n+   * @throws IllegalStateException If this method was called more often than provided level of\n+   *     parallelism.\n+   */\n+  int nextRunCount() {\n+    final int leftoverRuns = this.leftoverRuns.getAndDecrement();\n+    if (leftoverRuns <= targetLeftover) {\n+      throw new IllegalStateException(", "originalCommit": "21a683d5cd8964bc0c80414ab0267131c1ba9beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDgzMA==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419554830", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-04T16:14:30Z", "path": "game-core/src/test/java/games/strategy/triplea/odds/calculator/RunCountDistributorTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package games.strategy.triplea.odds.calculator;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.stream.IntStream;\n+import org.junit.jupiter.api.Test;\n+\n+public class RunCountDistributorTest {\n+\n+  @Test\n+  void verifyEvenDistributionWhenCleanlyDividable() {\n+    final var runCountDistributor = new RunCountDistributor(20, 4);\n+\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+  }\n+\n+  @Test", "originalCommit": "21a683d5cd8964bc0c80414ab0267131c1ba9beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDgzNA==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419554834", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-04T16:14:30Z", "path": "game-core/src/test/java/games/strategy/triplea/odds/calculator/RunCountDistributorTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package games.strategy.triplea.odds.calculator;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.stream.IntStream;\n+import org.junit.jupiter.api.Test;\n+\n+public class RunCountDistributorTest {\n+\n+  @Test\n+  void verifyEvenDistributionWhenCleanlyDividable() {\n+    final var runCountDistributor = new RunCountDistributor(20, 4);\n+\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+  }\n+\n+  @Test\n+  void verifyDistributionWhenNotCleanlyDividable() {\n+    final var runCountDistributor = new RunCountDistributor(13, 3);\n+\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(4)));\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(4)));\n+  }\n+\n+  @Test", "originalCommit": "21a683d5cd8964bc0c80414ab0267131c1ba9beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMTU3Mg==", "url": "https://github.com/triplea-game/triplea/pull/6369#discussion_r419621572", "bodyText": "Minor suggestion: Might be good to have a display name to say we are spawning 4 threads and each should have 5. It's not immediately clear why there is repetition.", "author": "DanVanAtta", "createdAt": "2020-05-04T17:58:55Z", "path": "game-core/src/test/java/games/strategy/triplea/odds/calculator/RunCountDistributorTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package games.strategy.triplea.odds.calculator;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.stream.IntStream;\n+import org.junit.jupiter.api.Test;\n+\n+public class RunCountDistributorTest {\n+\n+  @Test\n+  void verifyEvenDistributionWhenCleanlyDividable() {\n+    final var runCountDistributor = new RunCountDistributor(20, 4);\n+\n+    assertThat(runCountDistributor.nextRunCount(), is(equalTo(5)));", "originalCommit": "21a683d5cd8964bc0c80414ab0267131c1ba9beb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}