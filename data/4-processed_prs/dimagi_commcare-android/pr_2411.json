{"pr_number": 2411, "pr_title": "Text to speech support", "pr_createdAt": "2020-11-30T12:46:41Z", "pr_url": "https://github.com/dimagi/commcare-android/pull/2411", "timeline": [{"oid": "a7367cd8c4afce85aeb5702ffe3f54f06e37f9ca", "url": "https://github.com/dimagi/commcare-android/commit/a7367cd8c4afce85aeb5702ffe3f54f06e37f9ca", "message": "Add Text to speech engine", "committedDate": "2020-11-30T11:24:24Z", "type": "commit"}, {"oid": "0d18314bb3bcea0d10add5e3f7578ad9467d1699", "url": "https://github.com/dimagi/commcare-android/commit/0d18314bb3bcea0d10add5e3f7578ad9467d1699", "message": "Add app preference for text-to-speech", "committedDate": "2020-11-30T12:43:50Z", "type": "commit"}, {"oid": "1d9947b601770a50ea05d9e942c0b10c6d335679", "url": "https://github.com/dimagi/commcare-android/commit/1d9947b601770a50ea05d9e942c0b10c6d335679", "message": "Add tts button to question view", "committedDate": "2020-12-01T05:08:43Z", "type": "forcePushed"}, {"oid": "046ff1a184e3c051dcacbe59a5c97028495e3a3a", "url": "https://github.com/dimagi/commcare-android/commit/046ff1a184e3c051dcacbe59a5c97028495e3a3a", "message": "Add tts button to question view", "committedDate": "2020-12-01T05:23:44Z", "type": "commit"}, {"oid": "046ff1a184e3c051dcacbe59a5c97028495e3a3a", "url": "https://github.com/dimagi/commcare-android/commit/046ff1a184e3c051dcacbe59a5c97028495e3a3a", "message": "Add tts button to question view", "committedDate": "2020-12-01T05:23:44Z", "type": "forcePushed"}, {"oid": "9dda46be1986ed5e7d7da881b718cb0558002106", "url": "https://github.com/dimagi/commcare-android/commit/9dda46be1986ed5e7d7da881b718cb0558002106", "message": "Stop audio when app goes to background", "committedDate": "2020-12-01T05:54:16Z", "type": "commit"}, {"oid": "cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "url": "https://github.com/dimagi/commcare-android/commit/cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "message": "Use lazy initialization for TTS", "committedDate": "2020-12-01T10:14:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc1NDY4NQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r534754685", "bodyText": "I think tts should be shown irrespective of all other media content except the audioURI i.e. only when audioURI is present we don't want the TTS settings to take effect but in all other cases if TTS is enabled, we should show the TTS button.", "author": "shubham1g5", "createdAt": "2020-12-03T06:53:41Z", "path": "app/src/org/commcare/views/media/MediaLayout.java", "diffHunk": "@@ -103,9 +105,15 @@ public static MediaLayout buildComprehensiveLayout(Context context,\n                                                        TextView text, String audioURI, String imageURI,\n                                                        final String videoURI, final String bigImageURI,\n                                                        final String qrCodeContent, String inlineVideoURI,\n+                                                       final String ttsText,\n                                                        int questionIndex) {\n         MediaLayout mediaLayout = new MediaLayout(context);\n         mediaLayout.setAVT(text, audioURI, imageURI, videoURI, bigImageURI, qrCodeContent, inlineVideoURI, false, questionIndex);\n+        // Show TTS view only when no other media is present\n+        if (ttsText != null && audioURI == null && imageURI == null && videoURI == null", "originalCommit": "cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg0NTkxOA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535845918", "bodyText": "Sure, will add this.", "author": "ShivamPokhriyal", "createdAt": "2020-12-04T05:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc1NDY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg1NTk5MA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r534855990", "bodyText": "4000 should not be hardcoded and use same mechanism as isTextLong to get the chunk length.", "author": "shubham1g5", "createdAt": "2020-12-03T07:57:43Z", "path": "app/src/org/commcare/tts/TextToSpeechConverter.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.commcare.tts\n+\n+import android.content.Context\n+import android.os.Build\n+import android.os.Handler\n+import android.os.Looper\n+import android.speech.tts.TextToSpeech\n+import android.speech.tts.UtteranceProgressListener\n+import android.text.TextUtils\n+\n+import org.javarosa.core.services.locale.Localization\n+\n+import java.util.Locale\n+import java.util.LinkedList\n+\n+import kotlin.collections.HashMap\n+\n+/**\n+ * Utility for Android's {@link android.speech.tts.TextToSpeech} that handles initialization, shutdown,\n+ * locale setting.\n+ */\n+object TextToSpeechConverter {\n+\n+    private const val MAX_TEXT_LENGTH = 4000\n+    private var mTextToSpeech: TextToSpeech? = null\n+    private var mInitialized: Boolean = false\n+    private var mTTSCallback: TextToSpeechCallback? = null\n+    private val mUtteranceProgressListener = object: UtteranceProgressListener() {\n+        // The callbacks specified here can be called from multiple threads.\n+        override fun onDone(utteranceId: String?) { }\n+\n+        override fun onError(utteranceId: String?) {\n+            Handler(Looper.getMainLooper()).post {\n+                mTTSCallback?.speakFailed()\n+            }\n+        }\n+\n+        override fun onStart(utteranceId: String?) { }\n+    }\n+\n+    /**\n+     * Adds a listener to register callbacks for different states of Text-To-Speech engine.\n+     */\n+    fun setListener(listener: TextToSpeechCallback) {\n+        mTTSCallback = listener\n+    }\n+\n+    /**\n+     * Attempts to speak the specified text.\n+     */\n+    fun speak(context: Context, text: String) {\n+        if (!mInitialized) {\n+            initialize(context, text)\n+            return\n+        }\n+        // Handle empty text\n+        if (TextUtils.isEmpty(text)) {\n+            return\n+        }\n+        mTextToSpeech?.let { tts ->\n+            if (isTextLong(text)) {\n+                text.chunked(4000).forEach {", "originalCommit": "cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg0NTg0OA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535845848", "bodyText": "Ahh yes, thanks for pointing it out.", "author": "ShivamPokhriyal", "createdAt": "2020-12-04T05:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg1NTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg4MzY2Mw==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r534883663", "bodyText": "youc can just call dialog1.dismiss instead of re-querying for the dialog.", "author": "shubham1g5", "createdAt": "2020-12-03T08:12:57Z", "path": "app/src/org/commcare/activities/FormEntryActivity.java", "diffHunk": "@@ -167,6 +171,34 @@\n \n     private boolean fullFormProfilingEnabled = false;\n     private EvaluationTraceReporter traceReporter;\n+    private TextToSpeechCallback mTTSCallback = new TextToSpeechCallback() {\n+        @Override\n+        public void initFailed() {\n+            Toast.makeText(FormEntryActivity.this, Localization.get(\"tts.init.failed\"), Toast.LENGTH_LONG).show();\n+        }\n+\n+        @Override\n+        public void speakFailed() {\n+            Toast.makeText(FormEntryActivity.this, Localization.get(\"tts.speak.failed\"), Toast.LENGTH_LONG).show();\n+        }\n+\n+        @Override\n+        public void voiceDataMissing(String language) {\n+            StandardAlertDialog dialog = new StandardAlertDialog(\n+                    FormEntryActivity.this,\n+                    Localization.get(\"tts.data.missing.title\"),\n+                    Localization.get(\"tts.data.missing.message\", language));\n+            dialog.setPositiveButton(Localization.get(\"dialog.ok\"), (dialog1, which) -> {\n+                Intent installIntent = new Intent();\n+                installIntent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA);\n+                startActivity(installIntent);\n+            });\n+            dialog.setNegativeButton(Localization.get(\"option.cancel\"), (dialog1, which) -> {\n+                dismissAlertDialog();", "originalCommit": "cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg4NDY0Ng==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r534884646", "bodyText": "should dismiss the dialog once user has taken an action", "author": "shubham1g5", "createdAt": "2020-12-03T08:13:28Z", "path": "app/src/org/commcare/activities/FormEntryActivity.java", "diffHunk": "@@ -167,6 +171,34 @@\n \n     private boolean fullFormProfilingEnabled = false;\n     private EvaluationTraceReporter traceReporter;\n+    private TextToSpeechCallback mTTSCallback = new TextToSpeechCallback() {\n+        @Override\n+        public void initFailed() {\n+            Toast.makeText(FormEntryActivity.this, Localization.get(\"tts.init.failed\"), Toast.LENGTH_LONG).show();\n+        }\n+\n+        @Override\n+        public void speakFailed() {\n+            Toast.makeText(FormEntryActivity.this, Localization.get(\"tts.speak.failed\"), Toast.LENGTH_LONG).show();\n+        }\n+\n+        @Override\n+        public void voiceDataMissing(String language) {\n+            StandardAlertDialog dialog = new StandardAlertDialog(\n+                    FormEntryActivity.this,\n+                    Localization.get(\"tts.data.missing.title\"),\n+                    Localization.get(\"tts.data.missing.message\", language));\n+            dialog.setPositiveButton(Localization.get(\"dialog.ok\"), (dialog1, which) -> {\n+                Intent installIntent = new Intent();\n+                installIntent.setAction(TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA);\n+                startActivity(installIntent);", "originalCommit": "cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r534936242", "bodyText": "the locale needs to be reapplied when user changes the language in form and we should also pass the conuntry code from default locale to account for accents.", "author": "shubham1g5", "createdAt": "2020-12-03T08:44:48Z", "path": "app/src/org/commcare/tts/TextToSpeechConverter.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.commcare.tts\n+\n+import android.content.Context\n+import android.os.Build\n+import android.os.Handler\n+import android.os.Looper\n+import android.speech.tts.TextToSpeech\n+import android.speech.tts.UtteranceProgressListener\n+import android.text.TextUtils\n+\n+import org.javarosa.core.services.locale.Localization\n+\n+import java.util.Locale\n+import java.util.LinkedList\n+\n+import kotlin.collections.HashMap\n+\n+/**\n+ * Utility for Android's {@link android.speech.tts.TextToSpeech} that handles initialization, shutdown,\n+ * locale setting.\n+ */\n+object TextToSpeechConverter {\n+\n+    private const val MAX_TEXT_LENGTH = 4000\n+    private var mTextToSpeech: TextToSpeech? = null\n+    private var mInitialized: Boolean = false\n+    private var mTTSCallback: TextToSpeechCallback? = null\n+    private val mUtteranceProgressListener = object: UtteranceProgressListener() {\n+        // The callbacks specified here can be called from multiple threads.\n+        override fun onDone(utteranceId: String?) { }\n+\n+        override fun onError(utteranceId: String?) {\n+            Handler(Looper.getMainLooper()).post {\n+                mTTSCallback?.speakFailed()\n+            }\n+        }\n+\n+        override fun onStart(utteranceId: String?) { }\n+    }\n+\n+    /**\n+     * Adds a listener to register callbacks for different states of Text-To-Speech engine.\n+     */\n+    fun setListener(listener: TextToSpeechCallback) {\n+        mTTSCallback = listener\n+    }\n+\n+    /**\n+     * Attempts to speak the specified text.\n+     */\n+    fun speak(context: Context, text: String) {\n+        if (!mInitialized) {\n+            initialize(context, text)\n+            return\n+        }\n+        // Handle empty text\n+        if (TextUtils.isEmpty(text)) {\n+            return\n+        }\n+        mTextToSpeech?.let { tts ->\n+            if (isTextLong(text)) {\n+                text.chunked(4000).forEach {\n+                    speakInternal(tts, it, TextToSpeech.QUEUE_ADD)\n+                }\n+            } else {\n+                speakInternal(tts, text)\n+            }\n+        } ?: run {\n+            mTTSCallback?.initFailed()\n+        }\n+    }\n+\n+    /**\n+     * Attempts to stop the TTS.\n+     */\n+    fun stop() {\n+        mTextToSpeech?.let {\n+            it.stop()\n+        }\n+    }\n+\n+    /**\n+     * Attempts to shutdown the TTS engine. No calls should be made to this object after calling this method.\n+     * Good to call this from onDestroy().\n+     */\n+    fun shutDown() {\n+        mTextToSpeech?.let {\n+            it.shutdown()\n+        }\n+        mInitialized = false\n+    }\n+\n+    private fun speakInternal(tts: TextToSpeech, text: String, queueMode: Int = TextToSpeech.QUEUE_FLUSH) {\n+        val utteranceId = System.currentTimeMillis().toString()\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            tts.speak(text, queueMode, null, utteranceId)\n+        } else {\n+            val params = HashMap<String, String>()\n+            params[TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID] = utteranceId\n+            tts.speak(text, queueMode, params)\n+        }\n+    }\n+\n+    private fun isTextLong(text: String): Boolean {\n+        // TTS can only speak 4000 characters at max at a time.\n+        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n+            text.length > TextToSpeech.getMaxSpeechInputLength()\n+        } else {\n+            text.length > MAX_TEXT_LENGTH\n+        }\n+    }\n+\n+    /**\n+     * Initializes the Text-To-Speech engine\n+     */\n+    private fun initialize(context: Context, text: String) {\n+        mTextToSpeech = TextToSpeech(context, TextToSpeech.OnInitListener { status ->\n+            if (status == TextToSpeech.SUCCESS) {\n+                // set language and speak\n+                mTextToSpeech?.let { tts ->\n+                    tts.setOnUtteranceProgressListener(mUtteranceProgressListener)\n+                    if (setLocale(tts, LinkedList(listOf(\n+                                    Locale(Localization.getCurrentLocale()),", "originalCommit": "cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NzA3MQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535867071", "bodyText": "we should also pass the conuntry code from default locale to account for accents.\n\nHow do I get the country codes?", "author": "ShivamPokhriyal", "createdAt": "2020-12-04T06:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2OTA0MQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535869041", "bodyText": "You can get the default country code using Locale.getDefault().getCountry*", "author": "shubham1g5", "createdAt": "2020-12-04T06:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg3MzA3MA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535873070", "bodyText": "Ohh, I thought you were talking about the Localization.getCurrent one.\nLocale.getDefault() returns a locale with the country code like en_US.", "author": "ShivamPokhriyal", "createdAt": "2020-12-04T06:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg3Nzk3Ng==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535877976", "bodyText": "So If you comprise the current locale as Locale(Localization.getCurrentLocale(), Locale.getDefault().getCountry()) you should be able to add the country info user is in to the language right ?", "author": "shubham1g5", "createdAt": "2020-12-04T06:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg3OTk1NA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535879954", "bodyText": "Ohh, I don't think that makes sense, like if Localization.getCurrentLocale() returns Arabic, and Locale.getDefault().getCountry() returns US. I'm not sure if it works like that.", "author": "ShivamPokhriyal", "createdAt": "2020-12-04T07:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NjIyOQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535886229", "bodyText": "What I am thinking is if a user in India who has set the device language to Hindi, Locale.getDefault().getCountry() should return India as the country and setting that context will improve the TTS by far in comparison to having a US accent for Hindi.   In case of (Arabic, US) the TTS should still return TextToSpeech.LANG_AVAILABLE so the behaviour won't get changed in comparison to just (Arabic).", "author": "shubham1g5", "createdAt": "2020-12-04T07:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5MTk1NA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535891954", "bodyText": "ohh ok. I'll test how it works.", "author": "ShivamPokhriyal", "createdAt": "2020-12-04T07:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg5MTQ0NA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r540891444", "bodyText": "Wondering if there are any concerns with this approach from the testing you did ?", "author": "shubham1g5", "createdAt": "2020-12-11T11:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEwNTY5NQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r542105695", "bodyText": "It worked fine for me.", "author": "ShivamPokhriyal", "createdAt": "2020-12-14T04:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkzNjI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk0MTkyOA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r534941928", "bodyText": "if it does not work at all, is there any sense of having it in code ?", "author": "shubham1g5", "createdAt": "2020-12-03T08:47:40Z", "path": "app/src/org/commcare/tts/TextToSpeechConverter.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.commcare.tts\n+\n+import android.content.Context\n+import android.os.Build\n+import android.os.Handler\n+import android.os.Looper\n+import android.speech.tts.TextToSpeech\n+import android.speech.tts.UtteranceProgressListener\n+import android.text.TextUtils\n+\n+import org.javarosa.core.services.locale.Localization\n+\n+import java.util.Locale\n+import java.util.LinkedList\n+\n+import kotlin.collections.HashMap\n+\n+/**\n+ * Utility for Android's {@link android.speech.tts.TextToSpeech} that handles initialization, shutdown,\n+ * locale setting.\n+ */\n+object TextToSpeechConverter {\n+\n+    private const val MAX_TEXT_LENGTH = 4000\n+    private var mTextToSpeech: TextToSpeech? = null\n+    private var mInitialized: Boolean = false\n+    private var mTTSCallback: TextToSpeechCallback? = null\n+    private val mUtteranceProgressListener = object: UtteranceProgressListener() {\n+        // The callbacks specified here can be called from multiple threads.\n+        override fun onDone(utteranceId: String?) { }\n+\n+        override fun onError(utteranceId: String?) {\n+            Handler(Looper.getMainLooper()).post {\n+                mTTSCallback?.speakFailed()\n+            }\n+        }\n+\n+        override fun onStart(utteranceId: String?) { }\n+    }\n+\n+    /**\n+     * Adds a listener to register callbacks for different states of Text-To-Speech engine.\n+     */\n+    fun setListener(listener: TextToSpeechCallback) {\n+        mTTSCallback = listener\n+    }\n+\n+    /**\n+     * Attempts to speak the specified text.\n+     */\n+    fun speak(context: Context, text: String) {\n+        if (!mInitialized) {\n+            initialize(context, text)\n+            return\n+        }\n+        // Handle empty text\n+        if (TextUtils.isEmpty(text)) {\n+            return\n+        }\n+        mTextToSpeech?.let { tts ->\n+            if (isTextLong(text)) {\n+                text.chunked(4000).forEach {\n+                    speakInternal(tts, it, TextToSpeech.QUEUE_ADD)\n+                }\n+            } else {\n+                speakInternal(tts, text)\n+            }\n+        } ?: run {\n+            mTTSCallback?.initFailed()\n+        }\n+    }\n+\n+    /**\n+     * Attempts to stop the TTS.\n+     */\n+    fun stop() {\n+        mTextToSpeech?.let {\n+            it.stop()\n+        }\n+    }\n+\n+    /**\n+     * Attempts to shutdown the TTS engine. No calls should be made to this object after calling this method.\n+     * Good to call this from onDestroy().\n+     */\n+    fun shutDown() {\n+        mTextToSpeech?.let {\n+            it.shutdown()\n+        }\n+        mInitialized = false\n+    }\n+\n+    private fun speakInternal(tts: TextToSpeech, text: String, queueMode: Int = TextToSpeech.QUEUE_FLUSH) {\n+        val utteranceId = System.currentTimeMillis().toString()\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            tts.speak(text, queueMode, null, utteranceId)\n+        } else {\n+            val params = HashMap<String, String>()\n+            params[TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID] = utteranceId\n+            tts.speak(text, queueMode, params)\n+        }\n+    }\n+\n+    private fun isTextLong(text: String): Boolean {\n+        // TTS can only speak 4000 characters at max at a time.\n+        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n+            text.length > TextToSpeech.getMaxSpeechInputLength()\n+        } else {\n+            text.length > MAX_TEXT_LENGTH\n+        }\n+    }\n+\n+    /**\n+     * Initializes the Text-To-Speech engine\n+     */\n+    private fun initialize(context: Context, text: String) {\n+        mTextToSpeech = TextToSpeech(context, TextToSpeech.OnInitListener { status ->\n+            if (status == TextToSpeech.SUCCESS) {\n+                // set language and speak\n+                mTextToSpeech?.let { tts ->\n+                    tts.setOnUtteranceProgressListener(mUtteranceProgressListener)\n+                    if (setLocale(tts, LinkedList(listOf(\n+                                    Locale(Localization.getCurrentLocale()),\n+                                    Locale.getDefault(),\n+                                    Locale.ENGLISH)))) {\n+                        // tts initialization completed.\n+                        mInitialized = true\n+                        speak(context, text)\n+                    }\n+                }\n+            } else {\n+                mTTSCallback?.initFailed()\n+            }\n+        })\n+    }\n+\n+    /**\n+     * Sets a TTS language from the given list of locale starting from the first Locale.\n+     *\n+     * Returns a boolean indicating whether we TTS language is ready to use.\n+     */\n+    private fun setLocale(tts: TextToSpeech, localeList: LinkedList<Locale>): Boolean {\n+        if (localeList.isEmpty()) {\n+            return false\n+        }\n+        val locale = localeList.pop()\n+        return when (tts.isLanguageAvailable(locale)) {\n+            TextToSpeech.LANG_AVAILABLE,\n+            TextToSpeech.LANG_COUNTRY_AVAILABLE,\n+            TextToSpeech.LANG_COUNTRY_VAR_AVAILABLE -> {\n+                // Set language\n+                tts.language = locale\n+\n+                // Check if voice data is present or not.\n+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+                    if (tts.voice != null) {\n+                        val features = tts.voice.features\n+                        if (features == null\n+                                || features.contains(TextToSpeech.Engine.KEY_FEATURE_NOT_INSTALLED)\n+                                || tts.voice.isNetworkConnectionRequired) {\n+                            // voice data is not present\n+                            mTTSCallback?.voiceDataMissing(locale.displayLanguage)\n+                            return false\n+                        }\n+                    }\n+                } else {\n+                    val features = tts.getFeatures(locale)\n+                    if (features == null || features.contains(\"notInstalled\")) {\n+                        mTTSCallback?.voiceDataMissing(locale.displayLanguage)\n+                        return false\n+                    }\n+                }\n+                // voice data is present so return true that we're ready to use.\n+                true\n+            }\n+            TextToSpeech.LANG_MISSING_DATA -> {\n+                // Unfortunately this callback doesn't really work.", "originalCommit": "cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2ODU1Mw==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535868553", "bodyText": "It didn't work for me in different android versions, but it's quite possible that the next TTS update of google might fix this, so I think the code would be useful then.", "author": "ShivamPokhriyal", "createdAt": "2020-12-04T06:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk0MTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg3MDYxMw==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535870613", "bodyText": "makes sense.", "author": "shubham1g5", "createdAt": "2020-12-04T06:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk0MTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk0MzM0OQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r534943349", "bodyText": "should we returning false when tts.voice==null ?", "author": "shubham1g5", "createdAt": "2020-12-03T08:48:21Z", "path": "app/src/org/commcare/tts/TextToSpeechConverter.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.commcare.tts\n+\n+import android.content.Context\n+import android.os.Build\n+import android.os.Handler\n+import android.os.Looper\n+import android.speech.tts.TextToSpeech\n+import android.speech.tts.UtteranceProgressListener\n+import android.text.TextUtils\n+\n+import org.javarosa.core.services.locale.Localization\n+\n+import java.util.Locale\n+import java.util.LinkedList\n+\n+import kotlin.collections.HashMap\n+\n+/**\n+ * Utility for Android's {@link android.speech.tts.TextToSpeech} that handles initialization, shutdown,\n+ * locale setting.\n+ */\n+object TextToSpeechConverter {\n+\n+    private const val MAX_TEXT_LENGTH = 4000\n+    private var mTextToSpeech: TextToSpeech? = null\n+    private var mInitialized: Boolean = false\n+    private var mTTSCallback: TextToSpeechCallback? = null\n+    private val mUtteranceProgressListener = object: UtteranceProgressListener() {\n+        // The callbacks specified here can be called from multiple threads.\n+        override fun onDone(utteranceId: String?) { }\n+\n+        override fun onError(utteranceId: String?) {\n+            Handler(Looper.getMainLooper()).post {\n+                mTTSCallback?.speakFailed()\n+            }\n+        }\n+\n+        override fun onStart(utteranceId: String?) { }\n+    }\n+\n+    /**\n+     * Adds a listener to register callbacks for different states of Text-To-Speech engine.\n+     */\n+    fun setListener(listener: TextToSpeechCallback) {\n+        mTTSCallback = listener\n+    }\n+\n+    /**\n+     * Attempts to speak the specified text.\n+     */\n+    fun speak(context: Context, text: String) {\n+        if (!mInitialized) {\n+            initialize(context, text)\n+            return\n+        }\n+        // Handle empty text\n+        if (TextUtils.isEmpty(text)) {\n+            return\n+        }\n+        mTextToSpeech?.let { tts ->\n+            if (isTextLong(text)) {\n+                text.chunked(4000).forEach {\n+                    speakInternal(tts, it, TextToSpeech.QUEUE_ADD)\n+                }\n+            } else {\n+                speakInternal(tts, text)\n+            }\n+        } ?: run {\n+            mTTSCallback?.initFailed()\n+        }\n+    }\n+\n+    /**\n+     * Attempts to stop the TTS.\n+     */\n+    fun stop() {\n+        mTextToSpeech?.let {\n+            it.stop()\n+        }\n+    }\n+\n+    /**\n+     * Attempts to shutdown the TTS engine. No calls should be made to this object after calling this method.\n+     * Good to call this from onDestroy().\n+     */\n+    fun shutDown() {\n+        mTextToSpeech?.let {\n+            it.shutdown()\n+        }\n+        mInitialized = false\n+    }\n+\n+    private fun speakInternal(tts: TextToSpeech, text: String, queueMode: Int = TextToSpeech.QUEUE_FLUSH) {\n+        val utteranceId = System.currentTimeMillis().toString()\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            tts.speak(text, queueMode, null, utteranceId)\n+        } else {\n+            val params = HashMap<String, String>()\n+            params[TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID] = utteranceId\n+            tts.speak(text, queueMode, params)\n+        }\n+    }\n+\n+    private fun isTextLong(text: String): Boolean {\n+        // TTS can only speak 4000 characters at max at a time.\n+        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n+            text.length > TextToSpeech.getMaxSpeechInputLength()\n+        } else {\n+            text.length > MAX_TEXT_LENGTH\n+        }\n+    }\n+\n+    /**\n+     * Initializes the Text-To-Speech engine\n+     */\n+    private fun initialize(context: Context, text: String) {\n+        mTextToSpeech = TextToSpeech(context, TextToSpeech.OnInitListener { status ->\n+            if (status == TextToSpeech.SUCCESS) {\n+                // set language and speak\n+                mTextToSpeech?.let { tts ->\n+                    tts.setOnUtteranceProgressListener(mUtteranceProgressListener)\n+                    if (setLocale(tts, LinkedList(listOf(\n+                                    Locale(Localization.getCurrentLocale()),\n+                                    Locale.getDefault(),\n+                                    Locale.ENGLISH)))) {\n+                        // tts initialization completed.\n+                        mInitialized = true\n+                        speak(context, text)\n+                    }\n+                }\n+            } else {\n+                mTTSCallback?.initFailed()\n+            }\n+        })\n+    }\n+\n+    /**\n+     * Sets a TTS language from the given list of locale starting from the first Locale.\n+     *\n+     * Returns a boolean indicating whether we TTS language is ready to use.\n+     */\n+    private fun setLocale(tts: TextToSpeech, localeList: LinkedList<Locale>): Boolean {\n+        if (localeList.isEmpty()) {\n+            return false\n+        }\n+        val locale = localeList.pop()\n+        return when (tts.isLanguageAvailable(locale)) {\n+            TextToSpeech.LANG_AVAILABLE,\n+            TextToSpeech.LANG_COUNTRY_AVAILABLE,\n+            TextToSpeech.LANG_COUNTRY_VAR_AVAILABLE -> {\n+                // Set language\n+                tts.language = locale\n+\n+                // Check if voice data is present or not.\n+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+                    if (tts.voice != null) {", "originalCommit": "cf1aee3d2c3fb9ba064f37a43b6c10847f61df54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg0ODYzNQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535848635", "bodyText": "actually no. tts.voice can be null for any reason but we know for sure that the language is available just that we won't be sure whether the voice data is available. So if we return false here, that means we're saying we can't use TTS at all, but we can. And if the internet is available, tts will work just fine. And if not, we'll simply say a toast that TTS won't work cuz utteranceListener onError will get called.", "author": "ShivamPokhriyal", "createdAt": "2020-12-04T05:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk0MzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg3MDQ1OA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r535870458", "bodyText": "I see, thanks for the explanation. Would be good to add an explicit else here and return true with a comment so that  we don't make a mistake of returning false from here in future.", "author": "shubham1g5", "createdAt": "2020-12-04T06:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk0MzM0OQ=="}], "type": "inlineReview"}, {"oid": "004fd3fa84cb1c43d397400153db4f8d5813dfd0", "url": "https://github.com/dimagi/commcare-android/commit/004fd3fa84cb1c43d397400153db4f8d5813dfd0", "message": "PR suggestions", "committedDate": "2020-12-04T06:36:59Z", "type": "commit"}, {"oid": "1d05bfda22685a7615752f95b3f856aaffe1f340", "url": "https://github.com/dimagi/commcare-android/commit/1d05bfda22685a7615752f95b3f856aaffe1f340", "message": "Return true when voice is null", "committedDate": "2020-12-04T07:15:55Z", "type": "commit"}, {"oid": "bcda13814c80d821c67806b156ef0c0d36a41f8a", "url": "https://github.com/dimagi/commcare-android/commit/bcda13814c80d821c67806b156ef0c0d36a41f8a", "message": "Use locale with country code", "committedDate": "2020-12-04T07:41:14Z", "type": "commit"}, {"oid": "3dd36a2f21a019dbb93dfb4fef2d637716cc9275", "url": "https://github.com/dimagi/commcare-android/commit/3dd36a2f21a019dbb93dfb4fef2d637716cc9275", "message": "Merge branch 'master' into text-to-speech", "committedDate": "2020-12-08T10:46:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzMTA5Nw==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r542131097", "bodyText": "How does the layout look when you have TTS plus a videoURI ?", "author": "shubham1g5", "createdAt": "2020-12-14T05:59:29Z", "path": "app/src/org/commcare/views/media/MediaLayout.java", "diffHunk": "@@ -103,9 +105,14 @@ public static MediaLayout buildComprehensiveLayout(Context context,\n                                                        TextView text, String audioURI, String imageURI,\n                                                        final String videoURI, final String bigImageURI,\n                                                        final String qrCodeContent, String inlineVideoURI,\n+                                                       final String ttsText,\n                                                        int questionIndex) {\n         MediaLayout mediaLayout = new MediaLayout(context);\n         mediaLayout.setAVT(text, audioURI, imageURI, videoURI, bigImageURI, qrCodeContent, inlineVideoURI, false, questionIndex);\n+        // Show TTS view only when audioURI is not present\n+        if (ttsText != null && audioURI == null) {", "originalCommit": "3dd36a2f21a019dbb93dfb4fef2d637716cc9275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA0MjQwOA==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r543042408", "bodyText": "", "author": "ShivamPokhriyal", "createdAt": "2020-12-15T04:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzMTA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA2NDUxMQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r543064511", "bodyText": "thanks, this will work.", "author": "shubham1g5", "createdAt": "2020-12-15T05:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzMTA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA2NzYyNw==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r543067627", "bodyText": "Should not this called again after user change a language in CommCare ?", "author": "shubham1g5", "createdAt": "2020-12-15T05:57:16Z", "path": "app/src/org/commcare/tts/TextToSpeechConverter.kt", "diffHunk": "@@ -0,0 +1,208 @@\n+package org.commcare.tts\n+\n+import android.content.Context\n+import android.os.Build\n+import android.os.Handler\n+import android.os.Looper\n+import android.speech.tts.TextToSpeech\n+import android.speech.tts.UtteranceProgressListener\n+import android.text.TextUtils\n+\n+import org.javarosa.core.services.locale.Localization\n+\n+import java.util.Locale\n+import java.util.LinkedList\n+\n+import kotlin.collections.HashMap\n+\n+/**\n+ * Utility for Android's {@link android.speech.tts.TextToSpeech} that handles initialization, shutdown,\n+ * locale setting.\n+ */\n+object TextToSpeechConverter {\n+\n+    private val MAX_TEXT_LENGTH = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n+        TextToSpeech.getMaxSpeechInputLength()\n+    } else {\n+        4000\n+    }\n+    private var mTextToSpeech: TextToSpeech? = null\n+    private var mInitialized: Boolean = false\n+    private var mTTSCallback: TextToSpeechCallback? = null\n+    private val mUtteranceProgressListener = object: UtteranceProgressListener() {\n+        // The callbacks specified here can be called from multiple threads.\n+        override fun onDone(utteranceId: String?) { }\n+\n+        override fun onError(utteranceId: String?) {\n+            Handler(Looper.getMainLooper()).post {\n+                mTTSCallback?.speakFailed()\n+            }\n+        }\n+\n+        override fun onStart(utteranceId: String?) { }\n+    }\n+\n+    /**\n+     * Adds a listener to register callbacks for different states of Text-To-Speech engine.\n+     */\n+    fun setListener(listener: TextToSpeechCallback) {\n+        mTTSCallback = listener\n+    }\n+\n+    /**\n+     * Attempts to speak the specified text.\n+     */\n+    fun speak(context: Context, text: String) {\n+        if (!mInitialized) {\n+            initialize(context, text)\n+            return\n+        }\n+        // Handle empty text\n+        if (TextUtils.isEmpty(text)) {\n+            return\n+        }\n+        mTextToSpeech?.let { tts ->\n+            if (text.length > MAX_TEXT_LENGTH) {\n+                text.chunked(MAX_TEXT_LENGTH).forEach {\n+                    speakInternal(tts, it, TextToSpeech.QUEUE_ADD)\n+                }\n+            } else {\n+                speakInternal(tts, text)\n+            }\n+        } ?: run {\n+            mTTSCallback?.initFailed()\n+        }\n+    }\n+\n+    /**\n+     * Attempts to stop the TTS.\n+     */\n+    fun stop() {\n+        mTextToSpeech?.let {\n+            it.stop()\n+        }\n+    }\n+\n+    /**\n+     * Attempts to shutdown the TTS engine. No calls should be made to this object after calling this method.\n+     * Good to call this from onDestroy().\n+     */\n+    fun shutDown() {\n+        mTextToSpeech?.let {\n+            it.shutdown()\n+        }\n+        mInitialized = false\n+    }\n+\n+    /**\n+     * Changes the locale of text to speech engine.\n+     */\n+    fun changeLocale(language: String) {\n+        mTextToSpeech?.let { tts ->\n+            setLocale(tts, LinkedList(listOf(Locale(language, Locale.getDefault().country))))\n+        }\n+    }\n+\n+    private fun speakInternal(tts: TextToSpeech, text: String, queueMode: Int = TextToSpeech.QUEUE_FLUSH) {\n+        val utteranceId = System.currentTimeMillis().toString()\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            tts.speak(text, queueMode, null, utteranceId)\n+        } else {\n+            val params = HashMap<String, String>()\n+            params[TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID] = utteranceId\n+            tts.speak(text, queueMode, params)\n+        }\n+    }\n+\n+    private fun isTextLong(text: String): Boolean {\n+        // TTS can only speak 4000 characters at max at a time.\n+        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n+            text.length > TextToSpeech.getMaxSpeechInputLength()\n+        } else {\n+            text.length > MAX_TEXT_LENGTH\n+        }\n+    }\n+\n+    /**\n+     * Initializes the Text-To-Speech engine\n+     */\n+    private fun initialize(context: Context, text: String) {", "originalCommit": "3dd36a2f21a019dbb93dfb4fef2d637716cc9275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MDI0Ng==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r543090246", "bodyText": "We only need to change the language which is done here https://github.com/dimagi/commcare-android/pull/2411/files#diff-c7cb0f5ab8dcc60f97dfaf06c122ffa5e54311f12db10e5bd388d3d4035feffbR825", "author": "ShivamPokhriyal", "createdAt": "2020-12-15T06:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA2NzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNzEyNw==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r543117127", "bodyText": "Ahh I missed that. thanks", "author": "shubham1g5", "createdAt": "2020-12-15T07:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA2NzYyNw=="}], "type": "inlineReview"}, {"oid": "d6adb96fc40c42bdb7bf0b74fc985a89713109a5", "url": "https://github.com/dimagi/commcare-android/commit/d6adb96fc40c42bdb7bf0b74fc985a89713109a5", "message": "Check for missing voice data only when we get error in speak\n\nOddly, TTS voice.getFeature returns notinstalled sometimes even when the data is installed. Because of this false positive we were showing a dialog to install voice data when it was already installed. With this change we now move the voice data check outside, and only report it when we get an error while speaking.", "committedDate": "2020-12-15T13:58:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM2NzMwOQ==", "url": "https://github.com/dimagi/commcare-android/pull/2411#discussion_r543367309", "bodyText": "features.contains(TextToSpeech.Engine.KEY_FEATURE_NOT_INSTALLED) returns true irregularly even when the data is installed. Because of this false positive we were showing a dialog to install voice data when it was already installed.", "author": "ShivamPokhriyal", "createdAt": "2020-12-15T14:04:48Z", "path": "app/src/org/commcare/tts/TextToSpeechConverter.kt", "diffHunk": "@@ -163,31 +187,6 @@ object TextToSpeechConverter {\n             TextToSpeech.LANG_COUNTRY_VAR_AVAILABLE -> {\n                 // Set language\n                 tts.language = locale\n-\n-                // Check if voice data is present or not.\n-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n-                    if (tts.voice != null) {\n-                        val features = tts.voice.features\n-                        if (features == null", "originalCommit": "d6adb96fc40c42bdb7bf0b74fc985a89713109a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}