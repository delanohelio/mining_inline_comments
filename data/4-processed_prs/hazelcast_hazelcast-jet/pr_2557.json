{"pr_number": 2557, "pr_title": "Add programming guide for error handling", "pr_createdAt": "2020-09-24T10:19:57Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2557", "timeline": [{"oid": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "url": "https://github.com/hazelcast/hazelcast-jet/commit/4cff1b149c4414a75904941c3bfdb49d62c0c55b", "message": "Add programming guide for error handling", "committedDate": "2020-09-24T10:18:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxNjcwMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494216703", "bodyText": "Learned a new word: resumption", "author": "nfrankel", "createdAt": "2020-09-24T10:47:18Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.\n+\n+One option for dealing with failure in immutable state jobs is simply\n+restarting them (once the cause of the failure has been addressed).\n+Restarted streaming jobs lacking mutable state can just resume\n+processing the input data flow from the current point in time, batch\n+jobs can be re-run from the beginning.\n+\n+### Processing Guarantees\n+\n+Jobs with mutable state, the ones that have [processing\n+guarantees](../architecture/fault-tolerance#processing-guarantee-is-a-shared-concern)\n+set, achieve their fault tolerance by periodically saving [recovery\n+snapshots](../architecture/fault-tolerance#distributed-snapshot). When\n+such jobs fail, not only does their execution stop, but also their\n+snapshots get deleted. This makes it impossible to resume them without\n+loss.\n+\n+To cope with this situation, starting from Jet 4.3, jobs can be\n+configured to be only suspended when failures occur, instead of having\n+them fail completely. For details see\n+[`JobConfig.setSuspendOnFailure`](/javadoc/{jet-version}/com/hazelcast/jet/config/JobConfig.html#setSuspendOnFailure(boolean)).\n+Note: to preserve behavior from older versions, this configuration\n+option is not the default, so it must be enabled explicitly.\n+\n+Having them in a suspended state preserves their snapshots and makes\n+resumptions possible, once the root cause of the failure has been", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxODI5NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494218295", "bodyText": "Why use Jet here? We can also use an unreachable web-service.", "author": "nfrankel", "createdAt": "2020-09-24T10:50:24Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1MzIxMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494253212", "bodyText": "\"We are all going to die anyway, so don't bother reading this document\".\nI'd rather say that Jet handles errors on multiple levels:\n\nFailures in cluster hw or sw (\"fault tolerance\")\nConnecting to sources and sinks, e.g. components external to Jet\nBugs and exceptions in Jet Job code\n\nFollowing sections discuss options and best practices to be used on all levels, following this structure.", "author": "vladoschreiner", "createdAt": "2020-09-24T11:53:22Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1NTU5Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494255592", "bodyText": "I don't agree. Batch jobs do have mutable state. What about offsets of open files, ongoing aggregations etc.?\nWhat makes them different is the fact that the state can be always restored by processing the bounded collections from the start.", "author": "vladoschreiner", "createdAt": "2020-09-24T11:57:42Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNjU0Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r495816542", "bodyText": "You are perfectly right, theoretically. Batch jobs do have state but they don't actually save it, so in practical terms they don't have state... You shouldn't even enable snapshotting for batch jobs, because there are known scenarios when it wouldn't work well (for example batch job with keyed windowing). Viliam can list a ton of related issues just from the top of his head... I will try to find the right formulation.", "author": "jbartok", "createdAt": "2020-09-28T09:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1NTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1NzAxNQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494257015", "bodyText": "So why do the jobs snapshot? It feels that there is no benefit unless one configures suspend on failure\nIt's important to say that snapshots are useful to overcome member failures.", "author": "vladoschreiner", "createdAt": "2020-09-24T12:00:16Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.\n+\n+One option for dealing with failure in immutable state jobs is simply\n+restarting them (once the cause of the failure has been addressed).\n+Restarted streaming jobs lacking mutable state can just resume\n+processing the input data flow from the current point in time, batch\n+jobs can be re-run from the beginning.\n+\n+### Processing Guarantees\n+\n+Jobs with mutable state, the ones that have [processing\n+guarantees](../architecture/fault-tolerance#processing-guarantee-is-a-shared-concern)\n+set, achieve their fault tolerance by periodically saving [recovery\n+snapshots](../architecture/fault-tolerance#distributed-snapshot). When", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNzA2OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r495827069", "bodyText": "I will emphasize that.", "author": "jbartok", "createdAt": "2020-09-28T10:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1NzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1ODYzMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494258632", "bodyText": "Catch exception on a processor level as another section. This is what we recommend to deal with user code.", "author": "vladoschreiner", "createdAt": "2020-09-24T12:03:05Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.\n+\n+One option for dealing with failure in immutable state jobs is simply\n+restarting them (once the cause of the failure has been addressed).\n+Restarted streaming jobs lacking mutable state can just resume\n+processing the input data flow from the current point in time, batch\n+jobs can be re-run from the beginning.\n+\n+### Processing Guarantees\n+\n+Jobs with mutable state, the ones that have [processing\n+guarantees](../architecture/fault-tolerance#processing-guarantee-is-a-shared-concern)\n+set, achieve their fault tolerance by periodically saving [recovery\n+snapshots](../architecture/fault-tolerance#distributed-snapshot). When\n+such jobs fail, not only does their execution stop, but also their\n+snapshots get deleted. This makes it impossible to resume them without\n+loss.\n+\n+To cope with this situation, starting from Jet 4.3, jobs can be\n+configured to be only suspended when failures occur, instead of having\n+them fail completely. For details see\n+[`JobConfig.setSuspendOnFailure`](/javadoc/{jet-version}/com/hazelcast/jet/config/JobConfig.html#setSuspendOnFailure(boolean)).\n+Note: to preserve behavior from older versions, this configuration\n+option is not the default, so it must be enabled explicitly.\n+\n+Having them in a suspended state preserves their snapshots and makes\n+resumptions possible, once the root cause of the failure has been\n+addressed.\n+\n+In the open-source version of Jet this scenario is limited to\n+fixing the input data by some external means and then simply [resuming\n+the job](../operations/job-management#restarting) via the client API.\n+\n+Enterprise users of Jet have the added option of [job upgrades](../enterprise/job-update).\n+They can:\n+\n+* export the latest snapshot\n+* update their pipeline, if needed, for example, to cope with unexpected\n+  data\n+* resubmit a new job based on the exported snapshot and the updated pipeline\n+\n+One caveat of the suspend-on-failure feature is that the latest snapshot\n+is not a \"failure snapshot.\" Jet can't take a full snapshot right at the\n+moment of the failure, because its processors can produce accurate\n+snapshots only when in a healthy state. So the latest snapshot we will\n+have available will be whatever has been saved at the last periodic\n+snapshotting phase. But even so, the recovery procedure should preserve\n+at-least-once guarantees.\n+\n+More information on the topic can also be found in the feature's design\n+document, for example, how clients that have submitted the job can\n+[discover if it got suspended this\n+way](../design-docs/012-improved-job-resilience#notifying-the-client).", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2ODAzMQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r495768031", "bodyText": "I don't really understand this particular comment. Our processors are not capable of dealing with their own errors right now and we've decided to not implement that at the moment, because it's not something achievable with reasonable effort. So if we would recommend anything to users, that would be to catch exceptions from their own code, which is just common sense, I think.\nDid you mean something else?", "author": "jbartok", "createdAt": "2020-09-28T08:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1ODYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk0NjAzNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r495946034", "bodyText": "if we would recommend anything to users, that would be to catch exceptions from their own code, which is just common sense\n\nThat is what I thought. We can skip this part for now.", "author": "vladoschreiner", "createdAt": "2020-09-28T13:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1ODYzMg=="}], "type": "inlineReview"}, {"oid": "6c3c49791ee50ecccf1e3422715403a76f17c11d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/6c3c49791ee50ecccf1e3422715403a76f17c11d", "message": "Touch up wording", "committedDate": "2020-09-24T12:18:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2MzYwMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494263600", "bodyText": "This discrimination is too anecdotal, we can do something more abstract:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n          \n          \n            \n              of them are incorrectly formatted\n          \n          \n            \n            * *bugs in user code*: ex. user provided filtering lambda throws a\n          \n          \n            \n              `NullPointerException` for certain input\n          \n          \n            \n            * *connection to external services lost*: Jet sink writing into an\n          \n          \n            \n              `IMap` loses connection to the remote Hazelcast cluster hosting the\n          \n          \n            \n              data\n          \n          \n            \n            * *input data error*: unexpected input data, e.g. unexpected null value, out-of-range date (`0000-00-00`) or malformed JSON document\n          \n          \n            \n            * *coding errors*: e.g. NullPointerException, memory leaks, ...\n          \n          \n            \n            * *I/O errors*: network errors, remote service failures\n          \n      \n    \n    \n  \n\nAlso \"ex.\" -> \"for example,\" or \"e.g.\"", "author": "viliam-durina", "createdAt": "2020-09-24T12:11:52Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2Mzg0OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494263848", "bodyText": "\"This are\" -> \"These are\"", "author": "viliam-durina", "createdAt": "2020-09-24T12:12:20Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NDIxNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494264214", "bodyText": "\"but not just those\"\n\"to Jet\" -> \"by Jet\"", "author": "viliam-durina", "createdAt": "2020-09-24T12:12:59Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxODIwOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r495718209", "bodyText": "I don't agree with the \"to -> by\" change. I wanted to say that Jet is not aware of the error, and for that \"transparent to Jet\" seems the right expression.", "author": "jbartok", "createdAt": "2020-09-28T06:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyMjI5NA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r495722294", "bodyText": "Instead of this confusion just use the active voice and say explicitly who is the actor.", "author": "mtopolnik", "createdAt": "2020-09-28T06:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczNzg4Ng==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r495737886", "bodyText": "@jbartok you're right, I missed it.", "author": "viliam-durina", "createdAt": "2020-09-28T07:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NzQ0NA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494267444", "bodyText": "\"all error handling\" -> all errors, really?", "author": "viliam-durina", "createdAt": "2020-09-24T12:18:16Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3MDEwNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494270106", "bodyText": "their fault tolerance", "author": "viliam-durina", "createdAt": "2020-09-24T12:22:42Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.\n+\n+One option for dealing with failure in immutable state jobs is simply\n+restarting them (once the cause of the failure has been addressed).\n+Restarted streaming jobs lacking mutable state can just resume\n+processing the input data flow from the current point in time, batch\n+jobs can be re-run from the beginning.\n+\n+### Processing Guarantees\n+\n+Jobs with mutable state, the ones that have [processing\n+guarantees](../architecture/fault-tolerance#processing-guarantee-is-a-shared-concern)\n+set, achieve their fault tolerance by periodically saving [recovery", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3MDY1MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494270651", "bodyText": "\"this configuration option is not the default\" -> \"this option is disabled by default\"", "author": "viliam-durina", "createdAt": "2020-09-24T12:23:41Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.\n+\n+One option for dealing with failure in immutable state jobs is simply\n+restarting them (once the cause of the failure has been addressed).\n+Restarted streaming jobs lacking mutable state can just resume\n+processing the input data flow from the current point in time, batch\n+jobs can be re-run from the beginning.\n+\n+### Processing Guarantees\n+\n+Jobs with mutable state, the ones that have [processing\n+guarantees](../architecture/fault-tolerance#processing-guarantee-is-a-shared-concern)\n+set, achieve their fault tolerance by periodically saving [recovery\n+snapshots](../architecture/fault-tolerance#distributed-snapshot). When\n+such jobs fail, not only does their execution stop, but also their\n+snapshots get deleted. This makes it impossible to resume them without\n+loss.\n+\n+To cope with this situation, starting from Jet 4.3, jobs can be\n+configured to be only suspended when failures occur, instead of having\n+them fail completely. For details see\n+[`JobConfig.setSuspendOnFailure`](/javadoc/{jet-version}/com/hazelcast/jet/config/JobConfig.html#setSuspendOnFailure(boolean)).\n+Note: to preserve behavior from older versions, this configuration\n+option is not the default, so it must be enabled explicitly.", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3MTA5NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494271095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            resumptions possible, once the root cause of the failure has been\n          \n          \n            \n            resumptions possible once the root cause of the failure has been", "author": "viliam-durina", "createdAt": "2020-09-24T12:24:28Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.\n+\n+One option for dealing with failure in immutable state jobs is simply\n+restarting them (once the cause of the failure has been addressed).\n+Restarted streaming jobs lacking mutable state can just resume\n+processing the input data flow from the current point in time, batch\n+jobs can be re-run from the beginning.\n+\n+### Processing Guarantees\n+\n+Jobs with mutable state, the ones that have [processing\n+guarantees](../architecture/fault-tolerance#processing-guarantee-is-a-shared-concern)\n+set, achieve their fault tolerance by periodically saving [recovery\n+snapshots](../architecture/fault-tolerance#distributed-snapshot). When\n+such jobs fail, not only does their execution stop, but also their\n+snapshots get deleted. This makes it impossible to resume them without\n+loss.\n+\n+To cope with this situation, starting from Jet 4.3, jobs can be\n+configured to be only suspended when failures occur, instead of having\n+them fail completely. For details see\n+[`JobConfig.setSuspendOnFailure`](/javadoc/{jet-version}/com/hazelcast/jet/config/JobConfig.html#setSuspendOnFailure(boolean)).\n+Note: to preserve behavior from older versions, this configuration\n+option is not the default, so it must be enabled explicitly.\n+\n+Having them in a suspended state preserves their snapshots and makes\n+resumptions possible, once the root cause of the failure has been", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3MjYwOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494272609", "bodyText": "It preserves exactly-once guarantee, but it's exactly-once semantics, not exactly-once processing. Exactly-once processing is impossible.", "author": "viliam-durina", "createdAt": "2020-09-24T12:27:05Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.\n+\n+One option for dealing with failure in immutable state jobs is simply\n+restarting them (once the cause of the failure has been addressed).\n+Restarted streaming jobs lacking mutable state can just resume\n+processing the input data flow from the current point in time, batch\n+jobs can be re-run from the beginning.\n+\n+### Processing Guarantees\n+\n+Jobs with mutable state, the ones that have [processing\n+guarantees](../architecture/fault-tolerance#processing-guarantee-is-a-shared-concern)\n+set, achieve their fault tolerance by periodically saving [recovery\n+snapshots](../architecture/fault-tolerance#distributed-snapshot). When\n+such jobs fail, not only does their execution stop, but also their\n+snapshots get deleted. This makes it impossible to resume them without\n+loss.\n+\n+To cope with this situation, starting from Jet 4.3, jobs can be\n+configured to be only suspended when failures occur, instead of having\n+them fail completely. For details see\n+[`JobConfig.setSuspendOnFailure`](/javadoc/{jet-version}/com/hazelcast/jet/config/JobConfig.html#setSuspendOnFailure(boolean)).\n+Note: to preserve behavior from older versions, this configuration\n+option is not the default, so it must be enabled explicitly.\n+\n+Having them in a suspended state preserves their snapshots and makes\n+resumptions possible, once the root cause of the failure has been\n+addressed.\n+\n+In the open-source version of Jet this scenario is limited to\n+fixing the input data by some external means and then simply [resuming\n+the job](../operations/job-management#restarting) via the client API.\n+\n+Enterprise users of Jet have the added option of [job upgrades](../enterprise/job-update).\n+They can:\n+\n+* export the latest snapshot\n+* update their pipeline, if needed, for example, to cope with unexpected\n+  data\n+* resubmit a new job based on the exported snapshot and the updated pipeline\n+\n+One caveat of the suspend-on-failure feature is that the latest snapshot\n+is not a \"failure snapshot.\" Jet can't take a full snapshot right at the\n+moment of the failure, because its processors can produce accurate\n+snapshots only when in a healthy state. So the latest snapshot we will\n+have available will be whatever has been saved at the last periodic\n+snapshotting phase. But even so, the recovery procedure should preserve\n+at-least-once guarantees.", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3MzI5OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r494273299", "bodyText": "We should not refer to description of important features in TDD. We can refer to TDD to read more why the design is as it is or so.", "author": "viliam-durina", "createdAt": "2020-09-24T12:28:08Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+There is unavoidable risk in running Jet jobs. They ingest data from\n+external sources, the correctness and consistency of which can't be\n+guaranteed. The processing they perform includes the running of user\n+code, which is written by humans and, as such, is unavoidably imperfect.\n+\n+So even if we assume no bugs in the Jet framework itself, errors can and\n+will happen. What options Jet offers for dealing with them is the topic\n+of the next sections.\n+\n+## Scope\n+\n+A Jet cluster, at any given time, is running an arbitrary number of\n+independent jobs in parallel. These jobs do not interact in any way, and\n+the failure of one should not lead to any consequences for any other.\n+When considering error handling, the basic unit of discussion will be\n+the job, mainly what happens with it once it encounters a problem.\n+\n+The default way Jet reacts to an error is to fail the job that has\n+produced it, but what one can do with such a failed job afterward is the\n+interesting part.\n+\n+## Types of Errors\n+\n+Before we dig deeper, let's list some typical error one might encounter:\n+\n+* *corrupt data*: ex. user-provided code is parsing JSON lines, but some\n+  of them are incorrectly formatted\n+* *bugs in user code*: ex. user provided filtering lambda throws a\n+  `NullPointerException` for certain input\n+* *connection to external services lost*: Jet sink writing into an\n+  `IMap` loses connection to the remote Hazelcast cluster hosting the\n+  data\n+\n+## Specific Solutions\n+\n+Some concrete types of error have solutions specifically tailored to\n+address them.\n+\n+### In-Memory Data Structures\n+\n+Jet comes out of the box with some [in-memory distributed data\n+structures](data-structures) which can be used as a data source or a\n+sink. This are hosted by Hazelcast clusters, which can be the same as\n+the one Jet runs on or separate, remote ones.\n+\n+In this case, all error handling (for example, communications failures\n+with the remote cluster, but not just) is handled transparently to Jet,\n+by the Hazelcast cluster itself. For further details and configuration\n+options, read the [relevant section in the Hazelcast\n+manual](https://docs.hazelcast.org/docs/latest/manual/html-single/#handling-failures).\n+\n+### Individual Sources & Sinks\n+\n+Sources and Sinks are Jet's points of contact with external data stores.\n+Their various types have specific characteristics that enable error\n+handling strategies applicable only to them.\n+\n+For example, our [Change Data Capture\n+sources](sources-sinks#change-data-capture-cdc) can attempt to reconnect\n+automatically whenever they lose connection to the databases they\n+monitor, so for intermittent network failures, their owner jobs don't\n+need to fail.\n+\n+For further such specific failure handling options, consult the Javadoc\n+of Jet's various [sources and sinks](sources-sinks).\n+\n+## Generic Solutions\n+\n+In Jet we also have generic options for dealing with random errors\n+affecting our jobs.\n+\n+### Jobs Without Mutable State\n+\n+For many streaming jobs, specifically the ones which don't have any\n+processing guarantee configured, the pipeline definition and the job\n+config are the only parts we can identify as state, and those are\n+immutable.\n+\n+Batch jobs also fall into the category of immutable state jobs.\n+\n+One option for dealing with failure in immutable state jobs is simply\n+restarting them (once the cause of the failure has been addressed).\n+Restarted streaming jobs lacking mutable state can just resume\n+processing the input data flow from the current point in time, batch\n+jobs can be re-run from the beginning.\n+\n+### Processing Guarantees\n+\n+Jobs with mutable state, the ones that have [processing\n+guarantees](../architecture/fault-tolerance#processing-guarantee-is-a-shared-concern)\n+set, achieve their fault tolerance by periodically saving [recovery\n+snapshots](../architecture/fault-tolerance#distributed-snapshot). When\n+such jobs fail, not only does their execution stop, but also their\n+snapshots get deleted. This makes it impossible to resume them without\n+loss.\n+\n+To cope with this situation, starting from Jet 4.3, jobs can be\n+configured to be only suspended when failures occur, instead of having\n+them fail completely. For details see\n+[`JobConfig.setSuspendOnFailure`](/javadoc/{jet-version}/com/hazelcast/jet/config/JobConfig.html#setSuspendOnFailure(boolean)).\n+Note: to preserve behavior from older versions, this configuration\n+option is not the default, so it must be enabled explicitly.\n+\n+Having them in a suspended state preserves their snapshots and makes\n+resumptions possible, once the root cause of the failure has been\n+addressed.\n+\n+In the open-source version of Jet this scenario is limited to\n+fixing the input data by some external means and then simply [resuming\n+the job](../operations/job-management#restarting) via the client API.\n+\n+Enterprise users of Jet have the added option of [job upgrades](../enterprise/job-update).\n+They can:\n+\n+* export the latest snapshot\n+* update their pipeline, if needed, for example, to cope with unexpected\n+  data\n+* resubmit a new job based on the exported snapshot and the updated pipeline\n+\n+One caveat of the suspend-on-failure feature is that the latest snapshot\n+is not a \"failure snapshot.\" Jet can't take a full snapshot right at the\n+moment of the failure, because its processors can produce accurate\n+snapshots only when in a healthy state. So the latest snapshot we will\n+have available will be whatever has been saved at the last periodic\n+snapshotting phase. But even so, the recovery procedure should preserve\n+at-least-once guarantees.\n+\n+More information on the topic can also be found in the feature's design\n+document, for example, how clients that have submitted the job can\n+[discover if it got suspended this\n+way](../design-docs/012-improved-job-resilience#notifying-the-client).", "originalCommit": "4cff1b149c4414a75904941c3bfdb49d62c0c55b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "941d274f50c0ce1fa1ec383242c4b5d63cd9f2a8", "url": "https://github.com/hazelcast/hazelcast-jet/commit/941d274f50c0ce1fa1ec383242c4b5d63cd9f2a8", "message": "Address review concerns", "committedDate": "2020-09-28T08:17:03Z", "type": "commit"}, {"oid": "2cdfe4598d632758a852ea489763bd9ea079832e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/2cdfe4598d632758a852ea489763bd9ea079832e", "message": "Address more review concerns", "committedDate": "2020-09-28T10:22:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0NzY2Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2557#discussion_r495847667", "bodyText": "scheduled maintenance isn't an error condition: you can do an orderly shutdown", "author": "viliam-durina", "createdAt": "2020-09-28T10:42:57Z", "path": "site/docs/api/error-handling.md", "diffHunk": "@@ -0,0 +1,128 @@\n+---\n+title: Error Handling Strategies\n+description: Ways of coping with unexpected error in Hazelcast Jet.\n+---\n+\n+Jet may experience errors on multiple levels:\n+\n+* on the *cluster level*: nodes can be removed from or added to the\n+  cluster at any given time, due to, for example, internal errors, loss\n+  of networking, or even scheduled maintenance", "originalCommit": "2cdfe4598d632758a852ea489763bd9ea079832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ebbec640b56018d1e1ae7f1bddfe999fb92ba6d5", "url": "https://github.com/hazelcast/hazelcast-jet/commit/ebbec640b56018d1e1ae7f1bddfe999fb92ba6d5", "message": "Fix minor problem", "committedDate": "2020-09-28T11:26:29Z", "type": "commit"}]}