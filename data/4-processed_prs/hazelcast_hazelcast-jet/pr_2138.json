{"pr_number": 2138, "pr_title": "Update JMS & JDBC sink docs", "pr_createdAt": "2020-04-03T13:52:21Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2138", "timeline": [{"oid": "7afda210804e7962885450934a2be3829bdff013", "url": "https://github.com/hazelcast/hazelcast-jet/commit/7afda210804e7962885450934a2be3829bdff013", "message": "Update JMS & JDBC sink docs", "committedDate": "2020-04-03T13:50:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4Mjg5MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403882891", "bodyText": "\"similar to\" was actually better (easier to pronounce) and it is grammatically acceptable.", "author": "mtopolnik", "createdAt": "2020-04-06T07:32:18Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -249,8 +249,8 @@ p.readFrom(S3Sources.s3(singletonList(\"input-bucket\"), \"prefix\",\n  .writeTo(Sinks.logger());\n ```\n \n-The S3 sink works similar to the local file sink, writing a line to the\n-output for each input item:\n+The S3 sink works similarly to the local file sink, writing a line to", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NDIzOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403884238", "bodyText": "using the ... patterns", "author": "mtopolnik", "createdAt": "2020-04-06T07:34:58Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -424,7 +424,7 @@ or greater than 1.0.0.\n ###\u00a0JMS\n \n JMS (Java Message Service) is a standard API for communicating with\n-various message brokers using the publish-subscribe patterns.\n+various message brokers using queue or publish-subscribe patterns.", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NTIyMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403885223", "bodyText": "shared, durable", "author": "mtopolnik", "createdAt": "2020-04-06T07:36:51Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -433,34 +433,61 @@ There are several brokers that implement the JMS standard, including:\n * IBM MQ\n * RabbitMQ\n * Solace\n+* ...\n \n-Jet is able to utilize these brokers both as a source and sink through\n+Jet is able to utilize these brokers both as a source and a sink through\n the use of the JMS API.\n \n-To use a JMS broker, such as ActiveMQ, you'll need the client libraries\n-either on the classpath (by putting them on the `lib` folder) of the\n-node or submit them with the job. The Jet JMS connector is part of the\n+To use a JMS broker, such as ActiveMQ, you need the client libraries\n+either on the classpath (by putting them into the `lib` folder) of the\n+node or submit them with the job. The Jet JMS connector is a part of the\n `hazelcast-jet` module, so requires no other dependencies than the\n client jar.\n \n+####\u00a0JMS Source Connector\n+\n A very simple pipeline which consumes messages from a given ActiveMQ\n-and then logs them is given below:\n+queue and then logs them is given below:\n+\n+```java\n+Pipeline p = Pipeline.create();\n+p.readFrom(Sources.jmsQueue(\"queueName\",\n+        () -> new ActiveMQConnectionFactory(\"tcp://localhost:61616\")))\n+ .withoutTimestamps()\n+ .writeTo(Sinks.logger());\n+```\n+\n+For a topic you can choose whether the consumer is durable or shared.\n+You need to use the `consumerFn` to create the desired consumer using a\n+JMS `Session` object.\n+\n+If you create a shared consumer, you need to let Jet know by calling\n+`sharedConsumer(true)` on the builder. If you don't do this, only one\n+cluster member will actually connect to the JMS broker and will receive\n+all of the messages. We always assume a shared consumer for queues.\n+\n+If you create a non-durable consumer, the fault-tolerance features won't\n+work since the JMS broker won't track which messages were delivered to\n+the client and which not.\n+\n+Below is a simple example to create a non-durable non-shared topic\n+source:\n \n ```java\n Pipeline p = Pipeline.create();\n-p.readFrom(Sources.jmsQueue(() -> new ActiveMQConnectionFactory(\n-        \"tcp://localhost:61616\"), \"queue\"))\n+p.readFrom(Sources.jmsTopic(\"topic\",\n+        () -> new ActiveMQConnectionFactory(\"tcp://localhost:61616\")))\n  .withoutTimestamps()\n  .writeTo(Sinks.logger());\n ```\n \n-For the topic, we recommend using a durable consumer where possible\n-so that you are able to make use of fault-tolerance features of Jet:\n+Here is a more complex example that uses a shared and durable consumer:", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NTQyNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403885424", "bodyText": "with the ... guarantee", "author": "mtopolnik", "createdAt": "2020-04-06T07:37:15Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NTY1Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403885653", "bodyText": "for the ... consumer. --The-- fault tolerance", "author": "mtopolnik", "createdAt": "2020-04-06T07:37:42Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NjQ3MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403886470", "bodyText": "In the ... mode\nsaves the IDs", "author": "mtopolnik", "createdAt": "2020-04-06T07:39:18Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved\n+by acknowledging the consumed messages only after they were fully\n+processed by the downstream stages. Acknowledging is done once per\n+snapshot, you need to enable the processing guarantee in the\n+`JobConfig`.\n+\n+In exactly-once mode the processor saves IDs of the messages processed", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NjczOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403886738", "bodyText": "extract the ... ID", "author": "mtopolnik", "createdAt": "2020-04-06T07:39:48Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved\n+by acknowledging the consumed messages only after they were fully\n+processed by the downstream stages. Acknowledging is done once per\n+snapshot, you need to enable the processing guarantee in the\n+`JobConfig`.\n+\n+In exactly-once mode the processor saves IDs of the messages processed\n+since the last snapshot into the snapshotted state. Therefore this mode\n+will not work if your messages don't have the JMS Message ID set (it is\n+an optional feature of JMS). In this case you need to set `messageIdFn`\n+on the builder to extract message ID from the payload. If you don't have", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4Njg4OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403886889", "bodyText": "In the ... mode (twice)", "author": "mtopolnik", "createdAt": "2020-04-06T07:40:04Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved\n+by acknowledging the consumed messages only after they were fully\n+processed by the downstream stages. Acknowledging is done once per\n+snapshot, you need to enable the processing guarantee in the\n+`JobConfig`.\n+\n+In exactly-once mode the processor saves IDs of the messages processed\n+since the last snapshot into the snapshotted state. Therefore this mode\n+will not work if your messages don't have the JMS Message ID set (it is\n+an optional feature of JMS). In this case you need to set `messageIdFn`\n+on the builder to extract message ID from the payload. If you don't have\n+a message ID to use, you must reduce the source guarantee to\n+at-least-once:\n+\n+```java\n+p.readFrom(Sources.jmsTopicBuilder(...)\n+        .maxGuarantee(ProcessingGuarantee.AT_LEAST_ONCE)\n+        ...\n+```\n+\n+In at-least-once mode messages are acknowledged in the same way as in", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NzE0MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403887141", "bodyText": "in the ... mode.", "author": "mtopolnik", "createdAt": "2020-04-06T07:40:31Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved\n+by acknowledging the consumed messages only after they were fully\n+processed by the downstream stages. Acknowledging is done once per\n+snapshot, you need to enable the processing guarantee in the\n+`JobConfig`.\n+\n+In exactly-once mode the processor saves IDs of the messages processed\n+since the last snapshot into the snapshotted state. Therefore this mode\n+will not work if your messages don't have the JMS Message ID set (it is\n+an optional feature of JMS). In this case you need to set `messageIdFn`\n+on the builder to extract message ID from the payload. If you don't have\n+a message ID to use, you must reduce the source guarantee to\n+at-least-once:\n+\n+```java\n+p.readFrom(Sources.jmsTopicBuilder(...)\n+        .maxGuarantee(ProcessingGuarantee.AT_LEAST_ONCE)\n+        ...\n+```\n+\n+In at-least-once mode messages are acknowledged in the same way as in\n+exactly-once mode, but message IDs are not saved to the snapshot.\n \n-####\u00a0Using as a sink\n+If you have no processing guarantee enabled, the processor will consume\n+the messages in `DUPS_OK_ACKNOWLEDGE` mode.", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NzM1MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403887350", "bodyText": "the ... guarantee.", "author": "mtopolnik", "createdAt": "2020-04-06T07:41:00Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NzQzNw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403887437", "bodyText": "consistent with", "author": "mtopolnik", "createdAt": "2020-04-06T07:41:13Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, messages are committed consistently with the last state", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4ODUwNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403888506", "bodyText": "\"wrought\" doesn't belong here. Maybe \"introduced\" or possibly \"brought\"?", "author": "mtopolnik", "createdAt": "2020-04-06T07:43:25Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, messages are committed consistently with the last state\n+snapshot. This greatly increases the latency, it is determined by the\n+snapshot interval: messages are visible to consumers only after the\n+commit. In order to make it work, the connection factory you provide has\n+to implement `javax.jms.XAConnectionFactory`, otherwise the job will not\n+start.\n+\n+If you want to avoid the higher latency, decrease the overhead wrought", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4ODY2OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403888668", "bodyText": "the ... mode", "author": "mtopolnik", "createdAt": "2020-04-06T07:43:42Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, messages are committed consistently with the last state\n+snapshot. This greatly increases the latency, it is determined by the\n+snapshot interval: messages are visible to consumers only after the\n+commit. In order to make it work, the connection factory you provide has\n+to implement `javax.jms.XAConnectionFactory`, otherwise the job will not\n+start.\n+\n+If you want to avoid the higher latency, decrease the overhead wrought\n+by the XA transactions, if your JMS implementation doesn't support XA\n+transactions or if you just don't need the guarantee, you can reduce it\n+just for the sink:\n+\n+```java\n+stage.writeTo(Sinks\n+         .jmsQueueBuilder(() -> new ActiveMQConnectionFactory(\"tcp://localhost:61616\"))\n+         // decrease the guarantee for the sink\n+         .exactlyOnce(false)\n+         .build());\n+```\n+\n+In at-least-once mode or if no guarantee is enabled, the transaction is", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4ODgyNQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403888825", "bodyText": "this is --the-- JMS's way", "author": "mtopolnik", "createdAt": "2020-04-06T07:43:58Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, messages are committed consistently with the last state\n+snapshot. This greatly increases the latency, it is determined by the\n+snapshot interval: messages are visible to consumers only after the\n+commit. In order to make it work, the connection factory you provide has\n+to implement `javax.jms.XAConnectionFactory`, otherwise the job will not\n+start.\n+\n+If you want to avoid the higher latency, decrease the overhead wrought\n+by the XA transactions, if your JMS implementation doesn't support XA\n+transactions or if you just don't need the guarantee, you can reduce it\n+just for the sink:\n+\n+```java\n+stage.writeTo(Sinks\n+         .jmsQueueBuilder(() -> new ActiveMQConnectionFactory(\"tcp://localhost:61616\"))\n+         // decrease the guarantee for the sink\n+         .exactlyOnce(false)\n+         .build());\n+```\n+\n+In at-least-once mode or if no guarantee is enabled, the transaction is\n+committed after each batch of messages: transactions are used for\n+performance as this is the JMS' way to send messages in batches. Batches", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4OTU2Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403889562", "bodyText": "I would remove \"out there\", it is conversational.", "author": "mtopolnik", "createdAt": "2020-04-06T07:45:20Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -770,12 +822,12 @@ which we will explore.\n \n ###\u00a0JDBC\n \n-JDBC is a very well established database API supported by every major\n-relational (and many non-relational) database implementation out there\n+JDBC is a well-established database API supported by every major\n+relational (and many non-relational) database implementations out there", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MDEwMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403890103", "bodyText": "I think \"JDBC driver\" is the official name, not just common usage.", "author": "mtopolnik", "createdAt": "2020-04-06T07:46:19Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -770,12 +822,12 @@ which we will explore.\n \n ###\u00a0JDBC\n \n-JDBC is a very well established database API supported by every major\n-relational (and many non-relational) database implementation out there\n+JDBC is a well-established database API supported by every major\n+relational (and many non-relational) database implementations out there\n including Oracle, MySQL, PostgreSQL, Microsoft SQL Server. The libraries\n-are typically referred to as _drivers_ and every major database vendor will\n-have this driver available for either download or on a package repository\n-such as maven.\n+are typically referred to as _JDBC drivers_ and every major database", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MDM0MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403890341", "bodyText": "in a package repository", "author": "mtopolnik", "createdAt": "2020-04-06T07:46:43Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -770,12 +822,12 @@ which we will explore.\n \n ###\u00a0JDBC\n \n-JDBC is a very well established database API supported by every major\n-relational (and many non-relational) database implementation out there\n+JDBC is a well-established database API supported by every major\n+relational (and many non-relational) database implementations out there\n including Oracle, MySQL, PostgreSQL, Microsoft SQL Server. The libraries\n-are typically referred to as _drivers_ and every major database vendor will\n-have this driver available for either download or on a package repository\n-such as maven.\n+are typically referred to as _JDBC drivers_ and every major database\n+vendor will have this driver available for either download or on a", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MDg1Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403890857", "bodyText": "the ... guarantee.", "author": "mtopolnik", "createdAt": "2020-04-06T07:47:34Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -837,7 +889,38 @@ p.readFrom(KafkaSources.<Person>kafka(.., \"people\"))\n JDBC sink will automatically try to reconnect during database\n connectivity issues and is suitable for use in streaming jobs. If you\n want to avoid duplicate writes to the database, then a suitable\n-_insert-or-update_ statement should be used instead of `INSERT`.\n+_insert-or-update_ statement should be used instead of `INSERT`, such as\n+`MERGE` or `REPLACE` or `INSERT .. ON CONFLICT ..`.\n+\n+#### Fault tolerance\n+\n+The JDBC sink supports exactly-once guarantee. It uses two-phase XA", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MTEyNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403891124", "bodyText": "the variant", "author": "mtopolnik", "createdAt": "2020-04-06T07:47:57Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -837,7 +889,38 @@ p.readFrom(KafkaSources.<Person>kafka(.., \"people\"))\n JDBC sink will automatically try to reconnect during database\n connectivity issues and is suitable for use in streaming jobs. If you\n want to avoid duplicate writes to the database, then a suitable\n-_insert-or-update_ statement should be used instead of `INSERT`.\n+_insert-or-update_ statement should be used instead of `INSERT`, such as\n+`MERGE` or `REPLACE` or `INSERT .. ON CONFLICT ..`.\n+\n+#### Fault tolerance\n+\n+The JDBC sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, the DML statements are committed consistently with the\n+last state snapshot. This greatly increases the latency, it is\n+determined by the snapshot interval: messages are visible to consumers\n+only after the commit. In order to make it work, instead of the JDBC URL\n+you have to use variant with `Supplier<CommonDataSource>` and it must", "originalCommit": "7afda210804e7962885450934a2be3829bdff013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "78faebce728e1f068c623c21f92879befb91d692", "url": "https://github.com/hazelcast/hazelcast-jet/commit/78faebce728e1f068c623c21f92879befb91d692", "message": "Address review", "committedDate": "2020-04-06T13:54:32Z", "type": "commit"}]}