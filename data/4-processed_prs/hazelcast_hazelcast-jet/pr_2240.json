{"pr_number": 2240, "pr_title": "[011] cleanup JSON API, add todos", "pr_createdAt": "2020-05-06T20:44:50Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2240", "timeline": [{"oid": "2ed5a43d051a7020a7fdec8439d5189a01c589a3", "url": "https://github.com/hazelcast/hazelcast-jet/commit/2ed5a43d051a7020a7fdec8439d5189a01c589a3", "message": "cleanup JSON API, add todos", "committedDate": "2020-05-06T20:44:53Z", "type": "commit"}, {"oid": "f807a2a084faa68ef32b3ee4129439ba63da70a1", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f807a2a084faa68ef32b3ee4129439ba63da70a1", "message": "address TODOs", "committedDate": "2020-05-07T12:55:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxMDQ1Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r421610453", "bodyText": "this should read a json which has a line per sales record, right now it's a list", "author": "cangencer", "createdAt": "2020-05-07T15:50:45Z", "path": "examples/files/src/main/java/com/hazelcast/jet/examples/files/SalesJsonAnalyzer.java", "diffHunk": "@@ -41,7 +42,7 @@ private static Pipeline buildPipeline(String sourceDir) {\n \n         BatchSource<SalesRecord> source = Sources.filesBuilder(sourceDir)\n                                                  .glob(\"*.json\")\n-                                                 .buildJson(SalesRecord.class);\n+                                                 .build(JsonUtil.asJson(SalesRecord.class));", "originalCommit": "f807a2a084faa68ef32b3ee4129439ba63da70a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxMDk4MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r421610980", "bodyText": "I'm not sure if we need to support Reader anymore, is it used anywhere?", "author": "cangencer", "createdAt": "2020-05-07T15:51:30Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/json/JsonUtil.java", "diffHunk": "@@ -50,129 +74,166 @@ private JsonUtil() {\n      * string using {@link Object#toString()}.\n      */\n     @Nonnull\n-    public static <T> HazelcastJsonValue hazelcastJsonValue(@Nonnull T object) {\n+    public static HazelcastJsonValue hazelcastJsonValue(@Nonnull Object object) {\n         return new HazelcastJsonValue(object.toString());\n     }\n \n     /**\n-     * Creates a {@link HazelcastJsonValue} by converting the key of the given\n-     * entry to string using {@link Object#toString()}.\n+     * Converts a JSON string to a object of given type.\n      */\n     @Nonnull\n-    public static <K> HazelcastJsonValue asJsonKey(@Nonnull Map.Entry<K, ?> entry) {\n-        return new HazelcastJsonValue(entry.getKey().toString());\n+    public static <T> T parse(@Nonnull Class<T> type, @Nonnull String jsonString) throws IOException {\n+        return JSON_JR.beanFrom(type, jsonString);\n     }\n \n     /**\n-     * Creates a {@link HazelcastJsonValue} by converting the value of the\n-     * given entry to string using {@link Object#toString()}.\n+     * Converts the contents of the specified {@code reader} to a object of\n+     * given type.\n      */\n     @Nonnull\n-    public static <V> HazelcastJsonValue asJsonValue(@Nonnull Map.Entry<?, V> entry) {\n-        return new HazelcastJsonValue(entry.getValue().toString());\n+    public static <T> T parse(@Nonnull Class<T> type, @Nonnull Reader reader) throws IOException {\n+        return JSON_JR.beanFrom(type, reader);\n     }\n \n     /**\n-     * Converts a JSON string to a object of given type.\n+     * Converts a JSON string to a {@link Map}.\n      */\n     @Nonnull\n-    public static <T> T parse(@Nonnull Class<T> type, @Nonnull String jsonString) {\n-        return uncheckCall(() -> JSON_JR.beanFrom(type, jsonString));\n+    public static Map<String, Object> parse(@Nonnull String jsonString) throws IOException {\n+        return JSON_JR.mapFrom(jsonString);\n     }\n \n     /**\n-     * Converts the contents of the specified {@code reader} to a object of\n-     * given type.\n+     * Converts the contents of the specified {@code reader} to a {@link Map}.\n      */\n     @Nonnull\n-    public static <T> T parse(@Nonnull Class<T> type, @Nonnull Reader reader) {\n-        return uncheckCall(() -> JSON_JR.beanFrom(type, reader));\n+    public static Map<String, Object> parse(@Nonnull Reader reader) throws IOException {\n+        return JSON_JR.mapFrom(reader);\n     }\n \n     /**\n-     * Converts a JSON string to a {@link Map}.\n+     * Converts a JSON string to a {@link List} of given type.\n      */\n     @Nonnull\n-    public static Map<String, Object> parse(@Nonnull String jsonString) {\n-        return uncheckCall(() -> JSON_JR.mapFrom(jsonString));\n+    public static <T> List<T> parseList(@Nonnull Class<T> type, @Nonnull String jsonString) throws IOException {\n+        return JSON_JR.listOfFrom(type, jsonString);\n     }\n \n     /**\n-     * Converts the contents of the specified {@code reader} to a {@link Map}.\n+     * Converts the contents of the specified {@code reader} to a {@link List}.\n+     * of given type.\n      */\n     @Nonnull\n-    public static Map<String, Object> parse(@Nonnull Reader reader) {\n-        return uncheckCall(() -> JSON_JR.mapFrom(reader));\n+    public static <T> List<T> parseList(@Nonnull Class<T> type, @Nonnull Reader reader) throws IOException {\n+        return JSON_JR.listOfFrom(type, reader);\n     }\n \n     /**\n-     * Returns an {@link Iterator} over the sequence of JSON objects parsed\n-     * from given {@code reader}.\n+     * Converts a JSON string to a {@link List}.\n      */\n     @Nonnull\n-    public static <T> Iterator<T> parseSequence(@Nonnull Class<T> type, @Nonnull Reader reader) {\n-        return uncheckCall(() -> JSON_JR.beanSequenceFrom(type, reader));\n+    public static List<Object> parseList(@Nonnull String jsonString) throws IOException {\n+        return JSON_JR.listFrom(jsonString);\n     }\n \n     /**\n-     * Extracts a string value from given JSON string. For extracting multiple\n-     * values from a JSON string see {@link #parse(String)}.\n+     * Converts the contents of the specified {@code reader} to a {@link List}.\n      */\n     @Nonnull\n-    public static String getString(@Nonnull String jsonString, @Nonnull String key) {\n-        return (String) parse(jsonString).get(key);\n+    public static List<Object> parseList(@Nonnull Reader reader) throws IOException {", "originalCommit": "f807a2a084faa68ef32b3ee4129439ba63da70a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxMTQxMQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r421611411", "bodyText": "this should use multiline by default. We don't need to support non-multiline for convenience purposes", "author": "cangencer", "createdAt": "2020-05-07T15:52:06Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/Sources.java", "diffHunk": "@@ -984,6 +984,38 @@ public static FileSourceBuilder filesBuilder(@Nonnull String directory) {\n         return filesBuilder(directory).build();\n     }\n \n+    /**\n+     * A source to read all files in a directory in a batch way. The\n+     * source treats each line as a JSON string and converts each line\n+     * to an object of given type.\n+     * <p>\n+     * This method is a shortcut for: <pre>{@code\n+     *   filesBuilder(directory)\n+     *      .charset(UTF_8)\n+     *      .glob(GLOB_WILDCARD)\n+     *      .sharedFileSystem(false)\n+     *      .build(JsonUtil.asJson(type))\n+     * }</pre>\n+     * <p>\n+     * If files are appended to while being read, the addition might or might\n+     * not be emitted or part of a line can be emitted. If files are modified\n+     * in more complex ways, the behavior is undefined.\n+     * <p>\n+     * If file contains multi-line JSON string, you can use\n+     * {@link #filesBuilder(String)} along with\n+     * {@link JsonUtil#asMultilineJson(Class)}.\n+     *\n+     * See {@link #filesBuilder(String)}, {@link #files(String)} and\n+     * {@link JsonUtil#asJson(Class)}.\n+     *\n+     * @since 4.2\n+     */\n+    @Nonnull\n+    public static <T> BatchSource<T> json(@Nonnull String directory, Class<T> type) {\n+        return filesBuilder(directory).build(JsonUtil.asJson(type));", "originalCommit": "f807a2a084faa68ef32b3ee4129439ba63da70a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxMTY3Ng==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r421611676", "bodyText": "this should use multiline by default", "author": "cangencer", "createdAt": "2020-05-07T15:52:30Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/Sources.java", "diffHunk": "@@ -1012,6 +1043,36 @@ public static FileSourceBuilder filesBuilder(@Nonnull String directory) {\n         return filesBuilder(watchedDirectory).buildWatcher();\n     }\n \n+    /**\n+     * A source to stream lines added to files in a directory. This is a\n+     * streaming source, it will watch directory and emit objects of given\n+     * {@code type} by converting each line as they are\n+     * appended to files in that directory.\n+     * <p>\n+     * This method is a shortcut for: <pre>{@code\n+     *   filesBuilder(directory)\n+     *      .charset(UTF_8)\n+     *      .glob(GLOB_WILDCARD)\n+     *      .sharedFileSystem(false)\n+     *      .buildWatcher((JsonUtil.asJson(type))\n+     * }</pre>\n+     *\n+     * <h3>Appending lines using an text editor</h3>\n+     * If you're testing this source, you might think of using a text editor to\n+     * append the lines. However, it might not work as expected because some\n+     * editors write to a temp file and then rename it or append extra newline\n+     * character at the end which gets overwritten if more text is added in the\n+     * editor. The best way to append is to use {@code echo text >> yourFile}.\n+     *\n+     * See {@link #filesBuilder(String)}, {@link #fileWatcher(String)},\n+     * and {@link JsonUtil#asJson(Class)}.\n+     *\n+     * @since 4.2\n+     */\n+    public static <T> StreamSource<T> jsonWatcher(@Nonnull String watchedDirectory, Class<T> type) {\n+        return filesBuilder(watchedDirectory).buildWatcher(JsonUtil.asJson(type));", "originalCommit": "f807a2a084faa68ef32b3ee4129439ba63da70a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYyNzUzOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r421627538", "bodyText": "we can't use multiline for watcher", "author": "gurbuzali", "createdAt": "2020-05-07T16:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxMTY3Ng=="}], "type": "inlineReview"}, {"oid": "a0e6eab0d042a3c72912a4e61dc167878702e208", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a0e6eab0d042a3c72912a4e61dc167878702e208", "message": "remove reader overloads, fix examples json file", "committedDate": "2020-05-07T16:27:19Z", "type": "commit"}, {"oid": "b362a5171f9359cc07d1d576fc05aa2fe3d3c07a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b362a5171f9359cc07d1d576fc05aa2fe3d3c07a", "message": "few tweaks", "committedDate": "2020-05-11T07:15:42Z", "type": "commit"}, {"oid": "a41cff5fb3e09878c668716b3ed9caf0a9ba636d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a41cff5fb3e09878c668716b3ed9caf0a9ba636d", "message": "add json source/sink documentation", "committedDate": "2020-05-11T07:35:57Z", "type": "commit"}, {"oid": "fccda2242c40ff64b379034e1684b4437bfa80b6", "url": "https://github.com/hazelcast/hazelcast-jet/commit/fccda2242c40ff64b379034e1684b4437bfa80b6", "message": "add docs and design-doc", "committedDate": "2020-05-11T07:45:12Z", "type": "commit"}, {"oid": "5679679f8cd7fafea4ac98efa37f41cf39884c6f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/5679679f8cd7fafea4ac98efa37f41cf39884c6f", "message": "further design doc", "committedDate": "2020-05-11T08:55:39Z", "type": "commit"}, {"oid": "94a67160a3c315912ec3be3c7e972e05aa019676", "url": "https://github.com/hazelcast/hazelcast-jet/commit/94a67160a3c315912ec3be3c7e972e05aa019676", "message": "fix tests", "committedDate": "2020-05-11T09:05:52Z", "type": "commit"}, {"oid": "555a2d4f58cd79ee7e55ab2021a448ce75dd63c7", "url": "https://github.com/hazelcast/hazelcast-jet/commit/555a2d4f58cd79ee7e55ab2021a448ce75dd63c7", "message": "document annotations", "committedDate": "2020-05-11T09:32:40Z", "type": "commit"}, {"oid": "daede0907024407d7e306872d70d689c0ee96ef9", "url": "https://github.com/hazelcast/hazelcast-jet/commit/daede0907024407d7e306872d70d689c0ee96ef9", "message": "add hook for DeferredMap", "committedDate": "2020-05-11T11:50:00Z", "type": "commit"}, {"oid": "46dcc0e94d3964534dbd6feb0205c3d8cb0f6cc2", "url": "https://github.com/hazelcast/hazelcast-jet/commit/46dcc0e94d3964534dbd6feb0205c3d8cb0f6cc2", "message": "merge master", "committedDate": "2020-05-11T11:51:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwMjQzOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r423002438", "bodyText": "could this be simplified as Sources.json(\"\")?", "author": "cangencer", "createdAt": "2020-05-11T12:26:55Z", "path": "examples/files/src/main/java/com/hazelcast/jet/examples/files/SalesJsonAnalyzer.java", "diffHunk": "@@ -41,7 +42,7 @@ private static Pipeline buildPipeline(String sourceDir) {\n \n         BatchSource<SalesRecord> source = Sources.filesBuilder(sourceDir)", "originalCommit": "46dcc0e94d3964534dbd6feb0205c3d8cb0f6cc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwNDA3MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r423004071", "bodyText": "I think we can remove this function, since it doesn't add much, filename is just ignored?", "author": "cangencer", "createdAt": "2020-05-11T12:29:58Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/json/JsonUtil.java", "diffHunk": "@@ -62,129 +75,135 @@ private JsonUtil() {\n      * string using {@link Object#toString()}.\n      */\n     @Nonnull\n-    public static <T> HazelcastJsonValue hazelcastJsonValue(@Nonnull T object) {\n+    public static HazelcastJsonValue hazelcastJsonValue(@Nonnull Object object) {\n         return new HazelcastJsonValue(object.toString());\n     }\n \n     /**\n-     * Creates a {@link HazelcastJsonValue} by converting the key of the given\n-     * entry to string using {@link Object#toString()}.\n+     * Converts a JSON string to a object of given type.\n      */\n     @Nonnull\n-    public static <K> HazelcastJsonValue asJsonKey(@Nonnull Map.Entry<K, ?> entry) {\n-        return new HazelcastJsonValue(entry.getKey().toString());\n+    public static <T> T mapFrom(@Nonnull Class<T> type, @Nonnull String jsonString) throws IOException {\n+        return JSON_JR.beanFrom(type, jsonString);\n     }\n \n     /**\n-     * Creates a {@link HazelcastJsonValue} by converting the value of the\n-     * given entry to string using {@link Object#toString()}.\n+     * Converts a JSON string to a {@link Map}.\n      */\n     @Nonnull\n-    public static <V> HazelcastJsonValue asJsonValue(@Nonnull Map.Entry<?, V> entry) {\n-        return new HazelcastJsonValue(entry.getValue().toString());\n+    public static Map<String, Object> mapFrom(@Nonnull String jsonString) throws IOException {\n+        return JSON_JR.mapFrom(jsonString);\n     }\n \n     /**\n-     * Converts a JSON string to a object of given type.\n+     * Converts a JSON string to a {@link List} of given type.\n      */\n     @Nonnull\n-    public static <T> T parse(@Nonnull Class<T> type, @Nonnull String jsonString) {\n-        return uncheckCall(() -> JSON_JR.beanFrom(type, jsonString));\n+    public static <T> List<T> listFrom(@Nonnull Class<T> type, @Nonnull String jsonString) throws IOException {\n+        return JSON_JR.listOfFrom(type, jsonString);\n     }\n \n     /**\n-     * Converts the contents of the specified {@code reader} to a object of\n-     * given type.\n+     * Converts a JSON string to a {@link List}.\n      */\n     @Nonnull\n-    public static <T> T parse(@Nonnull Class<T> type, @Nonnull Reader reader) {\n-        return uncheckCall(() -> JSON_JR.beanFrom(type, reader));\n+    public static List<Object> listFrom(@Nonnull String jsonString) throws IOException {\n+        return JSON_JR.listFrom(jsonString);\n     }\n \n     /**\n-     * Converts a JSON string to a {@link Map}.\n+     * Converts a JSON string to an Object. The returned object will differ\n+     * according to the content of the string:\n+     * <ul>\n+     *     <li>content is a JSON object, returns a {@link Map}. See\n+     *     {@link #mapFrom(String)}.</li>\n+     *     <li>content is a JSON array, returns a {@link List}. See\n+     *     {@link #listFrom(String)}.</li>\n+     *     <li>content is a String, null or primitive, returns String, null or\n+     *     primitive.</li>\n+     * </ul>\n      */\n-    @Nonnull\n-    public static Map<String, Object> parse(@Nonnull String jsonString) {\n-        return uncheckCall(() -> JSON_JR.mapFrom(jsonString));\n+    public static Object anyFrom(@Nonnull String jsonString) throws IOException {\n+        return JSON_JR.anyFrom(jsonString);\n     }\n \n     /**\n-     * Converts the contents of the specified {@code reader} to a {@link Map}.\n+     * Returns an {@link Iterator} over the sequence of JSON objects parsed\n+     * from given JSON string.\n      */\n     @Nonnull\n-    public static Map<String, Object> parse(@Nonnull Reader reader) {\n-        return uncheckCall(() -> JSON_JR.mapFrom(reader));\n+    public static <T> Iterator<T> sequenceFrom(@Nonnull Class<T> type, @Nonnull String jsonString)\n+            throws IOException {\n+        return JSON_JR.beanSequenceFrom(type, jsonString);\n     }\n \n     /**\n      * Returns an {@link Iterator} over the sequence of JSON objects parsed\n      * from given {@code reader}.\n      */\n     @Nonnull\n-    public static <T> Iterator<T> parseSequence(@Nonnull Class<T> type, @Nonnull Reader reader) {\n-        return uncheckCall(() -> JSON_JR.beanSequenceFrom(type, reader));\n-    }\n-\n-    /**\n-     * Extracts a string value from given JSON string. For extracting multiple\n-     * values from a JSON string see {@link #parse(String)}.\n-     */\n-    @Nonnull\n-    public static String getString(@Nonnull String jsonString, @Nonnull String key) {\n-        return (String) parse(jsonString).get(key);\n-    }\n-\n-    /**\n-     * Extracts an integer value from given JSON string. For extracting\n-     * multiple values from a JSON string see {@link #parse(String)}.\n-     */\n-    public static int getInt(@Nonnull String jsonString, @Nonnull String key) {\n-        return (int) parse(jsonString).get(key);\n-    }\n-\n-    /**\n-     * Extracts a boolean value from given JSON string. For extracting\n-     * multiple values from a JSON string see {@link #parse(String)}.\n-     */\n-    public static boolean getBoolean(@Nonnull String jsonString, @Nonnull String key) {\n-        return (boolean) parse(jsonString).get(key);\n+    public static <T> Iterator<T> sequenceFrom(@Nonnull Class<T> type, @Nonnull Reader reader)\n+            throws IOException {\n+        return JSON_JR.beanSequenceFrom(type, reader);\n     }\n \n     /**\n-     * Extracts an array value as a {@link List} from given JSON string. For\n-     * extracting multiple values from a JSON string see {@link #parse(String)}.\n+     * Returns a function which takes a file {@code Path} as input and\n+     * returns a stream of objects with the given type. The content of the file\n+     * is considered to have a sequence of JSON strings, each one can span\n+     * multiple lines. The function is designed to be used with\n+     * {@link FileSourceBuilder#build(FunctionEx)}.\n+     * <p>\n+     * See {@link Sources#json(String, Class)}.\n      */\n     @Nonnull\n-    public static List<Object> getList(@Nonnull String jsonString, @Nonnull String key) {\n-        return (List) parse(jsonString).get(key);\n+    public static <T> FunctionEx<? super Path, ? extends Stream<T>> asMultilineJson(\n+            @Nonnull Class<T> type\n+    ) {\n+        return path -> {\n+            InputStreamReader reader = new InputStreamReader(new FileInputStream(path.toFile()), UTF_8);\n+            Spliterator<T> spliterator = Spliterators.spliteratorUnknownSize(JsonUtil.sequenceFrom(type, reader),\n+                    Spliterator.ORDERED | Spliterator.NONNULL);\n+            return StreamSupport.stream(spliterator, false);\n+        };\n     }\n \n     /**\n-     * Extracts an array value as a {@link Object Object[]} from given JSON\n-     * string. For extracting multiple values from a JSON string see\n-     * {@link #parse(String)}.\n+     * Returns a bi-function which takes the fileName and line as input\n+     * and returns an object by converting the line to an object of\n+     * given {@code type}. The function is designed to be used with\n+     * {@link FileSourceBuilder#build(BiFunctionEx)} and\n+     * {@link FileSourceBuilder#buildWatcher(BiFunctionEx)}.\n+     * <p>\n+     * See {@link Sources#json(String, Class)} and\n+     * {@link Sources#jsonWatcher(String, Class)}.\n      */\n     @Nonnull\n-    public static Object[] getArray(@Nonnull String jsonString, @Nonnull String key) {\n-        return getList(jsonString, key).toArray();\n+    public static <T> BiFunctionEx<String, String, ? extends T> asJson(@Nonnull Class<T> type) {\n+        return (fileName, line) -> JsonUtil.mapFrom(type, line);\n     }\n \n     /**\n-     * Extracts an object as a {@link Map} from given JSON string. For\n-     * extracting multiple values from a JSON string see {@link #parse(String)}.\n+     * Returns a bi-function which takes the fileName and line as input, parses\n+     * the line to the {@link Map} representation of the JSON string and\n+     * returns it. The function is designed to be used with\n+     * {@link FileSourceBuilder#build(BiFunctionEx)} and\n+     * {@link FileSourceBuilder#buildWatcher(BiFunctionEx)}.\n+     * <p>\n+     * See {@link Sources#json(String)} and\n+     * {@link Sources#jsonWatcher(String)}.\n      */\n     @Nonnull\n-    public static Map<String, Object> getObject(@Nonnull String jsonString, @Nonnull String key) {\n-        return (Map<String, Object>) parse(jsonString).get(key);\n+    public static BiFunctionEx<String, String, Map<String, Object>> asJson() {", "originalCommit": "46dcc0e94d3964534dbd6feb0205c3d8cb0f6cc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwNDc0Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r423004743", "bodyText": "missing @since", "author": "cangencer", "createdAt": "2020-05-11T12:31:06Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/Sources.java", "diffHunk": "@@ -1012,6 +1057,50 @@ public static FileSourceBuilder filesBuilder(@Nonnull String directory) {\n         return filesBuilder(watchedDirectory).buildWatcher();\n     }\n \n+    /**\n+     * A source to stream lines added to files with a `.json` extension in a\n+     * directory. This is a streaming source, it will watch directory and emit\n+     * objects of given {@code type} by converting each line as they are\n+     * appended to files in that directory.\n+     * <p>\n+     * This method is a shortcut for: <pre>{@code\n+     *   filesBuilder(directory)\n+     *      .charset(UTF_8)\n+     *      .glob(GLOB_WILDCARD)\n+     *      .sharedFileSystem(false)\n+     *      .buildWatcher((JsonUtil.asJson(type))\n+     * }</pre>\n+     *\n+     * <h3>Appending lines using an text editor</h3>\n+     * If you're testing this source, you might think of using a text editor to\n+     * append the lines. However, it might not work as expected because some\n+     * editors write to a temp file and then rename it or append extra newline\n+     * character at the end which gets overwritten if more text is added in the\n+     * editor. The best way to append is to use {@code echo text >> yourFile}.\n+     *\n+     * See {@link #filesBuilder(String)}, {@link #fileWatcher(String)},\n+     * and {@link JsonUtil#asJson(Class)}.\n+     *\n+     * @since 4.2\n+     */\n+    @Nonnull\n+    public static <T> StreamSource<T> jsonWatcher(@Nonnull String watchedDirectory, @Nonnull Class<T> type) {\n+        return filesBuilder(watchedDirectory)\n+                .glob(\"*.json\")\n+                .buildWatcher(JsonUtil.asJson(type));\n+    }\n+\n+    /**\n+     * Convenience for {@link #jsonWatcher(String, Class)} which converts each\n+     * line appended to the {@link Map} representation of the JSON string.\n+     */\n+    @Nonnull", "originalCommit": "46dcc0e94d3964534dbd6feb0205c3d8cb0f6cc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAwNTQ5MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r423005491", "bodyText": "I don't see any test coverage for this, does it actually work as intended? or we can get half-written JSON?", "author": "cangencer", "createdAt": "2020-05-11T12:32:29Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/Sources.java", "diffHunk": "@@ -1012,6 +1057,50 @@ public static FileSourceBuilder filesBuilder(@Nonnull String directory) {\n         return filesBuilder(watchedDirectory).buildWatcher();\n     }\n \n+    /**\n+     * A source to stream lines added to files with a `.json` extension in a\n+     * directory. This is a streaming source, it will watch directory and emit\n+     * objects of given {@code type} by converting each line as they are\n+     * appended to files in that directory.\n+     * <p>\n+     * This method is a shortcut for: <pre>{@code\n+     *   filesBuilder(directory)\n+     *      .charset(UTF_8)\n+     *      .glob(GLOB_WILDCARD)\n+     *      .sharedFileSystem(false)\n+     *      .buildWatcher((JsonUtil.asJson(type))\n+     * }</pre>\n+     *\n+     * <h3>Appending lines using an text editor</h3>\n+     * If you're testing this source, you might think of using a text editor to\n+     * append the lines. However, it might not work as expected because some\n+     * editors write to a temp file and then rename it or append extra newline\n+     * character at the end which gets overwritten if more text is added in the\n+     * editor. The best way to append is to use {@code echo text >> yourFile}.\n+     *\n+     * See {@link #filesBuilder(String)}, {@link #fileWatcher(String)},\n+     * and {@link JsonUtil#asJson(Class)}.\n+     *\n+     * @since 4.2\n+     */\n+    @Nonnull\n+    public static <T> StreamSource<T> jsonWatcher(@Nonnull String watchedDirectory, @Nonnull Class<T> type) {", "originalCommit": "46dcc0e94d3964534dbd6feb0205c3d8cb0f6cc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a59dd90f62ddc69e7dcc87024034f3758b5ed850", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a59dd90f62ddc69e7dcc87024034f3758b5ed850", "message": "remove JsonUtil function methods", "committedDate": "2020-05-11T14:01:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNTc1OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r423505759", "bodyText": "can we also update the summary section in the end?", "author": "cangencer", "createdAt": "2020-05-12T07:02:47Z", "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -79,6 +117,15 @@ p.readFrom(Sources.fileWatcher(\"/home/data\"))\n  .writeTo(Sinks.logger());\n ```\n \n+You can create streaming file source for JSON files too:\n+\n+```java\n+Pipeline p = Pipeline.create();\n+p.readFrom(Sources.jsonWatcher(\"/home/data\", Person.class))\n+ .withoutTimestamps()\n+ .writeTo(Sinks.logger());\n+```\n+", "originalCommit": "a59dd90f62ddc69e7dcc87024034f3758b5ed850", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNTg2Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2240#discussion_r423505862", "bodyText": "could we add the target release here?", "author": "cangencer", "createdAt": "2020-05-12T07:02:59Z", "path": "site/docs/design-docs/011-json-convenience.md", "diffHunk": "@@ -0,0 +1,208 @@\n+---\n+title: 010 - JSON Convenience\n+description: Add tooling to work with JSON formatted data.\n+---\n+", "originalCommit": "a59dd90f62ddc69e7dcc87024034f3758b5ed850", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "be73c38d2ba010b3ab765d05d02f945c097bb70c", "url": "https://github.com/hazelcast/hazelcast-jet/commit/be73c38d2ba010b3ab765d05d02f945c097bb70c", "message": "add json to sources/sinks summary, add target release for json", "committedDate": "2020-05-12T07:29:48Z", "type": "commit"}, {"oid": "6644d15b935201b4ea1eed95bc1eb0565ee19efd", "url": "https://github.com/hazelcast/hazelcast-jet/commit/6644d15b935201b4ea1eed95bc1eb0565ee19efd", "message": "fix typo", "committedDate": "2020-05-12T07:32:15Z", "type": "commit"}, {"oid": "38a7e538b08030be73cb25ecc999fea524e95398", "url": "https://github.com/hazelcast/hazelcast-jet/commit/38a7e538b08030be73cb25ecc999fea524e95398", "message": "docs improvements", "committedDate": "2020-05-12T10:18:18Z", "type": "commit"}, {"oid": "624bdfa20377488a69c843361dffa83355f9a85e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/624bdfa20377488a69c843361dffa83355f9a85e", "message": "fix id", "committedDate": "2020-05-12T10:20:50Z", "type": "commit"}, {"oid": "d5fe764a656f069b69f427ab701f65593632abbc", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d5fe764a656f069b69f427ab701f65593632abbc", "message": "fix annotation", "committedDate": "2020-05-12T10:43:31Z", "type": "commit"}, {"oid": "1fd063607e9be0ae5dbd3f619be5400893666dda", "url": "https://github.com/hazelcast/hazelcast-jet/commit/1fd063607e9be0ae5dbd3f619be5400893666dda", "message": "fix more annotations", "committedDate": "2020-05-12T11:14:06Z", "type": "commit"}]}