{"pr_number": 2595, "pr_title": "Support SQL batch aggregations", "pr_createdAt": "2020-10-08T10:18:15Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2595", "timeline": [{"oid": "7b63e2edb1f7dc018107a559735be56fdf68112a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/7b63e2edb1f7dc018107a559735be56fdf68112a", "message": "Basic support for GROUP BY & aggregates", "committedDate": "2020-10-02T13:54:57Z", "type": "commit"}, {"oid": "442a5772cb6bcc87c189435a90ed5e63dade8500", "url": "https://github.com/hazelcast/hazelcast-jet/commit/442a5772cb6bcc87c189435a90ed5e63dade8500", "message": "Basic support for GROUP BY & aggregates", "committedDate": "2020-10-02T13:56:23Z", "type": "commit"}, {"oid": "354ba340071c8df2dd4f0738c6c0e1e59283e2c4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/354ba340071c8df2dd4f0738c6c0e1e59283e2c4", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-05T10:14:53Z", "type": "commit"}, {"oid": "5811c21551a805d9ea6bed3a2eb6336f3061e12d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/5811c21551a805d9ea6bed3a2eb6336f3061e12d", "message": "Make empty aggregations work", "committedDate": "2020-10-05T15:03:11Z", "type": "commit"}, {"oid": "fd518d2dc8bcaa9a3d0dd7d3a543a757ce1a10a4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/fd518d2dc8bcaa9a3d0dd7d3a543a757ce1a10a4", "message": "Refactor", "committedDate": "2020-10-06T09:13:30Z", "type": "commit"}, {"oid": "e8a01d4b82b5c1f2488b521a7375014dd1ac5723", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e8a01d4b82b5c1f2488b521a7375014dd1ac5723", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-06T09:18:12Z", "type": "commit"}, {"oid": "e6f496ec6e27ac12c20d136b96affd19ca5978d4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e6f496ec6e27ac12c20d136b96affd19ca5978d4", "message": "Fail on DISTINCT aggregate", "committedDate": "2020-10-06T09:28:55Z", "type": "commit"}, {"oid": "190e409a54d604ca11990e45b28ed19376a84b3b", "url": "https://github.com/hazelcast/hazelcast-jet/commit/190e409a54d604ca11990e45b28ed19376a84b3b", "message": "Fail aggregation on stream connector", "committedDate": "2020-10-06T09:33:50Z", "type": "commit"}, {"oid": "b391522ff6b40b06083f4229fe4644c2aea06d06", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b391522ff6b40b06083f4229fe4644c2aea06d06", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-06T09:37:17Z", "type": "commit"}, {"oid": "bb126ffc9a151814a2a0d0cde520d4c56db013bc", "url": "https://github.com/hazelcast/hazelcast-jet/commit/bb126ffc9a151814a2a0d0cde520d4c56db013bc", "message": "Fail aggregation on stream connector", "committedDate": "2020-10-06T10:02:53Z", "type": "commit"}, {"oid": "47608ba1f6c9e78e71e0298e0727a31761967f08", "url": "https://github.com/hazelcast/hazelcast-jet/commit/47608ba1f6c9e78e71e0298e0727a31761967f08", "message": "Fix checkstyle", "committedDate": "2020-10-06T11:55:25Z", "type": "commit"}, {"oid": "310378d4880b90c2f7caf9268bc75b2f8b88ea5f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/310378d4880b90c2f7caf9268bc75b2f8b88ea5f", "message": "Naming & simplify", "committedDate": "2020-10-06T12:04:31Z", "type": "commit"}, {"oid": "96ba2698b3e6172e57ef577d2318f702e3632210", "url": "https://github.com/hazelcast/hazelcast-jet/commit/96ba2698b3e6172e57ef577d2318f702e3632210", "message": "Cleanup", "committedDate": "2020-10-06T12:21:22Z", "type": "commit"}, {"oid": "d85b393b3c3faea45e988fe6b85dd61863e518d4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d85b393b3c3faea45e988fe6b85dd61863e518d4", "message": "Yet another format & cleanup", "committedDate": "2020-10-06T12:33:44Z", "type": "commit"}, {"oid": "d182179500873f074736b421de60f92bb1a24b00", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d182179500873f074736b421de60f92bb1a24b00", "message": "Adjust sum types & cleanup", "committedDate": "2020-10-07T07:08:20Z", "type": "commit"}, {"oid": "191d8f104671acf2bf6f38de8297f4f00119f5d3", "url": "https://github.com/hazelcast/hazelcast-jet/commit/191d8f104671acf2bf6f38de8297f4f00119f5d3", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-07T07:20:45Z", "type": "commit"}, {"oid": "9ecb3c436c1a8cbd99bf52ce099d78e801d6248a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/9ecb3c436c1a8cbd99bf52ce099d78e801d6248a", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-07T10:14:50Z", "type": "commit"}, {"oid": "61f5f828ef841b7ab6ee6da1a9a81e87db0fd351", "url": "https://github.com/hazelcast/hazelcast-jet/commit/61f5f828ef841b7ab6ee6da1a9a81e87db0fd351", "message": "Better support for scalar aggregates", "committedDate": "2020-10-07T13:47:52Z", "type": "commit"}, {"oid": "2bac3162b0aef424590ea101439feb21c74d6fbe", "url": "https://github.com/hazelcast/hazelcast-jet/commit/2bac3162b0aef424590ea101439feb21c74d6fbe", "message": "Better description", "committedDate": "2020-10-07T14:14:13Z", "type": "commit"}, {"oid": "aa2e1f5fb811c47a70cb32e2d95defa1b98e695e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/aa2e1f5fb811c47a70cb32e2d95defa1b98e695e", "message": "Better description", "committedDate": "2020-10-07T14:14:45Z", "type": "commit"}, {"oid": "38282765635da1c57d2bc8bbd3d92e47533ce37d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/38282765635da1c57d2bc8bbd3d92e47533ce37d", "message": "Better description", "committedDate": "2020-10-07T14:17:09Z", "type": "commit"}, {"oid": "f25d10041e5d8855763133aadab87d6a32ad2aff", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f25d10041e5d8855763133aadab87d6a32ad2aff", "message": "Fix grouping by nullable column", "committedDate": "2020-10-08T06:13:50Z", "type": "commit"}, {"oid": "4d6b17816cb66bcf58573aedbcc21d10c9987f04", "url": "https://github.com/hazelcast/hazelcast-jet/commit/4d6b17816cb66bcf58573aedbcc21d10c9987f04", "message": "Fix grouping by nullable column", "committedDate": "2020-10-08T06:33:44Z", "type": "commit"}, {"oid": "0c77dc8acf2a87041b8b446acf91ebb77fba28bf", "url": "https://github.com/hazelcast/hazelcast-jet/commit/0c77dc8acf2a87041b8b446acf91ebb77fba28bf", "message": "Refactor", "committedDate": "2020-10-08T07:29:44Z", "type": "commit"}, {"oid": "b5ae9a62e2718c12b625235d8d2b0c1fad48a21a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b5ae9a62e2718c12b625235d8d2b0c1fad48a21a", "message": "Cleanup", "committedDate": "2020-10-08T08:45:09Z", "type": "commit"}, {"oid": "eb62667cefb180d579477d76173a81a37b3bb432", "url": "https://github.com/hazelcast/hazelcast-jet/commit/eb62667cefb180d579477d76173a81a37b3bb432", "message": "Support COUNTing non nulls", "committedDate": "2020-10-08T13:19:55Z", "type": "commit"}, {"oid": "5b0bcfe10a9a75fa398039a3e90f937aaa725c7e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/5b0bcfe10a9a75fa398039a3e90f937aaa725c7e", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-09T20:49:32Z", "type": "commit"}, {"oid": "6010325325ab66d5fa357fcbd08aafe1cf869393", "url": "https://github.com/hazelcast/hazelcast-jet/commit/6010325325ab66d5fa357fcbd08aafe1cf869393", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-09T21:53:40Z", "type": "commit"}, {"oid": "70763cbcce3ba7b6a4e3e9231b1c8ce8749428b9", "url": "https://github.com/hazelcast/hazelcast-jet/commit/70763cbcce3ba7b6a4e3e9231b1c8ce8749428b9", "message": "Add Javadoc", "committedDate": "2020-10-09T22:04:25Z", "type": "commit"}, {"oid": "df1c61b709e8d4ee997437a76eaa5270ba4b431b", "url": "https://github.com/hazelcast/hazelcast-jet/commit/df1c61b709e8d4ee997437a76eaa5270ba4b431b", "message": "More tests", "committedDate": "2020-10-09T22:04:37Z", "type": "commit"}, {"oid": "908f2f483f4b5f8e845e0cccc39114c0327c99be", "url": "https://github.com/hazelcast/hazelcast-jet/commit/908f2f483f4b5f8e845e0cccc39114c0327c99be", "message": "Validate special chars in TestBatchSqlConnector", "committedDate": "2020-10-09T22:05:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ2Nzg0OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2595#discussion_r502467849", "bodyText": "This is almost a copy of forceTotalParallelismOne. It would be better to create forceTotalParallelismOne(targetAddress) next to the current fTPO.\n\n\nif no member has the desired address, it will create no-op processors on all members. It's apparently designed to be used with Edge.distributedTo, but it would be better to handle this case cleanly. We can check addresses.contains(destinationAddress) and throw if not.", "author": "viliam-durina", "createdAt": "2020-10-09T14:30:16Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/aggregate/AggregateProcessors.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.aggregate;\n+\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.Traverser;\n+import com.hazelcast.jet.aggregate.AggregateOperation;\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.Processor;\n+import com.hazelcast.jet.core.ProcessorMetaSupplier;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.DataSerializable;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.nCopies;\n+import static java.util.Collections.singletonList;\n+\n+public final class AggregateProcessors {\n+\n+    private AggregateProcessors() {\n+    }\n+\n+    public static ProcessorMetaSupplier combine(\n+            Address destinationMemberAddress,\n+            FunctionEx<Object, Object> partitionKeyFn,\n+            AggregateOperation<Aggregations, Object[]> aggregateOperation\n+    ) {\n+        return new CombineProcessorMetaSupplier(destinationMemberAddress, partitionKeyFn, aggregateOperation);\n+    }\n+\n+    @SuppressFBWarnings(\n+            value = {\"SE_BAD_FIELD\", \"SE_NO_SERIALVERSIONID\"},\n+            justification = \"the class is never java-serialized\"\n+    )\n+    private static final class CombineProcessorMetaSupplier implements ProcessorMetaSupplier, DataSerializable {\n+\n+        private transient Address destinationMemberAddress;\n+        private FunctionEx<Object, Object> partitionKeyFn;\n+        private AggregateOperation<Aggregations, Object[]> aggregationOperation;\n+\n+        @SuppressWarnings(\"unused\")\n+        private CombineProcessorMetaSupplier() {\n+        }\n+\n+        private CombineProcessorMetaSupplier(\n+                Address destinationMemberAddress,\n+                FunctionEx<Object, Object> partitionKeyFn,\n+                AggregateOperation<Aggregations, Object[]> aggregationOperation\n+        ) {\n+            this.destinationMemberAddress = destinationMemberAddress;\n+            this.partitionKeyFn = partitionKeyFn;\n+            this.aggregationOperation = aggregationOperation;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public Function<? super Address, ? extends ProcessorSupplier> get(@Nonnull List<Address> addresses) {\n+            return address -> address.equals(destinationMemberAddress)\n+                    ?\n+                    new ProcessorSupplier() {\n+                        @Nonnull\n+                        @Override\n+                        public Collection<? extends Processor> get(int count) {\n+                            assert count == 1 : \"\" + count;\n+\n+                            return singletonList(new CombineP(partitionKeyFn, aggregationOperation));\n+                        }\n+                    }\n+                    :\n+                    count -> nCopies(count, new AbstractProcessor() {\n+                        @Override\n+                        protected boolean tryProcess(int ordinal, @Nonnull Object item) {\n+                            throw new IllegalArgumentException(\"This vertex has a total parallelism of one\"\n+                                    + \" and expects input on a specific edge. Edge configuration must be adjusted\"\n+                                    + \" to make sure that only the expected node receives any input.\"\n+                                    + \" Unexpected input received from ordinal \" + ordinal + \": \" + item\n+                            );\n+                        }\n+\n+                        @Override\n+                        protected void restoreFromSnapshot(@Nonnull Object key, @Nonnull Object value) {\n+                            // state might be broadcast to all instances - ignore it in the no-op instances\n+                        }\n+                    });\n+        }", "originalCommit": "eb62667cefb180d579477d76173a81a37b3bb432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ3MDM3Ng==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2595#discussion_r502470376", "bodyText": "We already use # to denote processor instance. Different character would be better, e.g. _", "author": "viliam-durina", "createdAt": "2020-10-09T14:34:08Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/opt/physical/visitor/CreateDagVisitor.java", "diffHunk": "@@ -91,43 +103,93 @@ public Vertex onFullScan(FullScanPhysicalRel rel) {\n     public Vertex onFilter(FilterPhysicalRel rel) {\n         PredicateEx<Object[]> filter = ExpressionUtil.filterFn(rel.filter());\n \n-        Vertex vertex = dag.newVertex(\"Filter\", filterP(filter::test));\n+        Vertex vertex = dag.newVertex(name(\"Filter\"), filterP(filter::test));\n         connectInput(rel.getInput(), vertex, null);\n         return vertex;\n     }\n \n     public Vertex onProject(ProjectPhysicalRel rel) {\n         FunctionEx<Object[], Object[]> projection = ExpressionUtil.projectionFn(rel.projection());\n \n-        Vertex vertex = dag.newVertex(\"Project\", mapP(projection));\n+        Vertex vertex = dag.newVertex(name(\"Project\"), mapP(projection));\n+        connectInput(rel.getInput(), vertex, null);\n+        return vertex;\n+    }\n+\n+    public Vertex onGroup(AggregateGroupPhysicalRel rel) {\n+        AggregateOperation<?, Object[]> aggregateOperation = rel.aggregateOperation();\n+\n+        Vertex vertex = dag.newVertex(\n+                name(\"Aggregate-Accumulate\"),\n+                Processors.accumulateP(aggregateOperation)\n+        );\n         connectInput(rel.getInput(), vertex, null);\n         return vertex;\n     }\n \n+    public Vertex onGroupByKey(AggregateGroupByKeyPhysicalRel rel) {\n+        FunctionEx<Object[], Object> partitionKeyFn = rel.partitionKeyFn();\n+        AggregateOperation<?, Object[]> aggregateOperation = rel.aggregateOperation();\n+\n+        Vertex vertex = dag.newVertex(\n+                name(\"Aggregate-Accumulate\"),\n+                Processors.accumulateByKeyP(singletonList(partitionKeyFn), aggregateOperation)\n+        );\n+        connectInput(rel.getInput(), vertex, edge -> edge.partitioned(partitionKeyFn));\n+        return vertex;\n+    }\n+\n+    public Vertex onCombine(AggregateCombinePhysicalRel rel) {\n+        SqlConnector connector = getJetSqlConnector(OptUtils.findHazelcastTable(rel).getTarget());\n+        if (connector.isStream()) {\n+            throw new UnsupportedOperationException(\"Grouping/aggregations are not supported for \"\n+                    + connector.getClass().getName());\n+        }\n+\n+        FunctionEx<Object, Object> partitionKeyFn = rel.partitionKeyFn();\n+        AggregateOperation<Aggregations, Object[]> aggregateOperation = rel.aggregateOperation();\n+\n+        Vertex vertex = dag.newVertex(\n+                name(\"Aggregate-Combine\"),\n+                AggregateProcessors.combine(localMemberAddress, partitionKeyFn, aggregateOperation)\n+        );\n+        connectInput(rel.getInput(), vertex, edge -> edge.allToOne(\"\").distributeTo(localMemberAddress));\n+        return vertex;\n+    }\n+\n     public Vertex onRoot(JetRootRel rootRel) {\n-        Vertex vertex = dag.newVertex(\"ClientSink\",\n+        Vertex vertex = dag.newVertex(name(\"ClientSink\"),\n                 rootResultConsumerSink(rootRel.getInitiatorAddress(), rootRel.getQueryId()));\n \n         // We use distribute-to-one edge to send all the items to the initiator member.\n         // Such edge has to be partitioned, but the sink is LP=1 anyway, so we can use\n         // allToOne with any key, it goes to a single processor on a single member anyway.\n-        connectInput(rootRel.getInput(), vertex,\n-                edge -> edge.allToOne(\"\").distributeTo(localMemberAddress));\n+        connectInput(rootRel.getInput(), vertex, edge -> edge.allToOne(\"\").distributeTo(localMemberAddress));\n         return vertex;\n     }\n \n     public DAG getDag() {\n         return dag;\n     }\n \n+    /**\n+     * Creates a unique {@code Vertex} name with a given prefix.\n+     */\n+    private String name(String prefix) {\n+        return prefix + \"#\" + ++vertexCounter;", "originalCommit": "eb62667cefb180d579477d76173a81a37b3bb432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY0MDQ2OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2595#discussion_r502640468", "bodyText": "We should handle overflows in the same way as IMDG: https://github.com/hazelcast/hazelcast/blob/a9aa9696060383e9205ea5d097711d221d27a9bf/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/PlusIntegrationTest.java#L114\nAlso in all other aggregations", "author": "viliam-durina", "createdAt": "2020-10-09T19:49:31Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/aggregate/SumAggregation.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.aggregate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.Objects;\n+\n+import static com.hazelcast.sql.impl.expression.math.ExpressionMath.DECIMAL_MATH_CONTEXT;\n+\n+@NotThreadSafe\n+public class SumAggregation implements Aggregation {\n+\n+    private int index;\n+    private QueryDataType operandType;\n+    private QueryDataType resultType;\n+\n+    private Object value;\n+\n+    @SuppressWarnings(\"unused\")\n+    private SumAggregation() {\n+    }\n+\n+    public SumAggregation(int index, QueryDataType operandType) {\n+        this.index = index;\n+        this.operandType = operandType;\n+        this.resultType = inferResultType(operandType);\n+    }\n+\n+    private static QueryDataType inferResultType(QueryDataType operandType) {\n+        switch (operandType.getTypeFamily()) {\n+            case TINYINT:\n+            case SMALLINT:\n+            case INTEGER:\n+            case BIGINT:\n+                return QueryDataType.BIGINT;\n+            case DECIMAL:\n+                return QueryDataType.DECIMAL;\n+            case REAL:\n+            case DOUBLE:\n+                return QueryDataType.DOUBLE;\n+            default:\n+                throw QueryException.error(\"Unsupported operand type: \" + operandType);\n+        }\n+    }\n+\n+    @Override\n+    public QueryDataType resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public void accumulate(Object[] row) {\n+        Object value = row[index];\n+        if (value != null) {\n+            add(value, operandType.getConverter());\n+        }\n+    }\n+\n+    @Override\n+    public void combine(Aggregation other0) {\n+        SumAggregation other = (SumAggregation) other0;\n+\n+        Object value = other.value;\n+        if (value != null) {\n+            add(value, resultType.getConverter());\n+        }\n+    }\n+\n+    private void add(Object value, Converter converter) {\n+        if (this.value == null) {\n+            this.value = identity();\n+        }\n+\n+        switch (resultType.getTypeFamily()) {\n+            case BIGINT:\n+                this.value = (long) this.value + converter.asBigint(value);", "originalCommit": "eb62667cefb180d579477d76173a81a37b3bb432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY1NTMyMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2595#discussion_r502655322", "bodyText": "We should not put user data to error messages. We can put the class.", "author": "viliam-durina", "createdAt": "2020-10-09T20:25:37Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/aggregate/MaxAggregation.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.aggregate;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+@NotThreadSafe\n+public class MaxAggregation implements Aggregation {\n+\n+    private int index;\n+    private QueryDataType operandType;\n+\n+    private Object value;\n+\n+    @SuppressWarnings(\"unused\")\n+    private MaxAggregation() {\n+    }\n+\n+    public MaxAggregation(int index, QueryDataType operandType) {\n+        this.index = index;\n+        this.operandType = operandType;\n+    }\n+\n+    @Override\n+    public QueryDataType resultType() {\n+        return operandType;\n+    }\n+\n+    @Override\n+    public void accumulate(Object[] row) {\n+        Object value = row[index];\n+\n+        if (this.value == null || (value != null && compare(this.value, value) < 0)) {\n+            this.value = value;\n+        }\n+    }\n+\n+    @Override\n+    public void combine(Aggregation other0) {\n+        MaxAggregation other = (MaxAggregation) other0;\n+\n+        Object value = other.value;\n+\n+        if (this.value == null || (value != null && compare(this.value, value) < 0)) {\n+            this.value = value;\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private int compare(Object left, Object right) {\n+        assert left != null;\n+        assert right != null;\n+\n+        Comparable leftComparable = asComparable(left);\n+        Comparable rightComparable = asComparable(right);\n+\n+        return leftComparable.compareTo(rightComparable);\n+    }\n+\n+    private static Comparable<?> asComparable(Object value) {\n+        if (value instanceof Comparable) {\n+            return (Comparable<?>) value;\n+        } else {\n+            throw QueryException.error(\"Value is not comparable: \" + value);", "originalCommit": "eb62667cefb180d579477d76173a81a37b3bb432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2MTkxNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2595#discussion_r502661916", "bodyText": "There's only one processor in this class. I'd move it to the processors package and put only 1 processor per file: one processor is multiple classes and many lines, it will be better encapsulated.", "author": "viliam-durina", "createdAt": "2020-10-09T20:42:02Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/aggregate/AggregateProcessors.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.aggregate;\n+\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.Traverser;\n+import com.hazelcast.jet.aggregate.AggregateOperation;\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.Processor;\n+import com.hazelcast.jet.core.ProcessorMetaSupplier;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.DataSerializable;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.nCopies;\n+import static java.util.Collections.singletonList;\n+\n+public final class AggregateProcessors {", "originalCommit": "eb62667cefb180d579477d76173a81a37b3bb432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY3NDk1Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2595#discussion_r502674952", "bodyText": "We could be aggregating a result of a join, the findHazelcastTable will fail...\nIt would be better to validate this in JetSqlValidator: we already validate there that CREATE JOB is used for a streaming query.\nAlso it's enough to say \"not supported for a streaming query\"", "author": "viliam-durina", "createdAt": "2020-10-09T21:16:43Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/opt/physical/visitor/CreateDagVisitor.java", "diffHunk": "@@ -91,43 +103,93 @@ public Vertex onFullScan(FullScanPhysicalRel rel) {\n     public Vertex onFilter(FilterPhysicalRel rel) {\n         PredicateEx<Object[]> filter = ExpressionUtil.filterFn(rel.filter());\n \n-        Vertex vertex = dag.newVertex(\"Filter\", filterP(filter::test));\n+        Vertex vertex = dag.newVertex(name(\"Filter\"), filterP(filter::test));\n         connectInput(rel.getInput(), vertex, null);\n         return vertex;\n     }\n \n     public Vertex onProject(ProjectPhysicalRel rel) {\n         FunctionEx<Object[], Object[]> projection = ExpressionUtil.projectionFn(rel.projection());\n \n-        Vertex vertex = dag.newVertex(\"Project\", mapP(projection));\n+        Vertex vertex = dag.newVertex(name(\"Project\"), mapP(projection));\n+        connectInput(rel.getInput(), vertex, null);\n+        return vertex;\n+    }\n+\n+    public Vertex onGroup(AggregateGroupPhysicalRel rel) {\n+        AggregateOperation<?, Object[]> aggregateOperation = rel.aggregateOperation();\n+\n+        Vertex vertex = dag.newVertex(\n+                name(\"Aggregate-Accumulate\"),\n+                Processors.accumulateP(aggregateOperation)\n+        );\n         connectInput(rel.getInput(), vertex, null);\n         return vertex;\n     }\n \n+    public Vertex onGroupByKey(AggregateGroupByKeyPhysicalRel rel) {\n+        FunctionEx<Object[], Object> partitionKeyFn = rel.partitionKeyFn();\n+        AggregateOperation<?, Object[]> aggregateOperation = rel.aggregateOperation();\n+\n+        Vertex vertex = dag.newVertex(\n+                name(\"Aggregate-Accumulate\"),\n+                Processors.accumulateByKeyP(singletonList(partitionKeyFn), aggregateOperation)\n+        );\n+        connectInput(rel.getInput(), vertex, edge -> edge.partitioned(partitionKeyFn));\n+        return vertex;\n+    }\n+\n+    public Vertex onCombine(AggregateCombinePhysicalRel rel) {\n+        SqlConnector connector = getJetSqlConnector(OptUtils.findHazelcastTable(rel).getTarget());\n+        if (connector.isStream()) {\n+            throw new UnsupportedOperationException(\"Grouping/aggregations are not supported for \"\n+                    + connector.getClass().getName());", "originalCommit": "eb62667cefb180d579477d76173a81a37b3bb432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "42121a5755c9e95b44ec5393e6203836f460c897", "url": "https://github.com/hazelcast/hazelcast-jet/commit/42121a5755c9e95b44ec5393e6203836f460c897", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-12T08:19:21Z", "type": "commit"}, {"oid": "4363176495c4e2b5cebca97cff0e66faa9333cb9", "url": "https://github.com/hazelcast/hazelcast-jet/commit/4363176495c4e2b5cebca97cff0e66faa9333cb9", "message": "Address review comments", "committedDate": "2020-10-12T10:43:48Z", "type": "commit"}, {"oid": "c6121768d7bbea30bc5714b01bfb9b071d2741f4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/c6121768d7bbea30bc5714b01bfb9b071d2741f4", "message": "Support DISTINCT aggregates", "committedDate": "2020-10-12T11:03:00Z", "type": "commit"}, {"oid": "50bf9ae813a3ff40371173849eb2a6cd2e710b6b", "url": "https://github.com/hazelcast/hazelcast-jet/commit/50bf9ae813a3ff40371173849eb2a6cd2e710b6b", "message": "Make checkstyle happy", "committedDate": "2020-10-12T11:26:43Z", "type": "commit"}, {"oid": "a26d1d7d3bb758ab7c302034158f87a058e785a6", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a26d1d7d3bb758ab7c302034158f87a058e785a6", "message": "Make spotbugs happy", "committedDate": "2020-10-12T11:38:15Z", "type": "commit"}, {"oid": "f3d93140b8d83234b9c53cd25475a8573ab67306", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f3d93140b8d83234b9c53cd25475a8573ab67306", "message": "Fix grouping/aggregation validation", "committedDate": "2020-10-12T12:36:00Z", "type": "commit"}, {"oid": "918cd4b07858881db3463b9b6e394231a5c76fe7", "url": "https://github.com/hazelcast/hazelcast-jet/commit/918cd4b07858881db3463b9b6e394231a5c76fe7", "message": "Merge branch 'sql-prod' into aggregates", "committedDate": "2020-10-13T06:33:04Z", "type": "commit"}, {"oid": "f9396df95792b36d878d84b11603da6ee61a1840", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f9396df95792b36d878d84b11603da6ee61a1840", "message": "Make SerialProcessorMS non-public, touchups", "committedDate": "2020-10-13T10:22:28Z", "type": "commit"}, {"oid": "97aba407045478838977af4d11b9774ef6bce245", "url": "https://github.com/hazelcast/hazelcast-jet/commit/97aba407045478838977af4d11b9774ef6bce245", "message": "Make checkstyle and spotbugs happy", "committedDate": "2020-10-13T10:36:31Z", "type": "commit"}, {"oid": "1cc3f2c2d85682137abd27fcfcc522292bfffa21", "url": "https://github.com/hazelcast/hazelcast-jet/commit/1cc3f2c2d85682137abd27fcfcc522292bfffa21", "message": "Remove unnecessary supplier", "committedDate": "2020-10-13T11:40:40Z", "type": "commit"}, {"oid": "0ba38c00187a8c1392583eedc59a9d2e7604bbdc", "url": "https://github.com/hazelcast/hazelcast-jet/commit/0ba38c00187a8c1392583eedc59a9d2e7604bbdc", "message": "Add two failing tests", "committedDate": "2020-10-13T11:48:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4NjA0Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2595#discussion_r503886043", "bodyText": "This is wrong. We'd return 1 row even if we're grouping and there's no input. See https://dbfiddle.uk/?rdbms=postgres_13&fiddle=597ea23ad5786aefc4716ad4fad8cbfc", "author": "viliam-durina", "createdAt": "2020-10-13T11:49:32Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/processors/AggregationCombiner.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.processors;\n+\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.Traverser;\n+import com.hazelcast.jet.aggregate.AggregateOperation;\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.sql.impl.aggregate.Aggregations;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import static java.util.Collections.singletonList;\n+\n+public final class AggregationCombiner extends AbstractProcessor {\n+\n+    private final Map<Object, Aggregations> keyToAggregations;\n+    private final FunctionEx<Object, Object> partitionKeyFn;\n+    private final AggregateOperation<Aggregations, Object[]> aggregationOperation;\n+\n+    private Traverser<Object[]> resultTraverser;\n+\n+    public AggregationCombiner(\n+            FunctionEx<Object, Object> partitionKeyFn,\n+            AggregateOperation<Aggregations, Object[]> aggregationOperation\n+    ) {\n+        this.keyToAggregations = new HashMap<>();\n+        this.partitionKeyFn = partitionKeyFn;\n+        this.aggregationOperation = aggregationOperation;\n+    }\n+\n+    @Override\n+    protected boolean tryProcess(int ordinal, @Nonnull Object item) {\n+        Aggregations aggregations = keyToAggregations.computeIfAbsent(\n+                partitionKeyFn.apply(item),\n+                key -> aggregationOperation.createFn().get()\n+        );\n+        aggregationOperation.accumulateFn(ordinal).accept(aggregations, item);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean complete() {\n+        if (resultTraverser == null) {\n+            resultTraverser = new ResultTraverser()\n+                    .map(aggregations -> aggregationOperation.finishFn().apply(aggregations));\n+        }\n+        return emitFromTraverser(resultTraverser);\n+    }\n+\n+    private final class ResultTraverser implements Traverser<Aggregations> {\n+\n+        private final Iterator<Aggregations> aggregations;\n+\n+        private ResultTraverser() {\n+            this.aggregations = keyToAggregations.isEmpty()\n+                    ? new ArrayList<>(singletonList(aggregationOperation.createFn().get())).iterator()\n+                    : keyToAggregations.values().iterator();", "originalCommit": "0ba38c00187a8c1392583eedc59a9d2e7604bbdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkwMjU3NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2595#discussion_r503902575", "bodyText": "This condition will wrongly reject this query:\nSELECT * FROM my_stream\nWHERE a=(SELECT COUNT(*) FROM my_table)\nWe don't support joins yet though. I think we should not check for aggregations on a deeper level. On every SELECT we should check if that very SELECT groups or aggregates, and if it does, check that there's no streaming input to it.\nIn the above example, the SELECT on line 1 doesn't aggregate or group, so no check for streaming sources. The SELECT on line 2 does aggregate, so check its inputs: its input is a table, so it's ok.", "author": "viliam-durina", "createdAt": "2020-10-13T12:17:50Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/validate/JetSqlValidator.java", "diffHunk": "@@ -59,27 +62,61 @@ public SqlNode validate(SqlNode topNode) {\n         SqlNode validated = super.validate(topNode);\n \n         if (validated instanceof SqlInsert) {\n-            if (!isCreateJob && isInsertFromStreamingSource((SqlInsert) validated)) {\n+            SqlInsert insert = ((SqlInsert) validated);\n+            if (!isCreateJob && containsStreamingSource(insert.getSource())) {\n                 throw newValidationError(topNode, RESOURCE.mustUseCreateJob());\n             }\n         }\n         return validated;\n     }\n \n+    @Override\n+    protected void validateGroupClause(SqlSelect select) {\n+        super.validateGroupClause(select);\n+\n+        if (containsGroupingOrAggregation(select) && containsStreamingSource(select)) {", "originalCommit": "0ba38c00187a8c1392583eedc59a9d2e7604bbdc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f87f78ac5daceae9f9c405bc043d24f14356b14a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f87f78ac5daceae9f9c405bc043d24f14356b14a", "message": "Fix tests, simplify aggregations", "committedDate": "2020-10-13T12:33:39Z", "type": "commit"}, {"oid": "e3456c7af25a7dfc3bac2b7148221f2c580214fb", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e3456c7af25a7dfc3bac2b7148221f2c580214fb", "message": "Improve JetSqlValidator batch aggregation validation", "committedDate": "2020-10-13T12:45:34Z", "type": "commit"}, {"oid": "5660f2f4555a2bfeade13db09a7134c9a79e7134", "url": "https://github.com/hazelcast/hazelcast-jet/commit/5660f2f4555a2bfeade13db09a7134c9a79e7134", "message": "Format", "committedDate": "2020-10-13T13:05:58Z", "type": "commit"}, {"oid": "9255d1bf3aec84da1ca9c0a321c100ec59d528e4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/9255d1bf3aec84da1ca9c0a321c100ec59d528e4", "message": "Test large and periodic BigDecimal with AVG", "committedDate": "2020-10-13T13:24:15Z", "type": "commit"}, {"oid": "25d9ea084daac49905dafea20d3e05c4af53ec98", "url": "https://github.com/hazelcast/hazelcast-jet/commit/25d9ea084daac49905dafea20d3e05c4af53ec98", "message": "Remove unused code path", "committedDate": "2020-10-13T13:28:03Z", "type": "commit"}, {"oid": "52571babb8f7eeb03149e6e83d00ba1b0f677b3e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/52571babb8f7eeb03149e6e83d00ba1b0f677b3e", "message": "Speed up partitionKeyFn (no unboxing)", "committedDate": "2020-10-13T13:30:08Z", "type": "commit"}, {"oid": "bd8fa77111ddd6f8253c8746b366420be73bb81d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/bd8fa77111ddd6f8253c8746b366420be73bb81d", "message": "Enable DISTINCT", "committedDate": "2020-10-13T13:37:29Z", "type": "commit"}, {"oid": "acd2721723efadef704b198d73c48a382cc1e64a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/acd2721723efadef704b198d73c48a382cc1e64a", "message": "Simplify DISTINCT validation", "committedDate": "2020-10-13T13:54:41Z", "type": "commit"}, {"oid": "6a57345f65ab54373c7e6e1e33c272373c082473", "url": "https://github.com/hazelcast/hazelcast-jet/commit/6a57345f65ab54373c7e6e1e33c272373c082473", "message": "Format", "committedDate": "2020-10-13T13:59:59Z", "type": "commit"}]}