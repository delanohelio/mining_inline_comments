{"pr_number": 2296, "pr_title": "[012] Mqtt Connector Design", "pr_createdAt": "2020-06-03T08:21:04Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2296", "timeline": [{"oid": "95a957489d39115620c5bb331a5d9f953cd80a40", "url": "https://github.com/hazelcast/hazelcast-jet/commit/95a957489d39115620c5bb331a5d9f953cd80a40", "message": "mqtt connector design", "committedDate": "2020-10-26T07:15:53Z", "type": "commit"}, {"oid": "95a957489d39115620c5bb331a5d9f953cd80a40", "url": "https://github.com/hazelcast/hazelcast-jet/commit/95a957489d39115620c5bb331a5d9f953cd80a40", "message": "mqtt connector design", "committedDate": "2020-10-26T07:15:53Z", "type": "forcePushed"}, {"oid": "14ba110b60bfbe2fcefe8a57452f2a80abfbb460", "url": "https://github.com/hazelcast/hazelcast-jet/commit/14ba110b60bfbe2fcefe8a57452f2a80abfbb460", "message": "change tdd id", "committedDate": "2020-10-26T08:00:56Z", "type": "commit"}, {"oid": "a3c64c5844f3d4cfb3e5ecfdccd51dd1de0a8cc8", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a3c64c5844f3d4cfb3e5ecfdccd51dd1de0a8cc8", "message": "add source/sink implementation", "committedDate": "2020-11-03T08:11:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY2MzA2OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2296#discussion_r516663068", "bodyText": "Capital MQTT. In general, I would suggest running this whole thing through Grammarly.", "author": "jbartok", "createdAt": "2020-11-03T13:25:22Z", "path": "site/docs/design-docs/015-mqtt-connector.md", "diffHunk": "@@ -0,0 +1,300 @@\n+---\n+title: 015 - Mqtt Connector\n+description: Mqtt Connector (source and sink)\n+---\n+\n+*Target Release*: 4.3\n+\n+## Background\n+\n+MQTT is a machine-to-machine (M2M)/\u201dInternet of Things\u201d connectivity\n+protocol. It was designed as an extremely lightweight publish/subscribe\n+messaging transport.\n+\n+## MQTT Protocol\n+\n+### Publish\n+\n+MQTT utilizes subject-based(topics) filtering of the messages on the\n+broker. Each message contains a topic name, payload (binary format),\n+QoS (Quality of Service Level), identifier and retain-flag.\n+\n+Topic Name: a simple string that is hierarchically structured with\n+'/' as delimiters. For example, \u201cmyhome/livingroom/temperature\u201d.\n+\n+Payload: the actual content of the message in binary format.\n+\n+QoS: a number indicates the delivery guarantee of the message.\n+\n+- 0, fire and forget\n+- 1, at least once (using acknowledgement)\n+- 2, exactly once (using 2-phase acknowledgement)\n+\n+Identifier: a short number that uniquely identifies the messages\n+between the client and broker. This is relevant only for QoS levels\n+greater than 0. Identifier is not unique between all clients and once\n+the message flow is complete can be re-used.\n+\n+Retain Flag: flag that defines whether the message is saved by the\n+broker as the last known good value for the specified topic. When a new\n+client subscribes to a topic, it receives the last message that is\n+retained on that topic.\n+\n+Publishing means sending a message for a specific topic. The broker\n+reads, acknowledges (according to QoS) and processes the message.\n+Processing means determining the clients subscribed to the specified\n+topic and sending the message to them. The publishing client does not\n+know anything about the processing.\n+\n+### Subscribe\n+\n+To receive messages on topics of interest, the client sends a\n+`SUBSCRIBE` message to the broker. The message contains a list of\n+subscriptions which are made of a topic and a QoS level. The topic can\n+contain wildcards that make it possible to subscribe to a topic pattern\n+rather than a specific topic.\n+\n+The broker sends back a return code indicating the QoS level granted\n+for each of the subscription. Messages published at a lower QoS will be\n+received at the published QoS. Messages published at a higher quality\n+of service will be received using the QoS specified on the subscription.\n+If the broker refuses a subscription, the return code indicates the\n+failure rather than QoS. For example, the client may have insufficient\n+permission to subscribe to the topic, or the topic may be malformed.\n+\n+All messages sent with QoS 1 and 2 are queued for offline clients until\n+the client is available again. However, this queuing is only possible\n+if the client has a persistent session.\n+\n+## MQTT Clients\n+\n+We need to pick a java mqtt client for source and sink to connect to", "originalCommit": "a3c64c5844f3d4cfb3e5ecfdccd51dd1de0a8cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY3MzQzMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2296#discussion_r516673430", "bodyText": "Source is not distributed, but could be, right? Having a single source topic (even if it's a wildcarded one) seems rather limiting, maybe a collection of them would make more sense. And if there are multiple ones, then we could distribute them among multiple source processor instances. I'm not saying we must do this, but it's an option, no?", "author": "jbartok", "createdAt": "2020-11-03T13:41:52Z", "path": "site/docs/design-docs/015-mqtt-connector.md", "diffHunk": "@@ -0,0 +1,300 @@\n+---\n+title: 015 - Mqtt Connector\n+description: Mqtt Connector (source and sink)\n+---\n+\n+*Target Release*: 4.3\n+\n+## Background\n+\n+MQTT is a machine-to-machine (M2M)/\u201dInternet of Things\u201d connectivity\n+protocol. It was designed as an extremely lightweight publish/subscribe\n+messaging transport.\n+\n+## MQTT Protocol\n+\n+### Publish\n+\n+MQTT utilizes subject-based(topics) filtering of the messages on the\n+broker. Each message contains a topic name, payload (binary format),\n+QoS (Quality of Service Level), identifier and retain-flag.\n+\n+Topic Name: a simple string that is hierarchically structured with\n+'/' as delimiters. For example, \u201cmyhome/livingroom/temperature\u201d.\n+\n+Payload: the actual content of the message in binary format.\n+\n+QoS: a number indicates the delivery guarantee of the message.\n+\n+- 0, fire and forget\n+- 1, at least once (using acknowledgement)\n+- 2, exactly once (using 2-phase acknowledgement)\n+\n+Identifier: a short number that uniquely identifies the messages\n+between the client and broker. This is relevant only for QoS levels\n+greater than 0. Identifier is not unique between all clients and once\n+the message flow is complete can be re-used.\n+\n+Retain Flag: flag that defines whether the message is saved by the\n+broker as the last known good value for the specified topic. When a new\n+client subscribes to a topic, it receives the last message that is\n+retained on that topic.\n+\n+Publishing means sending a message for a specific topic. The broker\n+reads, acknowledges (according to QoS) and processes the message.\n+Processing means determining the clients subscribed to the specified\n+topic and sending the message to them. The publishing client does not\n+know anything about the processing.\n+\n+### Subscribe\n+\n+To receive messages on topics of interest, the client sends a\n+`SUBSCRIBE` message to the broker. The message contains a list of\n+subscriptions which are made of a topic and a QoS level. The topic can\n+contain wildcards that make it possible to subscribe to a topic pattern\n+rather than a specific topic.\n+\n+The broker sends back a return code indicating the QoS level granted\n+for each of the subscription. Messages published at a lower QoS will be\n+received at the published QoS. Messages published at a higher quality\n+of service will be received using the QoS specified on the subscription.\n+If the broker refuses a subscription, the return code indicates the\n+failure rather than QoS. For example, the client may have insufficient\n+permission to subscribe to the topic, or the topic may be malformed.\n+\n+All messages sent with QoS 1 and 2 are queued for offline clients until\n+the client is available again. However, this queuing is only possible\n+if the client has a persistent session.\n+\n+## MQTT Clients\n+\n+We need to pick a java mqtt client for source and sink to connect to\n+the broker. There are several options out there:\n+\n+### Paho Java Client\n+\n+The Eclipse Paho project provides open-source client implementations of\n+MQTT protocols for various languages and [Paho Java Client](https://www.eclipse.org/paho/clients/java/)\n+is one of them. The client offers synchronous and asynchronous APIs, the\n+sync one is a wrapper to the asynchronous one. Paho Java Client does\n+not support MQTT 5.0 protocol yet, it is a work in progress.\n+\n+If not configured explicitly, client will try to connect to the broker\n+using MQTT 3.1.1 protocol and if fails to connect falls back to MQTT\n+3.0 protocol.\n+\n+The client supports:\n+\n+- LWT: Last will and testament\n+- SSL/TLS: secure connection\n+- Message persistence: Client persists messages in case of an\n+  application crash\n+- Automatic reconnect: Automatically reconnects\n+- Offline buffering: Client buffers messages whilst offline to send\n+  when reconnects.\n+- WebSocket: Client can connect to brokers that support WebSockets\n+- High Availability: You can configure multiple brokers and in case of\n+  a failure, client tries other brokers.\n+\n+It is really lightweight(240 KB), single jar without any dependencies.\n+We can say that it is one of the most popular clients.\n+\n+### HiveMQ Client\n+\n+HiveMQ Client uses `Netty` for handling networking and `RxJava` for\n+handling the asynchronous streaming of messages. The client provides\n+three distinct flavours of API: blocking, asynchronous and reactive.\n+HiveMQ Client supports MQTT 5.0 protocol as well as 3.1.1.\n+\n+The client supports:\n+\n+- LWT: Last will and testament\n+- SSL/TLS: secure connection\n+- Automatic reconnect: Automatically reconnects\n+- Offline buffering: Client buffers messages whilst offline to send\n+  when reconnects.\n+- WebSocket: Client can connect to brokers that support WebSockets\n+- Backpressure handling: ask the producers to throttle their output\n+  back (MQTT 5.0 feature, broker needs to have/enabled the feature)\n+\n+HiveMQ Client is not lightweight compared to Paho Java client, 1.1 MB.\n+It has also netty and rxjava dependencies.\n+\n+## MQTT Versions\n+\n+- 1999 MQTT invention\n+- 2010 MQTT 3.1 Royalty-free release\n+- 2014 MQTT 3.1.1 OASIS standard\n+- 2016 MQTT 3.1.1 ISO standard\n+- 2018 MQTT 5 Initial release\n+- 2019 MQTT 5 OASIS standard\n+\n+MQTT 5 brings new features like `Shared subscriptions` and `Time to\n+live` for messages and client sessions and many more. While these new\n+features looks promising, I couldn't find any information regarding the\n+adoption rate of MQTT 5. The only java client supports MQTT 5 is\n+`HiveMQ Client` and for other languages I've found only a single\n+library or none at all.\n+\n+## MQTT Connector\n+\n+We choose `Paho Java Client` over `HiveMQ Client` since it is\n+lightweight and without dependencies. `Paho Java Client` does not\n+support MQTT 5, but the adoption rate of MQTT 5 is questionable.\n+\n+### Source\n+\n+We use our `SourceBuilder` to create a streaming source for MQTT\n+messages. Source is not distributed, it creates a client on one of the", "originalCommit": "a3c64c5844f3d4cfb3e5ecfdccd51dd1de0a8cc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY3NjY0Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2296#discussion_r516676643", "bodyText": "Hmmm... I just saw the subscription list in the code. Maybe this document and the code can be made more in sync.", "author": "jbartok", "createdAt": "2020-11-03T13:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY3MzQzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4MjE4Ng==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2296#discussion_r516682186", "bodyText": "Looks strange to me, I still feel like we should go fully distributed.", "author": "jbartok", "createdAt": "2020-11-03T13:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY3MzQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4NTU0NA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2296#discussion_r516685544", "bodyText": "What happens when the sink publishes an item and an MqttException is thrown? There should be specific tests for such failure scenarios.", "author": "jbartok", "createdAt": "2020-11-03T13:59:48Z", "path": "site/docs/design-docs/015-mqtt-connector.md", "diffHunk": "@@ -0,0 +1,300 @@\n+---\n+title: 015 - Mqtt Connector\n+description: Mqtt Connector (source and sink)\n+---\n+\n+*Target Release*: 4.3\n+\n+## Background\n+\n+MQTT is a machine-to-machine (M2M)/\u201dInternet of Things\u201d connectivity\n+protocol. It was designed as an extremely lightweight publish/subscribe\n+messaging transport.\n+\n+## MQTT Protocol\n+\n+### Publish\n+\n+MQTT utilizes subject-based(topics) filtering of the messages on the\n+broker. Each message contains a topic name, payload (binary format),\n+QoS (Quality of Service Level), identifier and retain-flag.\n+\n+Topic Name: a simple string that is hierarchically structured with\n+'/' as delimiters. For example, \u201cmyhome/livingroom/temperature\u201d.\n+\n+Payload: the actual content of the message in binary format.\n+\n+QoS: a number indicates the delivery guarantee of the message.\n+\n+- 0, fire and forget\n+- 1, at least once (using acknowledgement)\n+- 2, exactly once (using 2-phase acknowledgement)\n+\n+Identifier: a short number that uniquely identifies the messages\n+between the client and broker. This is relevant only for QoS levels\n+greater than 0. Identifier is not unique between all clients and once\n+the message flow is complete can be re-used.\n+\n+Retain Flag: flag that defines whether the message is saved by the\n+broker as the last known good value for the specified topic. When a new\n+client subscribes to a topic, it receives the last message that is\n+retained on that topic.\n+\n+Publishing means sending a message for a specific topic. The broker\n+reads, acknowledges (according to QoS) and processes the message.\n+Processing means determining the clients subscribed to the specified\n+topic and sending the message to them. The publishing client does not\n+know anything about the processing.\n+\n+### Subscribe\n+\n+To receive messages on topics of interest, the client sends a\n+`SUBSCRIBE` message to the broker. The message contains a list of\n+subscriptions which are made of a topic and a QoS level. The topic can\n+contain wildcards that make it possible to subscribe to a topic pattern\n+rather than a specific topic.\n+\n+The broker sends back a return code indicating the QoS level granted\n+for each of the subscription. Messages published at a lower QoS will be\n+received at the published QoS. Messages published at a higher quality\n+of service will be received using the QoS specified on the subscription.\n+If the broker refuses a subscription, the return code indicates the\n+failure rather than QoS. For example, the client may have insufficient\n+permission to subscribe to the topic, or the topic may be malformed.\n+\n+All messages sent with QoS 1 and 2 are queued for offline clients until\n+the client is available again. However, this queuing is only possible\n+if the client has a persistent session.\n+\n+## MQTT Clients\n+\n+We need to pick a java mqtt client for source and sink to connect to\n+the broker. There are several options out there:\n+\n+### Paho Java Client\n+\n+The Eclipse Paho project provides open-source client implementations of\n+MQTT protocols for various languages and [Paho Java Client](https://www.eclipse.org/paho/clients/java/)\n+is one of them. The client offers synchronous and asynchronous APIs, the\n+sync one is a wrapper to the asynchronous one. Paho Java Client does\n+not support MQTT 5.0 protocol yet, it is a work in progress.\n+\n+If not configured explicitly, client will try to connect to the broker\n+using MQTT 3.1.1 protocol and if fails to connect falls back to MQTT\n+3.0 protocol.\n+\n+The client supports:\n+\n+- LWT: Last will and testament\n+- SSL/TLS: secure connection\n+- Message persistence: Client persists messages in case of an\n+  application crash\n+- Automatic reconnect: Automatically reconnects\n+- Offline buffering: Client buffers messages whilst offline to send\n+  when reconnects.\n+- WebSocket: Client can connect to brokers that support WebSockets\n+- High Availability: You can configure multiple brokers and in case of\n+  a failure, client tries other brokers.\n+\n+It is really lightweight(240 KB), single jar without any dependencies.\n+We can say that it is one of the most popular clients.\n+\n+### HiveMQ Client\n+\n+HiveMQ Client uses `Netty` for handling networking and `RxJava` for\n+handling the asynchronous streaming of messages. The client provides\n+three distinct flavours of API: blocking, asynchronous and reactive.\n+HiveMQ Client supports MQTT 5.0 protocol as well as 3.1.1.\n+\n+The client supports:\n+\n+- LWT: Last will and testament\n+- SSL/TLS: secure connection\n+- Automatic reconnect: Automatically reconnects\n+- Offline buffering: Client buffers messages whilst offline to send\n+  when reconnects.\n+- WebSocket: Client can connect to brokers that support WebSockets\n+- Backpressure handling: ask the producers to throttle their output\n+  back (MQTT 5.0 feature, broker needs to have/enabled the feature)\n+\n+HiveMQ Client is not lightweight compared to Paho Java client, 1.1 MB.\n+It has also netty and rxjava dependencies.\n+\n+## MQTT Versions\n+\n+- 1999 MQTT invention\n+- 2010 MQTT 3.1 Royalty-free release\n+- 2014 MQTT 3.1.1 OASIS standard\n+- 2016 MQTT 3.1.1 ISO standard\n+- 2018 MQTT 5 Initial release\n+- 2019 MQTT 5 OASIS standard\n+\n+MQTT 5 brings new features like `Shared subscriptions` and `Time to\n+live` for messages and client sessions and many more. While these new\n+features looks promising, I couldn't find any information regarding the\n+adoption rate of MQTT 5. The only java client supports MQTT 5 is\n+`HiveMQ Client` and for other languages I've found only a single\n+library or none at all.\n+\n+## MQTT Connector\n+\n+We choose `Paho Java Client` over `HiveMQ Client` since it is\n+lightweight and without dependencies. `Paho Java Client` does not\n+support MQTT 5, but the adoption rate of MQTT 5 is questionable.\n+\n+### Source\n+\n+We use our `SourceBuilder` to create a streaming source for MQTT\n+messages. Source is not distributed, it creates a client on one of the\n+members and subscribes to the topics.\n+\n+The subscription mechanism is push-based. We set a callback to the\n+client, and it is called as the messages arrived. Since our\n+`SourceBuilder` is designed for pull based systems, we buffer the\n+messages to a blocking queue and drain them in the `fillBufferFn`. We\n+apply the given mapping function to the binary message and keep the\n+mapped item in the queue.\n+\n+#### API\n+\n+Since there are several configuration options for the source, we\n+created a `MqttSourceBuilder` to configure and build the source. We've\n+also introduced a class named `Subscription` which consists of the\n+topic and quality of service for that topic.\n+\n+Below is a usage example of the source builder with all the\n+configuration options:\n+\n+```java\n+MqttSources.builder()\n+        .clientId(\"consumer\")\n+        .broker(\"tcp://localhost:1883\")\n+        .auth(\"username\", \"password\".toCharArray())\n+        .topic(\"topic\")\n+        .qualityOfService(QualityOfService.EXACTLY_ONCE)\n+        .autoReconnect()\n+        .keepSession()\n+        .mapToItemFn((topic, message) -> message.toString())\n+        .build();\n+```\n+\n+You can also subscribe to multiple topics and can provide a\n+`MqttConnectOptions` function instead of configuring the options one by\n+one:\n+\n+```java\n+MqttSources.builder()\n+        .clientId(\"consumer\")\n+        .broker(\"tcp://localhost:1883\")\n+        .subscriptions(Subscription.of(\"topic1\"), Subscription.of(\"topic2\", QualityOfService.EXACTLY_ONCE))\n+        .connectOptionsFn(() -> {\n+            MqttConnectOptions options = new MqttConnectOptions();\n+            options.setCleanSession(false);\n+            options.setAutomaticReconnect(true);\n+            options.setUserName(\"username\");\n+            options.setPassword(\"password\".toCharArray());\n+            options.setMaxInflight(100);\n+            return options;\n+        })\n+        .mapToItemFn((topic, message) -> message.toString())\n+        .build();\n+```\n+\n+#### Fault Tolerance\n+\n+Mqtt protocol defines these quality of services for subscribing the\n+topics: `AT_MOST_ONCE`, `AT_LEAST_ONCE`, `EXACTLY_ONCE`. But I've\n+confirmed loss of message with `EXACTLY_ONCE` configuration even when\n+the client restarted gracefully. I'm not sure if this is an issue of\n+the client or the broker. I'll test the behaviour with HiveMQ client\n+too.\n+\n+If a client subscribes to a topic with quality of service `AT_LEAST_ONCE`\n+or `EXACTLY_ONCE` and connects to the broker with `cleanSession=false`,\n+then the broker keeps the messages in case of a disconnection. Broker\n+serves these buffered messages once the client is re-connected. You\n+need to use a unique identifier for the client.\n+\n+The source itself is not fault tolerant and does not save any state. In\n+case of a restart, source does not know where it left and relies on the\n+broker. If broker keeps a session for the client (above situation),\n+source continues where it left otherwise the source emits messages after\n+the subscription.\n+\n+Paho client has an `autoReconnect` option, in case of a disconnect\n+client tries to reconnect to the broker. After the reconnection, source\n+re-subscribes to the topics.\n+\n+### Sink\n+\n+We use `SinkBuilder` to create a sink for MQTT messages. The sink\n+creates a client for each processor and publishes messages to the\n+specified topic. We append the global processor index to the specified\n+clientId for uniqueness, e.g `producer-1`, `producer-2`...\n+\n+Paho client has a configuration called `maxInflight` which limits the\n+`in-flight` messages with quality of service `AT_LEAST_ONCE` and\n+`EXACTLY_ONCE`. This limitation is per client. Sink uses a semaphore\n+with the permit count of specified `maxInflight` to limit the messages.\n+Sink does not apply this limiting to the messages with quality of\n+service `AT_MOST_ONCE`.\n+\n+#### API\n+\n+Since there are several configuration options for the sink, we created\n+a `MqttSinkBuilder` to configure and build the sink.\n+\n+Below is a usage example of the sink builder with all the configuration\n+options:\n+\n+```java\n+MqttSinks.builder()\n+        .clientId(\"producer\")\n+        .broker(\"tcp://localhost:1883\")\n+        .auth(\"username\", \"password\".toCharArray())\n+        .topic(\"topic\")\n+        .autoReconnect()\n+        .keepSession()\n+        .messageFn(item -> {\n+            MqttMessage message = new MqttMessage(item.getBytes());\n+            message.setQos(2);\n+            return message;\n+        })\n+        .build();\n+```\n+\n+You can also provide a `MqttConnectOptions` function instead of\n+configuring the options one by one:\n+\n+```java\n+MqttSinks.builder()\n+        .clientId(\"producer\")\n+        .broker(\"tcp://localhost:1883\")\n+        .connectOptionsFn(() -> {\n+            MqttConnectOptions options = new MqttConnectOptions();\n+            options.setCleanSession(false);\n+            options.setAutomaticReconnect(true);\n+            options.setUserName(\"username\");\n+            options.setPassword(\"password\".toCharArray());\n+            options.setMaxInflight(100);\n+            return options;\n+        })\n+        .topic(\"topic\")\n+        .messageFn(item -> {\n+            MqttMessage message = new MqttMessage(item.getBytes());\n+            message.setQos(2);\n+            return message;\n+        })\n+        .build();\n+```\n+\n+#### Fault Tolerance\n+\n+The sink is not fault tolerant and does not save any state. In case of\n+a restart, some messages can be duplicated.\n+\n+#### Error handling\n+\n+The sink uses async client to publish the messages. Any error/exception", "originalCommit": "a3c64c5844f3d4cfb3e5ecfdccd51dd1de0a8cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY5MTA4OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2296#discussion_r516691088", "bodyText": "Target release can't be 4.x, because the connector is in the contrib repo. I still think it shouldn't be there. It should be in the main repo, because this should be a professional source/sink (written by us). But we will probably need to take a new look at how we add such extensions, because we are starting to have many of them and they are all in the main distribution jar.", "author": "jbartok", "createdAt": "2020-11-03T14:07:53Z", "path": "site/docs/design-docs/015-mqtt-connector.md", "diffHunk": "@@ -0,0 +1,300 @@\n+---\n+title: 015 - Mqtt Connector\n+description: Mqtt Connector (source and sink)\n+---\n+\n+*Target Release*: 4.3", "originalCommit": "a3c64c5844f3d4cfb3e5ecfdccd51dd1de0a8cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b93e00d38a087395f353eb2eb1385684314e6452", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b93e00d38a087395f353eb2eb1385684314e6452", "message": "grammerly fixes", "committedDate": "2020-11-06T07:04:30Z", "type": "commit"}, {"oid": "7e157e3b86884dabb8596c0488db9d99d92fdcb2", "url": "https://github.com/hazelcast/hazelcast-jet/commit/7e157e3b86884dabb8596c0488db9d99d92fdcb2", "message": "error handling of sink", "committedDate": "2020-11-10T21:49:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE3MjQwMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2296#discussion_r521172400", "bodyText": "I don't like this retry function, because it's a new abstraction for something we already have an abstraction for: com.hazelcast.jet.retry.RetryStrategy. Why not use that?", "author": "jbartok", "createdAt": "2020-11-11T07:43:34Z", "path": "site/docs/design-docs/015-mqtt-connector.md", "diffHunk": "@@ -0,0 +1,305 @@\n+---\n+title: 015 - Mqtt Connector\n+description: Mqtt Connector (source and sink)\n+---\n+\n+## Background\n+\n+MQTT is a machine-to-machine (M2M)/\u201dInternet of Things\u201d connectivity\n+protocol. It was designed as an extremely lightweight publish/subscribe\n+messaging transport.\n+\n+## MQTT Protocol\n+\n+### Publish\n+\n+MQTT utilizes subject-based(topics) filtering of the messages on the\n+broker. Each message contains a topic name, payload (binary format),\n+QoS (Quality of Service Level), identifier and retain-flag.\n+\n+Topic Name: a simple string that is hierarchically structured with\n+'/' as delimiters. For example, \u201cmyhome/livingroom/temperature\u201d.\n+\n+Payload: the actual content of the message in binary format.\n+\n+QoS: a number indicates the delivery guarantee of the message.\n+\n+- 0, fire and forget\n+- 1, at least once (using acknowledgement)\n+- 2, exactly once (using 2-phase acknowledgement)\n+\n+Identifier: a short number that uniquely identifies the messages\n+between the client and broker. This is relevant only for QoS levels\n+greater than 0. The identifier is not unique between all clients.\n+Once the message flow is complete, the client can reuse the identifier.\n+\n+Retain Flag: flag that defines whether the message is saved by the\n+broker as the last known good value for the specified topic. When a new\n+client subscribes to a topic, it receives the last message that is\n+retained on that topic.\n+\n+Publishing means sending a message for a specific topic. The broker\n+reads, acknowledges (according to QoS) and processes the message.\n+Processing means determining the clients subscribed to the specified\n+topic and sending the message to them. The publishing client does not\n+know anything about the processing.\n+\n+### Subscribe\n+\n+To receive messages on topics of interest, the client sends a\n+`SUBSCRIBE` message to the broker. The message contains a list of\n+subscriptions which consists of a topic and a QoS level. The topic can\n+contain wildcards that make it possible to subscribe to a topic pattern\n+rather than a specific topic.\n+\n+The broker sends back a return code indicating the QoS level granted\n+for each of the subscriptions. Messages published at a lower QoS will be\n+received at the published QoS. Messages published at a higher quality\n+of service will be received using the QoS specified on the subscription.\n+If the broker refuses a subscription, the return code indicates the\n+failure rather than QoS. For example, the client may have insufficient\n+permission to subscribe to the topic, or the topic may be malformed.\n+\n+All messages sent with QoS 1 and 2 are queued for offline clients until\n+the client is available again. However, this queuing is only possible\n+if the client has a persistent session.\n+\n+## MQTT Clients\n+\n+We need to pick a java MQTT client for source and sink to connect to\n+the broker. There are several options out there:\n+\n+### Paho Java Client\n+\n+The Eclipse Paho project provides open-source client implementations of\n+MQTT protocols for various languages and [Paho Java Client](https://www.eclipse.org/paho/clients/java/)\n+is one of them. The client offers synchronous and asynchronous APIs.\n+The sync one is a wrapper to the asynchronous one. Paho Java Client\n+does not support MQTT 5.0 protocol yet. It is a work in progress.\n+\n+If not configured explicitly, the client will try to connect to the\n+broker using MQTT 3.1.1 protocol. If it fails to connect, the client\n+falls back to MQTT 3.0 protocol.\n+\n+The client supports:\n+\n+- LWT: Last will and testament\n+- SSL/TLS: secure connection\n+- Message persistence: Client persists messages in case of an\n+  application crash\n+- Automatic reconnect: Automatically reconnects\n+- Offline buffering: Client buffers messages whilst offline to send\n+  when reconnects.\n+- WebSocket: Client can connect to brokers that support WebSockets\n+- High Availability: You can configure multiple brokers and in case of\n+  a failure, the client tries other brokers.\n+\n+It is lightweight(240 KB) and a single jar without any dependencies.\n+We can say that it is one of the most popular clients.\n+\n+### HiveMQ Client\n+\n+HiveMQ Client uses `Netty` for handling networking and `RxJava` for\n+handling the asynchronous streaming of messages. The client provides\n+three distinct flavours of API: blocking, asynchronous and reactive.\n+HiveMQ Client supports MQTT 5.0 protocol as well as 3.1.1.\n+\n+The client supports:\n+\n+- LWT: Last will and testament\n+- SSL/TLS: secure connection\n+- Automatic reconnect: Automatically reconnects\n+- Offline buffering: Client buffers messages whilst offline to send\n+  when reconnects.\n+- WebSocket: Client can connect to brokers that support WebSockets\n+- Backpressure handling: ask the producers to throttle their output\n+  back (MQTT 5.0 feature, broker needs to have/enabled the feature)\n+\n+HiveMQ Client is not lightweight compared to Paho Java client, 1.1 MB.\n+It has also `netty` and `rxjava` dependencies.\n+\n+## MQTT Versions\n+\n+- 1999 MQTT invention\n+- 2010 MQTT 3.1 Royalty-free release\n+- 2014 MQTT 3.1.1 OASIS standard\n+- 2016 MQTT 3.1.1 ISO standard\n+- 2018 MQTT 5 Initial release\n+- 2019 MQTT 5 OASIS standard\n+\n+MQTT 5 brings new features like `Shared subscriptions` and `Time to\n+live` for messages and client sessions and many more. While these new\n+features look promising, I couldn't find any information regarding the\n+adoption rate of MQTT 5. The only java client supports MQTT 5 is\n+`HiveMQ Client` and for other languages, I've found only a single\n+library or none at all.\n+\n+## MQTT Connector\n+\n+We choose `Paho Java Client` over `HiveMQ Client` since it is\n+lightweight and without dependencies. `Paho Java Client` does not\n+support MQTT 5, but the adoption rate of MQTT 5 is questionable.\n+\n+### Source\n+\n+We use our `SourceBuilder` to create a streaming source for MQTT\n+messages. The source is not distributed, it creates a client on one of\n+the members and subscribes to the topics.\n+\n+The subscription mechanism is push-based. We set a callback to the\n+client, and it is called as the messages arrived. Since our\n+`SourceBuilder` is designed for pull-based systems, we buffer the\n+messages to a blocking queue and drain them in the `fillBufferFn`. We\n+apply the given mapping function to the binary message and keep the\n+mapped item in the queue.\n+\n+#### API\n+\n+Since there are several configuration options for the source, we\n+created a `MqttSourceBuilder` to configure and build the source. We've\n+also introduced a class named `Subscription` which consists of the\n+topic and quality of service for that topic.\n+\n+Below is a usage example of the source builder with all the\n+configuration options:\n+\n+```java\n+MqttSources.builder()\n+        .clientId(\"consumer\")\n+        .broker(\"tcp://localhost:1883\")\n+        .auth(\"username\", \"password\".toCharArray())\n+        .topic(\"topic\")\n+        .qualityOfService(QualityOfService.EXACTLY_ONCE)\n+        .autoReconnect()\n+        .keepSession()\n+        .mapToItemFn((topic, message) -> message.toString())\n+        .build();\n+```\n+\n+You can also subscribe to multiple topics and can provide a\n+`MqttConnectOptions` function instead of configuring the options one by\n+one:\n+\n+```java\n+MqttSources.builder()\n+        .clientId(\"consumer\")\n+        .broker(\"tcp://localhost:1883\")\n+        .subscriptions(Subscription.of(\"topic1\"), Subscription.of(\"topic2\", QualityOfService.EXACTLY_ONCE))\n+        .connectOptionsFn(() -> {\n+            MqttConnectOptions options = new MqttConnectOptions();\n+            options.setCleanSession(false);\n+            options.setAutomaticReconnect(true);\n+            options.setUserName(\"username\");\n+            options.setPassword(\"password\".toCharArray());\n+            options.setMaxInflight(100);\n+            return options;\n+        })\n+        .mapToItemFn((topic, message) -> message.toString())\n+        .build();\n+```\n+\n+#### Fault Tolerance\n+\n+MQTT protocol defines these quality-of-services for subscribing the\n+topics: `AT_MOST_ONCE`, `AT_LEAST_ONCE`, `EXACTLY_ONCE`. But I've\n+confirmed a loss of message with `EXACTLY_ONCE` configuration even when\n+the client restarted gracefully. I'm not sure if this is an issue of\n+the client or the broker. I'll test the behaviour with HiveMQ client\n+too.\n+\n+If a client subscribes to a topic with quality of service `AT_LEAST_ONCE`\n+or `EXACTLY_ONCE` and connects to the broker with `cleanSession=false`,\n+then the broker keeps the messages in case of a disconnection. The broker\n+serves these buffered messages once the client is re-connected. You\n+need to use a unique identifier for the client.\n+\n+The source itself is not fault-tolerant and does not save any state. In\n+case of a restart, the source does not know where it left and relies on\n+the broker. If the broker keeps a session for the client (above\n+situation), the source continues where it left otherwise the source\n+emits messages after the subscription.\n+\n+Paho client has an `autoReconnect` option, in case of a disconnect, the\n+client tries to reconnect to the broker. After the reconnection, source\n+re-subscribes to the topics.\n+\n+### Sink\n+\n+We use `SinkBuilder` to create a sink for MQTT messages. The sink\n+creates a client for each processor and publishes messages to the\n+specified topic. We append the global processor index to the specified\n+clientId for uniqueness, e.g `producer-1`, `producer-2`...\n+\n+#### API\n+\n+Since there are several configuration options for the sink, we created\n+a `MqttSinkBuilder` to configure and build the sink.\n+\n+Below is a usage example of the sink builder with all the configuration\n+options:\n+\n+```java\n+MqttSinks.builder()\n+        .clientId(\"producer\")\n+        .broker(\"tcp://localhost:1883\")\n+        .auth(\"username\", \"password\".toCharArray())\n+        .topic(\"topic\")\n+        .autoReconnect()\n+        .keepSession()\n+        .retryCount(5)\n+        .messageFn(item -> {\n+            MqttMessage message = new MqttMessage(item.getBytes());\n+            message.setQos(2);\n+            return message;\n+        })\n+        .build();\n+```\n+\n+You can provide a `MqttConnectOptions` function instead of configuring\n+the options one by one.\n+\n+```java\n+MqttSinks.builder()\n+        .clientId(\"producer\")\n+        .broker(\"tcp://localhost:1883\")\n+        .connectOptionsFn(() -> {\n+            MqttConnectOptions options = new MqttConnectOptions();\n+            options.setCleanSession(false);\n+            options.setAutomaticReconnect(true);\n+            options.setUserName(\"username\");\n+            options.setPassword(\"password\".toCharArray());\n+            options.setMaxInflight(100);\n+            return options;\n+        })\n+        .retryFn((exception, tryCount) -> {\n+            if(tryCount > 5) {\n+                return 0;\n+            }\n+            if(exception.getReasonCode() != MqttException.REASON_CODE_BROKER_UNAVAILABLE) {\n+                return 0;\n+            }\n+            return 200;\n+        })\n+        .topic(\"topic\")\n+        .messageFn(item -> {\n+            MqttMessage message = new MqttMessage(item.getBytes());\n+            message.setQos(2);\n+            return message;\n+        })\n+        .build();\n+```\n+\n+#### Fault Tolerance\n+\n+The sink is not fault-tolerant and does not save any state. In case of\n+a restart, some messages can be duplicated.\n+\n+#### Error handling\n+\n+The sink uses sync client to publish the messages. Any error/exception\n+encountered while publishing the messages will fail the job. User can\n+configure the retrying of the messages by providing a retry function.", "originalCommit": "7e157e3b86884dabb8596c0488db9d99d92fdcb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "981b54b97b22c514739de46396e9ca504c761ea3", "url": "https://github.com/hazelcast/hazelcast-jet/commit/981b54b97b22c514739de46396e9ca504c761ea3", "message": "update retry-strategy", "committedDate": "2020-11-23T07:16:35Z", "type": "commit"}]}