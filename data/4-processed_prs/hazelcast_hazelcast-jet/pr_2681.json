{"pr_number": 2681, "pr_title": "Infer Kafka (de)serializers", "pr_createdAt": "2020-11-18T15:19:06Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2681", "timeline": [{"oid": "d691ebc953fd29018e96a9e8853fc07aa32c6021", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d691ebc953fd29018e96a9e8853fc07aa32c6021", "message": "Infer Kafka (de)serializers", "committedDate": "2020-11-18T15:17:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4NzA3MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2681#discussion_r526187070", "bodyText": "I think we can use switch (format). Since java 7 it works for strings.", "author": "viliam-durina", "createdAt": "2020-11-18T15:40:32Z", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/kafka/PropertiesResolver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.connector.kafka;\n+\n+import com.hazelcast.jet.sql.impl.connector.SqlConnector;\n+import org.apache.kafka.common.serialization.ByteArrayDeserializer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.DoubleDeserializer;\n+import org.apache.kafka.common.serialization.DoubleSerializer;\n+import org.apache.kafka.common.serialization.FloatDeserializer;\n+import org.apache.kafka.common.serialization.FloatSerializer;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.LongDeserializer;\n+import org.apache.kafka.common.serialization.LongSerializer;\n+import org.apache.kafka.common.serialization.ShortDeserializer;\n+import org.apache.kafka.common.serialization.ShortSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import static com.hazelcast.jet.sql.impl.connector.SqlConnector.AVRO_FORMAT;\n+import static com.hazelcast.jet.sql.impl.connector.SqlConnector.JAVA_FORMAT;\n+import static com.hazelcast.jet.sql.impl.connector.SqlConnector.JSON_FORMAT;\n+import static com.hazelcast.jet.sql.impl.connector.SqlConnector.OPTION_KEY_FORMAT;\n+import static com.hazelcast.jet.sql.impl.connector.SqlConnector.OPTION_VALUE_FORMAT;\n+\n+final class PropertiesResolver {\n+\n+    static final String KEY_SERIALIZER = \"key.serializer\";\n+    static final String KEY_DESERIALIZER = \"key.deserializer\";\n+    static final String VALUE_SERIALIZER = \"value.serializer\";\n+    static final String VALUE_DESERIALIZER = \"value.deserializer\";\n+\n+    static final String AVRO_SERIALIZER = \"io.confluent.kafka.serializers.KafkaAvroSerializer\";\n+    static final String AVRO_DESERIALIZER = \"io.confluent.kafka.serializers.KafkaAvroDeserializer\";\n+\n+    static final String JSON_SERIALIZER = ByteArraySerializer.class.getCanonicalName();\n+    static final String JSON_DESERIALIZER = ByteArrayDeserializer.class.getCanonicalName();\n+\n+    private PropertiesResolver() {\n+    }\n+\n+    static Properties resolveProperties(Map<String, String> options) {\n+        Properties properties = new Properties();\n+        properties.putAll(options);\n+\n+        properties(options, true).forEach(properties::putIfAbsent);\n+        properties(options, false).forEach(properties::putIfAbsent);\n+\n+        return properties;\n+    }\n+\n+    private static Map<String, String> properties(Map<String, String> options, boolean isKey) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        String serializer = isKey ? KEY_SERIALIZER : VALUE_SERIALIZER;\n+        String deserializer = isKey ? KEY_DESERIALIZER : VALUE_DESERIALIZER;\n+\n+        String format = options.get(isKey ? OPTION_KEY_FORMAT : OPTION_VALUE_FORMAT);\n+        if (JAVA_FORMAT.equals(format)) {", "originalCommit": "d691ebc953fd29018e96a9e8853fc07aa32c6021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NDQ0OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2681#discussion_r526194448", "bodyText": "I would like to tolerate nulls", "author": "gierlachg", "createdAt": "2020-11-18T15:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4NzA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4ODEzNQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2681#discussion_r526188135", "bodyText": "This test would actually pass even if the option got replaced, because we use the default value. We can use some missing class and check that it fails not finding it.\nAgain in SqlJsonTest", "author": "viliam-durina", "createdAt": "2020-11-18T15:41:50Z", "path": "hazelcast-jet-sql/src/test/java/com/hazelcast/jet/sql/impl/connector/kafka/SqlAvroTest.java", "diffHunk": "@@ -407,6 +379,40 @@ public void test_topLevelFieldExtraction() {\n         );\n     }\n \n+    @Test\n+    public void test_explicitKeyAndValueSerializers() {\n+        String name = createRandomTopic();\n+        sqlService.execute(\"CREATE MAPPING \" + name + \" (\"\n+                + \"key_name VARCHAR EXTERNAL NAME \\\"__key.name\\\"\"\n+                + \", value_name VARCHAR EXTERNAL NAME \\\"this.name\\\"\"\n+                + \") TYPE \" + KafkaSqlConnector.TYPE_NAME + ' '\n+                + \"OPTIONS ( \"\n+                + '\"' + OPTION_KEY_FORMAT + \"\\\" '\" + AVRO_FORMAT + '\\''\n+                + \", \\\"\" + OPTION_VALUE_FORMAT + \"\\\" '\" + AVRO_FORMAT + '\\''\n+                + \", \\\"key.serializer\\\" '\" + KafkaAvroSerializer.class.getCanonicalName() + '\\''", "originalCommit": "d691ebc953fd29018e96a9e8853fc07aa32c6021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMTI3Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2681#discussion_r526201273", "bodyText": "I'm checking that existing options are not replaced in PropertiesResolverTest", "author": "gierlachg", "createdAt": "2020-11-18T15:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4ODEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4OTY0Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2681#discussion_r526189647", "bodyText": "Can't we remove these two lines?", "author": "viliam-durina", "createdAt": "2020-11-18T15:43:40Z", "path": "hazelcast-jet-sql/src/test/java/com/hazelcast/jet/sql/impl/connector/kafka/SqlPrimitiveTest.java", "diffHunk": "@@ -326,38 +294,67 @@ public void test_explicitKeyAndThis() {\n     }\n \n     @Test\n-    public void test_noValueFormat() {\n-        String topicName = randomName();\n-        assertThatThrownBy(\n-                () -> sqlService.execute(\"CREATE MAPPING \" + topicName + \" TYPE \" + KafkaSqlConnector.TYPE_NAME + \" \"\n-                        + \"OPTIONS (\"\n-                        + '\"' + OPTION_KEY_FORMAT + \"\\\" '\" + JAVA_FORMAT + \"',\"\n-                        + '\"' + OPTION_KEY_CLASS + \"\\\" '\" + String.class.getName() + \"'\"\n-                        + \")\"))\n-                .hasMessage(\"Missing 'valueFormat' option\");\n+    public void test_explicitKeyAndValueSerializers() {\n+        String name = createRandomTopic();\n+        sqlService.execute(\"CREATE MAPPING \" + name + ' '\n+                + \"TYPE \" + KafkaSqlConnector.TYPE_NAME + ' '\n+                + \"OPTIONS ( \"\n+                + '\"' + OPTION_KEY_FORMAT + \"\\\" '\" + JAVA_FORMAT + '\\''\n+                + \", \\\"\" + OPTION_KEY_CLASS + \"\\\" '\" + Integer.class.getName() + '\\''\n+                + \", \\\"\" + OPTION_VALUE_FORMAT + \"\\\" '\" + JAVA_FORMAT + '\\''\n+                + \", \\\"\" + OPTION_VALUE_CLASS + \"\\\" '\" + String.class.getName() + '\\''\n+                + \", \\\"key.serializer\\\" '\" + IntegerSerializer.class.getCanonicalName() + '\\''\n+                + \", \\\"key.deserializer\\\" '\" + IntegerDeserializer.class.getCanonicalName() + '\\''\n+                + \", \\\"value.serializer\\\" '\" + StringSerializer.class.getCanonicalName() + '\\''\n+                + \", \\\"value.deserializer\\\" '\" + StringDeserializer.class.getCanonicalName() + '\\''\n+                + \", \\\"bootstrap.servers\\\" '\" + kafkaTestSupport.getBrokerConnectionString() + '\\''\n+                + \", \\\"auto.offset.reset\\\" 'earliest'\"\n+                + \")\"\n+        );\n+\n+        assertTopicEventually(\n+                name,\n+                \"INSERT INTO \" + name + \" (__key, this) VALUES (1, '2')\",\n+                createMap(1, \"2\")\n+        );\n+        assertRowsEventuallyInAnyOrder(\n+                \"SELECT * FROM \" + name,\n+                singletonList(new Row(1, \"2\"))\n+        );\n     }\n \n     @Test\n     public void test_noKeyFormat() {\n         String topicName = createRandomTopic();\n         sqlService.execute(\"CREATE MAPPING \" + topicName + ' '\n-                + \"TYPE \" + KafkaSqlConnector.TYPE_NAME + ' '\n-                + \"OPTIONS (\"\n-                + '\"' + OPTION_VALUE_FORMAT + \"\\\" '\" + JAVA_FORMAT + \"',\"\n-                + '\"' + OPTION_VALUE_CLASS + \"\\\" '\" + Integer.class.getName() + \"'\"\n-                + \", \\\"bootstrap.servers\\\" '\" + kafkaTestSupport.getBrokerConnectionString() + '\\''\n-                + \", \\\"key.serializer\\\" '\" + IntegerSerializer.class.getCanonicalName() + '\\''\n-                + \", \\\"key.deserializer\\\" '\" + IntegerDeserializer.class.getCanonicalName() + '\\''\n-                + \", \\\"value.serializer\\\" '\" + IntegerSerializer.class.getCanonicalName() + '\\''\n-                + \", \\\"value.deserializer\\\" '\" + IntegerDeserializer.class.getCanonicalName() + '\\''\n-                + \", \\\"auto.offset.reset\\\" 'earliest'\"\n-                + \")\");\n+                           + \"TYPE \" + KafkaSqlConnector.TYPE_NAME + ' '\n+                           + \"OPTIONS (\"\n+                           + '\"' + OPTION_VALUE_FORMAT + \"\\\" '\" + JAVA_FORMAT + \"',\"\n+                           + '\"' + OPTION_VALUE_CLASS + \"\\\" '\" + Integer.class.getName() + \"'\"\n+                           + \", \\\"key.serializer\\\" '\" + IntegerSerializer.class.getCanonicalName() + '\\''\n+                           + \", \\\"key.deserializer\\\" '\" + IntegerDeserializer.class.getCanonicalName() + '\\''", "originalCommit": "d691ebc953fd29018e96a9e8853fc07aa32c6021", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5ODM0NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2681#discussion_r526198345", "bodyText": "serializer options are required, without format we are unable to infer it", "author": "gierlachg", "createdAt": "2020-11-18T15:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4OTY0Nw=="}], "type": "inlineReview"}, {"oid": "a32642322df805734fb9abb4d14730943e153009", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a32642322df805734fb9abb4d14730943e153009", "message": "More tests", "committedDate": "2020-11-18T15:48:19Z", "type": "commit"}]}