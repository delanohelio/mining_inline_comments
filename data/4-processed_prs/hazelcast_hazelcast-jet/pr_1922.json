{"pr_number": 1922, "pr_title": "Add refman for transactional sources", "pr_createdAt": "2020-01-31T22:50:57Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/1922", "timeline": [{"oid": "3f37142c86b88b26ce7e3c604dbf91e5f21cbc94", "url": "https://github.com/hazelcast/hazelcast-jet/commit/3f37142c86b88b26ce7e3c604dbf91e5f21cbc94", "message": "Add refman for transactional sources", "committedDate": "2020-01-31T22:50:13Z", "type": "commit"}, {"oid": "b8724ae7d11b4da758083053c72c48f7357e99d2", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b8724ae7d11b4da758083053c72c48f7357e99d2", "message": "Document individual connectors", "committedDate": "2020-02-04T10:41:46Z", "type": "commit"}, {"oid": "756dc6c22380ddd2decf704688bc715c91f3f56a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/756dc6c22380ddd2decf704688bc715c91f3f56a", "message": "Merge branch 'master' into 2pc-refman", "committedDate": "2020-02-04T10:42:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1MjkwNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375152906", "bodyText": "Could you rewrite this to use the active voice?", "author": "mtopolnik", "createdAt": "2020-02-05T09:48:03Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/Sinks.java", "diffHunk": "@@ -798,12 +798,12 @@ private Sinks() {\n      * <h3>Fault tolerance</h3>\n      * If the job is running in <i>exactly-once</i> mode, items will be written\n      * to temporary files (ending with a {@value\n-     * FileSinkBuilder#TEMP_FILE_SUFFIX} suffix). When the snapshot is", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1MzUyNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375153526", "bodyText": "Same here (active voice)", "author": "mtopolnik", "createdAt": "2020-02-05T09:49:13Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/file-socket.adoc", "diffHunk": "@@ -56,6 +63,15 @@ member will write to different file names. You can achieve the effect of\n a distributed sink if you manually collect all the output files on all\n members and combine their contents.\n \n+If the job is running in exactly-once mode, items will be written to", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1MzcyNw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375153727", "bodyText": "a -> are", "author": "mtopolnik", "createdAt": "2020-02-05T09:49:37Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/kafka.adoc", "diffHunk": "@@ -42,17 +36,22 @@ The Kafka source supports snapshots. Upon each snapshot it saves the\n current offset for each partition. When the job is restarted from a\n snapshot, the source can continue reading from the saved offset.\n \n-If snapshots are disabled, the source will commit the offset of the\n+If snapshots are disabled, the source will commit the offsets of the\n last record it read to the Kafka cluster. Since the fact that the source\n read an item doesn't mean that the whole Jet pipeline processed it, this\n-doesn't guarantee against data loss.\n+prevents neither data loss nor duplicate processing.\n \n == Using Kafka as a Sink\n \n-The Kafka sink creates one `KafkaProducer` per cluster member and shares\n-it among all the sink processors on that member. You can provide a\n-mapping function that transforms the items the sink receives into\n-`ProducerRecord`s.\n+The sink provides exactly-once guarantee at the cost of using Kafka\n+transactions: Jet commits the produced records after each snapshot is\n+completed. This greatly increases the latency because consumers see the\n+records only after they are committed.\n+\n+If you use _at-least-once_ guarantee, records a visible immediately, but", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1Mzg4Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375153887", "bodyText": "the exactly-once guarantee", "author": "mtopolnik", "createdAt": "2020-02-05T09:49:52Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/kafka.adoc", "diffHunk": "@@ -42,17 +36,22 @@ The Kafka source supports snapshots. Upon each snapshot it saves the\n current offset for each partition. When the job is restarted from a\n snapshot, the source can continue reading from the saved offset.\n \n-If snapshots are disabled, the source will commit the offset of the\n+If snapshots are disabled, the source will commit the offsets of the\n last record it read to the Kafka cluster. Since the fact that the source\n read an item doesn't mean that the whole Jet pipeline processed it, this\n-doesn't guarantee against data loss.\n+prevents neither data loss nor duplicate processing.\n \n == Using Kafka as a Sink\n \n-The Kafka sink creates one `KafkaProducer` per cluster member and shares\n-it among all the sink processors on that member. You can provide a\n-mapping function that transforms the items the sink receives into\n-`ProducerRecord`s.\n+The sink provides exactly-once guarantee at the cost of using Kafka", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1NDc4Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375154783", "bodyText": "the Kafka sink", "author": "mtopolnik", "createdAt": "2020-02-05T09:51:33Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/overview.adoc", "diffHunk": "@@ -24,45 +24,66 @@ Journal feature). You can also set up an `IMap`/`ICache` as a sink for\n an infinite amount of data, either by ensuring that the size of the\n keyset will be finite or by allowing the eviction of old entries.\n \n-== Is it Replayable?\n+== Is it Fault-Tolerant?\n \n-Most finite data sources are replayable because they come from\n-persistent storage. You can easily replay the whole dataset. However, an\n-infinite data source may be of such nature that it can be consumed only\n-once. An example is the TCP socket connector. Such sources are bad at\n-fault tolerance: if anything goes wrong during the computation, it\n-cannot be retried.\n+Can the connector work in a way that even in case of a job failure and\n+restart it doesn't miss or duplicate any items it reads or creates? There are\n+multiple ways this can be achieved:\n \n-== Does it Support Checkpointing?\n+=== Replayable Source\n \n-You cannot retry to process an infinite data stream from the very\n-beginning. You must save the complete state at regular intervals, then\n-replay the input stream from the last saved position (_checkpoint_).\n-Jet can create snapshots of its internal processing state, but for this\n-to be useful the data source must have the ability to replay its data\n-from the chosen point, discarding everything before it. Both Kafka and\n-the Hazelcast Event Journal support this.\n+If a source has a notion of item offset and a reader can seek to an\n+offset and read the exactly same data from it multiple times, we say\n+it's replayable. For finite sources it's feasible to restart from offset\n+0, such as re-read a file. However, an infinite data source may be of\n+such nature that it can be consumed only once. An example is the TCP\n+socket connector. Such sources are not fault-tolerant: if anything goes\n+wrong during the computation, it cannot be retried. Examples of\n+unbounded replayable sources are Hazelcast Event Journal or Kafka.\n+\n+=== Consumption Acknowledgements\n+\n+If a consumer has to acknowledge each processed message and\n+non-acknowledged messages are redelivered, it's possible to create a\n+fault-tolerant source. An example of this is the JMS source.\n+\n+=== XA Transactions\n+\n+Two-phase transactions are another way to achieve fault-tolerance. Jet\n+can use the standard X/Open XA Transactions or equivalent API. An\n+example is Kafka sink. JMS and JDBC are planned for the next release.", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1NTkzNQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375155935", "bodyText": "one Jet member", "author": "mtopolnik", "createdAt": "2020-02-05T09:53:38Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/overview.adoc", "diffHunk": "@@ -24,45 +24,66 @@ Journal feature). You can also set up an `IMap`/`ICache` as a sink for\n an infinite amount of data, either by ensuring that the size of the\n keyset will be finite or by allowing the eviction of old entries.\n \n-== Is it Replayable?\n+== Is it Fault-Tolerant?\n \n-Most finite data sources are replayable because they come from\n-persistent storage. You can easily replay the whole dataset. However, an\n-infinite data source may be of such nature that it can be consumed only\n-once. An example is the TCP socket connector. Such sources are bad at\n-fault tolerance: if anything goes wrong during the computation, it\n-cannot be retried.\n+Can the connector work in a way that even in case of a job failure and\n+restart it doesn't miss or duplicate any items it reads or creates? There are\n+multiple ways this can be achieved:\n \n-== Does it Support Checkpointing?\n+=== Replayable Source\n \n-You cannot retry to process an infinite data stream from the very\n-beginning. You must save the complete state at regular intervals, then\n-replay the input stream from the last saved position (_checkpoint_).\n-Jet can create snapshots of its internal processing state, but for this\n-to be useful the data source must have the ability to replay its data\n-from the chosen point, discarding everything before it. Both Kafka and\n-the Hazelcast Event Journal support this.\n+If a source has a notion of item offset and a reader can seek to an\n+offset and read the exactly same data from it multiple times, we say\n+it's replayable. For finite sources it's feasible to restart from offset\n+0, such as re-read a file. However, an infinite data source may be of\n+such nature that it can be consumed only once. An example is the TCP\n+socket connector. Such sources are not fault-tolerant: if anything goes\n+wrong during the computation, it cannot be retried. Examples of\n+unbounded replayable sources are Hazelcast Event Journal or Kafka.\n+\n+=== Consumption Acknowledgements\n+\n+If a consumer has to acknowledge each processed message and\n+non-acknowledged messages are redelivered, it's possible to create a\n+fault-tolerant source. An example of this is the JMS source.\n+\n+=== XA Transactions\n+\n+Two-phase transactions are another way to achieve fault-tolerance. Jet\n+can use the standard X/Open XA Transactions or equivalent API. An\n+example is Kafka sink. JMS and JDBC are planned for the next release.\n+\n+=== Idempotent writes\n+\n+An operation is idempotent if, even if executed multiple times, the end\n+result is the same as if executed just once. If a sink is idempotent and\n+the job restarts and repeat some writes, the duplicate writes will have\n+no effect. An example is an IMap sink, but only in case the keys are\n+unique and deterministic.\n \n == Is it Distributed?\n \n+A source is distributed if it can be read by multiple readers and each\n+will get a part of the data. We don't discuss sinks here as practically\n+all targets can be written to by multiple writers. It also doesn't\n+matter whether the resource actually stores data in multiple nodes.\n+\n A distributed computation engine prefers to work with distributed data\n-resources. If the resource is not distributed, all Jet members will have\n-to contend for access to a single endpoint. Kafka, HDFS, `IMap` and\n-`ICache` are all distributed. On the other hand, an `IList` is not: it\n-resides on a single member. When used as a source, only one Jet member\n-pulls its data. When used as a sink, all Jet members send their data\n-to the one that holds it.\n+resources. If the resource is not distributed, one Jet members has to do", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1NzQ3MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375157470", "bodyText": "StackOverflowError also has unrestricted scope because the exception can happen in the middle of updating a shared structure. It's basically the same damage potential as OutOfMemoryError.", "author": "mtopolnik", "createdAt": "2020-02-05T09:56:28Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/overview.adoc", "diffHunk": "@@ -78,10 +99,9 @@ choices: have Jet connect to a Hazelcast IMDG cluster, or use Jet itself\n to host the data (since a Jet cluster is at the same time a Hazelcast\n IMDG cluster). In the second case Jet will automatically ensure a\n data-local access pattern, but there's a caveat: if the Jet job causes\n-an error of unrestricted scope, such as `OutOfMemoryError` or\n-`StackOverflowError`, it will have unpredictable consequences for the\n-state of the whole Jet member, jeopardizing the integrity of the data\n-stored on it.\n+an error of unrestricted scope, such as `OutOfMemoryError`, it will have", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1OTIwMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375159203", "bodyText": "with the exactly-once guarantee", "author": "mtopolnik", "createdAt": "2020-02-05T09:59:39Z", "path": "reference-manual/src/main/asciidoc/work-with-jet/configure-fault-tolerance.adoc", "diffHunk": "@@ -6,29 +6,31 @@ correctly in the face of Jet members failing and leaving the cluster.\n \n Jet takes snapshots of the entire state of the computation at regular\n intervals. It coordinates the snapshot across the cluster and\n-synchronizes it with a checkpoint on the data source. The source must\n-ensure that, in the case of a restart, it will be able to replay all the\n-data it emitted after the last checkpoint. Each of the other components\n-in the job will restore its processing state to exactly what it was at\n-the time of the last snapshot. If a cluster member goes away, Jet will\n-restart the job on the remaining members, rewind the sources to the\n-last checkpoint, restore the state of processing from the last\n-snapshot, and then seamlessly continue from that point.\n+synchronizes it with connectors with fault-tolerance support. The source\n+must ensure that, in the case of a restart, it will be able to replay\n+all the data it emitted after the last checkpoint. Each of the other\n+components in the job will restore their processing state to exactly\n+what it was at the time of the last snapshot. If a cluster member goes\n+away, Jet will restart the job on the remaining members, restore the\n+state of processing from the last snapshot, and then seamlessly continue\n+from that point.\n \n == Exactly-Once\n \n \"Exactly-once processing\" means the output is consistent with processing\n each stream item exactly once. This is the ultimate guarantee you can\n ask for.\n \n-As of version 0.6, Hazelcast Jet supports exactly-once processing with\n-the source being either a Hazelcast `IMap` journal or a Kafka topic,\n-and the sink being a Hazelcast `IMap`.\n+Hazelcast Jet supports exactly-once processing with multiple sources and\n+sinks. Each of them specifies the guarantees it is able to provide, for\n+details see the summary in <<overview-of-sources-and-sinks>>.\n \n-If you configure Jet for exactly-once but use Kafka as the sink, after a\n-job restart you may get duplicates in the output. As opposed to doubly\n-processing an input item, this is more benign because it just means\n-getting the exact same result twice.\n+If you configure Jet job for exactly-once but use a sink with", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1OTM2OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375159369", "bodyText": "same", "author": "mtopolnik", "createdAt": "2020-02-05T09:59:59Z", "path": "reference-manual/src/main/asciidoc/work-with-jet/configure-fault-tolerance.adoc", "diffHunk": "@@ -6,29 +6,31 @@ correctly in the face of Jet members failing and leaving the cluster.\n \n Jet takes snapshots of the entire state of the computation at regular\n intervals. It coordinates the snapshot across the cluster and\n-synchronizes it with a checkpoint on the data source. The source must\n-ensure that, in the case of a restart, it will be able to replay all the\n-data it emitted after the last checkpoint. Each of the other components\n-in the job will restore its processing state to exactly what it was at\n-the time of the last snapshot. If a cluster member goes away, Jet will\n-restart the job on the remaining members, rewind the sources to the\n-last checkpoint, restore the state of processing from the last\n-snapshot, and then seamlessly continue from that point.\n+synchronizes it with connectors with fault-tolerance support. The source\n+must ensure that, in the case of a restart, it will be able to replay\n+all the data it emitted after the last checkpoint. Each of the other\n+components in the job will restore their processing state to exactly\n+what it was at the time of the last snapshot. If a cluster member goes\n+away, Jet will restart the job on the remaining members, restore the\n+state of processing from the last snapshot, and then seamlessly continue\n+from that point.\n \n == Exactly-Once\n \n \"Exactly-once processing\" means the output is consistent with processing\n each stream item exactly once. This is the ultimate guarantee you can\n ask for.\n \n-As of version 0.6, Hazelcast Jet supports exactly-once processing with\n-the source being either a Hazelcast `IMap` journal or a Kafka topic,\n-and the sink being a Hazelcast `IMap`.\n+Hazelcast Jet supports exactly-once processing with multiple sources and\n+sinks. Each of them specifies the guarantees it is able to provide, for\n+details see the summary in <<overview-of-sources-and-sinks>>.\n \n-If you configure Jet for exactly-once but use Kafka as the sink, after a\n-job restart you may get duplicates in the output. As opposed to doubly\n-processing an input item, this is more benign because it just means\n-getting the exact same result twice.\n+If you configure Jet job for exactly-once but use a sink with\n+at-least-once guarantee, after a job restart you may get duplicates in\n+the output. As opposed to doubly processing an input item, this is more\n+benign because it just means getting the exact same result twice. If you\n+use a source with at-least-once guarantee, some events might be", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1OTU1MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375159550", "bodyText": "in the case", "author": "mtopolnik", "createdAt": "2020-02-05T10:00:19Z", "path": "reference-manual/src/main/asciidoc/work-with-jet/configure-fault-tolerance.adoc", "diffHunk": "@@ -42,6 +44,11 @@ In some other cases, however, duplicate processing of data items can\n have quite surprising consequences. There is more information about this\n in our <<pitfalls-alo, Jet Concepts>> chapter.\n \n+Also note that duplicate event processing can occur only in case of a", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1OTc2OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375159768", "bodyText": "in the case", "author": "mtopolnik", "createdAt": "2020-02-05T10:00:45Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/kafka.adoc", "diffHunk": "@@ -42,17 +36,22 @@ The Kafka source supports snapshots. Upon each snapshot it saves the\n current offset for each partition. When the job is restarted from a\n snapshot, the source can continue reading from the saved offset.\n \n-If snapshots are disabled, the source will commit the offset of the\n+If snapshots are disabled, the source will commit the offsets of the\n last record it read to the Kafka cluster. Since the fact that the source\n read an item doesn't mean that the whole Jet pipeline processed it, this\n-doesn't guarantee against data loss.\n+prevents neither data loss nor duplicate processing.\n \n == Using Kafka as a Sink\n \n-The Kafka sink creates one `KafkaProducer` per cluster member and shares\n-it among all the sink processors on that member. You can provide a\n-mapping function that transforms the items the sink receives into\n-`ProducerRecord`s.\n+The sink provides exactly-once guarantee at the cost of using Kafka\n+transactions: Jet commits the produced records after each snapshot is\n+completed. This greatly increases the latency because consumers see the\n+records only after they are committed.\n+\n+If you use _at-least-once_ guarantee, records a visible immediately, but\n+in case of a failure some records could be produced duplicately. You can", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1OTgyMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375159822", "bodyText": "in the case", "author": "mtopolnik", "createdAt": "2020-02-05T10:00:52Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/overview.adoc", "diffHunk": "@@ -24,45 +24,66 @@ Journal feature). You can also set up an `IMap`/`ICache` as a sink for\n an infinite amount of data, either by ensuring that the size of the\n keyset will be finite or by allowing the eviction of old entries.\n \n-== Is it Replayable?\n+== Is it Fault-Tolerant?\n \n-Most finite data sources are replayable because they come from\n-persistent storage. You can easily replay the whole dataset. However, an\n-infinite data source may be of such nature that it can be consumed only\n-once. An example is the TCP socket connector. Such sources are bad at\n-fault tolerance: if anything goes wrong during the computation, it\n-cannot be retried.\n+Can the connector work in a way that even in case of a job failure and", "originalCommit": "756dc6c22380ddd2decf704688bc715c91f3f56a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "41cc04e7c483f1cc09531bf39c6bf29d3386696e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/41cc04e7c483f1cc09531bf39c6bf29d3386696e", "message": "Address review", "committedDate": "2020-02-05T14:29:49Z", "type": "commit"}, {"oid": "f6a83c304b7ee4a6fb4457793569fd96f40ac94f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f6a83c304b7ee4a6fb4457793569fd96f40ac94f", "message": "One more change", "committedDate": "2020-02-05T14:32:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMxOTk2Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375319967", "bodyText": "the exactly-once guarantee", "author": "mtopolnik", "createdAt": "2020-02-05T15:20:48Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/file-socket.adoc", "diffHunk": "@@ -63,11 +63,11 @@ member will write to different file names. You can achieve the effect of\n a distributed sink if you manually collect all the output files on all\n members and combine their contents.\n \n-If the job is running in exactly-once mode, items will be written to\n-temporary files (ending with a \".tmp\" suffix). When a snapshot is\n-completed, the file will be atomically renamed to remove this suffix.\n-Thanks to the two-phase commit of the snapshot, exactly-once guarantee\n-is provided for the sink.\n+If the job is running in exactly-once mode, items are written to\n+temporary files (ending with a \".tmp\" suffix). When Jet commits a\n+snapshot, it atomically renames the file to remove this suffix. Thanks\n+to the two-phase commit of the snapshot the sink provides exactly-once", "originalCommit": "41cc04e7c483f1cc09531bf39c6bf29d3386696e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyMDUxOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375320518", "bodyText": "with the at-least once", "author": "mtopolnik", "createdAt": "2020-02-05T15:21:41Z", "path": "reference-manual/src/main/asciidoc/work-with-jet/configure-fault-tolerance.adoc", "diffHunk": "@@ -25,12 +25,12 @@ Hazelcast Jet supports exactly-once processing with multiple sources and\n sinks. Each of them specifies the guarantees it is able to provide, for\n details see the summary in <<overview-of-sources-and-sinks>>.\n \n-If you configure Jet job for exactly-once but use a sink with\n-at-least-once guarantee, after a job restart you may get duplicates in\n-the output. As opposed to doubly processing an input item, this is more\n-benign because it just means getting the exact same result twice. If you\n-use a source with at-least-once guarantee, some events might be\n-processed multiple times.\n+If you configure Jet job with the exactly-once guarantee but use a sink\n+with at-least-once guarantee, after a job restart you may get duplicates", "originalCommit": "41cc04e7c483f1cc09531bf39c6bf29d3386696e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzMTI1OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375331259", "bodyText": "It won't work on Windows. It seems obvious that it is bash command but it can be confusing for not experienced users.", "author": "olukas", "createdAt": "2020-02-05T15:37:17Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/file-socket.adoc", "diffHunk": "@@ -46,6 +46,13 @@ after startup: both new files and new content appended to existing ones. Files\n must be updated in an append-only fashion; if the existing content changes, the\n behavior is undefined.\n \n+Often, GUI text editors, even if you just add lines at the end, delete\n+the whole file and recreate it. This gives undefined results. For\n+testing it's best to use:\n+```\n+echo \"foo\" >> your_file", "originalCommit": "f6a83c304b7ee4a6fb4457793569fd96f40ac94f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4MTE4OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375681189", "bodyText": "This exact command works, surprisingly, on Windows :)", "author": "viliam-durina", "createdAt": "2020-02-06T07:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzMTI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5ODk5Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375698992", "bodyText": "wow, really? ok then \ud83d\udc4d", "author": "olukas", "createdAt": "2020-02-06T08:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzMTI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxOTAzOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375719038", "bodyText": "echo without argument works differently on Windows, then it prints echo is OFF if i remember right :)", "author": "mtopolnik", "createdAt": "2020-02-06T09:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzMTI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1Mjg3Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375752873", "bodyText": "It also prints the quotes, weird...", "author": "viliam-durina", "createdAt": "2020-02-06T10:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzMTI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMzMTMyNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375331326", "bodyText": "JMS and JDBC are planned for the next release. - is it something what we want to have in reference manual now? I mean during implementation and testing of JMS source it was reimplemented from XA to Consumption Acknowledgements - something similar can happen for these as well. I think we should not advertise those sources here for version 4.0.", "author": "olukas", "createdAt": "2020-02-05T15:37:24Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/overview.adoc", "diffHunk": "@@ -24,45 +24,67 @@ Journal feature). You can also set up an `IMap`/`ICache` as a sink for\n an infinite amount of data, either by ensuring that the size of the\n keyset will be finite or by allowing the eviction of old entries.\n \n-== Is it Replayable?\n+== Is it Fault-Tolerant?\n \n-Most finite data sources are replayable because they come from\n-persistent storage. You can easily replay the whole dataset. However, an\n-infinite data source may be of such nature that it can be consumed only\n-once. An example is the TCP socket connector. Such sources are bad at\n-fault tolerance: if anything goes wrong during the computation, it\n-cannot be retried.\n+Can the connector work in a way that even in the case of a job failure\n+and restart it doesn't miss or duplicate any items it reads or creates?\n+There are multiple ways this can be achieved:\n \n-== Does it Support Checkpointing?\n+=== Replayable Source\n \n-You cannot retry to process an infinite data stream from the very\n-beginning. You must save the complete state at regular intervals, then\n-replay the input stream from the last saved position (_checkpoint_).\n-Jet can create snapshots of its internal processing state, but for this\n-to be useful the data source must have the ability to replay its data\n-from the chosen point, discarding everything before it. Both Kafka and\n-the Hazelcast Event Journal support this.\n+If a source has a notion of item offset and a reader can seek to an\n+offset and read the exactly same data from it multiple times, we say\n+it's replayable. For finite sources it's feasible to restart from offset\n+0, such as re-read a file. However, an infinite data source may be of\n+such nature that it can be consumed only once. An example is the TCP\n+socket connector. Such sources are not fault-tolerant: if anything goes\n+wrong during the computation, it cannot be retried. Examples of\n+unbounded replayable sources are Hazelcast Event Journal or Kafka.\n+\n+=== Consumption Acknowledgements\n+\n+If a consumer has to acknowledge each processed message and\n+non-acknowledged messages are redelivered, it's possible to create a\n+fault-tolerant source. An example of this is the JMS source.\n+\n+=== XA Transactions\n+\n+Two-phase transactions are another way to achieve fault-tolerance. Jet\n+can use the standard X/Open XA Transactions or equivalent API. An\n+example is the Kafka sink. JMS and JDBC are planned for the next", "originalCommit": "f6a83c304b7ee4a6fb4457793569fd96f40ac94f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0MzM4MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375343381", "bodyText": "This Guarantee seems to me like \"default\" guarantee and not \"the most precise guarantee which can be achieved\". For example if I take a look into the table I'll start to think that JMS source is exactly-once by default.", "author": "olukas", "createdAt": "2020-02-05T15:55:23Z", "path": "reference-manual/src/main/asciidoc/source-sink-connectors/overview.adoc", "diffHunk": "@@ -96,16 +117,17 @@ aren't packaged with Jet.\n \n .Sources and Sinks\n |===\n-|Resource|Javadoc|Sample|Unbounded?|Replayable?|Checkpointing?|Distributed?|Data Locality\n+|Resource|Javadoc|Sample|Unbounded?|Guarantee|Distributed?|Data Locality", "originalCommit": "f6a83c304b7ee4a6fb4457793569fd96f40ac94f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY4NDY0MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375684641", "bodyText": "Seems OK to me. What do you suggest?", "author": "viliam-durina", "createdAt": "2020-02-06T07:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0MzM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcwMTM2MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1922#discussion_r375701361", "bodyText": "Based on our discussion it is ok how it is now. I'm marking this as resolved.", "author": "olukas", "createdAt": "2020-02-06T08:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0MzM4MQ=="}], "type": "inlineReview"}, {"oid": "a84030dcddda65b1a211c2c2445a97b334fca841", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a84030dcddda65b1a211c2c2445a97b334fca841", "message": "Address Ondrej's review", "committedDate": "2020-02-06T08:03:37Z", "type": "commit"}, {"oid": "9e30dd4419aaa12e60969ef0b0221eca5766f52c", "url": "https://github.com/hazelcast/hazelcast-jet/commit/9e30dd4419aaa12e60969ef0b0221eca5766f52c", "message": "Touchups", "committedDate": "2020-02-06T10:11:10Z", "type": "commit"}, {"oid": "d3df6f3d1c0599220bd90775dd5e79ee89f49d73", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d3df6f3d1c0599220bd90775dd5e79ee89f49d73", "message": "Merge branch 'master' into 2pc-refman", "committedDate": "2020-02-06T10:20:16Z", "type": "commit"}, {"oid": "4bebd7835452f4ebe8baf5a5086d62e4cbc2e4ab", "url": "https://github.com/hazelcast/hazelcast-jet/commit/4bebd7835452f4ebe8baf5a5086d62e4cbc2e4ab", "message": "Merge branch 'master' into 2pc-refman", "committedDate": "2020-02-07T10:49:56Z", "type": "commit"}, {"oid": "ee4dc591a6c850c78af2fae82fc2fb7981ce3d3d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/ee4dc591a6c850c78af2fae82fc2fb7981ce3d3d", "message": "Update JMS refman", "committedDate": "2020-02-07T14:19:45Z", "type": "commit"}, {"oid": "aedfd6b9beea0a5531b1327bf18ebfde861e7356", "url": "https://github.com/hazelcast/hazelcast-jet/commit/aedfd6b9beea0a5531b1327bf18ebfde861e7356", "message": "Merge branch 'master' into 2pc-refman\n\n# Conflicts:\n#\treference-manual/src/main/asciidoc/source-sink-connectors/kafka.adoc", "committedDate": "2020-02-07T14:34:57Z", "type": "commit"}]}