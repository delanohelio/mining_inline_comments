{"pr_number": 1979, "pr_title": "(de)serialization page draft.", "pr_createdAt": "2020-02-13T13:51:10Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/1979", "timeline": [{"oid": "73bfc92cf40967b68ebfbbd86b24b698cf3acc9e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/73bfc92cf40967b68ebfbbd86b24b698cf3acc9e", "message": "(De)serialization docs.", "committedDate": "2020-02-13T13:29:23Z", "type": "commit"}, {"oid": "37df40991d5b399eb7f2615110c2a82897585b13", "url": "https://github.com/hazelcast/hazelcast-jet/commit/37df40991d5b399eb7f2615110c2a82897585b13", "message": "Wrap each line to 72 chars.", "committedDate": "2020-02-13T14:01:58Z", "type": "commit"}, {"oid": "aab6a607d08defb31c3d830b9ebcd15ee95befcd", "url": "https://github.com/hazelcast/hazelcast-jet/commit/aab6a607d08defb31c3d830b9ebcd15ee95befcd", "message": "Add size comparison.", "committedDate": "2020-02-13T15:21:01Z", "type": "commit"}, {"oid": "47f7861642d1b831be206a1ab84d992f35b7eff8", "url": "https://github.com/hazelcast/hazelcast-jet/commit/47f7861642d1b831be206a1ab84d992f35b7eff8", "message": "Merge remote-tracking branch 'upstream/docs' into docs", "committedDate": "2020-02-13T15:48:12Z", "type": "commit"}, {"oid": "62471c8fb8b903642f0b1e287383b65e3df81a8d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/62471c8fb8b903642f0b1e287383b65e3df81a8d", "message": "Add (de)serialization pros and cons.", "committedDate": "2020-02-14T08:17:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNDU0MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379324540", "bodyText": "WDYT  about crucial to efficient usage of Hazelcast Jet ?", "author": "eminn", "createdAt": "2020-02-14T09:21:50Z", "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.", "originalCommit": "62471c8fb8b903642f0b1e287383b65e3df81a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNDkzNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379324936", "bodyText": "Maybe a link to the DAG section if we have it atm or a javadoc link ?", "author": "eminn", "createdAt": "2020-02-14T09:22:48Z", "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.\n+\n+Hazelcast Jet closely integrates with Hazelcast IMDG exposing many of \n+its features to Jet users. In particular, one can use IMDG data \n+structure as Jet `Source` and/or `Sink`. Objects retrieved from and \n+stored in those have to be (de)serializable.\n+\n+Another case which might require (de)serializable objects is sending \n+computation results between remote vertices. Hazelcast Jet tries to \n+minimize network traffic as much as possible, nonetheless different \n+parts of a `DAG` can reside on separate cluster members. To catch ", "originalCommit": "62471c8fb8b903642f0b1e287383b65e3df81a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNjA3MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379326071", "bodyText": "Maybe a link to the benchmark source for reproducibility ?", "author": "eminn", "createdAt": "2020-02-14T09:25:18Z", "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.\n+\n+Hazelcast Jet closely integrates with Hazelcast IMDG exposing many of \n+its features to Jet users. In particular, one can use IMDG data \n+structure as Jet `Source` and/or `Sink`. Objects retrieved from and \n+stored in those have to be (de)serializable.\n+\n+Another case which might require (de)serializable objects is sending \n+computation results between remote vertices. Hazelcast Jet tries to \n+minimize network traffic as much as possible, nonetheless different \n+parts of a `DAG` can reside on separate cluster members. To catch \n+(de)serialization issues early on, we recommend using a 2-member local \n+Jet cluster for development and testing.\n+\n+Currently, Hazelcast Jet supports 6 interfaces to (de)serialize objects:\n+- [java.io.Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)\n+- [java.io.Externalizable](https://docs.oracle.com/javase/8/docs/api/java/io/Externalizable.html)\n+- [com.hazelcast.nio.serialization.DataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/DataSerializable.html)\n+- [com.hazelcast.nio.serialization.IdentifiedDataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/IdentifiedDataSerializable.html)\n+- [com.hazelcast.nio.serialization.Portable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/Portable.html)\n+- [com.hazelcast.nio.serialization.StreamSerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/StreamSerializer.html) &\n+  [com.hazelcast.nio.serialization.ByteArraySerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/ByteArraySerializer.html)\n+\n+The following table provides a comparison between them to help you in \n+deciding which interface to use in your applications.\n+|      Serialization interface      |                                                                      Advantages                                                                      |                                               Drawbacks                                              |\n+|:---------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------:|\n+|            Serializable           | <ul><li>Easy to start with, requires no implementation</li></ul>                                                                                     | <ul><li>CPU intensive</li><li>Space inefficient</li></ul>                                            |\n+|           Externalizable          | <ul><li>Faster and more space efficient than Serializable</li></ul>                                                                                  | <ul><li>CPU intensive</li><li>Space inefficient</li><li>Requires implementation</li></ul>            |\n+|          DataSerializable         | <ul><li>Faster and more space efficient than java standard interfaces</li></ul>                                                                      | <ul><li>Requires implementation</li></ul>                                                            |\n+|     IdentifiedDataSerializable    | <ul><li>Relatively fast and space efficient</li></ul>                                                                                                | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+|              Portable             | <ul><li>Faster and more space efficient than java standard interfaces</li><li>Supports versioning</li><li>Supports partial deserialization</li></ul> | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+| [Stream&#124;ByteArray]Serializer | <ul><li>The fastest and lightest out of supported interfaces</li></ul>                                                                               | <ul><li>Requires implementation</li><li>Requires registration during cluster setup</li></ul>         |\n+\n+Below you can find rough performance numbers one can expect when \n+employing each of those strategies. A straightforward benchmark which continuously serializes and then ", "originalCommit": "62471c8fb8b903642f0b1e287383b65e3df81a8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzMDYwMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379330603", "bodyText": "I'm not sure about this, I wanted the readers just to have an idea about the potential performance. Where would that sit if we wanted to add it?", "author": "gierlachg", "createdAt": "2020-02-14T09:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNjA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNDMwOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379334309", "bodyText": "I think https://github.com/hazelcast/hazelcast-jmh is a good candidate for that. My thinking was that they can take the benchmarking boilerplate and plug their own POJOs to see the real performance impact for their actual objects.", "author": "eminn", "createdAt": "2020-02-14T09:42:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNjA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNTc2MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379335760", "bodyText": "Makes sense. I need to polish it then a bit and add it.", "author": "gierlachg", "createdAt": "2020-02-14T09:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNjA3MQ=="}], "type": "inlineReview"}, {"oid": "b990ddf1fb76417c8a4f3cdffec7795cdfc1b299", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b990ddf1fb76417c8a4f3cdffec7795cdfc1b299", "message": "Address reviews.", "committedDate": "2020-02-14T09:31:06Z", "type": "commit"}, {"oid": "d798703990dedb23fb5147ca22969aa0994d8984", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d798703990dedb23fb5147ca22969aa0994d8984", "message": "Amend numbers & add (not yet active) benchmark link.", "committedDate": "2020-02-14T14:51:12Z", "type": "commit"}]}