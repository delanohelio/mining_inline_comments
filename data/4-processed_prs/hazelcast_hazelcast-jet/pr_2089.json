{"pr_number": 2089, "pr_title": "Inner join distinction", "pr_createdAt": "2020-03-23T17:27:16Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2089", "timeline": [{"oid": "3f0f6702543aed5876ecb2f1a85e237c376fd7b0", "url": "https://github.com/hazelcast/hazelcast-jet/commit/3f0f6702543aed5876ecb2f1a85e237c376fd7b0", "message": "Added special innerHashJoin method, to avoid repetitive filtering and make it more clear for users #1238", "committedDate": "2020-03-23T17:21:41Z", "type": "commit"}, {"oid": "a66ec04259cf1375401080f193bf237946c3b0b6", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a66ec04259cf1375401080f193bf237946c3b0b6", "message": "Added JavaDoc", "committedDate": "2020-03-23T17:27:12Z", "type": "commit"}, {"oid": "d8c44e658586e4aae4c9f0008fb8e5c51a048919", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d8c44e658586e4aae4c9f0008fb8e5c51a048919", "message": "Fix checkstyl error", "committedDate": "2020-03-23T19:18:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3ODE4OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397678189", "bodyText": "Please follow the formatting guidelines you can infer from the rest of the docs. We use text line length of 72 (excluding any indentation and *),  we don't use </p> and we don't indent the text.", "author": "mtopolnik", "createdAt": "2020-03-25T08:27:58Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,48 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage a inner-hash-joining stage and\n+     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to a stream of countries and outputs\n+     * a stream of users with the {@code country} field set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     *\n+     * users.innerHashJoin(\n+     *     idAndCountry,\n+     *     JoinClause.joinMapEntries(User::getCountryId),\n+     *     (user, country) -> user.setCountry(country)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>", "originalCommit": "d8c44e658586e4aae4c9f0008fb8e5c51a048919", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3OTkxMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397679913", "bodyText": "You should also update the Javadoc that this doc points to. The com.hazelcast.jet.pipeline Javadoc now explicitly states that \"hash join is a left-outer join\".", "author": "mtopolnik", "createdAt": "2020-03-25T08:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3ODE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3ODQzNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397678436", "bodyText": "Typo: metod", "author": "mtopolnik", "createdAt": "2020-03-25T08:28:27Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,48 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage a inner-hash-joining stage and\n+     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to a stream of countries and outputs\n+     * a stream of users with the {@code country} field set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     *\n+     * users.innerHashJoin(\n+     *     idAndCountry,\n+     *     JoinClause.joinMapEntries(User::getCountryId),\n+     *     (user, country) -> user.setCountry(country)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     *     This metod is similar to {@link #hashJoin(BatchStage, JoinClause, BiFunctionEx)} method,", "originalCommit": "d8c44e658586e4aae4c9f0008fb8e5c51a048919", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3ODU0Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397678542", "bodyText": "Typo: a inner, should be an inner.", "author": "mtopolnik", "createdAt": "2020-03-25T08:28:41Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,48 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage a inner-hash-joining stage and", "originalCommit": "d8c44e658586e4aae4c9f0008fb8e5c51a048919", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "message": "Fixed formatting and added info to package-info", "committedDate": "2020-03-25T12:54:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MTA2Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397841062", "bodyText": "Please reflow these paragraphs.", "author": "mtopolnik", "createdAt": "2020-03-25T13:12:25Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2MTgzNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r401761836", "bodyText": "Please reflow these paragraphs.\n\nBy reflow you mean only formatting or also how sentences are written?", "author": "TomaszGaweda", "createdAt": "2020-04-01T16:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MTA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5NjMyMQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r401796321", "bodyText": "Just the formatting aspect :)", "author": "mtopolnik", "createdAt": "2020-04-01T17:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MTA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MjE5OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397842198", "bodyText": "Please try to use the active voice as much as possible. This can be \"If you need the inner join, \". Also note \"inner join\" (without a dash). We actually need to fix \"hash-join\" into \"hash join\" as well, but this is not the topic of this PR.", "author": "mtopolnik", "createdAt": "2020-03-25T13:13:52Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:\n+ * for each primary item there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item, the output will\n+ * have a {@code null} instead of the enriching item.\n+ * <p>\n+ * If SQL inner-join is needed,", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzE3Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397843177", "bodyText": "the specialized innerHashJoin", "author": "mtopolnik", "createdAt": "2020-03-25T13:15:21Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:\n+ * for each primary item there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item, the output will\n+ * have a {@code null} instead of the enriching item.\n+ * <p>\n+ * If SQL inner-join is needed,\n+ * then specialised {@code innerHashJoin} can be used, in which", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzQzMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397843433", "bodyText": "with the given primary item", "author": "mtopolnik", "createdAt": "2020-03-25T13:15:44Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:\n+ * for each primary item there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item, the output will\n+ * have a {@code null} instead of the enriching item.\n+ * <p>\n+ * If SQL inner-join is needed,\n+ * then specialised {@code innerHashJoin} can be used, in which\n+ * for each primary item with at least one match, there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item,\n+ * there will be no records with given primary item.", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzcwOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397843709", "bodyText": "the output function's", "author": "mtopolnik", "createdAt": "2020-03-25T13:16:10Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:\n+ * for each primary item there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item, the output will\n+ * have a {@code null} instead of the enriching item.\n+ * <p>\n+ * If SQL inner-join is needed,\n+ * then specialised {@code innerHashJoin} can be used, in which\n+ * for each primary item with at least one match, there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item,\n+ * there will be no records with given primary item.\n+ * In this case output function's arguments are always non-null.", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0NzMyNQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397847325", "bodyText": "This claims to test that innerHashJoin filters out nulls, but it actually uses hashJoin and asserts that it does not filter out nulls.\nAbout method naming: we use _ only for special purposes like the structure when_predondition_then_postcondition. So this method should be when_hashJoin_then_dontFilterOutNulls or similar.", "author": "mtopolnik", "createdAt": "2020-03-25T13:21:42Z", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java", "diffHunk": "@@ -1035,6 +1035,35 @@ public void hashJoin_when_outputFnReturnsNull_then_filteredOut() {\n         assertEquals(emptyList(), new ArrayList<>(sinkList));\n     }\n \n+    @Test", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0OTE1Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397849153", "bodyText": "This seems to test the behavior common to inner and outer join. The input has no nulls to begin with.", "author": "mtopolnik", "createdAt": "2020-03-25T13:24:16Z", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/StreamStageTest.java", "diffHunk": "@@ -1253,6 +1253,39 @@ public void hashJoin() {\n         );\n     }\n \n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void innerHashJoin() {", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYzMDUxNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r399630514", "bodyText": "We also have hashJoin2() and hashJoinBuilder(), they also need the same API extension. You could add a method to the hash join builder: buildInner.", "author": "mtopolnik", "createdAt": "2020-03-28T07:14:55Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/pipeline/BatchStageImpl.java", "diffHunk": "@@ -165,6 +165,21 @@ public BatchStageImpl(@Nonnull Transform transform, FunctionAdapter ignored, @No\n         return attachHashJoin(stage1, joinClause1, mapToOutputFn);\n     }\n \n+    @Nonnull @Override\n+    public <K, T1_IN, T1, R> BatchStage<R> innerHashJoin(\n+            @Nonnull BatchStage<T1_IN> stage1,\n+            @Nonnull JoinClause<K, ? super T, ? super T1_IN, ? extends T1> joinClause1,\n+            @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n+    ) {\n+        BiFunctionEx<T, T1, R> finalOutputFn = (leftSide, rightSide) -> {\n+            if (leftSide == null || rightSide == null) {\n+                return null;\n+            }\n+            return mapToOutputFn.apply(leftSide, rightSide);\n+        };\n+        return attachHashJoin(stage1, joinClause1, finalOutputFn);\n+    }\n+", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc4MTYxMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r401781610", "bodyText": "Maybe not builderInner, but rather addInner? So you can have left outer and inner join in one builder", "author": "TomaszGaweda", "createdAt": "2020-04-01T17:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYzMDUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5Njg5OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r401796899", "bodyText": "Yes, sounds better than my idea.", "author": "mtopolnik", "createdAt": "2020-04-01T17:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYzMDUxNA=="}], "type": "inlineReview"}, {"oid": "52ed9207980bce7e7eedb9f0b91fd81c9cf7452a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/52ed9207980bce7e7eedb9f0b91fd81c9cf7452a", "message": "Fix test - intention was to show that innerHashJoin filter outs nulsl", "committedDate": "2020-04-01T16:43:50Z", "type": "commit"}, {"oid": "ce78bfad0b67eb1041b3559bc7fe0252873e7568", "url": "https://github.com/hazelcast/hazelcast-jet/commit/ce78bfad0b67eb1041b3559bc7fe0252873e7568", "message": "Fix another test - show that innerHashJoin works in stream scenario", "committedDate": "2020-04-01T16:46:59Z", "type": "commit"}, {"oid": "e875aabb41969304f2410a700addc9810272fa7d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e875aabb41969304f2410a700addc9810272fa7d", "message": "Fixed JavaDoc as per CR Comments", "committedDate": "2020-04-01T16:58:08Z", "type": "commit"}, {"oid": "cfdea20ddc71021c38e807ab8666ceee8e2368d3", "url": "https://github.com/hazelcast/hazelcast-jet/commit/cfdea20ddc71021c38e807ab8666ceee8e2368d3", "message": "Added The there needed", "committedDate": "2020-04-01T16:59:56Z", "type": "commit"}, {"oid": "f67c69299fad3ced5691b58408e95bc746221909", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f67c69299fad3ced5691b58408e95bc746221909", "message": "Fixed line length", "committedDate": "2020-04-01T17:12:39Z", "type": "commit"}, {"oid": "f840f2aba73e603efdfe608d7ef58974aeb7f6cc", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f840f2aba73e603efdfe608d7ef58974aeb7f6cc", "message": "Added missing since", "committedDate": "2020-04-02T13:40:39Z", "type": "commit"}, {"oid": "d41155e2fba0e77c42803d73d464c7ffcec5ca3f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d41155e2fba0e77c42803d73d464c7ffcec5ca3f", "message": "Added innerHashJoin2", "committedDate": "2020-04-16T18:32:30Z", "type": "commit"}, {"oid": "7690fea8d56a61e20f45d58608d2a45112f7a48f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/7690fea8d56a61e20f45d58608d2a45112f7a48f", "message": "Added addInner to HashJoinBuilder", "committedDate": "2020-04-16T19:58:08Z", "type": "commit"}, {"oid": "a6f21975abae376d0af6069d08b12eb9e2ff9965", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a6f21975abae376d0af6069d08b12eb9e2ff9965", "message": "Fixed test and Reversed condition.", "committedDate": "2020-04-16T20:02:39Z", "type": "commit"}, {"oid": "5ff8d2ca545b11cfd4435f0e05d995106edc1c19", "url": "https://github.com/hazelcast/hazelcast-jet/commit/5ff8d2ca545b11cfd4435f0e05d995106edc1c19", "message": "Added misssing since annotation", "committedDate": "2020-04-17T08:08:00Z", "type": "commit"}, {"oid": "af34d0de1ad6e745ad35a940044d3bf9e1264007", "url": "https://github.com/hazelcast/hazelcast-jet/commit/af34d0de1ad6e745ad35a940044d3bf9e1264007", "message": "Improved formatting and JavaDocs in general", "committedDate": "2020-04-17T08:14:33Z", "type": "commit"}, {"oid": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "message": "Fixed checkstyle errors", "committedDate": "2020-04-17T12:26:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyODQwMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410228402", "bodyText": "There's a double space here.", "author": "mtopolnik", "createdAt": "2020-04-17T13:38:42Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,49 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage an inner hash-joining stage\n+     * and  returns it. This stage plays the role of the <em>primary stage</em>", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyOTE2Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410229163", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:39:49Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -795,6 +838,58 @@\n             @Nonnull TriFunction<T, T1, T2, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to this and the two supplied stages a inner hash-joining stage and", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyOTQ3Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410229477", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:40:20Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -795,6 +838,58 @@\n             @Nonnull TriFunction<T, T1, T2, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to this and the two supplied stages a inner hash-joining stage and\n+     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to streams of countries and\n+     * companies, and outputs a stream of users with the {@code country} and\n+     * {@code company} fields set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     * BatchStage<Map.Entry<Long, Company>> idAndCompany;\n+     *\n+     * users.innerHashJoin2(\n+     *     idAndCountry, JoinClause.joinMapEntries(User::getCountryId),\n+     *     idAndCompany, JoinClause.joinMapEntries(User::getCompanyId),\n+     *     (user, country, company) -> user.setCountry(country).setCompany(company)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     * This method is similar to {@link #hashJoin2(BatchStage, JoinClause, BatchStage, JoinClause, TriFunction)}", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyOTY4Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410229687", "bodyText": "Line too long. Note that you can just refer to a method name without parameters.", "author": "mtopolnik", "createdAt": "2020-04-17T13:40:40Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,49 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage an inner hash-joining stage\n+     * and  returns it. This stage plays the role of the <em>primary stage</em>\n+     * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to a stream of countries and outputs\n+     * a stream of users with the {@code country} field set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     *\n+     * users.innerHashJoin(\n+     *     idAndCountry,\n+     *     JoinClause.joinMapEntries(User::getCountryId),\n+     *     (user, country) -> user.setCountry(country)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     * This method is similar to {@link #hashJoin(BatchStage, JoinClause, BiFunctionEx)}", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzMDA2Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410230067", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:41:17Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java", "diffHunk": "@@ -82,7 +82,28 @@\n      */\n     public <K, T1_IN, T1> Tag<T1> add(BatchStage<T1_IN> stage, JoinClause<K, T0, T1_IN, T1> joinClause) {\n         Tag<T1> tag = tag(clauses.size());\n-        clauses.put(tag, new TransformAndClause<>(stage, joinClause));\n+        clauses.put(tag, new TransformAndClause<>(stage, joinClause, false));\n+        return tag;\n+    }\n+\n+    /**\n+     * Adds another contributing pipeline stage to the hash-join operation.\n+     *\n+     * If no matching items for returned {@linkplain Tag tag} is found, no records", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzMDcxOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410230718", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:42:15Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,49 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage an inner hash-joining stage\n+     * and  returns it. This stage plays the role of the <em>primary stage</em>\n+     * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to a stream of countries and outputs\n+     * a stream of users with the {@code country} field set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     *\n+     * users.innerHashJoin(\n+     *     idAndCountry,\n+     *     JoinClause.joinMapEntries(User::getCountryId),\n+     *     (user, country) -> user.setCountry(country)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     * This method is similar to {@link #hashJoin(BatchStage, JoinClause, BiFunctionEx)}\n+     * method, but it guarantees that both input items will be not-null. Nulls will", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzMDk2OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410230968", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:42:40Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -795,6 +838,58 @@\n             @Nonnull TriFunction<T, T1, T2, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to this and the two supplied stages a inner hash-joining stage and\n+     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to streams of countries and\n+     * companies, and outputs a stream of users with the {@code country} and\n+     * {@code company} fields set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     * BatchStage<Map.Entry<Long, Company>> idAndCompany;\n+     *\n+     * users.innerHashJoin2(\n+     *     idAndCountry, JoinClause.joinMapEntries(User::getCountryId),\n+     *     idAndCompany, JoinClause.joinMapEntries(User::getCompanyId),\n+     *     (user, country, company) -> user.setCountry(country).setCompany(company)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     * This method is similar to {@link #hashJoin2(BatchStage, JoinClause, BatchStage, JoinClause, TriFunction)}\n+     * method, but it guarantees that both input items will be not-null. Nulls will", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1ODc4Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410258782", "bodyText": "All this comments are addressed. Limit of 72 chars in line will be my next nightmare I think :D", "author": "TomaszGaweda", "createdAt": "2020-04-17T14:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzMDk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0MTk2Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410241967", "bodyText": "Could you adjust this test so that one side is inner join and the other outer? I think that would test for the less trivial behavior. Or maybe duplicate and modify this test so we have both.", "author": "mtopolnik", "createdAt": "2020-04-17T13:59:35Z", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java", "diffHunk": "@@ -1035,6 +1035,75 @@ public void hashJoin_when_outputFnReturnsNull_then_filteredOut() {\n         assertEquals(emptyList(), new ArrayList<>(sinkList));\n     }\n \n+    @Test\n+    public void when_innerHashJoin_then_filterOutNulls() {\n+        // Given\n+        List<Integer> input = sequence(itemCount);\n+        String prefix = \"value-\";\n+        BatchStage<Entry<Integer, String>> enrichingStage = batchStageFromList(input)\n+                .filter(i -> i % 2 == 0)\n+                .map(i -> entry(i, prefix + i));\n+\n+        // When\n+        BatchStage<Entry<Integer, String>> joined = batchStageFromList(input).innerHashJoin(\n+                enrichingStage,\n+                joinMapEntries(wholeItem()),\n+                Util::entry);\n+\n+        // Then\n+        joined.writeTo(sink);\n+        execute();\n+        Function<Entry<Integer, String>, String> formatFn =\n+                e -> String.format(\"(%04d, %s)\", e.getKey(), e.getValue());\n+        assertEquals(\n+                streamToString(input.stream().filter(e -> e % 2 == 0).map(i -> tuple2(i, prefix + i)), formatFn),\n+                streamToString(sinkStreamOfEntry(), formatFn));\n+    }\n+\n+    @Test\n+    public void when_hashJoinBuilderAddInner_then_filterOutNulls() {\n+        // Given\n+        int itemCountLocal = itemCount;\n+        List<Integer> input = sequence(itemCountLocal);\n+        String prefixA = \"A-\";\n+        String prefixB = \"B-\";\n+        String prefixC = \"C-\";\n+        String prefixD = \"D-\";\n+        BatchStage<Entry<Integer, String>> enrichingStage1 =\n+                batchStageFromList(input)\n+                        .filter(e -> e <= itemCountLocal / 2)\n+                        .flatMap(i -> traverseItems(entry(i, prefixA + i), entry(i, prefixB + i)));\n+        BatchStage<Entry<Integer, String>> enrichingStage2 =\n+                batchStageFromList(input)\n+                        .filter(e -> e <= itemCountLocal / 4)\n+                        .flatMap(i -> traverseItems(entry(i, prefixC + i), entry(i, prefixD + i)));\n+\n+        // When\n+        HashJoinBuilder<Integer> b = batchStageFromList(input).hashJoinBuilder();\n+        Tag<String> tagA = b.addInner(enrichingStage1, joinMapEntries(wholeItem()));\n+        Tag<String> tagB = b.addInner(enrichingStage2, joinMapEntries(wholeItem()));", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0NzA2OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410247069", "bodyText": "Sure. BTW. One question - typically when we do\nx\nleft join y\njoin z\nthen join to y is also treated as inner join. Currently only no value on z will cause no tuple returned, the lack of y will be ignored. Is it ok or should we stay as compatible with SQL as possible?", "author": "TomaszGaweda", "createdAt": "2020-04-17T14:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1NTA1Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410255053", "bodyText": "Treating each side separately seems more flexible and useful to me. You may legitimately need such a combination. SQL strictly follows relational algebra, and there we'd consider the whole expression as a composition of two joins, so if the first one is an inner join, the tuple is eliminated even before reaching the left join. Jet's transforms are not an implementation of relational algebra so I'm fine with going the more useful route.\n@viliam-durina what do you think?", "author": "mtopolnik", "createdAt": "2020-04-17T14:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0MTk2Nw=="}], "type": "inlineReview"}, {"oid": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/8601549d01a4b5c5674ed03375819143ac2d3a7a", "message": "Fixed line lengths", "committedDate": "2020-04-17T14:05:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1MDMwMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410250300", "bodyText": "I tried it, you can safely inline this into the usage below. The reason that joinClauses stream had to be extracted does not appear in this case.", "author": "mtopolnik", "createdAt": "2020-04-17T14:12:35Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java", "diffHunk": "@@ -98,17 +119,23 @@\n                         orderedClauses.stream().map(e -> e.getValue().transform())\n                 ).collect(toList());\n         // A probable javac bug forced us to extract this variable\n+        // and not using method reference\n         Stream<JoinClause<?, T0, ?, ?>> joinClauses = orderedClauses\n                 .stream()\n                 .map(e -> e.getValue().clause())\n-                .map(fnAdapter::adaptJoinClause);\n+                .map(joinClause -> fnAdapter.adaptJoinClause(joinClause));\n+        Stream<Boolean> whereNullNotAllowed = orderedClauses", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1ODM0MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410258340", "bodyText": "Done", "author": "TomaszGaweda", "createdAt": "2020-04-17T14:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1MDMwMA=="}], "type": "inlineReview"}, {"oid": "2e4803277a43a4ed6ecc0d9c0ee4c7c8950d590f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/2e4803277a43a4ed6ecc0d9c0ee4c7c8950d590f", "message": "Extended the test to test inner and left join at the same time", "committedDate": "2020-04-17T14:23:16Z", "type": "commit"}, {"oid": "40f5d6199fb7c90f05d508177eeda82c773da9ce", "url": "https://github.com/hazelcast/hazelcast-jet/commit/40f5d6199fb7c90f05d508177eeda82c773da9ce", "message": "After CR: inlined variable", "committedDate": "2020-04-17T14:23:59Z", "type": "commit"}]}