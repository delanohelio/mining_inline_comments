{"pr_number": 1974, "pr_title": "Cluster sizing draft", "pr_createdAt": "2020-02-12T18:51:01Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/1974", "timeline": [{"oid": "ef8cf8d27c02a8b4fd720e8d385615b08356b5d1", "url": "https://github.com/hazelcast/hazelcast-jet/commit/ef8cf8d27c02a8b4fd720e8d385615b08356b5d1", "message": "Cluster sizing draft", "committedDate": "2020-02-12T18:48:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY4MzA2OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1974#discussion_r378683069", "bodyText": "I'm not sure of this \"local IMDG\" term. It sounds like IMDG is something else running side by side, when it's one and the same.", "author": "cangencer", "createdAt": "2020-02-13T07:06:53Z", "path": "site/docs/operations/cluster-sizing.md", "diffHunk": "@@ -0,0 +1,114 @@\n+---\n+title: Cluster Sizing\n+id: cluster-sizing\n+---\n+\n+Jet cluster performance depends on multiple factors including the pipeline design and user defined functions. Therefore, planning the Jet cluster remains a complex task that requires a knowledge of the Jet architecture and concepts. We will introduce a basic guideline that will help you size your cluster. \n+\n+We recommend to always benchmark your setup before deploying it to production. See a sample cluster sizing with benchmark that can be used as a reference.\n+\n+Please read the Hazelcast IMDG Deployment and Operations Guide when using the [local IMDG](concepts/in-memory-storage.md#relationship-with-hazelcast-imdg) setup. Your Jet cluster will run both workloads (local IMDG and Jet jobs) so you should plan for it.", "originalCommit": "ef8cf8d27c02a8b4fd720e8d385615b08356b5d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY4MzUxNw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1974#discussion_r378683517", "bodyText": "typo, aggressively", "author": "cangencer", "createdAt": "2020-02-13T07:08:31Z", "path": "site/docs/operations/cluster-sizing.md", "diffHunk": "@@ -0,0 +1,114 @@\n+---\n+title: Cluster Sizing\n+id: cluster-sizing\n+---\n+\n+Jet cluster performance depends on multiple factors including the pipeline design and user defined functions. Therefore, planning the Jet cluster remains a complex task that requires a knowledge of the Jet architecture and concepts. We will introduce a basic guideline that will help you size your cluster. \n+\n+We recommend to always benchmark your setup before deploying it to production. See a sample cluster sizing with benchmark that can be used as a reference.\n+\n+Please read the Hazelcast IMDG Deployment and Operations Guide when using the [local IMDG](concepts/in-memory-storage.md#relationship-with-hazelcast-imdg) setup. Your Jet cluster will run both workloads (local IMDG and Jet jobs) so you should plan for it.\n+\n+## Sizing considerations\n+\n+To size the cluster for your use case, you must first be able to answer the following questions:\n+\n+* What are the throughput and latency requirements?\n+* How many concurrent Jobs shall the cluster run?\n+* Fault tolerance requirements\n+* Characteristics of the data (number of input partitions, key distribution and , size of the dataset)\n+* Shape of the pipelines (operations used, external systems involved)\n+* Source and sink capacity\n+* Network throughput \n+* How long is the error window?\n+\n+## Determining cluster size\n+\n+Even a single Jet instance can host and run hundreds of jobs at a time. The clustered setup improves the performance (throughput and latency) of hosted jobs and increases the resillience.\n+\n+A cluster with 3 members is a minimum count for fault tolerant operations. Generally, you need ```n+1``` cluster members to tolerate `n` member failures with next higher odd number choosen for a split brain detection.\n+\n+Jet can utilise hundreds of CPU cores efficiently by exploiting data and task parallelism. Adding more members to the cluster therefore helps with scaling the CPU-bound computations. Better performance is achieved by distributing the data partitions accros the cluster to process them in parallel. \n+\n+Benchmark your jobs in a clustered setup to see the differences in performance, see the Sizing Example.\n+\n+## Sizing for failures\n+\n+Jet cluster is elastic to deal with failures and performance spikes. Mostly down-scales temporarily reduce the available resources and increase the stress on remaining members. The overal memory and CPU available in the cluster reduces. The data previously owned by the newly offline member is distributed among the remaining members. The cluster must catch up the missed data in the stream and keep up with the head of the stream.\n+\n+To tolerate the failure of one member, we recommend to size your cluster to operate with ```n-1``` members setup.\n+\n+You can use Hazelcast IMap Journal to ingest the streaming data. Journal is a in-memory structure with a fixed capacity. If the jobs consuming the journal can't keep up there is a risk of data loss.  The pace of the data producers and the capacity of the Journal therefore determine the lenght of an error window of your application. If you can't afford losing data, consider increasing the journal size or use persistent streaming storage such as Apache Kafka or Apache Pulsar.\n+\n+## Balancing cluster size with job count\n+\n+The jobs running in one cluster share the resources to maximise the HW utilization. This is efficient for setups without a risk of noisy neighbours such as:\n+* Clusters hosting many short-living jobs\n+* Clusters hosting jobs with a predictable performance \n+* Jobs with relaxed SLAs\n+\n+For stronger resource isolation (multi-tenant environments, strict SLAs), consider starting multiple smaller clusters with resources (CPU, memory, network) allocated on an OS level or a resource manager level.\n+\n+## Hardware Planning\n+\n+Jet is designed to run efficiently on homogeneous clusters. All JVM processes that participate in the cluster should have equal CPU, memory and network resources. One slow cluster member can kill the performance of the whole cluster.\n+\n+### Minimal Configuration\n+\n+Jet is a lightweight framework and is reported to run on a devices such as Rapsberry Pi Zerro (1GHz single-core CPU, 512MB RAM).\n+\n+### Recommended Configuration\n+\n+As a starting point for a data-intensive oprerations consider machines with: \n+\n+* 8 CPU cores\n+* 16 GB RAM\n+* 10 Gbps network\n+\n+### CPU\n+\n+Jet can utilise hundreds of CPU cores efficiently by exploiting data and task parallelism. Adding more CPU can therefore help with scaling the CPU-bound computations. Read about the [Execution model](architecture/execution-engine.md) to understand how Jet makes the computation parallel and design your pipelines according to it. \n+\n+Don't rely just on a CPU usage when benchmarking your cluster, benchmnark the throughput and latency instead. The task manager of Jet [can be configured](https://hazelcast.com/blog/idle-green-threads-in-jet/) to use the CPU aggresivelly. The idle Jet instance can use 20% of the CPU, Jet using 100% of the CPU can handle 5x more load.", "originalCommit": "ef8cf8d27c02a8b4fd720e8d385615b08356b5d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY4MzY1MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1974#discussion_r378683651", "bodyText": "\"The idle Jet instance can use 20% of the CPU, Jet using 100% of the CPU can handle 5x more load\"\nThis sounded confusing to me.", "author": "cangencer", "createdAt": "2020-02-13T07:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY4MzUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY4Mzg5MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1974#discussion_r378683891", "bodyText": "there is no mention of Garbage Collection which is a huge operation concern , but maybe that's worth a separate section", "author": "cangencer", "createdAt": "2020-02-13T07:09:52Z", "path": "site/docs/operations/cluster-sizing.md", "diffHunk": "@@ -0,0 +1,114 @@\n+---\n+title: Cluster Sizing\n+id: cluster-sizing\n+---\n+\n+Jet cluster performance depends on multiple factors including the pipeline design and user defined functions. Therefore, planning the Jet cluster remains a complex task that requires a knowledge of the Jet architecture and concepts. We will introduce a basic guideline that will help you size your cluster. \n+\n+We recommend to always benchmark your setup before deploying it to production. See a sample cluster sizing with benchmark that can be used as a reference.\n+\n+Please read the Hazelcast IMDG Deployment and Operations Guide when using the [local IMDG](concepts/in-memory-storage.md#relationship-with-hazelcast-imdg) setup. Your Jet cluster will run both workloads (local IMDG and Jet jobs) so you should plan for it.\n+\n+## Sizing considerations\n+\n+To size the cluster for your use case, you must first be able to answer the following questions:\n+\n+* What are the throughput and latency requirements?\n+* How many concurrent Jobs shall the cluster run?\n+* Fault tolerance requirements\n+* Characteristics of the data (number of input partitions, key distribution and , size of the dataset)\n+* Shape of the pipelines (operations used, external systems involved)\n+* Source and sink capacity\n+* Network throughput \n+* How long is the error window?\n+\n+## Determining cluster size\n+\n+Even a single Jet instance can host and run hundreds of jobs at a time. The clustered setup improves the performance (throughput and latency) of hosted jobs and increases the resillience.\n+\n+A cluster with 3 members is a minimum count for fault tolerant operations. Generally, you need ```n+1``` cluster members to tolerate `n` member failures with next higher odd number choosen for a split brain detection.\n+\n+Jet can utilise hundreds of CPU cores efficiently by exploiting data and task parallelism. Adding more members to the cluster therefore helps with scaling the CPU-bound computations. Better performance is achieved by distributing the data partitions accros the cluster to process them in parallel. \n+\n+Benchmark your jobs in a clustered setup to see the differences in performance, see the Sizing Example.\n+\n+## Sizing for failures\n+\n+Jet cluster is elastic to deal with failures and performance spikes. Mostly down-scales temporarily reduce the available resources and increase the stress on remaining members. The overal memory and CPU available in the cluster reduces. The data previously owned by the newly offline member is distributed among the remaining members. The cluster must catch up the missed data in the stream and keep up with the head of the stream.\n+\n+To tolerate the failure of one member, we recommend to size your cluster to operate with ```n-1``` members setup.\n+\n+You can use Hazelcast IMap Journal to ingest the streaming data. Journal is a in-memory structure with a fixed capacity. If the jobs consuming the journal can't keep up there is a risk of data loss.  The pace of the data producers and the capacity of the Journal therefore determine the lenght of an error window of your application. If you can't afford losing data, consider increasing the journal size or use persistent streaming storage such as Apache Kafka or Apache Pulsar.\n+\n+## Balancing cluster size with job count\n+\n+The jobs running in one cluster share the resources to maximise the HW utilization. This is efficient for setups without a risk of noisy neighbours such as:\n+* Clusters hosting many short-living jobs\n+* Clusters hosting jobs with a predictable performance \n+* Jobs with relaxed SLAs\n+\n+For stronger resource isolation (multi-tenant environments, strict SLAs), consider starting multiple smaller clusters with resources (CPU, memory, network) allocated on an OS level or a resource manager level.\n+\n+## Hardware Planning\n+\n+Jet is designed to run efficiently on homogeneous clusters. All JVM processes that participate in the cluster should have equal CPU, memory and network resources. One slow cluster member can kill the performance of the whole cluster.\n+\n+### Minimal Configuration\n+\n+Jet is a lightweight framework and is reported to run on a devices such as Rapsberry Pi Zerro (1GHz single-core CPU, 512MB RAM).\n+\n+### Recommended Configuration\n+\n+As a starting point for a data-intensive oprerations consider machines with: \n+\n+* 8 CPU cores\n+* 16 GB RAM\n+* 10 Gbps network\n+\n+### CPU\n+\n+Jet can utilise hundreds of CPU cores efficiently by exploiting data and task parallelism. Adding more CPU can therefore help with scaling the CPU-bound computations. Read about the [Execution model](architecture/execution-engine.md) to understand how Jet makes the computation parallel and design your pipelines according to it. \n+\n+Don't rely just on a CPU usage when benchmarking your cluster, benchmnark the throughput and latency instead. The task manager of Jet [can be configured](https://hazelcast.com/blog/idle-green-threads-in-jet/) to use the CPU aggresivelly. The idle Jet instance can use 20% of the CPU, Jet using 100% of the CPU can handle 5x more load.\n+\n+### Memory", "originalCommit": "ef8cf8d27c02a8b4fd720e8d385615b08356b5d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY4NDA1MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1974#discussion_r378684051", "bodyText": "I don't think it's worth mentioning JVM + Jet Framework itself", "author": "cangencer", "createdAt": "2020-02-13T07:10:29Z", "path": "site/docs/operations/cluster-sizing.md", "diffHunk": "@@ -0,0 +1,114 @@\n+---\n+title: Cluster Sizing\n+id: cluster-sizing\n+---\n+\n+Jet cluster performance depends on multiple factors including the pipeline design and user defined functions. Therefore, planning the Jet cluster remains a complex task that requires a knowledge of the Jet architecture and concepts. We will introduce a basic guideline that will help you size your cluster. \n+\n+We recommend to always benchmark your setup before deploying it to production. See a sample cluster sizing with benchmark that can be used as a reference.\n+\n+Please read the Hazelcast IMDG Deployment and Operations Guide when using the [local IMDG](concepts/in-memory-storage.md#relationship-with-hazelcast-imdg) setup. Your Jet cluster will run both workloads (local IMDG and Jet jobs) so you should plan for it.\n+\n+## Sizing considerations\n+\n+To size the cluster for your use case, you must first be able to answer the following questions:\n+\n+* What are the throughput and latency requirements?\n+* How many concurrent Jobs shall the cluster run?\n+* Fault tolerance requirements\n+* Characteristics of the data (number of input partitions, key distribution and , size of the dataset)\n+* Shape of the pipelines (operations used, external systems involved)\n+* Source and sink capacity\n+* Network throughput \n+* How long is the error window?\n+\n+## Determining cluster size\n+\n+Even a single Jet instance can host and run hundreds of jobs at a time. The clustered setup improves the performance (throughput and latency) of hosted jobs and increases the resillience.\n+\n+A cluster with 3 members is a minimum count for fault tolerant operations. Generally, you need ```n+1``` cluster members to tolerate `n` member failures with next higher odd number choosen for a split brain detection.\n+\n+Jet can utilise hundreds of CPU cores efficiently by exploiting data and task parallelism. Adding more members to the cluster therefore helps with scaling the CPU-bound computations. Better performance is achieved by distributing the data partitions accros the cluster to process them in parallel. \n+\n+Benchmark your jobs in a clustered setup to see the differences in performance, see the Sizing Example.\n+\n+## Sizing for failures\n+\n+Jet cluster is elastic to deal with failures and performance spikes. Mostly down-scales temporarily reduce the available resources and increase the stress on remaining members. The overal memory and CPU available in the cluster reduces. The data previously owned by the newly offline member is distributed among the remaining members. The cluster must catch up the missed data in the stream and keep up with the head of the stream.\n+\n+To tolerate the failure of one member, we recommend to size your cluster to operate with ```n-1``` members setup.\n+\n+You can use Hazelcast IMap Journal to ingest the streaming data. Journal is a in-memory structure with a fixed capacity. If the jobs consuming the journal can't keep up there is a risk of data loss.  The pace of the data producers and the capacity of the Journal therefore determine the lenght of an error window of your application. If you can't afford losing data, consider increasing the journal size or use persistent streaming storage such as Apache Kafka or Apache Pulsar.\n+\n+## Balancing cluster size with job count\n+\n+The jobs running in one cluster share the resources to maximise the HW utilization. This is efficient for setups without a risk of noisy neighbours such as:\n+* Clusters hosting many short-living jobs\n+* Clusters hosting jobs with a predictable performance \n+* Jobs with relaxed SLAs\n+\n+For stronger resource isolation (multi-tenant environments, strict SLAs), consider starting multiple smaller clusters with resources (CPU, memory, network) allocated on an OS level or a resource manager level.\n+\n+## Hardware Planning\n+\n+Jet is designed to run efficiently on homogeneous clusters. All JVM processes that participate in the cluster should have equal CPU, memory and network resources. One slow cluster member can kill the performance of the whole cluster.\n+\n+### Minimal Configuration\n+\n+Jet is a lightweight framework and is reported to run on a devices such as Rapsberry Pi Zerro (1GHz single-core CPU, 512MB RAM).\n+\n+### Recommended Configuration\n+\n+As a starting point for a data-intensive oprerations consider machines with: \n+\n+* 8 CPU cores\n+* 16 GB RAM\n+* 10 Gbps network\n+\n+### CPU\n+\n+Jet can utilise hundreds of CPU cores efficiently by exploiting data and task parallelism. Adding more CPU can therefore help with scaling the CPU-bound computations. Read about the [Execution model](architecture/execution-engine.md) to understand how Jet makes the computation parallel and design your pipelines according to it. \n+\n+Don't rely just on a CPU usage when benchmarking your cluster, benchmnark the throughput and latency instead. The task manager of Jet [can be configured](https://hazelcast.com/blog/idle-green-threads-in-jet/) to use the CPU aggresivelly. The idle Jet instance can use 20% of the CPU, Jet using 100% of the CPU can handle 5x more load.\n+\n+### Memory\n+\n+Jet is a memory-centric framework and all operational data must fit to the memory. This design leads to a predictable performance but requires enough RAM not to run out of memory. Estimate the memory requirements and plan with a headroom of 25% for normal memory fragmentation. For fault-tolerant operations, we recommend reserving an extra memory to survive the failure. See [Sizing for failures](#sizing-for-failures).\n+\n+Memory consumption is affected by:\n+\n+* **JVM:** Hundreds of MBs (depending on your JVM)\n+* **Jet framework overhead:** Tens of MBs", "originalCommit": "ef8cf8d27c02a8b4fd720e8d385615b08356b5d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e77624203b0709bc9f10a7c4e90fd51b39cc93e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/6e77624203b0709bc9f10a7c4e90fd51b39cc93e", "message": "Fixed review points", "committedDate": "2020-02-13T12:43:43Z", "type": "commit"}, {"oid": "fc82e556560354e224d2eaf74099379522fdd702", "url": "https://github.com/hazelcast/hazelcast-jet/commit/fc82e556560354e224d2eaf74099379522fdd702", "message": "Performance sizing example", "committedDate": "2020-02-13T15:21:10Z", "type": "commit"}, {"oid": "e82137108be06816f44213b6b9ac89f513c74a5f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e82137108be06816f44213b6b9ac89f513c74a5f", "message": "Typos", "committedDate": "2020-02-13T15:22:53Z", "type": "commit"}, {"oid": "a0f7eb86de31c4485b16d829ced7f435a9db83d4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a0f7eb86de31c4485b16d829ced7f435a9db83d4", "message": "Fault-Tolerance", "committedDate": "2020-02-13T16:40:05Z", "type": "commit"}, {"oid": "1d9b90487a799dc15f39d635316fc33278249a33", "url": "https://github.com/hazelcast/hazelcast-jet/commit/1d9b90487a799dc15f39d635316fc33278249a33", "message": "Re-wrapping", "committedDate": "2020-02-13T16:51:50Z", "type": "commit"}, {"oid": "17e31ec8eb25b0266795e8e4e79f27868e1bfa10", "url": "https://github.com/hazelcast/hazelcast-jet/commit/17e31ec8eb25b0266795e8e4e79f27868e1bfa10", "message": "i18n added", "committedDate": "2020-02-14T14:34:25Z", "type": "commit"}, {"oid": "30a4b2f0daee4986541a29030ab6f081b832aaf7", "url": "https://github.com/hazelcast/hazelcast-jet/commit/30a4b2f0daee4986541a29030ab6f081b832aaf7", "message": "Typos", "committedDate": "2020-02-14T14:52:26Z", "type": "commit"}, {"oid": "15c87458a73de5a1cda5d458ea717b5e03f8e443", "url": "https://github.com/hazelcast/hazelcast-jet/commit/15c87458a73de5a1cda5d458ea717b5e03f8e443", "message": "Remove i18n", "committedDate": "2020-02-17T10:05:05Z", "type": "commit"}, {"oid": "ae6aa0f26bff09269a8837bb0ac0226154054057", "url": "https://github.com/hazelcast/hazelcast-jet/commit/ae6aa0f26bff09269a8837bb0ac0226154054057", "message": "Merge branch 'docs' into docs-cluster-sizing", "committedDate": "2020-02-17T10:07:23Z", "type": "commit"}]}