{"pr_number": 2343, "pr_title": "Add missing docs from previous reference manual", "pr_createdAt": "2020-06-19T13:29:12Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2343", "timeline": [{"oid": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "url": "https://github.com/hazelcast/hazelcast-jet/commit/cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "message": "Add missing docs from previous reference manual\n\n* addTimestamps\n* mapUsingPython\n* earlyResults\n* guide for building custom aggregations", "committedDate": "2020-06-19T13:28:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2Mzc2MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2343#discussion_r442863760", "bodyText": "This isn't aligned", "author": "mtopolnik", "createdAt": "2020-06-19T14:11:46Z", "path": "site/docs/api/stateless-transforms.md", "diffHunk": "@@ -250,6 +250,78 @@ As you can see, there is some more code to write to combine the results\n back, but this should give better throughput given the service is able\n to efficient batching.\n \n+## mapUsingPython\n+\n+Hazelcast Jet can call Python code to perform a mapping step in the\n+pipeline. The prerequisite is that the Jet servers are Linux or Mac with\n+Python installed and that the `hazelcast-jet-python` module is deployed\n+on the classpath, through being present in the `lib` folder. Jet\n+supports Python versions 3.5-3.7.\n+\n+You are expected to define a function, conventionally named\n+`transform_list(input_list)`, that takes a list of strings and returns a\n+list of strings whose items match positionally one-to-one with the input\n+list. Jet will call this function with batches of items received by the\n+Python mapping stage. If necessary, you can also use a custom name for\n+the transforming function.\n+\n+Internally Jet launches Python processes that execute your function. It\n+launches as many of them as requested by the `localParallelism` setting\n+on the Python pipeline stage. It prepares a local virtual Python\n+environment for the processes to run in and they communicate with it\n+over the loopback network interface, using a bidirectional streaming\n+gRPC call.\n+\n+If you have some simple Python work that fits into a single file, you\n+can tell Jet just the name of that file, which is assumed to be a Python\n+module file that declares `transform_list`:\n+\n+```java\n+StreamStage<String> sourceStage = sourceStage();\n+StreamStage<String> pythonMapped = sourceStage.apply(PythonTransforms.mapUsingPython(\n+        new PythonServiceConfig().setHandlerFile(\"path/to/handler.py\")));\n+```\n+\n+And here's an example of `handler.py`:\n+\n+```python\n+def transform_list(input_list):\n+    return ['reply-' + item for item in input_list]\n+```\n+\n+If you have an entire Python project that you want to use from Jet, just\n+name its base directory and Jet will upload all of it (recursively) to\n+the cluster as a part of the submitted job. In this case you must also\n+name the Python module that declares `transform_list`:\n+\n+```java\n+StreamStage<String> sourceStage = sourceStage();\n+StreamStage<String> pythonMapped = sourceStage.apply(PythonTransforms.mapUsingPython(\n+        new PythonServiceConfig().setBaseDir(\"path/to/python_project\")\n+                                    .setHandlerModule(\"jet_handler\")));", "originalCommit": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NDU5Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2343#discussion_r442864592", "bodyText": "kinds", "author": "mtopolnik", "createdAt": "2020-06-19T14:13:18Z", "path": "site/docs/how-tos/custom-aggregate-operation.md", "diffHunk": "@@ -0,0 +1,274 @@\n+---\n+title: Build a Custom Aggregate Operation\n+description: How to create a custom aggregation operation using Jet\n+---\n+\n+One of the most important kind of processing Jet does is aggregation. In", "originalCommit": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NTE1OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2343#discussion_r442865159", "bodyText": "_aggregate function_, without backticks.", "author": "mtopolnik", "createdAt": "2020-06-19T14:14:26Z", "path": "site/docs/how-tos/custom-aggregate-operation.md", "diffHunk": "@@ -0,0 +1,274 @@\n+---\n+title: Build a Custom Aggregate Operation\n+description: How to create a custom aggregation operation using Jet\n+---\n+\n+One of the most important kind of processing Jet does is aggregation. In\n+general it is a transformation of a set of input values into a single\n+output value. The function that does this transformation is called the\n+`aggregate function`. A basic example is `sum` applied to a set of", "originalCommit": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3NTM3Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2343#discussion_r442875372", "bodyText": "(acc, n) -> {\n    acc.set1(acc.get1() + n); \n    acc.set2(acc.get2() + 1); \n}", "author": "mtopolnik", "createdAt": "2020-06-19T14:33:04Z", "path": "site/docs/how-tos/custom-aggregate-operation.md", "diffHunk": "@@ -0,0 +1,274 @@\n+---\n+title: Build a Custom Aggregate Operation\n+description: How to create a custom aggregation operation using Jet\n+---\n+\n+One of the most important kind of processing Jet does is aggregation. In\n+general it is a transformation of a set of input values into a single\n+output value. The function that does this transformation is called the\n+`aggregate function`. A basic example is `sum` applied to a set of\n+integer numbers, but the result can also be a complex value, for example\n+a list of all the input items.\n+\n+Jet's library contains a range of [predefined aggregate\n+functions](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperations.html),\n+but it also exposes an abstraction, called\n+[`AggregateOperation`](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperation.html),\n+that allows you to plug in your own. Since Jet does the aggregation in a\n+parallelized and distributed way, you can't simply supply a piece of\n+Java code that implements the aggregate function; we need you to break\n+it down into several smaller pieces that fit into Jet's processing\n+engine.\n+\n+## Characteristics of Distributed Aggregation\n+\n+The ability to compute the aggregate function in parallel comes at a\n+cost: Jet must be able to give a slice of the total data set to each\n+processing unit and then combine the partial results from all the units.\n+The combining step is crucial: it will only make sense if we're\n+combining the partial results of a _commutative associative_ function\n+(CA for short). On the example of `sum` this is trivial: we know from\n+elementary school that `+` is a CA operation. If you have a stream of\n+numbers: `{17, 37, 5, 11, 42}`, you can sum up `{17, 5}` separately from\n+`{42, 11, 37}` and then combine the partial sums (also note the\n+reordering of the elements).\n+\n+If you need something more complex, like `average`, it doesn't by itself\n+have this property; however if you add one more ingredient, the `finish`\n+function, you can express it easily. Jet allows you to first compute\n+some CA function, whose partial results can be combined, and then at the\n+very end apply the `finish` function on the fully combined result. To\n+compute the average, your CA function will output the pair `(sum,\n+count)`. Two such pairs are trivial to combine by summing each\n+component. The `finish` function will be `sum / count`.\n+\n+In addition to the mathematical side, there is also the practical one:\n+you have to provide Jet with a specific mutable object, called the\n+`accumulator`, which will keep the `running score` of the operation in\n+progress. For the `average` example, it would be something like\n+\n+```java\n+public class AvgAccumulator {\n+\n+    private long sum;\n+    private long count;\n+\n+    public void accumulate(long value) {\n+        sum += value;\n+        count++;\n+    }\n+\n+    public void combine(AvgAccumulator that) {\n+        this.sum += that.sum;\n+        this.count += that.sum;\n+    }\n+\n+    public double finish() {\n+        return (double) sum / count;\n+    }\n+}\n+```\n+\n+This object will also have to be [serializable](../api/serialization),\n+and preferably with Hazelcast's serialization instead of Java's because\n+in a group-and-aggregate operation there's one accumulator per each key\n+and all of them have to be sent across the network to be combined and\n+finished.\n+\n+## The Building Blocks\n+\n+Instead of requiring you to write a complete class from scratch, Jet\n+separates the concern of holding the accumulated state from that of the\n+computation performed on it. This means that you just need one\n+accumulator class for each kind of structure that holds the accumulated\n+data, as opposed to one for each aggregate operation. Jet's library\n+offers in the\n+[`com.hazelcast.jet.accumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/package-summary.html)\n+package several such classes, one of them being\n+[`LongLongAccumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/LongLongAccumulator.html),\n+which is a match for our `average` function. You'll just have to supply\n+the logic on top of it.\n+\n+Specifically, you have to provide a set of six functions (we call them\n+\"`primitives`\"):\n+\n+- `create` a new accumulator object.\n+- `accumulate` the data of an item by mutating the accumulator's state.\n+- `combine` the contents of the right-hand accumulator into the\n+  left-hand one.\n+- `deduct` the contents of the right-hand accumulator from the left-hand\n+  one (undo the effects of `combine`).\n+- `finish` accumulation by transforming the accumulator object into the\n+  final result.\n+- `export` the result of aggregation in a way that's not destructive for\n+  the accumulator (used in rolling aggregations).\n+\n+We already mentioned most of these above. The `deduct` primitive is\n+optional and Jet can manage without it, but if you are computing a\n+sliding window over an infinite stream, this primitive can give a\n+significant performance boost because it allows Jet to reuse the results\n+of the previous calculations.\n+\n+In a similar fashion Jet discerns between the `export` and `finish`\n+primitives for optimization purposes. Every function that works as the\n+`export` primitive will also work as `finish`, but you can specify a\n+different `finish` that reuses the state already allocated in the\n+accumulator. Jet applies `finish` only if it will never again use that\n+accumulator.\n+\n+If you happen to have a deeper familiarity with JDK's `java.util.stream`\n+API, you'll find `AggregateOperation` quite similar to\n+`java.util.stream.Collector`, which is also a holder of several\n+functional primitives. Jet's definitions are slightly different, though,\n+and there are the additional optimizing primitives we just mentioned.\n+\n+Let's see how this works with our `average` function. Using\n+`LongLongAccumulator` we can express our `accumulate` primitive as\n+\n+```java\n+(acc, n) -> {acc.set1(acc.get1() + n); acc.set2(acc.get2() + 1);", "originalCommit": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3NjMzOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2343#discussion_r442876339", "bodyText": "(left, right) -> {\n    left.set1(left.get1() + right.get1());\n    left.set2(left.get2() + right.get2());\n}", "author": "mtopolnik", "createdAt": "2020-06-19T14:34:54Z", "path": "site/docs/how-tos/custom-aggregate-operation.md", "diffHunk": "@@ -0,0 +1,274 @@\n+---\n+title: Build a Custom Aggregate Operation\n+description: How to create a custom aggregation operation using Jet\n+---\n+\n+One of the most important kind of processing Jet does is aggregation. In\n+general it is a transformation of a set of input values into a single\n+output value. The function that does this transformation is called the\n+`aggregate function`. A basic example is `sum` applied to a set of\n+integer numbers, but the result can also be a complex value, for example\n+a list of all the input items.\n+\n+Jet's library contains a range of [predefined aggregate\n+functions](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperations.html),\n+but it also exposes an abstraction, called\n+[`AggregateOperation`](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperation.html),\n+that allows you to plug in your own. Since Jet does the aggregation in a\n+parallelized and distributed way, you can't simply supply a piece of\n+Java code that implements the aggregate function; we need you to break\n+it down into several smaller pieces that fit into Jet's processing\n+engine.\n+\n+## Characteristics of Distributed Aggregation\n+\n+The ability to compute the aggregate function in parallel comes at a\n+cost: Jet must be able to give a slice of the total data set to each\n+processing unit and then combine the partial results from all the units.\n+The combining step is crucial: it will only make sense if we're\n+combining the partial results of a _commutative associative_ function\n+(CA for short). On the example of `sum` this is trivial: we know from\n+elementary school that `+` is a CA operation. If you have a stream of\n+numbers: `{17, 37, 5, 11, 42}`, you can sum up `{17, 5}` separately from\n+`{42, 11, 37}` and then combine the partial sums (also note the\n+reordering of the elements).\n+\n+If you need something more complex, like `average`, it doesn't by itself\n+have this property; however if you add one more ingredient, the `finish`\n+function, you can express it easily. Jet allows you to first compute\n+some CA function, whose partial results can be combined, and then at the\n+very end apply the `finish` function on the fully combined result. To\n+compute the average, your CA function will output the pair `(sum,\n+count)`. Two such pairs are trivial to combine by summing each\n+component. The `finish` function will be `sum / count`.\n+\n+In addition to the mathematical side, there is also the practical one:\n+you have to provide Jet with a specific mutable object, called the\n+`accumulator`, which will keep the `running score` of the operation in\n+progress. For the `average` example, it would be something like\n+\n+```java\n+public class AvgAccumulator {\n+\n+    private long sum;\n+    private long count;\n+\n+    public void accumulate(long value) {\n+        sum += value;\n+        count++;\n+    }\n+\n+    public void combine(AvgAccumulator that) {\n+        this.sum += that.sum;\n+        this.count += that.sum;\n+    }\n+\n+    public double finish() {\n+        return (double) sum / count;\n+    }\n+}\n+```\n+\n+This object will also have to be [serializable](../api/serialization),\n+and preferably with Hazelcast's serialization instead of Java's because\n+in a group-and-aggregate operation there's one accumulator per each key\n+and all of them have to be sent across the network to be combined and\n+finished.\n+\n+## The Building Blocks\n+\n+Instead of requiring you to write a complete class from scratch, Jet\n+separates the concern of holding the accumulated state from that of the\n+computation performed on it. This means that you just need one\n+accumulator class for each kind of structure that holds the accumulated\n+data, as opposed to one for each aggregate operation. Jet's library\n+offers in the\n+[`com.hazelcast.jet.accumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/package-summary.html)\n+package several such classes, one of them being\n+[`LongLongAccumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/LongLongAccumulator.html),\n+which is a match for our `average` function. You'll just have to supply\n+the logic on top of it.\n+\n+Specifically, you have to provide a set of six functions (we call them\n+\"`primitives`\"):\n+\n+- `create` a new accumulator object.\n+- `accumulate` the data of an item by mutating the accumulator's state.\n+- `combine` the contents of the right-hand accumulator into the\n+  left-hand one.\n+- `deduct` the contents of the right-hand accumulator from the left-hand\n+  one (undo the effects of `combine`).\n+- `finish` accumulation by transforming the accumulator object into the\n+  final result.\n+- `export` the result of aggregation in a way that's not destructive for\n+  the accumulator (used in rolling aggregations).\n+\n+We already mentioned most of these above. The `deduct` primitive is\n+optional and Jet can manage without it, but if you are computing a\n+sliding window over an infinite stream, this primitive can give a\n+significant performance boost because it allows Jet to reuse the results\n+of the previous calculations.\n+\n+In a similar fashion Jet discerns between the `export` and `finish`\n+primitives for optimization purposes. Every function that works as the\n+`export` primitive will also work as `finish`, but you can specify a\n+different `finish` that reuses the state already allocated in the\n+accumulator. Jet applies `finish` only if it will never again use that\n+accumulator.\n+\n+If you happen to have a deeper familiarity with JDK's `java.util.stream`\n+API, you'll find `AggregateOperation` quite similar to\n+`java.util.stream.Collector`, which is also a holder of several\n+functional primitives. Jet's definitions are slightly different, though,\n+and there are the additional optimizing primitives we just mentioned.\n+\n+Let's see how this works with our `average` function. Using\n+`LongLongAccumulator` we can express our `accumulate` primitive as\n+\n+```java\n+(acc, n) -> {acc.set1(acc.get1() + n); acc.set2(acc.get2() + 1);\n+```\n+\n+The `export`/`finish` primitive will be\n+\n+```java\n+acc -> (double) acc.get1() / acc.get2()\n+```\n+\n+Now we have to define the other three primitives to match our main\n+logic. For `create` we just refer to the constructor:\n+`LongLongAccumulator::new`. The `combine` primitive expects you to\n+update the left-hand accumulator with the contents of the right-hand\n+one, so:\n+\n+```java\n+(left, right) -> {left.set1(left.get1() + right.get1());\n+    left.set2(left.get2() + right.get2());\n+}\n+```", "originalCommit": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3NjgwMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2343#discussion_r442876802", "bodyText": "(left, right) -> {\n    left.set1(left.get1() - right.get1());\n    left.set2(left.get2() - right.get2());\n}", "author": "mtopolnik", "createdAt": "2020-06-19T14:35:41Z", "path": "site/docs/how-tos/custom-aggregate-operation.md", "diffHunk": "@@ -0,0 +1,274 @@\n+---\n+title: Build a Custom Aggregate Operation\n+description: How to create a custom aggregation operation using Jet\n+---\n+\n+One of the most important kind of processing Jet does is aggregation. In\n+general it is a transformation of a set of input values into a single\n+output value. The function that does this transformation is called the\n+`aggregate function`. A basic example is `sum` applied to a set of\n+integer numbers, but the result can also be a complex value, for example\n+a list of all the input items.\n+\n+Jet's library contains a range of [predefined aggregate\n+functions](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperations.html),\n+but it also exposes an abstraction, called\n+[`AggregateOperation`](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperation.html),\n+that allows you to plug in your own. Since Jet does the aggregation in a\n+parallelized and distributed way, you can't simply supply a piece of\n+Java code that implements the aggregate function; we need you to break\n+it down into several smaller pieces that fit into Jet's processing\n+engine.\n+\n+## Characteristics of Distributed Aggregation\n+\n+The ability to compute the aggregate function in parallel comes at a\n+cost: Jet must be able to give a slice of the total data set to each\n+processing unit and then combine the partial results from all the units.\n+The combining step is crucial: it will only make sense if we're\n+combining the partial results of a _commutative associative_ function\n+(CA for short). On the example of `sum` this is trivial: we know from\n+elementary school that `+` is a CA operation. If you have a stream of\n+numbers: `{17, 37, 5, 11, 42}`, you can sum up `{17, 5}` separately from\n+`{42, 11, 37}` and then combine the partial sums (also note the\n+reordering of the elements).\n+\n+If you need something more complex, like `average`, it doesn't by itself\n+have this property; however if you add one more ingredient, the `finish`\n+function, you can express it easily. Jet allows you to first compute\n+some CA function, whose partial results can be combined, and then at the\n+very end apply the `finish` function on the fully combined result. To\n+compute the average, your CA function will output the pair `(sum,\n+count)`. Two such pairs are trivial to combine by summing each\n+component. The `finish` function will be `sum / count`.\n+\n+In addition to the mathematical side, there is also the practical one:\n+you have to provide Jet with a specific mutable object, called the\n+`accumulator`, which will keep the `running score` of the operation in\n+progress. For the `average` example, it would be something like\n+\n+```java\n+public class AvgAccumulator {\n+\n+    private long sum;\n+    private long count;\n+\n+    public void accumulate(long value) {\n+        sum += value;\n+        count++;\n+    }\n+\n+    public void combine(AvgAccumulator that) {\n+        this.sum += that.sum;\n+        this.count += that.sum;\n+    }\n+\n+    public double finish() {\n+        return (double) sum / count;\n+    }\n+}\n+```\n+\n+This object will also have to be [serializable](../api/serialization),\n+and preferably with Hazelcast's serialization instead of Java's because\n+in a group-and-aggregate operation there's one accumulator per each key\n+and all of them have to be sent across the network to be combined and\n+finished.\n+\n+## The Building Blocks\n+\n+Instead of requiring you to write a complete class from scratch, Jet\n+separates the concern of holding the accumulated state from that of the\n+computation performed on it. This means that you just need one\n+accumulator class for each kind of structure that holds the accumulated\n+data, as opposed to one for each aggregate operation. Jet's library\n+offers in the\n+[`com.hazelcast.jet.accumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/package-summary.html)\n+package several such classes, one of them being\n+[`LongLongAccumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/LongLongAccumulator.html),\n+which is a match for our `average` function. You'll just have to supply\n+the logic on top of it.\n+\n+Specifically, you have to provide a set of six functions (we call them\n+\"`primitives`\"):\n+\n+- `create` a new accumulator object.\n+- `accumulate` the data of an item by mutating the accumulator's state.\n+- `combine` the contents of the right-hand accumulator into the\n+  left-hand one.\n+- `deduct` the contents of the right-hand accumulator from the left-hand\n+  one (undo the effects of `combine`).\n+- `finish` accumulation by transforming the accumulator object into the\n+  final result.\n+- `export` the result of aggregation in a way that's not destructive for\n+  the accumulator (used in rolling aggregations).\n+\n+We already mentioned most of these above. The `deduct` primitive is\n+optional and Jet can manage without it, but if you are computing a\n+sliding window over an infinite stream, this primitive can give a\n+significant performance boost because it allows Jet to reuse the results\n+of the previous calculations.\n+\n+In a similar fashion Jet discerns between the `export` and `finish`\n+primitives for optimization purposes. Every function that works as the\n+`export` primitive will also work as `finish`, but you can specify a\n+different `finish` that reuses the state already allocated in the\n+accumulator. Jet applies `finish` only if it will never again use that\n+accumulator.\n+\n+If you happen to have a deeper familiarity with JDK's `java.util.stream`\n+API, you'll find `AggregateOperation` quite similar to\n+`java.util.stream.Collector`, which is also a holder of several\n+functional primitives. Jet's definitions are slightly different, though,\n+and there are the additional optimizing primitives we just mentioned.\n+\n+Let's see how this works with our `average` function. Using\n+`LongLongAccumulator` we can express our `accumulate` primitive as\n+\n+```java\n+(acc, n) -> {acc.set1(acc.get1() + n); acc.set2(acc.get2() + 1);\n+```\n+\n+The `export`/`finish` primitive will be\n+\n+```java\n+acc -> (double) acc.get1() / acc.get2()\n+```\n+\n+Now we have to define the other three primitives to match our main\n+logic. For `create` we just refer to the constructor:\n+`LongLongAccumulator::new`. The `combine` primitive expects you to\n+update the left-hand accumulator with the contents of the right-hand\n+one, so:\n+\n+```java\n+(left, right) -> {left.set1(left.get1() + right.get1());\n+    left.set2(left.get2() + right.get2());\n+}\n+```\n+\n+Deducting must undo the effect of a previous `combine`:\n+\n+```java\n+(left, right) -> {left.set1(left.get1() - right.get1());\n+    left.set2(left.get2() - right.get2());\n+}\n+```", "originalCommit": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3OTAxOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2343#discussion_r442879019", "bodyText": "maybe the letter \"s\" can now come back to where it belongs? (delete space)", "author": "mtopolnik", "createdAt": "2020-06-19T14:39:42Z", "path": "site/docs/how-tos/custom-aggregate-operation.md", "diffHunk": "@@ -0,0 +1,274 @@\n+---\n+title: Build a Custom Aggregate Operation\n+description: How to create a custom aggregation operation using Jet\n+---\n+\n+One of the most important kind of processing Jet does is aggregation. In\n+general it is a transformation of a set of input values into a single\n+output value. The function that does this transformation is called the\n+`aggregate function`. A basic example is `sum` applied to a set of\n+integer numbers, but the result can also be a complex value, for example\n+a list of all the input items.\n+\n+Jet's library contains a range of [predefined aggregate\n+functions](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperations.html),\n+but it also exposes an abstraction, called\n+[`AggregateOperation`](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperation.html),\n+that allows you to plug in your own. Since Jet does the aggregation in a\n+parallelized and distributed way, you can't simply supply a piece of\n+Java code that implements the aggregate function; we need you to break\n+it down into several smaller pieces that fit into Jet's processing\n+engine.\n+\n+## Characteristics of Distributed Aggregation\n+\n+The ability to compute the aggregate function in parallel comes at a\n+cost: Jet must be able to give a slice of the total data set to each\n+processing unit and then combine the partial results from all the units.\n+The combining step is crucial: it will only make sense if we're\n+combining the partial results of a _commutative associative_ function\n+(CA for short). On the example of `sum` this is trivial: we know from\n+elementary school that `+` is a CA operation. If you have a stream of\n+numbers: `{17, 37, 5, 11, 42}`, you can sum up `{17, 5}` separately from\n+`{42, 11, 37}` and then combine the partial sums (also note the\n+reordering of the elements).\n+\n+If you need something more complex, like `average`, it doesn't by itself\n+have this property; however if you add one more ingredient, the `finish`\n+function, you can express it easily. Jet allows you to first compute\n+some CA function, whose partial results can be combined, and then at the\n+very end apply the `finish` function on the fully combined result. To\n+compute the average, your CA function will output the pair `(sum,\n+count)`. Two such pairs are trivial to combine by summing each\n+component. The `finish` function will be `sum / count`.\n+\n+In addition to the mathematical side, there is also the practical one:\n+you have to provide Jet with a specific mutable object, called the\n+`accumulator`, which will keep the `running score` of the operation in\n+progress. For the `average` example, it would be something like\n+\n+```java\n+public class AvgAccumulator {\n+\n+    private long sum;\n+    private long count;\n+\n+    public void accumulate(long value) {\n+        sum += value;\n+        count++;\n+    }\n+\n+    public void combine(AvgAccumulator that) {\n+        this.sum += that.sum;\n+        this.count += that.sum;\n+    }\n+\n+    public double finish() {\n+        return (double) sum / count;\n+    }\n+}\n+```\n+\n+This object will also have to be [serializable](../api/serialization),\n+and preferably with Hazelcast's serialization instead of Java's because\n+in a group-and-aggregate operation there's one accumulator per each key\n+and all of them have to be sent across the network to be combined and\n+finished.\n+\n+## The Building Blocks\n+\n+Instead of requiring you to write a complete class from scratch, Jet\n+separates the concern of holding the accumulated state from that of the\n+computation performed on it. This means that you just need one\n+accumulator class for each kind of structure that holds the accumulated\n+data, as opposed to one for each aggregate operation. Jet's library\n+offers in the\n+[`com.hazelcast.jet.accumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/package-summary.html)\n+package several such classes, one of them being\n+[`LongLongAccumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/LongLongAccumulator.html),\n+which is a match for our `average` function. You'll just have to supply\n+the logic on top of it.\n+\n+Specifically, you have to provide a set of six functions (we call them\n+\"`primitives`\"):\n+\n+- `create` a new accumulator object.\n+- `accumulate` the data of an item by mutating the accumulator's state.\n+- `combine` the contents of the right-hand accumulator into the\n+  left-hand one.\n+- `deduct` the contents of the right-hand accumulator from the left-hand\n+  one (undo the effects of `combine`).\n+- `finish` accumulation by transforming the accumulator object into the\n+  final result.\n+- `export` the result of aggregation in a way that's not destructive for\n+  the accumulator (used in rolling aggregations).\n+\n+We already mentioned most of these above. The `deduct` primitive is\n+optional and Jet can manage without it, but if you are computing a\n+sliding window over an infinite stream, this primitive can give a\n+significant performance boost because it allows Jet to reuse the results\n+of the previous calculations.\n+\n+In a similar fashion Jet discerns between the `export` and `finish`\n+primitives for optimization purposes. Every function that works as the\n+`export` primitive will also work as `finish`, but you can specify a\n+different `finish` that reuses the state already allocated in the\n+accumulator. Jet applies `finish` only if it will never again use that\n+accumulator.\n+\n+If you happen to have a deeper familiarity with JDK's `java.util.stream`\n+API, you'll find `AggregateOperation` quite similar to\n+`java.util.stream.Collector`, which is also a holder of several\n+functional primitives. Jet's definitions are slightly different, though,\n+and there are the additional optimizing primitives we just mentioned.\n+\n+Let's see how this works with our `average` function. Using\n+`LongLongAccumulator` we can express our `accumulate` primitive as\n+\n+```java\n+(acc, n) -> {acc.set1(acc.get1() + n); acc.set2(acc.get2() + 1);\n+```\n+\n+The `export`/`finish` primitive will be\n+\n+```java\n+acc -> (double) acc.get1() / acc.get2()\n+```\n+\n+Now we have to define the other three primitives to match our main\n+logic. For `create` we just refer to the constructor:\n+`LongLongAccumulator::new`. The `combine` primitive expects you to\n+update the left-hand accumulator with the contents of the right-hand\n+one, so:\n+\n+```java\n+(left, right) -> {left.set1(left.get1() + right.get1());\n+    left.set2(left.get2() + right.get2());\n+}\n+```\n+\n+Deducting must undo the effect of a previous `combine`:\n+\n+```java\n+(left, right) -> {left.set1(left.get1() - right.get1());\n+    left.set2(left.get2() - right.get2());\n+}\n+```\n+\n+All put together, we can define our averaging operation as follows:\n+\n+```java\n+AggregateOperation1<Long, LongLongAccumulator, Double> aggrOp = AggregateOperation\n+    .withCreate(LongLongAccumulator::new)\n+    .<Long>andAccumulate((acc, n) -> {\n+        acc.set1(acc.get1() + n);\n+        acc.set2(acc.get2() + 1);\n+    })\n+    .andCombine((left, right) -> {\n+        left.set1(left.get1() + right.get1());\n+        left.set2(left.get2() + right.get2());\n+    })\n+    .andDeduct((left, right) -> {\n+        left.set1(left.get1() - right.get1());\n+        left.set2(left.get2() - right.get2());\n+    })\n+    .andExportFinish(acc -> (double) acc.get1() / acc.get2());\n+```\n+\n+Let's stop for a second to look at the type we got:\n+`AggregateOperation1<Long, LongLongAccumulator, Double>`. Its type\n+parameters are:\n+\n+1. `Long`: the type of the input item\n+2. `LongLongAccumulator`: the type of the accumulator\n+3. `Double`: the type of the result\n+\n+Specifically note the `1` at the end of the type's name: it signifies\n+that it's the specialization of the general `AggregateOperation` to\n+exactly one input stream. In Hazelcast Jet you can also perform a\n+[co-aggregating](../api/stateful-transforms#co-group--join)\n+operation, aggregating several input streams together. Since the number\n+of input types is variable, the general `AggregateOperation` type cannot\n+statically capture them and we need separate subtypes. We decided to\n+statically support up to three input types; if you need more, you'll\n+have to resort to the less type-safe, general `AggregateOperation`.\n+\n+## Aggregating Over Multiple Inputs\n+\n+Hazelcast Jet can join several streams and simultaneously perform\n+aggregation on all of them. You specify a separate aggregate operation\n+for each input stream and have the opportunity to combine their results\n+when done. You can use aggregate operations [provided in the\n+library](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperations.html)\n+(see the section on\n+[co-aggregating](../api/stateful-transforms#co-group--join) for an\n+example).\n+\n+If you cannot express your aggregation logic using this approach, you\n+can also specify a custom multi-input aggregate operation that can\n+combine the items into the accumulator immediately as it receives them.\n+\n+We'll present a simple example on how to build a custom multi-input\n+aggregate operation. Note that the same logic can also be expressed\n+using separate single-input operations; the point of the example is\n+introducing the API.\n+\n+Say we are interested in the behavior of users in an online shop\n+application and want to gather the following statistics for each user:\n+\n+1. total load time of the visited product pages\n+2. quantity of items added to the shopping cart\n+3. amount paid for bought items\n+\n+This data is dispersed among separate datasets: `PageVisit`, `AddToCart`\n+and `Payment`. Note that in each case we're dealing with a simple `sum`\n+applied to a field in the input item. We can perform a\n+cogroup-and-aggregate transform with the following aggregate operation:\n+\n+```java\n+Pipeline p = Pipeline.create();\n+BatchStage<PageVisit> pageVisit = p.readFrom(Sources.list(\"pageVisit\"));\n+BatchStage<AddToCart> addToCart = p.readFrom(Sources.list(\"addToCart\"));\n+BatchStage<Payment> payment = p.readFrom(Sources.list(\"payment\"));\n+\n+AggregateOperation3<PageVisit, AddToCart, Payment, LongAccumulator[], long[]>\n+    aggrOp = AggregateOperation\n+        .withCreate(() -> new LongAccumulator[] {\n+            new LongAccumulator(),\n+            new LongAccumulator(),\n+            new LongAccumulator()\n+        })\n+        .<PageVisit>andAccumulate0((accs, pv) -> accs[0].add(pv.loadTime()))\n+        .<AddToCart>andAccumulate1((accs, atc) -> accs[1].add(atc.quantity()))\n+        .<Payment>andAccumulate2((accs, pm) -> accs[2].add(pm.amount()))\n+        .andCombine((accs1, accs2) -> {\n+            accs1[0].add(accs2[0]);\n+            accs1[1].add(accs2[1]);\n+            accs1[2].add(accs2[2]);\n+        })\n+        .andExportFinish(accs -> new long[] {\n+            accs[0].get(),\n+            accs[1].get(),\n+            accs[2].get()\n+        });\n+\n+BatchStage<Entry<Integer, long[]>> coGrouped =\n+    pageVisit.groupingKey(PageVisit::userId)\n+             .aggregate3(\n+                addToCart.groupingKey(AddToCart::userId),\n+                payment.groupingKey(Payment::userId),\n+                aggrOp\n+             );\n+```\n+\n+Note how we got an `AggregateOperation3` and how it captured each input\n+type. When we use it as an argument to a cogroup-and-aggregate\n+transform, the compiler will ensure that the `ComputeStage` s we attach", "originalCommit": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg3OTMxOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2343#discussion_r442879319", "bodyText": "\"to it\"", "author": "mtopolnik", "createdAt": "2020-06-19T14:40:17Z", "path": "site/docs/how-tos/custom-aggregate-operation.md", "diffHunk": "@@ -0,0 +1,274 @@\n+---\n+title: Build a Custom Aggregate Operation\n+description: How to create a custom aggregation operation using Jet\n+---\n+\n+One of the most important kind of processing Jet does is aggregation. In\n+general it is a transformation of a set of input values into a single\n+output value. The function that does this transformation is called the\n+`aggregate function`. A basic example is `sum` applied to a set of\n+integer numbers, but the result can also be a complex value, for example\n+a list of all the input items.\n+\n+Jet's library contains a range of [predefined aggregate\n+functions](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperations.html),\n+but it also exposes an abstraction, called\n+[`AggregateOperation`](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperation.html),\n+that allows you to plug in your own. Since Jet does the aggregation in a\n+parallelized and distributed way, you can't simply supply a piece of\n+Java code that implements the aggregate function; we need you to break\n+it down into several smaller pieces that fit into Jet's processing\n+engine.\n+\n+## Characteristics of Distributed Aggregation\n+\n+The ability to compute the aggregate function in parallel comes at a\n+cost: Jet must be able to give a slice of the total data set to each\n+processing unit and then combine the partial results from all the units.\n+The combining step is crucial: it will only make sense if we're\n+combining the partial results of a _commutative associative_ function\n+(CA for short). On the example of `sum` this is trivial: we know from\n+elementary school that `+` is a CA operation. If you have a stream of\n+numbers: `{17, 37, 5, 11, 42}`, you can sum up `{17, 5}` separately from\n+`{42, 11, 37}` and then combine the partial sums (also note the\n+reordering of the elements).\n+\n+If you need something more complex, like `average`, it doesn't by itself\n+have this property; however if you add one more ingredient, the `finish`\n+function, you can express it easily. Jet allows you to first compute\n+some CA function, whose partial results can be combined, and then at the\n+very end apply the `finish` function on the fully combined result. To\n+compute the average, your CA function will output the pair `(sum,\n+count)`. Two such pairs are trivial to combine by summing each\n+component. The `finish` function will be `sum / count`.\n+\n+In addition to the mathematical side, there is also the practical one:\n+you have to provide Jet with a specific mutable object, called the\n+`accumulator`, which will keep the `running score` of the operation in\n+progress. For the `average` example, it would be something like\n+\n+```java\n+public class AvgAccumulator {\n+\n+    private long sum;\n+    private long count;\n+\n+    public void accumulate(long value) {\n+        sum += value;\n+        count++;\n+    }\n+\n+    public void combine(AvgAccumulator that) {\n+        this.sum += that.sum;\n+        this.count += that.sum;\n+    }\n+\n+    public double finish() {\n+        return (double) sum / count;\n+    }\n+}\n+```\n+\n+This object will also have to be [serializable](../api/serialization),\n+and preferably with Hazelcast's serialization instead of Java's because\n+in a group-and-aggregate operation there's one accumulator per each key\n+and all of them have to be sent across the network to be combined and\n+finished.\n+\n+## The Building Blocks\n+\n+Instead of requiring you to write a complete class from scratch, Jet\n+separates the concern of holding the accumulated state from that of the\n+computation performed on it. This means that you just need one\n+accumulator class for each kind of structure that holds the accumulated\n+data, as opposed to one for each aggregate operation. Jet's library\n+offers in the\n+[`com.hazelcast.jet.accumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/package-summary.html)\n+package several such classes, one of them being\n+[`LongLongAccumulator`](/javadoc/{jet-version}/com/hazelcast/jet/accumulator/LongLongAccumulator.html),\n+which is a match for our `average` function. You'll just have to supply\n+the logic on top of it.\n+\n+Specifically, you have to provide a set of six functions (we call them\n+\"`primitives`\"):\n+\n+- `create` a new accumulator object.\n+- `accumulate` the data of an item by mutating the accumulator's state.\n+- `combine` the contents of the right-hand accumulator into the\n+  left-hand one.\n+- `deduct` the contents of the right-hand accumulator from the left-hand\n+  one (undo the effects of `combine`).\n+- `finish` accumulation by transforming the accumulator object into the\n+  final result.\n+- `export` the result of aggregation in a way that's not destructive for\n+  the accumulator (used in rolling aggregations).\n+\n+We already mentioned most of these above. The `deduct` primitive is\n+optional and Jet can manage without it, but if you are computing a\n+sliding window over an infinite stream, this primitive can give a\n+significant performance boost because it allows Jet to reuse the results\n+of the previous calculations.\n+\n+In a similar fashion Jet discerns between the `export` and `finish`\n+primitives for optimization purposes. Every function that works as the\n+`export` primitive will also work as `finish`, but you can specify a\n+different `finish` that reuses the state already allocated in the\n+accumulator. Jet applies `finish` only if it will never again use that\n+accumulator.\n+\n+If you happen to have a deeper familiarity with JDK's `java.util.stream`\n+API, you'll find `AggregateOperation` quite similar to\n+`java.util.stream.Collector`, which is also a holder of several\n+functional primitives. Jet's definitions are slightly different, though,\n+and there are the additional optimizing primitives we just mentioned.\n+\n+Let's see how this works with our `average` function. Using\n+`LongLongAccumulator` we can express our `accumulate` primitive as\n+\n+```java\n+(acc, n) -> {acc.set1(acc.get1() + n); acc.set2(acc.get2() + 1);\n+```\n+\n+The `export`/`finish` primitive will be\n+\n+```java\n+acc -> (double) acc.get1() / acc.get2()\n+```\n+\n+Now we have to define the other three primitives to match our main\n+logic. For `create` we just refer to the constructor:\n+`LongLongAccumulator::new`. The `combine` primitive expects you to\n+update the left-hand accumulator with the contents of the right-hand\n+one, so:\n+\n+```java\n+(left, right) -> {left.set1(left.get1() + right.get1());\n+    left.set2(left.get2() + right.get2());\n+}\n+```\n+\n+Deducting must undo the effect of a previous `combine`:\n+\n+```java\n+(left, right) -> {left.set1(left.get1() - right.get1());\n+    left.set2(left.get2() - right.get2());\n+}\n+```\n+\n+All put together, we can define our averaging operation as follows:\n+\n+```java\n+AggregateOperation1<Long, LongLongAccumulator, Double> aggrOp = AggregateOperation\n+    .withCreate(LongLongAccumulator::new)\n+    .<Long>andAccumulate((acc, n) -> {\n+        acc.set1(acc.get1() + n);\n+        acc.set2(acc.get2() + 1);\n+    })\n+    .andCombine((left, right) -> {\n+        left.set1(left.get1() + right.get1());\n+        left.set2(left.get2() + right.get2());\n+    })\n+    .andDeduct((left, right) -> {\n+        left.set1(left.get1() - right.get1());\n+        left.set2(left.get2() - right.get2());\n+    })\n+    .andExportFinish(acc -> (double) acc.get1() / acc.get2());\n+```\n+\n+Let's stop for a second to look at the type we got:\n+`AggregateOperation1<Long, LongLongAccumulator, Double>`. Its type\n+parameters are:\n+\n+1. `Long`: the type of the input item\n+2. `LongLongAccumulator`: the type of the accumulator\n+3. `Double`: the type of the result\n+\n+Specifically note the `1` at the end of the type's name: it signifies\n+that it's the specialization of the general `AggregateOperation` to\n+exactly one input stream. In Hazelcast Jet you can also perform a\n+[co-aggregating](../api/stateful-transforms#co-group--join)\n+operation, aggregating several input streams together. Since the number\n+of input types is variable, the general `AggregateOperation` type cannot\n+statically capture them and we need separate subtypes. We decided to\n+statically support up to three input types; if you need more, you'll\n+have to resort to the less type-safe, general `AggregateOperation`.\n+\n+## Aggregating Over Multiple Inputs\n+\n+Hazelcast Jet can join several streams and simultaneously perform\n+aggregation on all of them. You specify a separate aggregate operation\n+for each input stream and have the opportunity to combine their results\n+when done. You can use aggregate operations [provided in the\n+library](/javadoc/{jet-version}/com/hazelcast/jet/aggregate/AggregateOperations.html)\n+(see the section on\n+[co-aggregating](../api/stateful-transforms#co-group--join) for an\n+example).\n+\n+If you cannot express your aggregation logic using this approach, you\n+can also specify a custom multi-input aggregate operation that can\n+combine the items into the accumulator immediately as it receives them.\n+\n+We'll present a simple example on how to build a custom multi-input\n+aggregate operation. Note that the same logic can also be expressed\n+using separate single-input operations; the point of the example is\n+introducing the API.\n+\n+Say we are interested in the behavior of users in an online shop\n+application and want to gather the following statistics for each user:\n+\n+1. total load time of the visited product pages\n+2. quantity of items added to the shopping cart\n+3. amount paid for bought items\n+\n+This data is dispersed among separate datasets: `PageVisit`, `AddToCart`\n+and `Payment`. Note that in each case we're dealing with a simple `sum`\n+applied to a field in the input item. We can perform a\n+cogroup-and-aggregate transform with the following aggregate operation:\n+\n+```java\n+Pipeline p = Pipeline.create();\n+BatchStage<PageVisit> pageVisit = p.readFrom(Sources.list(\"pageVisit\"));\n+BatchStage<AddToCart> addToCart = p.readFrom(Sources.list(\"addToCart\"));\n+BatchStage<Payment> payment = p.readFrom(Sources.list(\"payment\"));\n+\n+AggregateOperation3<PageVisit, AddToCart, Payment, LongAccumulator[], long[]>\n+    aggrOp = AggregateOperation\n+        .withCreate(() -> new LongAccumulator[] {\n+            new LongAccumulator(),\n+            new LongAccumulator(),\n+            new LongAccumulator()\n+        })\n+        .<PageVisit>andAccumulate0((accs, pv) -> accs[0].add(pv.loadTime()))\n+        .<AddToCart>andAccumulate1((accs, atc) -> accs[1].add(atc.quantity()))\n+        .<Payment>andAccumulate2((accs, pm) -> accs[2].add(pm.amount()))\n+        .andCombine((accs1, accs2) -> {\n+            accs1[0].add(accs2[0]);\n+            accs1[1].add(accs2[1]);\n+            accs1[2].add(accs2[2]);\n+        })\n+        .andExportFinish(accs -> new long[] {\n+            accs[0].get(),\n+            accs[1].get(),\n+            accs[2].get()\n+        });\n+\n+BatchStage<Entry<Integer, long[]>> coGrouped =\n+    pageVisit.groupingKey(PageVisit::userId)\n+             .aggregate3(\n+                addToCart.groupingKey(AddToCart::userId),\n+                payment.groupingKey(Payment::userId),\n+                aggrOp\n+             );\n+```\n+\n+Note how we got an `AggregateOperation3` and how it captured each input\n+type. When we use it as an argument to a cogroup-and-aggregate\n+transform, the compiler will ensure that the `ComputeStage` s we attach\n+it to have the correct type and are in the correct order.", "originalCommit": "cf1abf6ce6f6ed493b6149e2cfc0897932862b4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b743180843981585870e546411a1a2064d8e8c3e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b743180843981585870e546411a1a2064d8e8c3e", "message": "address reviews", "committedDate": "2020-06-19T15:37:02Z", "type": "commit"}]}