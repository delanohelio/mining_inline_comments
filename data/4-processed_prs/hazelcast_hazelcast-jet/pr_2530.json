{"pr_number": 2530, "pr_title": "CDC blog post", "pr_createdAt": "2020-09-18T09:54:09Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2530", "timeline": [{"oid": "f40226715bed7558ba8d411dc387992039cb380f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f40226715bed7558ba8d411dc387992039cb380f", "message": "Add CDC blog post", "committedDate": "2020-09-18T09:52:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4NDk2MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490884960", "bodyText": "Does not explain what functionality change data capture technologies provide.", "author": "frant-hartm", "createdAt": "2020-09-18T11:30:46Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture", "originalCommit": "f40226715bed7558ba8d411dc387992039cb380f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5MzIxMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490893212", "bodyText": "Yes after reading whole article I think you should briefly explain what CDC is.", "author": "frant-hartm", "createdAt": "2020-09-18T11:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4NDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4NzQ4Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490887483", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              of- or even entire Debezium events can be interpreted\n          \n          \n            \n              of - or even entire Debezium events can be interpreted", "author": "frant-hartm", "createdAt": "2020-09-18T11:34:58Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of- or even entire Debezium events can be interpreted", "originalCommit": "f40226715bed7558ba8d411dc387992039cb380f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4ODYzNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490888636", "bodyText": "I would leave out this paragraph.", "author": "frant-hartm", "createdAt": "2020-09-18T11:36:50Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of- or even entire Debezium events can be interpreted\n+\n+For an example look at this sample from our [CDC\n+tutorial](https://jet-start.sh/docs/tutorials/cdc#6-define-jet-job). All\n+the code you would need to build an in-memory replica of your MySQL\n+database table would be something like:\n+\n+```java\n+StreamSource<ChangeRecord> source = MySqlCdcSources.mysql(\"source\")\n+        .setDatabaseAddress(\"127.0.0.1\")\n+        .setDatabasePort(3306)\n+        .setDatabaseUser(\"debezium\")\n+        .setDatabasePassword(\"dbz\")\n+        .setClusterName(\"dbserver1\")\n+        .setDatabaseWhitelist(\"inventory\")\n+        .setTableWhitelist(\"inventory.customers\")\n+        .build();\n+\n+Pipeline pipeline = Pipeline.create();\n+pipeline.readFrom(source)\n+        .withoutTimestamps()\n+        .peek()\n+        .writeTo(CdcSinks.map(\"customers\",\n+                r -> r.key().toMap().get(\"id\"),\n+                r -> r.value().toObject(Customer.class).toString()));\n+\n+JobConfig cfg = new JobConfig().setName(\"mysql-monitor\");\n+Jet.bootstrappedInstance().newJob(pipeline, cfg);\n+```\n+\n+One last service that Jet aims to add to Debezium\u2019s value is performance", "originalCommit": "f40226715bed7558ba8d411dc387992039cb380f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5MDU0Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490890543", "bodyText": "I can already tell you it was an unfortunate decision. It makes processing delete events difficult. I left out a delete operation from my elastic/cdc blog because of this.", "author": "frant-hartm", "createdAt": "2020-09-18T11:39:43Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of- or even entire Debezium events can be interpreted\n+\n+For an example look at this sample from our [CDC\n+tutorial](https://jet-start.sh/docs/tutorials/cdc#6-define-jet-job). All\n+the code you would need to build an in-memory replica of your MySQL\n+database table would be something like:\n+\n+```java\n+StreamSource<ChangeRecord> source = MySqlCdcSources.mysql(\"source\")\n+        .setDatabaseAddress(\"127.0.0.1\")\n+        .setDatabasePort(3306)\n+        .setDatabaseUser(\"debezium\")\n+        .setDatabasePassword(\"dbz\")\n+        .setClusterName(\"dbserver1\")\n+        .setDatabaseWhitelist(\"inventory\")\n+        .setTableWhitelist(\"inventory.customers\")\n+        .build();\n+\n+Pipeline pipeline = Pipeline.create();\n+pipeline.readFrom(source)\n+        .withoutTimestamps()\n+        .peek()\n+        .writeTo(CdcSinks.map(\"customers\",\n+                r -> r.key().toMap().get(\"id\"),\n+                r -> r.value().toObject(Customer.class).toString()));\n+\n+JobConfig cfg = new JobConfig().setName(\"mysql-monitor\");\n+Jet.bootstrappedInstance().newJob(pipeline, cfg);\n+```\n+\n+One last service that Jet aims to add to Debezium\u2019s value is performance\n+benchmarks. We want to measure both the performance impact of enabling\n+CDC on specific databases and the event throughput. This work is still\n+ongoing, we still have to publish our exact testing methodology, but the\n+results obtained so far are available [here](https://jet-start.sh/docs/next/design-docs/005-cdc-sources#performance).\n+\n+## Architecture\n+\n+I have stated above that when Debezium is integrated into Jet, the\n+latter takes on the role of service-provider as far as fault tolerance\n+and scalability are concerned.\n+\n+Jet doesn't delegate its cluster management and fault tolerance concerns\n+to an outside system like ZooKeeper. It reuses the groundwork\n+implemented for Hazelcast IMDG: cluster management and the IMap, and\n+adds its own implementation of Chandy-Lamport distributed snapshots. If\n+a cluster member fails, Jet will restart the job on the remaining\n+members, restore the state of processing from the last snapshot, and\n+then seamlessly continue from that point. For further details, consult\n+our [documentation on the\n+topic](https://jet-start.sh/docs/next/architecture/fault-tolerance).\n+\n+Extending this functionality umbrella to cover Debezium has been\n+surprisingly simple. All that was really needed was to add Debezium\u2019s\n+source offset to Jet\u2019s snapshots. This way, whenever Jet needs to\n+execute a recovery, it can also pass the recovered offset to Debezium,\n+which in turn is able to resume the data flow from that offset.\n+\n+One other thing we did and might be worth mentioning is that the Jet\n+integration also makes use of Debezium\u2019s [new record state\n+extraction](https://debezium.io/documentation/reference/1.2/configuration/event-flattening.html)\n+SMT (Simple Message Transformation), for the purpose of message\n+structure simplification. With this transformation in effect, only the\n+\"after\" structure of the Debezium event envelope is processed by Jet.\n+However, whether this is a good idea or not, only time will tell. I", "originalCommit": "f40226715bed7558ba8d411dc387992039cb380f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkwMjgwOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490902808", "bodyText": "As discussed on Slack, this is not really so for deletion. Delete events do have state/data/body and it's how the record looked before being deleted. Where you indeed only see the current image and not the previous one too is updates.\nWe can revisit this, but separately from the Blog. For now maybe I can improve some wording, to make it more clear, because if you have been mislead, then others will be too.", "author": "jbartok", "createdAt": "2020-09-18T12:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5MDU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5MTU1MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490891551", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When we will cover further connectors and if we will extend existing\n          \n          \n            \n            When we cover further connectors and if we extend existing", "author": "frant-hartm", "createdAt": "2020-09-18T11:41:13Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of- or even entire Debezium events can be interpreted\n+\n+For an example look at this sample from our [CDC\n+tutorial](https://jet-start.sh/docs/tutorials/cdc#6-define-jet-job). All\n+the code you would need to build an in-memory replica of your MySQL\n+database table would be something like:\n+\n+```java\n+StreamSource<ChangeRecord> source = MySqlCdcSources.mysql(\"source\")\n+        .setDatabaseAddress(\"127.0.0.1\")\n+        .setDatabasePort(3306)\n+        .setDatabaseUser(\"debezium\")\n+        .setDatabasePassword(\"dbz\")\n+        .setClusterName(\"dbserver1\")\n+        .setDatabaseWhitelist(\"inventory\")\n+        .setTableWhitelist(\"inventory.customers\")\n+        .build();\n+\n+Pipeline pipeline = Pipeline.create();\n+pipeline.readFrom(source)\n+        .withoutTimestamps()\n+        .peek()\n+        .writeTo(CdcSinks.map(\"customers\",\n+                r -> r.key().toMap().get(\"id\"),\n+                r -> r.value().toObject(Customer.class).toString()));\n+\n+JobConfig cfg = new JobConfig().setName(\"mysql-monitor\");\n+Jet.bootstrappedInstance().newJob(pipeline, cfg);\n+```\n+\n+One last service that Jet aims to add to Debezium\u2019s value is performance\n+benchmarks. We want to measure both the performance impact of enabling\n+CDC on specific databases and the event throughput. This work is still\n+ongoing, we still have to publish our exact testing methodology, but the\n+results obtained so far are available [here](https://jet-start.sh/docs/next/design-docs/005-cdc-sources#performance).\n+\n+## Architecture\n+\n+I have stated above that when Debezium is integrated into Jet, the\n+latter takes on the role of service-provider as far as fault tolerance\n+and scalability are concerned.\n+\n+Jet doesn't delegate its cluster management and fault tolerance concerns\n+to an outside system like ZooKeeper. It reuses the groundwork\n+implemented for Hazelcast IMDG: cluster management and the IMap, and\n+adds its own implementation of Chandy-Lamport distributed snapshots. If\n+a cluster member fails, Jet will restart the job on the remaining\n+members, restore the state of processing from the last snapshot, and\n+then seamlessly continue from that point. For further details, consult\n+our [documentation on the\n+topic](https://jet-start.sh/docs/next/architecture/fault-tolerance).\n+\n+Extending this functionality umbrella to cover Debezium has been\n+surprisingly simple. All that was really needed was to add Debezium\u2019s\n+source offset to Jet\u2019s snapshots. This way, whenever Jet needs to\n+execute a recovery, it can also pass the recovered offset to Debezium,\n+which in turn is able to resume the data flow from that offset.\n+\n+One other thing we did and might be worth mentioning is that the Jet\n+integration also makes use of Debezium\u2019s [new record state\n+extraction](https://debezium.io/documentation/reference/1.2/configuration/event-flattening.html)\n+SMT (Simple Message Transformation), for the purpose of message\n+structure simplification. With this transformation in effect, only the\n+\"after\" structure of the Debezium event envelope is processed by Jet.\n+However, whether this is a good idea or not, only time will tell. I\n+personally think that if and when we will start covering schema changes\n+more, we might end up re-enabling the full Debezium event content.\n+\n+## Examples\n+\n+The simplest example of using the Jet-Debezium integration would be our\n+[CDC tutorial](https://jet-start.sh/docs/next/tutorials/cdc) that I\u2019ve\n+already mentioned above. A more involved one can be seen in my\n+colleague\u2019s, Nicolas Fr\u00e4nkel\u2019s [blog\n+post](https://jet-start.sh/blog/2020/07/16/designing-evergreen-cache-cdc).\n+\n+## License\n+\n+The Jet - Debezium integration is currently provided under the [Apache\n+License, Version 2](https://www.apache.org/licenses/LICENSE-2.0.txt),\n+just like most of Jet and Debezium, so making full usage of the\n+combination of the two should have no impediments in your own projects.\n+\n+## Looking ahead\n+\n+At the moment of writing the Jet-Debezium integration is fully finished\n+only for MySQL and Postgres databases and has been [released in version\n+4.2](https://jet-start.sh/blog/2020/07/14/jet-42-is-released) of Jet.\n+When we will cover further connectors and if we will extend existing", "originalCommit": "f40226715bed7558ba8d411dc387992039cb380f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5Mjc3Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490892777", "bodyText": "Doesn't merger imply some cooperation between us and Debezium?\nMaybe use something more abstract, like synergy or whatever fancy word you can think of.", "author": "frant-hartm", "createdAt": "2020-09-18T11:43:27Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of- or even entire Debezium events can be interpreted\n+\n+For an example look at this sample from our [CDC\n+tutorial](https://jet-start.sh/docs/tutorials/cdc#6-define-jet-job). All\n+the code you would need to build an in-memory replica of your MySQL\n+database table would be something like:\n+\n+```java\n+StreamSource<ChangeRecord> source = MySqlCdcSources.mysql(\"source\")\n+        .setDatabaseAddress(\"127.0.0.1\")\n+        .setDatabasePort(3306)\n+        .setDatabaseUser(\"debezium\")\n+        .setDatabasePassword(\"dbz\")\n+        .setClusterName(\"dbserver1\")\n+        .setDatabaseWhitelist(\"inventory\")\n+        .setTableWhitelist(\"inventory.customers\")\n+        .build();\n+\n+Pipeline pipeline = Pipeline.create();\n+pipeline.readFrom(source)\n+        .withoutTimestamps()\n+        .peek()\n+        .writeTo(CdcSinks.map(\"customers\",\n+                r -> r.key().toMap().get(\"id\"),\n+                r -> r.value().toObject(Customer.class).toString()));\n+\n+JobConfig cfg = new JobConfig().setName(\"mysql-monitor\");\n+Jet.bootstrappedInstance().newJob(pipeline, cfg);\n+```\n+\n+One last service that Jet aims to add to Debezium\u2019s value is performance\n+benchmarks. We want to measure both the performance impact of enabling\n+CDC on specific databases and the event throughput. This work is still\n+ongoing, we still have to publish our exact testing methodology, but the\n+results obtained so far are available [here](https://jet-start.sh/docs/next/design-docs/005-cdc-sources#performance).\n+\n+## Architecture\n+\n+I have stated above that when Debezium is integrated into Jet, the\n+latter takes on the role of service-provider as far as fault tolerance\n+and scalability are concerned.\n+\n+Jet doesn't delegate its cluster management and fault tolerance concerns\n+to an outside system like ZooKeeper. It reuses the groundwork\n+implemented for Hazelcast IMDG: cluster management and the IMap, and\n+adds its own implementation of Chandy-Lamport distributed snapshots. If\n+a cluster member fails, Jet will restart the job on the remaining\n+members, restore the state of processing from the last snapshot, and\n+then seamlessly continue from that point. For further details, consult\n+our [documentation on the\n+topic](https://jet-start.sh/docs/next/architecture/fault-tolerance).\n+\n+Extending this functionality umbrella to cover Debezium has been\n+surprisingly simple. All that was really needed was to add Debezium\u2019s\n+source offset to Jet\u2019s snapshots. This way, whenever Jet needs to\n+execute a recovery, it can also pass the recovered offset to Debezium,\n+which in turn is able to resume the data flow from that offset.\n+\n+One other thing we did and might be worth mentioning is that the Jet\n+integration also makes use of Debezium\u2019s [new record state\n+extraction](https://debezium.io/documentation/reference/1.2/configuration/event-flattening.html)\n+SMT (Simple Message Transformation), for the purpose of message\n+structure simplification. With this transformation in effect, only the\n+\"after\" structure of the Debezium event envelope is processed by Jet.\n+However, whether this is a good idea or not, only time will tell. I\n+personally think that if and when we will start covering schema changes\n+more, we might end up re-enabling the full Debezium event content.\n+\n+## Examples\n+\n+The simplest example of using the Jet-Debezium integration would be our\n+[CDC tutorial](https://jet-start.sh/docs/next/tutorials/cdc) that I\u2019ve\n+already mentioned above. A more involved one can be seen in my\n+colleague\u2019s, Nicolas Fr\u00e4nkel\u2019s [blog\n+post](https://jet-start.sh/blog/2020/07/16/designing-evergreen-cache-cdc).\n+\n+## License\n+\n+The Jet - Debezium integration is currently provided under the [Apache\n+License, Version 2](https://www.apache.org/licenses/LICENSE-2.0.txt),\n+just like most of Jet and Debezium, so making full usage of the\n+combination of the two should have no impediments in your own projects.\n+\n+## Looking ahead\n+\n+At the moment of writing the Jet-Debezium integration is fully finished\n+only for MySQL and Postgres databases and has been [released in version\n+4.2](https://jet-start.sh/blog/2020/07/14/jet-42-is-released) of Jet.\n+When we will cover further connectors and if we will extend existing\n+ones (for example by adding handling for database schema changes),\n+remains to be seen.\n+\n+The functionality provided by Debezium, the ability to allow modern\n+processing of legacy data is a great fit to Jet\u2019s ability to carry out\n+that processing efficiently. The combination of the two has the\n+potential to become much more than the sum of their parts. I\u2019m very much\n+looking forward to finding out what this merger can lead to. Stay tuned!", "originalCommit": "f40226715bed7558ba8d411dc387992039cb380f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkwNDMwOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490904308", "bodyText": "Hook-up? ;)", "author": "jbartok", "createdAt": "2020-09-18T12:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5Mjc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkyMzc0Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490923743", "bodyText": "\"integration\" maybe", "author": "mtopolnik", "createdAt": "2020-09-18T12:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5Mjc3Nw=="}], "type": "inlineReview"}, {"oid": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "url": "https://github.com/hazelcast/hazelcast-jet/commit/836ec41c4f0b60df0fa95c647d8e77786282aa44", "message": "Update site/website/blog/2020-09-18-cdc-meets-stream-processing.md\n\nCo-authored-by: Franti\u0161ek Hartman <frant.hartm@gmail.com>", "committedDate": "2020-09-18T12:05:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNTY1Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490915652", "bodyText": "What's the diff here? Just curious :)", "author": "mtopolnik", "createdAt": "2020-09-18T12:30:33Z", "path": "site/website/blog/2020-04-01-upgrading-to-jet-40.md", "diffHunk": "@@ -158,8 +158,8 @@ We made multiple breaking changes in Jet\u2019s own APIs too:\n   `withUnorderedAsyncResponses()` were removed from `ServiceFactory`.\n   These properties are relevant only in the context of asynchronous\n   operations and were used in conjunction with\n-  `GeneralStage.mapUsingServiceAsync(\u2026\u200b)`. In Jet 4.0 the\n-  `GeneralStage.mapUsingServiceAsync(\u2026\u200b)` method has a new variant with\n+  `GeneralStage.mapUsingServiceAsync(\u2026)`. In Jet 4.0 the\n+  `GeneralStage.mapUsingServiceAsync(\u2026)` method has a new variant with", "originalCommit": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1NjM5Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490956397", "bodyText": "The old version includes this unicode character: ZERO WIDTH SPACE. It is visible when opening the file with Intellij.", "author": "ufukyilmaz", "createdAt": "2020-09-18T13:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNzc2NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490917765", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \u201cdumbed down\u201dversion (even as full-blown is light enough to be\n          \n          \n            \n            \u201cdumbed down\u201d version (even as full-blown is light enough to be", "author": "mtopolnik", "createdAt": "2020-09-18T12:34:51Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be", "originalCommit": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxODA4NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490918085", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n          \n          \n            \n            we used Debezium to build a Kafka Connect source for Jet. Well\u2026", "author": "mtopolnik", "createdAt": "2020-09-18T12:35:30Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026", "originalCommit": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxOTU0OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490919549", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n          \n          \n            \n              Jr](https://github.com/FasterXML/jackson-jr), to simplify how parts", "author": "mtopolnik", "createdAt": "2020-09-18T12:38:14Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts", "originalCommit": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg1MTA2Ng==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r491851066", "bodyText": "No, it's a small \"j\": https://github.com/FasterXML/jackson-jr\nI don't like it either, but it's how it is.", "author": "jbartok", "createdAt": "2020-09-21T07:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxOTU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkyMDA3OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490920079", "bodyText": "Delete this line", "author": "mtopolnik", "createdAt": "2020-09-18T12:39:20Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of - or even entire Debezium events can be interpreted\n+\n+For an example look at this sample from our [CDC\n+tutorial](https://jet-start.sh/docs/tutorials/cdc#6-define-jet-job). All\n+the code you would need to build an in-memory replica of your MySQL\n+database table would be something like:\n+\n+```java\n+StreamSource<ChangeRecord> source = MySqlCdcSources.mysql(\"source\")\n+        .setDatabaseAddress(\"127.0.0.1\")\n+        .setDatabasePort(3306)\n+        .setDatabaseUser(\"debezium\")\n+        .setDatabasePassword(\"dbz\")\n+        .setClusterName(\"dbserver1\")\n+        .setDatabaseWhitelist(\"inventory\")\n+        .setTableWhitelist(\"inventory.customers\")\n+        .build();\n+\n+Pipeline pipeline = Pipeline.create();\n+pipeline.readFrom(source)\n+        .withoutTimestamps()\n+        .peek()", "originalCommit": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkyMTc4OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490921789", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            surprisingly simple. All that was really needed was to add Debezium\u2019s\n          \n          \n            \n            surprisingly simple. All we had to do was add Debezium\u2019s", "author": "mtopolnik", "createdAt": "2020-09-18T12:42:27Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of - or even entire Debezium events can be interpreted\n+\n+For an example look at this sample from our [CDC\n+tutorial](https://jet-start.sh/docs/tutorials/cdc#6-define-jet-job). All\n+the code you would need to build an in-memory replica of your MySQL\n+database table would be something like:\n+\n+```java\n+StreamSource<ChangeRecord> source = MySqlCdcSources.mysql(\"source\")\n+        .setDatabaseAddress(\"127.0.0.1\")\n+        .setDatabasePort(3306)\n+        .setDatabaseUser(\"debezium\")\n+        .setDatabasePassword(\"dbz\")\n+        .setClusterName(\"dbserver1\")\n+        .setDatabaseWhitelist(\"inventory\")\n+        .setTableWhitelist(\"inventory.customers\")\n+        .build();\n+\n+Pipeline pipeline = Pipeline.create();\n+pipeline.readFrom(source)\n+        .withoutTimestamps()\n+        .peek()\n+        .writeTo(CdcSinks.map(\"customers\",\n+                r -> r.key().toMap().get(\"id\"),\n+                r -> r.value().toObject(Customer.class).toString()));\n+\n+JobConfig cfg = new JobConfig().setName(\"mysql-monitor\");\n+Jet.bootstrappedInstance().newJob(pipeline, cfg);\n+```\n+\n+One last service that Jet aims to add to Debezium\u2019s value is performance\n+benchmarks. We want to measure both the performance impact of enabling\n+CDC on specific databases and the event throughput. This work is still\n+ongoing, we still have to publish our exact testing methodology, but the\n+results obtained so far are available [here](https://jet-start.sh/docs/next/design-docs/005-cdc-sources#performance).\n+\n+## Architecture\n+\n+I have stated above that when Debezium is integrated into Jet, the\n+latter takes on the role of service-provider as far as fault tolerance\n+and scalability are concerned.\n+\n+Jet doesn't delegate its cluster management and fault tolerance concerns\n+to an outside system like ZooKeeper. It reuses the groundwork\n+implemented for Hazelcast IMDG: cluster management and the IMap, and\n+adds its own implementation of Chandy-Lamport distributed snapshots. If\n+a cluster member fails, Jet will restart the job on the remaining\n+members, restore the state of processing from the last snapshot, and\n+then seamlessly continue from that point. For further details, consult\n+our [documentation on the\n+topic](https://jet-start.sh/docs/next/architecture/fault-tolerance).\n+\n+Extending this functionality umbrella to cover Debezium has been\n+surprisingly simple. All that was really needed was to add Debezium\u2019s", "originalCommit": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkyMjQ0MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490922441", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            execute a recovery, it can also pass the recovered offset to Debezium,\n          \n          \n            \n            execute a recovery, it passes the recovered offset to Debezium,", "author": "mtopolnik", "createdAt": "2020-09-18T12:43:36Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of - or even entire Debezium events can be interpreted\n+\n+For an example look at this sample from our [CDC\n+tutorial](https://jet-start.sh/docs/tutorials/cdc#6-define-jet-job). All\n+the code you would need to build an in-memory replica of your MySQL\n+database table would be something like:\n+\n+```java\n+StreamSource<ChangeRecord> source = MySqlCdcSources.mysql(\"source\")\n+        .setDatabaseAddress(\"127.0.0.1\")\n+        .setDatabasePort(3306)\n+        .setDatabaseUser(\"debezium\")\n+        .setDatabasePassword(\"dbz\")\n+        .setClusterName(\"dbserver1\")\n+        .setDatabaseWhitelist(\"inventory\")\n+        .setTableWhitelist(\"inventory.customers\")\n+        .build();\n+\n+Pipeline pipeline = Pipeline.create();\n+pipeline.readFrom(source)\n+        .withoutTimestamps()\n+        .peek()\n+        .writeTo(CdcSinks.map(\"customers\",\n+                r -> r.key().toMap().get(\"id\"),\n+                r -> r.value().toObject(Customer.class).toString()));\n+\n+JobConfig cfg = new JobConfig().setName(\"mysql-monitor\");\n+Jet.bootstrappedInstance().newJob(pipeline, cfg);\n+```\n+\n+One last service that Jet aims to add to Debezium\u2019s value is performance\n+benchmarks. We want to measure both the performance impact of enabling\n+CDC on specific databases and the event throughput. This work is still\n+ongoing, we still have to publish our exact testing methodology, but the\n+results obtained so far are available [here](https://jet-start.sh/docs/next/design-docs/005-cdc-sources#performance).\n+\n+## Architecture\n+\n+I have stated above that when Debezium is integrated into Jet, the\n+latter takes on the role of service-provider as far as fault tolerance\n+and scalability are concerned.\n+\n+Jet doesn't delegate its cluster management and fault tolerance concerns\n+to an outside system like ZooKeeper. It reuses the groundwork\n+implemented for Hazelcast IMDG: cluster management and the IMap, and\n+adds its own implementation of Chandy-Lamport distributed snapshots. If\n+a cluster member fails, Jet will restart the job on the remaining\n+members, restore the state of processing from the last snapshot, and\n+then seamlessly continue from that point. For further details, consult\n+our [documentation on the\n+topic](https://jet-start.sh/docs/next/architecture/fault-tolerance).\n+\n+Extending this functionality umbrella to cover Debezium has been\n+surprisingly simple. All that was really needed was to add Debezium\u2019s\n+source offset to Jet\u2019s snapshots. This way, whenever Jet needs to\n+execute a recovery, it can also pass the recovered offset to Debezium,", "originalCommit": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkyMjU3MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r490922571", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            which in turn is able to resume the data flow from that offset.\n          \n          \n            \n            which in turn resumes the data flow from that offset.", "author": "mtopolnik", "createdAt": "2020-09-18T12:43:52Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -0,0 +1,178 @@\n+---\n+title: Change Data Capture meets Stream Processing\n+description: Debezium based Change Data Capture sources for Hazelcast Jet\n+author: Bart\u00f3k J\u00f3zsef\n+authorURL: https://www.linkedin.com/in/bjozsef/\n+authorImageURL: https://www.itdays.ro/public/images/speakers-big/Jozsef_Bartok.jpg\n+---\n+\n+## Introduction\n+\n+Hazelcast Jet is a distributed, lightweight stream processing framework.\n+It allows you to write modern Java code that focuses purely on data\n+transformation while it does all the heavy lifting of getting the data\n+flowing and computation running across a cluster of nodes. Jet stores\n+computational state in [fault-tolerant, distributed in-memory\n+storage](https://jet-start.sh/docs/api/data-structures), allowing\n+thousands of concurrent users granular and fast access to your data\n+without breaking a sweat.\n+\n+While stream processing is a natural solution for providing insight into\n+many big-data workloads, it\u2019s a relatively new evolution over its\n+predecessor - offline batch processing. Utilizing stream processing\n+effectively requires re-architecting existing systems to event-driven\n+architectures and introducing several new components. This process is\n+not always straightforward and also requires a shift in mindset.\n+\n+In this context, the functionality provided by change data capture\n+technologies, for which Debezium is one of the, if not THE best\n+open-source alternative, is a godsend. To be able to ingest data from\n+relational databases, without affecting the applications that use them,\n+changes the game for streaming systems. It becomes possible to safely\n+extend old systems with all kinds of new functionality: real-time\n+analytics, complex event processing, anomaly & fraud detection and so\n+on.\n+\n+## Integration\n+\n+When we first considered integrating Debezium into Jet, the most\n+important decisions were centered around the fact that Debezium is\n+designed to be deployed via Apache [Kafka\n+Connect](https://kafka.apache.org/documentation/#connect), which then\n+takes care of *fault tolerance* and *scalability*. Fortunately, Jet is\n+fully capable of providing these crucial services. Also, Kafka Connect\n+is a good enough abstraction that we were able to mimic it for Debezium.\n+\n+We are aware that Debezium also offers an *embedded mode* for\n+applications not interested in fault-tolerance guarantees such as\n+exactly-once processing and resilience, but since Jet does not have a\n+\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+embedded), we quickly discarded this approach.\n+\n+So, first, we added generic support for Kafka Connect sources to Jet,\n+which should be a valuable feature even outside the scope of CDC. Then\n+we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n+\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n+source. We just had to make sure that Jet\u2019s specific fault-tolerance\n+mechanisms will interact with it properly, through the Kafka Connect\n+API.\n+\n+## Synergy\n+\n+One immediate benefit that Jet offers to Debezium users is eliminating\n+the need for *external services*. No Zookeeper, no Kafka needed. When\n+using Debezium through Jet, the latter takes care of the whole lifecycle\n+and fault tolerance of all the components involved. The setup is greatly\n+simplified.\n+\n+Then, obviously, there is the *stream processing capability*, because\n+that\u2019s what Jet does. Not only do you get access to the data, but you\n+also have the toolbox to process it, extract whatever insights you need\n+from it.\n+\n+In addition, Jet also aims to offer *further convenience* wrappers when\n+the Debezium source is being used. For example:\n+\n+* builders for the most common configuration properties to make setting\n+  up Debezium for some specific DB as simple as possible\n+* standard Java interfaces to give structure to the complex Debezium\n+  events\n+* JSON parsing, including mapping to Objects, based on [Jackson\n+  jr](https://github.com/FasterXML/jackson-jr), to simplify how parts\n+  of - or even entire Debezium events can be interpreted\n+\n+For an example look at this sample from our [CDC\n+tutorial](https://jet-start.sh/docs/tutorials/cdc#6-define-jet-job). All\n+the code you would need to build an in-memory replica of your MySQL\n+database table would be something like:\n+\n+```java\n+StreamSource<ChangeRecord> source = MySqlCdcSources.mysql(\"source\")\n+        .setDatabaseAddress(\"127.0.0.1\")\n+        .setDatabasePort(3306)\n+        .setDatabaseUser(\"debezium\")\n+        .setDatabasePassword(\"dbz\")\n+        .setClusterName(\"dbserver1\")\n+        .setDatabaseWhitelist(\"inventory\")\n+        .setTableWhitelist(\"inventory.customers\")\n+        .build();\n+\n+Pipeline pipeline = Pipeline.create();\n+pipeline.readFrom(source)\n+        .withoutTimestamps()\n+        .peek()\n+        .writeTo(CdcSinks.map(\"customers\",\n+                r -> r.key().toMap().get(\"id\"),\n+                r -> r.value().toObject(Customer.class).toString()));\n+\n+JobConfig cfg = new JobConfig().setName(\"mysql-monitor\");\n+Jet.bootstrappedInstance().newJob(pipeline, cfg);\n+```\n+\n+One last service that Jet aims to add to Debezium\u2019s value is performance\n+benchmarks. We want to measure both the performance impact of enabling\n+CDC on specific databases and the event throughput. This work is still\n+ongoing, we still have to publish our exact testing methodology, but the\n+results obtained so far are available [here](https://jet-start.sh/docs/next/design-docs/005-cdc-sources#performance).\n+\n+## Architecture\n+\n+I have stated above that when Debezium is integrated into Jet, the\n+latter takes on the role of service-provider as far as fault tolerance\n+and scalability are concerned.\n+\n+Jet doesn't delegate its cluster management and fault tolerance concerns\n+to an outside system like ZooKeeper. It reuses the groundwork\n+implemented for Hazelcast IMDG: cluster management and the IMap, and\n+adds its own implementation of Chandy-Lamport distributed snapshots. If\n+a cluster member fails, Jet will restart the job on the remaining\n+members, restore the state of processing from the last snapshot, and\n+then seamlessly continue from that point. For further details, consult\n+our [documentation on the\n+topic](https://jet-start.sh/docs/next/architecture/fault-tolerance).\n+\n+Extending this functionality umbrella to cover Debezium has been\n+surprisingly simple. All that was really needed was to add Debezium\u2019s\n+source offset to Jet\u2019s snapshots. This way, whenever Jet needs to\n+execute a recovery, it can also pass the recovered offset to Debezium,\n+which in turn is able to resume the data flow from that offset.", "originalCommit": "836ec41c4f0b60df0fa95c647d8e77786282aa44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e000d15754e3936826ead5b8fc0c2102e26651d7", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e000d15754e3936826ead5b8fc0c2102e26651d7", "message": "Address review concerns", "committedDate": "2020-09-21T07:57:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkzOTY2Ng==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2530#discussion_r491939666", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            we used Debezium to build a Kafka Connect source for Jet. Well\u2026\u201cbuild\u201d\n          \n          \n            \n            we used Debezium to build a Kafka Connect source for Jet. Well\u2026 \u201cbuild\u201d", "author": "mtopolnik", "createdAt": "2020-09-21T10:28:45Z", "path": "site/website/blog/2020-09-18-cdc-meets-stream-processing.md", "diffHunk": "@@ -46,16 +50,15 @@ is a good enough abstraction that we were able to mimic it for Debezium.\n We are aware that Debezium also offers an *embedded mode* for\n applications not interested in fault-tolerance guarantees such as\n exactly-once processing and resilience, but since Jet does not have a\n-\u201cdumbed down\u201dversion (even as full-blown is light enough to be\n+\u201cdumbed down\u201d version (even as full-blown is light enough to be\n embedded), we quickly discarded this approach.\n \n So, first, we added generic support for Kafka Connect sources to Jet,\n which should be a valuable feature even outside the scope of CDC. Then\n-we\u2019ve used Debezium to build a Kafka Connect source for Jet. Well\u2026\n-\u201cbuild\u201d might be overstating it. Debezium already is a Kafka Connect\n-source. We just had to make sure that Jet\u2019s specific fault-tolerance\n-mechanisms will interact with it properly, through the Kafka Connect\n-API.\n+we used Debezium to build a Kafka Connect source for Jet. Well\u2026\u201cbuild\u201d", "originalCommit": "e000d15754e3936826ead5b8fc0c2102e26651d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0055fcdb1c66eb6693875c16cb7f3d123e5d2f87", "url": "https://github.com/hazelcast/hazelcast-jet/commit/0055fcdb1c66eb6693875c16cb7f3d123e5d2f87", "message": "Add missing space", "committedDate": "2020-09-21T10:30:57Z", "type": "commit"}]}