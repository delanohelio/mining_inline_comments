{"pr_number": 9256, "pr_title": "Provides the ability to customize the apikey generation and signing.", "pr_createdAt": "2020-09-02T05:22:11Z", "pr_url": "https://github.com/wso2/carbon-apimgt/pull/9256", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTcyNDAwMg==", "url": "https://github.com/wso2/carbon-apimgt/pull/9256#discussion_r481724002", "bodyText": "Change the license header to 2020", "author": "ChamodDamitha", "createdAt": "2020-09-02T05:29:54Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/token/DefaultApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "originalCommit": "b5a8919a43c112dd33242bb0d68f78d3909552ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTcyNDE3NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/9256#discussion_r481724175", "bodyText": "add new line", "author": "ChamodDamitha", "createdAt": "2020-09-02T05:30:07Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/token/ApiKeyGenerator.java", "diffHunk": "@@ -1,136 +1,39 @@\n /*\n- * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n  *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n  *\n- * http://www.apache.org/licenses/LICENSE-2.0\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n  *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n  */\n \n package org.wso2.carbon.apimgt.impl.token;\n \n-import com.nimbusds.jwt.JWTClaimsSet;\n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n-import org.json.JSONObject;\n import org.wso2.carbon.apimgt.api.APIManagementException;\n-import org.wso2.carbon.apimgt.impl.APIConstants;\n import org.wso2.carbon.apimgt.impl.dto.JwtTokenInfoDTO;\n-import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n-import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n-import org.wso2.carbon.core.util.KeyStoreManager;\n-import org.wso2.carbon.utils.multitenancy.MultitenantConstants;\n \n-import java.nio.charset.Charset;\n-import java.security.PrivateKey;\n-import java.security.cert.Certificate;\n-import java.util.UUID;\n-import java.util.concurrent.TimeUnit;\n-\n-public class ApiKeyGenerator {\n-\n-    private static final Log log = LogFactory.getLog(ApiKeyGenerator.class);\n-\n-    public static String generateToken(JwtTokenInfoDTO jwtTokenInfoDTO) throws APIManagementException {\n-\n-        String jwtHeader = buildHeader();\n-        String base64UrlEncodedHeader = \"\";\n-        if (jwtHeader != null) {\n-            base64UrlEncodedHeader = encode(jwtHeader.getBytes(Charset.defaultCharset()));\n-        }\n-\n-        String jwtBody = buildBody(jwtTokenInfoDTO);\n-        String base64UrlEncodedBody = \"\";\n-        if (jwtBody != null) {\n-            base64UrlEncodedBody = encode(jwtBody.getBytes());\n-        }\n-\n-        String assertion = base64UrlEncodedHeader + '.' + base64UrlEncodedBody;\n-        //get the assertion signed\n-        byte[] signedAssertion = buildSignature(assertion);\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"signed assertion value : \" + new String(signedAssertion, Charset.defaultCharset()));\n-        }\n-        String base64UrlEncodedAssertion = encode(signedAssertion);\n-\n-        return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.' + base64UrlEncodedAssertion;\n-    }\n-\n-    private static String buildBody(JwtTokenInfoDTO jwtTokenInfoDTO) {\n-        long currentTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n-        long expireIn;\n-        if (jwtTokenInfoDTO.getExpirationTime() == -1 ||\n-                jwtTokenInfoDTO.getExpirationTime() > (Integer.MAX_VALUE-currentTime)) {\n-            expireIn = -1;\n-        } else {\n-            expireIn = currentTime + jwtTokenInfoDTO.getExpirationTime();\n-        }\n-        String issuerIdentifier = ServiceReferenceHolder.getInstance().getOauthServerConfiguration()\n-                .getOpenIDConnectIDTokenIssuerIdentifier();\n-        JWTClaimsSet.Builder jwtClaimsSetBuilder = new JWTClaimsSet.Builder();\n-        jwtClaimsSetBuilder.claim(\"sub\", APIUtil.getUserNameWithTenantSuffix(jwtTokenInfoDTO.getEndUserName()));\n-        jwtClaimsSetBuilder.claim(\"jti\", UUID.randomUUID().toString());\n-        jwtClaimsSetBuilder.claim(\"iss\", issuerIdentifier);\n-        jwtClaimsSetBuilder.claim(\"iat\", currentTime);\n-        if (expireIn != -1) {\n-            jwtClaimsSetBuilder.claim(\"exp\", expireIn);\n-        }\n-        jwtClaimsSetBuilder.claim(\"subscribedAPIs\", jwtTokenInfoDTO.getSubscribedApiDTOList());\n-        jwtClaimsSetBuilder.claim(\"tierInfo\", jwtTokenInfoDTO.getSubscriptionPolicyDTOList());\n-        jwtClaimsSetBuilder.claim(\"application\", jwtTokenInfoDTO.getApplication());\n-        jwtClaimsSetBuilder.claim(\"keytype\", jwtTokenInfoDTO.getKeyType());\n-\n-        if (jwtTokenInfoDTO.getPermittedIP() != null) {\n-            jwtClaimsSetBuilder.claim(APIConstants.JwtTokenConstants.PERMITTED_IP, jwtTokenInfoDTO.getPermittedIP());\n-        }\n-        if (jwtTokenInfoDTO.getPermittedReferer() != null) {\n-            jwtClaimsSetBuilder.claim(APIConstants.JwtTokenConstants.PERMITTED_REFERER, jwtTokenInfoDTO.getPermittedReferer());\n-        }\n-\n-        return jwtClaimsSetBuilder.build().toJSONObject().toJSONString();\n-    }\n-\n-    private static String buildHeader() throws APIManagementException {\n-        Certificate publicCert;\n-        JSONObject headerWithKid;\n-        try {\n-            KeyStoreManager tenantKSM = KeyStoreManager.getInstance(MultitenantConstants.SUPER_TENANT_ID);\n-            publicCert = tenantKSM.getDefaultPrimaryCertificate();\n-            String headerWithoutKid = APIUtil.generateHeader(publicCert, APIConstants.SIGNATURE_ALGORITHM_SHA256_WITH_RSA);\n-            headerWithKid = new JSONObject(headerWithoutKid);\n-            headerWithKid.put(\"kid\", APIUtil.getApiKeyAlias());\n-\n-        } catch (Exception e) {\n-            throw new APIManagementException(\"Error while building Api key header\", e);\n-        }\n-        return headerWithKid.toString();\n-    }\n-\n-    private static byte[] buildSignature(String assertion) throws APIManagementException {\n-        PrivateKey privateKey;\n-        //get super tenant's key store manager\n-        KeyStoreManager tenantKSM = KeyStoreManager.getInstance(MultitenantConstants.SUPER_TENANT_ID);\n-        try {\n-            privateKey = tenantKSM.getDefaultPrivateKey();\n-        } catch (Exception e) {\n-            throw new APIManagementException(\"Error while signing Api Key\", e);\n-        }\n-        return APIUtil.signJwt(assertion, privateKey, \"SHA256withRSA\");\n-    }\n-\n-    private static String encode(byte[] stringToBeEncoded) throws APIManagementException {\n-        try {\n-            return java.util.Base64.getUrlEncoder().encodeToString(stringToBeEncoded);\n-        } catch (Exception e) {\n-            throw new APIManagementException(\"Error while encoding the Api Key \",e);\n-        }\n-    }\n-\n-}\n+/**\n+ * This interface encapsulates an apikey generator\n+ * Anyone trying to customize the apikey generation or signing can either implement the interface or extend the default\n+ * implementation given in org.wso2.carbon.apimgt.impl.token.DefaultApiKeyGenerator and mention the fully qualified class name\n+ * in deployment.toml\n+ * [apim.devportal]\n+ * api_key_generator_impl = <fully qualified class name>\n+ *\n+ */\n+public interface ApiKeyGenerator {\n+    /**\n+     * Generates and signs the apikey, which can be used for the authorization of APIs deployed at gateways\n+     * @param jwtTokenInfoDTO\n+     * @return the signed apikey as a string\n+     * @throws org.wso2.carbon.apimgt.api.APIManagementException\n+     */\n+    String generateToken(JwtTokenInfoDTO jwtTokenInfoDTO) throws APIManagementException;\n+}", "originalCommit": "b5a8919a43c112dd33242bb0d68f78d3909552ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTcyNDM4NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/9256#discussion_r481724385", "bodyText": "add new line", "author": "ChamodDamitha", "createdAt": "2020-09-02T05:30:20Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/token/DefaultApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.token;\n+\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dto.JwtTokenInfoDTO;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.api.ServerConfigurationService;\n+import org.wso2.carbon.core.util.KeyStoreManager;\n+import org.wso2.carbon.identity.oauth.config.OAuthServerConfiguration;\n+import org.wso2.carbon.utils.multitenancy.MultitenantConstants;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.charset.Charset;\n+import java.security.*;\n+import java.security.cert.Certificate;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DefaultApiKeyGenerator implements ApiKeyGenerator {\n+\n+    private static final Log log = LogFactory.getLog(DefaultApiKeyGenerator.class);\n+\n+    public DefaultApiKeyGenerator() {\n+    }\n+\n+    public String generateToken(JwtTokenInfoDTO jwtTokenInfoDTO) throws APIManagementException {\n+\n+        String jwtHeader = buildHeader();\n+        String base64UrlEncodedHeader = \"\";\n+        if (jwtHeader != null) {\n+            base64UrlEncodedHeader = encode(jwtHeader.getBytes(Charset.defaultCharset()));\n+        }\n+\n+        String jwtBody = buildBody(jwtTokenInfoDTO);\n+        String base64UrlEncodedBody = \"\";\n+        if (jwtBody != null) {\n+            base64UrlEncodedBody = encode(jwtBody.getBytes());\n+        }\n+\n+        String assertion = base64UrlEncodedHeader + '.' + base64UrlEncodedBody;\n+        //get the assertion signed\n+        byte[] signedAssertion = buildSignature(assertion);\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"signed assertion value : \" + new String(signedAssertion, Charset.defaultCharset()));\n+        }\n+        String base64UrlEncodedAssertion = encode(signedAssertion);\n+\n+        return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.' + base64UrlEncodedAssertion;\n+    }\n+\n+    protected String buildBody(JwtTokenInfoDTO jwtTokenInfoDTO) {\n+        long currentTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n+        long expireIn;\n+        if (jwtTokenInfoDTO.getExpirationTime() == -1 ||\n+                jwtTokenInfoDTO.getExpirationTime() > (Integer.MAX_VALUE-currentTime)) {\n+            expireIn = -1;\n+        } else {\n+            expireIn = currentTime + jwtTokenInfoDTO.getExpirationTime();\n+        }\n+        String issuerIdentifier = OAuthServerConfiguration.getInstance().getOpenIDConnectIDTokenIssuerIdentifier();\n+        JWTClaimsSet.Builder jwtClaimsSetBuilder = new JWTClaimsSet.Builder();\n+        jwtClaimsSetBuilder.claim(\"sub\", APIUtil.getUserNameWithTenantSuffix(jwtTokenInfoDTO.getEndUserName()));\n+        jwtClaimsSetBuilder.claim(\"jti\", UUID.randomUUID().toString());\n+        jwtClaimsSetBuilder.claim(\"iss\", issuerIdentifier);\n+        jwtClaimsSetBuilder.claim(\"iat\", currentTime);\n+        if (expireIn != -1) {\n+            jwtClaimsSetBuilder.claim(\"exp\", expireIn);\n+        }\n+        jwtClaimsSetBuilder.claim(\"subscribedAPIs\", jwtTokenInfoDTO.getSubscribedApiDTOList());\n+        jwtClaimsSetBuilder.claim(\"tierInfo\", jwtTokenInfoDTO.getSubscriptionPolicyDTOList());\n+        jwtClaimsSetBuilder.claim(\"application\", jwtTokenInfoDTO.getApplication());\n+        jwtClaimsSetBuilder.claim(\"keytype\", jwtTokenInfoDTO.getKeyType());\n+\n+        return jwtClaimsSetBuilder.build().toJSONObject().toJSONString();\n+    }\n+\n+    protected String buildHeader() throws APIManagementException {\n+        Certificate publicCert;\n+        JSONObject headerWithKid;\n+        try {\n+            KeyStoreManager tenantKSM = KeyStoreManager.getInstance(MultitenantConstants.SUPER_TENANT_ID);\n+            publicCert = tenantKSM.getDefaultPrimaryCertificate();\n+            String headerWithoutKid = APIUtil.generateHeader(publicCert, APIConstants.SIGNATURE_ALGORITHM_SHA256_WITH_RSA);\n+            headerWithKid = new JSONObject(headerWithoutKid);\n+            headerWithKid.put(\"kid\", APIUtil.getApiKeyAlias());\n+\n+        } catch (Exception e) {\n+            throw new APIManagementException(\"Error while building Api key header\", e);\n+        }\n+        return headerWithKid.toString();\n+    }\n+\n+    protected byte[] buildSignature(String assertion) throws APIManagementException {\n+        PrivateKey privateKey = null;\n+        //get super tenant's key store manager\n+        KeyStoreManager tenantKSM = KeyStoreManager.getInstance(MultitenantConstants.SUPER_TENANT_ID);\n+        try {\n+\n+            ServerConfigurationService config =  tenantKSM.getServerConfigService();\n+            String apiKeySignKeyStoreName = APIUtil.getApiKeySignKeyStoreName();\n+            String keyStorePassword = config.getFirstProperty(APIConstants.KeyStoreManagement\n+                    .SERVER_APIKEYSIGN_PRIVATE_KEY_PASSWORD.replaceFirst(APIConstants.KeyStoreManagement.KeyStoreName,\n+                            apiKeySignKeyStoreName));\n+            String apiKeySignAlias = config.getFirstProperty(APIConstants.KeyStoreManagement\n+                    .SERVER_APIKEYSIGN_KEYSTORE_KEY_ALIAS.replaceFirst(APIConstants.KeyStoreManagement.KeyStoreName,\n+                            apiKeySignKeyStoreName));\n+            KeyStore apiKeySignKeyStore = getApiKeySignKeyStore(tenantKSM);\n+            if (apiKeySignKeyStore != null) {\n+                privateKey = (PrivateKey) apiKeySignKeyStore.getKey(apiKeySignAlias,\n+                        keyStorePassword.toCharArray());\n+            }\n+        } catch (Exception e) {\n+            throw new APIManagementException(\"Error while signing Api Key\", e);\n+        }\n+        return APIUtil.signJwt(assertion, privateKey, \"SHA256withRSA\");\n+    }\n+\n+    private KeyStore getApiKeySignKeyStore(KeyStoreManager keyStoreManager) throws Exception {\n+        KeyStore apiKeySignKeyStore;\n+        ServerConfigurationService config = keyStoreManager.getServerConfigService();\n+        String apiKeySignKeyStoreName = APIUtil.getApiKeySignKeyStoreName();\n+        if (config.\n+                getFirstProperty(APIConstants.KeyStoreManagement.SERVER_APIKEYSIGN_KEYSTORE_FILE.\n+                        replaceFirst(APIConstants.KeyStoreManagement.KeyStoreName, apiKeySignKeyStoreName)) == null) {\n+            return null;\n+        }\n+\n+        String file = new File(config\n+                .getFirstProperty(APIConstants.KeyStoreManagement.SERVER_APIKEYSIGN_KEYSTORE_FILE\n+                        .replaceFirst(APIConstants.KeyStoreManagement.KeyStoreName, apiKeySignKeyStoreName)))\n+                .getAbsolutePath();\n+        KeyStore store = KeyStore.getInstance(config\n+                .getFirstProperty(APIConstants.KeyStoreManagement.SERVER_APIKEYSIGN_KEYSTORE_TYPE\n+                        .replaceFirst(APIConstants.KeyStoreManagement.KeyStoreName, apiKeySignKeyStoreName)));\n+        String password = config\n+                .getFirstProperty(APIConstants.KeyStoreManagement.SERVER_APIKEYSIGN_KEYSTORE_PASSWORD\n+                        .replaceFirst(APIConstants.KeyStoreManagement.KeyStoreName, apiKeySignKeyStoreName));\n+\n+        try (FileInputStream in = new FileInputStream(file)) {\n+            store.load(in, password.toCharArray());\n+            apiKeySignKeyStore = store;\n+        }\n+        return apiKeySignKeyStore;\n+    }\n+\n+    private static String encode(byte[] stringToBeEncoded) throws APIManagementException {\n+        try {\n+            return java.util.Base64.getUrlEncoder().encodeToString(stringToBeEncoded);\n+        } catch (Exception e) {\n+            throw new APIManagementException(\"Error while encoding the Api Key \",e);\n+        }\n+    }\n+\n+}", "originalCommit": "b5a8919a43c112dd33242bb0d68f78d3909552ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTcyNDkzOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9256#discussion_r481724938", "bodyText": "remove wild card import", "author": "ChamodDamitha", "createdAt": "2020-09-02T05:30:52Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/token/DefaultApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.token;\n+\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dto.JwtTokenInfoDTO;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.api.ServerConfigurationService;\n+import org.wso2.carbon.core.util.KeyStoreManager;\n+import org.wso2.carbon.identity.oauth.config.OAuthServerConfiguration;\n+import org.wso2.carbon.utils.multitenancy.MultitenantConstants;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.charset.Charset;\n+import java.security.*;", "originalCommit": "b5a8919a43c112dd33242bb0d68f78d3909552ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTcyNjYxOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9256#discussion_r481726618", "bodyText": "use the constants declared in APIConstants.JwtTokenConstants", "author": "ChamodDamitha", "createdAt": "2020-09-02T05:32:36Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/token/DefaultApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.token;\n+\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dto.JwtTokenInfoDTO;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.base.api.ServerConfigurationService;\n+import org.wso2.carbon.core.util.KeyStoreManager;\n+import org.wso2.carbon.identity.oauth.config.OAuthServerConfiguration;\n+import org.wso2.carbon.utils.multitenancy.MultitenantConstants;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.charset.Charset;\n+import java.security.*;\n+import java.security.cert.Certificate;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+public class DefaultApiKeyGenerator implements ApiKeyGenerator {\n+\n+    private static final Log log = LogFactory.getLog(DefaultApiKeyGenerator.class);\n+\n+    public DefaultApiKeyGenerator() {\n+    }\n+\n+    public String generateToken(JwtTokenInfoDTO jwtTokenInfoDTO) throws APIManagementException {\n+\n+        String jwtHeader = buildHeader();\n+        String base64UrlEncodedHeader = \"\";\n+        if (jwtHeader != null) {\n+            base64UrlEncodedHeader = encode(jwtHeader.getBytes(Charset.defaultCharset()));\n+        }\n+\n+        String jwtBody = buildBody(jwtTokenInfoDTO);\n+        String base64UrlEncodedBody = \"\";\n+        if (jwtBody != null) {\n+            base64UrlEncodedBody = encode(jwtBody.getBytes());\n+        }\n+\n+        String assertion = base64UrlEncodedHeader + '.' + base64UrlEncodedBody;\n+        //get the assertion signed\n+        byte[] signedAssertion = buildSignature(assertion);\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"signed assertion value : \" + new String(signedAssertion, Charset.defaultCharset()));\n+        }\n+        String base64UrlEncodedAssertion = encode(signedAssertion);\n+\n+        return base64UrlEncodedHeader + '.' + base64UrlEncodedBody + '.' + base64UrlEncodedAssertion;\n+    }\n+\n+    protected String buildBody(JwtTokenInfoDTO jwtTokenInfoDTO) {\n+        long currentTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n+        long expireIn;\n+        if (jwtTokenInfoDTO.getExpirationTime() == -1 ||\n+                jwtTokenInfoDTO.getExpirationTime() > (Integer.MAX_VALUE-currentTime)) {\n+            expireIn = -1;\n+        } else {\n+            expireIn = currentTime + jwtTokenInfoDTO.getExpirationTime();\n+        }\n+        String issuerIdentifier = OAuthServerConfiguration.getInstance().getOpenIDConnectIDTokenIssuerIdentifier();\n+        JWTClaimsSet.Builder jwtClaimsSetBuilder = new JWTClaimsSet.Builder();\n+        jwtClaimsSetBuilder.claim(\"sub\", APIUtil.getUserNameWithTenantSuffix(jwtTokenInfoDTO.getEndUserName()));", "originalCommit": "b5a8919a43c112dd33242bb0d68f78d3909552ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "35ba63159c1c7b30b3c9b05f0bef4aafb6829934", "url": "https://github.com/wso2/carbon-apimgt/commit/35ba63159c1c7b30b3c9b05f0bef4aafb6829934", "message": "Add changes to sign JWT with a different keystore", "committedDate": "2021-02-12T05:43:30Z", "type": "commit"}, {"oid": "da4a7bba80be42768f65778cbc7e3ddc6172c0e1", "url": "https://github.com/wso2/carbon-apimgt/commit/da4a7bba80be42768f65778cbc7e3ddc6172c0e1", "message": "Correct formatting errors", "committedDate": "2021-02-12T05:43:30Z", "type": "commit"}, {"oid": "4ac532c970c3809dc44b1d9f01c9e2f95b7cd743", "url": "https://github.com/wso2/carbon-apimgt/commit/4ac532c970c3809dc44b1d9f01c9e2f95b7cd743", "message": "Replace some values with constatnts", "committedDate": "2021-02-12T05:48:09Z", "type": "commit"}, {"oid": "9d794120a37a2aef36f01b46a7f98976dd02ef47", "url": "https://github.com/wso2/carbon-apimgt/commit/9d794120a37a2aef36f01b46a7f98976dd02ef47", "message": "Add remaining changes", "committedDate": "2021-02-12T05:48:09Z", "type": "commit"}, {"oid": "9d794120a37a2aef36f01b46a7f98976dd02ef47", "url": "https://github.com/wso2/carbon-apimgt/commit/9d794120a37a2aef36f01b46a7f98976dd02ef47", "message": "Add remaining changes", "committedDate": "2021-02-12T05:48:09Z", "type": "forcePushed"}, {"oid": "303e0fc943b637e10baffb8ba27ca384ba5ece86", "url": "https://github.com/wso2/carbon-apimgt/commit/303e0fc943b637e10baffb8ba27ca384ba5ece86", "message": "Update license headers", "committedDate": "2021-02-12T10:17:08Z", "type": "commit"}]}