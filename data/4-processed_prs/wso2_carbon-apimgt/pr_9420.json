{"pr_number": 9420, "pr_title": "Resolve parameters at server-side while importing an API project [APIM Server side]", "pr_createdAt": "2020-11-24T03:34:29Z", "pr_url": "https://github.com/wso2/carbon-apimgt/pull/9420", "timeline": [{"oid": "11589fae5324fced92847a51d12340f96ef4fb14", "url": "https://github.com/wso2/carbon-apimgt/commit/11589fae5324fced92847a51d12340f96ef4fb14", "message": "Adding changes after the code review", "committedDate": "2020-11-27T05:57:14Z", "type": "forcePushed"}, {"oid": "dc09113c3247e6e2c1547691724828fdf748fb80", "url": "https://github.com/wso2/carbon-apimgt/commit/dc09113c3247e6e2c1547691724828fdf748fb80", "message": "Adding the licence header", "committedDate": "2020-12-02T05:25:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDgwMzk3MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9420#discussion_r534803970", "bodyText": "Shall we use try resource when creating the FileOutputStream? So that we do not need to close the file explicitly in line 365.", "author": "wasuradananjith", "createdAt": "2020-12-03T07:26:40Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/CommonUtil.java", "diffHunk": "@@ -328,4 +332,59 @@ public static String extractArchive(File sourceFile, String destination) throws\n             throw new APIImportExportException(errorMessage, e);\n         }\n     }\n+\n+    /**\n+     * This method will be used to generate Endpoint certificates and meta information related to endpoint certs\n+     *\n+     * @param filePath String of new file path\n+     * @param content  String of content to write into the file\n+     * @throws IOException If an error occurs when generating new certs and yaml file\n+     */\n+    public static void generateFiles(String filePath, String content) throws IOException {\n+        FileOutputStream fos = null;", "originalCommit": "dc09113c3247e6e2c1547691724828fdf748fb80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b3e0e00666d5db3b4dc3b34b189d8b448498f75c", "url": "https://github.com/wso2/carbon-apimgt/commit/b3e0e00666d5db3b4dc3b34b189d8b448498f75c", "message": "Resolving multiple endpoint types", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "7e0b39bc0df255fb9f72e983de937601bbd18618", "url": "https://github.com/wso2/carbon-apimgt/commit/7e0b39bc0df255fb9f72e983de937601bbd18618", "message": "Resolving gateway environments", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "9151d1602fd07c63b10c4aa16dcd9bbc9e10549d", "url": "https://github.com/wso2/carbon-apimgt/commit/9151d1602fd07c63b10c4aa16dcd9bbc9e10549d", "message": "Resolve configs and endpoint security params", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "25ad3cd70d3491da3db78b98dfef8362dac98edd", "url": "https://github.com/wso2/carbon-apimgt/commit/25ad3cd70d3491da3db78b98dfef8362dac98edd", "message": "Extracting env params from the yaml", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "68a76cbfa120535ce3b6f33a03b09941e1c3bd37", "url": "https://github.com/wso2/carbon-apimgt/commit/68a76cbfa120535ce3b6f33a03b09941e1c3bd37", "message": "Handling client and enpoint certificates", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "4ca892df0804228ea4cf6010f8fe3c9a89f4833c", "url": "https://github.com/wso2/carbon-apimgt/commit/4ca892df0804228ea4cf6010f8fe3c9a89f4833c", "message": "Adding comments and test fixes", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "234097bd97ace0e12ab62f1d44145365a912169a", "url": "https://github.com/wso2/carbon-apimgt/commit/234097bd97ace0e12ab62f1d44145365a912169a", "message": "Add changes to import function", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "dffde09adea21852654e40c196363cc2046f2719", "url": "https://github.com/wso2/carbon-apimgt/commit/dffde09adea21852654e40c196363cc2046f2719", "message": "Changes after integration test run", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "f3a6f2386283313c7966942a33c5d5aad0bda400", "url": "https://github.com/wso2/carbon-apimgt/commit/f3a6f2386283313c7966942a33c5d5aad0bda400", "message": "Change cert directory", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "178495dbbabdcad08e142a7be66a29b9656b1413", "url": "https://github.com/wso2/carbon-apimgt/commit/178495dbbabdcad08e142a7be66a29b9656b1413", "message": "Fixing formatting errors", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "7b8489ee0463c7cbe38fe2bc16fe8eb18d72208a", "url": "https://github.com/wso2/carbon-apimgt/commit/7b8489ee0463c7cbe38fe2bc16fe8eb18d72208a", "message": "Drafted changes after the code review", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "8e0f65273914fd5ed436171ca075ea63217bfbdb", "url": "https://github.com/wso2/carbon-apimgt/commit/8e0f65273914fd5ed436171ca075ea63217bfbdb", "message": "Adding changes after the code review", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "ed8a9037dde9e10f0070774565cbf65aba98c354", "url": "https://github.com/wso2/carbon-apimgt/commit/ed8a9037dde9e10f0070774565cbf65aba98c354", "message": "Adding the licence header", "committedDate": "2020-12-04T08:01:23Z", "type": "commit"}, {"oid": "6753e91e7e202a762bda6bb86ea01b56086e5516", "url": "https://github.com/wso2/carbon-apimgt/commit/6753e91e7e202a762bda6bb86ea01b56086e5516", "message": "Moving parameters solving functions from Admin to Publisher", "committedDate": "2020-12-07T07:05:02Z", "type": "commit"}, {"oid": "5b184c5c48ff05c853a6fa1f6428c03650eca7f6", "url": "https://github.com/wso2/carbon-apimgt/commit/5b184c5c48ff05c853a6fa1f6428c03650eca7f6", "message": "Remove Params resolving from importexport Utils", "committedDate": "2020-12-07T07:08:47Z", "type": "commit"}, {"oid": "5b184c5c48ff05c853a6fa1f6428c03650eca7f6", "url": "https://github.com/wso2/carbon-apimgt/commit/5b184c5c48ff05c853a6fa1f6428c03650eca7f6", "message": "Remove Params resolving from importexport Utils", "committedDate": "2020-12-07T07:08:47Z", "type": "forcePushed"}, {"oid": "b6449dae8b0be0991a7965f15ec23baf1b45210c", "url": "https://github.com/wso2/carbon-apimgt/commit/b6449dae8b0be0991a7965f15ec23baf1b45210c", "message": "Adding try resources", "committedDate": "2020-12-08T08:37:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIyNDcwNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/9420#discussion_r538224705", "bodyText": "Wrapping an exception with another exception of the same type can be confusing in a stack trace. Better if we can wrap the IOException in another type of exception such as APIMgtException", "author": "uvindra", "createdAt": "2020-12-08T10:35:11Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/CommonUtil.java", "diffHunk": "@@ -328,4 +330,46 @@ public static String extractArchive(File sourceFile, String destination) throws\n             throw new APIImportExportException(errorMessage, e);\n         }\n     }\n+\n+    /**\n+     * This method will be used to generate Endpoint certificates and meta information related to endpoint certs\n+     *\n+     * @param filePath String of new file path\n+     * @param content  String of content to write into the file\n+     * @throws IOException If an error occurs when generating new certs and yaml file\n+     */\n+    public static void generateFiles(String filePath, String content) throws IOException {\n+\n+        File file = new File(filePath);\n+        try (FileOutputStream fos = new FileOutputStream(file)) {\n+\n+            if (!file.exists()) {\n+                file.createNewFile();\n+            }\n+            byte[] bytesArray = content.getBytes();\n+\n+            fos.write(bytesArray);\n+            fos.flush();\n+\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while generating meta information of client certificates from path.\";\n+            throw new IOException(errorMessage, e);", "originalCommit": "b6449dae8b0be0991a7965f15ec23baf1b45210c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIyNDg0Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/9420#discussion_r538224847", "bodyText": "Wrapping an exception with another exception of the same type can be confusing in a stack trace. Better if we can wrap the IOException in another type of exception such as APIMgtException", "author": "uvindra", "createdAt": "2020-12-08T10:35:21Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/CommonUtil.java", "diffHunk": "@@ -328,4 +330,46 @@ public static String extractArchive(File sourceFile, String destination) throws\n             throw new APIImportExportException(errorMessage, e);\n         }\n     }\n+\n+    /**\n+     * This method will be used to generate Endpoint certificates and meta information related to endpoint certs\n+     *\n+     * @param filePath String of new file path\n+     * @param content  String of content to write into the file\n+     * @throws IOException If an error occurs when generating new certs and yaml file\n+     */\n+    public static void generateFiles(String filePath, String content) throws IOException {\n+\n+        File file = new File(filePath);\n+        try (FileOutputStream fos = new FileOutputStream(file)) {\n+\n+            if (!file.exists()) {\n+                file.createNewFile();\n+            }\n+            byte[] bytesArray = content.getBytes();\n+\n+            fos.write(bytesArray);\n+            fos.flush();\n+\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while generating meta information of client certificates from path.\";\n+            throw new IOException(errorMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * This method will be used to copy files from source to destination\n+     *\n+     * @param source String of the source file path\n+     * @param dest   String of the destination file path\n+     * @throws IOException If an error occurs when copying files\n+     */\n+    public static void moveFile(String source, String dest) throws IOException {\n+        try {\n+            Files.move(Paths.get(source), Paths.get(dest));\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while moving file from\" + source + \"to\" + dest;\n+            throw new IOException(errorMessage, e);", "originalCommit": "b6449dae8b0be0991a7965f15ec23baf1b45210c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNDIwOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9420#discussion_r538234208", "bodyText": "Shall we throw an exception here instead of returning null? Since we only support either Dynamic or AWS Endpoint type, any other value could lead to a NPE.", "author": "uvindra", "createdAt": "2020-12-08T10:46:37Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1.common/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/common/mappings/APIControllerUtil.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.carbon.apimgt.rest.api.publisher.v1.common.mappings;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.Gson;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.dto.CertificateMetadataDTO;\n+import org.wso2.carbon.apimgt.api.dto.ClientCertificateDTO;\n+import org.wso2.carbon.apimgt.api.model.API;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.impl.importexport.APIImportExportException;\n+import org.wso2.carbon.apimgt.impl.importexport.ExportFormat;\n+import org.wso2.carbon.apimgt.impl.importexport.ImportExportConstants;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.APIAndAPIProductCommonUtil;\n+import org.wso2.carbon.apimgt.impl.importexport.utils.CommonUtil;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIDTO;\n+import org.wso2.carbon.apimgt.rest.api.publisher.v1.dto.APIEndpointSecurityDTO;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+public class APIControllerUtil {\n+\n+    private static final Log log = LogFactory.getLog(APIAndAPIProductCommonUtil.class);\n+\n+    /**\n+     * Method will check the archive and extract environment related params\n+     *\n+     * @param pathToArchive String of the archive project\n+     * @return JsonObject of environment parameters\n+     * @throws IOException\n+     */\n+    public static JsonObject resolveAPIControllerEnvParams(String pathToArchive) throws IOException {\n+\n+        String jsonParamsContent;\n+        jsonParamsContent = getParamsDefinitionAsJSON(pathToArchive);\n+        if (StringUtils.isEmpty(jsonParamsContent)) {\n+            return null;\n+        }\n+        JsonElement paramsElement = new JsonParser().parse(jsonParamsContent);\n+        return paramsElement.getAsJsonObject();\n+    }\n+\n+    /**\n+     * Retrieve API params file as JSON.\n+     *\n+     * @param pathToArchive Path to API or API Product archive\n+     * @return String JsonString of environment parameters\n+     * @throws IOException If an error occurs while reading the file\n+     */\n+    public static String getParamsDefinitionAsJSON(String pathToArchive) throws IOException {\n+\n+        String jsonContent = null;\n+        String pathToYamlFile = pathToArchive + ImportExportConstants.YAML_API_PARAMS_FILE_LOCATION;\n+        String pathToJsonFile = pathToArchive + ImportExportConstants.JSON_API_PARAMS_FILE_LOCATION;\n+\n+        // load yaml representation first,if it is present\n+        if (CommonUtil.checkFileExistence(pathToYamlFile)) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api params definition file \" + pathToYamlFile);\n+            }\n+            String yamlContent = FileUtils.readFileToString(new File(pathToYamlFile));\n+            if (StringUtils.isNotEmpty(yamlContent)) {\n+                jsonContent = CommonUtil.yamlToJson(yamlContent);\n+            }\n+        } else if (CommonUtil.checkFileExistence(pathToJsonFile)) {\n+            // load as a json fallback\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Found api params definition file \" + pathToJsonFile);\n+            }\n+            jsonContent = FileUtils.readFileToString(new File(pathToJsonFile));\n+        }\n+        return jsonContent;\n+    }\n+\n+    /**\n+     * This method will be used to add Extracted environment parameters to the imported Api object\n+     *\n+     * @param pathToArchive  Path to API or API Product archive\n+     * @param importedApiDto APIDTO object to be imported\n+     * @param envParams      Env params object with required parameters\n+     * @return API Updated API Object\n+     * @throws APIManagementException If an error occurs merging env parameters with api\n+     */\n+    public static APIDTO injectEnvParamsToAPI(APIDTO importedApiDto, JsonObject envParams, String pathToArchive)\n+            throws APIManagementException {\n+\n+        if (envParams == null || envParams.isJsonNull()) {\n+            return importedApiDto;\n+        }\n+\n+        API importedApi = APIMappingUtil.fromDTOtoAPI(importedApiDto, importedApiDto.getProvider());\n+\n+        // if endpointType field is not specified in the api_params.yaml, it will be considered as HTTP/REST\n+        JsonElement endpointTypeElement = envParams.get(ImportExportConstants.ENDPOINT_TYPE_FIELD);\n+        String endpointType = null;\n+        if (endpointTypeElement != null) {\n+            endpointType = endpointTypeElement.getAsString();\n+        } else {\n+            endpointType = ImportExportConstants.REST_TYPE_ENDPOINT;\n+        }\n+\n+        //Handle multiple end points\n+        JsonObject jsonObject = setupMultipleEndpoints(envParams, endpointType);\n+        ObjectMapper mapper = new ObjectMapper();\n+        HashMap<String, Object> endpointConfig;\n+        try {\n+            endpointConfig = mapper.readValue(jsonObject.toString(), HashMap.class);\n+        } catch (JsonProcessingException e) {\n+            throw new APIManagementException(e);\n+        }\n+        importedApiDto.setEndpointConfig(endpointConfig);\n+\n+        //handle gateway environments\n+        if (envParams.get(ImportExportConstants.GATEWAY_ENVIRONMENTS_FIELD) != null) {\n+            List<String> environments = setupGatewayEnvironments(\n+                    envParams.get(ImportExportConstants.GATEWAY_ENVIRONMENTS_FIELD).getAsJsonArray());\n+            importedApiDto.setGatewayEnvironments(environments);\n+        }\n+\n+        //handle mutualSSL certificates\n+        JsonElement clientCertificates = envParams.get(ImportExportConstants.MUTUAL_SSL_CERTIFICATES_FIELD);\n+        if (clientCertificates != null) {\n+            try {\n+                List<String> apiSecurity = importedApiDto.getSecurityScheme();\n+                if (!apiSecurity.isEmpty()) {\n+                    if (!apiSecurity.contains(ImportExportConstants.MUTUAL_SSL_ENABLED)) {\n+                        // if the apiSecurity field does not have mutualssl type, append it\n+                        apiSecurity.add(ImportExportConstants.MUTUAL_SSL_ENABLED);\n+                    }\n+                } else {\n+                    // if the apiSecurity field is empty, assign the value as \"mutualssl\"\n+                    apiSecurity.add(ImportExportConstants.MUTUAL_SSL_ENABLED);\n+                }\n+                importedApiDto.securityScheme(apiSecurity);\n+                String jsonString = clientCertificates.toString();\n+                handleClientCertificates(new JsonParser().parse(jsonString).getAsJsonArray(), importedApi.getId(),\n+                        pathToArchive);\n+            } catch (IOException e) {\n+                //Error is logged and when generating certificate details and certs in the archive\n+                String errorMessage = \"Error while generating meta information of client certificates from path.\";\n+                throw new APIManagementException(errorMessage, e);\n+            }\n+        }\n+\n+        //handle endpoint certificates\n+        JsonElement endpointCertificates = envParams.get(ImportExportConstants.ENDPOINT_CERTIFICATES_FIELD);\n+        if (endpointCertificates != null) {\n+            try {\n+                String jsonString = endpointCertificates.toString();\n+                handleEndpointCertificates(new JsonParser().parse(jsonString).getAsJsonArray(), pathToArchive);\n+            } catch (IOException e) {\n+                //Error is logged and when generating certificate details and certs in the archive\n+                String errorMessage = \"Error while generating meta information of client certificates from path.\";\n+                throw new APIManagementException(errorMessage, e);\n+            }\n+        }\n+\n+        //handle security configs\n+        JsonElement securityConfigs = envParams.get(ImportExportConstants.ENDPOINT_SECURITY_FIELD);\n+        if (securityConfigs != null) {\n+            handleEndpointSecurityConfigs(envParams, importedApiDto);\n+        }\n+        return importedApiDto;\n+    }\n+\n+    /**\n+     * This method will be used to add Endpoint security related environment parameters to imported Api object\n+     *\n+     * @param importedApiDto APIDTO object to be updated\n+     * @param envParams      Env params object with required parameters\n+     * @throws APIManagementException If an error occurs when setting security env parameters\n+     */\n+    private static void handleEndpointSecurityConfigs(JsonObject envParams, APIDTO importedApiDto)\n+            throws APIManagementException {\n+        // If the user has set (either true or false) the enabled field under security in api_params.yaml,\n+        // the following code should be executed.\n+        JsonObject security = envParams.getAsJsonObject(ImportExportConstants.ENDPOINT_SECURITY_FIELD);\n+        if (security == null) {\n+            return;\n+        }\n+        String securityEnabled = security.get(ImportExportConstants.ENDPOINT_SECURITY_ENABLED).getAsString();\n+        boolean isSecurityEnabled = Boolean.parseBoolean(securityEnabled);\n+        //set endpoint security details to API\n+        APIEndpointSecurityDTO apiEndpointSecurityDTO = new APIEndpointSecurityDTO();\n+\n+        // If endpoint security is enabled\n+        if (isSecurityEnabled) {\n+            // Check whether the username, password and type fields have set in api_params.yaml\n+            JsonElement username = security.get(ImportExportConstants.ENDPOINT_UT_USERNAME);\n+            JsonElement password = security.get(ImportExportConstants.ENDPOINT_UT_PASSWORD);\n+            JsonElement type = security.get(ImportExportConstants.ENDPOINT_SECURITY_TYPE);\n+\n+            if (username == null) {\n+                throw new APIManagementException(\"You have enabled endpoint security but the username is not found \"\n+                        + \"in the api_params.yaml. Please specify username field for and continue...\");\n+            } else if (password == null) {\n+                throw new APIManagementException(\"You have enabled endpoint security but the password is not found \"\n+                        + \"in the api_params.yaml. Please specify password field for and continue...\");\n+            } else if (type == null) {\n+                throw new APIManagementException(\"You have enabled endpoint security but the password is not found \"\n+                        + \"in the api_params.yaml. Please specify password field for and continue...\");\n+            } else {\n+                apiEndpointSecurityDTO.setPassword(password.toString());\n+                apiEndpointSecurityDTO.setUsername(username.getAsString());\n+                //setup security type (basic or digest)\n+                if (StringUtils.equals(type.getAsString(), ImportExportConstants.ENDPOINT_DIGEST_SECURITY_TYPE)) {\n+                    apiEndpointSecurityDTO.setType(APIEndpointSecurityDTO.TypeEnum.DIGEST);\n+                } else if (StringUtils.equals(type.getAsString(), ImportExportConstants.ENDPOINT_BASIC_SECURITY_TYPE)) {\n+                    apiEndpointSecurityDTO.setType(APIEndpointSecurityDTO.TypeEnum.BASIC);\n+                } else {\n+                    // If the type is not either basic or digest, return an error\n+                    throw new APIManagementException(\"Invalid endpoint security type found in the api_params.yaml. \"\n+                            + \"Should be either basic or digest\"\n+                            + \"Please specify correct security types field for and continue...\");\n+                }\n+            }\n+            importedApiDto.setEndpointSecurity(apiEndpointSecurityDTO);\n+        }\n+    }\n+\n+    /**\n+     * This method will be used to add gateway environments to imported Api object\n+     *\n+     * @param gatewayEnvironments Json array of gateway environments extracted from env params file\n+     * @return Gateway Environment list\n+     */\n+    private static List<String> setupGatewayEnvironments(JsonArray gatewayEnvironments) {\n+\n+        List<String> environments = new ArrayList<>();\n+        for (int i = 0; i < gatewayEnvironments.size(); i++) {\n+            environments.add(gatewayEnvironments.get(i).getAsString());\n+        }\n+        return environments;\n+    }\n+\n+    /**\n+     * This method will be used to extract endpoint configurations from the env params file\n+     *\n+     * @param endpointType Endpoint type\n+     * @param envParams    JsonObject of Env params  with required parameters\n+     * @return JsonObject with Endpoint configs\n+     * @throws APIManagementException If an error occurs when extracting endpoint configurations\n+     */\n+    private static JsonObject setupMultipleEndpoints(JsonObject envParams, String endpointType)\n+            throws APIManagementException {\n+\n+        //default production and sandbox endpoints\n+        JsonObject defaultProductionEndpoint = new JsonObject();\n+        defaultProductionEndpoint\n+                .addProperty(ImportExportConstants.ENDPOINT_URL, ImportExportConstants.DEFAULT_PRODUCTION_ENDPOINT_URL);\n+        JsonObject defaultSandboxEndpoint = new JsonObject();\n+        defaultSandboxEndpoint\n+                .addProperty(ImportExportConstants.ENDPOINT_URL, ImportExportConstants.DEFAULT_SANDBOX_ENDPOINT_URL);\n+\n+        JsonObject multipleEndpointsConfig = null;\n+        String routingPolicy = null;\n+\n+        // if the endpoint routing policy or the endpoints field is not specified and\n+        // if the endpoint type is AWS or Dynamic\n+        if (envParams.get(ImportExportConstants.ROUTING_POLICY_FIELD) != null) {\n+            routingPolicy = envParams.get(ImportExportConstants.ROUTING_POLICY_FIELD).getAsString();\n+        }\n+\n+        if (StringUtils.isEmpty(routingPolicy)) {\n+            multipleEndpointsConfig = handleDynamicAndAwsEndpoints(envParams, defaultProductionEndpoint,\n+                    defaultSandboxEndpoint, endpointType);\n+        }\n+\n+        // if endpoint type is HTTP/REST\n+        if (StringUtils.equals(endpointType, ImportExportConstants.HTTP_TYPE_ENDPOINT) || StringUtils\n+                .equals(endpointType, ImportExportConstants.REST_TYPE_ENDPOINT)) {\n+            //add REST endpoint configs as endpoint configs\n+            multipleEndpointsConfig = handleRestEndpoints(routingPolicy, envParams, defaultProductionEndpoint,\n+                    defaultSandboxEndpoint);\n+        }\n+\n+        // if endpoint type is HTTP/SOAP\n+        if (ImportExportConstants.SOAP_TYPE_ENDPOINT.equals(endpointType)) {\n+            //add SOAP endpoint configs as endpoint configs\n+            multipleEndpointsConfig = handleSoapEndpoints(routingPolicy, envParams, defaultProductionEndpoint,\n+                    defaultSandboxEndpoint);\n+        }\n+        return multipleEndpointsConfig;\n+    }\n+\n+    /**\n+     * This method will handle the Dynamic and AWS endpoint configs\n+     *\n+     * @param envParams                 Json object of Env parameters\n+     * @param defaultProductionEndpoint Default production endpoint json object\n+     * @param defaultSandboxEndpoint    Default sandbox endpoint json object\n+     * @param endpointType              String of endpoint type\n+     * @return JsonObject with Dynamic or AWS Endpoint configs\n+     * @throws APIManagementException If an error occurs when extracting endpoint configurations\n+     */\n+    private static JsonObject handleDynamicAndAwsEndpoints(JsonObject envParams, JsonObject defaultProductionEndpoint,\n+            JsonObject defaultSandboxEndpoint, String endpointType) throws APIManagementException {\n+        JsonObject endpointsObject = null;\n+        if (envParams.get(ImportExportConstants.ENDPOINTS_FIELD) != null) {\n+            endpointsObject = envParams.get(ImportExportConstants.ENDPOINTS_FIELD).getAsJsonObject();\n+        }\n+        // if endpoint type is Dynamic\n+        if (ImportExportConstants.DYNAMIC_TYPE_ENDPOINT.equals(endpointType)) {\n+            JsonObject updatedDynamicEndpointParams = new JsonObject();\n+            //replace url property in dynamic endpoints\n+            defaultProductionEndpoint.addProperty(ImportExportConstants.ENDPOINT_URL,\n+                    ImportExportConstants.DEFAULT_DYNAMIC_ENDPOINT_URL);\n+            defaultSandboxEndpoint.addProperty(ImportExportConstants.ENDPOINT_URL,\n+                    ImportExportConstants.DEFAULT_DYNAMIC_ENDPOINT_URL);\n+            updatedDynamicEndpointParams.addProperty(ImportExportConstants.ENDPOINT_TYPE_PROPERTY,\n+                    ImportExportConstants.DEFAULT_DYNAMIC_ENDPOINT_URL);\n+            updatedDynamicEndpointParams\n+                    .addProperty(ImportExportConstants.FAILOVER_ROUTING_POLICY, Boolean.FALSE.toString());\n+            handleEndpointValues(endpointsObject, updatedDynamicEndpointParams, defaultProductionEndpoint,\n+                    defaultSandboxEndpoint);\n+            //add dynamic endpoint configs as endpoint configs\n+            return updatedDynamicEndpointParams;\n+\n+        } else if (ImportExportConstants.AWS_TYPE_ENDPOINT.equals(endpointType)) {// if endpoint type is AWS Lambda\n+            //if aws config is not provided\n+            if (envParams.get(ImportExportConstants.AWS_LAMBDA_ENDPOINT_JSON_PROPERTY) == null) {\n+                throw new APIManagementException(\"Please specify awsLambdaEndpoints field for  and continue...\");\n+            }\n+            JsonObject awsEndpointParams = envParams.get(ImportExportConstants.AWS_LAMBDA_ENDPOINT_JSON_PROPERTY)\n+                    .getAsJsonObject();\n+            JsonObject updatedAwsEndpointParams = new JsonObject();\n+            //if the access method is provided with credentials\n+            if (StringUtils\n+                    .equals(awsEndpointParams.get(ImportExportConstants.AWS_ACCESS_METHOD_JSON_PROPERTY).getAsString(),\n+                            ImportExportConstants.AWS_STORED_ACCESS_METHOD)) {\n+                //get the same config object for aws configs\n+                updatedAwsEndpointParams = awsEndpointParams;\n+                updatedAwsEndpointParams.remove(ImportExportConstants.AWS_ACCESS_METHOD_JSON_PROPERTY);\n+                updatedAwsEndpointParams.addProperty(ImportExportConstants.AWS_ACCESS_METHOD_PROPERTY,\n+                        ImportExportConstants.AWS_STORED_ACCESS_METHOD);\n+            } else {\n+                //if the credentials are not provided the default will be used\n+                updatedAwsEndpointParams.addProperty(ImportExportConstants.AWS_ACCESS_METHOD_PROPERTY,\n+                        ImportExportConstants.AWS_ROLE_SUPPLIED_ACCESS_METHOD);\n+            }\n+            updatedAwsEndpointParams.addProperty(ImportExportConstants.ENDPOINT_TYPE_PROPERTY,\n+                    ImportExportConstants.AWS_LAMBDA_TYPE_ENDPOINT);\n+            handleEndpointValues(endpointsObject, updatedAwsEndpointParams, defaultProductionEndpoint,\n+                    defaultSandboxEndpoint);\n+            //add AWS endpoint configs as endpoint configs\n+            return updatedAwsEndpointParams;\n+        }\n+        return null;", "originalCommit": "b6449dae8b0be0991a7965f15ec23baf1b45210c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c05a0f65f6516d8bac130e9b891ceaf0abf7ba0f", "url": "https://github.com/wso2/carbon-apimgt/commit/c05a0f65f6516d8bac130e9b891ceaf0abf7ba0f", "message": "Fixing review suggestions", "committedDate": "2020-12-08T11:36:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA2Mzc3MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/9420#discussion_r555063771", "bodyText": "Shall we remove this new line ?", "author": "Sarangan0219", "createdAt": "2021-01-11T13:57:43Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/APIImportExportConstants.java", "diffHunk": "@@ -136,4 +136,5 @@\n         // To identify thumbnail icons\n         fileExtensionMapping.put(\"application/json\", \"json\");\n     }\n+", "originalCommit": "c05a0f65f6516d8bac130e9b891ceaf0abf7ba0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU0ODA2Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/9420#discussion_r565548062", "bodyText": "Fixed with c1f8462", "author": "Chamindu36", "createdAt": "2021-01-27T18:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA2Mzc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA2NjgyMQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/9420#discussion_r555066821", "bodyText": "Shall we add a finally clause here?\n        finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n            } catch (IOException e) {\n                log.error(\"Error occurred closing file output stream\", e);\n            }\n        }", "author": "Sarangan0219", "createdAt": "2021-01-11T14:02:34Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/importexport/utils/CommonUtil.java", "diffHunk": "@@ -328,4 +331,46 @@ public static String extractArchive(File sourceFile, String destination) throws\n             throw new APIImportExportException(errorMessage, e);\n         }\n     }\n+\n+    /**\n+     * This method will be used to generate Endpoint certificates and meta information related to endpoint certs\n+     *\n+     * @param filePath String of new file path\n+     * @param content  String of content to write into the file\n+     * @throws APIManagementException If an error occurs when generating new certs and yaml file\n+     */\n+    public static void generateFiles(String filePath, String content) throws APIManagementException {\n+\n+        File file = new File(filePath);\n+        try (FileOutputStream fos = new FileOutputStream(file)) {\n+\n+            if (!file.exists()) {\n+                file.createNewFile();\n+            }\n+            byte[] bytesArray = content.getBytes();\n+\n+            fos.write(bytesArray);\n+            fos.flush();\n+\n+        } catch (IOException e) {\n+            String errorMessage = \"Error while generating meta information of client certificates from path.\";\n+            throw new APIManagementException(errorMessage, e);", "originalCommit": "c05a0f65f6516d8bac130e9b891ceaf0abf7ba0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTUyNDE2MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9420#discussion_r555524160", "bodyText": "The current code uses the Java 7 try with resources pattern which will cause fos to be closed automatically when it goes out of scope. Therefore it does not require to be explicitly closed in a finally block.", "author": "uvindra", "createdAt": "2021-01-12T05:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA2NjgyMQ=="}], "type": "inlineReview"}]}