{"pr_number": 11374, "pr_title": "add boulder CA to acme FAT", "pr_createdAt": "2020-03-18T18:52:23Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/11374", "timeline": [{"oid": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "url": "https://github.com/OpenLiberty/open-liberty/commit/3dd0ccb898e794282f2c55bdc25f1b9f77207045", "message": "add boulder CA to acme FAT", "committedDate": "2020-03-18T18:59:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NTkwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395285909", "bodyText": "Add copyright.", "author": "jvanhill", "createdAt": "2020-03-19T19:59:45Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5Mjg4OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395292889", "bodyText": "No doc, does this override a method?", "author": "jvanhill", "createdAt": "2020-03-19T20:13:17Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(IMAGE);\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+    }\n+    \n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5MzI3Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395293276", "bodyText": "No doc. Does this override a method? how is this different than the method in CAContainer?", "author": "jvanhill", "createdAt": "2020-03-19T20:13:53Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(IMAGE);\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+    }\n+    \n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5MzQ1NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395293454", "bodyText": "Copyright is missing.", "author": "jvanhill", "createdAt": "2020-03-19T20:14:18Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDA3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395294077", "bodyText": "Should this be static? Or does each override it?", "author": "jvanhill", "createdAt": "2020-03-19T20:15:29Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMzUwNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395303505", "bodyText": "I see you set this in the construct. This field is confusing since it ghosted statically in the child classes. They won't all agree, which could be confusing.", "author": "jvanhill", "createdAt": "2020-03-19T20:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTY5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404271696", "bodyText": "Rename so it follows java naming guidelines (camel-case) as it is not a constant.", "author": "jvanhill", "createdAt": "2020-04-06T17:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDE3Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395294173", "bodyText": "Javadoc.\nShould this also be an abstract class?", "author": "jvanhill", "createdAt": "2020-03-19T20:15:39Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDQwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395294401", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Get Pebble's intermediate certificate.\n          \n          \n            \n            \t * Get the CA server's intermediate certificate.", "author": "jvanhill", "createdAt": "2020-03-19T20:16:06Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDgwMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395294800", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return Pebble's root CA certificate in the form of a PEM file.\n          \n          \n            \n            \t * @return The CA's intermediate certificate in the form of PEM contained in a byte array.", "author": "jvanhill", "createdAt": "2020-03-19T20:16:50Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTY3Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395295673", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n          \n          \n            \n            \t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));", "author": "jvanhill", "createdAt": "2020-03-19T20:18:33Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTgyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395295824", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);", "author": "jvanhill", "createdAt": "2020-03-19T20:18:51Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjAwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296003", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Get Pebble's root certificate.\n          \n          \n            \n            \t * Get the CA server's root certificate.", "author": "jvanhill", "createdAt": "2020-03-19T20:19:15Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjMxMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296311", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return Pebble's root CA certificate in the form of a PEM file.\n          \n          \n            \n            \t * @return The CA's root certificate in the form of PEM contained in a byte array.", "author": "jvanhill", "createdAt": "2020-03-19T20:19:53Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjU1OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296558", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);", "author": "jvanhill", "createdAt": "2020-03-19T20:20:24Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjY5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296698", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n          \n          \n            \n            \t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));", "author": "jvanhill", "createdAt": "2020-03-19T20:20:40Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NjkzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395296935", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);", "author": "jvanhill", "createdAt": "2020-03-19T20:21:08Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NzE5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395297198", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n          \n          \n            \n            \t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));", "author": "jvanhill", "createdAt": "2020-03-19T20:21:38Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NzM3Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395297372", "bodyText": "Javadoc", "author": "jvanhill", "createdAt": "2020-03-19T20:22:00Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5Nzg5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395297899", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);", "author": "jvanhill", "createdAt": "2020-03-19T20:22:56Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5ODAzOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395298039", "bodyText": "Javadoc. Maybe explain how you replicated what was in the docker-compose file.", "author": "jvanhill", "createdAt": "2020-03-19T20:23:13Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5OTg5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395299896", "bodyText": "white space", "author": "jvanhill", "createdAt": "2020-03-19T20:26:50Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(IMAGE);\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+    }\n+    \n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t@Override", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMDI1Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395300256", "bodyText": "How is this different then the method in CAContainer?", "author": "jvanhill", "createdAt": "2020-03-19T20:27:33Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(IMAGE);\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+    }\n+    \n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjE0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395302140", "bodyText": "It appears that you set this value in CAContainer... do we need this one? This value is somewhat ghosting the one in CAContainer.", "author": "jvanhill", "createdAt": "2020-03-19T20:31:05Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjc1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395302751", "bodyText": "Rename to DOCKER image? May want to comment that you create this one as part of replicating docker-compose with a GenericContainer.\nI wonder if WebSphere has it's own docker hub we could use?", "author": "jvanhill", "createdAt": "2020-03-19T20:32:21Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.utility.MountableFile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class BoulderContainer extends CAContainer {\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 8055;\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String IMAGE = \"ryanesch/acme-boulder:latest\";", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjkzMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395302931", "bodyText": "We also probably need instruction on how you created your image.", "author": "jvanhill", "createdAt": "2020-03-19T20:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMzU2Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395303563", "bodyText": "Javadoc", "author": "jvanhill", "createdAt": "2020-03-19T20:33:54Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMzYyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395303629", "bodyText": "javadoc", "author": "jvanhill", "createdAt": "2020-03-19T20:34:03Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNDQ1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395304451", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);", "author": "jvanhill", "createdAt": "2020-03-19T20:35:43Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNDY3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395304677", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);", "author": "jvanhill", "createdAt": "2020-03-19T20:36:08Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNTc1Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395305752", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n          \n          \n            \n            \t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);", "author": "jvanhill", "createdAt": "2020-03-19T20:38:05Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNTk4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395305982", "bodyText": "Whitespace and javadoc", "author": "jvanhill", "createdAt": "2020-03-19T20:38:34Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpublic String getManagementAddress() {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNjA3Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395306073", "bodyText": "javadoc", "author": "jvanhill", "createdAt": "2020-03-19T20:38:45Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\tpublic String getAcmeDirectoryURI() {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNjE1Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395306153", "bodyText": "Javadoc.", "author": "jvanhill", "createdAt": "2020-03-19T20:38:56Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\tpublic String getAcmeDirectoryURI() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic String getIntraContainerIP() {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNjQ3OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395306478", "bodyText": "Don't use fail. Throw an IllegalStateException. We don't want to assume everyone is using these in JUnits.", "author": "jvanhill", "createdAt": "2020-03-19T20:39:35Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,372 @@\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Map.Entry;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+public class CAContainer extends GenericContainer<BoulderContainer> {\n+\n+\n+\tpublic static final int HTTP_PORT = 5002;\n+\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\n+\t/**\n+\t * Get Pebble's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(PebbleContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(PebbleContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get Pebble's root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Pebble's root CA certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(BoulderContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(BoulderContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(ChalltestsrvContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\tpublic String getAcmeDirectoryURI() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic String getIntraContainerIP() {\n+\t\tString intraContainerIpAddress = null;\n+\t\tfor (Entry<String, ContainerNetwork> entry : getContainerInfo().getNetworkSettings().getNetworks().entrySet()) {\n+\t\t\tintraContainerIpAddress = entry.getValue().getIpAddress();\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (intraContainerIpAddress == null) {\n+\t\t\tfail(\"Didn't find IP address for challtestsrv server.\");", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzI4NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395307285", "bodyText": "I wasn't really expecting both PebbleContainer and CAContainer to extend CAContainer. My expectation was that the There would be a new class that would wrap both the PebbleContainer and ChalltestsrvContainer that would extend the CAContainer. This class would then call through appropriately.", "author": "jvanhill", "createdAt": "2020-03-19T20:41:10Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/ChalltestsrvContainer.java", "diffHunk": "@@ -13,29 +13,19 @@\n \n import static junit.framework.Assert.fail;\n \n-import java.io.IOException;\n import java.util.Map.Entry;\n \n-import org.apache.http.StatusLine;\n-import org.apache.http.client.methods.CloseableHttpResponse;\n-import org.apache.http.client.methods.HttpPost;\n-import org.apache.http.entity.ContentType;\n-import org.apache.http.entity.StringEntity;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.testcontainers.containers.GenericContainer;\n import org.testcontainers.containers.Network;\n import org.testcontainers.containers.output.OutputFrame;\n \n import com.github.dockerjava.api.model.ContainerNetwork;\n import com.ibm.websphere.simplicity.log.Log;\n-import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n \n /**\n  * Testcontainer implementation for the letsencrypt/pebble-challtestsrv\n  * container.\n  */\n-public class ChalltestsrvContainer extends GenericContainer<ChalltestsrvContainer> {\n+public class ChalltestsrvContainer extends CAContainer {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzg0OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395307849", "bodyText": "Again, I expected a wrapper class to extend CAContainer and to contain the Pebble and Challtestserv containers.", "author": "jvanhill", "createdAt": "2020-03-19T20:42:23Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/PebbleContainer.java", "diffHunk": "@@ -33,13 +33,7 @@\n /**\n  * Testcontainer implementation for the letsencrypt/pebble container.\n  */\n-public class PebbleContainer extends GenericContainer<PebbleContainer> {\n-\n-\t/**\n-\t * The port that ACME HTTP validation requests will be sent to the domain\n-\t * on. Must match the port in 'publish/files/pebble-config.json'.\n-\t */\n-\tpublic static final int HTTP_PORT = 5002;\n+public class PebbleContainer extends CAContainer {", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTcwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r395309701", "bodyText": "Probably rename this file. What is this file for?", "author": "jvanhill", "createdAt": "2020-03-19T20:46:04Z", "path": "dev/com.ibm.ws.security.acme_fat/publish/files/test-ca2.pem", "diffHunk": "@@ -0,0 +1,25 @@\n+-----BEGIN CERTIFICATE-----", "originalCommit": "3dd0ccb898e794282f2c55bdc25f1b9f77207045", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1NTQzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404255438", "bodyText": "That's what boulder uses to get the intermediate certificate.", "author": "ryanesch", "createdAt": "2020-04-06T17:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTcwMQ=="}], "type": "inlineReview"}, {"oid": "7529c1ed7801b1972510d7432880d8ac14751133", "url": "https://github.com/OpenLiberty/open-liberty/commit/7529c1ed7801b1972510d7432880d8ac14751133", "message": "squash containers", "committedDate": "2020-03-28T21:08:09Z", "type": "forcePushed"}, {"oid": "9faeff463a2a98ead8c2e44258d46f74371f3736", "url": "https://github.com/OpenLiberty/open-liberty/commit/9faeff463a2a98ead8c2e44258d46f74371f3736", "message": "squash containers", "committedDate": "2020-03-28T21:38:02Z", "type": "forcePushed"}, {"oid": "12b00c5d135e551f48ae4ee1567e54ceb8054024", "url": "https://github.com/OpenLiberty/open-liberty/commit/12b00c5d135e551f48ae4ee1567e54ceb8054024", "message": "squash containers", "committedDate": "2020-03-28T21:42:50Z", "type": "forcePushed"}, {"oid": "556f2bf0d7cd627f526cd95379940eb7d82bf9de", "url": "https://github.com/OpenLiberty/open-liberty/commit/556f2bf0d7cd627f526cd95379940eb7d82bf9de", "message": "squash containers", "committedDate": "2020-03-31T21:53:45Z", "type": "forcePushed"}, {"oid": "d5587cea8eef806212fba92eb0abfb2887d87306", "url": "https://github.com/OpenLiberty/open-liberty/commit/d5587cea8eef806212fba92eb0abfb2887d87306", "message": "squash containers", "committedDate": "2020-04-05T23:26:17Z", "type": "forcePushed"}, {"oid": "c90862ec1ed8c65904674e71564ad8fcfbe22375", "url": "https://github.com/OpenLiberty/open-liberty/commit/c90862ec1ed8c65904674e71564ad8fcfbe22375", "message": "squash containers", "committedDate": "2020-04-06T17:00:11Z", "type": "forcePushed"}, {"oid": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "url": "https://github.com/OpenLiberty/open-liberty/commit/3c28406c01e42dd902f376fac4532e84cf17aa5f", "message": "squash containers", "committedDate": "2020-04-06T17:14:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NzExOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401867118", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, 2020 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2020 IBM Corporation and others.", "author": "jvanhill", "createdAt": "2020-04-01T19:47:14Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.", "originalCommit": "556f2bf0d7cd627f526cd95379940eb7d82bf9de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NzQ1NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401867455", "bodyText": "Lets not require Junit to run this, otherwise running it outside of Junit will be confusing.", "author": "jvanhill", "createdAt": "2020-04-01T19:47:50Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;", "originalCommit": "556f2bf0d7cd627f526cd95379940eb7d82bf9de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NzYwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401867607", "bodyText": "Whitespace.", "author": "jvanhill", "createdAt": "2020-04-01T19:48:07Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**", "originalCommit": "556f2bf0d7cd627f526cd95379940eb7d82bf9de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2ODMxNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401868315", "bodyText": "Can you do a reformat of this file? seems the indenting is not correct.", "author": "jvanhill", "createdAt": "2020-04-01T19:49:19Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\tprivate static String TRUSTSTORE_FILE;\n+\tprivate static String FILE_ACCOUNT_KEY;\n+\tprivate static String FILE_DOMAIN_KEY;\n+\tprivate static final String TRUSTSTORE_PASSWORD = \"password\";\n+\tprivate static X509Certificate intermediateCertificate = null;\n+\tprivate static HttpChallengeServer challengeServer = null;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/test-ca2.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*", "originalCommit": "556f2bf0d7cd627f526cd95379940eb7d82bf9de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2OTAyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r401869028", "bodyText": "Why is this here? Liberty will be the challenge server.", "author": "jvanhill", "createdAt": "2020-04-01T19:50:35Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\n+\tprivate static String TRUSTSTORE_FILE;\n+\tprivate static String FILE_ACCOUNT_KEY;\n+\tprivate static String FILE_DOMAIN_KEY;\n+\tprivate static final String TRUSTSTORE_PASSWORD = \"password\";\n+\tprivate static X509Certificate intermediateCertificate = null;\n+\tprivate static HttpChallengeServer challengeServer = null;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/test-ca2.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:latest\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\n+\t\t/*\n+\t\t * Start a simple HTTP server to respond to challenges.\n+\t\t */\n+\t\tchallengeServer = new HttpChallengeServer(HTTP_PORT);", "originalCommit": "556f2bf0d7cd627f526cd95379940eb7d82bf9de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NzU1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404267550", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, 2020 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2020 IBM Corporation and others.", "author": "jvanhill", "createdAt": "2020-04-06T17:33:02Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2ODM5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404268399", "bodyText": "weird alignment.", "author": "jvanhill", "createdAt": "2020-04-06T17:34:29Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2ODQ5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404268496", "bodyText": "whitespace", "author": "jvanhill", "createdAt": "2020-04-06T17:34:39Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2ODkxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404268916", "bodyText": "whitespace", "author": "jvanhill", "createdAt": "2020-04-06T17:35:16Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTExMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404269110", "bodyText": "whitespace", "author": "jvanhill", "createdAt": "2020-04-06T17:35:35Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}\n+\t/**", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTQ1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404269459", "bodyText": "Remove this comment. Make the methods abstract to force their implementation in child classes.", "author": "jvanhill", "createdAt": "2020-04-06T17:36:16Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTY4Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404269683", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n          \n          \n            \n            \tpublic abstract String getAcmeDirectoryURI(boolean usePebbleURI);", "author": "jvanhill", "createdAt": "2020-04-06T17:36:38Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTkxNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404269917", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn null;", "author": "jvanhill", "createdAt": "2020-04-06T17:36:58Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDAwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404270001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t}", "author": "jvanhill", "createdAt": "2020-04-06T17:37:08Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDI4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404270284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic String getIntraContainerIP() {\n          \n          \n            \n            \tpublic abstract String getIntraContainerIP();", "author": "jvanhill", "createdAt": "2020-04-06T17:37:34Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}\n+\t/**\n+\t * Get the IP address for the container as seen from the container network.\n+\t * \n+\t * @return The IP address for the container on the container network.\n+\t */\n+\tpublic String getIntraContainerIP() {", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDQzNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404270437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn null;", "author": "jvanhill", "createdAt": "2020-04-06T17:37:48Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}\n+\t/**\n+\t * Get the IP address for the container as seen from the container network.\n+\t * \n+\t * @return The IP address for the container on the container network.\n+\t */\n+\tpublic String getIntraContainerIP() {\n+\t\treturn null;", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDU2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404270565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t}", "author": "jvanhill", "createdAt": "2020-04-06T17:38:01Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT);\n+\t}\n+\n+\t/*\n+\t * The following methods should be overridden in the respective container class.\n+\t */\n+\t\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI. This param is ignored for Boulder.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn null;\n+\t}\n+\t/**\n+\t * Get the IP address for the container as seen from the container network.\n+\t * \n+\t * @return The IP address for the container on the container network.\n+\t */\n+\tpublic String getIntraContainerIP() {\n+\t\treturn null;\n+\t}", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTA5Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404271097", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, 2020 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2020 IBM Corporation and others.", "author": "jvanhill", "createdAt": "2020-04-06T17:38:51Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MjAzNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404272037", "bodyText": "whitespace", "author": "jvanhill", "createdAt": "2020-04-06T17:40:22Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NTk0Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404275947", "bodyText": "Should this be static? Doesn't seem that we would want to directly reference BoulderContainer.LISTEN_PORT from outside this class? Maybe we would call CAContainer.getListenPort()....", "author": "jvanhill", "createdAt": "2020-04-06T17:46:48Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQzNzkxNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r406437914", "bodyText": "I removed the static modifier. Pebble uses a different listen port.", "author": "ryanesch", "createdAt": "2020-04-09T19:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NTk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjE2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404276160", "bodyText": "Javadoc", "author": "jvanhill", "createdAt": "2020-04-06T17:47:12Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjU4OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404276589", "bodyText": "I would move this as a comment in the method so we don't override the inherited javadoc.", "author": "jvanhill", "createdAt": "2020-04-06T17:47:54Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3Njg1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404276859", "bodyText": "Move inside the method. Don't override the inherited javadoc.", "author": "jvanhill", "createdAt": "2020-04-06T17:48:22Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzI0Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404277247", "bodyText": "Is there a reason to override the inherited javadoc?", "author": "jvanhill", "createdAt": "2020-04-06T17:48:59Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.\n+     */\n+    @Override\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\treturn new FileInputStream(new File(FILE_MINICA_PEM));\n+\t}\n+    /**\n+     * Get Boulder's directory URI. Pebble has two possible URIs to", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzM2NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404277364", "bodyText": "whitespace", "author": "jvanhill", "createdAt": "2020-04-06T17:49:08Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.\n+     */\n+    @Override\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\treturn new FileInputStream(new File(FILE_MINICA_PEM));\n+\t}\n+    /**", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzQxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404277412", "bodyText": "Is there a reason to override the inherited javadoc?", "author": "jvanhill", "createdAt": "2020-04-06T17:49:13Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNzM1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404427351", "bodyText": "no", "author": "ryanesch", "createdAt": "2020-04-06T22:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzU1NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404277554", "bodyText": "whitespace", "author": "jvanhill", "createdAt": "2020-04-06T17:49:28Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.\n+     */\n+    @Override\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\treturn new FileInputStream(new File(FILE_MINICA_PEM));\n+\t}\n+    /**\n+     * Get Boulder's directory URI. Pebble has two possible URIs to\n+     * return, so the method takes a boolean. Boulder will always\n+     * return this URI.\n+     * \n+\t * @return The URI to the ACME CA's directory.\n+     */\n+\t@Override\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT) + \"/directory\";\n+\t}\n+\t/**", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3ODI3OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404278279", "bodyText": "It appears both this and PebbleContianer have this method. Why isn't this defined in the CAContainer class? Either as an abstract method, or if these are the same, then as a concrete method. (That is if this method should be callable publicly, if not make it private.)", "author": "jvanhill", "createdAt": "2020-04-06T17:50:37Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/boulder/BoulderContainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker.boulder;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.Map.Entry;\n+\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.github.dockerjava.api.model.ContainerNetwork.Ipam;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.AcmeCaException;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+import com.ibm.ws.security.acme.fat.FATSuite;\n+import com.ibm.ws.security.acme.internal.AcmeClient;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+import com.ibm.ws.security.acme.utils.HttpChallengeServer;\n+/**\n+ * Testcontainer implementation for the letsencrypt/boulder container.\n+ * Boulder is designed to run with docker-compose. In order to integrate\n+ * Boulder into the acme FAT, the docker-compose file from letsencrypt\n+ * was turned into the following GenericContainers. This class consists\n+ * of three containers and two networks. Because Boulder consists of\n+ * many files, a Docker image was created that is built on top of\n+ * letsencrypt/boulder-tools-go and includes all the files that would\n+ * otherwise need to be copied at runtime. This saves 8+ minutes per\n+ * run.\n+ */\n+public class BoulderContainer extends CAContainer {\n+\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 4001;\n+\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/boulder.minica.pem\";\n+\t\n+\n+    \n+    public final Network bluenet = Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.77.77.0/24\")));\n+            })\n+            .build();\n+\n+    public final Network rednet =  Network.builder()\n+            .createNetworkCmdModifier(cmd -> {\n+                cmd.withDriver(\"bridge\");\n+                cmd.withIpam(new com.github.dockerjava.api.model.Network.Ipam()\n+                        .withDriver(\"default\")\n+                        .withConfig(new com.github.dockerjava.api.model.Network.Ipam.Config()\n+                                .withSubnet(\"10.88.88.0/24\")));\n+            })\n+            .build();\n+    \n+    public final GenericContainer<?> bhsm = new GenericContainer<>(DOCKER_IMAGE)\n+            .withEnv(\"PKCS11_DAEMON_SOCKET\", \"tcp://0.0.0.0:5657\")\n+            .withExposedPorts(5657)\n+            .withNetwork(bluenet)\n+            .withNetworkAliases(\"boulder-hsm\")\n+            .withCommand(\"/usr/local/bin/pkcs11-daemon /usr/lib/softhsm/libsofthsm2.so\")\n+            .withLogConsumer(o -> System.out.print(\"[HSM] \" + o.getUtf8String()));\n+    \n+    public final GenericContainer<?> bmysql = new GenericContainer<>(\"mariadb:10.3\")\n+            .withNetwork(bluenet)\n+            .withExposedPorts(3306)\n+            .withNetworkAliases(\"boulder-mysql\")\n+            .withEnv(\"MYSQL_ALLOW_EMPTY_PASSWORD\", \"yes\")\n+            .withCommand(\"mysqld --bind-address=0.0.0.0 --slow-query-log --log-output=TABLE --log-queries-not-using-indexes=ON\")\n+            .withLogConsumer(o -> System.out.print(\"[SQL] \" + o.getUtf8String()));\n+    \n+    private static final String DOCKER_IMAGE = \"ryanesch/acme-boulder:1.1\";\n+    \n+    public BoulderContainer() {\n+        super(DOCKER_IMAGE);\n+\t\t/*\n+\t\t * Need to expose the HTTP port that is used to answer the HTTP-01\n+\t\t * challenge.\n+\t\t */\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+    \tstart();\n+    }\n+    \n+    @Override\n+    protected void configure() {\n+            this.withEnv(\"FAKE_DNS\", \"172.17.0.68\")\n+            .withEnv(\"PKCS11_PROXY_SOCKET\", \"tcp://boulder-hsm:5657\")\n+            .withEnv(\"BOULDER_CONFIG_DIR\", \"test/config\")\n+            .withEnv(\"GO111MODULE\", \"on\")\n+            .withEnv(\"GOFLAGS\", \"-mod=vendor\")\n+            .withEnv(\"PYTHONIOENCODING\", \"utf-8\")\n+            .withCreateContainerCmdModifier(cmd -> {\n+                cmd.withDns(\"10.77.77.77\");\n+            })\n+            \n+            .withWorkingDirectory(\"/go/src/github.com/letsencrypt/boulder\")\n+            .withCommand(\"/go/src/github.com/letsencrypt/boulder/test/entrypoint.sh\")\n+            .withNetworkAliases(\"boulder\")\n+            .withCreateContainerCmdModifier(cmd -> cmd.withHostName(\"boulder\"))\n+    \t\t.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT)\n+            .withLogConsumer(o -> System.out.print(\"[BOL] \" + o.getUtf8String()))\n+            .withStartupTimeout(Duration.ofMinutes(3));\n+    }\n+    \t\t\t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\n+    \t\t\t\t\t\t\t\t\t\n+\n+    @Override\n+    protected void containerIsCreated(String containerId) {\n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(bluenet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.77.77.77\")\n+                        .withNetworkID(bluenet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.77.77.77\"))\n+                        .withAliases(\"sa1.boulder\", \"ca1.boulder\", \"ra1.boulder\", \"va1.boulder\", \"publisher1.boulder\", \n+                              \"ocsp-updater.boulder\", \"admin-revoker.boulder\", \"nonce1.boulder\"))\n+                .exec();\n+        \n+        getDockerClient().connectToNetworkCmd()\n+                .withNetworkId(rednet.getId())\n+                .withContainerId(containerId)\n+                .withContainerNetwork(new ContainerNetwork()\n+                        .withIpv4Address(\"10.88.88.88\")\n+                        .withNetworkID(rednet.getId())\n+                        .withIpamConfig(new Ipam().withIpv4Address(\"10.88.88.88\"))\n+                        .withAliases(\"sa2.boulder\", \"ca2.boulder\", \"ra2.boulder\", \"va2.boulder\", \n+                                \"publisher2.boulder\", \"nonce2.boulder\"))\n+                .exec();\n+    }\n+    \n+\t/**\n+\t * We need to start up the containers in an orderly fashion so that we can\n+\t * pass the IP address of the DNS server to the Boulder server.\n+\t * @throws IOException \n+\t */\n+    @Override\n+    public void start() {\n+        bmysql.start();\n+        bhsm.start();\n+        super.start();\n+        addARecords();\n+    }\n+    \n+    /**\n+     * Stop all the containers, the challenge server, and the networks.\n+     */\n+    @Override\n+    public void stop() {\n+        bmysql.stop();\n+        bhsm.stop();\n+        super.stop();\n+\t\tbluenet.close();\n+\t\trednet.close();\n+    }\n+   \n+    /**\n+     * @return the InputStream that points to Boulder's PEM file.\n+     */\n+    @Override\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\treturn new FileInputStream(new File(FILE_MINICA_PEM));\n+\t}\n+    /**\n+     * Get Boulder's directory URI. Pebble has two possible URIs to\n+     * return, so the method takes a boolean. Boulder will always\n+     * return this URI.\n+     * \n+\t * @return The URI to the ACME CA's directory.\n+     */\n+\t@Override\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\treturn \"http://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT) + \"/directory\";\n+\t}\n+\t/**\n+\t * Get the IP address for the container as seen from the container network.\n+\t * \n+\t * @return The IP address for the container on the container network.\n+\t */\n+\tpublic String getIntraContainerIP() {", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3OTEwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404279103", "bodyText": "whitespace", "author": "jvanhill", "createdAt": "2020-04-06T17:51:55Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+package com.ibm.ws.security.acme.docker.pebble;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.util.Map.Entry;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.output.OutputFrame;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+\n+/**\n+ * Testcontainer implementation for the letsencrypt/pebble container.\n+ */\n+public class PebbleContainer extends CAContainer {\n+\t\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 14000;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 15000;\n+\t/**\n+\t * The mock DNS server port.\n+\t */\n+\tpublic static final int DNS_PORT = 8053;\n+\n+\t/**\n+\t * The REST management port.\n+\t */\n+\tpublic static final int CHALL_MANAGEMENT_PORT = 8055;\n+\t\n+\t\n+\tprivate Network network = Network.newNetwork();\n+\n+\t\n+    public final GenericContainer<?> challtestsrv = new GenericContainer<>(\"letsencrypt/pebble-challtestsrv\")\n+     .withCommand(\"pebble-challtestsrv\")\n+\t .withExposedPorts(DNS_PORT, CHALL_MANAGEMENT_PORT)\n+     .withNetwork(network)\n+\t .withLogConsumer(o -> System.out.print(\"[CHL] \" + o.getUtf8String()));\n+\t\n+\t/**\n+\t * Log the output from this testcontainer.\n+\t * \n+\t * @param frame\n+\t *            The frame containing log data.\n+\t */\n+\tpublic static void log(OutputFrame frame) {\n+\t\tString msg = frame.getUtf8String();\n+\t\tif (msg.endsWith(\"\\n\"))\n+\t\t\tmsg = msg.substring(0, msg.length() - 1);\n+\t\tLog.info(PebbleContainer.class, \"pebble\", msg);\n+\t}\n+\n+\t/**\n+\t * Instantiate a new {@link PebbleContainer} instance.\n+\t * \n+\t * @param dnsServer\n+\t *            Address of the DNS server to use to make DNS lookups for\n+\t *            domains.\n+\t */\n+\tpublic PebbleContainer() {\n+\t\tsuper(new ImageFromDockerfile()\n+\t\t\t\t.withDockerfileFromBuilder(builder -> builder.from(\"letsencrypt/pebble\")\n+\t\t\t\t\t\t.copy(\"pebble-config.json\", \"/test/config/pebble-config.json\").build())\n+\t\t\t\t.withFileFromFile(\"pebble-config.json\", new File(\"lib/LibertyFATTestFiles/pebble-config.json\")), MANAGEMENT_PORT);\n+\t\t\n+\t\tchalltestsrv.start();\n+\t\t\n+\t\tString dnsServer = getIntraContainerIP() + \":\" + DNS_PORT;\n+\n+\t\tthis.withCommand(\"pebble\", \"-dnsserver\", dnsServer, \"-config\", \"/test/config/pebble-config.json\", \"-strict\",\n+\t\t\t\t\"false\");\n+\t\tthis.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT);\n+\t\tthis.withNetwork(network);\n+\t\tthis.withLogConsumer(PebbleContainer::log);\n+\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\t\t\n+\t\tstart();\n+\t\t\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerIpAddress: \" + getContainerIpAddress());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"DockerImageName:    \" + getDockerImageName());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerInfo:      \" + getContainerInfo());\n+\t\t\n+        addARecords();\n+\t}\n+\t@Override", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3OTM4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404279381", "bodyText": "It appears both this and BoulderContainer have this method. Why isn't this defined in the CAContainer class? Either as an abstract method, or if these are the same, then as a concrete method. (That is if this method should be callable publicly, if not make it private.)", "author": "jvanhill", "createdAt": "2020-04-06T17:52:23Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+package com.ibm.ws.security.acme.docker.pebble;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.util.Map.Entry;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.output.OutputFrame;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+\n+/**\n+ * Testcontainer implementation for the letsencrypt/pebble container.\n+ */\n+public class PebbleContainer extends CAContainer {\n+\t\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 14000;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 15000;\n+\t/**\n+\t * The mock DNS server port.\n+\t */\n+\tpublic static final int DNS_PORT = 8053;\n+\n+\t/**\n+\t * The REST management port.\n+\t */\n+\tpublic static final int CHALL_MANAGEMENT_PORT = 8055;\n+\t\n+\t\n+\tprivate Network network = Network.newNetwork();\n+\n+\t\n+    public final GenericContainer<?> challtestsrv = new GenericContainer<>(\"letsencrypt/pebble-challtestsrv\")\n+     .withCommand(\"pebble-challtestsrv\")\n+\t .withExposedPorts(DNS_PORT, CHALL_MANAGEMENT_PORT)\n+     .withNetwork(network)\n+\t .withLogConsumer(o -> System.out.print(\"[CHL] \" + o.getUtf8String()));\n+\t\n+\t/**\n+\t * Log the output from this testcontainer.\n+\t * \n+\t * @param frame\n+\t *            The frame containing log data.\n+\t */\n+\tpublic static void log(OutputFrame frame) {\n+\t\tString msg = frame.getUtf8String();\n+\t\tif (msg.endsWith(\"\\n\"))\n+\t\t\tmsg = msg.substring(0, msg.length() - 1);\n+\t\tLog.info(PebbleContainer.class, \"pebble\", msg);\n+\t}\n+\n+\t/**\n+\t * Instantiate a new {@link PebbleContainer} instance.\n+\t * \n+\t * @param dnsServer\n+\t *            Address of the DNS server to use to make DNS lookups for\n+\t *            domains.\n+\t */\n+\tpublic PebbleContainer() {\n+\t\tsuper(new ImageFromDockerfile()\n+\t\t\t\t.withDockerfileFromBuilder(builder -> builder.from(\"letsencrypt/pebble\")\n+\t\t\t\t\t\t.copy(\"pebble-config.json\", \"/test/config/pebble-config.json\").build())\n+\t\t\t\t.withFileFromFile(\"pebble-config.json\", new File(\"lib/LibertyFATTestFiles/pebble-config.json\")), MANAGEMENT_PORT);\n+\t\t\n+\t\tchalltestsrv.start();\n+\t\t\n+\t\tString dnsServer = getIntraContainerIP() + \":\" + DNS_PORT;\n+\n+\t\tthis.withCommand(\"pebble\", \"-dnsserver\", dnsServer, \"-config\", \"/test/config/pebble-config.json\", \"-strict\",\n+\t\t\t\t\"false\");\n+\t\tthis.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT);\n+\t\tthis.withNetwork(network);\n+\t\tthis.withLogConsumer(PebbleContainer::log);\n+\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\t\t\n+\t\tstart();\n+\t\t\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerIpAddress: \" + getContainerIpAddress());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"DockerImageName:    \" + getDockerImageName());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerInfo:      \" + getContainerInfo());\n+\t\t\n+        addARecords();\n+\t}\n+\t@Override\n+\tpublic void stop() {\n+\t\tchalltestsrv.stop();\n+\t\tsuper.stop();\n+\t\tnetwork.close();\n+\t}\n+\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\tif (usePebbleURI) {\n+\t\t\t/*\n+\t\t\t * The \"acme://pebble/<host>:<port>\" will tell acme4j to load the\n+\t\t\t * PebbleAcmeProvider and PebbleHttpConnector, which will trust\n+\t\t\t * Pebble's static self-signed certificate.\n+\t\t\t */\n+\t\t\treturn \"acme://pebble/\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * This will cause acme4j to use the GenericAcmeProvider.\n+\t\t\t */\n+\t\t\treturn \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT) + \"/dir\";\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the IP address for the challtestsrv container as seen from the container network.\n+\t * \n+\t * @return The IP address for the challenge test server on the container.\n+\t */\n+\tpublic String getIntraContainerIP() {", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3OTg4Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404279883", "bodyText": "@OverRide?\nIf so then don't redefine the javadoc.", "author": "jvanhill", "createdAt": "2020-04-06T17:53:13Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+package com.ibm.ws.security.acme.docker.pebble;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.util.Map.Entry;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.output.OutputFrame;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+\n+/**\n+ * Testcontainer implementation for the letsencrypt/pebble container.\n+ */\n+public class PebbleContainer extends CAContainer {\n+\t\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 14000;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 15000;\n+\t/**\n+\t * The mock DNS server port.\n+\t */\n+\tpublic static final int DNS_PORT = 8053;\n+\n+\t/**\n+\t * The REST management port.\n+\t */\n+\tpublic static final int CHALL_MANAGEMENT_PORT = 8055;\n+\t\n+\t\n+\tprivate Network network = Network.newNetwork();\n+\n+\t\n+    public final GenericContainer<?> challtestsrv = new GenericContainer<>(\"letsencrypt/pebble-challtestsrv\")\n+     .withCommand(\"pebble-challtestsrv\")\n+\t .withExposedPorts(DNS_PORT, CHALL_MANAGEMENT_PORT)\n+     .withNetwork(network)\n+\t .withLogConsumer(o -> System.out.print(\"[CHL] \" + o.getUtf8String()));\n+\t\n+\t/**\n+\t * Log the output from this testcontainer.\n+\t * \n+\t * @param frame\n+\t *            The frame containing log data.\n+\t */\n+\tpublic static void log(OutputFrame frame) {\n+\t\tString msg = frame.getUtf8String();\n+\t\tif (msg.endsWith(\"\\n\"))\n+\t\t\tmsg = msg.substring(0, msg.length() - 1);\n+\t\tLog.info(PebbleContainer.class, \"pebble\", msg);\n+\t}\n+\n+\t/**\n+\t * Instantiate a new {@link PebbleContainer} instance.\n+\t * \n+\t * @param dnsServer\n+\t *            Address of the DNS server to use to make DNS lookups for\n+\t *            domains.\n+\t */\n+\tpublic PebbleContainer() {\n+\t\tsuper(new ImageFromDockerfile()\n+\t\t\t\t.withDockerfileFromBuilder(builder -> builder.from(\"letsencrypt/pebble\")\n+\t\t\t\t\t\t.copy(\"pebble-config.json\", \"/test/config/pebble-config.json\").build())\n+\t\t\t\t.withFileFromFile(\"pebble-config.json\", new File(\"lib/LibertyFATTestFiles/pebble-config.json\")), MANAGEMENT_PORT);\n+\t\t\n+\t\tchalltestsrv.start();\n+\t\t\n+\t\tString dnsServer = getIntraContainerIP() + \":\" + DNS_PORT;\n+\n+\t\tthis.withCommand(\"pebble\", \"-dnsserver\", dnsServer, \"-config\", \"/test/config/pebble-config.json\", \"-strict\",\n+\t\t\t\t\"false\");\n+\t\tthis.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT);\n+\t\tthis.withNetwork(network);\n+\t\tthis.withLogConsumer(PebbleContainer::log);\n+\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\t\t\n+\t\tstart();\n+\t\t\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerIpAddress: \" + getContainerIpAddress());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"DockerImageName:    \" + getDockerImageName());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerInfo:      \" + getContainerInfo());\n+\t\t\n+        addARecords();\n+\t}\n+\t@Override\n+\tpublic void stop() {\n+\t\tchalltestsrv.stop();\n+\t\tsuper.stop();\n+\t\tnetwork.close();\n+\t}\n+\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MDYzNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404280636", "bodyText": "Don't override Javadoc.", "author": "jvanhill", "createdAt": "2020-04-06T17:54:25Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleContainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+\n+package com.ibm.ws.security.acme.docker.pebble;\n+\n+import static junit.framework.Assert.fail;\n+\n+import java.io.File;\n+import java.util.Map.Entry;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.output.OutputFrame;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.github.dockerjava.api.model.ContainerNetwork;\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.docker.CAContainer;\n+\n+/**\n+ * Testcontainer implementation for the letsencrypt/pebble container.\n+ */\n+public class PebbleContainer extends CAContainer {\n+\t\n+\t/** The port used to listen for incoming ACME requests. */\n+\tpublic static final int LISTEN_PORT = 14000;\n+\n+\t/** The REST management API port. */\n+\tpublic static final int MANAGEMENT_PORT = 15000;\n+\t/**\n+\t * The mock DNS server port.\n+\t */\n+\tpublic static final int DNS_PORT = 8053;\n+\n+\t/**\n+\t * The REST management port.\n+\t */\n+\tpublic static final int CHALL_MANAGEMENT_PORT = 8055;\n+\t\n+\t\n+\tprivate Network network = Network.newNetwork();\n+\n+\t\n+    public final GenericContainer<?> challtestsrv = new GenericContainer<>(\"letsencrypt/pebble-challtestsrv\")\n+     .withCommand(\"pebble-challtestsrv\")\n+\t .withExposedPorts(DNS_PORT, CHALL_MANAGEMENT_PORT)\n+     .withNetwork(network)\n+\t .withLogConsumer(o -> System.out.print(\"[CHL] \" + o.getUtf8String()));\n+\t\n+\t/**\n+\t * Log the output from this testcontainer.\n+\t * \n+\t * @param frame\n+\t *            The frame containing log data.\n+\t */\n+\tpublic static void log(OutputFrame frame) {\n+\t\tString msg = frame.getUtf8String();\n+\t\tif (msg.endsWith(\"\\n\"))\n+\t\t\tmsg = msg.substring(0, msg.length() - 1);\n+\t\tLog.info(PebbleContainer.class, \"pebble\", msg);\n+\t}\n+\n+\t/**\n+\t * Instantiate a new {@link PebbleContainer} instance.\n+\t * \n+\t * @param dnsServer\n+\t *            Address of the DNS server to use to make DNS lookups for\n+\t *            domains.\n+\t */\n+\tpublic PebbleContainer() {\n+\t\tsuper(new ImageFromDockerfile()\n+\t\t\t\t.withDockerfileFromBuilder(builder -> builder.from(\"letsencrypt/pebble\")\n+\t\t\t\t\t\t.copy(\"pebble-config.json\", \"/test/config/pebble-config.json\").build())\n+\t\t\t\t.withFileFromFile(\"pebble-config.json\", new File(\"lib/LibertyFATTestFiles/pebble-config.json\")), MANAGEMENT_PORT);\n+\t\t\n+\t\tchalltestsrv.start();\n+\t\t\n+\t\tString dnsServer = getIntraContainerIP() + \":\" + DNS_PORT;\n+\n+\t\tthis.withCommand(\"pebble\", \"-dnsserver\", dnsServer, \"-config\", \"/test/config/pebble-config.json\", \"-strict\",\n+\t\t\t\t\"false\");\n+\t\tthis.withExposedPorts(MANAGEMENT_PORT, LISTEN_PORT);\n+\t\tthis.withNetwork(network);\n+\t\tthis.withLogConsumer(PebbleContainer::log);\n+\n+\t\tTestcontainers.exposeHostPorts(HTTP_PORT);\n+\t\t\n+\t\tstart();\n+\t\t\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerIpAddress: \" + getContainerIpAddress());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"DockerImageName:    \" + getDockerImageName());\n+\t\tLog.info(PebbleContainer.class, \"PebbleContainer\", \"ContainerInfo:      \" + getContainerInfo());\n+\t\t\n+        addARecords();\n+\t}\n+\t@Override\n+\tpublic void stop() {\n+\t\tchalltestsrv.stop();\n+\t\tsuper.stop();\n+\t\tnetwork.close();\n+\t}\n+\n+\t/**\n+\t * Get the URI to the ACME CA's directory.\n+\t * \n+\t * @param usePebbleURI\n+\t *            Use the \"acme://pebble\" style URI instead of the generic\n+\t *            \"https:\" URI.\n+\t * @return The URI to the ACME CA's directory.\n+\t */\n+\tpublic String getAcmeDirectoryURI(boolean usePebbleURI) {\n+\t\tif (usePebbleURI) {\n+\t\t\t/*\n+\t\t\t * The \"acme://pebble/<host>:<port>\" will tell acme4j to load the\n+\t\t\t * PebbleAcmeProvider and PebbleHttpConnector, which will trust\n+\t\t\t * Pebble's static self-signed certificate.\n+\t\t\t */\n+\t\t\treturn \"acme://pebble/\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * This will cause acme4j to use the GenericAcmeProvider.\n+\t\t\t */\n+\t\t\treturn \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(LISTEN_PORT) + \"/dir\";\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the IP address for the challtestsrv container as seen from the container network.\n+\t * \n+\t * @return The IP address for the challenge test server on the container.\n+\t */\n+\tpublic String getIntraContainerIP() {\n+\t\tString intraContainerIpAddress = null;\n+\t\tfor (Entry<String, ContainerNetwork> entry : challtestsrv.getContainerInfo().getNetworkSettings().getNetworks().entrySet()) {\n+\t\t\tintraContainerIpAddress = entry.getValue().getIpAddress();\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (intraContainerIpAddress == null) {\n+\t\t\tfail(\"Didn't find IP address for challtestsrv server.\");\n+\t\t}\n+\n+\t\treturn intraContainerIpAddress;\n+\t}\n+    \n+\t/**", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MTcxNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404281714", "bodyText": "This logic is specific for Boulder. Pebble overrides it. Seems this method should be abstract and this version moved to BoulderContainer.", "author": "jvanhill", "createdAt": "2020-04-06T17:56:14Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/CAContainer.java", "diffHunk": "@@ -0,0 +1,442 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.security.acme.docker;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.cert.X509Certificate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.http.StatusLine;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.images.builder.ImageFromDockerfile;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+import com.ibm.ws.security.acme.utils.AcmeFatUtils;\n+\n+/**\n+ * Testcontainer implementation for Pebble and Boulder Certificate Authorities.\n+ * \n+ */\n+public class CAContainer extends GenericContainer<CAContainer> {\n+\n+\tprivate static final String TEST_DOMAIN_1 = \"domain1.com\";\n+\tprivate static final String TEST_DOMAIN_2 = \"domain2.com\";\n+\tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n+\tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n+\t\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;\n+\t/** The REST management API port. */\n+\tpublic int MANAGEMENT_PORT = 8055;\n+\t\n+\t/**\n+\t * This constructor is used by BoulderContainer\n+\t */\n+\tpublic CAContainer(String image) {\n+\t\tsuper(image);\n+\t}\n+\n+\t/**\n+\t * This constructor is used by PebbleContainer. The\n+\t * management port is different for Pebble, so this\n+\t * is passed in.\n+\t */\n+\tpublic CAContainer(ImageFromDockerfile image, int managementPort) {\n+\t\tsuper(image);\n+\t\tMANAGEMENT_PORT = managementPort;\n+\t}\n+\n+\t/**\n+\t * Get CA's intermediate certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return CA's intermediate certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic InputStream getAcmeCaIntermediateCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaIntermediateCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/intermediates/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn  new ByteArrayInputStream(result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get the root certificate.\n+\t * \n+\t * @param fileName\n+\t *            The name of the file to save the certificate to.\n+\t * @return Certificate Authority's root certificate in the form of a PEM file.\n+\t * @throws Exception\n+\t *             If we failed to receive the certificate.\n+\t */\n+\tpublic byte[] getAcmeCaRootCertificate() throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCaRootCertificate()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT) + \"/roots/0\";\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] result = EntityUtils.toByteArray(response.getEntity());\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Get the status of the certificate from the ACME CA server.\n+\t * \n+\t * @param certificate\n+\t *            The certificate to check.\n+\t * @return The status of the certificate.\n+\t * @throws Exception\n+\t */\n+\tpublic String getAcmeCertificateStatus(X509Certificate certificate) throws Exception {\n+\t\tfinal String METHOD_NAME = \"getAcmeCertificateStatus()\";\n+\t\tString url = \"https://\" + this.getContainerIpAddress() + \":\" + this.getMappedPort(MANAGEMENT_PORT)\n+\t\t\t\t+ \"/cert-status-by-serial/\" + certificate.getSerialNumber().toString(16);\n+\n+\t\ttry (CloseableHttpClient httpclient = AcmeFatUtils.getInsecureHttpsClient()) {\n+\t\t\t/*\n+\t\t\t * Create a GET request to the ACME CA server.\n+\t\t\t */\n+\t\t\tHttpGet httpGet = new HttpGet(url);\n+\n+\t\t\t/*\n+\t\t\t * Send the GET request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpGet)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpGet, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\n+\t\t\t\tString result = EntityUtils.toString(response.getEntity());\n+\n+\t\t\t\t/*\n+\t\t\t\t * The result is in JSON, lets just parse out the status.\n+\t\t\t\t */\n+\t\t\t\tPattern p = Pattern.compile(\".*\\\"Status\\\": \\\"(\\\\w+)\\\",.*\", Pattern.DOTALL);\n+\t\t\t\tMatcher m = p.matcher(result);\n+\t\t\t\tif (m.find()) {\n+\t\t\t\t\tresult = m.group(1);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new Exception(\n+\t\t\t\t\t\t\t\"Certificate status response was not in expected JSON format. Response: \" + result);\n+\t\t\t\t}\n+\n+\t\t\t\tLog.info(CAContainer.class, METHOD_NAME, new String(result));\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Retrieves the client host's IP address that is reachable from the\n+\t * container.\n+\t * \n+\t * @return The client host's IP address that is reachable from the\n+\t *         container.\n+\t * @throws IllegalStateException\n+\t *             If the address was not found.\n+\t */\n+\tpublic String getClientHost() throws IllegalStateException {\n+\t\tfor (String extraHost : this.getExtraHosts()) {\n+\t\t\tif (extraHost.startsWith(\"host.testcontainers.internal:\")) {\n+\t\t\t\treturn extraHost.replace(\"host.testcontainers.internal:\", \"\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Unable to resolve local host from docker container. Could not find 'host.testcontainers.internal' property.\");\n+\t}\n+\t\n+\t/**\n+\t * Add A and AAAA records.\n+\t */\n+    public void addARecords() {\n+    \ttry {\n+\t\t\tfor (String domain : new String[] { TEST_DOMAIN_1, TEST_DOMAIN_2, TEST_DOMAIN_3, TEST_DOMAIN_4 }) {\n+\t\t\t\t/*\n+\t\t\t\t * Disable the IPv6 responses for this domain. The Boulder CA server\n+\t\t\t\t * responds on AAAA (IPv6) responses before A (IPv4) responses, and\n+\t\t\t\t * we don't currently have the testcontainer host's IPv6 address.\n+\t\t\t\t */\n+\t\t\t\taddARecord(domain, getClientHost());\n+\t\t\t\taddAAAARecord(domain, \"\");\n+\t\t\t}\n+    \t} catch (Exception e) {\n+    \t\tLog.error(CAContainer.class, \"addARecords\", e);\n+    \t}\n+    }\n+    /**\n+     * Convenience method for adding A records.\n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+     */\n+\tpublic void addARecord(String domain) throws IOException {\n+\t\taddARecord(domain, getClientHost());\n+\t}\n+\t/**\n+\t * Add an A record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv4 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Add an AAAA record to the mock DNS server. This will allow us to redirect\n+\t * requests to a named domain to the IPv6 address of our choice.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @param address\n+\t *            The address to direct the requests for that host to.\n+\t * @throws IOException\n+\t */\n+\tpublic void addAAAARecord(String host, String address) throws IOException {\n+\t\tfinal String METHOD_NAME = \"addAAAARecord\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\n+\t\t\t/*\n+\t\t\t * Generate the JSON request. The request can support multiple\n+\t\t\t * addresses but for the time being we will only support sending\n+\t\t\t * one.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\",\\\"addresses\\\":[\\\"\" + address + \"\\\"]}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/add-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * Clear a previously added AAAA record that was added to the mock DNS\n+\t * server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearAAAARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearAAAARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-aaaa\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Clear a previously added A record that was added to the mock DNS server.\n+\t * \n+\t * @param host\n+\t *            The host / domain to redirect requests for.\n+\t * @throws IOException\n+\t */\n+\tpublic void clearARecord(String host) throws IOException {\n+\t\tfinal String METHOD_NAME = \"clearMockARecord(String)\";\n+\n+\t\ttry (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n+\t\t\t/*\n+\t\t\t * Generate the JSON request.\n+\t\t\t */\n+\t\t\tString jsonString = \"{\\\"host\\\":\\\"\" + host + \"\\\"}\";\n+\t\t\tStringEntity requestEntity = new StringEntity(jsonString, ContentType.APPLICATION_JSON);\n+\n+\t\t\t/*\n+\t\t\t * Create a POST request to the mock DNS server.\n+\t\t\t */\n+\t\t\tHttpPost httpPost = new HttpPost(getManagementAddress() + \"/clear-a\");\n+\t\t\thttpPost.setEntity(requestEntity);\n+\n+\t\t\t/*\n+\t\t\t * Send the POST request and process the response.\n+\t\t\t */\n+\t\t\ttry (final CloseableHttpResponse response = httpclient.execute(httpPost)) {\n+\t\t\t\tAcmeFatUtils.logHttpResponse(CAContainer.class, METHOD_NAME, httpPost, response);\n+\n+\t\t\t\tStatusLine statusLine = response.getStatusLine();\n+\t\t\t\tif (statusLine.getStatusCode() != 200) {\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tMETHOD_NAME + \": Expected response 200, but received response: \" + statusLine);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t/**\n+\t * The HTTP address that can be used the reach the REST management API for\n+\t * the server.\n+\t * \n+\t * @return The HTTP address to the REST management endpoint.\n+\t */\n+\tpublic String getManagementAddress() {", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MjIzMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404282231", "bodyText": "If we don't need this, delete it.", "author": "jvanhill", "createdAt": "2020-04-06T17:57:04Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/docker/pebble/PebbleDriver.java", "diffHunk": "@@ -109,36 +108,19 @@ private static void start() {\n \t\t * challenge.\n \t\t */\n \t\tSystem.out.println(\"Running Testcontainers.exposeHostPorts\");\n-\t\tTestcontainers.exposeHostPorts(PebbleContainer.HTTP_PORT);\n-\n-\t\t/*\n-\t\t * Startup the challtestsrv container first. This container will serve\n-\t\t * as a mock DNS server to the Pebble server that starts on the other\n-\t\t * container.\n-\t\t */\n-\t\tSystem.out.println(\"Starting ChalltestsrvContainer\");\n-\t\tchalltestsrv = new ChalltestsrvContainer();\n-\t\tchalltestsrv.start();\n-\n+\t//\tTestcontainers.exposeHostPorts(PebbleContainer.HTTP_PORT);", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4NDQ0Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404284443", "bodyText": "Can't we get this from the CAContainer?", "author": "jvanhill", "createdAt": "2020-04-06T18:00:36Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeClientTest.java", "diffHunk": "@@ -56,20 +55,38 @@\n \tprivate static final String TEST_DOMAIN_3 = \"domain3.com\";\n \tprivate static final String TEST_DOMAIN_4 = \"domain4.com\";\n \n-\tprivate static final String FILE_MINICA_PEM = \"lib/LibertyFATTestFiles/pebble.minica.pem\";\n-\tprivate static final String TRUSTSTORE_FILE;\n-\tprivate static final String FILE_ACCOUNT_KEY;\n-\tprivate static final String FILE_DOMAIN_KEY;\n-\tprivate static final String TRUSTSTORE_PASSWORD = \"password\";\n-\tprivate static X509Certificate pebbleIntermediateCertificate = null;\n \tprivate static HttpChallengeServer challengeServer = null;\n-\tprivate static final String acmeDirectoryURI = FATSuite.pebble.getAcmeDirectoryURI(true);\n+\t/** Challenge server port. */\n+\tpublic static final int HTTP_PORT = 5002;", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4NDk1OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404284958", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\"Boulder Intermediate Cert: \" + String.valueOf(intermediateCertificate));\n          \n          \n            \n            \t\t\t\t\t\"Pebble Intermediate Cert: \" + String.valueOf(intermediateCertificate));", "author": "jvanhill", "createdAt": "2020-04-06T18:01:28Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeClientTest.java", "diffHunk": "@@ -112,10 +129,10 @@\n \t\t\t * verify that the generated certificate is actually signed by the\n \t\t\t * root and intermediate certificates.\n \t\t\t */\n-\t\t\tpebbleIntermediateCertificate = AcmeFatUtils\n-\t\t\t\t\t.getX509Certificate(new ByteArrayInputStream(FATSuite.pebble.getAcmeCaIntermediateCertificate()));\n+\t\t\tintermediateCertificate = AcmeFatUtils\n+\t\t\t\t\t.getX509Certificate(pebble.getAcmeCaIntermediateCertificate());\n \t\t\tLog.info(AcmeClientTest.class, \"<cinit>\",\n-\t\t\t\t\t\"Pebble Intermediate Cert: \" + String.valueOf(pebbleIntermediateCertificate));\n+\t\t\t\t\t\"Boulder Intermediate Cert: \" + String.valueOf(intermediateCertificate));", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4NzUwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404287504", "bodyText": "Do we need this empty method?", "author": "jvanhill", "createdAt": "2020-04-06T18:05:52Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeURISimpleTest.java", "diffHunk": "@@ -29,12 +31,15 @@\n @Mode(TestMode.FULL)\n public class AcmeURISimpleTest extends AcmeSimpleTest {\n \n+\t@AfterClass", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4NzY1NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404287655", "bodyText": "Whitespace between methods.", "author": "jvanhill", "createdAt": "2020-04-06T18:06:08Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/AcmeURISimpleTest.java", "diffHunk": "@@ -29,12 +31,15 @@\n @Mode(TestMode.FULL)\n public class AcmeURISimpleTest extends AcmeSimpleTest {\n \n+\t@AfterClass\n+\tpublic static void afterClass() throws Exception {\n+\t}", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODM0Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11374#discussion_r404288343", "bodyText": "Do we still need this since we start our containers in each case separately?", "author": "jvanhill", "createdAt": "2020-04-06T18:07:26Z", "path": "dev/com.ibm.ws.security.acme_fat/fat/src/com/ibm/ws/security/acme/fat/FATSuite.java", "diffHunk": "@@ -43,62 +30,5 @@\n \t\tExternalTestServiceDockerClientStrategy.clearTestcontainersConfig();", "originalCommit": "3c28406c01e42dd902f376fac4532e84cf17aa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2574971a7a737463507e402179be3fb4b9dd9dd7", "url": "https://github.com/OpenLiberty/open-liberty/commit/2574971a7a737463507e402179be3fb4b9dd9dd7", "message": "squash containers", "committedDate": "2020-04-09T20:04:52Z", "type": "forcePushed"}, {"oid": "f1d9477b02cd4ff93239aa6c7da98f9bdfe76dea", "url": "https://github.com/OpenLiberty/open-liberty/commit/f1d9477b02cd4ff93239aa6c7da98f9bdfe76dea", "message": "squash containers", "committedDate": "2020-04-10T01:01:11Z", "type": "forcePushed"}, {"oid": "6e02c8450df10fc85d84a982b8b54cca700a42d7", "url": "https://github.com/OpenLiberty/open-liberty/commit/6e02c8450df10fc85d84a982b8b54cca700a42d7", "message": "squash containers", "committedDate": "2020-04-10T01:04:25Z", "type": "forcePushed"}, {"oid": "6c5b7d97dbafcf28f90f05824c41b8b0059e4e2d", "url": "https://github.com/OpenLiberty/open-liberty/commit/6c5b7d97dbafcf28f90f05824c41b8b0059e4e2d", "message": "squash containers", "committedDate": "2020-04-10T01:07:54Z", "type": "forcePushed"}, {"oid": "09288467a0af347a4713b8dc9e8be092ef2a75c8", "url": "https://github.com/OpenLiberty/open-liberty/commit/09288467a0af347a4713b8dc9e8be092ef2a75c8", "message": "squash containers", "committedDate": "2020-04-10T18:13:33Z", "type": "forcePushed"}, {"oid": "e9d477636774d6d9aba23d8d1f6024dd97106e5a", "url": "https://github.com/OpenLiberty/open-liberty/commit/e9d477636774d6d9aba23d8d1f6024dd97106e5a", "message": "squash containers", "committedDate": "2020-04-16T15:55:11Z", "type": "forcePushed"}, {"oid": "191d931a169a15d5b4934f514fae4c55a0dd0b43", "url": "https://github.com/OpenLiberty/open-liberty/commit/191d931a169a15d5b4934f514fae4c55a0dd0b43", "message": "squash containers", "committedDate": "2020-04-17T07:05:21Z", "type": "forcePushed"}, {"oid": "ba1cf03fd0b78dc5cea1ef96a9fc3987cac74d64", "url": "https://github.com/OpenLiberty/open-liberty/commit/ba1cf03fd0b78dc5cea1ef96a9fc3987cac74d64", "message": "squash containers", "committedDate": "2020-04-17T15:08:58Z", "type": "forcePushed"}, {"oid": "91fe8d4aa6692d650f75e871c2323b9e27a29bde", "url": "https://github.com/OpenLiberty/open-liberty/commit/91fe8d4aa6692d650f75e871c2323b9e27a29bde", "message": "add boulder CA to acme FAT", "committedDate": "2020-04-17T19:45:52Z", "type": "commit"}, {"oid": "b9908b810effb6298eed9512be6a760bf121ea24", "url": "https://github.com/OpenLiberty/open-liberty/commit/b9908b810effb6298eed9512be6a760bf121ea24", "message": "squash containers", "committedDate": "2020-04-17T19:46:33Z", "type": "forcePushed"}, {"oid": "d0decb71a64062009099ae2dd56b143f55a90c32", "url": "https://github.com/OpenLiberty/open-liberty/commit/d0decb71a64062009099ae2dd56b143f55a90c32", "message": "squash containers", "committedDate": "2020-04-20T14:12:11Z", "type": "forcePushed"}, {"oid": "302cebd3fa7806cdf1dac4d209dbf0c67f20bc61", "url": "https://github.com/OpenLiberty/open-liberty/commit/302cebd3fa7806cdf1dac4d209dbf0c67f20bc61", "message": "squash containers", "committedDate": "2020-04-20T14:15:16Z", "type": "commit"}, {"oid": "302cebd3fa7806cdf1dac4d209dbf0c67f20bc61", "url": "https://github.com/OpenLiberty/open-liberty/commit/302cebd3fa7806cdf1dac4d209dbf0c67f20bc61", "message": "squash containers", "committedDate": "2020-04-20T14:15:16Z", "type": "forcePushed"}]}