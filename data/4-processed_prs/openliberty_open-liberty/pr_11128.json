{"pr_number": 11128, "pr_title": "Issue 10277: Initial FAT bucket for autonomical polling.", "pr_createdAt": "2020-02-28T18:38:56Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/11128", "timeline": [{"oid": "515ef5da337df0d005490ff5d8f0336afbe31b36", "url": "https://github.com/OpenLiberty/open-liberty/commit/515ef5da337df0d005490ff5d8f0336afbe31b36", "message": "Issue 10277: Initial FAT bucket for autonomical polling.", "committedDate": "2020-02-28T18:36:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5MzA1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11128#discussion_r385893051", "bodyText": "My own preference would be to choose a fixed value, for example 5, and not use a random in tests.", "author": "njr-11", "createdAt": "2020-02-28T19:54:09Z", "path": "dev/com.ibm.ws.concurrent.persistent_fat_auto_pollinterval/fat/src/com/ibm/ws/concurrent/persistent/fat/autonomicalpolling1serv/AutonomicalPolling1ServerTest.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.concurrent.persistent.fat.autonomicalpolling1serv;\n+\n+import static org.junit.Assert.fail;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.config.ConfigElementList;\n+import com.ibm.websphere.simplicity.config.PersistentExecutor;\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.FATServletClient;\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.custom.junit.runner.Mode;\n+import componenttest.custom.junit.runner.Mode.TestMode;\n+\n+/**\n+ * This test bucket attempts to simulate fail-over of tasks.\n+ * For this oversimplified scenario, we don't actually have multiple servers, just multiple\n+ * persistent executor instances on a single server.\n+ * We can simulate an instance going down by removing it from the configuration.\n+ */\n+@RunWith(FATRunner.class)\n+public class AutonomicalPolling1ServerTest extends FATServletClient {\n+\tprivate static final String APP_NAME = \"autonomicalpolling1servApp\";\n+\tprivate static final Set<String> APP_NAMES = Collections.singleton(APP_NAME);\n+\n+\tprivate static ServerConfiguration originalConfig;\n+\n+\t@Server(\"com.ibm.ws.concurrent.persistent.fat.autonomicalpolling1serv\")\n+\tpublic static LibertyServer server;\n+\n+\tprivate static final String TASK_ID_MESSAGE = \"Task id is \";\n+\n+\t@BeforeClass\n+\tpublic static void setUp() throws Exception {\n+\t\toriginalConfig = server.getServerConfiguration().clone();\n+\t\tShrinkHelper.defaultDropinApp(server, APP_NAME, \"autonomicalpolling1serv.web\");\n+\n+\t\tserver.deleteDirectoryFromLibertyInstallRoot(\"usr/shared/resources/data/autonomicalpolling1db\");\n+\n+\t\tserver.startServer();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void tearDown() throws Exception {\n+\t\ttry {\n+\t\t\tserver.stopServer(\"J2CA0027E\", \"DSRA0304E\", \"DSRA0302E\");\n+\t\t} finally {\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * testAdd10Remove1PersistentExecs - Add 10 persistent executors, then remove 1, and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10Remove1PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable 1 of the 10 persistent executors.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\texecutors.get(9).setEnableTaskExecution(\"false\");\n+\t\t\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(10000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=9\");\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * testAdd10Remove9PersistentExecs - Add 10 persistent executors, then remove 9, and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10Remove9PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable all but 1 persistent executor.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\tfor (int i = 1; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"false\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(10000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=1\");\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * testAdd10RemoveAllImmediatelyAdd10PersistentExecs - Add 10 persistent executors, remove them all,\n+\t * immediately add 10 persistent executors back, and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10RemoveAllImmediatelyAdd10PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable all.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"false\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for 3 seconds so we have missed more than 1 poll interval.\n+\t\tThread.sleep(3000);\n+\t\t\n+\t\t// Enable all.\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"true\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=10\");\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * testAdd10RemoveAllWaitAdd10PersistentExecs - Add 10 persistent executors, remove them all, wait long enough to miss more than one poll interval,\n+\t * add 10 persistent executors back, and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10RemoveAllWaitAdd10PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable all.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"false\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for 3 seconds so we have missed more than 1 poll interval.\n+\t\tThread.sleep(3000);\n+\t\t\n+\t\t// Enable all.\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"true\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=10\");\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * testAdd10RemoveRandomPersistentExecs - Add 10 persistent executors, then remove a random (2-8) number of them,\n+\t * and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10RemoveRandomPersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable between 2 and 8 persistent executors.\n+\t\tint random = ThreadLocalRandom.current().nextInt(2, 9);", "originalCommit": "515ef5da337df0d005490ff5d8f0336afbe31b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NTEyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11128#discussion_r385895123", "bodyText": "I think you could accomplish the same with:\nfor (int i = 5; i < 7; i++)\n   persistentExecs[i].setEnableTaskExecution(\"false\");\n\nIt's also a bit odd that we started with slot 4, rather than 0, but I was still able to follow the logic.", "author": "njr-11", "createdAt": "2020-02-28T19:58:40Z", "path": "dev/com.ibm.ws.concurrent.persistent_fat_auto_pollinterval/fat/src/com/ibm/ws/concurrent/persistent/fat/autonomicalpolling1serv/AutonomicalPolling1ServerTest.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.concurrent.persistent.fat.autonomicalpolling1serv;\n+\n+import static org.junit.Assert.fail;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.ibm.websphere.simplicity.ShrinkHelper;\n+import com.ibm.websphere.simplicity.config.ConfigElementList;\n+import com.ibm.websphere.simplicity.config.PersistentExecutor;\n+import com.ibm.websphere.simplicity.config.ServerConfiguration;\n+\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.utils.FATServletClient;\n+import componenttest.annotation.AllowedFFDC;\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.custom.junit.runner.Mode;\n+import componenttest.custom.junit.runner.Mode.TestMode;\n+\n+/**\n+ * This test bucket attempts to simulate fail-over of tasks.\n+ * For this oversimplified scenario, we don't actually have multiple servers, just multiple\n+ * persistent executor instances on a single server.\n+ * We can simulate an instance going down by removing it from the configuration.\n+ */\n+@RunWith(FATRunner.class)\n+public class AutonomicalPolling1ServerTest extends FATServletClient {\n+\tprivate static final String APP_NAME = \"autonomicalpolling1servApp\";\n+\tprivate static final Set<String> APP_NAMES = Collections.singleton(APP_NAME);\n+\n+\tprivate static ServerConfiguration originalConfig;\n+\n+\t@Server(\"com.ibm.ws.concurrent.persistent.fat.autonomicalpolling1serv\")\n+\tpublic static LibertyServer server;\n+\n+\tprivate static final String TASK_ID_MESSAGE = \"Task id is \";\n+\n+\t@BeforeClass\n+\tpublic static void setUp() throws Exception {\n+\t\toriginalConfig = server.getServerConfiguration().clone();\n+\t\tShrinkHelper.defaultDropinApp(server, APP_NAME, \"autonomicalpolling1serv.web\");\n+\n+\t\tserver.deleteDirectoryFromLibertyInstallRoot(\"usr/shared/resources/data/autonomicalpolling1db\");\n+\n+\t\tserver.startServer();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void tearDown() throws Exception {\n+\t\ttry {\n+\t\t\tserver.stopServer(\"J2CA0027E\", \"DSRA0304E\", \"DSRA0302E\");\n+\t\t} finally {\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * testAdd10Remove1PersistentExecs - Add 10 persistent executors, then remove 1, and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10Remove1PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable 1 of the 10 persistent executors.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\texecutors.get(9).setEnableTaskExecution(\"false\");\n+\t\t\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(10000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=9\");\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * testAdd10Remove9PersistentExecs - Add 10 persistent executors, then remove 9, and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10Remove9PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable all but 1 persistent executor.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\tfor (int i = 1; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"false\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(10000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=1\");\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * testAdd10RemoveAllImmediatelyAdd10PersistentExecs - Add 10 persistent executors, remove them all,\n+\t * immediately add 10 persistent executors back, and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10RemoveAllImmediatelyAdd10PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable all.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"false\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for 3 seconds so we have missed more than 1 poll interval.\n+\t\tThread.sleep(3000);\n+\t\t\n+\t\t// Enable all.\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"true\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=10\");\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * testAdd10RemoveAllWaitAdd10PersistentExecs - Add 10 persistent executors, remove them all, wait long enough to miss more than one poll interval,\n+\t * add 10 persistent executors back, and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10RemoveAllWaitAdd10PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable all.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"false\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for 3 seconds so we have missed more than 1 poll interval.\n+\t\tThread.sleep(3000);\n+\t\t\n+\t\t// Enable all.\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"true\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=10\");\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * testAdd10RemoveRandomPersistentExecs - Add 10 persistent executors, then remove a random (2-8) number of them,\n+\t * and verify the polling interval is set correctly.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\t@Mode(TestMode.FULL)\n+\tpublic void testAdd10RemoveRandomPersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[10];\n+\n+\t\t// Create 10 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 0; i < persistentExecs.length; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle.\n+\t\tThread.sleep(6000);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec1&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable between 2 and 8 persistent executors.\n+\t\tint random = ThreadLocalRandom.current().nextInt(2, 9);\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\tfor (int i = random; i < executors.size(); i++) {\n+\t\t\texecutors.get(i).setEnableTaskExecution(\"false\");\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Wait for polling to settle. 10 seconds isn't always enough for this scenario, so we may need to increase in the future.\n+\t\t// Currently our retries cover the cases when we haven't waited long enough.\n+\t\tThread.sleep(10000);\n+\t\t\n+\t\t// Verify the polling delay of the persistent executors.\n+\t\ttry {\n+\t\t\tresult = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\", \"testPersistentExecPolling&numPersistentExecs=\" + random);\n+\t\t\tassertTrue(\"testPersistentExecPolling failed with delay results of (values should be sequential starting with 0): \" + result.toString(), \n+\t\t\t\t\tresult.indexOf(\"PASSED\") > -1);\n+\t\t} finally {\n+\t\t\t// always cancel the task\n+\t\t\trunTest(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\t\"testCancelTask&taskId=\" + taskId + \"&jndiName=persistent/exec1&test=testPersistentExecPolling[1]\");\n+\n+\t\t\t// restore original configuration\n+\t\t\tserver.setMarkToEndOfLog();\n+\t\t\tserver.updateServerConfiguration(originalConfig);\n+\t\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * testAdd3Add4PersistentExecs - Add 3 persistent executors, remove 2, and then add 4 more. Verify the polling intervals for all the\n+\t * persistent executors are correct.\n+\t */\n+\t// When more than one Persistent Executor tries to request a unique Partition ID at the same time the following Derby error occurs:   \n+\t// \"ERROR 40XL1: A lock could not be obtained within the time requested\"\n+\t// This later results in a XA_RBTIMEOUT (106) error on the transaction (javax.transaction.xa.XAException).\n+\t// We recover/retry just fine, but this is a reason why Derby is not used for production.\n+\t@AllowedFFDC(\"javax.transaction.xa.XAException\")\n+\t@Test\n+\tpublic void testAdd3Remove2Add4PersistentExecs() throws Exception {\n+\t\tPersistentExecutor persistentExecs[] = new PersistentExecutor[7];\n+\n+\t\t// Add 3 persistent executors.\n+\t\tServerConfiguration config = originalConfig.clone();\n+\t\tfor (int i = 4; i < 7; i++) {\n+\t\t\tpersistentExecs[i] = new PersistentExecutor();\n+\t\t\tpersistentExecs[i].setId(\"persistentExec\" + i);\n+\t\t\tpersistentExecs[i].setJndiName(\"persistent/exec\" + i);\n+\t\t\tpersistentExecs[i].setPollInterval(\"1s\");\n+\t\t\tpersistentExecs[i].setMissedTaskThreshold(\"3s\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"ignore.minimum.for.test.use.only\", \"true\");\n+\t\t\tpersistentExecs[i].setExtraAttribute(\"pollingCoordination.for.test.use.only\", \"true\");\n+\t\t\tconfig.getPersistentExecutors().add(persistentExecs[i]);\n+\t\t}\n+\t\tserver.setMarkToEndOfLog();\n+\t\tserver.updateServerConfiguration(config);\n+\t\tserver.waitForConfigUpdateInLogUsingMark(APP_NAMES);\n+\t\t\n+\t\t// Schedule a repeating task to run.\n+\t\tStringBuilder result = runTestWithResponse(server, APP_NAME + \"/AutonomicalPolling1ServerTestServlet\",\n+\t\t\t\t\"testScheduleRepeatingTask&jndiName=persistent/exec4&initialDelayMS=0&delayMS=1900&test=testPersistentExecPolling[1]\");\n+\n+\t\tint start = result.indexOf(TASK_ID_MESSAGE);\n+\t\tif (start < 0)\n+\t\t\tfail(\"Task id of scheduled task not found in servlet output: \" + result);\n+\t\tString taskId = result.substring(start += TASK_ID_MESSAGE.length(), result.indexOf(\".\", start));\n+\n+\t\tSystem.out.println(\"Scheduled task \" + taskId);\n+\t\t\n+\t\t// Disable all but one.\n+\t\tConfigElementList<PersistentExecutor> executors = config.getPersistentExecutors();\n+\t\tfor (int i = 0; i < executors.size(); i++) {\n+\t\t\tif(!\"persistent/exec4\".equals(executors.get(i).getJndiName()))\n+\t\t\t\texecutors.get(i).setEnableTaskExecution(\"false\");", "originalCommit": "515ef5da337df0d005490ff5d8f0336afbe31b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NzAzMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11128#discussion_r385897032", "bodyText": "Comment is missing if you were going to add one here", "author": "njr-11", "createdAt": "2020-02-28T20:03:09Z", "path": "dev/com.ibm.ws.concurrent.persistent_fat_auto_pollinterval/test-applications/autonomicalpolling1servApp/src/autonomicalpolling1serv/web/AutonomicalPolling1ServerTestServlet.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package autonomicalpolling1serv.web;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.naming.InitialContext;\n+import javax.servlet.annotation.WebServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.ibm.websphere.concurrent.persistent.PersistentExecutor;\n+import com.ibm.websphere.concurrent.persistent.TaskStatus;\n+\n+import componenttest.app.FATServlet;\n+\n+@SuppressWarnings(\"serial\")\n+@WebServlet(urlPatterns = \"/AutonomicalPolling1ServerTestServlet\")\n+public class AutonomicalPolling1ServerTestServlet extends FATServlet {\n+\n+    /**\n+     * Maximum number of nanoseconds to wait for a task to finish.\n+     */\n+    private static final long TIMEOUT_NS = TimeUnit.MINUTES.toNanos(2);\n+\n+    /**\n+     * Cancel a task so that no subsequent executions occur.\n+     */\n+    public void testCancelTask(HttpServletRequest request, HttpServletResponse response) throws Exception {\n+        String jndiName = request.getParameter(\"jndiName\");\n+        long taskId = Long.parseLong(request.getParameter(\"taskId\"));\n+\n+        PersistentExecutor executor = (PersistentExecutor) new InitialContext().lookup(jndiName);\n+\n+        TaskStatus<?> status = executor.getStatus(taskId);\n+        if (status != null)\n+            status.cancel(false);\n+    }\n+\n+    /**\n+     * testPersistentExecPolling - ", "originalCommit": "515ef5da337df0d005490ff5d8f0336afbe31b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODQxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11128#discussion_r385898412", "bodyText": "Minor: this file mixes tabs and spaces and so lines don't line up.", "author": "njr-11", "createdAt": "2020-02-28T20:06:10Z", "path": "dev/com.ibm.ws.concurrent.persistent_fat_auto_pollinterval/test-applications/autonomicalpolling1servApp/src/autonomicalpolling1serv/web/AutonomicalPolling1ServerTestServlet.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package autonomicalpolling1serv.web;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.naming.InitialContext;\n+import javax.servlet.annotation.WebServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.ibm.websphere.concurrent.persistent.PersistentExecutor;\n+import com.ibm.websphere.concurrent.persistent.TaskStatus;\n+\n+import componenttest.app.FATServlet;\n+\n+@SuppressWarnings(\"serial\")\n+@WebServlet(urlPatterns = \"/AutonomicalPolling1ServerTestServlet\")\n+public class AutonomicalPolling1ServerTestServlet extends FATServlet {\n+\n+    /**\n+     * Maximum number of nanoseconds to wait for a task to finish.\n+     */\n+    private static final long TIMEOUT_NS = TimeUnit.MINUTES.toNanos(2);\n+\n+    /**\n+     * Cancel a task so that no subsequent executions occur.\n+     */\n+    public void testCancelTask(HttpServletRequest request, HttpServletResponse response) throws Exception {\n+        String jndiName = request.getParameter(\"jndiName\");\n+        long taskId = Long.parseLong(request.getParameter(\"taskId\"));\n+\n+        PersistentExecutor executor = (PersistentExecutor) new InitialContext().lookup(jndiName);\n+\n+        TaskStatus<?> status = executor.getStatus(taskId);\n+        if (status != null)\n+            status.cancel(false);\n+    }\n+\n+    /**\n+     * testPersistentExecPolling - \n+     */\n+    public void testPersistentExecPolling(HttpServletRequest request, HttpServletResponse response) throws Exception {\n+    \tint numPersistentExecs = Integer.parseInt(request.getParameter(\"numPersistentExecs\"));\n+    \tfinal long[] expectedDelays = new long[numPersistentExecs];\n+\t\tlong delays[] = new long[numPersistentExecs];\n+\t\tint attempts = 0;\n+\n+\t\t// initialize expectedDelays to {0,1,2...}\n+\t\tfor (int i = 0; i < expectedDelays.length; i++) {\n+\t\t\texpectedDelays[i] = i;\n+\t\t}\n+\n+\t\twhile (attempts < 20) {\n+\t\t\tattempts++;\n+\t\t\tcollectDelays(delays);\n+\n+\t\t\tArrays.sort(delays);\n+\t\t\tSystem.out.println(\"persistent executor delays: \" + Arrays.toString(delays));\n+\n+\t\t\tif(Arrays.equals(expectedDelays, delays)) {\n+\t\t\t\t// We got passing results.\n+\t\t\t\tresponse.getWriter().println(\"PASSED\");\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t// Wait a least one poll interval to try again.\n+\t\t\tThread.sleep(1100);\n+\t\t}\n+\t\t\n+\t\t// We failed to get expected delay values. Returns the delay values we got for debug.\n+\t\tresponse.getWriter().println(Arrays.toString(delays));\n+    }\n+    \n+    private void collectDelays(long[] delays) throws Exception {\n+    \tInitialContext context = new InitialContext();\n+\t\tfor( int i = 0; i < delays.length; i++) {\n+\t\t\tPersistentExecutor persistentExec = (PersistentExecutor)context.lookup(\"persistent/exec\" + i);\n+\t\t\tField f = persistentExec.getClass().getDeclaredField(\"pollingFutureRef\");\n+\t\t\tf.setAccessible(true);\n+\t\t\tAtomicReference<ScheduledFuture<?>> pollingFutureRef = (AtomicReference<ScheduledFuture<?>>)f.get(persistentExec);\n+\t\t\tdelays[i] = pollingFutureRef.get().getDelay(TimeUnit.SECONDS);\n+\t\t\tSystem.out.println(\"persistentExec.pollingFutureRef.getDelay(): \" + pollingFutureRef.get().getDelay(TimeUnit.MILLISECONDS));\n+\t\t}\n+    }\n+    \n+    /**\n+     * testPollIntervalStable - verify the poll interval is happening at the correct rate and persistent executors are taking turns pulling.\n+     */\n+    public void testPollIntervalStable(HttpServletRequest request, HttpServletResponse response) throws Exception {\n+    \tIncTask.reset();\n+    \tlong start = System.nanoTime();\n+    \twhile (IncTask.counter < 13 && System.nanoTime() - start < TIMEOUT_NS) {\n+    \t\tThread.sleep(1000);\n+    \t}\n+    \t\n+    \tif (IncTask.counter < 13) {\n+    \t\tfail(\"Test timed out!   start = \" + start + \"; now = \" + System.nanoTime());\n+    \t}\n+    \t\n+    \tSystem.out.println(\"IncTask.ranWithExec = \" + Arrays.toString(IncTask.ranWithExec));\n+\t\t// Verify the same persistent executor isn't being used every time.", "originalCommit": "515ef5da337df0d005490ff5d8f0336afbe31b36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da85832d00994c49bb8ce2fd28c53f32f9058306", "url": "https://github.com/OpenLiberty/open-liberty/commit/da85832d00994c49bb8ce2fd28c53f32f9058306", "message": "Code review updates.", "committedDate": "2020-02-28T21:50:22Z", "type": "commit"}]}