{"pr_number": 10801, "pr_title": "Issue 10277: Autonomical algorithm for calculating pollInterval.", "pr_createdAt": "2020-02-07T19:48:46Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/10801", "timeline": [{"oid": "2773d3e4785bd97d6883622fd1e3f5f8259e1db6", "url": "https://github.com/OpenLiberty/open-liberty/commit/2773d3e4785bd97d6883622fd1e3f5f8259e1db6", "message": "Issue 10277: Autonomical algorithm for calculating pollInterval.\n\nWe store two values in the partition table.\n(1) last time we pulled\n(2) time when the last poll slot reserved will trigger\n\nWe will assign the current poll to use value (2) plus a global poll value to determine when it will poll for tasks next.\nValue (1) is used to detect if any poll intervals have been missed.", "committedDate": "2020-02-07T19:40:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwOTEwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10801#discussion_r376609103", "bodyText": "Just to be sure you are aware, with this change it is still possible that this could be a time in the past.\nFor example, 25800 / 1000 * 1000 + 600 evaluates to 25600.", "author": "njr-11", "createdAt": "2020-02-07T21:10:46Z", "path": "dev/com.ibm.ws.concurrent.persistent/src/com/ibm/ws/concurrent/persistent/db/DatabaseTaskStore.java", "diffHunk": "@@ -593,7 +593,7 @@ public long findOrCreatePollPartition() throws Exception {\n                 // Initialize to already-expired and eligible for any server to claim.\n                 // Use a fractional second to help avoid accessing the database around the same time as scheduled tasks\n                 // which might be scheduled to run on the hour or minute.\n-                partition.EXPIRY = (System.currentTimeMillis() / 1000 - 1) * 1000 + 600;\n+                partition.EXPIRY = System.currentTimeMillis() / 1000 * 1000 + 600;", "originalCommit": "2773d3e4785bd97d6883622fd1e3f5f8259e1db6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMTUzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10801#discussion_r376611535", "bodyText": "If the current poll itself is slightly late, this could accidentally push us past the threshold and trigger the logic after just one missed poll.  We could guard against this by adding half a poll interval:\nif (now - lastUpdated > missedPollsThreshold * config.pollInterval + config.pollInterval / 2) {", "author": "njr-11", "createdAt": "2020-02-07T21:16:56Z", "path": "dev/com.ibm.ws.concurrent.persistent/src/com/ibm/ws/concurrent/persistent/internal/PersistentExecutorImpl.java", "diffHunk": "@@ -2293,12 +2295,29 @@ private long coordinateNextPoll(Config config) {\n \n                 tranMgr.begin();\n                 try {\n-                    // TODO implement this method. For now, we invoke some basic db operations to demonstrate that what we have so far is working\n                     Object[] expiryAndLastUpdated = taskStore.findPollInfoForUpdate(pollPartitionId);\n                     long expiry = (Long) expiryAndLastUpdated[0];\n                     long lastUpdated = (Long) expiryAndLastUpdated[1];\n-                    taskStore.updatePollInfo(pollPartitionId, System.currentTimeMillis() + config.pollInterval);\n-                    delay = config.pollInterval;\n+                    long now = System.currentTimeMillis();\n+                    int slot = 0;\n+                    final int missedPollsThreshold = 2; // Could be make configurable in the future.\n+\n+                    if (now - lastUpdated > missedPollsThreshold * config.pollInterval) {", "originalCommit": "2773d3e4785bd97d6883622fd1e3f5f8259e1db6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}