{"pr_number": 14445, "pr_title": "JWE builder fat 1", "pr_createdAt": "2020-10-12T18:30:40Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/14445", "timeline": [{"oid": "f66df8b6be2d2567d37234b68f11e1b83fce58cf", "url": "https://github.com/OpenLiberty/open-liberty/commit/f66df8b6be2d2567d37234b68f11e1b83fce58cf", "message": "Issue 13576: Initial drop for JWE generation\n\nFor issue #13576\n\nFirst drop of support JWE creation. Building via server configuration should be working. Incomplete server config coupled with using the `encryptWith()` API method still has some holes.", "committedDate": "2020-10-09T18:54:53Z", "type": "commit"}, {"oid": "a9fffa76739f25b71f8195ae4e058c170bd74b2c", "url": "https://github.com/OpenLiberty/open-liberty/commit/a9fffa76739f25b71f8195ae4e058c170bd74b2c", "message": "First delivery of JWE Builder FAT", "committedDate": "2020-10-12T19:20:00Z", "type": "forcePushed"}, {"oid": "08db637490f86137a0df4ffc6fd7a370c3362a8c", "url": "https://github.com/OpenLiberty/open-liberty/commit/08db637490f86137a0df4ffc6fd7a370c3362a8c", "message": "First delivery of JWE Builder FAT", "committedDate": "2020-10-13T00:07:08Z", "type": "forcePushed"}, {"oid": "1713d60b083d2237d293d34d41cfb2398eb715ef", "url": "https://github.com/OpenLiberty/open-liberty/commit/1713d60b083d2237d293d34d41cfb2398eb715ef", "message": "First delivery of JWE Builder FAT", "committedDate": "2020-10-13T00:35:37Z", "type": "forcePushed"}, {"oid": "3381b5a665c3c812b09efaf3d262994a1b074dd6", "url": "https://github.com/OpenLiberty/open-liberty/commit/3381b5a665c3c812b09efaf3d262994a1b074dd6", "message": "First delivery of JWE Builder FAT", "committedDate": "2020-10-13T03:42:18Z", "type": "commit"}, {"oid": "3381b5a665c3c812b09efaf3d262994a1b074dd6", "url": "https://github.com/OpenLiberty/open-liberty/commit/3381b5a665c3c812b09efaf3d262994a1b074dd6", "message": "First delivery of JWE Builder FAT", "committedDate": "2020-10-13T03:42:18Z", "type": "forcePushed"}, {"oid": "d58f44490b9278b51f9ccac441a72c9a09645637", "url": "https://github.com/OpenLiberty/open-liberty/commit/d58f44490b9278b51f9ccac441a72c9a09645637", "message": "Update consumer servers for updated tooling", "committedDate": "2020-10-14T15:00:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4MzIzNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505583237", "bodyText": "My experience with the consumer side has suggested that specifying these constraints might not be needed; Jose4j might be detecting and pulling this info from the JWE automatically. Perfectly fine if it's working, but might not be necessary.", "author": "ayoho", "createdAt": "2020-10-15T14:21:36Z", "path": "dev/com.ibm.ws.security.fat.common.jwt/src/com/ibm/ws/security/fat/common/jwt/JwtTokenForTest.java", "diffHunk": "@@ -104,8 +172,46 @@ public JwtTokenForTest(String jwtTokenString) throws Exception {\n \n     }\n \n+    public void processJWE(String jwtTokenString, String expectedKeyMgmtAlg, String privateKey, String expectedContentEncryptAlg) throws Exception {\n+\n+        Log.info(thisClass, \"processJWE\", \"Original JWE Token String: \" + jwtTokenString);\n+\n+        // process the JWE Header\n+        String[] jwtParts = splitTokenString(jwtTokenString);\n+\n+        if (jwtParts.length != 5) {\n+            Log.info(thisClass, \"validateEncryptedToken\", \"Token does not have 5 parts\");\n+        }\n+\n+        jweHeaderString = jwtParts[0];\n+        jweHeaderJson = deserialize(jweHeaderString);\n+        jweHeaderMap = mapClaimsFromJsonAsStrings(jweHeaderString);\n+\n+        // now decrypt the JWE and process the JWS\n+        JsonWebEncryption jwe = new JsonWebEncryption();\n+        AlgorithmConstraints algorithmConstraints = new AlgorithmConstraints(ConstraintType.WHITELIST, expectedKeyMgmtAlg);\n+        jwe.setAlgorithmConstraints(algorithmConstraints);\n+        AlgorithmConstraints encryptionConstraints = new AlgorithmConstraints(ConstraintType.WHITELIST, expectedContentEncryptAlg);\n+        jwe.setContentEncryptionAlgorithmConstraints(encryptionConstraints);", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNDE5Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505734197", "bodyText": "I want to fail if the content of the JWE is not what the test expects (which is what we're passing in).  I want to decrypt this thing as the test expects in otherwords...", "author": "c00crane", "createdAt": "2020-10-15T17:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4MzIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4NjI1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505586250", "bodyText": "The * line below this should mean we don't have to add this line.", "author": "ayoho", "createdAt": "2020-10-15T14:25:23Z", "path": "dev/com.ibm.ws.security.fat.common/bnd.bnd", "diffHunk": "@@ -21,6 +21,7 @@ Export-Package: \\\n Import-Package: \\\n     !*.internal.*, \\\n     !com.ibm.ws.kernel.boot.cmdline, \\\n+    org.jose4j.*, \\", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczMzAxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505733012", "bodyText": "added trying to get something to run - will remove on the next delivery.", "author": "c00crane", "createdAt": "2020-10-15T17:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4NjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MDE1Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505590156", "bodyText": "Not a problem, but curious why you use SimplePEMEncoder here and then Base64 to do the decoding in getPublicKeyFromPem()?", "author": "ayoho", "createdAt": "2020-10-15T14:30:00Z", "path": "dev/com.ibm.ws.security.fat.common/src/com/ibm/ws/security/fat/common/utils/KeyTools.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.ibm.ws.security.fat.common.utils;\n+\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import org.jose4j.base64url.Base64;\n+import org.jose4j.base64url.SimplePEMEncoder;\n+import org.jose4j.lang.JoseException;\n+\n+import com.ibm.websphere.simplicity.log.Log;\n+\n+import componenttest.topology.impl.LibertyServer;\n+\n+public class KeyTools {\n+\n+    protected static Class<?> thisClass = KeyTools.class;\n+\n+    public final static String rsaPublicPrefix = \"-----BEGIN PUBLIC KEY-----\";\n+    public final static String rsaPublicSuffix = \"-----END PUBLIC KEY-----\";\n+    public final static String rsaPrivatePrefix = \"-----BEGIN PRIVATE KEY-----\";\n+    public final static String rsaPrivateSuffix = \"-----END PRIVATE KEY-----\";\n+\n+    public static String getComplexKey(LibertyServer server, String fileName) throws Exception {\n+        Log.info(thisClass, \"getComplexKey\", \"fileName: \" + fileName);\n+        return getKeyFromFile(server, fileName);\n+    }\n+\n+    public String getSimpleKey(LibertyServer server, String fileName) throws Exception {\n+        String rawKey = getKeyFromFile(server, fileName);\n+        if (rawKey != null) {\n+            rawKey.replace(rsaPublicPrefix, \"\").replace(rsaPublicSuffix, \"\");\n+            rawKey.replace(rsaPrivatePrefix, \"\").replace(rsaPrivateSuffix, \"\");\n+        }\n+        return rawKey;\n+    }\n+\n+    public static String getKeyFromFile(LibertyServer server, String fileName) throws Exception {\n+\n+        String fullPathToFile = getDefaultKeyFileLoc(server) + fileName;\n+\n+        CommonIOUtils cioTools = new CommonIOUtils();\n+        String key = cioTools.readFileAsString(fullPathToFile);\n+\n+        return key;\n+    }\n+\n+    public static String getDefaultKeyFileLoc(LibertyServer server) throws Exception {\n+\n+        return server.getServerRoot() + \"/\";\n+    }\n+\n+    public static PrivateKey getPrivateKeyFromPem(String privateKeyString) throws JoseException, InvalidKeySpecException, NoSuchAlgorithmException {\n+\n+        int beginIndex = privateKeyString.indexOf(rsaPrivatePrefix) + rsaPrivatePrefix.length();\n+        int endIndex = privateKeyString.indexOf(rsaPrivateSuffix);\n+\n+        String base64 = privateKeyString.substring(beginIndex, endIndex).trim();\n+        //        Log.info(thisClass, \"getPrivateKeyFromPem\", \"base64: \" + base64 + \" end\");\n+        byte[] decode = SimplePEMEncoder.decode(base64);", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNDMzMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505734331", "bodyText": "Just code done at 2 very different times in different places (and then moved to 1 file).  I'll look at that for the next delivery", "author": "c00crane", "createdAt": "2020-10-15T17:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzcwMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505637700", "bodyText": "Did you mean to take this out?", "author": "ayoho", "createdAt": "2020-10-15T15:30:03Z", "path": "dev/com.ibm.ws.security.jwtsso_fat/publish/shared/config/jwtSsoFeatures_mpJwt11.xml", "diffHunk": "@@ -14,7 +14,6 @@\n         <feature>jsp-2.3</feature>\n         <feature>jwtSso-1.0</feature>\n         <feature>componenttest-1.0</feature>\n-        <feature>mpJwt-1.1</feature>", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczMTYwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505731608", "bodyText": "That is a bad automerge done by git...", "author": "c00crane", "createdAt": "2020-10-15T17:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzODkwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505638907", "bodyText": "So these aren't ready to be replaced yet?", "author": "ayoho", "createdAt": "2020-10-15T15:31:34Z", "path": "dev/com.ibm.ws.security.mp.jwt.1.1_fat/fat/src/com/ibm/ws/security/mp/jwt11/fat/utils/MPConfigSettings.java", "diffHunk": "@@ -95,6 +95,7 @@ public String getCertType() {\n         return certType;\n     }\n \n+    // TODO - these have been duplicated in the JWT tooling project - when encryption is added to mpJwt - remove these and replace with instances in JwtKeyTools\n     public static String getComplexKeyForSigAlg(LibertyServer server, String sigAlg) throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMTg4OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505721889", "bodyText": "no - I'll mess with reworking the mp.jwt tools when I work on the mp.jwt tests.  I want to redo a few things and that'll take more time than I want to spend right now when I'm trying to get the builder finished.", "author": "c00crane", "createdAt": "2020-10-15T17:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzODkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MDIzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505680238", "bodyText": "What error handling is missing?", "author": "ayoho", "createdAt": "2020-10-15T16:30:32Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNjc4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505726784", "bodyText": "Coming with the next delivery - the code I had to work from (before last Friday) didn't have specific errors", "author": "c00crane", "createdAt": "2020-10-15T17:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MDIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MTExMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505681110", "bodyText": "What error handling is missing?", "author": "ayoho", "createdAt": "2020-10-15T16:31:37Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtKey\";\n+\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is missing\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_missingKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNjY4MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505726680", "bodyText": "Coming with the next delivery - the code I had to work from (before last Friday) didn't have specific errors", "author": "c00crane", "createdAt": "2020-10-15T17:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MTk2Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505681967", "bodyText": "Can this test not be enabled?", "author": "ayoho", "createdAt": "2020-10-15T16:32:46Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtKey\";\n+\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is missing\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_missingKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtKey\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is RSA_OAEP-256\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // chc - not allowing RSA-OAEP-256 at the moment @Test\n+    public void JwtBuilderAPIConfigTests_encryption_RSAOAEP256KeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNjQzNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505726437", "bodyText": "Coming with the next delivery - the code I had to work from (before last Friday) didn't have the defaults coded for ContentEncryptionAlg and KeyMgmtKeyAlg.\nRSA-OAEP-256 is not supported in the config and we'll get the default value now.", "author": "c00crane", "createdAt": "2020-10-15T17:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MTk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MjMzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505682338", "bodyText": "Can this test not be enabled?", "author": "ayoho", "createdAt": "2020-10-15T16:33:24Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtKey\";\n+\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is missing\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_missingKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtKey\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is RSA_OAEP-256\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // chc - not allowing RSA-OAEP-256 at the moment @Test\n+    public void JwtBuilderAPIConfigTests_encryption_RSAOAEP256KeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_rsaOaep256_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>e will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_invalidContentEncryptAlg() throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNTk1NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505725954", "bodyText": "it will be in the next delivery - the behavior with the code I had last week was not what is going to be delivered.", "author": "c00crane", "createdAt": "2020-10-15T17:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MjMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MzE1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505683150", "bodyText": "Can this test not be enabled?", "author": "ayoho", "createdAt": "2020-10-15T16:34:45Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtKey\";\n+\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is missing\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_missingKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtKey\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is RSA_OAEP-256\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // chc - not allowing RSA-OAEP-256 at the moment @Test\n+    public void JwtBuilderAPIConfigTests_encryption_RSAOAEP256KeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_rsaOaep256_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>e will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_invalidContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>TheContent Encryption Algorithm is missing\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_missingContentEncryptAlg() throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNTM3OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505725379", "bodyText": "Coming with the next delivery - the code I had to work from (before last Friday) didn't have the defaults coded for ContentEncryptionAlg and KeyMgmtKeyAlg.", "author": "c00crane", "createdAt": "2020-10-15T17:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4MzE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5MjkzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505692938", "bodyText": "What exactly is the failure here? I'm guessing that Jose4j is blowing up because a key management key alias pointing to an Elliptical Curve key was used?", "author": "ayoho", "createdAt": "2020-10-15T16:50:17Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtKey\";\n+\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is missing\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_missingKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtKey\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is RSA_OAEP-256\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // chc - not allowing RSA-OAEP-256 at the moment @Test\n+    public void JwtBuilderAPIConfigTests_encryption_RSAOAEP256KeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_rsaOaep256_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>e will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_invalidContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>TheContent Encryption Algorithm is missing\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_missingContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg_SigAlgES384() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256_sigAlgES384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        JwtTokenForTest jwtTokenForTest = validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+        // let's do a little more validation\n+        JsonObject jwsHeader = jwtTokenForTest.getJsonHeader();\n+        validationUtils.assertTrueAndLog(_testName, \"JWS header algorithm is not set to ES384\", JWTBuilderConstants.SIGALG_ES384.equals(jwsHeader.getString(HeaderConstants.ALGORITHM)));\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @ExpectedFFDC({ \"org.jose4j.lang.InvalidKeyException\", \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodES256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_ES256\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNDQxOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505724418", "bodyText": "Still working on this test class - not sure offhand what the exact error is, but, the test case will check for something more than the generic error - the code last week wasn't giving specific errors", "author": "c00crane", "createdAt": "2020-10-15T17:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5MjkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NDAwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505694001", "bodyText": "Anything more specific we can check for here?", "author": "ayoho", "createdAt": "2020-10-15T16:52:05Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtKey\";\n+\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is missing\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_missingKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtKey\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is RSA_OAEP-256\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // chc - not allowing RSA-OAEP-256 at the moment @Test\n+    public void JwtBuilderAPIConfigTests_encryption_RSAOAEP256KeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_rsaOaep256_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>e will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_invalidContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>TheContent Encryption Algorithm is missing\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_missingContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg_SigAlgES384() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256_sigAlgES384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        JwtTokenForTest jwtTokenForTest = validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+        // let's do a little more validation\n+        JsonObject jwsHeader = jwtTokenForTest.getJsonHeader();\n+        validationUtils.assertTrueAndLog(_testName, \"JWS header algorithm is not set to ES384\", JWTBuilderConstants.SIGALG_ES384.equals(jwsHeader.getString(HeaderConstants.ALGORITHM)));\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @ExpectedFFDC({ \"org.jose4j.lang.InvalidKeyException\", \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodES256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_ES256\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));\n+        //chc        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.NewMSG, \"Message log did not contain an error indicating a problem with ...\"));\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWS instead of a JWE (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_missingKeyManagementKeyAlias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtAlias\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWSToken(response);\n+\n+    }\n+\n+    @ExpectedFFDC({ \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_badKeyManagementKeyAlias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtAlias\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMjQyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505722425", "bodyText": "Coming with the next delivery - the code I had to work from (before last Friday) didn't have specific errors", "author": "c00crane", "createdAt": "2020-10-15T17:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NDAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NDM5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505694394", "bodyText": "Anything more specific we can check for here?", "author": "ayoho", "createdAt": "2020-10-15T16:52:41Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtKey\";\n+\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is missing\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_missingKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtKey\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is RSA_OAEP-256\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // chc - not allowing RSA-OAEP-256 at the moment @Test\n+    public void JwtBuilderAPIConfigTests_encryption_RSAOAEP256KeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_rsaOaep256_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>e will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_invalidContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>TheContent Encryption Algorithm is missing\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_missingContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg_SigAlgES384() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256_sigAlgES384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        JwtTokenForTest jwtTokenForTest = validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+        // let's do a little more validation\n+        JsonObject jwsHeader = jwtTokenForTest.getJsonHeader();\n+        validationUtils.assertTrueAndLog(_testName, \"JWS header algorithm is not set to ES384\", JWTBuilderConstants.SIGALG_ES384.equals(jwsHeader.getString(HeaderConstants.ALGORITHM)));\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @ExpectedFFDC({ \"org.jose4j.lang.InvalidKeyException\", \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodES256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_ES256\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));\n+        //chc        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.NewMSG, \"Message log did not contain an error indicating a problem with ...\"));\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWS instead of a JWE (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_missingKeyManagementKeyAlias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtAlias\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWSToken(response);\n+\n+    }\n+\n+    @ExpectedFFDC({ \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_badKeyManagementKeyAlias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtAlias\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));\n+        //chc        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.NewMSG, \"Message log did not contain an error indicating a problem with ...\"));\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @ExpectedFFDC({ \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodKeyManagementKeyAlias_goodContentEncryptAlg_trustStoreRefMissing() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_trustStoreRef\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMTE0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505721148", "bodyText": "Coming with the next delivery - the code I had to work from (before last Friday) didn't have specific errors", "author": "c00crane", "createdAt": "2020-10-15T17:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NDM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NDY3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505694674", "bodyText": "Anything more specific we can check for here?", "author": "ayoho", "createdAt": "2020-10-15T16:53:11Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderAPIConfigTests.java", "diffHunk": "@@ -1963,4 +1967,403 @@ public void JwtBuilderAPIConfigTests_jwkEnabled_jwkSigningKeySize_4096() throws\n         validationUtils.validateResult(response, expectations);\n \n     }\n+\n+    /* Encryption */\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs384 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS384Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS384), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs512 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS512Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS512\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS512), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>An invalid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_invalidKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtKey\";\n+\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is missing\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_missingKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtKey\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>The Key Management Key Algorithm is RSA_OAEP-256\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the key management key algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // chc - not allowing RSA-OAEP-256 at the moment @Test\n+    public void JwtBuilderAPIConfigTests_encryption_RSAOAEP256KeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_rsaOaep256_RS256\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>e will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    //chc - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_invalidContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>TheContent Encryption Algorithm is missing\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>An error about the invalid value is logged during startup.\n+     * <LI>We will create a JWE instead of just a JWS using the default value of the content encryption algorithm (the content of\n+     * the token will be validated)\n+     * </OL>\n+     */\n+    // - need updated error handling @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_missingContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_contentEncryptAlg\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodRS256Alias_goodContentEncryptAlg_SigAlgES384() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_RS256_sigAlgES384\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        JwtTokenForTest jwtTokenForTest = validationUtils.validateJWEToken(response, (String) expectationSettings.get(HeaderConstants.ALGORITHM), JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256), (String) expectationSettings.get(HeaderConstants.ENCRYPTION));\n+\n+        // let's do a little more validation\n+        JsonObject jwsHeader = jwtTokenForTest.getJsonHeader();\n+        validationUtils.assertTrueAndLog(_testName, \"JWS header algorithm is not set to ES384\", JWTBuilderConstants.SIGALG_ES384.equals(jwsHeader.getString(HeaderConstants.ALGORITHM)));\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWE instead of just a JWS (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @ExpectedFFDC({ \"org.jose4j.lang.InvalidKeyException\", \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodES256Alias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_good_ES256\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));\n+        //chc        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.NewMSG, \"Message log did not contain an error indicating a problem with ...\"));\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Invoke the JWT Builder using a config that specifies encryption.\n+     * <LI>A valid Key Management Key Algorithm is specified\n+     * <LI>The the rs256 public key alias is specified for encryption\n+     * <LI>A valid Content Encryption Algorithm is specified\n+     * <LI>Finally the trustStoreRef is specified to point to the trust store containing the public key used to encrypt\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>We will create a JWS instead of a JWE (the content of the token will be validated)\n+     * </OL>\n+     */\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_missingKeyManagementKeyAlias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_keyMgmtAlias\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+        validationUtils.validateJWSToken(response);\n+\n+    }\n+\n+    @ExpectedFFDC({ \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_badKeyManagementKeyAlias_goodContentEncryptAlg() throws Exception {\n+\n+        String builderId = \"key_encrypt_bad_keyMgmtAlias\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));\n+        //chc        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.NewMSG, \"Message log did not contain an error indicating a problem with ...\"));\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @ExpectedFFDC({ \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodKeyManagementKeyAlias_goodContentEncryptAlg_trustStoreRefMissing() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_trustStoreRef\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));\n+        //chc        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.NewMSG, \"Message log did not contain an error indicating a problem with ...\"));\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodServerWideKeyManagementKeyAlias_goodContentEncryptAlg_trustStoreRefMissing() throws Exception {\n+\n+        String builderId = \"key_encrypt_missing_trustStoreRef_userServerWideAlias\";\n+        JSONObject expectationSettings = BuilderHelpers.setDefaultClaimsWithEncryption(builderId, JWTBuilderConstants.DEFAULT_KEY_MGMT_KEY_ALG, JWTBuilderConstants.DEFAULT_CONTENT_ENCRYPT_ALG);\n+\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId);\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @ExpectedFFDC({ \"com.ibm.ws.security.jwt.internal.JwtTokenException\" })\n+    @Test\n+    public void JwtBuilderAPIConfigTests_encryption_goodKeyMgmtKeyAlg_goodKeyManagementKeyAlias_goodContentEncryptAlg_trustStoreRefInvalid() throws Exception {\n+\n+        String builderId = \"key_encrypt_invalid_trustStoreRef\";\n+        Expectations expectations = BuilderHelpers.createBadBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, builderServer);\n+        expectations.addExpectation(new ServerMessageExpectation(builderServer, JwtBuilderMessageConstants.CWWKS6020E_CAN_NOT_CAST, \"Message log did not contain an error indicating a problem trying to encrypt the token.\"));", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMDk3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505720971", "bodyText": "Coming with the next delivery - the code I had to work from (before last Friday) didn't have specific errors", "author": "c00crane", "createdAt": "2020-10-15T17:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NDY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5ODI0Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505698247", "bodyText": "Are all of these not ready to be run yet?", "author": "ayoho", "createdAt": "2020-10-15T16:58:45Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderApiBasicTests.java", "diffHunk": "@@ -5336,4 +5341,757 @@ public void JwtBuilderAPIBasicTests_multiple_apis_and_consumeToken() throws Exce\n         validationUtils.validateResult(appResponse, appExpectations);\n \n     }\n+\n+    /***************************************************** Test encryptWith ****************************************************/\n+    /**\n+     * The encryption tests will behave the same as the non-encryption tests - the test app will run the set methods,\n+     * build, then the get methods - the output from the get methods is what the builder expectations will validate against.\n+     * When the token is encrypted, the same get methods should/better work... So, we'll be testing that they return\n+     * the correct results.\n+     * The app will also run compact on the builder to generated the JWT Token string - when it's encrypted, it'll create\n+     * a 5 part string (not encrypted, it'll be 3 parts)\n+     * The encryption tests will decrypt and parse the token to do extra validation on the token!\n+     *\n+     **/\n+    //    // encryptWith(String  keyManagementAlg,  Key keyManagementKey,  String  contentEncryptionAlg)\n+    //    //\"RSA-OAEP\",  rsaPublicKey, \"A256GCM\"\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM() throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxODMxMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505718313", "bodyText": "not with this delivery - these are what I'm working on now - need those extra 2 commits", "author": "c00crane", "createdAt": "2020-10-15T17:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5ODI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMjUzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505712538", "bodyText": "Shouldn't need this test since JwtBuilderAPIBasicTests_claimsFrom_jweString_to_jwtToken_allClaims should be doing the same thing. We may need to consider a TODO on the product code side to decide whether we want to detect a possible JWE being passed in and issue an error message, in addition to updating the Javadoc.", "author": "ayoho", "createdAt": "2020-10-15T17:21:53Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderApiBasicTests.java", "diffHunk": "@@ -5336,4 +5341,757 @@ public void JwtBuilderAPIBasicTests_multiple_apis_and_consumeToken() throws Exce\n         validationUtils.validateResult(appResponse, appExpectations);\n \n     }\n+\n+    /***************************************************** Test encryptWith ****************************************************/\n+    /**\n+     * The encryption tests will behave the same as the non-encryption tests - the test app will run the set methods,\n+     * build, then the get methods - the output from the get methods is what the builder expectations will validate against.\n+     * When the token is encrypted, the same get methods should/better work... So, we'll be testing that they return\n+     * the correct results.\n+     * The app will also run compact on the builder to generated the JWT Token string - when it's encrypted, it'll create\n+     * a 5 part string (not encrypted, it'll be 3 parts)\n+     * The encryption tests will decrypt and parse the token to do extra validation on the token!\n+     *\n+     **/\n+    //    // encryptWith(String  keyManagementAlg,  Key keyManagementKey,  String  contentEncryptionAlg)\n+    //    //\"RSA-OAEP\",  rsaPublicKey, \"A256GCM\"\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //\n+    //        String encryptKey = JwtKeyTools.getComplexPublicKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256);\n+    //        String decryptKey = JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, encryptKey);\n+    //        testSettings.put(JWTBuilderConstants.DECRYPT_KEY, decryptKey);\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //        validationUtils.validateJWEToken(response, (String) testSettings.get(JWTBuilderConstants.KEY_MGMT_ALG), (String) testSettings.get(JWTBuilderConstants.DECRYPT_KEY), (String) testSettings.get(JWTBuilderConstants.CONTENT_ENCRYPT_ALG));\n+    //\n+    //    }\n+    //  remaining tests will require updates similiar to the above test\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_shortPublicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"short_RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_privateKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512private-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM_signWith_RS256() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_RS256);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM_signWith_ES384() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_ES384);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM_signWith_HS512() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_HS512);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY, \"useThisToSign\");\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_STRING_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_shortPublicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"short_RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_privateKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384private-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_publicKey_A256GCM_signWith_RS384() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_RS384);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_publicKey_A256GCM_signWith_ES512() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_ES512);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_publicKey_A256GCM_signWith_HS256() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_HS256);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY, \"useThisToSign\");\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_STRING_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_shortPublicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"short_RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_privateKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512private-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_publicKey_A256GCM_signWith_RS512() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_RS512);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_publicKey_A256GCM_signWith_ES256() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_ES256);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_publicKey_A256GCM_signWith_HS384() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_HS384);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY, \"useThisToSign\");\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_STRING_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_Invalid_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, \"Some Random string\");\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_Invalid_KeyMgmtAlg_RS256_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"SomeKeyMgmtAlg\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_Invalid_ContentEncryptAlg() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"SomeContentEncryptAlg\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_sigAlg_RS256_key_string() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_null_key_string() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_empty_key_string() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_garbage_key_string() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS256_key_privKey() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS384_key_privKey() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS512_key_privKey() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS256_key_publicKey() throws Exception {\n+    //    //    public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS256_key_null() throws Exception {\n+\n+    /*****************************************************\n+     * Test various claimsFrom using encryption\n+     ****************************************************/\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Create a JWT builder using <config1> and create a JWT Token (in the servlet)\n+     * <LI>In the same server instance, use <config2> to create another builder.\n+     * <LI>Use the claimsFrom api to load all claims from the original token\n+     * <LI>Build another token\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>Verify that the second returned JWT Token contains all of the claims from the original token\n+     * </OL>\n+     *\n+     * @throws Exception\n+     */\n+    @Mode(TestMode.LITE)\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jwtToken_to_jweToken_allClaims() throws Exception {\n+\n+        String baseBuilderId = \"jwt1\";\n+        // The test code can't really convert the jwt string into the jwt token, so, tell the\n+        // test app to create a jwt token from another jwt builder config\n+        // use that as the source for the claimFrom call.\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_PARAM_BUILDER_ID, baseBuilderId);\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_TOKEN);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using one builder), then create a builder for another builder, load all claims from the token into the second builder\n+        String builderId = \"encryptJwtRS256\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+        // extract the first jwt token from the output and use that to create expectations.  We'll compare the content of the second token\n+        // to that of the first (since everything from the original token was obtained via claimFrom(<jwtToken>), they should be the same\n+        String jwtToken = BuilderHelpers.extractJwtTokenFromResponse(response, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM + \": \");\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken); // first token is NOT encrypted\n+        // second token will be encrypted - we don't have a way to pass the key to the validation methods, so, we'll skip the checks that required the actual payload content\n+        baseSettings.remove(PayloadConstants.EXPIRATION_TIME);\n+        baseSettings.remove(PayloadConstants.ISSUED_AT);\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweToken_to_jwtToken_allClaims() throws Exception {\n+\n+        String baseBuilderId = \"encryptJwtRS256\";\n+        // The test code can't really convert the jwt string into the jwt token, so, tell the\n+        // test app to create a jwt token from another jwt builder config\n+        // use that as the source for the claimFrom call.\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_PARAM_BUILDER_ID, baseBuilderId);\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_TOKEN);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using one builder), then create a builder for another builder, load all claims from the token into the second builder\n+        String builderId = \"jwt1\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+        // extract the first jwt token from the output and use that to create expectations.  We'll compare the content of the second token\n+        // to that of the first (since everything from the original token was obtained via claimFrom(<jwtToken>), they should be the same\n+        String jwtToken = BuilderHelpers.extractJwtTokenFromResponse(response, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM + \": \");\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken, JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256)); // first token is  encrypted\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweTokenRS256_to_jweTokenRS384_allClaims() throws Exception {\n+\n+        String baseBuilderId = \"encryptJwtRS256\";\n+        // The test code can't really convert the jwt string into the jwt token, so, tell the\n+        // test app to create a jwt token from another jwt builder config\n+        // use that as the source for the claimFrom call.\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_PARAM_BUILDER_ID, baseBuilderId);\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_TOKEN);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using one builder), then create a builder for another builder, load all claims from the token into the second builder\n+        String builderId = \"encryptJwtRS384\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+        // extract the first jwt token from the output and use that to create expectations.  We'll compare the content of the second token\n+        // to that of the first (since everything from the original token was obtained via claimFrom(<jwtToken>), they should be the same\n+        String jwtToken = BuilderHelpers.extractJwtTokenFromResponse(response, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM + \": \");\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken, JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256)); // first token is  encrypted\n+        // second token will be encrypted - we don't have a way to pass the key to the validation methods, so, we'll skip the checks that required the actual payload content\n+        baseSettings.remove(PayloadConstants.EXPIRATION_TIME);\n+        baseSettings.remove(PayloadConstants.ISSUED_AT);\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jwtString_to_jweToken_allClaims() throws Exception {\n+\n+        // build a token using the alternate builder config (we'll get claims from it)\n+        String baseBuilderId = \"jwt1\";\n+        String jwtToken = getBaseToken(baseBuilderId);\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken);\n+        // second token will be encrypted - we don't have a way to pass the key to the validation methods, so, we'll skip the checks that required the actual payload content\n+        baseSettings.remove(PayloadConstants.EXPIRATION_TIME);\n+        baseSettings.remove(PayloadConstants.ISSUED_AT);\n+        // since we getting all claims in the case, we can base our expectations upon the content of this first token)\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        // build settings that will tell the test app how to run/what to pass to the \"claimFrom\" api\n+        // give it a flag that says jwt string, and then pass the 3 part jwt token string\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_STRING);\n+        testSettings.put(JWTBuilderConstants.JWT_TOKEN, jwtToken);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using (a second) builder, load all claims from the token into the second builder\n+        String builderId = \"encryptJwtRS256\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    // TODO Failing since claimsFrom doesn't know how to parse JWE Token\n+    //@Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweString_to_jwtToken_allClaims() throws Exception {\n+\n+        // build a token using the alternate builder config (we'll get claims from it)\n+        String baseBuilderId = \"encryptJwtRS256\";\n+        String jwtToken = getBaseToken(baseBuilderId);\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken, JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256));\n+        // since we getting all claims in the case, we can base our expectations upon the content of this first token)\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        // build settings that will tell the test app how to run/what to pass to the \"claimFrom\" api\n+        // give it a flag that says jwt string, and then pass the 3 part jwt token string\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_STRING);\n+        testSettings.put(JWTBuilderConstants.JWT_TOKEN, jwtToken);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using (a second) builder, load all claims from the token into the second builder\n+        String builderId = \"jwt1\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    // TODO Failing since claimsFrom doesn't know how to parse JWE Token\n+    //@Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweStringRS256_to_jweTokenRS384_allClaims() throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxODgwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505718809", "bodyText": "clean up of this will come with the next delivery...", "author": "c00crane", "createdAt": "2020-10-15T17:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMjUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzY3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505713671", "bodyText": "Is this not doing the same thing as JwtBuilderAPIBasicTests_claimsFrom_jwtString_to_jweToken_allClaims?", "author": "ayoho", "createdAt": "2020-10-15T17:23:50Z", "path": "dev/com.ibm.ws.security.jwt_fat.builder/fat/src/com/ibm/ws/security/jwt/fat/builder/JwtBuilderApiBasicTests.java", "diffHunk": "@@ -5336,4 +5341,757 @@ public void JwtBuilderAPIBasicTests_multiple_apis_and_consumeToken() throws Exce\n         validationUtils.validateResult(appResponse, appExpectations);\n \n     }\n+\n+    /***************************************************** Test encryptWith ****************************************************/\n+    /**\n+     * The encryption tests will behave the same as the non-encryption tests - the test app will run the set methods,\n+     * build, then the get methods - the output from the get methods is what the builder expectations will validate against.\n+     * When the token is encrypted, the same get methods should/better work... So, we'll be testing that they return\n+     * the correct results.\n+     * The app will also run compact on the builder to generated the JWT Token string - when it's encrypted, it'll create\n+     * a 5 part string (not encrypted, it'll be 3 parts)\n+     * The encryption tests will decrypt and parse the token to do extra validation on the token!\n+     *\n+     **/\n+    //    // encryptWith(String  keyManagementAlg,  Key keyManagementKey,  String  contentEncryptionAlg)\n+    //    //\"RSA-OAEP\",  rsaPublicKey, \"A256GCM\"\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //\n+    //        String encryptKey = JwtKeyTools.getComplexPublicKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256);\n+    //        String decryptKey = JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, encryptKey);\n+    //        testSettings.put(JWTBuilderConstants.DECRYPT_KEY, decryptKey);\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //        validationUtils.validateJWEToken(response, (String) testSettings.get(JWTBuilderConstants.KEY_MGMT_ALG), (String) testSettings.get(JWTBuilderConstants.DECRYPT_KEY), (String) testSettings.get(JWTBuilderConstants.CONTENT_ENCRYPT_ALG));\n+    //\n+    //    }\n+    //  remaining tests will require updates similiar to the above test\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_shortPublicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"short_RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_privateKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512private-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM_signWith_RS256() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_RS256);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM_signWith_ES384() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_ES384);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_A256GCM_signWith_HS512() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_HS512);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY, \"useThisToSign\");\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_STRING_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_shortPublicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"short_RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_privateKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384private-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_publicKey_A256GCM_signWith_RS384() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_RS384);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_publicKey_A256GCM_signWith_ES512() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_ES512);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS384_publicKey_A256GCM_signWith_HS256() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_HS256);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY, \"useThisToSign\");\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_STRING_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS384public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_shortPublicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"short_RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_privateKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512private-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_publicKey_A256GCM_signWith_RS512() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_RS512);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_publicKey_A256GCM_signWith_ES256() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_ES256);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_PRIVATE_KEY_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS512_publicKey_A256GCM_signWith_HS384() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(HeaderConstants.ALGORITHM, JWTBuilderConstants.SIGALG_HS384);\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY, \"useThisToSign\");\n+    //        testSettings.put(JWTBuilderConstants.SHARED_KEY_TYPE, JWTBuilderConstants.SHARED_KEY_STRING_TYPE);\n+    //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS512public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_Invalid_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, \"Some Random string\");\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_Invalid_KeyMgmtAlg_RS256_publicKey_A256GCM() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"SomeKeyMgmtAlg\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"A256GCM\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    @Test\n+    //    public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_RS256_publicKey_Invalid_ContentEncryptAlg() throws Exception {\n+    //\n+    //        String builderId = \"jwt1\";\n+    //        JSONObject expectationSettings = BuilderHelpers.setDefaultClaims(builderId);\n+    //\n+    //        // create settings that will be passed to the test app as well as used to create what to expect in the results\n+    //        JSONObject testSettings = new JSONObject();\n+    //        testSettings.put(JWTBuilderConstants.KEY_MGMT_ALG, \"RSA-OAEP\");\n+    //        testSettings.put(JWTBuilderConstants.ENCRYPT_KEY, getKeyFromFile(builderServer, \"RS256public-key.pem\"));\n+    //        testSettings.put(JWTBuilderConstants.CONTENT_ENCRYPT_ALG, \"SomeContentEncryptAlg\");\n+    //        //        expectationSettings.put(\"overrideSettings\", testSettings);\n+    //        // TODO - update expectations for the encryption settings.\n+    //\n+    //        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, expectationSettings, builderServer);\n+    //\n+    //        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+    //        validationUtils.validateResult(response, expectations);\n+    //\n+    //    }\n+    //\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_RSA_OAEP_sigAlg_RS256_key_string() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_null_key_string() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_empty_key_string() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_garbage_key_string() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS256_key_privKey() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS384_key_privKey() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS512_key_privKey() throws Exception {\n+    //    //        public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS256_key_publicKey() throws Exception {\n+    //    //    public void JwtBuilderAPIBasicTests_encryptWith_sigAlg_RS256_key_null() throws Exception {\n+\n+    /*****************************************************\n+     * Test various claimsFrom using encryption\n+     ****************************************************/\n+    /**\n+     * Test Purpose:\n+     * <OL>\n+     * <LI>Create a JWT builder using <config1> and create a JWT Token (in the servlet)\n+     * <LI>In the same server instance, use <config2> to create another builder.\n+     * <LI>Use the claimsFrom api to load all claims from the original token\n+     * <LI>Build another token\n+     * </OL>\n+     * <P>\n+     * Expected Results:\n+     * <OL>\n+     * <LI>Verify that the second returned JWT Token contains all of the claims from the original token\n+     * </OL>\n+     *\n+     * @throws Exception\n+     */\n+    @Mode(TestMode.LITE)\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jwtToken_to_jweToken_allClaims() throws Exception {\n+\n+        String baseBuilderId = \"jwt1\";\n+        // The test code can't really convert the jwt string into the jwt token, so, tell the\n+        // test app to create a jwt token from another jwt builder config\n+        // use that as the source for the claimFrom call.\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_PARAM_BUILDER_ID, baseBuilderId);\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_TOKEN);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using one builder), then create a builder for another builder, load all claims from the token into the second builder\n+        String builderId = \"encryptJwtRS256\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+        // extract the first jwt token from the output and use that to create expectations.  We'll compare the content of the second token\n+        // to that of the first (since everything from the original token was obtained via claimFrom(<jwtToken>), they should be the same\n+        String jwtToken = BuilderHelpers.extractJwtTokenFromResponse(response, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM + \": \");\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken); // first token is NOT encrypted\n+        // second token will be encrypted - we don't have a way to pass the key to the validation methods, so, we'll skip the checks that required the actual payload content\n+        baseSettings.remove(PayloadConstants.EXPIRATION_TIME);\n+        baseSettings.remove(PayloadConstants.ISSUED_AT);\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweToken_to_jwtToken_allClaims() throws Exception {\n+\n+        String baseBuilderId = \"encryptJwtRS256\";\n+        // The test code can't really convert the jwt string into the jwt token, so, tell the\n+        // test app to create a jwt token from another jwt builder config\n+        // use that as the source for the claimFrom call.\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_PARAM_BUILDER_ID, baseBuilderId);\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_TOKEN);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using one builder), then create a builder for another builder, load all claims from the token into the second builder\n+        String builderId = \"jwt1\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+        // extract the first jwt token from the output and use that to create expectations.  We'll compare the content of the second token\n+        // to that of the first (since everything from the original token was obtained via claimFrom(<jwtToken>), they should be the same\n+        String jwtToken = BuilderHelpers.extractJwtTokenFromResponse(response, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM + \": \");\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken, JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256)); // first token is  encrypted\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweTokenRS256_to_jweTokenRS384_allClaims() throws Exception {\n+\n+        String baseBuilderId = \"encryptJwtRS256\";\n+        // The test code can't really convert the jwt string into the jwt token, so, tell the\n+        // test app to create a jwt token from another jwt builder config\n+        // use that as the source for the claimFrom call.\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_PARAM_BUILDER_ID, baseBuilderId);\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_TOKEN);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using one builder), then create a builder for another builder, load all claims from the token into the second builder\n+        String builderId = \"encryptJwtRS384\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+        // extract the first jwt token from the output and use that to create expectations.  We'll compare the content of the second token\n+        // to that of the first (since everything from the original token was obtained via claimFrom(<jwtToken>), they should be the same\n+        String jwtToken = BuilderHelpers.extractJwtTokenFromResponse(response, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM + \": \");\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken, JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256)); // first token is  encrypted\n+        // second token will be encrypted - we don't have a way to pass the key to the validation methods, so, we'll skip the checks that required the actual payload content\n+        baseSettings.remove(PayloadConstants.EXPIRATION_TIME);\n+        baseSettings.remove(PayloadConstants.ISSUED_AT);\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jwtString_to_jweToken_allClaims() throws Exception {\n+\n+        // build a token using the alternate builder config (we'll get claims from it)\n+        String baseBuilderId = \"jwt1\";\n+        String jwtToken = getBaseToken(baseBuilderId);\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken);\n+        // second token will be encrypted - we don't have a way to pass the key to the validation methods, so, we'll skip the checks that required the actual payload content\n+        baseSettings.remove(PayloadConstants.EXPIRATION_TIME);\n+        baseSettings.remove(PayloadConstants.ISSUED_AT);\n+        // since we getting all claims in the case, we can base our expectations upon the content of this first token)\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        // build settings that will tell the test app how to run/what to pass to the \"claimFrom\" api\n+        // give it a flag that says jwt string, and then pass the 3 part jwt token string\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_STRING);\n+        testSettings.put(JWTBuilderConstants.JWT_TOKEN, jwtToken);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using (a second) builder, load all claims from the token into the second builder\n+        String builderId = \"encryptJwtRS256\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    // TODO Failing since claimsFrom doesn't know how to parse JWE Token\n+    //@Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweString_to_jwtToken_allClaims() throws Exception {\n+\n+        // build a token using the alternate builder config (we'll get claims from it)\n+        String baseBuilderId = \"encryptJwtRS256\";\n+        String jwtToken = getBaseToken(baseBuilderId);\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken, JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256));\n+        // since we getting all claims in the case, we can base our expectations upon the content of this first token)\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        // build settings that will tell the test app how to run/what to pass to the \"claimFrom\" api\n+        // give it a flag that says jwt string, and then pass the 3 part jwt token string\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_STRING);\n+        testSettings.put(JWTBuilderConstants.JWT_TOKEN, jwtToken);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using (a second) builder, load all claims from the token into the second builder\n+        String builderId = \"jwt1\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    // TODO Failing since claimsFrom doesn't know how to parse JWE Token\n+    //@Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweStringRS256_to_jweTokenRS384_allClaims() throws Exception {\n+\n+        // build a token using the alternate builder config (we'll get claims from it)\n+        String baseBuilderId = \"encryptJwtRS256\";\n+        String jwtToken = getBaseToken(baseBuilderId);\n+        JSONObject baseSettings = BuilderHelpers.setClaimsFromToken(jwtToken, JwtKeyTools.getComplexPrivateKeyForSigAlg(builderServer, JWTBuilderConstants.SIGALG_RS256));\n+        // second token will be encrypted - we don't have a way to pass the key to the validation methods, so, we'll skip the checks that required the actual payload content\n+        baseSettings.remove(PayloadConstants.EXPIRATION_TIME);\n+        baseSettings.remove(PayloadConstants.ISSUED_AT);\n+        // since we getting all claims in the case, we can base our expectations upon the content of this first token)\n+        Expectations expectations = BuilderHelpers.createGoodBuilderExpectations(JWTBuilderConstants.JWT_BUILDER_SETAPIS_ENDPOINT, baseSettings, builderServer);\n+\n+        // build settings that will tell the test app how to run/what to pass to the \"claimFrom\" api\n+        // give it a flag that says jwt string, and then pass the 3 part jwt token string\n+        JSONObject testSettings = new JSONObject();\n+        testSettings.put(JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM, JWTBuilderConstants.JWT_BUILDER_ACTION_CLAIM_FROM_JWT_STRING);\n+        testSettings.put(JWTBuilderConstants.JWT_TOKEN, jwtToken);\n+\n+        // Now, add any override values - for this test, there are none\n+        // Invoke the builder app to create a token (using (a second) builder, load all claims from the token into the second builder\n+        String builderId = \"encryptJwtRS384\";\n+        Page response = actions.invokeJwtBuilder_setApis(_testName, builderServer, builderId, testSettings);\n+\n+        validationUtils.validateResult(response, expectations);\n+\n+    }\n+\n+    @Test\n+    public void JwtBuilderAPIBasicTests_claimsFrom_jweString_encodedPayload_allClaims() throws Exception {", "originalCommit": "d58f44490b9278b51f9ccac441a72c9a09645637", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMDM0OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14445#discussion_r505720349", "bodyText": "no - this is taking a JWE and pulling the payload out (in the test code) and passing just the payload (it's really the same as using a JWS payload test that we have, just making sure that the payload was formed properly when it comes from a JWE.", "author": "c00crane", "createdAt": "2020-10-15T17:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzY3MQ=="}], "type": "inlineReview"}]}