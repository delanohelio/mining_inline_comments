{"pr_number": 1287, "pr_title": "[HUDI-566] Added new test cases for class HoodieTimeline, HoodieDefaultTimeline and HoodieActiveTimeline.", "pr_createdAt": "2020-01-27T23:41:41Z", "pr_url": "https://github.com/apache/hudi/pull/1287", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1ODIxNQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372558215", "bodyText": "What is the reason for this change ? Is this related to test cases ?", "author": "n3nash", "createdAt": "2020-01-29T18:35:04Z", "path": "pom.xml", "diffHunk": "@@ -257,11 +257,6 @@\n               <configuration>\n                 <!-- Sets the path to the file which contains the execution data. -->\n                 <destFile>${project.build.directory}/coverage-reports/jacoco-ut.exec</destFile>\n-                <!--", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIwNzg5MQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373207891", "bodyText": "This is an unrelated change but is required to run jacoco. Currently jacococ plugin does not run on master branch.\nI will separate this into another PR.", "author": "prashantwason", "createdAt": "2020-01-30T21:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1ODIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1ODU1Nw==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372558557", "bodyText": "We need more memory only for integration tests, any reason to increase memory here ?", "author": "n3nash", "createdAt": "2020-01-29T18:35:47Z", "path": "pom.xml", "diffHunk": "@@ -110,6 +110,7 @@\n     <spark.bundle.hive.shade.prefix></spark.bundle.hive.shade.prefix>\n     <utilities.bundle.hive.scope>provided</utilities.bundle.hive.scope>\n     <utilities.bundle.hive.shade.prefix></utilities.bundle.hive.shade.prefix>\n+    <argLine>-Xmx1024m -XX:MaxPermSize=256m</argLine>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIwODAxNA==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373208014", "bodyText": "This is an unrelated change but is required to run jacoco. Currently jacococ plugin does not run on master branch.\nI will separate this into another PR.", "author": "prashantwason", "createdAt": "2020-01-30T21:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1ODU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1OTkzNQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372559935", "bodyText": "In all other parts of the code we use junit Assert, what is the reason to choose a different way of asserting the value of these get operations ? Also, if one of them fails, what is the exception expected ?", "author": "n3nash", "createdAt": "2020-01-29T18:38:35Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxMjU1Mg==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373212552", "bodyText": "This is the same way except I have grouped it into a function to reduce the number of lines of test code. Each checkTimline.accept(...) call is 2 lines of repeated code.\nIf any of them fails then it is similar to a single junit Assert failing.\nI will added a comment describing the function.", "author": "prashantwason", "createdAt": "2020-01-30T21:50:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1OTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDEyMA==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372560120", "bodyText": "What is the need to use a Vector here ? Does list not suffice ?", "author": "n3nash", "createdAt": "2020-01-29T18:38:56Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxNDM4NA==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373214384", "bodyText": "List is fine too. I used Vector as that is the data structure allocated within getAllInstants().", "author": "prashantwason", "createdAt": "2020-01-30T21:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDkyNw==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372560927", "bodyText": "Again, what is the use of vector here ?", "author": "n3nash", "createdAt": "2020-01-29T18:40:36Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxNDU4MQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373214581", "bodyText": "List is fine too.", "author": "prashantwason", "createdAt": "2020-01-30T21:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MTcyMw==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372561723", "bodyText": "In general, if you're not checking against the \"commitTime\" of the hoodie instant, can you simply use the ActiveTime.getInstant() to get a valid commit time instead of passing \"1\", \"2\" etc. One of the reasons is to standardize this across all tests - all other tests use commit times in the following format -> \"000\", \"001\" if they want to check against a deterministic commit time in the test..", "author": "n3nash", "createdAt": "2020-01-29T18:42:10Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxNzU0Ng==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373217546", "bodyText": "I think you mean to use the createNewInstantTime() method to get an instant time. (I did not find any getInstant()).\ncreateNewInstantTime() is not suitable for unit tests like this as it has a mandatory delay of 1 sec between two invocations. So creating many instants times increases the test time.\nI can switch to \"00X\" format.", "author": "prashantwason", "createdAt": "2020-01-30T22:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjMzMw==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372562333", "bodyText": "Are these following lines testing anything ?", "author": "n3nash", "createdAt": "2020-01-29T18:43:19Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+\n+    // Etc.\n+    timeline.getInstantDetails(clean);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxNzc5Ng==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373217796", "bodyText": "removed.", "author": "prashantwason", "createdAt": "2020-01-30T22:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MzA3MA==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372563070", "bodyText": "Generally, for any test, you want to have an evaluation function, if you want to test createInstants for eg, then get the number of instants from getAllInstants() and check against the number provided by       timeline.createNewInstant(instant by asserting they are equal.", "author": "n3nash", "createdAt": "2020-01-29T18:44:49Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+\n+    // Etc.\n+    timeline.getInstantDetails(clean);\n+    timeline.toString();\n+    clean.toString();\n+  }\n+\n+  @Test\n+  public void testCreateInstants() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxODY4Mg==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373218682", "bodyText": "Test added.", "author": "prashantwason", "createdAt": "2020-01-30T22:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MzA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MzcwMQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372563701", "bodyText": "Please use a valid commitTime here or standardize with \"000\", \"001\" used in other tests.", "author": "n3nash", "createdAt": "2020-01-29T18:45:58Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+\n+    // Etc.\n+    timeline.getInstantDetails(clean);\n+    timeline.toString();\n+    clean.toString();\n+  }\n+\n+  @Test\n+  public void testCreateInstants() {\n+    for (HoodieInstant instant : getAllInstants()) {\n+      timeline.createNewInstant(instant);\n+    }\n+  }\n+\n+  @Test\n+  public void testInstantFilenameOperations() {\n+    HoodieInstant instantRequested = new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantInflight = new HoodieInstant(State.INFLIGHT, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantComplete = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantRequested.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantInflight.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantComplete.getFileName()), \"5\");\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsComplete(instantInflight.getFileName()),\n+            instantComplete.getFileName());\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsInflight(instantComplete.getFileName()),\n+            instantInflight.getFileName());\n+  }\n+\n+  @Test\n+  public void testFiltering() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    timeline.setInstants(allInstants);\n+\n+    // getReverseOrderedInstants\n+    Stream<HoodieInstant> instants = timeline.getReverseOrderedInstants();\n+    List<HoodieInstant> v1 = instants.collect(Collectors.toList());\n+    List<HoodieInstant> v2 = sup.get().collect(Collectors.toList());\n+    Collections.reverse(v2);\n+    assertEquals(v1, v2);\n+\n+    BiConsumer<HoodieTimeline, Set<State>> checkFilter = (HoodieTimeline timeline, Set<State> states) -> {\n+      sup.get().filter(i -> states.contains(i.getState())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !states.contains(i.getState())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    checkFilter.accept(timeline.filter(i -> false), Sets.newHashSet());\n+    checkFilter.accept(timeline.filterInflights(), Sets.newHashSet(State.INFLIGHT));\n+    checkFilter.accept(timeline.filterInflightsAndRequested(),\n+            Sets.newHashSet(State.INFLIGHT, State.REQUESTED));\n+\n+    // filterCompletedAndCompactionInstants\n+    // This cannot be done using checkFilter as it involves both states and actions\n+    final HoodieTimeline t1 = timeline.filterCompletedAndCompactionInstants();\n+    final Set<State> states = Sets.newHashSet(State.REQUESTED, State.COMPLETED);\n+    final Set<String> actions = Sets.newHashSet(HoodieTimeline.COMPACTION_ACTION);\n+    sup.get().filter(i -> states.contains(i.getState()) || actions.contains(i.getAction()))\n+        .forEach(i -> assertTrue(t1.containsInstant(i)));\n+    sup.get().filter(i -> !(states.contains(i.getState()) || actions.contains(i.getAction())))\n+        .forEach(i -> assertFalse(t1.containsInstant(i)));\n+\n+    // filterPendingCompactionTimeline\n+    final HoodieTimeline t2 = timeline.filterPendingCompactionTimeline();\n+    sup.get().filter(i -> i.getAction() == HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertTrue(t2.containsInstant(i)));\n+    sup.get().filter(i -> i.getAction() != HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertFalse(t2.containsInstant(i)));\n+  }\n+\n+  private Vector<HoodieInstant> getAllInstants() {\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    Vector<HoodieInstant> allInstants = new Vector<HoodieInstant>();\n+    long startTime = System.currentTimeMillis();\n+    for (State state : State.values()) {\n+      if (state == State.INVALID) {\n+        continue;\n+      }\n+      for (String action : new String[] {HoodieTimeline.COMMIT_ACTION,\n+                                         HoodieTimeline.DELTA_COMMIT_ACTION,\n+                                         HoodieTimeline.CLEAN_ACTION,\n+                                         HoodieTimeline.SAVEPOINT_ACTION,\n+                                         HoodieTimeline.RESTORE_ACTION,\n+                                         HoodieTimeline.ROLLBACK_ACTION,\n+                                         HoodieTimeline.COMPACTION_ACTION,\n+          }) {\n+        allInstants.add(new HoodieInstant(state, action, String.valueOf(startTime++)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMzMzI0Ng==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373333246", "bodyText": "Done", "author": "prashantwason", "createdAt": "2020-01-31T06:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MzcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTM2MA==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372565360", "bodyText": "May be introduce a variable VALID_ACTION_IN_TIMELINE which is a set in the HoodieActiveTimeline class. Tomorrow, if a new action is added, it might be easier to evolve the test ?", "author": "n3nash", "createdAt": "2020-01-29T18:49:21Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+\n+    // Etc.\n+    timeline.getInstantDetails(clean);\n+    timeline.toString();\n+    clean.toString();\n+  }\n+\n+  @Test\n+  public void testCreateInstants() {\n+    for (HoodieInstant instant : getAllInstants()) {\n+      timeline.createNewInstant(instant);\n+    }\n+  }\n+\n+  @Test\n+  public void testInstantFilenameOperations() {\n+    HoodieInstant instantRequested = new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantInflight = new HoodieInstant(State.INFLIGHT, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantComplete = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantRequested.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantInflight.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantComplete.getFileName()), \"5\");\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsComplete(instantInflight.getFileName()),\n+            instantComplete.getFileName());\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsInflight(instantComplete.getFileName()),\n+            instantInflight.getFileName());\n+  }\n+\n+  @Test\n+  public void testFiltering() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    timeline.setInstants(allInstants);\n+\n+    // getReverseOrderedInstants\n+    Stream<HoodieInstant> instants = timeline.getReverseOrderedInstants();\n+    List<HoodieInstant> v1 = instants.collect(Collectors.toList());\n+    List<HoodieInstant> v2 = sup.get().collect(Collectors.toList());\n+    Collections.reverse(v2);\n+    assertEquals(v1, v2);\n+\n+    BiConsumer<HoodieTimeline, Set<State>> checkFilter = (HoodieTimeline timeline, Set<State> states) -> {\n+      sup.get().filter(i -> states.contains(i.getState())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !states.contains(i.getState())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    checkFilter.accept(timeline.filter(i -> false), Sets.newHashSet());\n+    checkFilter.accept(timeline.filterInflights(), Sets.newHashSet(State.INFLIGHT));\n+    checkFilter.accept(timeline.filterInflightsAndRequested(),\n+            Sets.newHashSet(State.INFLIGHT, State.REQUESTED));\n+\n+    // filterCompletedAndCompactionInstants\n+    // This cannot be done using checkFilter as it involves both states and actions\n+    final HoodieTimeline t1 = timeline.filterCompletedAndCompactionInstants();\n+    final Set<State> states = Sets.newHashSet(State.REQUESTED, State.COMPLETED);\n+    final Set<String> actions = Sets.newHashSet(HoodieTimeline.COMPACTION_ACTION);\n+    sup.get().filter(i -> states.contains(i.getState()) || actions.contains(i.getAction()))\n+        .forEach(i -> assertTrue(t1.containsInstant(i)));\n+    sup.get().filter(i -> !(states.contains(i.getState()) || actions.contains(i.getAction())))\n+        .forEach(i -> assertFalse(t1.containsInstant(i)));\n+\n+    // filterPendingCompactionTimeline\n+    final HoodieTimeline t2 = timeline.filterPendingCompactionTimeline();\n+    sup.get().filter(i -> i.getAction() == HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertTrue(t2.containsInstant(i)));\n+    sup.get().filter(i -> i.getAction() != HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertFalse(t2.containsInstant(i)));\n+  }\n+\n+  private Vector<HoodieInstant> getAllInstants() {\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    Vector<HoodieInstant> allInstants = new Vector<HoodieInstant>();\n+    long startTime = System.currentTimeMillis();\n+    for (State state : State.values()) {\n+      if (state == State.INVALID) {\n+        continue;\n+      }\n+      for (String action : new String[] {HoodieTimeline.COMMIT_ACTION,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMyNDc1MQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r373324751", "bodyText": "Sounds good.", "author": "prashantwason", "createdAt": "2020-01-31T05:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzExMQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374443111", "bodyText": "nit : s/VALID_ACTION_IN_TIMELINE/VALID_ACTIONS_IN_TIMELINE/", "author": "n3nash", "createdAt": "2020-02-04T02:16:07Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTimeline.java", "diffHunk": "@@ -56,6 +56,10 @@\n   String REQUESTED_EXTENSION = \".requested\";\n   String RESTORE_ACTION = \"restore\";\n \n+  String[] VALID_ACTION_IN_TIMELINE = {COMMIT_ACTION, DELTA_COMMIT_ACTION,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzI0NQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374443245", "bodyText": "Can we avoid these changes ? Might be due to your intellij setup, please check", "author": "n3nash", "createdAt": "2020-02-04T02:16:39Z", "path": "hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTimeline.java", "diffHunk": "@@ -111,21 +115,21 @@\n    * view is constructed with this timeline so that file-slice after pending compaction-requested instant-time is also\n    * considered valid. A RT file-system view for reading must then merge the file-slices before and after pending\n    * compaction instant so that all delta-commits are read.\n-   * \n+   *", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNTcwMQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374915701", "bodyText": "Sure. will fix my setup.", "author": "prashantwason", "createdAt": "2020-02-04T20:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDU4MQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374444581", "bodyText": "Please move this to a different PR", "author": "n3nash", "createdAt": "2020-02-04T02:22:42Z", "path": "hudi-hadoop-mr/pom.xml", "diffHunk": "@@ -114,6 +114,10 @@\n         <groupId>org.apache.rat</groupId>\n         <artifactId>apache-rat-plugin</artifactId>\n       </plugin>\n+      <plugin>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNjIzNg==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374916236", "bodyText": "Sure", "author": "prashantwason", "createdAt": "2020-02-04T20:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDY4Mg==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374444682", "bodyText": "Can we just use List since that's consistently used across the project ? (unless there is a need for vector)", "author": "n3nash", "createdAt": "2020-02-04T02:23:12Z", "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,269 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    List<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    /**\n+     * Helper function to check HoodieTimeline only contains some type of Instant actions.\n+     * @param timeline The HoodieTimeline to check\n+     * @param actions The actions that should be present in the timeline being checked\n+     */\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    List<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+  }\n+\n+  @Test\n+  public void testCreateInstants() {\n+    List<HoodieInstant> allInstants = getAllInstants();\n+    for (HoodieInstant instant : allInstants) {\n+      timeline.createNewInstant(instant);\n+    }\n+\n+    timeline = timeline.reload();\n+    for (HoodieInstant instant : allInstants) {\n+      assertTrue(timeline.containsInstant(instant));\n+    }\n+  }\n+\n+  @Test\n+  public void testInstantFilenameOperations() {\n+    HoodieInstant instantRequested = new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantInflight = new HoodieInstant(State.INFLIGHT, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantComplete = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantRequested.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantInflight.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantComplete.getFileName()), \"5\");\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsComplete(instantInflight.getFileName()),\n+            instantComplete.getFileName());\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsInflight(instantComplete.getFileName()),\n+            instantInflight.getFileName());\n+  }\n+\n+  @Test\n+  public void testFiltering() {\n+    List<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    timeline.setInstants(allInstants);\n+\n+    // getReverseOrderedInstants\n+    Stream<HoodieInstant> instants = timeline.getReverseOrderedInstants();\n+    List<HoodieInstant> v1 = instants.collect(Collectors.toList());\n+    List<HoodieInstant> v2 = sup.get().collect(Collectors.toList());\n+    Collections.reverse(v2);\n+    assertEquals(v1, v2);\n+\n+    /**\n+     * Helper function to check HoodieTimeline only contains some type of Instant states.\n+     * @param timeline The HoodieTimeline to check\n+     * @param states The states that should be present in the timeline being checked\n+     */\n+    BiConsumer<HoodieTimeline, Set<State>> checkFilter = (HoodieTimeline timeline, Set<State> states) -> {\n+      sup.get().filter(i -> states.contains(i.getState())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !states.contains(i.getState())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    checkFilter.accept(timeline.filter(i -> false), Sets.newHashSet());\n+    checkFilter.accept(timeline.filterInflights(), Sets.newHashSet(State.INFLIGHT));\n+    checkFilter.accept(timeline.filterInflightsAndRequested(),\n+            Sets.newHashSet(State.INFLIGHT, State.REQUESTED));\n+\n+    // filterCompletedAndCompactionInstants\n+    // This cannot be done using checkFilter as it involves both states and actions\n+    final HoodieTimeline t1 = timeline.filterCompletedAndCompactionInstants();\n+    final Set<State> states = Sets.newHashSet(State.REQUESTED, State.COMPLETED);\n+    final Set<String> actions = Sets.newHashSet(HoodieTimeline.COMPACTION_ACTION);\n+    sup.get().filter(i -> states.contains(i.getState()) || actions.contains(i.getAction()))\n+        .forEach(i -> assertTrue(t1.containsInstant(i)));\n+    sup.get().filter(i -> !(states.contains(i.getState()) || actions.contains(i.getAction())))\n+        .forEach(i -> assertFalse(t1.containsInstant(i)));\n+\n+    // filterPendingCompactionTimeline\n+    final HoodieTimeline t2 = timeline.filterPendingCompactionTimeline();\n+    sup.get().filter(i -> i.getAction() == HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertTrue(t2.containsInstant(i)));\n+    sup.get().filter(i -> i.getAction() != HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertFalse(t2.containsInstant(i)));\n+  }\n+\n+  /**\n+   * Returns an exhaustive list of all possible HoodieInstant.\n+   * @return list of HoodieInstant\n+   */\n+  private List<HoodieInstant> getAllInstants() {\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    Vector<HoodieInstant> allInstants = new Vector<HoodieInstant>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNjczOQ==", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374916739", "bodyText": "No real need for vector.", "author": "prashantwason", "createdAt": "2020-02-04T20:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDY4Mg=="}], "type": "inlineReview"}, {"oid": "952391dee72c7bb8747c0096ac399edc09b92f2a", "url": "https://github.com/apache/hudi/commit/952391dee72c7bb8747c0096ac399edc09b92f2a", "message": "[HUDI-566] Added new test cases for class HoodieTimeline, HoodieDefaultTimeline and HoodieActiveTimeline.", "committedDate": "2020-02-05T01:53:31Z", "type": "commit"}, {"oid": "952391dee72c7bb8747c0096ac399edc09b92f2a", "url": "https://github.com/apache/hudi/commit/952391dee72c7bb8747c0096ac399edc09b92f2a", "message": "[HUDI-566] Added new test cases for class HoodieTimeline, HoodieDefaultTimeline and HoodieActiveTimeline.", "committedDate": "2020-02-05T01:53:31Z", "type": "forcePushed"}]}