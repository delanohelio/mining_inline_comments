{"pr_number": 1793, "pr_title": "[HUDI-1068] Fixing deletes in global bloom", "pr_createdAt": "2020-07-04T20:04:48Z", "pr_url": "https://github.com/apache/hudi/pull/1793", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgxOTY1Mw==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r449819653", "bodyText": "It seems that we don't need to unseal() as the sealed is false when using\n\n  \n    \n      hudi/hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecord.java\n    \n    \n        Lines 67 to 73\n      in\n      574dcf9\n    \n    \n    \n    \n\n        \n          \n            \n        \n\n        \n          \n           public HoodieRecord(HoodieKey key, T data) { \n        \n\n        \n          \n             this.key = key; \n        \n\n        \n          \n             this.data = data; \n        \n\n        \n          \n             this.currentLocation = null; \n        \n\n        \n          \n             this.newLocation = null; \n        \n\n        \n          \n             this.sealed = false;", "author": "xushiyan", "createdAt": "2020-07-05T01:18:23Z", "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/HoodieGlobalBloomIndex.java", "diffHunk": "@@ -125,6 +125,9 @@ public HoodieGlobalBloomIndex(HoodieWriteConfig config) {\n           // Create an empty record to delete the record in the old partition\n           HoodieRecord<T> emptyRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,\n               new EmptyHoodieRecordPayload());\n+          emptyRecord.unseal();\n+          emptyRecord.setCurrentLocation(recordLocationHoodieKeyPair.get()._1());\n+          emptyRecord.seal();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgxOTY1NQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r449819655", "bodyText": "ditto", "author": "xushiyan", "createdAt": "2020-07-05T01:18:36Z", "path": "hudi-client/src/main/java/org/apache/hudi/index/simple/HoodieGlobalSimpleIndex.java", "diffHunk": "@@ -131,6 +131,9 @@ public HoodieGlobalSimpleIndex(HoodieWriteConfig config) {\n             if (config.getGlobalSimpleIndexUpdatePartitionPath() && !(inputRecord.getPartitionPath().equals(partitionPath))) {\n               // Create an empty record to delete the record in the old partition\n               HoodieRecord<T> emptyRecord = new HoodieRecord(new HoodieKey(inputRecord.getRecordKey(), partitionPath), new EmptyHoodieRecordPayload());\n+              emptyRecord.unseal();\n+              emptyRecord.setCurrentLocation(location);\n+              emptyRecord.seal();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgxOTY3Mg==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r449819672", "bodyText": "minor: @throws Exception looks redundant without further info", "author": "xushiyan", "createdAt": "2020-07-05T01:19:19Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,173 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition\n+   * is deleted appropriately.\n+   * @throws Exception", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDU0NQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450160545", "bodyText": "lets rename this to deleteRecord", "author": "vinothchandar", "createdAt": "2020-07-06T11:34:37Z", "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/HoodieGlobalBloomIndex.java", "diffHunk": "@@ -125,6 +125,9 @@ public HoodieGlobalBloomIndex(HoodieWriteConfig config) {\n           // Create an empty record to delete the record in the old partition\n           HoodieRecord<T> emptyRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDgwOQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450160809", "bodyText": "and taggedRecord to insert..  this makes what this block is doing clearer..", "author": "vinothchandar", "createdAt": "2020-07-06T11:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTI3NA==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450161274", "bodyText": "why is this relevant for this test?", "author": "vinothchandar", "createdAt": "2020-07-06T11:36:10Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,173 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition\n+   * is deleted appropriately.\n+   * @throws Exception\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in\n+   * old partition is deleted appropriately.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType,\n+      HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // Force using older timeline layout", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxMjY5NQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450812695", "bodyText": "I don't know actually. I tried removing version_0 and the test fails. If we know why testUpsertsInternal in the same class does it (@bvaradar ), we might have an answer.", "author": "nsivabalan", "createdAt": "2020-07-07T12:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTk0NA==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450161944", "bodyText": "can. we explicitly check for duplicates?", "author": "vinothchandar", "createdAt": "2020-07-06T11:37:42Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,173 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition\n+   * is deleted appropriately.\n+   * @throws Exception\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in\n+   * old partition is deleted appropriately.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType,\n+      HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // Force using older timeline layout\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true).build())\n+        .withTimelineLayoutVersion(\n+            VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(),\n+        metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n \n     // Write 1 (only inserts)\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n+    // Check the entire dataset has all records still\n     String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n     for (int i = 0; i < fullPartitionPaths.length; i++) {\n       fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n+    Dataset<Row> rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    List<Pair<String, String>> actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // verify all partitionpath, record key matches\n+    assertEquals(expectedPartitionPathRecKeyPairs.size(), actualPartitionPathRecKeyPairs.size());\n+    for (Pair<String, String> entry : actualPartitionPathRecKeyPairs) {\n+      assertTrue(expectedPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    for (Pair<String, String> entry : expectedPartitionPathRecKeyPairs) {\n+      assertTrue(actualPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n+\n+    // Check the entire dataset has all records still\n+    fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n+    for (int i = 0; i < fullPartitionPaths.length; i++) {\n+      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    }\n+\n+    rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // verify all partitionpath, record key matches\n+    assertEquals(expectedPartitionPathRecKeyPairs.size(), actualPartitionPathRecKeyPairs.size());\n+    for (Pair<String, String> entry : actualPartitionPathRecKeyPairs) {\n+      assertTrue(expectedPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    for (Pair<String, String> entry : expectedPartitionPathRecKeyPairs) {\n+      assertTrue(actualPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    // Write 2 (updates)\n+    newCommitTime = \"003\";\n+    records = records.subList(5, 10);\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+      String partitionPath = rec.getPartitionPath();\n+      String newPartitionPath = null;\n+      if (partitionPath.equalsIgnoreCase(DEFAULT_FIRST_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_SECOND_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_SECOND_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_THIRD_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_THIRD_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_FIRST_PARTITION_PATH;\n+      } else {\n+        throw new IllegalStateException(\"Unknown partition path \" + rec.getPartitionPath());\n+      }\n+      recordsToUpsert.add(\n+          new HoodieRecord(new HoodieKey(rec.getRecordKey(), newPartitionPath),\n+              rec.getData()));\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(newPartitionPath, rec.getRecordKey()));\n+    }\n+\n+    writeRecords = jsc.parallelize(recordsToUpsert, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    statuses = result.collect();\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(updates1, fs);\n     // Check the entire dataset has all records still\n     fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n     for (int i = 0; i < fullPartitionPaths.length; i++) {\n       fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n+\n+    rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n+\n+    // verify all partitionpath, record key matches", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MjE3NA==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450162174", "bodyText": "and also atleast two files being present before triggering the update of the partition path", "author": "vinothchandar", "createdAt": "2020-07-06T11:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgwOTYwMg==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450809602", "bodyText": "I have refactored the test now. You can check it out. have added assertions to verify basefile counts.", "author": "nsivabalan", "createdAt": "2020-07-07T11:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxMTM4MA==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450811380", "bodyText": "We do assert with expected entries count. so duplicates should be taken care of in that assertion.", "author": "nsivabalan", "createdAt": "2020-07-07T12:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNTY0Mw==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453215643", "bodyText": "nit: typo insertRecord", "author": "xushiyan", "createdAt": "2020-07-11T17:21:44Z", "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/HoodieGlobalBloomIndex.java", "diffHunk": "@@ -123,11 +123,13 @@ public HoodieGlobalBloomIndex(HoodieWriteConfig config) {\n         if (config.getBloomIndexUpdatePartitionPath()\n             && !recordLocationHoodieKeyPair.get()._2.getPartitionPath().equals(hoodieRecord.getPartitionPath())) {\n           // Create an empty record to delete the record in the old partition\n-          HoodieRecord<T> emptyRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,\n+          HoodieRecord<T> deleteRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,\n               new EmptyHoodieRecordPayload());\n+          deleteRecord.setCurrentLocation(recordLocationHoodieKeyPair.get()._1());\n+          deleteRecord.seal();\n           // Tag the incoming record for inserting to the new partition\n-          HoodieRecord<T> taggedRecord = HoodieIndexUtils.getTaggedRecord(hoodieRecord, Option.empty());\n-          return Arrays.asList(emptyRecord, taggedRecord).iterator();\n+          HoodieRecord<T> insetRecord = HoodieIndexUtils.getTaggedRecord(hoodieRecord, Option.empty());\n+          return Arrays.asList(deleteRecord, insetRecord).iterator();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNTc0Ng==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453215746", "bodyText": "these 2 can be combined into a @ParameterizedTest with IndexType as argument", "author": "xushiyan", "createdAt": "2020-07-11T17:23:11Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNjk0Mw==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453216943", "bodyText": "assertAll() works better for iterating assertions", "author": "xushiyan", "createdAt": "2020-07-11T17:35:53Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNzA4NQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453217085", "bodyText": "result.collect() return value not used?", "author": "xushiyan", "createdAt": "2020-07-11T17:38:01Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMzY3NA==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453713674", "bodyText": "yes, we just need to trigger the action.", "author": "nsivabalan", "createdAt": "2020-07-13T14:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNzA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNzg1Mg==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453217852", "bodyText": "these lines can be simplified to assertTrue(entrySet().stream().filter().count()>=1)", "author": "xushiyan", "createdAt": "2020-07-11T17:45:46Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify that there are more than 1 basefiles per partition\n+    // we can't guarantee randomness in partitions where records are distributed. So, verify atleast one partition has more than 1 basefile.\n+    baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    boolean hasMoreThanOneBaseFile = false;\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      if (entry.getValue() > 1) {\n+        hasMoreThanOneBaseFile = true;\n+        break;\n+      }\n+    }\n+    assertTrue(hasMoreThanOneBaseFile, \"Atleast one partition should have more than 1 base file after 2nd batch of writes\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxODQ0OQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453218449", "bodyText": "can this be replaced by using a new variable for expectedPartitionPathRecKeyPairs? a bit hard to track what is contained.", "author": "xushiyan", "createdAt": "2020-07-11T17:52:12Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify that there are more than 1 basefiles per partition\n+    // we can't guarantee randomness in partitions where records are distributed. So, verify atleast one partition has more than 1 basefile.\n+    baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    boolean hasMoreThanOneBaseFile = false;\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      if (entry.getValue() > 1) {\n+        hasMoreThanOneBaseFile = true;\n+        break;\n+      }\n+    }\n+    assertTrue(hasMoreThanOneBaseFile, \"Atleast one partition should have more than 1 base file after 2nd batch of writes\");\n+\n+    // Write 3 (upserts to records from batch 1 with diff partition path)\n+    newCommitTime = \"003\";\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      // remove older entry from expected partition path record key pairs\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNTkwNQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453715905", "bodyText": "don't get you. This tracks all partitionpath record key pairs so far. And in this block, for records for which partition path is getting updated, we need to remove those entries from this expected list and add updated entries. So, don't quite understand how introducing new variable will simplify things. would you mind clarifying.", "author": "nsivabalan", "createdAt": "2020-07-13T15:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxODQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1OTc2MA==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r454059760", "bodyText": "ah ok i see. thanks for clarifying", "author": "xushiyan", "createdAt": "2020-07-14T02:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxODQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxOTAwOQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453219009", "bodyText": "Looks like Set<Pair<String, String>> is better suited for expectedPartitionPathRecKeyPairs? so these can be simplified as assertEquals(expected, actual);", "author": "xushiyan", "createdAt": "2020-07-11T17:58:28Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify that there are more than 1 basefiles per partition\n+    // we can't guarantee randomness in partitions where records are distributed. So, verify atleast one partition has more than 1 basefile.\n+    baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    boolean hasMoreThanOneBaseFile = false;\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      if (entry.getValue() > 1) {\n+        hasMoreThanOneBaseFile = true;\n+        break;\n+      }\n+    }\n+    assertTrue(hasMoreThanOneBaseFile, \"Atleast one partition should have more than 1 base file after 2nd batch of writes\");\n+\n+    // Write 3 (upserts to records from batch 1 with diff partition path)\n+    newCommitTime = \"003\";\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      // remove older entry from expected partition path record key pairs\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+      String partitionPath = rec.getPartitionPath();\n+      String newPartitionPath = null;\n+      if (partitionPath.equalsIgnoreCase(DEFAULT_FIRST_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_SECOND_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_SECOND_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_THIRD_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_THIRD_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_FIRST_PARTITION_PATH;\n+      } else {\n+        throw new IllegalStateException(\"Unknown partition path \" + rec.getPartitionPath());\n+      }\n+      recordsToUpsert.add(\n+          new HoodieRecord(new HoodieKey(rec.getRecordKey(), newPartitionPath),\n+              rec.getData()));\n+      // populate expected partition path and record keys\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(newPartitionPath, rec.getRecordKey()));\n+    }\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(updates1, fs);\n-    // Check the entire dataset has all records still\n-    fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n+    writeRecords = jsc.parallelize(recordsToUpsert, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    statuses = result.collect();\n+\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+  }\n+\n+  private void assertPartitionPathRecordKeys(String[] fullPartitionPaths, List<Pair<String, String>> expectedPartitionPathRecKeyPairs) {\n+    Dataset<Row> rows = getAllRows(fullPartitionPaths);\n+    List<Pair<String, String>> actualPartitionPathRecKeyPairs = getActualPartitionPathAndRecordKeys(rows);\n+    // verify all partitionpath, record key matches\n+    assertActualAndExpectedPartitionPathRecordKeyMatches(expectedPartitionPathRecKeyPairs, actualPartitionPathRecKeyPairs);\n+  }\n+\n+  private List<Pair<String, String>> getActualPartitionPathAndRecordKeys(Dataset<org.apache.spark.sql.Row> rows) {\n+    List<Pair<String, String>> actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n+    return actualPartitionPathRecKeyPairs;\n+  }\n+\n+  private Dataset<org.apache.spark.sql.Row> getAllRows(String[] fullPartitionPaths) {\n+    return HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+  }\n+\n+  private String[] getFullPartitionPaths() {\n+    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n     for (int i = 0; i < fullPartitionPaths.length; i++) {\n       fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n+    return fullPartitionPaths;\n+  }\n+\n+  private Map<String, Integer> getBaseFileCounts(String[] fullPartitionPaths) {\n+    return HoodieClientTestUtils.getBaseFileCountForPaths(basePath, fs, fullPartitionPaths);\n+  }\n+\n+  private void assertActualAndExpectedPartitionPathRecordKeyMatches(List<Pair<String, String>> expectedPartitionPathRecKeyPairs,\n+      List<Pair<String, String>> actualPartitionPathRecKeyPairs) {\n+    // verify all partitionpath, record key matches\n+    assertEquals(expectedPartitionPathRecKeyPairs.size(), actualPartitionPathRecKeyPairs.size());\n+    for (Pair<String, String> entry : actualPartitionPathRecKeyPairs) {\n+      assertTrue(expectedPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    for (Pair<String, String> entry : expectedPartitionPathRecKeyPairs) {\n+      assertTrue(actualPartitionPathRecKeyPairs.contains(entry));\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNDg5Mg==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453724892", "bodyText": "I will fix the expected entries to be a Set, but can't fix the actual. we want to capture any duplicates if any. So, can't really use assertEquals(set, list).", "author": "nsivabalan", "createdAt": "2020-07-13T15:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxOTAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxOTI4NQ==", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453219285", "bodyText": "to align with junit assertions, can we make the expected variable 1st argument?", "author": "xushiyan", "createdAt": "2020-07-11T18:01:53Z", "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify that there are more than 1 basefiles per partition\n+    // we can't guarantee randomness in partitions where records are distributed. So, verify atleast one partition has more than 1 basefile.\n+    baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    boolean hasMoreThanOneBaseFile = false;\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      if (entry.getValue() > 1) {\n+        hasMoreThanOneBaseFile = true;\n+        break;\n+      }\n+    }\n+    assertTrue(hasMoreThanOneBaseFile, \"Atleast one partition should have more than 1 base file after 2nd batch of writes\");\n+\n+    // Write 3 (upserts to records from batch 1 with diff partition path)\n+    newCommitTime = \"003\";\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      // remove older entry from expected partition path record key pairs\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+      String partitionPath = rec.getPartitionPath();\n+      String newPartitionPath = null;\n+      if (partitionPath.equalsIgnoreCase(DEFAULT_FIRST_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_SECOND_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_SECOND_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_THIRD_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_THIRD_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_FIRST_PARTITION_PATH;\n+      } else {\n+        throw new IllegalStateException(\"Unknown partition path \" + rec.getPartitionPath());\n+      }\n+      recordsToUpsert.add(\n+          new HoodieRecord(new HoodieKey(rec.getRecordKey(), newPartitionPath),\n+              rec.getData()));\n+      // populate expected partition path and record keys\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(newPartitionPath, rec.getRecordKey()));\n+    }\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(updates1, fs);\n-    // Check the entire dataset has all records still\n-    fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n+    writeRecords = jsc.parallelize(recordsToUpsert, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    statuses = result.collect();\n+\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+  }\n+\n+  private void assertPartitionPathRecordKeys(String[] fullPartitionPaths, List<Pair<String, String>> expectedPartitionPathRecKeyPairs) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc", "url": "https://github.com/apache/hudi/commit/95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc", "message": "Fixing deletes in global bloom", "committedDate": "2020-07-13T17:52:20Z", "type": "commit"}, {"oid": "95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc", "url": "https://github.com/apache/hudi/commit/95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc", "message": "Fixing deletes in global bloom", "committedDate": "2020-07-13T17:52:20Z", "type": "forcePushed"}]}