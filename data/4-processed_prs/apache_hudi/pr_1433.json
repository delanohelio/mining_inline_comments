{"pr_number": 1433, "pr_title": "[HUDI-728]: Implement custom key generator", "pr_createdAt": "2020-03-21T09:20:33Z", "pr_url": "https://github.com/apache/hudi/pull/1433", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNjI5NA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400516294", "bodyText": "java docs. Also try to see if having an example would help devs.", "author": "nsivabalan", "createdAt": "2020-03-30T21:51:33Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIxMzU2MQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r408213561", "bodyText": "Sure, will add docs here.", "author": "pratyakshsharma", "createdAt": "2020-04-14T15:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNjkwNw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400516907", "bodyText": "do you think we need to check for empty as well?", "author": "nsivabalan", "createdAt": "2020-03-30T21:52:51Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4ODEzMg==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r408088132", "bodyText": "valid point. Added the check.", "author": "pratyakshsharma", "createdAt": "2020-04-14T12:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNjkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxOTE0OQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400519149", "bodyText": "Do you think adding a field called \"KeyGeneratorType\" in KeyGenerator would make sense. Looking to avoid typos with these string vals. So that we can use getKeyGenerateType()", "author": "nsivabalan", "createdAt": "2020-03-30T21:57:39Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (fieldWithType[1]) {\n+        case \"simple\":", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODExOTc0Mg==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r408119742", "bodyText": "Done.", "author": "pratyakshsharma", "createdAt": "2020-04-14T13:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxOTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMDY0NQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400520645", "bodyText": "ah, you have defined an enum. May I know why using strings back there ?", "author": "nsivabalan", "createdAt": "2020-03-30T22:00:50Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);\n+\n+  public abstract String getRecordKey(GenericRecord record);\n+\n+  public enum PartitionKeyType {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODExOTkwNQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r408119905", "bodyText": "added a function to use it now.", "author": "pratyakshsharma", "createdAt": "2020-04-14T13:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMDY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTc0Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400521746", "bodyText": "Do you think we can add tests for these cases as well?", "author": "nsivabalan", "createdAt": "2020-03-30T22:03:27Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (fieldWithType[1]) {\n+        case \"simple\":\n+          keyGenerator = new SimpleKeyGenerator(properties);\n+          break;\n+        case \"timestampBased\":\n+          keyGenerator = new TimestampBasedKeyGenerator(properties);\n+          break;\n+        case \"noPartition\":\n+          keyGenerator = new NonpartitionedKeyGenerator(properties);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIxMzIzNQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r408213235", "bodyText": "added.", "author": "pratyakshsharma", "createdAt": "2020-04-14T15:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTg5MA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400521890", "bodyText": "same here. In general, lets try to see if we can add tests for all happy and exception paths if doable.", "author": "nsivabalan", "createdAt": "2020-03-30T22:03:48Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (fieldWithType[1]) {\n+        case \"simple\":\n+          keyGenerator = new SimpleKeyGenerator(properties);\n+          break;\n+        case \"timestampBased\":\n+          keyGenerator = new TimestampBasedKeyGenerator(properties);\n+          break;\n+        case \"noPartition\":\n+          keyGenerator = new NonpartitionedKeyGenerator(properties);\n+          nonPartitionedTable = true;\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIxMzA4Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r408213086", "bodyText": "added.", "author": "pratyakshsharma", "createdAt": "2020-04-14T15:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTk5NA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400521994", "bodyText": "Can we have test covering this line?", "author": "nsivabalan", "createdAt": "2020-03-30T22:04:04Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4OTE5Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r408089196", "bodyText": "Yes will be adding test cases for every possible happy flow and exceptions. This initial PR was just to see if the implementation looks good. Will update once I write all the test cases :)", "author": "pratyakshsharma", "createdAt": "2020-04-14T12:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIxMjkyNA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r408212924", "bodyText": "Added.", "author": "pratyakshsharma", "createdAt": "2020-04-14T15:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NDkzMQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r411494931", "bodyText": "please name enum elements like constants.. all caps", "author": "vinothchandar", "createdAt": "2020-04-20T15:57:17Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);\n+\n+  public abstract String getRecordKey(GenericRecord record);\n+\n+  public enum PartitionKeyType {\n+    simple(\"simple\"), complex(\"complex\"), timestampBased(\"timestampBased\"), noPartition(\"noPartition\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQzODU2Nw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414438567", "bodyText": "Done.", "author": "pratyakshsharma", "createdAt": "2020-04-24T09:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NDkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NTQ0NA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r411495444", "bodyText": "this is not needed right? we can just use ordinal/name from the name itself?", "author": "vinothchandar", "createdAt": "2020-04-20T15:57:59Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);\n+\n+  public abstract String getRecordKey(GenericRecord record);\n+\n+  public enum PartitionKeyType {\n+    simple(\"simple\"), complex(\"complex\"), timestampBased(\"timestampBased\"), noPartition(\"noPartition\");\n+\n+    private String type;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQzODQ0Mw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414438443", "bodyText": "Makes sense. Removed now.", "author": "pratyakshsharma", "createdAt": "2020-04-24T09:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjM5Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r411496396", "bodyText": "javadocs for these abstract methods?\nAlso I am not sure if it makes sense to add these component methods here.. We already have a top level one getKey()", "author": "vinothchandar", "createdAt": "2020-04-20T15:59:10Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNjkyNw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414306927", "bodyText": "I understand you want to reuse the other key generators.. I suggest exposing the methods in those concrete classes without leaking it to the abstract class here.. This will otherwise break all custom key generator implementations out there..", "author": "vinothchandar", "createdAt": "2020-04-24T05:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ0NDQ3Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414444476", "bodyText": "Yeah this thing was in my mind at the time of writing this piece of code. So there is a tradeoff here. If you do not want to expose these methods in abstract class, then I cannot initialise keyGenerator in a generic way in getPartitionPath() and getRecordKey() functions in CustomKeyGenerator class like I am doing right now and there will be a bit of redundant code in this class then. Hence I preferred to have it the way it is right now.\nAnyways let me refactor as you are saying, then we can discuss further.", "author": "pratyakshsharma", "createdAt": "2020-04-24T09:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDA4MQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414304081", "bodyText": "I assume this whol;e change is just restructuring code", "author": "vinothchandar", "createdAt": "2020-04-24T05:30:06Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -64,6 +62,32 @@ public HoodieKey getKey(GenericRecord record) {\n       throw new HoodieKeyException(\"Unable to find field names for record key or partition path in cfg\");\n     }\n \n+    String recordKey = getRecordKey(record);\n+    StringBuilder partitionPath = new StringBuilder();\n+    for (String partitionPathField : partitionPathFields) {\n+      partitionPath.append(getPartitionPath(record, partitionPathField));\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return new HoodieKey(recordKey, partitionPath.toString());\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String partitionPathField) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQzMjY4Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414432686", "bodyText": "Yes.", "author": "pratyakshsharma", "createdAt": "2020-04-24T09:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDc5MA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414304790", "bodyText": "all this needs to be documented for the user?", "author": "vinothchandar", "createdAt": "2020-04-24T05:31:58Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.noPartition;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.simple;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.timestampBased;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQzMzI5MQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414433291", "bodyText": "in our documentation you mean to say? Happy to do that @vinothchandar\nWill raise a follow up PR once this gets merged.", "author": "pratyakshsharma", "createdAt": "2020-04-24T09:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyMzQ1NQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416123455", "bodyText": "yes..\nis the CustomKeyGenerator compatible with the SimpleKeyGenerator configs? I am wondering if we can replace the default with this, without forcing user to do any additional work.. I think this is worth pursuing.. (We can then rename this DefaultKeyGenerator", "author": "vinothchandar", "createdAt": "2020-04-27T20:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4MzcwNA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r418483704", "bodyText": "No the configs are not compatible, since CustomKeyGenerator expects partitionPathFields to be provided in a particular format. :(\nBut since we are going with a major release next, I guess we can make this as the default? (My thinking here is users can expect a bit of breaking changes in major releases, anyways we will mention all the changes in the release notes). WDYT?", "author": "pratyakshsharma", "createdAt": "2020-05-01T09:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5NDkwNQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r418494905", "bodyText": "Also because this key generator pretty much covers all the possible cases for key generation.", "author": "pratyakshsharma", "createdAt": "2020-05-01T10:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNTQyMw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414305423", "bodyText": "let's turn this into an enum?", "author": "vinothchandar", "createdAt": "2020-04-24T05:33:44Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.noPartition;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.simple;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.timestampBased;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null || partitionPathFields.isEmpty()) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (getPartitionKeyType(fieldWithType[1])) {\n+        case simple:\n+          keyGenerator = new SimpleKeyGenerator(properties);\n+          break;\n+        case timestampBased:\n+          keyGenerator = new TimestampBasedKeyGenerator(properties);\n+          break;\n+        case noPartition:\n+          keyGenerator = new NonpartitionedKeyGenerator(properties);\n+          nonPartitionedTable = true;\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");\n+      }\n+\n+      if (nonPartitionedTable) {\n+        return \"\";\n+      }\n+      partitionPath.append(keyGenerator.getPartitionPath(record, partitionPathField));\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return partitionPath.toString();\n+  }\n+\n+  private PartitionKeyType getPartitionKeyType(String type) {\n+    switch (type) {\n+      case \"simple\":", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQzNzU1NQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414437555", "bodyText": "This function actually returns the enums as per the string passed as input by the user.", "author": "pratyakshsharma", "createdAt": "2020-04-24T09:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNTQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNjM5NQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414306395", "bodyText": "or can they leave the partitionPathFields as empty?  that seems more intuitive?", "author": "vinothchandar", "createdAt": "2020-04-24T05:36:37Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.noPartition;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.simple;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.timestampBased;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1Mzk5MA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414453990", "bodyText": "Wanted to have a uniform experience in terms of configuring keyGenerator type here. If you insist, I can change it. Please let me know @vinothchandar", "author": "pratyakshsharma", "createdAt": "2020-04-24T10:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNjM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNDQ3MA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416124470", "bodyText": "If you think, it will improve user experience we can do it. I mean not specifying partition field can default to noPartition and it wont be a surprising outcome for the user, right?", "author": "vinothchandar", "createdAt": "2020-04-27T20:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNjM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4NDEyMA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r418484120", "bodyText": "Ok, makes sense. Let me change it.", "author": "pratyakshsharma", "createdAt": "2020-05-01T09:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNjM5NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNTM3MQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416125371", "bodyText": "we can can skip the \"Based\" ? just timestamp ?", "author": "vinothchandar", "createdAt": "2020-04-27T20:28:10Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.NOPARTITION;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.SIMPLE;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.TIMESTAMP_BASED;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null || partitionPathFields.isEmpty()) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (getPartitionKeyType(fieldWithType[1])) {\n+        case SIMPLE:\n+          SimpleKeyGenerator simpleKeyGenerator = new SimpleKeyGenerator(properties);\n+          partitionPath.append(simpleKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case TIMESTAMP_BASED:\n+          TimestampBasedKeyGenerator timestampBasedKeyGenerator = new TimestampBasedKeyGenerator(properties);\n+          partitionPath.append(timestampBasedKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case NOPARTITION:\n+          NonpartitionedKeyGenerator nonpartitionedKeyGenerator = new NonpartitionedKeyGenerator(properties);\n+          partitionPath.append(nonpartitionedKeyGenerator.getPartitionPath(record, partitionPathField));\n+          nonPartitionedTable = true;\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");\n+      }\n+\n+      if (nonPartitionedTable) {\n+        return \"\";\n+      }\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return partitionPath.toString();\n+  }\n+\n+  private PartitionKeyType getPartitionKeyType(String type) {\n+    switch (type) {\n+      case \"simple\":\n+        return SIMPLE;\n+      case \"timestampBased\":", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4NzMwNw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r418487307", "bodyText": "Ok. Done.", "author": "pratyakshsharma", "createdAt": "2020-05-01T10:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNTM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNzU4Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416127586", "bodyText": "why do we need this method? would n't PartitionKeyType.valueOf(type.toUpper()) help?  I think its better if we keep the enum names mapping 1-1 to the strings they are constructed from.. thoughts?\nfield1:SIMPLE,field2:TIMESTAMP for e.g", "author": "vinothchandar", "createdAt": "2020-04-27T20:31:39Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.NOPARTITION;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.SIMPLE;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.TIMESTAMP_BASED;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null || partitionPathFields.isEmpty()) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (getPartitionKeyType(fieldWithType[1])) {\n+        case SIMPLE:\n+          SimpleKeyGenerator simpleKeyGenerator = new SimpleKeyGenerator(properties);\n+          partitionPath.append(simpleKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case TIMESTAMP_BASED:\n+          TimestampBasedKeyGenerator timestampBasedKeyGenerator = new TimestampBasedKeyGenerator(properties);\n+          partitionPath.append(timestampBasedKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case NOPARTITION:\n+          NonpartitionedKeyGenerator nonpartitionedKeyGenerator = new NonpartitionedKeyGenerator(properties);\n+          partitionPath.append(nonpartitionedKeyGenerator.getPartitionPath(record, partitionPathField));\n+          nonPartitionedTable = true;\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");\n+      }\n+\n+      if (nonPartitionedTable) {\n+        return \"\";\n+      }\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return partitionPath.toString();\n+  }\n+\n+  private PartitionKeyType getPartitionKeyType(String type) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4ODYxMw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r418488613", "bodyText": "Done.", "author": "pratyakshsharma", "createdAt": "2020-05-01T10:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNzU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDE0Mg==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416130142", "bodyText": "just one line new HoodieKey(getRecordKey(record), EMPTY....) ?", "author": "vinothchandar", "createdAt": "2020-04-27T20:36:12Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/GlobalDeleteKeyGenerator.java", "diffHunk": "@@ -52,6 +52,11 @@ public HoodieKey getKey(GenericRecord record) {\n       throw new HoodieKeyException(\"Unable to find field names for record key or partition path in cfg\");\n     }\n \n+    String recordKey = getRecordKey(record);\n+    return new HoodieKey(recordKey, EMPTY_PARTITION);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4ODc4NA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r418488784", "bodyText": "Done.", "author": "pratyakshsharma", "createdAt": "2020-05-01T10:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTk1MA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416131950", "bodyText": "ok.. this is just overriding from SimpleKeyGenerator . ack", "author": "vinothchandar", "createdAt": "2020-04-27T20:39:19Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/TimestampBasedKeyGenerator.java", "diffHunk": "@@ -88,6 +86,13 @@ public TimestampBasedKeyGenerator(TypedProperties config) {\n \n   @Override\n   public HoodieKey getKey(GenericRecord record) {\n+    String recordKey = getRecordKey(record);\n+    String partitionPath = getPartitionPath(record, partitionPathField);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String partitionPathField) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4ODgyNw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r418488827", "bodyText": "Yeah.", "author": "pratyakshsharma", "createdAt": "2020-05-01T10:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTk1MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NDMzOQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425544339", "bodyText": "does this needs to be public? why not protected or package private?", "author": "nsivabalan", "createdAt": "2020-05-15T03:21:03Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -49,21 +50,44 @@\n \n   public ComplexKeyGenerator(TypedProperties props) {\n     super(props);\n-    this.recordKeyFields = Arrays.asList(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\"))\n-            .stream().map(String::trim).collect(Collectors.toList());\n-    this.partitionPathFields =\n-        Arrays.asList(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\"))\n-                .stream().map(String::trim).collect(Collectors.toList());\n+    DataSourceUtils.checkRequiredProperties(props, Arrays.asList(\n+        DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(),\n+        DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY())\n+    );\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\"))\n+        .map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields = Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\"))\n+        .map(String::trim).collect(Collectors.toList());\n     this.hiveStylePartitioning = props.getBoolean(DataSourceWriteOptions.HIVE_STYLE_PARTITIONING_OPT_KEY(),\n         Boolean.parseBoolean(DataSourceWriteOptions.DEFAULT_HIVE_STYLE_PARTITIONING_OPT_VAL()));\n   }\n \n   @Override\n   public HoodieKey getKey(GenericRecord record) {\n-    if (recordKeyFields == null || partitionPathFields == null) {\n-      throw new HoodieKeyException(\"Unable to find field names for record key or partition path in cfg\");\n+    String recordKey = getRecordKey(record);\n+    StringBuilder partitionPath = new StringBuilder();\n+    for (String partitionPathField : partitionPathFields) {\n+      partitionPath.append(getPartitionPath(record, partitionPathField));\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return new HoodieKey(recordKey, partitionPath.toString());\n+  }\n+\n+  public String getPartitionPath(GenericRecord record, String partitionPathField) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MTIwNA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426191204", "bodyText": "Good catch. Made it package private.", "author": "pratyakshsharma", "createdAt": "2020-05-16T21:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NDMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NTcwOA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425545708", "bodyText": "minor typo. \"customize\"", "author": "nsivabalan", "createdAt": "2020-05-15T03:27:15Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4OTE4OQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426189189", "bodyText": "Done.", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NTcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NzIzNw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425547237", "bodyText": "same here. does this need to be public?", "author": "nsivabalan", "createdAt": "2020-05-15T03:33:13Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/SimpleKeyGenerator.java", "diffHunk": "@@ -66,6 +68,14 @@ public HoodieKey getKey(GenericRecord record) {\n       partitionPath = partitionPathField + \"=\" + partitionPath;\n     }\n \n-    return new HoodieKey(recordKey, partitionPath);\n+    return partitionPath;\n+  }\n+\n+  public String getRecordKey(GenericRecord record) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MTIzNA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426191234", "bodyText": "Modified to package-private.", "author": "pratyakshsharma", "createdAt": "2020-05-16T21:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NzIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NzcxOQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425547719", "bodyText": "did you think if we need to make this an abstract method in KeyGenerator?", "author": "nsivabalan", "createdAt": "2020-05-15T03:35:15Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/SimpleKeyGenerator.java", "diffHunk": "@@ -66,6 +68,14 @@ public HoodieKey getKey(GenericRecord record) {\n       partitionPath = partitionPathField + \"=\" + partitionPath;\n     }\n \n-    return new HoodieKey(recordKey, partitionPath);\n+    return partitionPath;\n+  }\n+\n+  public String getRecordKey(GenericRecord record) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4OTY5NA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426189694", "bodyText": "Yeah this has been discussed already. Please refer to this - #1433 (comment)", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NzcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM1MA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425548350", "bodyText": "a naive question. May I know why some key generators of them are extending from SimpleKeyGenerator and some are extending KeyGenerators. Even those extending from SimpleKeyGen, I don't see any obvious need to extend from SimpleKeyGenerator. Can you throw some light.", "author": "nsivabalan", "createdAt": "2020-05-15T03:38:16Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/TimestampBasedKeyGenerator.java", "diffHunk": "@@ -88,6 +86,13 @@ public TimestampBasedKeyGenerator(TypedProperties config) {\n \n   @Override\n   public HoodieKey getKey(GenericRecord record) {\n+    String recordKey = getRecordKey(record);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4OTkyMQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426189921", "bodyText": "This is done only to reuse the variables defined in SimpleKeyGenerator class, for example hiveStylePartitioning, recordKeyField etc.", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMzkwNA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426313904", "bodyText": "Usually its a good practice to use for logical reasons and not just for variables. If you think TimestampBasedKeyGenerator is an extension to Simple, it is fine. But will let you take a call. Just my 2 cents.", "author": "nsivabalan", "createdAt": "2020-05-17T22:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNTMzNQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426715335", "bodyText": "@nsivabalan actually TimestampBasedKeyGenerator extending SimpleKeyGenerator has been there historically. I agree with your point, if you wish, I can refactor the code.\nLet me actually go ahead and do it.", "author": "pratyakshsharma", "createdAt": "2020-05-18T15:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczNTExMA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426735110", "bodyText": "My bad. TimestampBasedKeyGenerator is reusing function getRecordKey() from SimpleKeyGenerator. So I guess we will keep it this way only.", "author": "pratyakshsharma", "createdAt": "2020-05-18T16:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODU1MQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425548551", "bodyText": "why all these methods are public ?", "author": "nsivabalan", "createdAt": "2020-05-15T03:39:19Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MDE4Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426190186", "bodyText": "Made them private.", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODkyOQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425548929", "bodyText": "sorry, if size = 1, how is it a no partition case ?", "author": "nsivabalan", "createdAt": "2020-05-15T03:41:10Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (partitionPathFields.size() == 1 && partitionPathFields.get(0).isEmpty()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MDcyOQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426190729", "bodyText": "So the idea behind this was if user wants to not have any partitions, he can simply leave partitionPathFields as blank. If he leaves the property value blank, that corresponds to a list with one element and that element is empty string. You can find more context here - #1433 (comment)", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMzE4Ng==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426313186", "bodyText": "I get it, but have a follow up question and a comment.\n\nI am not sure why would someone set empty string. if users wants to not have any partitions, might as well not set it only ? Anyways, guess you discussed w/ vinoth on that. Will let you folks decide on whats better.\nAssuming, user might set it to empty, in line 69 where we generate  partitionPathFields, we trim for empty strings isn't? So, the list should be empty in that case in my understanding. correct me if I am wrong.", "author": "nsivabalan", "createdAt": "2020-05-17T22:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNDU5Mw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426724593", "bodyText": "if users wants to not have any partitions, might as well not set it only\n\nActually in the constructor of CustomKeyGenerator, partitionPathFields get initialised through a call to props.getString() which internally checks if key exists. So user will have to include this key always. I am ok with both ways, so chose to follow what Vinoth suggested.\n\nSo, the list should be empty in that case in my understanding. correct me if I am wrong\n\nNo the list actually contains one element always which is an empty string. I have verified this. :)", "author": "pratyakshsharma", "createdAt": "2020-05-18T15:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1MzUwMw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428953503", "bodyText": "ok, my bad. Just checked the trim docs, it will just trim leading and trailing whitespaces if any.", "author": "nsivabalan", "createdAt": "2020-05-21T22:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTIyMw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425549223", "bodyText": "can we do it in one line.\npartitionPath.append(new SimpleKeyGenerator(properties).getPartitionPath(record, partitionPathField));", "author": "nsivabalan", "createdAt": "2020-05-15T03:42:27Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (partitionPathFields.size() == 1 && partitionPathFields.get(0).isEmpty()) {\n+      return \"\";\n+    }\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n+      switch (keyType) {\n+        case SIMPLE:\n+          SimpleKeyGenerator simpleKeyGenerator = new SimpleKeyGenerator(properties);\n+          partitionPath.append(simpleKeyGenerator.getPartitionPath(record, partitionPathField));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MDc5NA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426190794", "bodyText": "Done.", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTI5NQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425549295", "bodyText": "same here. can we do it in one line.", "author": "nsivabalan", "createdAt": "2020-05-15T03:42:40Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (partitionPathFields.size() == 1 && partitionPathFields.get(0).isEmpty()) {\n+      return \"\";\n+    }\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n+      switch (keyType) {\n+        case SIMPLE:\n+          SimpleKeyGenerator simpleKeyGenerator = new SimpleKeyGenerator(properties);\n+          partitionPath.append(simpleKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case TIMESTAMP:\n+          TimestampBasedKeyGenerator timestampBasedKeyGenerator = new TimestampBasedKeyGenerator(properties);\n+          partitionPath.append(timestampBasedKeyGenerator.getPartitionPath(record, partitionPathField));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MDgwNg==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426190806", "bodyText": "Done", "author": "pratyakshsharma", "createdAt": "2020-05-16T20:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMzI0OQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426313249", "bodyText": "do you think adding the invalid key type here would help ?", "author": "nsivabalan", "createdAt": "2020-05-17T22:43:56Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customize some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  private String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (partitionPathFields.size() == 1 && partitionPathFields.get(0).isEmpty()) {\n+      return \"\";\n+    }\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n+      switch (keyType) {\n+        case SIMPLE:\n+          partitionPath.append(new SimpleKeyGenerator(properties).getPartitionPath(record, partitionPathField));\n+          break;\n+        case TIMESTAMP:\n+          partitionPath.append(new TimestampBasedKeyGenerator(properties).getPartitionPath(record, partitionPathField));\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMDkxMg==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426730912", "bodyText": "makes sense. Will do that.", "author": "pratyakshsharma", "createdAt": "2020-05-18T15:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMzI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDMwMA==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954300", "bodyText": "need a new line", "author": "nsivabalan", "createdAt": "2020-05-21T22:43:01Z", "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/TimestampBasedKeyGenerator.java", "diffHunk": "@@ -154,4 +153,4 @@ private long convertLongTimeToMillis(Long partitionVal) {\n \n     return MILLISECONDS.convert(partitionVal, timeUnit);\n   }\n-}\n+}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDM3MQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954371", "bodyText": "same here", "author": "nsivabalan", "createdAt": "2020-05-21T22:43:16Z", "path": "hudi-spark/src/test/java/org/apache/hudi/keygen/TestComplexKeyGenerator.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class TestComplexKeyGenerator extends TestKeyGeneratorUtilities {\n+\n+  private TypedProperties getCommonProps(boolean getComplexRecordKey) {\n+    TypedProperties properties = new TypedProperties();\n+    if (getComplexRecordKey) {\n+      properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key, pii_col\");\n+    } else {\n+      properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key\");\n+    }\n+    properties.put(DataSourceWriteOptions.HIVE_STYLE_PARTITIONING_OPT_KEY(), \"true\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropertiesWithoutPartitionPathProp() {\n+    return getCommonProps(false);\n+  }\n+\n+  private TypedProperties getPropertiesWithoutRecordKeyProp() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getWrongRecordKeyFieldProps() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_wrong_key\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getProps() {\n+    TypedProperties properties = getCommonProps(true);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp,ts_ms\");\n+    return properties;\n+  }\n+\n+  @Test\n+  public void testNullPartitionPathFields() {\n+    Assertions.assertThrows(IllegalArgumentException.class, () -> new ComplexKeyGenerator(getPropertiesWithoutPartitionPathProp()));\n+  }\n+\n+  @Test\n+  public void testNullRecordKeyFields() {\n+    Assertions.assertThrows(IllegalArgumentException.class, () -> new ComplexKeyGenerator(getPropertiesWithoutRecordKeyProp()));\n+  }\n+\n+  @Test\n+  public void testWrongRecordKeyField() {\n+    ComplexKeyGenerator keyGenerator = new ComplexKeyGenerator(getWrongRecordKeyFieldProps());\n+    Assertions.assertThrows(HoodieKeyException.class, () -> keyGenerator.getRecordKey(getRecord()));\n+  }\n+\n+  @Test\n+  public void testHappyFlow() {\n+    ComplexKeyGenerator keyGenerator = new ComplexKeyGenerator(getProps());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"_row_key:key1,pii_col:pi\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686/ts_ms=2020-03-21\");\n+  }\n+}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDQxNw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954417", "bodyText": "same here", "author": "nsivabalan", "createdAt": "2020-05-21T22:43:25Z", "path": "hudi-spark/src/test/java/org/apache/hudi/keygen/TestCustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class TestCustomKeyGenerator extends TestKeyGeneratorUtilities {\n+\n+  private TypedProperties getCommonProps(boolean getComplexRecordKey) {\n+    TypedProperties properties = new TypedProperties();\n+    if (getComplexRecordKey) {\n+      properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key, pii_col\");\n+    } else {\n+      properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key\");\n+    }\n+    properties.put(DataSourceWriteOptions.HIVE_STYLE_PARTITIONING_OPT_KEY(), \"true\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropertiesForSimpleKeyGen() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:simple\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getImproperPartitionFieldFormatProp() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getInvalidPartitionKeyTypeProps() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:dummy\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getComplexRecordKeyWithSimplePartitionProps() {\n+    TypedProperties properties = getCommonProps(true);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:simple\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getComplexRecordKeyAndPartitionPathProps() {\n+    TypedProperties properties = getCommonProps(true);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:simple,ts_ms:timestamp\");\n+    populateNecessaryPropsForTimestampBasedKeyGen(properties);\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropsWithoutRecordKeyFieldProps() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:simple\");\n+    return properties;\n+  }\n+\n+  private void populateNecessaryPropsForTimestampBasedKeyGen(TypedProperties properties) {\n+    properties.put(\"hoodie.deltastreamer.keygen.timebased.timestamp.type\", \"DATE_STRING\");\n+    properties.put(\"hoodie.deltastreamer.keygen.timebased.input.dateformat\", \"yyyy-MM-dd\");\n+    properties.put(\"hoodie.deltastreamer.keygen.timebased.output.dateformat\", \"yyyyMMdd\");\n+  }\n+\n+  private TypedProperties getPropertiesForTimestampBasedKeyGen() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"ts_ms:timestamp\");\n+    populateNecessaryPropsForTimestampBasedKeyGen(properties);\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropertiesForNonPartitionedKeyGen() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"\");\n+    return properties;\n+  }\n+\n+  @Test\n+  public void testSimpleKeyGenerator() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getPropertiesForSimpleKeyGen());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"key1\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686\");\n+  }\n+\n+  @Test\n+  public void testTimestampBasedKeyGenerator() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getPropertiesForTimestampBasedKeyGen());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"key1\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"ts_ms=20200321\");\n+  }\n+\n+  @Test\n+  public void testNonPartitionedKeyGenerator() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getPropertiesForNonPartitionedKeyGen());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"key1\");\n+    Assertions.assertTrue(key.getPartitionPath().isEmpty());\n+  }\n+\n+  @Test\n+  public void testInvalidPartitionKeyType() {\n+    try {\n+      KeyGenerator keyGenerator = new CustomKeyGenerator(getInvalidPartitionKeyTypeProps());\n+      keyGenerator.getKey(getRecord());\n+      Assertions.fail(\"should fail when invalid PartitionKeyType is provided!\");\n+    } catch (Exception e) {\n+      Assertions.assertTrue(e.getMessage().contains(\"No enum constant org.apache.hudi.keygen.CustomKeyGenerator.PartitionKeyType.DUMMY\"));\n+    }\n+  }\n+\n+  @Test\n+  public void testNoRecordKeyFieldProp() {\n+    try {\n+      KeyGenerator keyGenerator = new CustomKeyGenerator(getPropsWithoutRecordKeyFieldProps());\n+      keyGenerator.getKey(getRecord());\n+      Assertions.fail(\"should fail when record key field is not provided!\");\n+    } catch (Exception e) {\n+      Assertions.assertTrue(e.getMessage().contains(\"Property hoodie.datasource.write.recordkey.field not found\"));\n+    }\n+  }\n+\n+  @Test\n+  public void testPartitionFieldsInImproperFormat() {\n+    try {\n+      KeyGenerator keyGenerator = new CustomKeyGenerator(getImproperPartitionFieldFormatProp());\n+      keyGenerator.getKey(getRecord());\n+      Assertions.fail(\"should fail when partition key field is provided in improper format!\");\n+    } catch (Exception e) {\n+      Assertions.assertTrue(e.getMessage().contains(\"Unable to find field names for partition path in proper format\"));\n+    }\n+  }\n+\n+  @Test\n+  public void testComplexRecordKeyWithSimplePartitionPath() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getComplexRecordKeyWithSimplePartitionProps());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"_row_key:key1,pii_col:pi\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686\");\n+  }\n+\n+  @Test\n+  public void testComplexRecordKeysWithComplexPartitionPath() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getComplexRecordKeyAndPartitionPathProps());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"_row_key:key1,pii_col:pi\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686/ts_ms=20200321\");\n+  }\n+}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDQ5OQ==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954499", "bodyText": "here as well", "author": "nsivabalan", "createdAt": "2020-05-21T22:43:42Z", "path": "hudi-spark/src/test/java/org/apache/hudi/keygen/TestSimpleKeyGenerator.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class TestSimpleKeyGenerator extends TestKeyGeneratorUtilities {\n+\n+  private TypedProperties getCommonProps() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key\");\n+    properties.put(DataSourceWriteOptions.HIVE_STYLE_PARTITIONING_OPT_KEY(), \"true\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropertiesWithoutPartitionPathProp() {\n+    return getCommonProps();\n+  }\n+\n+  private TypedProperties getPropertiesWithoutRecordKeyProp() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getWrongRecordKeyFieldProps() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_wrong_key\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getComplexRecordKeyProp() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key,pii_col\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getProps() {\n+    TypedProperties properties = getCommonProps();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    return properties;\n+  }\n+\n+  @Test\n+  public void testNullPartitionPathFields() {\n+    Assertions.assertThrows(IllegalArgumentException.class, () -> new SimpleKeyGenerator(getPropertiesWithoutPartitionPathProp()));\n+  }\n+\n+  @Test\n+  public void testNullRecordKeyFields() {\n+    Assertions.assertThrows(IllegalArgumentException.class, () -> new SimpleKeyGenerator(getPropertiesWithoutRecordKeyProp()));\n+  }\n+\n+  @Test\n+  public void testWrongRecordKeyField() {\n+    SimpleKeyGenerator keyGenerator = new SimpleKeyGenerator(getWrongRecordKeyFieldProps());\n+    Assertions.assertThrows(HoodieKeyException.class, () -> keyGenerator.getRecordKey(getRecord()));\n+  }\n+\n+  @Test\n+  public void testComplexRecordKeyField() {\n+    SimpleKeyGenerator keyGenerator = new SimpleKeyGenerator(getComplexRecordKeyProp());\n+    Assertions.assertThrows(HoodieKeyException.class, () -> keyGenerator.getRecordKey(getRecord()));\n+  }\n+\n+  @Test\n+  public void testHappyFlow() {\n+    SimpleKeyGenerator keyGenerator = new SimpleKeyGenerator(getProps());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"key1\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686\");\n+  }\n+}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDU0Mw==", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954543", "bodyText": "sam here.", "author": "nsivabalan", "createdAt": "2020-05-21T22:43:50Z", "path": "hudi-spark/src/test/java/org/apache/hudi/keygen/TestTimestampBasedKeyGenerator.java", "diffHunk": "@@ -95,4 +95,4 @@ public void testScalar() {\n     HoodieKey hk5 = new TimestampBasedKeyGenerator(properties).getKey(baseRecord);\n     assertEquals(hk5.getPartitionPath(), \"2024-10-04 12\");\n   }\n-}\n+}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "f3094f6ca1dd43f263f9005291861321fb58b24a", "url": "https://github.com/apache/hudi/commit/f3094f6ca1dd43f263f9005291861321fb58b24a", "message": "[HUDI-728]: implemented custom key generator", "committedDate": "2020-07-01T11:35:50Z", "type": "commit"}, {"oid": "f3094f6ca1dd43f263f9005291861321fb58b24a", "url": "https://github.com/apache/hudi/commit/f3094f6ca1dd43f263f9005291861321fb58b24a", "message": "[HUDI-728]: implemented custom key generator", "committedDate": "2020-07-01T11:35:50Z", "type": "forcePushed"}]}