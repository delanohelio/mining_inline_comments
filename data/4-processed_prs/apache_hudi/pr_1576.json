{"pr_number": 1576, "pr_title": "[HUDI-850] Avoid unnecessary listings in incremental cleaning mode", "pr_createdAt": "2020-04-30T08:47:29Z", "pr_url": "https://github.com/apache/hudi/pull/1576", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4OTE1MA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418089150", "bodyText": "Collections.emptyList()?", "author": "vinothchandar", "createdAt": "2020-04-30T15:18:18Z", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return new ArrayList<>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTQ3Nw==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199477", "bodyText": "Done", "author": "bvaradar", "createdAt": "2020-04-30T18:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4OTE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDExOA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418090118", "bodyText": "can we break this method up into two, based on the policy? it feels very overloaded now..", "author": "vinothchandar", "createdAt": "2020-04-30T15:19:44Z", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTQ1OA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199458", "bodyText": "Done", "author": "bvaradar", "createdAt": "2020-04-30T18:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDQxMQ==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418090411", "bodyText": "do we have enough tests that now test when a valid cleaner plan?", "author": "vinothchandar", "createdAt": "2020-04-30T15:20:08Z", "path": "hudi-client/src/test/java/org/apache/hudi/table/TestCleaner.java", "diffHunk": "@@ -128,10 +128,8 @@ private void insertFirstBigBatchForClientCleanerTest(HoodieWriteConfig cfg, Hood\n \n     assertFalse(table.getCompletedCommitsTimeline().empty());\n     String instantTime = table.getCompletedCommitsTimeline().getInstants().findFirst().get().getTimestamp();\n+    // We no longer write empty cleaner plans when there are not enough commits present", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTM1NA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199354", "bodyText": "Yes, this particular check is when inserting first batch of data. There are other checks present which validates the effect of valid clean operations", "author": "bvaradar", "createdAt": "2020-04-30T18:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDQxMQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjM1Mw==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418632353", "bodyText": "move to separate lines?", "author": "vinothchandar", "createdAt": "2020-05-01T16:58:10Z", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTcyMA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418875720", "bodyText": "done", "author": "bvaradar", "createdAt": "2020-05-02T04:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjc0Ng==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418632746", "bodyText": "we don't need the second check anymore , due to the switch above?", "author": "vinothchandar", "createdAt": "2020-05-01T16:59:01Z", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTU2MA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418875560", "bodyText": "Fixed", "author": "bvaradar", "createdAt": "2020-05-02T04:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNDcxOA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418634718", "bodyText": "rename: getPartitionPathsForIncrementalCleaning() ?", "author": "vinothchandar", "createdAt": "2020-05-01T17:03:16Z", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return Collections.emptyList();\n+    }\n+\n+    if (config.incrementalCleanerModeEnabled()) {\n+      Option<HoodieInstant> lastClean = hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n       if (lastClean.isPresent()) {\n         HoodieCleanMetadata cleanMetadata = TimelineMetadataUtils\n             .deserializeHoodieCleanMetadata(hoodieTable.getActiveTimeline().getInstantDetails(lastClean.get()).get());\n         if ((cleanMetadata.getEarliestCommitToRetain() != null)\n             && (cleanMetadata.getEarliestCommitToRetain().length() > 0)) {\n-          LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n-              + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n-              + \". New Instant to retain : \" + newInstantToRetain);\n-          return hoodieTable.getCompletedCommitsTimeline().getInstants()\n-              .filter(instant ->\n-                  HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS, cleanMetadata.getEarliestCommitToRetain())\n-                  && HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())\n-              ).flatMap(instant -> {\n-                try {\n-                  HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(), HoodieCommitMetadata.class);\n-                  return commitMetadata.getPartitionToWriteStats().keySet().stream();\n-                } catch (IOException e) {\n-                  throw new HoodieIOException(e.getMessage(), e);\n-                }\n-              }).distinct().collect(Collectors.toList());\n+          return getPartitionPathsForCleaningUsingIncrementalMode(cleanMetadata, instantToRetain);\n         }\n       }\n     }\n-    // Otherwise go to brute force mode of scanning all partitions\n-    return FSUtils.getAllPartitionPaths(hoodieTable.getMetaClient().getFs(),\n-        hoodieTable.getMetaClient().getBasePath(), config.shouldAssumeDatePartitioning());\n+    return scanAllPartitionsForCleaning();\n+  }\n+\n+  /**\n+   * Use Incremental Mode for finding partition paths.\n+   * @param cleanMetadata\n+   * @param newInstantToRetain\n+   * @return\n+   */\n+  private List<String> getPartitionPathsForCleaningUsingIncrementalMode(HoodieCleanMetadata cleanMetadata,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTY3NA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418875674", "bodyText": "done", "author": "bvaradar", "createdAt": "2020-05-02T04:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNDcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNTE2MA==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418635160", "bodyText": "rename: getPartitionPathsForFullCleaning()", "author": "vinothchandar", "createdAt": "2020-05-01T17:04:11Z", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return Collections.emptyList();\n+    }\n+\n+    if (config.incrementalCleanerModeEnabled()) {\n+      Option<HoodieInstant> lastClean = hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n       if (lastClean.isPresent()) {\n         HoodieCleanMetadata cleanMetadata = TimelineMetadataUtils\n             .deserializeHoodieCleanMetadata(hoodieTable.getActiveTimeline().getInstantDetails(lastClean.get()).get());\n         if ((cleanMetadata.getEarliestCommitToRetain() != null)\n             && (cleanMetadata.getEarliestCommitToRetain().length() > 0)) {\n-          LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n-              + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n-              + \". New Instant to retain : \" + newInstantToRetain);\n-          return hoodieTable.getCompletedCommitsTimeline().getInstants()\n-              .filter(instant ->\n-                  HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS, cleanMetadata.getEarliestCommitToRetain())\n-                  && HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())\n-              ).flatMap(instant -> {\n-                try {\n-                  HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(), HoodieCommitMetadata.class);\n-                  return commitMetadata.getPartitionToWriteStats().keySet().stream();\n-                } catch (IOException e) {\n-                  throw new HoodieIOException(e.getMessage(), e);\n-                }\n-              }).distinct().collect(Collectors.toList());\n+          return getPartitionPathsForCleaningUsingIncrementalMode(cleanMetadata, instantToRetain);\n         }\n       }\n     }\n-    // Otherwise go to brute force mode of scanning all partitions\n-    return FSUtils.getAllPartitionPaths(hoodieTable.getMetaClient().getFs(),\n-        hoodieTable.getMetaClient().getBasePath(), config.shouldAssumeDatePartitioning());\n+    return scanAllPartitionsForCleaning();\n+  }\n+\n+  /**\n+   * Use Incremental Mode for finding partition paths.\n+   * @param cleanMetadata\n+   * @param newInstantToRetain\n+   * @return\n+   */\n+  private List<String> getPartitionPathsForCleaningUsingIncrementalMode(HoodieCleanMetadata cleanMetadata,\n+      Option<HoodieInstant> newInstantToRetain) {\n+    LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n+        + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n+        + \". New Instant to retain : \" + newInstantToRetain);\n+    return hoodieTable.getCompletedCommitsTimeline().getInstants().filter(\n+        instant -> HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS,\n+            cleanMetadata.getEarliestCommitToRetain()) && HoodieTimeline.compareTimestamps(instant.getTimestamp(),\n+            HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())).flatMap(instant -> {\n+              try {\n+                HoodieCommitMetadata commitMetadata = HoodieCommitMetadata\n+                    .fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(),\n+                        HoodieCommitMetadata.class);\n+                return commitMetadata.getPartitionToWriteStats().keySet().stream();\n+              } catch (IOException e) {\n+                throw new HoodieIOException(e.getMessage(), e);\n+              }\n+            }).distinct().collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Scan and list all paritions for cleaning.\n+   * @return all partitions paths for the dataset.\n+   * @throws IOException\n+   */\n+  private List<String> scanAllPartitionsForCleaning() throws IOException {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTYxMw==", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418875613", "bodyText": "Done", "author": "bvaradar", "createdAt": "2020-05-02T04:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNTE2MA=="}], "type": "inlineReview"}, {"oid": "641532c28daa1ba530550b6b0588cd71d7fa7b90", "url": "https://github.com/apache/hudi/commit/641532c28daa1ba530550b6b0588cd71d7fa7b90", "message": "[HUDI-850] Avoid unnecessary listings in incremental cleaning mode", "committedDate": "2020-05-02T04:00:46Z", "type": "commit"}, {"oid": "641532c28daa1ba530550b6b0588cd71d7fa7b90", "url": "https://github.com/apache/hudi/commit/641532c28daa1ba530550b6b0588cd71d7fa7b90", "message": "[HUDI-850] Avoid unnecessary listings in incremental cleaning mode", "committedDate": "2020-05-02T04:00:46Z", "type": "forcePushed"}]}