{"pr_number": 32, "pr_title": "ObfuscationReflectionHelper", "pr_createdAt": "2020-01-20T21:38:03Z", "pr_url": "https://github.com/PatchworkMC/patchwork-api/pull/32", "timeline": [{"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "url": "https://github.com/PatchworkMC/patchwork-api/commit/580dd0834452a87fefe4a20c5ac5e33a5986e605", "message": "ObfuscationReflectionHelper", "committedDate": "2020-01-20T21:37:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDU5MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368740590", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            **/\n          \n          \n            \n             */", "author": "coderbot16", "createdAt": "2020-01-20T22:07:05Z", "path": "patchwork-fml/src/main/java/cpw/mods/modlauncher/api/INameMappingService.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package cpw.mods.modlauncher.api;\n+\n+/**\n+ * Only serves to expose the Domain enum.\n+**/", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDc4NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368740784", "bodyText": "Could this cause issues if Fabric is launched using ModLauncher? I would assume the true class would get loaded in that case, however.", "author": "coderbot16", "createdAt": "2020-01-20T22:07:54Z", "path": "patchwork-fml/src/main/java/cpw/mods/modlauncher/api/INameMappingService.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package cpw.mods.modlauncher.api;", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1MDIxOA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r370250218", "bodyText": "Based on a bit of googling--as long as ModLauncher is loaded before Patchwork (which is true) it should just not load our stripped class.\nThe only way to know for absolutely sure is to test, but it should work fine theoretically.", "author": "TheGlitch76", "createdAt": "2020-01-23T17:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTM0NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741345", "bodyText": "Can't this be replaced with Objects.requireNonNull?", "author": "coderbot16", "createdAt": "2020-01-20T22:10:21Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1MTc2Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r370251766", "bodyText": "Technically, yes, but IMO it's better for consistency because methods that have no equivalent in Objects like Preconditions.checkArgument are used elsewhere in this class.", "author": "TheGlitch76", "createdAt": "2020-01-23T17:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTUwOA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741508", "bodyText": "This line seems a little long, maybe split it up? Maybe method instead of m too.", "author": "coderbot16", "createdAt": "2020-01-20T22:11:03Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tMethod m = clazz.getDeclaredMethod(PatchworkMappingResolver.remapName(INameMappingService.Domain.METHOD, clazz, methodName), parameterTypes);", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTU2OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741568", "bodyText": "Objects.requireNonNull again", "author": "coderbot16", "createdAt": "2020-01-20T22:11:20Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tMethod m = clazz.getDeclaredMethod(PatchworkMappingResolver.remapName(INameMappingService.Domain.METHOD, clazz, methodName), parameterTypes);\n+\t\t\tm.setAccessible(true);\n+\t\t\treturn m;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new UnableToFindMethodException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a constructor with the specified parameter types in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the constructor is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the constructor in.\n+\t * @param parameterTypes The parameter types of the constructor.\n+\t * @param <T>            The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnknownConstructorException If the constructor could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Constructor<T> findConstructor(@Nonnull final Class<T> clazz, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find constructor on cannot be null.\");", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2MDQzNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r370260435", "bodyText": "See above", "author": "TheGlitch76", "createdAt": "2020-01-23T17:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTgyNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741827", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * <p>Throws an exception if the constructor is not found.</p>\n          \n          \n            \n            \t * <p>Throws an exception if the constructor was not found.</p>", "author": "coderbot16", "createdAt": "2020-01-20T22:12:39Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tMethod m = clazz.getDeclaredMethod(PatchworkMappingResolver.remapName(INameMappingService.Domain.METHOD, clazz, methodName), parameterTypes);\n+\t\t\tm.setAccessible(true);\n+\t\t\treturn m;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new UnableToFindMethodException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a constructor with the specified parameter types in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the constructor is not found.</p>", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTkzNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741934", "bodyText": "This line seems a little long too; maybe field instead?", "author": "coderbot16", "createdAt": "2020-01-20T22:13:10Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tMethod m = clazz.getDeclaredMethod(PatchworkMappingResolver.remapName(INameMappingService.Domain.METHOD, clazz, methodName), parameterTypes);\n+\t\t\tm.setAccessible(true);\n+\t\t\treturn m;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new UnableToFindMethodException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a constructor with the specified parameter types in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the constructor is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the constructor in.\n+\t * @param parameterTypes The parameter types of the constructor.\n+\t * @param <T>            The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnknownConstructorException If the constructor could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Constructor<T> findConstructor(@Nonnull final Class<T> clazz, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find constructor on cannot be null.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of constructor to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tConstructor<T> constructor = clazz.getDeclaredConstructor(parameterTypes);\n+\t\t\tconstructor.setAccessible(true);\n+\t\t\treturn constructor;\n+\t\t} catch (final NoSuchMethodException e) {\n+\t\t\tfinal StringBuilder desc = new StringBuilder();\n+\t\t\tdesc.append(clazz.getSimpleName());\n+\n+\t\t\tStringJoiner joiner = new StringJoiner(\", \", \"(\", \")\");\n+\n+\t\t\tfor (Class<?> type : parameterTypes) {\n+\t\t\t\tjoiner.add(type.getSimpleName());\n+\t\t\t}\n+\n+\t\t\tdesc.append(joiner);\n+\n+\t\t\tthrow new UnknownConstructorException(\"Could not find constructor '\" + desc + \"' in \" + clazz);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a field with the specified name in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the field is not found.</p>\n+\t *\n+\t * @param clazz     The class to find the field on.\n+\t * @param fieldName The intermediary (unmapped) name of the field to find (e.g. \"field_1817\").\n+\t * @param <T>       The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException       If {@code clazz} is null.\n+\t * @throws NullPointerException       If {@code fieldName} is null.\n+\t * @throws IllegalArgumentException   If {@code fieldName} is empty.\n+\t * @throws UnableToFindFieldException If the field could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Field findField(@Nonnull final Class<? super T> clazz, @Nonnull final String fieldName) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find field on cannot be null.\");\n+\t\tPreconditions.checkNotNull(fieldName, \"Name of field to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!fieldName.isEmpty(), \"Name of field to find cannot be empty.\");\n+\n+\t\ttry {\n+\t\t\tField f = clazz.getDeclaredField(PatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, clazz, fieldName));", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MjQ0Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368742447", "bodyText": "Mixins? This comment isn't super relevant to Patchwork, since ATs don't exist at runtime (unless we're talking about FabricASM)", "author": "coderbot16", "createdAt": "2020-01-20T22:15:32Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MjU3MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368742571", "bodyText": "These warnings are scary, if they're only relevant for a few lines maybe move them to a more restricted scope?", "author": "coderbot16", "createdAt": "2020-01-20T22:16:10Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MjkwNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368742906", "bodyText": "Does this actually print the exception?", "author": "coderbot16", "createdAt": "2020-01-20T22:17:47Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2MDMzOQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r370260339", "bodyText": "Yeah, it will print the exception and its stacktrace on a new line. I tested it", "author": "TheGlitch76", "createdAt": "2020-01-23T17:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MzA4Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368743082", "bodyText": "descriptor?", "author": "coderbot16", "createdAt": "2020-01-20T22:18:38Z", "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapMethodName(NAMED, className, name, methodDescriptor);\n+\t\tcase FIELD:\n+\t\t\tString fieldDescriptor = null;\n+\n+\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapFieldName(INTERMEDIARY, className, field.getName(),\n+\t\t\t\t\t\tgetDescriptorForClass(field.getType(), false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tfieldDescriptor = getDescriptorForClass(field.getType(), true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapFieldName(NAMED, className, name, fieldDescriptor);\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Someone's been tampering with enums! Got unexpected type \" + domain.name());\n+\t\t}\n+\t}\n+\n+\t// this is a stackoverflow response but with remapping\n+\tprivate static String getDescriptorForClass(final Class<?> c, boolean remapToIntermediary) {\n+\t\tif (c.isPrimitive()) {\n+\t\t\t// This could technically be turned into a map lookup, but that seems like overengineering considering this will never change\n+\t\t\tif (c == byte.class) {\n+\t\t\t\treturn \"B\";\n+\t\t\t} else if (c == char.class) {\n+\t\t\t\treturn \"C\";\n+\t\t\t} else if (c == double.class) {\n+\t\t\t\treturn \"D\";\n+\t\t\t} else if (c == float.class) {\n+\t\t\t\treturn \"F\";\n+\t\t\t} else if (c == int.class) {\n+\t\t\t\treturn \"I\";\n+\t\t\t} else if (c == long.class) {\n+\t\t\t\treturn \"J\";\n+\t\t\t} else if (c == short.class) {\n+\t\t\t\treturn \"S\";\n+\t\t\t} else if (c == boolean.class) {\n+\t\t\t\treturn \"Z\";\n+\t\t\t} else if (c == void.class) {\n+\t\t\t\treturn \"V\";\n+\t\t\t} else {\n+\t\t\t\tthrow new RuntimeException(\"Unrecognized primitive \" + c);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tString className = c.getName();\n+\n+\t\t\tif (remapToIntermediary) {\n+\t\t\t\tclassName = FabricLoader.getInstance().getMappingResolver().mapClassName(INTERMEDIARY, className);\n+\t\t\t}\n+\n+\t\t\tif (c.isArray()) {\n+\t\t\t\treturn className.replace('.', '/');\n+\t\t\t} else {\n+\t\t\t\treturn ('L' + className + ';').replace('.', '/');\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static String getMethodDescriptor(Method m, boolean remapToIntermediary) {\n+\t\tStringBuilder sb = new StringBuilder();", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MzEwNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368743104", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate static String getMethodDescriptor(Method m, boolean remapToIntermediary) {\n          \n          \n            \n            \tprivate static String getMethodDescriptor(Method method, boolean remapToIntermediary) {", "author": "coderbot16", "createdAt": "2020-01-20T22:18:46Z", "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapMethodName(NAMED, className, name, methodDescriptor);\n+\t\tcase FIELD:\n+\t\t\tString fieldDescriptor = null;\n+\n+\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapFieldName(INTERMEDIARY, className, field.getName(),\n+\t\t\t\t\t\tgetDescriptorForClass(field.getType(), false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tfieldDescriptor = getDescriptorForClass(field.getType(), true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapFieldName(NAMED, className, name, fieldDescriptor);\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Someone's been tampering with enums! Got unexpected type \" + domain.name());\n+\t\t}\n+\t}\n+\n+\t// this is a stackoverflow response but with remapping\n+\tprivate static String getDescriptorForClass(final Class<?> c, boolean remapToIntermediary) {\n+\t\tif (c.isPrimitive()) {\n+\t\t\t// This could technically be turned into a map lookup, but that seems like overengineering considering this will never change\n+\t\t\tif (c == byte.class) {\n+\t\t\t\treturn \"B\";\n+\t\t\t} else if (c == char.class) {\n+\t\t\t\treturn \"C\";\n+\t\t\t} else if (c == double.class) {\n+\t\t\t\treturn \"D\";\n+\t\t\t} else if (c == float.class) {\n+\t\t\t\treturn \"F\";\n+\t\t\t} else if (c == int.class) {\n+\t\t\t\treturn \"I\";\n+\t\t\t} else if (c == long.class) {\n+\t\t\t\treturn \"J\";\n+\t\t\t} else if (c == short.class) {\n+\t\t\t\treturn \"S\";\n+\t\t\t} else if (c == boolean.class) {\n+\t\t\t\treturn \"Z\";\n+\t\t\t} else if (c == void.class) {\n+\t\t\t\treturn \"V\";\n+\t\t\t} else {\n+\t\t\t\tthrow new RuntimeException(\"Unrecognized primitive \" + c);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tString className = c.getName();\n+\n+\t\t\tif (remapToIntermediary) {\n+\t\t\t\tclassName = FabricLoader.getInstance().getMappingResolver().mapClassName(INTERMEDIARY, className);\n+\t\t\t}\n+\n+\t\t\tif (c.isArray()) {\n+\t\t\t\treturn className.replace('.', '/');\n+\t\t\t} else {\n+\t\t\t\treturn ('L' + className + ';').replace('.', '/');\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static String getMethodDescriptor(Method m, boolean remapToIntermediary) {", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MzE2MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368743161", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate static String getDescriptorForClass(final Class<?> c, boolean remapToIntermediary) {\n          \n          \n            \n            \tprivate static String getDescriptorForClass(final Class<?> clazz, boolean remapToIntermediary) {", "author": "coderbot16", "createdAt": "2020-01-20T22:19:06Z", "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapMethodName(NAMED, className, name, methodDescriptor);\n+\t\tcase FIELD:\n+\t\t\tString fieldDescriptor = null;\n+\n+\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapFieldName(INTERMEDIARY, className, field.getName(),\n+\t\t\t\t\t\tgetDescriptorForClass(field.getType(), false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tfieldDescriptor = getDescriptorForClass(field.getType(), true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapFieldName(NAMED, className, name, fieldDescriptor);\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Someone's been tampering with enums! Got unexpected type \" + domain.name());\n+\t\t}\n+\t}\n+\n+\t// this is a stackoverflow response but with remapping\n+\tprivate static String getDescriptorForClass(final Class<?> c, boolean remapToIntermediary) {", "originalCommit": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3953feadcec609eedc6d3ce499daa3a42e82c432", "url": "https://github.com/PatchworkMC/patchwork-api/commit/3953feadcec609eedc6d3ce499daa3a42e82c432", "message": "Reviews", "committedDate": "2020-01-23T17:41:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2OTE1OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r370969159", "bodyText": "Should probably null-check here", "author": "coderbot16", "createdAt": "2020-01-26T02:25:50Z", "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+", "originalCommit": "3953feadcec609eedc6d3ce499daa3a42e82c432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2OTE3NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r370969174", "bodyText": "Null check here too", "author": "coderbot16", "createdAt": "2020-01-26T02:26:02Z", "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapMethodName(NAMED, className, name, methodDescriptor);\n+\t\tcase FIELD:\n+\t\t\tString fieldDescriptor = null;\n+\n+\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapFieldName(INTERMEDIARY, className, field.getName(),\n+\t\t\t\t\t\tgetDescriptorForClass(field.getType(), false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tfieldDescriptor = getDescriptorForClass(field.getType(), true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+", "originalCommit": "3953feadcec609eedc6d3ce499daa3a42e82c432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5cd6746a4b46db28fd9afe9db8a4710ae8dfade6", "url": "https://github.com/PatchworkMC/patchwork-api/commit/5cd6746a4b46db28fd9afe9db8a4710ae8dfade6", "message": "Complete refactor of method used to remap names", "committedDate": "2020-01-26T23:23:19Z", "type": "commit"}, {"oid": "c517d60ad166259a5be5f09dc3a14b8aef684d35", "url": "https://github.com/PatchworkMC/patchwork-api/commit/c517d60ad166259a5be5f09dc3a14b8aef684d35", "message": "Merge branch 'master' of github.com:PatchworkMC/patchwork-api into feature/obf-reflection-helper", "committedDate": "2020-01-30T01:35:04Z", "type": "commit"}, {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "url": "https://github.com/PatchworkMC/patchwork-api/commit/c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "message": "It's 2020", "committedDate": "2020-01-30T01:35:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTA3OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311078", "bodyText": "Blank lines before documentation comments\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/**\n          \n          \n            \n            \n          \n          \n            \n            \t/**", "author": "coderbot16", "createdAt": "2020-01-31T04:24:38Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**", "originalCommit": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTA5NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *", "author": "coderbot16", "createdAt": "2020-01-31T04:24:44Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *", "originalCommit": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTM3Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311376", "bodyText": "It could make more sense just to check for intermediary, there's no guarantee that someone won't show up with some yarn-at-runtime mod or something. We're remapping from intermediary anyways.", "author": "coderbot16", "createdAt": "2020-01-31T04:26:37Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (!FabricLoader.getInstance().isDevelopmentEnvironment()) {", "originalCommit": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTQ2NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311465", "bodyText": "I feel that we should at least put some note here about the fact that we're reaching around in internal Fabric APIs, maybe a TODO or something.", "author": "coderbot16", "createdAt": "2020-01-31T04:27:13Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();", "originalCommit": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTkxMw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311913", "bodyText": "We already know the class here, I don't think we should scan over every single method def in every single class instead of just looking through that class directly.", "author": "coderbot16", "createdAt": "2020-01-31T04:30:13Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (!FabricLoader.getInstance().isDevelopmentEnvironment()) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tswitch (domain) {\n+\t\t\tcase CLASS:\n+\t\t\t\tif (classDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\treturn classDef.getName(NAMED);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase METHOD:\n+\t\t\t\tfor (MethodDef methodDef : classDef.getMethods()) {\n+\t\t\t\t\tif (methodDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn methodDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase FIELD:\n+\t\t\t\tfor (FieldDef fieldDef : classDef.getFields()) {\n+\t\t\t\t\tif (fieldDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn fieldDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new IllegalArgumentException(\"Someones tampered with enums! Got unexpected type \" + domain.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\t// It couldn't be found.\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tString name = remapName(INameMappingService.Domain.METHOD, methodName);", "originalCommit": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTk1Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311956", "bodyText": "Same here, but for fields instead.", "author": "coderbot16", "createdAt": "2020-01-31T04:30:29Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (!FabricLoader.getInstance().isDevelopmentEnvironment()) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tswitch (domain) {\n+\t\t\tcase CLASS:\n+\t\t\t\tif (classDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\treturn classDef.getName(NAMED);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase METHOD:\n+\t\t\t\tfor (MethodDef methodDef : classDef.getMethods()) {\n+\t\t\t\t\tif (methodDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn methodDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase FIELD:\n+\t\t\t\tfor (FieldDef fieldDef : classDef.getFields()) {\n+\t\t\t\t\tif (fieldDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn fieldDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new IllegalArgumentException(\"Someones tampered with enums! Got unexpected type \" + domain.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\t// It couldn't be found.\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tString name = remapName(INameMappingService.Domain.METHOD, methodName);\n+\t\t\tMethod method = clazz.getDeclaredMethod(name, parameterTypes);\n+\t\t\tmethod.setAccessible(true);\n+\t\t\treturn method;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new UnableToFindMethodException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a constructor with the specified parameter types in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the constructor is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the constructor in.\n+\t * @param parameterTypes The parameter types of the constructor.\n+\t * @param <T>            The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnknownConstructorException If the constructor could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Constructor<T> findConstructor(@Nonnull final Class<T> clazz, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find constructor on cannot be null.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of constructor to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tConstructor<T> constructor = clazz.getDeclaredConstructor(parameterTypes);\n+\t\t\tconstructor.setAccessible(true);\n+\t\t\treturn constructor;\n+\t\t} catch (final NoSuchMethodException e) {\n+\t\t\tfinal StringBuilder desc = new StringBuilder();\n+\t\t\tdesc.append(clazz.getSimpleName());\n+\n+\t\t\tStringJoiner joiner = new StringJoiner(\", \", \"(\", \")\");\n+\n+\t\t\tfor (Class<?> type : parameterTypes) {\n+\t\t\t\tjoiner.add(type.getSimpleName());\n+\t\t\t}\n+\n+\t\t\tdesc.append(joiner);\n+\n+\t\t\tthrow new UnknownConstructorException(\"Could not find constructor '\" + desc + \"' in \" + clazz);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a field with the specified name in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the field was not found.</p>\n+\t *\n+\t * @param clazz     The class to find the field on.\n+\t * @param fieldName The intermediary (unmapped) name of the field to find (e.g. \"field_1817\").\n+\t * @param <T>       The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException       If {@code clazz} is null.\n+\t * @throws NullPointerException       If {@code fieldName} is null.\n+\t * @throws IllegalArgumentException   If {@code fieldName} is empty.\n+\t * @throws UnableToFindFieldException If the field could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Field findField(@Nonnull final Class<? super T> clazz, @Nonnull final String fieldName) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find field on cannot be null.\");\n+\t\tPreconditions.checkNotNull(fieldName, \"Name of field to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!fieldName.isEmpty(), \"Name of field to find cannot be empty.\");\n+\n+\t\ttry {\n+\t\t\tString name = remapName(INameMappingService.Domain.FIELD, fieldName);", "originalCommit": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMjI3NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373312275", "bodyText": "I don't really like looking up the name here again, even if it's just on the error path...", "author": "coderbot16", "createdAt": "2020-01-31T04:32:31Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (!FabricLoader.getInstance().isDevelopmentEnvironment()) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tswitch (domain) {\n+\t\t\tcase CLASS:\n+\t\t\t\tif (classDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\treturn classDef.getName(NAMED);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase METHOD:\n+\t\t\t\tfor (MethodDef methodDef : classDef.getMethods()) {\n+\t\t\t\t\tif (methodDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn methodDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase FIELD:\n+\t\t\t\tfor (FieldDef fieldDef : classDef.getFields()) {\n+\t\t\t\t\tif (fieldDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn fieldDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new IllegalArgumentException(\"Someones tampered with enums! Got unexpected type \" + domain.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\t// It couldn't be found.\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);", "originalCommit": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzA2OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373807068", "bodyText": "We actually have to do the expensive lookup instead of the fast one, because this only throws when the field isn't found. Not doing the expensive lookup would reduce error readability in the event that someone looked up the right field name in the wrong class.\n(tl;dr there's no way to not look up twice)", "author": "TheGlitch76", "createdAt": "2020-02-01T22:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMjI3NQ=="}], "type": "inlineReview"}, {"oid": "7829737eda62df30d2f392db6c8db0cf08be453b", "url": "https://github.com/PatchworkMC/patchwork-api/commit/7829737eda62df30d2f392db6c8db0cf08be453b", "message": "Reviews", "committedDate": "2020-02-01T22:57:41Z", "type": "commit"}, {"oid": "b6f865272c34528c38ecbde7b6baa16731d0ad29", "url": "https://github.com/PatchworkMC/patchwork-api/commit/b6f865272c34528c38ecbde7b6baa16731d0ad29", "message": "Clean up ternary operators a bit", "committedDate": "2020-02-01T23:32:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwOTQzNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373809435", "bodyText": "If this is a class, you can do a map lookup like in the other class outside of the loop", "author": "coderbot16", "createdAt": "2020-02-01T23:59:36Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\t// We're technically messing with Loader's internal APIs here, if Loader ever gets a better mapping resolution system this class should be refactored.\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tif (domain == INameMappingService.Domain.CLASS) {", "originalCommit": "b6f865272c34528c38ecbde7b6baa16731d0ad29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwOTQ0MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373809440", "bodyText": "This should come first", "author": "coderbot16", "createdAt": "2020-02-01T23:59:58Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\t// We're technically messing with Loader's internal APIs here, if Loader ever gets a better mapping resolution system this class should be refactored.\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\t\tif (classDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\treturn classDef.getName(NAMED);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tboolean domainIsMethod = domain == INameMappingService.Domain.METHOD;\n+\n+\t\t\t\tfor (Mapped mapped : domainIsMethod ? classDef.getMethods() : classDef.getFields()) {\n+\t\t\t\t\tif (mapped.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn mapped.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// It couldn't be found.\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Like {@link ObfuscationReflectionHelper#remapName(INameMappingService.Domain, String)}, but only iterates through members of the target class.\n+\t * @param domain The {@link INameMappingService.Domain} to look up.\n+\t * @param clazz The class that contains the {@code name} to look up.\n+\t * @param name The name to remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\tpublic static String remapNameFast(INameMappingService.Domain domain, Class<?> clazz, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\tremapName(domain, name);\n+\t\t}\n+\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {", "originalCommit": "b6f865272c34528c38ecbde7b6baa16731d0ad29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2e04067ca2f8c02fa4cef2e86e04f419c58f652", "url": "https://github.com/PatchworkMC/patchwork-api/commit/b2e04067ca2f8c02fa4cef2e86e04f419c58f652", "message": "Reviews pt. 3", "committedDate": "2020-02-02T23:28:05Z", "type": "commit"}, {"oid": "a83665bf47b61c28eb5e1ec87e128b7109284a86", "url": "https://github.com/PatchworkMC/patchwork-api/commit/a83665bf47b61c28eb5e1ec87e128b7109284a86", "message": "Deduplicate code + add some javadoc formatting", "committedDate": "2020-02-02T23:47:39Z", "type": "commit"}, {"oid": "e09b0ed6fbca34179617e1cb856070560abe49fb", "url": "https://github.com/PatchworkMC/patchwork-api/commit/e09b0ed6fbca34179617e1cb856070560abe49fb", "message": "Move helper methods to PatchworkMappingService", "committedDate": "2020-02-03T01:00:32Z", "type": "commit"}, {"oid": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21", "url": "https://github.com/PatchworkMC/patchwork-api/commit/b8f049b4e479ca0a6c13d6c167f10f03ce380c21", "message": "Move static final fields to PatchworkMappingService", "committedDate": "2020-02-03T02:58:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwOTgwNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373909805", "bodyText": "These should be private", "author": "coderbot16", "createdAt": "2020-02-03T03:28:24Z", "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+public class PatchworkMappingService {\n+\tpublic static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();", "originalCommit": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwOTk3NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373909975", "bodyText": "This should be private", "author": "coderbot16", "createdAt": "2020-02-03T03:29:56Z", "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+public class PatchworkMappingService {\n+\tpublic static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tprivate PatchworkMappingService() {\n+\t\t// NO-OP\n+\t}\n+\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param name      The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn MAPPINGS.getDefaultNamespaceClassMap().get(name).getName(NAMED);\n+\t\t}\n+\n+\t\tString remappedName;\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tremappedName = PatchworkMappingService.remapNameInternal(domain, classDef, name);\n+\n+\t\t\tif (remappedName != null) {\n+\t\t\t\treturn remappedName;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Like {@link PatchworkMappingService#remapName(INameMappingService.Domain, String)}, but only iterates through members of the target class.\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param clazz     The class that contains the {@code name} to look up.\n+\t * @param name      The name to remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapNameFast(INameMappingService.Domain domain, Class<?> clazz, String name) {\n+\t\tClassDef classDef = MAPPINGS.getDefaultNamespaceClassMap().get(clazz.getName());\n+\t\tString remappedName = remapNameInternal(domain, classDef, name);\n+\n+\t\treturn remappedName != null ? remappedName : name;\n+\t}\n+\n+\t/**\n+\t * Like {@link PatchworkMappingService#remapNameFast(INameMappingService.Domain, Class, String)}, but takes a {@link ClassDef} instead of a {@link Class}.\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param classDef  The classDef that contains the {@code name} to look up.\n+\t * @param name      The name to remap.\n+\t * @return The remapped name, or null if it couldn't be remapped.\n+\t */\n+\t@Nullable\n+\tpublic static String remapNameInternal(INameMappingService.Domain domain, ClassDef classDef, String name) {", "originalCommit": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMDAxOA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373910018", "bodyText": "This should get moved to PatchworkMappingService", "author": "coderbot16", "createdAt": "2020-02-03T03:30:17Z", "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingService;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\t// We're technically messing with Loader's internal APIs here, if Loader ever gets a better mapping resolution system this class should be refactored.", "originalCommit": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMTcwNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373911707", "bodyText": "This should have the intermediary check too (avoid executing any remap code in prod), and also I think we should deduplicate it into a private helper function (isIntermediary or something similar?)", "author": "coderbot16", "createdAt": "2020-02-03T03:42:53Z", "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+public class PatchworkMappingService {\n+\tpublic static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tprivate PatchworkMappingService() {\n+\t\t// NO-OP\n+\t}\n+\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param name      The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn MAPPINGS.getDefaultNamespaceClassMap().get(name).getName(NAMED);\n+\t\t}\n+\n+\t\tString remappedName;\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tremappedName = PatchworkMappingService.remapNameInternal(domain, classDef, name);\n+\n+\t\t\tif (remappedName != null) {\n+\t\t\t\treturn remappedName;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Like {@link PatchworkMappingService#remapName(INameMappingService.Domain, String)}, but only iterates through members of the target class.\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param clazz     The class that contains the {@code name} to look up.\n+\t * @param name      The name to remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapNameFast(INameMappingService.Domain domain, Class<?> clazz, String name) {\n+\t\tClassDef classDef = MAPPINGS.getDefaultNamespaceClassMap().get(clazz.getName());", "originalCommit": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "35a460a383c9d9ddf1f37dce7159de11f422538e", "url": "https://github.com/PatchworkMC/patchwork-api/commit/35a460a383c9d9ddf1f37dce7159de11f422538e", "message": "Final (hopefully) reviews", "committedDate": "2020-02-03T18:34:03Z", "type": "commit"}]}