{"pr_number": 3982, "pr_title": "Add local Bitcoin node configuration detection", "pr_createdAt": "2020-02-17T22:56:43Z", "pr_url": "https://github.com/bisq-network/bisq/pull/3982", "timeline": [{"oid": "f895da416fbe4c75acdaebe9f9f22e534edf09d1", "url": "https://github.com/bisq-network/bisq/commit/f895da416fbe4c75acdaebe9f9f22e534edf09d1", "message": "Add local Bitcoin node configuration detection\n\nRefactors LocalBitcoinNode and adds detection for local Bitcoin node's\nconfiguration, namely, whether it is pruning and whether it has bloom\nfilter queries enabled.\n\nThe local node's configuration (and its presence) is retrieved by\nperforming a Bitcoin protocol handshake, which includes the local\nBitcoin node sending us its version message (VersionMessage in\nBitcoinJ), which contains the information we're interested in.\n\nDue to some quirky BitcoinJ logic, sometimes the handshake is\ninterrupted, even though we have received the local node's version\nmessage. That contributes to the handshake handling in LocalBitcoinNode\nbeing a bit complicated.\n\nRefactoring consists of two principle changes: the public interface is\nsplit into methods that trigger checks and methods that retrieve the\ncached results. The methods that trigger checks have names starting\nwith \"check\", and methods that retrieve the cached results have names\nthat start with \"is\".\n\nThe other major refactor is the use of Optional<Boolean> instead of\nboolean for storing and returning the results, an empty Optional\nsignifying that the relevant check was not yet performed. Switching to\nOptionals has caused other code that queries LocalBitcoinNode to throw\nan exception in case the query is made before the checks are. Before,\nthe results were instantiated to \"false\" and that would be returned\nin case the query was made before the checks completed. This change has\nrevealed one occasion (Preferences class) where this happens.", "committedDate": "2020-02-17T22:34:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTYwMQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380391601", "bodyText": "Removed redundant LocalBitcoinNode call, because Preferences.getUseTorForBitcoinJ makes the same call and it has the same effect.", "author": "dmos62", "createdAt": "2020-02-17T22:58:53Z", "path": "core/src/main/java/bisq/core/app/BisqSetup.java", "diffHunk": "@@ -559,7 +576,7 @@ else if (displayTorNetworkSettingsHandler != null)\n \n         // We only init wallet service here if not using Tor for bitcoinj.\n         // When using Tor, wallet init must be deferred until Tor is ready.\n-        if (!preferences.getUseTorForBitcoinJ() || localBitcoinNode.isDetected()) {", "originalCommit": "f895da416fbe4c75acdaebe9f9f22e534edf09d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM2OTA5MA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384369090", "bodyText": "If localBitcoinNode.willUse() == true and config.useTorForBtcOptionSetExplicitly == true the new code will behave differently than before. So I don't think we should remove this from here.", "author": "ripcurlx", "createdAt": "2020-02-26T09:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ3MzEwMg==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384473102", "bodyText": "You're right, I missed that. Thanks! My concern here is that this line decides whether to \"initiate wallet\" at this time, which implies that Tor will not be used. Ideally Preferences.getUseTorForBitcoinJ() would be a full authority on whether or not we're using Tor, but here it's only one half of the condition. So I can restore initial logic, but ideally I'd like to restructure this. I'll see what I can do.", "author": "dmos62", "createdAt": "2020-02-26T12:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MjA5MQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380392091", "bodyText": "Apart from the .isDetected() -> .isUsable.get() line, these are just formatting changes.", "author": "dmos62", "createdAt": "2020-02-17T23:01:27Z", "path": "desktop/src/main/java/bisq/desktop/main/MainViewModel.java", "diffHunk": "@@ -441,10 +451,12 @@ private void setupBtcNumPeersWatcher() {\n                 checkNumberOfBtcPeersTimer = UserThread.runAfter(() -> {\n                     // check again numPeers\n                     if (walletsSetup.numPeersProperty().get() == 0) {\n-                        if (localBitcoinNode.isDetected())\n-                            getWalletServiceErrorMsg().set(Res.get(\"mainView.networkWarning.localhostBitcoinLost\", Res.getBaseCurrencyName().toLowerCase()));", "originalCommit": "f895da416fbe4c75acdaebe9f9f22e534edf09d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MjI0Mw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380392243", "bodyText": "This is the bug I mentioned.", "author": "dmos62", "createdAt": "2020-02-17T23:02:19Z", "path": "core/src/main/java/bisq/core/user/Preferences.java", "diffHunk": "@@ -736,11 +736,24 @@ public boolean showAgain(String key) {\n     }\n \n     public boolean getUseTorForBitcoinJ() {\n-        // We override the useTorForBitcoinJ and set it to false if we detected a localhost node or if we are not on mainnet,\n+        // We override the useTorForBitcoinJ and set it to false if we found a usable localhost node or if we are not on mainnet,\n         // unless the useTorForBtc parameter is explicitly provided.\n         // On testnet there are very few Bitcoin tor nodes and we don't provide tor nodes.\n+\n+        // TODO bug. Non-critical, apparently.\n+        // Sometimes this method, which queries LocalBitcoinNode for whether or not there's a\n+        // usable local Bitcoin node, is called before LocalBitcoinNode has performed its\n+        // checks. This was noticed when LocalBitcoinNode was refactored to return\n+        // Optional<Boolean> istead of boolean, an empty Optional signifying that the relevant\n+        // check has not yet been performed.\n+        //\n+        // To keep the method's behaviour unchanged, until a fix is implemented, we use\n+        // Optional.orElse(false). Here 'false' normally means that the checks were performed\n+        // and a suitable local Bitcoin node wasn't found.\n+        var usableLocalNodePresent = localBitcoinNode.isUsable().orElse(false);", "originalCommit": "f895da416fbe4c75acdaebe9f9f22e534edf09d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "18478d9b0dba78e5cb662bb10f72debd3973226d", "url": "https://github.com/bisq-network/bisq/commit/18478d9b0dba78e5cb662bb10f72debd3973226d", "message": "Downgrade Optional usage to Java 10\n\nI was erroniously targeting Java 11, when Travis requires Java 10. `Optional.isEmpty` shows up only in Java 11.", "committedDate": "2020-02-18T10:21:17Z", "type": "commit"}, {"oid": "74c946a28b9237c8bf9d2ea96a699723ba19a2c9", "url": "https://github.com/bisq-network/bisq/commit/74c946a28b9237c8bf9d2ea96a699723ba19a2c9", "message": "Remove defunct test suite\n\nThe workings of LocalBitcoinNode significantly changed, especially how\ndetection works. Before, we were only checking if a port was open, but\nnow we're actually performing a Bitcoin protocol handshake, which is\ndifficult to stub. For these reasons the old tests are irrelevant and\nreplacement tests were not written.", "committedDate": "2020-02-18T10:31:15Z", "type": "commit"}, {"oid": "daa1b0b20b02c13daf58036a41486087b8328e07", "url": "https://github.com/bisq-network/bisq/commit/daa1b0b20b02c13daf58036a41486087b8328e07", "message": "Minor changes to satisfy Codacy or clarify why it fails", "committedDate": "2020-02-18T11:02:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY2Mjk2MQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380662961", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ;\n          \n          \n            \n                            // No action", "author": "sqrrm", "createdAt": "2020-02-18T13:14:27Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -229,6 +231,7 @@ public void onSuccess(Peer peer) {\n                 peerVersionMessageFuture.set(peer.getPeerVersionMessage());\n             }\n             public void onFailure(Throwable thr) {\n+                ;", "originalCommit": "daa1b0b20b02c13daf58036a41486087b8328e07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY2MzYxNw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380663617", "bodyText": "I think a comment might work, codacy is complaining about the lone semicolon, which does look odd.", "author": "sqrrm", "createdAt": "2020-02-18T13:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY2Mjk2MQ=="}], "type": "inlineReview"}, {"oid": "e6dea3d3edf28f9dc6e3474b648c0b0f9f74487f", "url": "https://github.com/bisq-network/bisq/commit/e6dea3d3edf28f9dc6e3474b648c0b0f9f74487f", "message": "Improve marking that method is empty\n\nCo-Authored-By: sqrrm <sqrrm@users.noreply.github.com>", "committedDate": "2020-02-18T15:30:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxODUzNQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380818535", "bodyText": "Since localBitcoinNode.isDetectedButMisconfigured() is an optional it would be prudent to check that it's present here. Although it might be certain for now that it's never null the characteristics of an optional is that it should be able to handle the null state.", "author": "sqrrm", "createdAt": "2020-02-18T17:19:57Z", "path": "core/src/main/java/bisq/core/app/BisqSetup.java", "diffHunk": "@@ -482,14 +482,31 @@ private void maybeShowTac() {\n         }\n     }\n \n-    private void detectLocalBitcoinNode(Runnable nextStep) {\n+    private void maybeCheckLocalBitcoinNode(Runnable nextStep) {\n         BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n-        if (config.ignoreLocalBtcNode || baseCurrencyNetwork.isDaoRegTest() || baseCurrencyNetwork.isDaoTestNet()) {\n+\n+        var shouldIgnoreLocalNode =\n+            config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+        if (shouldIgnoreLocalNode) {\n             nextStep.run();\n             return;\n         }\n \n-        localBitcoinNode.detectAndRun(nextStep);\n+        // Results of the check don't have to be passed to nextStep,\n+        // because they're cached in LocalBitcoinNode and dependent routines query it themselves.\n+        localBitcoinNode.checkUsable();\n+\n+        // Here we only want to provide the user with a choice (in a popup) in case a local node is\n+        // detected, but badly configured.\n+        var detectedButMisconfigured = localBitcoinNode.isDetectedButMisconfigured().get();", "originalCommit": "f895da416fbe4c75acdaebe9f9f22e534edf09d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0NjIwNA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382846204", "bodyText": "I took your suggestion about getting rid of most of the Optional.get()s in other places, but in my opinion here a check would be superfluous, because it's easy to see that getting an empty Optional is impossible here with the current implementation of LocalBitcoinNode (.checkUsable() on the previous line guarantees that). That said if it were to change, all the calls would have to be reconsidered anyway, right?", "author": "dmos62", "createdAt": "2020-02-21T23:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxODUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyMTMzMw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380821333", "bodyText": "Same here with the usage of Optional without checking isPresent().", "author": "sqrrm", "createdAt": "2020-02-18T17:24:55Z", "path": "core/src/main/java/bisq/core/app/BisqSetup.java", "diffHunk": "@@ -862,7 +879,7 @@ private void maybeShowSecurityRecommendation() {\n     }\n \n     private void maybeShowLocalhostRunningInfo() {\n-        maybeTriggerDisplayHandler(\"bitcoinLocalhostNode\", displayLocalhostHandler, localBitcoinNode.isDetected());\n+        maybeTriggerDisplayHandler(\"bitcoinLocalhostNode\", displayLocalhostHandler, localBitcoinNode.isUsable().get());", "originalCommit": "f895da416fbe4c75acdaebe9f9f22e534edf09d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzMjYzNg==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380832636", "bodyText": "So much space in this method...", "author": "sqrrm", "createdAt": "2020-02-18T17:45:34Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +49,272 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n+     * Creates an NioClient that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+\n+    private static NioClient createClient(\n+            Peer peer, int port, int connectionTimeout\n+    ) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /**\n+     * Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n      */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+\n+    private static Peer createLocalPeer(\n+            int port\n+    ) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+", "originalCommit": "f895da416fbe4c75acdaebe9f9f22e534edf09d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxMDUxNg==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r381310516", "bodyText": "Yes, please apply same formatting advice here as I mentioned above on lines 65\u201367. And apply it consistently to any other similar changes in this PR as well. The general rule in effect here is to keep things on one line up to the 120-char right margin.", "author": "cbeams", "createdAt": "2020-02-19T14:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzMjYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1NDEyMg==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r380854122", "bodyText": "Same with the checks for Optional.isPresent().", "author": "sqrrm", "createdAt": "2020-02-18T18:26:41Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +49,272 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n+     * Creates an NioClient that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+\n+    private static NioClient createClient(\n+            Peer peer, int port, int connectionTimeout\n+    ) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /**\n+     * Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n      */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+\n+    private static Peer createLocalPeer(\n+            int port\n+    ) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        var context = new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /**\n+     * Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or not.\n+        // The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /**\n+     * Initiates detection and configuration checks. The results are cached so that the public\n+     * methods isUsable, isDetected, isWellConfigured don't trigger a recheck.\n+     */\n+\n+    public boolean checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+        // We know that the Optional/s will be populated by the end of the checks.\n+        return isUsable().get();", "originalCommit": "f895da416fbe4c75acdaebe9f9f22e534edf09d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMwODg1Nw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r381308857", "bodyText": "To follow convention, formatting here should be:\nprivate static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {", "author": "cbeams", "createdAt": "2020-02-19T14:03:14Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +49,275 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n+     * Creates an NioClient that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+\n+    private static NioClient createClient(\n+            Peer peer, int port, int connectionTimeout\n+    ) throws IOException {", "originalCommit": "e6dea3d3edf28f9dc6e3474b648c0b0f9f74487f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxMTUxMA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r381311510", "bodyText": "Nit: unnecessary newline here, and this need not be a (/**) Javadoc comment as it's on a private method and will never be published. Wrap comments at 90-char right margin, thanks.", "author": "cbeams", "createdAt": "2020-02-19T14:07:38Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +49,275 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n+     * Creates an NioClient that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+\n+    private static NioClient createClient(\n+            Peer peer, int port, int connectionTimeout\n+    ) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /**\n+     * Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n      */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+\n+    private static Peer createLocalPeer(\n+            int port\n+    ) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ.\n+        // We don't keep a reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /**\n+     * Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+", "originalCommit": "e6dea3d3edf28f9dc6e3474b648c0b0f9f74487f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxMTk4NQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r381311985", "bodyText": "Local variables should be camelCase.", "author": "cbeams", "createdAt": "2020-02-19T14:08:26Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +49,275 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n+     * Creates an NioClient that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+\n+    private static NioClient createClient(\n+            Peer peer, int port, int connectionTimeout\n+    ) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /**\n+     * Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n      */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+\n+    private static Peer createLocalPeer(\n+            int port\n+    ) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ.\n+        // We don't keep a reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /**\n+     * Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or not.\n+        // The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;", "originalCommit": "e6dea3d3edf28f9dc6e3474b648c0b0f9f74487f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1MTc3MA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382851770", "bodyText": "Do you feel strongly about this? These are constants, in the semantic sense, that I encapsulated in a single method with the code that uses them, and formating them as such helps single them out. I didn't want to separate them out to top-level static variables, because they're part of a small port from upstream BitcoinJ and I wanted to keep it completely separate from the rest of the class.", "author": "dmos62", "createdAt": "2020-02-21T23:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxMTk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkyNzM3Mg==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382927372", "bodyText": "In my opinion this kind of containment is good. Camel case local variables would not be appropriate, but making them local seems right considering the situation.", "author": "sqrrm", "createdAt": "2020-02-22T17:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxMTk4NQ=="}], "type": "inlineReview"}, {"oid": "65177fcc4c12cd1d3cdb410cc34a35867aaf1ae0", "url": "https://github.com/bisq-network/bisq/commit/65177fcc4c12cd1d3cdb410cc34a35867aaf1ae0", "message": "Fix unchecked usage of LocalBitcoinNode.isUsable()", "committedDate": "2020-02-21T21:52:36Z", "type": "commit"}, {"oid": "08cd31b242892c519e58c3dfdac4757411d8fca7", "url": "https://github.com/bisq-network/bisq/commit/08cd31b242892c519e58c3dfdac4757411d8fca7", "message": "Silence NioClient and NioClientManager loggers", "committedDate": "2020-02-21T21:53:02Z", "type": "commit"}, {"oid": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "url": "https://github.com/bisq-network/bisq/commit/7848836adc83ef5393d0af821d81c3fe63ea80f7", "message": "Formating changes", "committedDate": "2020-02-21T23:30:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODEzNw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948137", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T22:59:25Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODE0NA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948144", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T22:59:41Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODE0Ng==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948146", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T22:59:46Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODE1MQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948151", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T22:59:52Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODE3Nw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948177", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:00:10Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODE4Mw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948183", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:00:18Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODE4Nw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948187", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:00:30Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODE5Mg==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948192", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:00:39Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODIzOA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948238", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:01:22Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+     * Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, isWellConfigured don't trigger a recheck.\n+     */\n+    public boolean checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+        // We know that the Optional/s will be populated by the end of the checks.\n+        return isUsable().get();\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = Optional.of(false);\n+            wellConfigured = Optional.of(false);\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = Optional.of(true);\n             log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODI2NA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948264", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:01:41Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+     * Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, isWellConfigured don't trigger a recheck.\n+     */\n+    public boolean checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+        // We know that the Optional/s will be populated by the end of the checks.\n+        return isUsable().get();\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = Optional.of(false);\n+            wellConfigured = Optional.of(false);\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = Optional.of(true);\n             log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = Optional.of(true);\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = Optional.of(false);\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODI3Ng==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948276", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:01:57Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+     * Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, isWellConfigured don't trigger a recheck.\n+     */\n+    public boolean checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+        // We know that the Optional/s will be populated by the end of the checks.\n+        return isUsable().get();\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = Optional.of(false);\n+            wellConfigured = Optional.of(false);\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = Optional.of(true);\n             log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = Optional.of(true);\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = Optional.of(false);\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n         } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n         }\n-        callback.run();\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODI4NA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948284", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:02:16Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+     * Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, isWellConfigured don't trigger a recheck.\n+     */\n+    public boolean checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+        // We know that the Optional/s will be populated by the end of the checks.\n+        return isUsable().get();\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = Optional.of(false);\n+            wellConfigured = Optional.of(false);\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = Optional.of(true);\n             log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = Optional.of(true);\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = Optional.of(false);\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n         } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n         }\n-        callback.run();\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODI5NQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948295", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:02:30Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+     * Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, isWellConfigured don't trigger a recheck.\n+     */\n+    public boolean checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+        // We know that the Optional/s will be populated by the end of the checks.\n+        return isUsable().get();\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = Optional.of(false);\n+            wellConfigured = Optional.of(false);\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = Optional.of(true);\n             log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = Optional.of(true);\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = Optional.of(false);\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n         } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n         }\n-        callback.run();\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n+        return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(klass);\n+    }\n+\n+    private ListenableFuture<VersionMessage> getVersionMessage(Peer peer) {\n+        SettableFuture<VersionMessage> peerVersionMessageFuture = SettableFuture.create();\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk3MjM2NA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382972364", "bodyText": "Here rationale is to separate the creation of the future from the parts that use it. The next three parts of the method operate on this future.", "author": "dmos62", "createdAt": "2020-02-23T07:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODMwNQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948305", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:02:45Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+     * Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, isWellConfigured don't trigger a recheck.\n+     */\n+    public boolean checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+        // We know that the Optional/s will be populated by the end of the checks.\n+        return isUsable().get();\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = Optional.of(false);\n+            wellConfigured = Optional.of(false);\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = Optional.of(true);\n             log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = Optional.of(true);\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = Optional.of(false);\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n         } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n         }\n-        callback.run();\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n+        return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(klass);\n+    }\n+\n+    private ListenableFuture<VersionMessage> getVersionMessage(Peer peer) {\n+        SettableFuture<VersionMessage> peerVersionMessageFuture = SettableFuture.create();\n+\n+        var versionHandshakeDone = peer.getVersionHandshakeFuture();\n+        FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<Peer>() {\n+            public void onSuccess(Peer peer) {\n+                peerVersionMessageFuture.set(peer.getPeerVersionMessage());\n+            }\n+            public void onFailure(Throwable thr) {\n+                // No action\n+            }\n+        };\n+        Futures.addCallback(\n+                versionHandshakeDone,\n+                fetchPeerVersionMessage\n+        );\n+\n+        PeerDisconnectedEventListener cancelIfConnectionFails =\n+                new PeerDisconnectedEventListener() {\n+                    public void onPeerDisconnected(Peer peer, int peerCount) {\n+                        var peerVersionMessageAlreadyReceived =\n+                                peerVersionMessageFuture.isDone();\n+                        if (peerVersionMessageAlreadyReceived) {\n+                            // This method is called whether or not the handshake was\n+                            // successful. In case it was successful, we don't want to do\n+                            // anything here.\n+                            return;\n+                        }\n+                        // In some cases Peer will self-disconnect after receiving\n+                        // node's VersionMessage, but before completing the handshake.\n+                        // In such a case, we want to retrieve the VersionMessage.\n+                        var peerVersionMessage = peer.getPeerVersionMessage();\n+                        if (peerVersionMessage != null) {\n+                            log.info(\"Handshake attempt was interrupted;\"\n+                                    + \" however, the local node's version message was coerced.\");\n+                            peerVersionMessageFuture.set(peerVersionMessage);\n+                        } else {\n+                            log.info(\"Handshake attempt did not result in a version message exchange.\");\n+                            var mayInterruptWhileRunning = true;\n+                            peerVersionMessageFuture.cancel(mayInterruptWhileRunning);\n+                        }\n+                    }\n+                };\n+\n+        // Cancel peerVersionMessageFuture if connection failed\n+        peer.addDisconnectedEventListener(cancelIfConnectionFails);\n+\n+        return peerVersionMessageFuture;\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns an optional that, in case it is not empty, shows whether or not the\n+     * local node was fit for usage at the time the checks were performed called,\n+     * meaning it's been detected and its configuration satisfied our checks; or, in\n+     * the case that it is empty, it signifies that the checks have not yet completed.\n      */\n-    public boolean isDetected() {\n+    public Optional<Boolean> isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns an Optional<Boolean> that, when not empty, tells you whether the local node\n+     * was detected, but misconfigured.\n+     */\n+    public Optional<Boolean> isDetectedButMisconfigured() {\n+        return isDetected().flatMap(goodDetect ->\n+                isWellConfigured().map(goodConfig ->\n+                        goodDetect && !goodConfig\n+                ));\n+    }\n+\n+    /**\n+     * Returns an optional, which is empty in case detection has not yet completed, or\n+     * which contains a Boolean, in case detection has been performed, which signifies\n+     * whether or not a Bitcoin node was running on localhost at the time the checks were\n+     * performed. No further monitoring is performed, so if the node goes up or down in\n+     * the meantime, this method will continue to return its original value. See\n+     * {@code MainViewModel#setupBtcNumPeersWatcher} to understand how disconnection and\n+     * reconnection of the local Bitcoin node is actually handled.\n+     */\n+    public Optional<Boolean> isDetected() {\n         return detected;\n     }\n+\n+    /**\n+     * Returns an optional whose emptiness signifies whether or not configuration checks\n+     * have been performed, and its Boolean contents whether the local node's\n+     * configuration satisfied our checks at the time they were performed. We check if the\n+     * local node is not pruning and has bloom filters enabled.\n+     */\n+    public Optional<Boolean> isWellConfigured() {\n+        return wellConfigured;\n+    }\n+\n+    /**\n+     * A \"safe\" variant, which, in case LocalBitcoinNode checks were\n+     * not performed, reverts to legacy behaviour and logs an error message. See\n+     * {@code LocalBitcoinNode#handleUnsafeQuery}.\n+     */\n+    public boolean safeIsUsable() {\n+        return handleUnsafeQuery(isUsable());\n+    }\n+\n+    private boolean handleUnsafeQuery(Optional<Boolean> opt) {\n+        return opt.orElseGet(() -> {\n+            /* Returning false when checks haven't been performed yet is what the behaviour\n+             * was before we switched to using Optionals. More specifically, the only query\n+             * method at the time, isDetected(), would return false in such a case. We are\n+             * relatively confident that the previous behaviour doesn't cause fatal bugs,\n+             * so, in case LocalBitcoinNode is queried too early, we revert to it, instead\n+             * of letting Optional.empty().get() throw an exception. The advantage over\n+             * plain booleans then is that we can log the below error message (with\n+             * stacktrace).\n+             */\n+            var whenChecksNotFinished = false;\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODMwOQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948309", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:02:51Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -25,39 +54,321 @@\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n     private final int port;\n-    private boolean detected = false;\n+    private Optional<Boolean> detected = Optional.empty();\n+    private Optional<Boolean> wellConfigured = Optional.empty();\n \n     @Inject\n     public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n         this.port = port;\n     }\n \n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n+     * Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, isWellConfigured don't trigger a recheck.\n+     */\n+    public boolean checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+        // We know that the Optional/s will be populated by the end of the checks.\n+        return isUsable().get();\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = Optional.of(false);\n+            wellConfigured = Optional.of(false);\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = Optional.of(true);\n             log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = Optional.of(true);\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = Optional.of(false);\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n         } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n         }\n-        callback.run();\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n+        return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(klass);\n+    }\n+\n+    private ListenableFuture<VersionMessage> getVersionMessage(Peer peer) {\n+        SettableFuture<VersionMessage> peerVersionMessageFuture = SettableFuture.create();\n+\n+        var versionHandshakeDone = peer.getVersionHandshakeFuture();\n+        FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<Peer>() {\n+            public void onSuccess(Peer peer) {\n+                peerVersionMessageFuture.set(peer.getPeerVersionMessage());\n+            }\n+            public void onFailure(Throwable thr) {\n+                // No action\n+            }\n+        };\n+        Futures.addCallback(\n+                versionHandshakeDone,\n+                fetchPeerVersionMessage\n+        );\n+\n+        PeerDisconnectedEventListener cancelIfConnectionFails =\n+                new PeerDisconnectedEventListener() {\n+                    public void onPeerDisconnected(Peer peer, int peerCount) {\n+                        var peerVersionMessageAlreadyReceived =\n+                                peerVersionMessageFuture.isDone();\n+                        if (peerVersionMessageAlreadyReceived) {\n+                            // This method is called whether or not the handshake was\n+                            // successful. In case it was successful, we don't want to do\n+                            // anything here.\n+                            return;\n+                        }\n+                        // In some cases Peer will self-disconnect after receiving\n+                        // node's VersionMessage, but before completing the handshake.\n+                        // In such a case, we want to retrieve the VersionMessage.\n+                        var peerVersionMessage = peer.getPeerVersionMessage();\n+                        if (peerVersionMessage != null) {\n+                            log.info(\"Handshake attempt was interrupted;\"\n+                                    + \" however, the local node's version message was coerced.\");\n+                            peerVersionMessageFuture.set(peerVersionMessage);\n+                        } else {\n+                            log.info(\"Handshake attempt did not result in a version message exchange.\");\n+                            var mayInterruptWhileRunning = true;\n+                            peerVersionMessageFuture.cancel(mayInterruptWhileRunning);\n+                        }\n+                    }\n+                };\n+\n+        // Cancel peerVersionMessageFuture if connection failed\n+        peer.addDisconnectedEventListener(cancelIfConnectionFails);\n+\n+        return peerVersionMessageFuture;\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns an optional that, in case it is not empty, shows whether or not the\n+     * local node was fit for usage at the time the checks were performed called,\n+     * meaning it's been detected and its configuration satisfied our checks; or, in\n+     * the case that it is empty, it signifies that the checks have not yet completed.\n      */\n-    public boolean isDetected() {\n+    public Optional<Boolean> isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns an Optional<Boolean> that, when not empty, tells you whether the local node\n+     * was detected, but misconfigured.\n+     */\n+    public Optional<Boolean> isDetectedButMisconfigured() {\n+        return isDetected().flatMap(goodDetect ->\n+                isWellConfigured().map(goodConfig ->\n+                        goodDetect && !goodConfig\n+                ));\n+    }\n+\n+    /**\n+     * Returns an optional, which is empty in case detection has not yet completed, or\n+     * which contains a Boolean, in case detection has been performed, which signifies\n+     * whether or not a Bitcoin node was running on localhost at the time the checks were\n+     * performed. No further monitoring is performed, so if the node goes up or down in\n+     * the meantime, this method will continue to return its original value. See\n+     * {@code MainViewModel#setupBtcNumPeersWatcher} to understand how disconnection and\n+     * reconnection of the local Bitcoin node is actually handled.\n+     */\n+    public Optional<Boolean> isDetected() {\n         return detected;\n     }\n+\n+    /**\n+     * Returns an optional whose emptiness signifies whether or not configuration checks\n+     * have been performed, and its Boolean contents whether the local node's\n+     * configuration satisfied our checks at the time they were performed. We check if the\n+     * local node is not pruning and has bloom filters enabled.\n+     */\n+    public Optional<Boolean> isWellConfigured() {\n+        return wellConfigured;\n+    }\n+\n+    /**\n+     * A \"safe\" variant, which, in case LocalBitcoinNode checks were\n+     * not performed, reverts to legacy behaviour and logs an error message. See\n+     * {@code LocalBitcoinNode#handleUnsafeQuery}.\n+     */\n+    public boolean safeIsUsable() {\n+        return handleUnsafeQuery(isUsable());\n+    }\n+\n+    private boolean handleUnsafeQuery(Optional<Boolean> opt) {\n+        return opt.orElseGet(() -> {\n+            /* Returning false when checks haven't been performed yet is what the behaviour\n+             * was before we switched to using Optionals. More specifically, the only query\n+             * method at the time, isDetected(), would return false in such a case. We are\n+             * relatively confident that the previous behaviour doesn't cause fatal bugs,\n+             * so, in case LocalBitcoinNode is queried too early, we revert to it, instead\n+             * of letting Optional.empty().get() throw an exception. The advantage over\n+             * plain booleans then is that we can log the below error message (with\n+             * stacktrace).\n+             */\n+            var whenChecksNotFinished = false;\n+\n+            var throwable = new Throwable(\"LocalBitcoinNode was queried before it was ready\");\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0ODMxNw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r382948317", "bodyText": "Blank line", "author": "sqrrm", "createdAt": "2020-02-22T23:03:03Z", "path": "core/src/main/java/bisq/core/user/Preferences.java", "diffHunk": "@@ -736,11 +736,20 @@ public boolean showAgain(String key) {\n     }\n \n     public boolean getUseTorForBitcoinJ() {\n-        // We override the useTorForBitcoinJ and set it to false if we detected a localhost node or if we are not on mainnet,\n+        // We override the useTorForBitcoinJ and set it to false if we found a usable localhost node or if we are not on mainnet,\n         // unless the useTorForBtc parameter is explicitly provided.\n         // On testnet there are very few Bitcoin tor nodes and we don't provide tor nodes.\n+\n+        // TODO bug. Non-critical, apparently.\n+        // Sometimes this method, which queries LocalBitcoinNode for whether or not there's a\n+        // usable local Bitcoin node, is called before LocalBitcoinNode has performed its\n+        // checks. This was noticed when LocalBitcoinNode was refactored to return\n+        // Optional<Boolean> istead of boolean, an empty Optional signifying that the relevant\n+        // check has not yet been performed.\n+        var usableLocalNodePresent = localBitcoinNode.safeIsUsable();\n+", "originalCommit": "7848836adc83ef5393d0af821d81c3fe63ea80f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0bbbe8c1e90c6f2be9e3c15520f2ae87eadffaf2", "url": "https://github.com/bisq-network/bisq/commit/0bbbe8c1e90c6f2be9e3c15520f2ae87eadffaf2", "message": "Perform checks automatically on first query\n\nIt's quite amazing how obvious this was, yet I missed it for such a long\ntime. Simplifies usage of LocalBitcoinNode and its internals even more\nso. Fixes #4005. The way we structured LocalBitcoinNode was as if the\ndetection checks were expensive, but they're not. Previously, in some\ncases we would notice that a local BTC node wouldn't be used even if it\nwas detected, so we would skip these checks. This optimization now\ndoesn't happen. It might be reimplemented in a coming change where more\nlocal BTC node logic is moved into LocalBitcoinNode, but, even if it's\nnot, this check is fairly cheap. A notable exception is if the local BTC\nnode is not responding, which would cause us to wait for a timeout, but\nif that is the case the mentioned optimization wouldn't help (most of\nthe time).", "committedDate": "2020-02-25T13:04:34Z", "type": "commit"}, {"oid": "aceb608e3a13c113fa7568b9228466d1edd5757e", "url": "https://github.com/bisq-network/bisq/commit/aceb608e3a13c113fa7568b9228466d1edd5757e", "message": "Reorder methods", "committedDate": "2020-02-25T13:18:36Z", "type": "commit"}, {"oid": "6b4878ada8c43d31410556e28df1becdc3f09238", "url": "https://github.com/bisq-network/bisq/commit/6b4878ada8c43d31410556e28df1becdc3f09238", "message": "Centralize some of local BTC node logic\n\nIntroduces LocalBitcoinNode::willUse and ::willIgnore to move logic that\nwas previously littered throughout the codebase into one place. Also,\nchanges the usages of LocalBitcoinNode to be more precise, specifying\nwhich of these questions are being asked:\n\n- \"is there a local BTC node\" (isDetected);\n- \"is it well configured\" (isWellConfigured and isUsable);\n- \"will we ignore a local BTC node even if we found a usable one\"\n  (willIgnore);\n- \"is there a usable local BTC node and will we use it\" (willUse).\n\nThese changes make related logic much easier to maintain and to read.", "committedDate": "2020-02-25T14:56:02Z", "type": "commit"}, {"oid": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "url": "https://github.com/bisq-network/bisq/commit/2a57ecddfc41b1d0219155df9fac2e9fa6780181", "message": "Fix failing test", "committedDate": "2020-02-25T15:22:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM2NTY1NQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384365655", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        displayLocalNodeMisconfigurationHandler.accept(nextStep);\n          \n          \n            \n                        if (displayLocalNodeMisconfigurationHandler != null) {\n          \n          \n            \n                            displayLocalNodeMisconfigurationHandler.accept(nextStep);\n          \n          \n            \n                        }\n          \n      \n    \n    \n  \n\nAdd a check to prevent possible NullPointerException.", "author": "ripcurlx", "createdAt": "2020-02-26T09:22:59Z", "path": "core/src/main/java/bisq/core/app/BisqSetup.java", "diffHunk": "@@ -482,14 +482,21 @@ private void maybeShowTac() {\n         }\n     }\n \n-    private void detectLocalBitcoinNode(Runnable nextStep) {\n-        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n-        if (config.ignoreLocalBtcNode || baseCurrencyNetwork.isDaoRegTest() || baseCurrencyNetwork.isDaoTestNet()) {\n+    private void maybeCheckLocalBitcoinNode(Runnable nextStep) {\n+        if (localBitcoinNode.willIgnore()) {\n             nextStep.run();\n             return;\n         }\n \n-        localBitcoinNode.detectAndRun(nextStep);\n+        // Here we only want to provide the user with a choice (in a popup) in case a\n+        // local node is detected, but badly configured.\n+        var detectedButMisconfigured = localBitcoinNode.isDetectedButMisconfigured();\n+        if (detectedButMisconfigured) {\n+            displayLocalNodeMisconfigurationHandler.accept(nextStep);", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM4ODQ0MA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384388440", "bodyText": "Using it like that the placeholder will never be filled. Maybe something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n          \n          \n            \n                        log.error(\"Local bitcoin node handshake attempt was unexpectedly interrupted\", ex);", "author": "ripcurlx", "createdAt": "2020-02-26T10:01:40Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM4ODkzNg==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384388936", "bodyText": "Using it like that the placeholder will never be filled. Maybe something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n          \n          \n            \n                        log.error(\"Local bitcoin node handshake attempt was unexpectedly interrupted\", ex);", "author": "ripcurlx", "createdAt": "2020-02-26T10:02:36Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM4OTg0OA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384389848", "bodyText": "Not sure if that makes it so much more readable than simply:\nreturn new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);", "author": "ripcurlx", "createdAt": "2020-02-26T10:04:09Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5MDc4OA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384390788", "bodyText": "Same here:\nreturn new NioClient(serverAddress, peer, connectionTimeout);", "author": "ripcurlx", "createdAt": "2020-02-26T10:05:47Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5MjA3NA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384392074", "bodyText": "I know that you do this because you use Vim, but everyone with a more sophisticated editor has this parameter information next to the null value in the constructor instantiation", "author": "ripcurlx", "createdAt": "2020-02-26T10:07:57Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5MzQwNA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384393404", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static Level silence(Class klass) {\n          \n          \n            \n                private static Level silence(Class<?> klass) {", "author": "ripcurlx", "createdAt": "2020-02-26T10:10:25Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    private static Level silence(Class klass) {", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5MzYzOA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384393638", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n          \n          \n            \n                private static void restoreLoggerLevel(Class<?> klass, Level originalLevel) {", "author": "ripcurlx", "createdAt": "2020-02-26T10:10:49Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5MzgxMw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384393813", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n          \n          \n            \n                private static ch.qos.logback.classic.Logger getLogger(Class<?> klass) {", "author": "ripcurlx", "createdAt": "2020-02-26T10:11:07Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5NDE5MA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384394190", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<Peer>() {\n          \n          \n            \n                    FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<>() {", "author": "ripcurlx", "createdAt": "2020-02-26T10:11:47Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n+        return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(klass);\n+    }\n+\n+    private ListenableFuture<VersionMessage> getVersionMessage(Peer peer) {\n+        SettableFuture<VersionMessage> peerVersionMessageFuture = SettableFuture.create();\n+\n+        var versionHandshakeDone = peer.getVersionHandshakeFuture();\n+        FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<Peer>() {", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5NDU5MQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384394591", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        public void onFailure(Throwable thr) {\n          \n          \n            \n                        public void onFailure(@NotNull Throwable thr) {", "author": "ripcurlx", "createdAt": "2020-02-26T10:12:30Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n+        return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(klass);\n+    }\n+\n+    private ListenableFuture<VersionMessage> getVersionMessage(Peer peer) {\n+        SettableFuture<VersionMessage> peerVersionMessageFuture = SettableFuture.create();\n+\n+        var versionHandshakeDone = peer.getVersionHandshakeFuture();\n+        FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<Peer>() {\n+            public void onSuccess(Peer peer) {\n+                peerVersionMessageFuture.set(peer.getPeerVersionMessage());\n+            }\n+            public void onFailure(Throwable thr) {", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5NjkwMw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384396903", "bodyText": "Can be replaced with:\n(disconnectedPeer, peerCount) -> {", "author": "ripcurlx", "createdAt": "2020-02-26T10:16:38Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n+        return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(klass);\n+    }\n+\n+    private ListenableFuture<VersionMessage> getVersionMessage(Peer peer) {\n+        SettableFuture<VersionMessage> peerVersionMessageFuture = SettableFuture.create();\n+\n+        var versionHandshakeDone = peer.getVersionHandshakeFuture();\n+        FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<Peer>() {\n+            public void onSuccess(Peer peer) {\n+                peerVersionMessageFuture.set(peer.getPeerVersionMessage());\n+            }\n+            public void onFailure(Throwable thr) {\n+                // No action\n+            }\n+        };\n+        Futures.addCallback(\n+                versionHandshakeDone,\n+                fetchPeerVersionMessage\n+        );\n+\n+        PeerDisconnectedEventListener cancelIfConnectionFails =\n+                new PeerDisconnectedEventListener() {\n+                    public void onPeerDisconnected(Peer peer, int peerCount) {", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5NzUxMA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384397510", "bodyText": "That would need also to change this to:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    var peerVersionMessage = peer.getPeerVersionMessage();\n          \n          \n            \n                                    var peerVersionMessage = disconnectedPeer.getPeerVersionMessage();\n          \n      \n    \n    \n  \n\nto prevent scope issues with the other peer passed as parameter. This makes it also easier to distinguish that they are different peers.", "author": "ripcurlx", "createdAt": "2020-02-26T10:17:52Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n+        return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(klass);\n+    }\n+\n+    private ListenableFuture<VersionMessage> getVersionMessage(Peer peer) {\n+        SettableFuture<VersionMessage> peerVersionMessageFuture = SettableFuture.create();\n+\n+        var versionHandshakeDone = peer.getVersionHandshakeFuture();\n+        FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<Peer>() {\n+            public void onSuccess(Peer peer) {\n+                peerVersionMessageFuture.set(peer.getPeerVersionMessage());\n+            }\n+            public void onFailure(Throwable thr) {\n+                // No action\n+            }\n+        };\n+        Futures.addCallback(\n+                versionHandshakeDone,\n+                fetchPeerVersionMessage\n+        );\n+\n+        PeerDisconnectedEventListener cancelIfConnectionFails =\n+                new PeerDisconnectedEventListener() {\n+                    public void onPeerDisconnected(Peer peer, int peerCount) {\n+                        var peerVersionMessageAlreadyReceived =\n+                                peerVersionMessageFuture.isDone();\n+                        if (peerVersionMessageAlreadyReceived) {\n+                            // This method is called whether or not the handshake was\n+                            // successful. In case it was successful, we don't want to do\n+                            // anything here.\n+                            return;\n+                        }\n+                        // In some cases Peer will self-disconnect after receiving\n+                        // node's VersionMessage, but before completing the handshake.\n+                        // In such a case, we want to retrieve the VersionMessage.\n+                        var peerVersionMessage = peer.getPeerVersionMessage();", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5ODM1MA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384398350", "bodyText": "Here again: This is something that helps only someone not using code editors like IntelliJ.", "author": "ripcurlx", "createdAt": "2020-02-26T10:19:26Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",\n+                    port);\n+            client = createClient(peer, port, CONNECTION_TIMEOUT);\n+        } catch (IOException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        ListenableFuture<VersionMessage> peerVersionMessageFuture = getVersionMessage(peer);\n+\n+        Optional<VersionMessage> optionalPeerVersionMessage;\n+\n+        // block for VersionMessage or cancellation (in case of connection failure)\n+        try {\n+            var peerVersionMessage = peerVersionMessageFuture.get();\n+            optionalPeerVersionMessage = Optional.of(peerVersionMessage);\n+        } catch (ExecutionException | InterruptedException | CancellationException ex) {\n+            optionalPeerVersionMessage = Optional.empty();\n+        }\n+\n+        peer.close();\n+        client.closeConnection();\n+\n+        restoreLoggerLevel(NioClient.class, originalNioClientLoggerLevel);\n+        restoreLoggerLevel(NioClientManager.class, originalNioClientManagerLoggerLevel);\n+\n+        return optionalPeerVersionMessage;\n+    }\n+\n+    /* Creates a Peer that is expected to only be used to coerce a VersionMessage out of a\n+     * local Bitcoin node and be closed right after.\n+     */\n+    private static Peer createLocalPeer(int port) throws UnknownHostException {\n+        // TODO: what's the effect of NetworkParameters on handshake?\n+        // i.e. is it fine to just always use MainNetParams?\n+        var networkParameters = new MainNetParams();\n+\n+        // We must construct a BitcoinJ Context before using BitcoinJ. We don't keep a\n+        // reference, because it's automatically kept in a thread local storage.\n+        new Context(networkParameters);\n+\n+        var ourVersionMessage = new VersionMessage(networkParameters, 0);\n+\n+        var localPeerAddress = new PeerAddress(InetAddress.getLocalHost(), port);\n+\n+        AbstractBlockChain blockchain = null;\n+\n+        var peer = new Peer(networkParameters, ourVersionMessage, localPeerAddress, blockchain);\n+        return peer;\n+    }\n+\n+    /* Creates an NioClient that is expected to only be used to coerce a VersionMessage\n+     * out of a local Bitcoin node and be closed right after.\n+     */\n+    private static NioClient createClient(Peer peer, int port, int connectionTimeout) throws IOException {\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLocalHost(), port);\n+\n+        // This initiates the handshake procedure, which, if successful, will complete\n+        // the peerVersionMessageFuture, or be cancelled, in case of failure.\n+        NioClient client = new NioClient(serverAddress, peer, connectionTimeout);\n+\n+        return client;\n+    }\n+\n+    private static Level silence(Class klass) {\n+        var logger = getLogger(klass);\n+        var originalLevel = logger.getLevel();\n+        logger.setLevel(Level.OFF);\n+        return originalLevel;\n+    }\n+\n+    private static void restoreLoggerLevel(Class klass, Level originalLevel) {\n+        getLogger(klass).setLevel(originalLevel);\n+    }\n+\n+    private static ch.qos.logback.classic.Logger getLogger(Class klass) {\n+        return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(klass);\n+    }\n+\n+    private ListenableFuture<VersionMessage> getVersionMessage(Peer peer) {\n+        SettableFuture<VersionMessage> peerVersionMessageFuture = SettableFuture.create();\n+\n+        var versionHandshakeDone = peer.getVersionHandshakeFuture();\n+        FutureCallback<Peer> fetchPeerVersionMessage = new FutureCallback<Peer>() {\n+            public void onSuccess(Peer peer) {\n+                peerVersionMessageFuture.set(peer.getPeerVersionMessage());\n+            }\n+            public void onFailure(Throwable thr) {\n+                // No action\n+            }\n+        };\n+        Futures.addCallback(\n+                versionHandshakeDone,\n+                fetchPeerVersionMessage\n+        );\n+\n+        PeerDisconnectedEventListener cancelIfConnectionFails =\n+                new PeerDisconnectedEventListener() {\n+                    public void onPeerDisconnected(Peer peer, int peerCount) {\n+                        var peerVersionMessageAlreadyReceived =\n+                                peerVersionMessageFuture.isDone();\n+                        if (peerVersionMessageAlreadyReceived) {\n+                            // This method is called whether or not the handshake was\n+                            // successful. In case it was successful, we don't want to do\n+                            // anything here.\n+                            return;\n+                        }\n+                        // In some cases Peer will self-disconnect after receiving\n+                        // node's VersionMessage, but before completing the handshake.\n+                        // In such a case, we want to retrieve the VersionMessage.\n+                        var peerVersionMessage = peer.getPeerVersionMessage();\n+                        if (peerVersionMessage != null) {\n+                            log.info(\"Handshake attempt was interrupted;\"\n+                                    + \" however, the local node's version message was coerced.\");\n+                            peerVersionMessageFuture.set(peerVersionMessage);\n+                        } else {\n+                            log.info(\"Handshake attempt did not result in a version message exchange.\");\n+                            var mayInterruptWhileRunning = true;\n+                            peerVersionMessageFuture.cancel(mayInterruptWhileRunning);", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ3ODAxNg==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384478016", "bodyText": "Is this a win/lose situation where we have to adopt to the majority? It does help me, as I'm not using IntelliJ. Does it disturb IntelliJ users?", "author": "dmos62", "createdAt": "2020-02-26T13:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4ODc4OQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384488789", "bodyText": "I've commited this and other IDE-related changes, since Github back-and-forths can be slow, but I'd like an answer to this.", "author": "dmos62", "createdAt": "2020-02-26T13:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4NTk2NA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384685964", "bodyText": "I agree with @ripcurlx here. In general I think the code should try to stick to the current style of the project. I did not choose this style but I follow it to make it easier for everyone to read the code. If everyone were to follow their own preferred style it would make the code much less readable.\nThis kind of extra variable comes as a surprise here since it's not following the common style and it makes me wonder why it's done in this particular way, as if it has some significance.", "author": "sqrrm", "createdAt": "2020-02-26T18:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5ODM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMzI5MA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384703290", "bodyText": "@sqrrm the reason why I use these is to not have \"anonymous\" values in calls. Example: buildHouse(false) v. buildHouse(withRoof).", "author": "dmos62", "createdAt": "2020-02-26T19:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5ODM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5OTAxMQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384399011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        || baseCurrencyNetwork.isDaoRegTest()\n          \n          \n            \n                            || baseCurrencyNetwork.isDaoRegTest()", "author": "ripcurlx", "createdAt": "2020-02-26T10:20:41Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5OTA4NQ==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384399085", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        || baseCurrencyNetwork.isDaoTestNet();\n          \n          \n            \n                            || baseCurrencyNetwork.isDaoTestNet();", "author": "ripcurlx", "createdAt": "2020-02-26T10:20:49Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5OTQzMA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384399430", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                + \" or the connection was prematurely closed\"\n          \n          \n            \n                                        + \" or the connection was prematurely closed\"", "author": "ripcurlx", "createdAt": "2020-02-26T10:21:25Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5OTU0Mw==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384399543", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                + \" (before a version messages could be coerced)\",\n          \n          \n            \n                                        + \" (before a version messages could be coerced)\",", "author": "ripcurlx", "createdAt": "2020-02-26T10:21:37Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM5OTc2OA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r384399768", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                + \"Bitcoin node (which may or may not be running) on port {}.\",\n          \n          \n            \n                                        + \"Bitcoin node (which may or may not be running) on port {}.\",", "author": "ripcurlx", "createdAt": "2020-02-26T10:22:03Z", "path": "core/src/main/java/bisq/core/btc/nodes/LocalBitcoinNode.java", "diffHunk": "@@ -24,40 +53,321 @@\n     private static final Logger log = LoggerFactory.getLogger(LocalBitcoinNode.class);\n     private static final int CONNECTION_TIMEOUT = 5000;\n \n+    private final Config config;\n+\n     private final int port;\n-    private boolean detected = false;\n+\n+    private Boolean detected;\n+    private Boolean wellConfigured;\n \n     @Inject\n-    public LocalBitcoinNode(@Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+    public LocalBitcoinNode(Config config, @Named(LOCAL_BITCOIN_NODE_PORT) int port) {\n+        this.config = config;\n         this.port = port;\n     }\n \n     /**\n-     * Detect whether a Bitcoin node is running on localhost by attempting to connect\n-     * to the node's port and run the given callback regardless of whether the connection\n-     * was successful. If the connection is successful, subsequent calls to\n-     * {@link #isDetected()} will return {@code true}.\n-     * @param callback code to run after detecting whether the node is running\n-     */\n-    public void detectAndRun(Runnable callback) {\n-        try (Socket socket = new Socket()) {\n-            socket.connect(new InetSocketAddress(\"127.0.0.1\", port), CONNECTION_TIMEOUT);\n-            log.info(\"Local Bitcoin node detected on port {}\", port);\n-            detected = true;\n-        } catch (IOException ex) {\n-            log.info(\"No local Bitcoin node detected on port {}.\", port);\n-        }\n-        callback.run();\n+     * Returns whether Bisq will use a local Bitcoin node. Meaning a usable node was found\n+     * and conditions under which we would ignore it are not met. If we're ignoring the\n+     * local node, a call to this method will not trigger an unnecessary detection\n+     * attempt.\n+     */\n+    public boolean willUse() {\n+        return !willIgnore() && isUsable();\n+    }\n+\n+    /**\n+     * Returns whether Bisq will ignore a local Bitcoin node even if it is usable.\n+     */\n+    public boolean willIgnore() {\n+        BaseCurrencyNetwork baseCurrencyNetwork = config.baseCurrencyNetwork;\n+\n+        // For dao testnet (server side regtest) we disable the use of local bitcoin node to\n+        // avoid confusion if local btc node is not synced with our dao testnet master node.\n+        // Note: above comment was previously in WalletConfig::createPeerGroup.\n+\n+        return config.ignoreLocalBtcNode\n+            || baseCurrencyNetwork.isDaoRegTest()\n+            || baseCurrencyNetwork.isDaoTestNet();\n+    }\n+\n+    /**\n+     * Returns whether or not a local Bitcion node was detected and was well configured\n+     * at the time the checks were performed. All checks are triggered in case they have\n+     * not been performed.\n+     */\n+    public boolean isUsable() {\n+        // If a node is found to be well configured, it implies that it was also detected,\n+        // so this is query is enough to show if the relevant checks were performed and if\n+        // their results are positive.\n+        return isWellConfigured();\n+    }\n+\n+    /**\n+     * Returns whether the local node was detected, but misconfigured. Combination of\n+     * methods isDetected and isWellConfigured.\n+     */\n+    public boolean isDetectedButMisconfigured() {\n+        return isDetected() && !isWellConfigured();\n     }\n \n     /**\n-     * Returns whether or not a Bitcoin node was running on localhost at the time\n-     * {@link #detectAndRun(Runnable)} was called. No further monitoring is performed, so\n-     * if the node goes up or down in the meantime, this method will continue to return\n-     * its original value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand\n-     * how disconnection and reconnection of the local Bitcoin node is actually handled.\n+     * Returns whether a local Bitcoin node was detected. All checks are triggered in case\n+     * they have not been performed. No further monitoring is performed, so if the node\n+     * goes up or down in the meantime, this method will continue to return its original\n+     * value. See {@code MainViewModel#setupBtcNumPeersWatcher} to understand how\n+     * disconnection and reconnection of the local Bitcoin node is actually handled.\n      */\n     public boolean isDetected() {\n+        if (detected == null) {\n+            performChecks();\n+        }\n         return detected;\n     }\n+\n+    /**\n+     * Returns whether the local node's configuration satisfied our checks at the time\n+     * they were performed. All checks are triggered in case they have not been performed.\n+     * We check if the local node is not pruning and has bloom filters enabled.\n+     */\n+    public boolean isWellConfigured() {\n+        if (wellConfigured == null) {\n+            performChecks();\n+        }\n+        return wellConfigured;\n+    }\n+\n+    /* Performs checks that the query methods might be interested in.\n+     */\n+    private void performChecks() {\n+        checkUsable();\n+    }\n+\n+    /* Initiates detection and configuration checks. The results are cached so that the\n+     * public methods isUsable, isDetected, etc. don't trigger a recheck.\n+     */\n+    private void checkUsable() {\n+        var optionalVersionMessage = attemptHandshakeForVersionMessage();\n+        handleHandshakeAttempt(optionalVersionMessage);\n+    }\n+\n+    private void handleHandshakeAttempt(Optional<VersionMessage> optionalVersionMessage) {\n+        if (!optionalVersionMessage.isPresent()) {\n+            detected = false;\n+            wellConfigured = false;\n+            log.info(\"No local Bitcoin node detected on port {},\"\n+                    + \" or the connection was prematurely closed\"\n+                    + \" (before a version messages could be coerced)\",\n+                    port);\n+        } else {\n+            detected = true;\n+            log.info(\"Local Bitcoin node detected on port {}\", port);\n+\n+            var versionMessage = optionalVersionMessage.get();\n+            var configurationCheckResult = checkWellConfigured(versionMessage);\n+\n+            if (configurationCheckResult) {\n+                wellConfigured = true;\n+                log.info(\"Local Bitcoin node found to be well configured\"\n+                        + \" (not pruning and allows bloom filters)\");\n+            } else {\n+                wellConfigured = false;\n+                log.info(\"Local Bitcoin node badly configured\"\n+                        + \" (it is pruning and/or bloom filters are disabled)\");\n+            }\n+        }\n+    }\n+\n+    private static boolean checkWellConfigured(VersionMessage versionMessage) {\n+        var notPruning = versionMessage.hasBlockChain();\n+        var supportsAndAllowsBloomFilters =\n+                isBloomFilteringSupportedAndEnabled(versionMessage);\n+        return notPruning && supportsAndAllowsBloomFilters;\n+    }\n+\n+    /* Method backported from upstream bitcoinj: at the time of writing, our version is\n+     * not BIP111-aware.\n+     * Source routines and data can be found in Bitcoinj under:\n+     * core/src/main/java/org/bitcoinj/core/VersionMessage.java\n+     * and\n+     * core/src/main/java/org/bitcoinj/core/NetworkParameters.java\n+     */\n+    private static boolean isBloomFilteringSupportedAndEnabled(VersionMessage versionMessage) {\n+        // A service bit that denotes whether the peer supports BIP37 bloom filters or\n+        // not. The service bit is defined in BIP111.\n+        int NODE_BLOOM = 1 << 2;\n+\n+        int BLOOM_FILTERS_BIP37_PROTOCOL_VERSION = 70000;\n+        var whenBloomFiltersWereIntroduced = BLOOM_FILTERS_BIP37_PROTOCOL_VERSION;\n+\n+        int BLOOM_FILTERS_BIP111_PROTOCOL_VERSION = 70011;\n+        var whenBloomFiltersWereDisabledByDefault = BLOOM_FILTERS_BIP111_PROTOCOL_VERSION;\n+\n+        int clientVersion = versionMessage.clientVersion;\n+        long localServices = versionMessage.localServices;\n+\n+        if (clientVersion >= whenBloomFiltersWereIntroduced\n+                && clientVersion < whenBloomFiltersWereDisabledByDefault)\n+            return true;\n+        return (localServices & NODE_BLOOM) == NODE_BLOOM;\n+    }\n+\n+    /* Performs a blocking Bitcoin protocol handshake, which includes exchanging version\n+     * messages and acks. Its purpose is to check if a local Bitcoin node is running,\n+     * and, if it is, check its advertised configuration. The returned Optional is empty,\n+     * if a local peer wasn't found, or if handshake failed for some reason. This method\n+     * could be noticably simplified, by turning connection failure callback into a\n+     * future and using a first-future-to-complete type of construct, but I couldn't find\n+     * a ready-made implementation.\n+     */\n+    private Optional<VersionMessage> attemptHandshakeForVersionMessage() {\n+        Peer peer;\n+        try {\n+            peer = createLocalPeer(port);\n+        } catch (UnknownHostException ex) {\n+            log.error(\"Local bitcoin node handshake attempt unexpectedly threw: {}\", ex);\n+            return Optional.empty();\n+        }\n+\n+        /* We temporarily silence BitcoinJ NioClient's and NioClientManager's loggers,\n+         * because when a local Bitcoin node is not found they pollute console output\n+         * with \"connection refused\" error messages.\n+         */\n+        var originalNioClientLoggerLevel = silence(NioClient.class);\n+        var originalNioClientManagerLoggerLevel = silence(NioClientManager.class);\n+\n+        NioClient client;\n+\n+        try {\n+            log.info(\"Initiating attempt to connect to and handshake with a local \"\n+                    + \"Bitcoin node (which may or may not be running) on port {}.\",", "originalCommit": "2a57ecddfc41b1d0219155df9fac2e9fa6780181", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6dec780ab4ee828433af4c0212044fe96f9f1d04", "url": "https://github.com/bisq-network/bisq/commit/6dec780ab4ee828433af4c0212044fe96f9f1d04", "message": "Minor requested changes (github batch)\n\nCo-Authored-By: Christoph Atteneder <christoph.atteneder@gmail.com>", "committedDate": "2020-02-26T13:21:03Z", "type": "commit"}, {"oid": "a92b6ad9dcda54c5ff3e1fb8893034e3049097e9", "url": "https://github.com/bisq-network/bisq/commit/a92b6ad9dcda54c5ff3e1fb8893034e3049097e9", "message": "Minor requested changes (non-github batch)", "committedDate": "2020-02-26T13:34:08Z", "type": "commit"}, {"oid": "30578bfa9dc5e01372e118a9b1bcd15eb61e5085", "url": "https://github.com/bisq-network/bisq/commit/30578bfa9dc5e01372e118a9b1bcd15eb61e5085", "message": "Have detection work on other network modes\n\nThis makes detection work on other BTC network modes, not only mainnet.", "committedDate": "2020-02-26T16:09:01Z", "type": "commit"}, {"oid": "fdaced460fea014c034c30f83e9103c5744300df", "url": "https://github.com/bisq-network/bisq/commit/fdaced460fea014c034c30f83e9103c5744300df", "message": "Changes to Background information popup", "committedDate": "2020-02-26T16:20:55Z", "type": "commit"}, {"oid": "b93ca2b2b1dd24cd53014f9bd85269d572fde032", "url": "https://github.com/bisq-network/bisq/commit/b93ca2b2b1dd24cd53014f9bd85269d572fde032", "message": "Polish formatting", "committedDate": "2020-02-26T20:24:38Z", "type": "commit"}, {"oid": "c1a99ccc55b57cc784f3b5c28c6dd48e99ad1291", "url": "https://github.com/bisq-network/bisq/commit/c1a99ccc55b57cc784f3b5c28c6dd48e99ad1291", "message": "Polish LocalBitcoinNode method names and visibility\n\n - Rename #willUse => #shouldBeUsed\n - Rename #willIgnore => #shouldBeIgnored\n - Reduce visibility of methods where appropriate\n - Edit Javadoc typos and use @link syntax where appropriate", "committedDate": "2020-02-27T08:35:36Z", "type": "commit"}, {"oid": "57b7041dfefba2e0c370468e150ca6e042df35c4", "url": "https://github.com/bisq-network/bisq/commit/57b7041dfefba2e0c370468e150ca6e042df35c4", "message": "Remove unnecessary LOCAL_BITCOIN_NODE_PORT constant\n\nThis was originally added with the intention that the local Bitcoin node\nport could be customized, but in fact it never could be, because Guice\nconfiguration always hard-wired the value to the default port for the\nCurrentBaseNetwork's Parameters (eg. 8333 for BTC_MAINNET).\n\nThis change removes the constant, removes any Guice wiring and injection\nand localizes the hard-coded assignment to the LocalBitcoinNode\nconstructor to simplify and make things explicit.\n\nIf it is desired to allow users to specify a custom port for their local\nBitcoin node, a proper option shoud be added to Config. In the meantime,\nusers may work around this by using `--btcNodes=localhost:4242` where\n4242 is the custom port. Note however, that the pruning and bloom filter\nchecks will not occur in this case as the provided node address will not\nbeing treated as a LocalBitcoinNode.", "committedDate": "2020-02-27T08:53:40Z", "type": "commit"}, {"oid": "85e4515f53116c0fbec27e4ecee0eaaf9313ef4c", "url": "https://github.com/bisq-network/bisq/commit/85e4515f53116c0fbec27e4ecee0eaaf9313ef4c", "message": "Remove reference to removed constant", "committedDate": "2020-02-27T11:14:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA2MzY5OA==", "url": "https://github.com/bisq-network/bisq/pull/3982#discussion_r385063698", "bodyText": "Good catch, thanks @dmos62.", "author": "cbeams", "createdAt": "2020-02-27T11:16:54Z", "path": "core/src/main/java/bisq/core/app/misc/ModuleForAppWithP2p.java", "diffHunk": "@@ -50,7 +50,6 @@\n import java.io.File;\n \n import static bisq.common.config.Config.*;\n-import static bisq.core.btc.nodes.LocalBitcoinNode.LOCAL_BITCOIN_NODE_PORT;", "originalCommit": "85e4515f53116c0fbec27e4ecee0eaaf9313ef4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}