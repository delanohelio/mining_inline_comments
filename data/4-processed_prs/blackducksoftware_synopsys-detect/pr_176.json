{"pr_number": 176, "pr_title": "DotNet 3", "pr_createdAt": "2020-05-27T19:26:47Z", "pr_url": "https://github.com/blackducksoftware/synopsys-detect/pull/176", "timeline": [{"oid": "a8d1717afb6b4e46dd647303ca59e9cda20291ad", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/a8d1717afb6b4e46dd647303ca59e9cda20291ad", "message": "feat(nuget): Begin implementing support for dotnet 3.1 runtime", "committedDate": "2020-05-22T14:26:09Z", "type": "commit"}, {"oid": "8bf0ca56328aafa79be975ec7f8d59cad1260089", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/8bf0ca56328aafa79be975ec7f8d59cad1260089", "message": "feat(nuget): Add semantic version parsing for dotnet runtimes and logic to determine which runtime to use", "committedDate": "2020-05-22T14:26:17Z", "type": "commit"}, {"oid": "71e80827f6f24ea1dd7ac7b90d8f6fda2f13affe", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/71e80827f6f24ea1dd7ac7b90d8f6fda2f13affe", "message": "feat(nuget): Make version parsing more generic", "committedDate": "2020-05-22T15:11:34Z", "type": "commit"}, {"oid": "54d35c2519c3b0917c2afadd84202373d97cb7d0", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/54d35c2519c3b0917c2afadd84202373d97cb7d0", "message": "Add artifactory constants for dotnet3", "committedDate": "2020-05-27T13:42:14Z", "type": "commit"}, {"oid": "971dcc60ed218f8e7bf38bc8b745c03a50b89488", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/971dcc60ed218f8e7bf38bc8b745c03a50b89488", "message": "feat(nuget): Create additional abstraction for redundant nuget code and clean up TODOs", "committedDate": "2020-05-27T15:27:04Z", "type": "commit"}, {"oid": "e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7", "message": "Merge branch 'master' into gk_support_dotnet_3", "committedDate": "2020-05-27T15:27:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxNDY0NQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r431414645", "bodyText": "I'd rather we separated the invocation of the command from the parsing and matching - it would make the unit tests simpler.", "author": "taikuukaits", "createdAt": "2020-05-27T20:12:35Z", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/NugetRuntimeResolver.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableOutput;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableRunner;\n+import com.synopsys.integration.detectable.detectable.executable.ExecutableRunnerException;\n+\n+public class NugetRuntimeResolver {", "originalCommit": "e7d2ae7bd907477bc4ba79fa562689ca8e6ed3a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b58ca7464daed344c2e3da25963f107ec859444", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/4b58ca7464daed344c2e3da25963f107ec859444", "message": "fix: resolve sonar code smells", "committedDate": "2020-05-27T20:14:38Z", "type": "commit"}, {"oid": "fc0d76289939b1c4e425e66876a9249ad000d773", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/fc0d76289939b1c4e425e66876a9249ad000d773", "message": "refactor(nuget): Split dotnet runtime finding and runtime verifying into separate classes", "committedDate": "2020-05-28T12:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODYyMA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432048620", "bodyText": "I think this is improved, but I think we could isolate more if you take in a List runtimes instead of taking the DotNetRuntimeFinder.", "author": "taikuukaits", "createdAt": "2020-05-28T18:49:39Z", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"\n+                                                                             + DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER\n+                                                                             + \"(\\\\.[0-9]+){0,2}(\\\\s){1}\\\\[.+\\\\]\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+\n+    private DotNetRuntimeFinder dotNetRuntimeFinder;\n+\n+    public DotNetRuntimeAvailabilityVerifier(DotNetRuntimeFinder dotNetRuntimeFinder) {\n+        this.dotNetRuntimeFinder = dotNetRuntimeFinder;\n+    }\n+\n+    public boolean isRuntimeAvailable(String semanticVersion) throws DetectableException {\n+        String[] versionTokenStrings = StringUtils.split(semanticVersion, '.');\n+        List<Integer> numericVersionTokens = Arrays.stream(versionTokenStrings)\n+                                                 .filter(NumberUtils::isDigits)\n+                                                 .map(NumberUtils::toInt)\n+                                                 .collect(Collectors.toList());\n+\n+        if (numericVersionTokens.isEmpty()) {\n+            logger.warn(\"Invalid semantic version parameter for dotnet runtime query\");\n+            return false;\n+        }\n+\n+        Integer[] intArray = new Integer[numericVersionTokens.size()];\n+        return isRuntimeAvailable(numericVersionTokens.toArray(intArray));\n+    }\n+\n+    public boolean isRuntimeAvailable(Integer... versionTokens) throws DetectableException {\n+        List<String> runtimes = dotNetRuntimeFinder.listAvailableRuntimes();", "originalCommit": "fc0d76289939b1c4e425e66876a9249ad000d773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1OTM3MQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432059371", "bodyText": "The reason I was hesitant about doing something like that is that it would allow you to pass in an arbitrary list of Strings. Even if we wrapped those Strings in a new type of object (e.g. DotNetRuntimeModel or something), I think these are concerns that are already correctly coupled. Decoupling further would essentially make this a semVer regex util that just so happens to have a constant pattern related to dotnet runtimes. If we want to go that route, that's fine (obviously we would move the runtime pattern constant somewhere else), but I think that is what we're really talking about if we decouple this further.", "author": "gkillough", "createdAt": "2020-05-28T19:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMzI1Ng==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432203256", "bodyText": "Gotcha, I can say it is very typical for parsers to take in a list of strings, such as NpmParser. And it is convention we know you can't just pass an arbitrary list of strings. That said I would not be opposed to a small data class like DotNetRuntimeResult(List runtimes).\nPersonally not having to create a mock runtime executable and eliminating the explicit dependency outweigh protecting someone from passing wrong strings. But I would also be fine with what you have. Depends on the type of change that comes in next.", "author": "taikuukaits", "createdAt": "2020-05-29T01:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0ODYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODU0NA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432138544", "bodyText": "Not in love with removing all the finals, but since we don't have an official rule on it, it's fine.", "author": "JakeMathews", "createdAt": "2020-05-28T21:37:24Z", "path": "src/main/java/com/synopsys/integration/detect/RunBeanConfiguration.java", "diffHunk": "@@ -139,7 +141,7 @@ public AirGapPathFinder airGapPathFinder() {\n \n     @Bean\n     public CodeLocationNameGenerator codeLocationNameService() {\n-        final String codeLocationNameOverride = detectConfiguration.getValueOrEmpty(DetectProperties.Companion.getDETECT_CODE_LOCATION_NAME()).orElse(null);", "originalCommit": "fc0d76289939b1c4e425e66876a9249ad000d773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzMzA1Mg==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432433052", "bodyText": "My save actions are configured based on the Engineer Onboarding on Confluence, but if you guys have a different preference in Detect, I can update the settings for the project accordingly. I assumed the finals were just left over from when we still had that convention mandated.", "author": "gkillough", "createdAt": "2020-05-29T11:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3NTAxOQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433975019", "bodyText": "If you could add them back for now that would be great.", "author": "JakeMathews", "createdAt": "2020-06-02T15:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzOTgzNw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432139837", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n          \n          \n            \n                    if (nugetAirGapPath.isPresent()) {\n          \n          \n            \n                        return new File(nugetAirGapPath.get(), childName);\n          \n          \n            \n                    }\n          \n          \n            \n                    throw new DetectableException(\"Could not get the nuget air gap path\");\n          \n          \n            \n                    return airGapInspectorPaths.getNugetInspectorAirGapFile()\n          \n          \n            \n                        .map(nugetAirGapPath -> new File(nugetAirGapPath, childName))\n          \n          \n            \n                        .orElseThrow(() -> new DetectableException(\"Could not get the nuget air gap path\"));", "author": "JakeMathews", "createdAt": "2020-05-28T21:40:27Z", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/AirgapNugetInspectorLocator.java", "diffHunk": "@@ -26,23 +26,39 @@\n import java.util.Optional;\n \n import com.synopsys.integration.detect.workflow.airgap.AirGapInspectorPaths;\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n \n public class AirgapNugetInspectorLocator implements NugetInspectorLocator {\n+    public static final String INSPECTOR_DIR_DOTNET3 = \"nuget_dotnet3\";\n+    public static final String INSPECTOR_DIR_DOTNET = \"nuget_dotnet\";\n+    public static final String INSPECTOR_DIR_CLASSIC = \"nuget_classic\";\n+\n     private final AirGapInspectorPaths airGapInspectorPaths;\n \n-    public AirgapNugetInspectorLocator(final AirGapInspectorPaths airGapInspectorPaths) {\n+    public AirgapNugetInspectorLocator(AirGapInspectorPaths airGapInspectorPaths) {\n         this.airGapInspectorPaths = airGapInspectorPaths;\n     }\n \n     @Override\n-    public File locateExeInspector() {\n-        final Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n-        return new File(nugetAirGapPath.get(), \"nuget_classic\"); // TODO: Why is there no ifPresent() check?\n+    public File locateDotnet3Inspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_DOTNET3);\n+    }\n+\n+    @Override\n+    public File locateDotnetInspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_DOTNET);\n     }\n \n     @Override\n-    public File locateDotnetInspector() {\n-        final Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n-        return new File(nugetAirGapPath.get(), \"nuget_dotnet\"); // TODO: Why is there no ifPresent() check?\n+    public File locateExeInspector() throws DetectableException {\n+        return locateInspector(INSPECTOR_DIR_CLASSIC);\n+    }\n+\n+    private File locateInspector(String childName) throws DetectableException {\n+        Optional<File> nugetAirGapPath = airGapInspectorPaths.getNugetInspectorAirGapFile();\n+        if (nugetAirGapPath.isPresent()) {\n+            return new File(nugetAirGapPath.get(), childName);\n+        }\n+        throw new DetectableException(\"Could not get the nuget air gap path\");", "originalCommit": "fc0d76289939b1c4e425e66876a9249ad000d773", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDQ1NA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432140454", "bodyText": "This seems like a very complicated Regex that will match small finite list of Strings. Perhaps a more simple lookup and replace is appropriate.", "author": "JakeMathews", "createdAt": "2020-05-28T21:41:50Z", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+\n+public class DotNetRuntimeAvailabilityVerifier {\n+    private static final String DOTNET_RUNTIME_PATTERN_VERSION_PLACEHOLDER = \"<DOTNET_VERSION>\";\n+    private static final String DOTNET_RUNTIME_PATTERN_WITHOUT_VERSION = \"Microsoft\\\\.(AspNetCore|NETCore){1}\\\\.(All|App){1}(\\\\s){1}\"", "originalCommit": "fc0d76289939b1c4e425e66876a9249ad000d773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzNDgzMA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432434830", "bodyText": "Yeah, I talked to @ekerwin about regex usage usage yesterday. I will be updating the logic here to be more universally maintainable.", "author": "gkillough", "createdAt": "2020-05-29T11:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjM5Mw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432142393", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final String overrideVersion;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private final String overrideVersion;\n          \n      \n    \n    \n  \n\nIf overrideVersion is nullable, can you add this annotation?\nIf it isn't actually nullable, why is it wrapped in Optional.ofNullable() below?", "author": "JakeMathews", "createdAt": "2020-05-28T21:46:23Z", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/OnlineNugetInspectorLocator.java", "diffHunk": "@@ -27,36 +27,40 @@\n \n import com.synopsys.integration.detect.workflow.file.DirectoryManager;\n import com.synopsys.integration.detectable.detectable.exception.DetectableException;\n+import com.synopsys.integration.function.ThrowingBiFunction;\n \n public class OnlineNugetInspectorLocator implements NugetInspectorLocator {\n     private final NugetInspectorInstaller nugetInspectorInstaller;\n     private final DirectoryManager directoryManager;\n     private final String overrideVersion;", "originalCommit": "fc0d76289939b1c4e425e66876a9249ad000d773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2MjExOQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432462119", "bodyText": "This was the state I found the source in and was trying to minimize my impact (I believe it's passed through in a couple places). That said, this is definitely a good change and I'll go ahead and make it.", "author": "gkillough", "createdAt": "2020-05-29T12:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzI5Mw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432143293", "bodyText": "You are using the wrong version of junit for some of your asserts.", "author": "JakeMathews", "createdAt": "2020-05-28T21:48:31Z", "path": "src/test/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/DotNetRuntimeAvailabilityVerifierTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.synopsys.integration.detect.tool.detector.inspectors.nuget;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+import org.junit.Assert;", "originalCommit": "fc0d76289939b1c4e425e66876a9249ad000d773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2NTM0Nw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432465347", "bodyText": "Good catch.", "author": "gkillough", "createdAt": "2020-05-29T12:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MzY5MQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r432143691", "bodyText": "While your at it, could you replace this with a String.format()?", "author": "JakeMathews", "createdAt": "2020-05-28T21:49:32Z", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "diffHunk": "@@ -97,61 +101,62 @@ private NugetInspector install() throws IntegrationException {\n         }\n \n         if (useDotnet) {\n-            final File dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n-            return findDotnetCoreInspector(dotnetFolder, dotnetExecutable);\n+            File dotnetFolder;\n+            if (dotNetRuntimeVerifier.isRuntimeAvailable(3, 1)) {\n+                dotnetFolder = nugetInspectorLocator.locateDotnet3Inspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"NugetDotnet3Inspector.dll\");\n+            } else {\n+                dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"BlackduckNugetInspector.dll\");\n+            }\n         } else {\n-            final File classicFolder = nugetInspectorLocator.locateExeInspector();\n+            File classicFolder = nugetInspectorLocator.locateExeInspector();\n             return findExeInspector(classicFolder);\n         }\n     }\n \n-    private DotNetCoreNugetInspector findDotnetCoreInspector(final File nupkgFolder, final File dotnetExecutable) throws DetectableException {\n-        //new inspector\n-        final String dotnetInspectorName = \"BlackduckNugetInspector.dll\";\n-        logger.debug(\"Searching for: \" + dotnetInspectorName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, dotnetInspectorName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new DotNetCoreNugetInspector(dotnetExecutable, inspectorExe, executableRunner);\n-        } else {\n-            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + dotnetInspectorName + \" in \" + toolsFolder.toString());\n-        }\n+    private NugetInspector findDotnetCoreInspector(File nupkgFolder, File dotnetExecutable, String dotnetInspectorName) throws DetectableException {\n+        Function<String, NugetInspector> constructor = (String exePath) -> new DotNetCoreNugetInspector(dotnetExecutable, exePath, executableRunner);\n+        return findInspector(nupkgFolder, dotnetInspectorName, constructor);\n+    }\n+\n+    //original inspector\n+    private NugetInspector findExeInspector(File nupkgFolder) throws DetectableException {\n+        String exeName = nugetInspectorName + \".exe\";\n+        Function<String, NugetInspector> constructor = (String exePath) -> new ExeNugetInspector(executableRunner, exePath);\n+        return findInspector(nupkgFolder, exeName, constructor);\n     }\n \n-    private ExeNugetInspector findExeInspector(final File nupkgFolder) throws DetectableException {\n-        //original inspector\n-        final String exeName = nugetInspectorName + \".exe\";\n-        logger.debug(\"Searching for: \" + exeName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n+    private NugetInspector findInspector(File nupkgFolder, String inspectorName, Function<String, NugetInspector> inspectorInitializer) throws DetectableException {\n+        logger.debug(\"Searching for: \" + inspectorName);\n+        File toolsFolder = new File(nupkgFolder, \"tools\");\n         logger.debug(\"Searching in: \" + toolsFolder.getAbsolutePath());\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, exeName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new ExeNugetInspector(executableRunner, inspectorExe);\n+        Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();\n+        if (foundExecutable.isPresent() && foundExecutable.get().exists()) {\n+            String inspectorExecutable = foundExecutable.get().getAbsolutePath();\n+            logger.debug(\"Found nuget inspector: {}\", inspectorExecutable);\n+            return inspectorInitializer.apply(inspectorExecutable);\n         } else {\n-            throw new DetectableException(\"Unable to find nuget inspector named '\" + exeName + \"' in \" + toolsFolder.getAbsolutePath());\n+            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + inspectorName + \" in \" + toolsFolder.toString());", "originalCommit": "fc0d76289939b1c4e425e66876a9249ad000d773", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9284befa605a6005182e049036207d27594213fd", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/9284befa605a6005182e049036207d27594213fd", "message": "fix: Resolve several issues discovered in code review", "committedDate": "2020-05-29T13:46:57Z", "type": "commit"}, {"oid": "71449bce2b74b908cf65248499682ecf21d24600", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/71449bce2b74b908cf65248499682ecf21d24600", "message": "fix: Replace regex functionality with java code", "committedDate": "2020-05-29T16:23:27Z", "type": "commit"}, {"oid": "4bb964fc56089f27be817b8393d584b81dc32bdc", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/4bb964fc56089f27be817b8393d584b81dc32bdc", "message": "refactor: Replace POC of dotnet runtime regex alternative with less verbose implementation", "committedDate": "2020-06-01T13:34:01Z", "type": "commit"}, {"oid": "b2c90baa54bff4e64cf9ed593db943d27a8b7ae1", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b2c90baa54bff4e64cf9ed593db943d27a8b7ae1", "message": "refactor: Clean up dotnet runtime parsing logic", "committedDate": "2020-06-01T14:30:46Z", "type": "commit"}, {"oid": "fe6b9786dcd742f815418fa07991d38144373bd4", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/fe6b9786dcd742f815418fa07991d38144373bd4", "message": "Merge branch 'gk_support_dotnet_3_no_regex' into gk_support_dotnet_3", "committedDate": "2020-06-02T12:38:07Z", "type": "commit"}, {"oid": "63f520d6d7e3b77dd262431db547099903af669e", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/63f520d6d7e3b77dd262431db547099903af669e", "message": "Merge branch 'master' into gk_support_dotnet_3", "committedDate": "2020-06-02T12:38:36Z", "type": "commit"}, {"oid": "fcd5c3fd90a5c7ae624fce221939e5abb9803646", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/fcd5c3fd90a5c7ae624fce221939e5abb9803646", "message": "refactor: Make method name plural", "committedDate": "2020-06-02T12:46:40Z", "type": "commit"}, {"oid": "5cde737c321f89502e64f6f57ba39629eebd72cd", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/5cde737c321f89502e64f6f57ba39629eebd72cd", "message": "chore: Add copyright header to new files", "committedDate": "2020-06-02T15:35:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3ODM1MA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433978350", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();\n          \n          \n            \n                    File foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().\n          \n          \n            \n                        .filter(File::exists)\n          \n          \n            \n                        .findFirst()\n          \n          \n            \n                        .orElseThrow(() -> new DetectableException(String.format(\"Unable to find nuget inspector, looking for %s in %s\", inspectorName, toolsFolder.toString())));", "author": "JakeMathews", "createdAt": "2020-06-02T15:45:52Z", "path": "src/main/java/com/synopsys/integration/detect/tool/detector/inspectors/nuget/LocatorNugetInspectorResolver.java", "diffHunk": "@@ -97,61 +102,62 @@ private NugetInspector install() throws IntegrationException {\n         }\n \n         if (useDotnet) {\n-            final File dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n-            return findDotnetCoreInspector(dotnetFolder, dotnetExecutable);\n+            File dotnetFolder;\n+            if (dotNetRuntimeManager.isRuntimeAvailable(3, 1)) {\n+                dotnetFolder = nugetInspectorLocator.locateDotnet3Inspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"NugetDotnet3Inspector.dll\");\n+            } else {\n+                dotnetFolder = nugetInspectorLocator.locateDotnetInspector();\n+                return findDotnetCoreInspector(dotnetFolder, dotnetExecutable, \"BlackduckNugetInspector.dll\");\n+            }\n         } else {\n-            final File classicFolder = nugetInspectorLocator.locateExeInspector();\n+            File classicFolder = nugetInspectorLocator.locateExeInspector();\n             return findExeInspector(classicFolder);\n         }\n     }\n \n-    private DotNetCoreNugetInspector findDotnetCoreInspector(final File nupkgFolder, final File dotnetExecutable) throws DetectableException {\n-        //new inspector\n-        final String dotnetInspectorName = \"BlackduckNugetInspector.dll\";\n-        logger.debug(\"Searching for: \" + dotnetInspectorName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, dotnetInspectorName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new DotNetCoreNugetInspector(dotnetExecutable, inspectorExe, executableRunner);\n-        } else {\n-            throw new DetectableException(\"Unable to find nuget inspector, looking for \" + dotnetInspectorName + \" in \" + toolsFolder.toString());\n-        }\n+    private NugetInspector findDotnetCoreInspector(File nupkgFolder, File dotnetExecutable, String dotnetInspectorName) throws DetectableException {\n+        Function<String, NugetInspector> constructor = (String exePath) -> new DotNetCoreNugetInspector(dotnetExecutable, exePath, executableRunner);\n+        return findInspector(nupkgFolder, dotnetInspectorName, constructor);\n+    }\n+\n+    //original inspector\n+    private NugetInspector findExeInspector(File nupkgFolder) throws DetectableException {\n+        String exeName = nugetInspectorName + \".exe\";\n+        Function<String, NugetInspector> constructor = (String exePath) -> new ExeNugetInspector(executableRunner, exePath);\n+        return findInspector(nupkgFolder, exeName, constructor);\n     }\n \n-    private ExeNugetInspector findExeInspector(final File nupkgFolder) throws DetectableException {\n-        //original inspector\n-        final String exeName = nugetInspectorName + \".exe\";\n-        logger.debug(\"Searching for: \" + exeName);\n-        final File toolsFolder = new File(nupkgFolder, \"tools\");\n+    private NugetInspector findInspector(File nupkgFolder, String inspectorName, Function<String, NugetInspector> inspectorInitializer) throws DetectableException {\n+        logger.debug(\"Searching for: \" + inspectorName);\n+        File toolsFolder = new File(nupkgFolder, \"tools\");\n         logger.debug(\"Searching in: \" + toolsFolder.getAbsolutePath());\n-        final Optional<File> foundExe = fileFinder.findFiles(toolsFolder, exeName, 3).stream().findFirst();\n-        if (foundExe.isPresent() && foundExe.get().exists()) {\n-            final String inspectorExe = foundExe.get().getAbsolutePath();\n-            logger.debug(\"Found nuget inspector: \" + inspectorExe);\n-            return new ExeNugetInspector(executableRunner, inspectorExe);\n+        Optional<File> foundExecutable = fileFinder.findFiles(toolsFolder, inspectorName, 3).stream().findFirst();", "originalCommit": "5cde737c321f89502e64f6f57ba39629eebd72cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3OTMxMQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/176#discussion_r433979311", "bodyText": "I think we don't need the if/else if we do the filtering in the Stream.", "author": "JakeMathews", "createdAt": "2020-06-02T15:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3ODM1MA=="}], "type": "inlineReview"}, {"oid": "3bf080bbf63bfb6d7610665cbd1955d08765384c", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/3bf080bbf63bfb6d7610665cbd1955d08765384c", "message": "fix: Add finals to local variables based on project preference", "committedDate": "2020-06-02T16:15:49Z", "type": "commit"}, {"oid": "f50c14e0a3a0e44d685e03a338cc0b0da0fd2675", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/f50c14e0a3a0e44d685e03a338cc0b0da0fd2675", "message": "Merge branch 'master' into gk_support_dotnet_3", "committedDate": "2020-06-02T18:48:40Z", "type": "commit"}]}