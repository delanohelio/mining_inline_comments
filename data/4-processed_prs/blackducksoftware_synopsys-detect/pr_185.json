{"pr_number": 185, "pr_title": "Sb bazel haskell cabal library rule", "pr_createdAt": "2020-06-09T19:52:22Z", "pr_url": "https://github.com/blackducksoftware/synopsys-detect/pull/185", "timeline": [{"oid": "9ddf8dc6c30e3ec4ff54b0e3c2877bf089abea38", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/9ddf8dc6c30e3ec4ff54b0e3c2877bf089abea38", "message": "refactor: class renaming in preparation for making bazel pipelines more generic, in preparation for adding haskell rule support", "committedDate": "2020-06-05T14:54:39Z", "type": "commit"}, {"oid": "d696bb3066847867a170bbb469d3a810eef0aa47", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/d696bb3066847867a170bbb469d3a810eef0aa47", "message": "feat(bazel): added Pipeline and associated classes", "committedDate": "2020-06-05T14:55:35Z", "type": "commit"}, {"oid": "faa81daaa4ab7e6f63619c69b4c6e079aec52e48", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/faa81daaa4ab7e6f63619c69b4c6e079aec52e48", "message": "refactor(bazel): migrating to Pipeline object...", "committedDate": "2020-06-05T19:26:24Z", "type": "commit"}, {"oid": "d6ff6fe813fa286ca7e31d129e6ee1da7153cbc7", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/d6ff6fe813fa286ca7e31d129e6ee1da7153cbc7", "message": "test: adapting tests to new bazel class structure", "committedDate": "2020-06-05T19:51:36Z", "type": "commit"}, {"oid": "0e3f4b7bbeaf71c3e1c0c0ad89aca4f9e1602bef", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/0e3f4b7bbeaf71c3e1c0c0ad89aca4f9e1602bef", "message": "feat(bazel): added (empty so far) FinalStepJsonProtoHaskellCabalLibrary", "committedDate": "2020-06-05T20:09:37Z", "type": "commit"}, {"oid": "bf11683fe3b225e821c9416c7cd83960f7e9ea91", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/bf11683fe3b225e821c9416c7cd83960f7e9ea91", "message": "refactor: bazel test pkg rename", "committedDate": "2020-06-05T20:10:34Z", "type": "commit"}, {"oid": "6d9c8a78653a871eb11f80015c27ef39b0083e02", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/6d9c8a78653a871eb11f80015c27ef39b0083e02", "message": "feat(bazel): Adding FinalStepJsonProtoHaskellCabalLibraries (in progress...)", "committedDate": "2020-06-05T22:53:05Z", "type": "commit"}, {"oid": "7a308d1f78f605e6067225e587923dc730d83935", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/7a308d1f78f605e6067225e587923dc730d83935", "message": "feat: continued development", "committedDate": "2020-06-07T18:08:02Z", "type": "commit"}, {"oid": "5511fa1b21063019dfc35d235a2bbf7cf2cc4432", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/5511fa1b21063019dfc35d235a2bbf7cf2cc4432", "message": "feat(bazel): continued work on FinalStepJsonProtoHaskellCabalLibrary", "committedDate": "2020-06-08T13:36:03Z", "type": "commit"}, {"oid": "4f0109d30800bb6e353cfc9c580950c673419402", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/4f0109d30800bb6e353cfc9c580950c673419402", "message": "feat(bazel): FinalStepJsonProtoHaskellCabalLibraries is passing test", "committedDate": "2020-06-08T16:07:20Z", "type": "commit"}, {"oid": "709045abac451a400de3f21b03942209df1de7a2", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/709045abac451a400de3f21b03942209df1de7a2", "message": "refactor: refactoring bazel haskell", "committedDate": "2020-06-08T19:11:05Z", "type": "commit"}, {"oid": "17fc2d4619777fd3688067fbb55877fff8e614c5", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/17fc2d4619777fd3688067fbb55877fff8e614c5", "message": "feat(bazel): Added haskell cabal library pipeline", "committedDate": "2020-06-08T20:16:51Z", "type": "commit"}, {"oid": "e447fa3f5dfaf3d51c24b0e8beb9b063469505ce", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/e447fa3f5dfaf3d51c24b0e8beb9b063469505ce", "message": "Merge commit 'd19ad856095068ace4a71441876158ed9f86124c' into sb_bazelHaskellCabalLibraryRule", "committedDate": "2020-06-08T21:03:11Z", "type": "commit"}, {"oid": "b167cf68cc19c88921432d495348e80b283cbd0d", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b167cf68cc19c88921432d495348e80b283cbd0d", "message": "refactor: bazel haskell: naming", "committedDate": "2020-06-08T21:17:34Z", "type": "commit"}, {"oid": "bb535495f7ac01fc77e2597d79887ab1dcfae0d5", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/bb535495f7ac01fc77e2597d79887ab1dcfae0d5", "message": "refactor: bazel haskell refactoring", "committedDate": "2020-06-08T22:00:30Z", "type": "commit"}, {"oid": "9b5a62b08cdad7e6682cd18a25733c22247a8d00", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/9b5a62b08cdad7e6682cd18a25733c22247a8d00", "message": "Merge branch 'master' into sb_bazelHaskellCabalLibraryRule", "committedDate": "2020-06-09T18:16:39Z", "type": "commit"}, {"oid": "93b8051b296b3c874aaaeba54d38521101cd32c9", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/93b8051b296b3c874aaaeba54d38521101cd32c9", "message": "style(help): Added doc for new bazel haskell_cabal_library functionality", "committedDate": "2020-06-09T20:40:14Z", "type": "commit"}, {"oid": "2911792ac2f145c5343b4a0063b6e6a30d664674", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/2911792ac2f145c5343b4a0063b6e6a30d664674", "message": "style(help): bazel haskell_cabal_library release note", "committedDate": "2020-06-09T20:46:07Z", "type": "commit"}, {"oid": "b5ebd5fa03548bf70f0069a26c1b567c52634b9e", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b5ebd5fa03548bf70f0069a26c1b567c52634b9e", "message": "refactor(bazel): cleaning up code smells", "committedDate": "2020-06-09T20:55:49Z", "type": "commit"}, {"oid": "c78734fba7a71ecdab43545237fb20a41ad21770", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/c78734fba7a71ecdab43545237fb20a41ad21770", "message": "refactor(bazel): Cleaning up code smells", "committedDate": "2020-06-09T21:54:16Z", "type": "commit"}, {"oid": "3a198492e8270a5c64ea1428e3c3f66f4df07e91", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/3a198492e8270a5c64ea1428e3c3f66f4df07e91", "message": "refactor(bazel): code smell cleanup", "committedDate": "2020-06-09T22:29:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMzYwMA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438933600", "bodyText": "Did you consider creating gson/pojo model classes?", "author": "taikuukaits", "createdAt": "2020-06-11T16:57:30Z", "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibraries.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * detectable\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.detectable.detectables.bazel.pipeline.step;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.graph.MutableMapDependencyGraph;\n+import com.synopsys.integration.bdio.model.Forge;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.bdio.model.externalid.ExternalId;\n+import com.synopsys.integration.bdio.model.externalid.ExternalIdFactory;\n+import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.util.NameVersion;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+public class FinalStepJsonProtoHaskellCabalLibraries implements FinalStep {\n+    private static final String FORGE_NAME = \"hackage\";\n+    private static final String FORGE_SEPARATOR = \"/\";\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    private final Forge hackageForge = new Forge(FORGE_SEPARATOR, FORGE_NAME);\n+\n+    @Override\n+    public MutableDependencyGraph finish(final List<String> input) throws IntegrationException {\n+        final String jsonString = extractJsonString(input);\n+        final JsonArray resultsArray = parseResultsJson(jsonString);\n+        final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph();\n+        for (final JsonElement resultsArrayMemberElement : resultsArray) {\n+            final Optional<JsonObject> ruleObject = extractHaskellCabalLibraryRule(resultsArrayMemberElement);\n+            if (ruleObject.isPresent()) {\n+                addDependencyToGraph(dependencyGraph, ruleObject.get());\n+            }\n+        }\n+        return dependencyGraph;\n+    }\n+\n+    private String extractJsonString(final List<String> input) throws IntegrationException {\n+        if (input.size() != 1) {\n+            throw new IntegrationException(String.format(\"Input size is %d; expected 1\", input.size()));\n+        }\n+        return input.get(0);\n+    }\n+\n+    private JsonArray parseResultsJson(final String jsonString) {\n+        final JsonElement protoElement = JsonParser.parseString(jsonString);\n+        final JsonObject protoObject = protoElement.getAsJsonObject();\n+        final JsonElement resultsElement = protoObject.get(\"results\");\n+        return resultsElement.getAsJsonArray();\n+    }\n+\n+    private Dependency haskageCompNameVersionToDependency(final String compName, final String compVersion) {\n+        final ExternalId externalId = (new ExternalIdFactory()).createNameVersionExternalId(hackageForge, compName, compVersion);\n+        externalId.createBdioId(); // Validity check; throws IllegalStateException if invalid\n+        return new Dependency(compName, compVersion, externalId);\n+    }\n+\n+    private Optional<JsonObject> extractHaskellCabalLibraryRule(final JsonElement resultsArrayMemberElement) {\n+        final JsonObject resultsArrayMemberObject = resultsArrayMemberElement.getAsJsonObject();", "originalCommit": "3a198492e8270a5c64ea1428e3c3f66f4df07e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNjU2Nw==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438936567", "bodyText": "I did... Bazel is very unstable (3 major versions in the last 8 months, and they include breaking changes even in minor versions), and I thought this might be more resilient to change. But I'm not actually sure of that... do you happen to know?", "author": "stevebillings", "createdAt": "2020-06-11T17:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMzYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0MDU3Mg==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438940572", "bodyText": "It probably depends on the changes, any idea what they typically change and will you need to support multiple models at the same time? I'd be hesitant to do the POJO if the changes were deeper than field renames - like if they were collections and the types stored in the collection changes.\nIf it is just field name changes, having muliple fields on the POJO some of which might be empty seems reasonable to me, and your code is just defensive against missing fields which it needs to be in the JsonElement case anyway.\nI think\nIf pojo.myField != null then haskellName = pojo.myField else haskellName = pojo.otherField\nseems better than\nif json.containsField(\"myField\") then haskellName = pojo.getFieldAsString(\"myField\") else haskellName = pojo.getFieldAsString(\"otherField\")\nI would definitely understand the json element if the two models are dramatically different and cannot be mashed together.", "author": "taikuukaits", "createdAt": "2020-06-11T17:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMzYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMDg4Ng==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r439600886", "bodyText": "changed it to a gson/pojo approach.", "author": "stevebillings", "createdAt": "2020-06-12T19:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMzYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNjUxMQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438926511", "bodyText": "haskageCompNameVersionToDependency typo?", "author": "JakeMathews", "createdAt": "2020-06-11T16:45:12Z", "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibraries.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * detectable\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.detectable.detectables.bazel.pipeline.step;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.graph.MutableMapDependencyGraph;\n+import com.synopsys.integration.bdio.model.Forge;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.bdio.model.externalid.ExternalId;\n+import com.synopsys.integration.bdio.model.externalid.ExternalIdFactory;\n+import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.util.NameVersion;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+public class FinalStepJsonProtoHaskellCabalLibraries implements FinalStep {\n+    private static final String FORGE_NAME = \"hackage\";\n+    private static final String FORGE_SEPARATOR = \"/\";\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    private final Forge hackageForge = new Forge(FORGE_SEPARATOR, FORGE_NAME);\n+\n+    @Override\n+    public MutableDependencyGraph finish(final List<String> input) throws IntegrationException {\n+        final String jsonString = extractJsonString(input);\n+        final JsonArray resultsArray = parseResultsJson(jsonString);\n+        final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph();\n+        for (final JsonElement resultsArrayMemberElement : resultsArray) {\n+            final Optional<JsonObject> ruleObject = extractHaskellCabalLibraryRule(resultsArrayMemberElement);\n+            if (ruleObject.isPresent()) {\n+                addDependencyToGraph(dependencyGraph, ruleObject.get());\n+            }\n+        }\n+        return dependencyGraph;\n+    }\n+\n+    private String extractJsonString(final List<String> input) throws IntegrationException {\n+        if (input.size() != 1) {\n+            throw new IntegrationException(String.format(\"Input size is %d; expected 1\", input.size()));\n+        }\n+        return input.get(0);\n+    }\n+\n+    private JsonArray parseResultsJson(final String jsonString) {\n+        final JsonElement protoElement = JsonParser.parseString(jsonString);\n+        final JsonObject protoObject = protoElement.getAsJsonObject();\n+        final JsonElement resultsElement = protoObject.get(\"results\");\n+        return resultsElement.getAsJsonArray();\n+    }\n+\n+    private Dependency haskageCompNameVersionToDependency(final String compName, final String compVersion) {", "originalCommit": "3a198492e8270a5c64ea1428e3c3f66f4df07e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMDk2OA==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r439600968", "bodyText": "fixed.", "author": "stevebillings", "createdAt": "2020-06-12T19:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNjUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMzE1MQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438933151", "bodyText": "Can this be smaller? Only include a few dependencies and maybe exclude data we don't parse? It looks like you are only checking the graph for colour.", "author": "JakeMathews", "createdAt": "2020-06-11T16:56:42Z", "path": "detectable/src/test/resources/detectables/functional/bazel/jsonProtoForHaskellCabalLibraries.txt", "diffHunk": "@@ -0,0 +1,908 @@\n+{\n+  \"results\": [{\n+    \"target\": {\n+      \"type\": \"RULE\",\n+      \"rule\": {\n+        \"name\": \"@stackage//:optparse-applicative\",\n+        \"ruleClass\": \"haskell_cabal_library\",\n+        \"location\": \"/root/.cache/bazel/_bazel_root/cc59a4f96db0d7083a7d7596a883ccd0/external/stackage/BUILD.bazel:528:1\",\n+        \"attribute\": [{\n+          \"name\": \"generator_location\",\n+          \"type\": \"STRING\",\n+          \"stringValue\": \"\",\n+          \"explicitlySpecified\": false,\n+          \"nodep\": false\n+        }, {", "originalCommit": "3a198492e8270a5c64ea1428e3c3f66f4df07e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMTA1MQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r439601051", "bodyText": "yup, done.", "author": "stevebillings", "createdAt": "2020-06-12T19:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzMzE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNDg2Mg==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438934862", "bodyText": "Why not use the GraphAssert class?\nAlso do we have to test that all the component pieces of ExternalId are set correctly? I think comparing the String result from ExternalId::createExternalId should be sufficient.", "author": "JakeMathews", "createdAt": "2020-06-11T16:59:43Z", "path": "detectable/src/test/java/com/synopsys/integration/detectable/detectables/bazel/functional/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibrariesTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.synopsys.integration.detectable.detectables.bazel.functional.bazel.pipeline.step;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.gson.Gson;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.detectable.detectables.bazel.pipeline.step.FinalStepJsonProtoHaskellCabalLibraries;\n+import com.synopsys.integration.exception.IntegrationException;\n+\n+public class FinalStepJsonProtoHaskellCabalLibrariesTest {\n+\n+    @Test\n+    public void testStep() throws IntegrationException, IOException {\n+        final File jsonProtoFile = new File(\"src/test/resources/detectables/functional/bazel/jsonProtoForHaskellCabalLibraries.txt\");\n+        final String jsonProtoHaskellCabalLibrary = FileUtils.readFileToString(jsonProtoFile, StandardCharsets.UTF_8);\n+        final FinalStepJsonProtoHaskellCabalLibraries step = new FinalStepJsonProtoHaskellCabalLibraries();\n+        final List<String> input = new ArrayList<>(1);\n+        input.add(jsonProtoHaskellCabalLibrary);\n+        final MutableDependencyGraph graph = step.finish(input);\n+        assertEquals(5, graph.getRootDependencies().size());\n+        boolean foundTargetComp = false;\n+        for (final Dependency dep : graph.getRootDependencies()) {\n+            if (\"colour\".equals(dep.getExternalId().getName())) {\n+                assertEquals(\"hackage\", dep.getExternalId().getForge().getName());\n+                assertEquals(\"/\", dep.getExternalId().getForge().getSeparator());\n+                assertEquals(\"colour\", dep.getExternalId().getName());\n+                assertEquals(\"2.3.5\", dep.getExternalId().getVersion());\n+                assertTrue(StringUtils.isBlank(dep.getExternalId().getGroup()));\n+                assertTrue(StringUtils.isBlank(dep.getExternalId().getArchitecture()));\n+                foundTargetComp = true;\n+                break;\n+            }\n+        }", "originalCommit": "3a198492e8270a5c64ea1428e3c3f66f4df07e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMTI4Ng==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r439601286", "bodyText": "changed it to use GraphAssert.", "author": "stevebillings", "createdAt": "2020-06-12T19:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNDg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTgwNg==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438935806", "bodyText": "Can Gson not parse this Json?", "author": "JakeMathews", "createdAt": "2020-06-11T17:01:20Z", "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibraries.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * detectable\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.detectable.detectables.bazel.pipeline.step;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.graph.MutableMapDependencyGraph;\n+import com.synopsys.integration.bdio.model.Forge;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.bdio.model.externalid.ExternalId;\n+import com.synopsys.integration.bdio.model.externalid.ExternalIdFactory;\n+import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.util.NameVersion;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+public class FinalStepJsonProtoHaskellCabalLibraries implements FinalStep {\n+    private static final String FORGE_NAME = \"hackage\";\n+    private static final String FORGE_SEPARATOR = \"/\";\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    private final Forge hackageForge = new Forge(FORGE_SEPARATOR, FORGE_NAME);\n+\n+    @Override\n+    public MutableDependencyGraph finish(final List<String> input) throws IntegrationException {\n+        final String jsonString = extractJsonString(input);\n+        final JsonArray resultsArray = parseResultsJson(jsonString);\n+        final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph();\n+        for (final JsonElement resultsArrayMemberElement : resultsArray) {\n+            final Optional<JsonObject> ruleObject = extractHaskellCabalLibraryRule(resultsArrayMemberElement);\n+            if (ruleObject.isPresent()) {\n+                addDependencyToGraph(dependencyGraph, ruleObject.get());\n+            }\n+        }\n+        return dependencyGraph;\n+    }\n+\n+    private String extractJsonString(final List<String> input) throws IntegrationException {\n+        if (input.size() != 1) {\n+            throw new IntegrationException(String.format(\"Input size is %d; expected 1\", input.size()));\n+        }\n+        return input.get(0);\n+    }\n+\n+    private JsonArray parseResultsJson(final String jsonString) {\n+        final JsonElement protoElement = JsonParser.parseString(jsonString);\n+        final JsonObject protoObject = protoElement.getAsJsonObject();\n+        final JsonElement resultsElement = protoObject.get(\"results\");\n+        return resultsElement.getAsJsonArray();\n+    }\n+\n+    private Dependency haskageCompNameVersionToDependency(final String compName, final String compVersion) {\n+        final ExternalId externalId = (new ExternalIdFactory()).createNameVersionExternalId(hackageForge, compName, compVersion);\n+        externalId.createBdioId(); // Validity check; throws IllegalStateException if invalid\n+        return new Dependency(compName, compVersion, externalId);\n+    }\n+\n+    private Optional<JsonObject> extractHaskellCabalLibraryRule(final JsonElement resultsArrayMemberElement) {\n+        final JsonObject resultsArrayMemberObject = resultsArrayMemberElement.getAsJsonObject();\n+        final JsonElement targetElement = resultsArrayMemberObject.get(\"target\");\n+        final JsonObject targetObject = targetElement.getAsJsonObject();\n+        logger.debug(String.format(\"targetType: %s\", targetObject.get(\"type\").toString()));\n+        final JsonElement targetTypeElement = targetObject.get(\"type\");\n+        final String targetTypeValue = targetTypeElement.getAsString();\n+        if (!\"RULE\".equals(targetTypeValue)) {\n+            logger.debug(String.format(\"This is not a rule; skipping it. (It's a %s)\", targetTypeValue));\n+            return Optional.empty();\n+        }\n+        final JsonElement ruleElement = targetObject.get(\"rule\");\n+        final JsonObject ruleObject = ruleElement.getAsJsonObject();\n+        logger.debug(String.format(\"ruleClass: %s\", ruleObject.get(\"ruleClass\").toString()));\n+        final JsonElement ruleClassElement = ruleObject.get(\"ruleClass\");\n+        final String ruleClassValue = ruleClassElement.getAsString();\n+        if (!\"haskell_cabal_library\".equals(ruleClassValue)) {\n+            logger.debug(String.format(\"This is not a haskell_cabal_library rule; skipping it. (It's a %s rule)\", ruleClassValue));\n+            return Optional.empty();\n+        }\n+        return Optional.of(ruleObject);", "originalCommit": "3a198492e8270a5c64ea1428e3c3f66f4df07e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMTQ5Ng==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r439601496", "bodyText": "changed it to a gson/pojo approach.", "author": "stevebillings", "createdAt": "2020-06-12T19:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0MjYxOQ==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r438942619", "bodyText": "I'd like to suggest more separation from parsing from transforming - you could have this Step use a Parser where the parser takes the string and returns say List of HaskellDependency and then the Step knows how to transform them into a dependency that is added to the graph, you are close as it is. I'd think extractHaskellCabalLibraryRule does all the json parsing and returns a well formed HaskellDependency and instead of returning a JsonObject that later work is done to, do all the json work up front and return a pojo. Then addDependencyToGraph doesn't take a JsonObject but takes in the HaskellDependency pojo. Then in your tests you can have a test that checks JsonObject -> HaskellDependency works and a test that List of HaskellDependency -> Graph. Would let you have smaller more isolated tests.", "author": "taikuukaits", "createdAt": "2020-06-11T17:13:39Z", "path": "detectable/src/main/java/com/synopsys/integration/detectable/detectables/bazel/pipeline/step/FinalStepJsonProtoHaskellCabalLibraries.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * detectable\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.detectable.detectables.bazel.pipeline.step;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.synopsys.integration.bdio.graph.MutableDependencyGraph;\n+import com.synopsys.integration.bdio.graph.MutableMapDependencyGraph;\n+import com.synopsys.integration.bdio.model.Forge;\n+import com.synopsys.integration.bdio.model.dependency.Dependency;\n+import com.synopsys.integration.bdio.model.externalid.ExternalId;\n+import com.synopsys.integration.bdio.model.externalid.ExternalIdFactory;\n+import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.util.NameVersion;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+public class FinalStepJsonProtoHaskellCabalLibraries implements FinalStep {\n+    private static final String FORGE_NAME = \"hackage\";\n+    private static final String FORGE_SEPARATOR = \"/\";\n+    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n+    private final Forge hackageForge = new Forge(FORGE_SEPARATOR, FORGE_NAME);\n+\n+    @Override\n+    public MutableDependencyGraph finish(final List<String> input) throws IntegrationException {\n+        final String jsonString = extractJsonString(input);\n+        final JsonArray resultsArray = parseResultsJson(jsonString);\n+        final MutableDependencyGraph dependencyGraph = new MutableMapDependencyGraph();\n+        for (final JsonElement resultsArrayMemberElement : resultsArray) {\n+            final Optional<JsonObject> ruleObject = extractHaskellCabalLibraryRule(resultsArrayMemberElement);\n+            if (ruleObject.isPresent()) {\n+                addDependencyToGraph(dependencyGraph, ruleObject.get());\n+            }\n+        }\n+        return dependencyGraph;\n+    }\n+\n+    private String extractJsonString(final List<String> input) throws IntegrationException {\n+        if (input.size() != 1) {\n+            throw new IntegrationException(String.format(\"Input size is %d; expected 1\", input.size()));\n+        }\n+        return input.get(0);\n+    }\n+\n+    private JsonArray parseResultsJson(final String jsonString) {\n+        final JsonElement protoElement = JsonParser.parseString(jsonString);\n+        final JsonObject protoObject = protoElement.getAsJsonObject();\n+        final JsonElement resultsElement = protoObject.get(\"results\");\n+        return resultsElement.getAsJsonArray();\n+    }\n+\n+    private Dependency haskageCompNameVersionToDependency(final String compName, final String compVersion) {\n+        final ExternalId externalId = (new ExternalIdFactory()).createNameVersionExternalId(hackageForge, compName, compVersion);\n+        externalId.createBdioId(); // Validity check; throws IllegalStateException if invalid\n+        return new Dependency(compName, compVersion, externalId);\n+    }\n+\n+    private Optional<JsonObject> extractHaskellCabalLibraryRule(final JsonElement resultsArrayMemberElement) {\n+        final JsonObject resultsArrayMemberObject = resultsArrayMemberElement.getAsJsonObject();\n+        final JsonElement targetElement = resultsArrayMemberObject.get(\"target\");\n+        final JsonObject targetObject = targetElement.getAsJsonObject();\n+        logger.debug(String.format(\"targetType: %s\", targetObject.get(\"type\").toString()));\n+        final JsonElement targetTypeElement = targetObject.get(\"type\");\n+        final String targetTypeValue = targetTypeElement.getAsString();\n+        if (!\"RULE\".equals(targetTypeValue)) {\n+            logger.debug(String.format(\"This is not a rule; skipping it. (It's a %s)\", targetTypeValue));\n+            return Optional.empty();\n+        }\n+        final JsonElement ruleElement = targetObject.get(\"rule\");\n+        final JsonObject ruleObject = ruleElement.getAsJsonObject();\n+        logger.debug(String.format(\"ruleClass: %s\", ruleObject.get(\"ruleClass\").toString()));\n+        final JsonElement ruleClassElement = ruleObject.get(\"ruleClass\");\n+        final String ruleClassValue = ruleClassElement.getAsString();\n+        if (!\"haskell_cabal_library\".equals(ruleClassValue)) {\n+            logger.debug(String.format(\"This is not a haskell_cabal_library rule; skipping it. (It's a %s rule)\", ruleClassValue));\n+            return Optional.empty();\n+        }\n+        return Optional.of(ruleObject);\n+    }\n+\n+    private void addDependencyToGraph(final MutableDependencyGraph dependencyGraph, final JsonObject ruleObject) throws IntegrationException {\n+        final JsonElement attributeElement = ruleObject.get(\"attribute\");\n+        final JsonArray attributeArray = attributeElement.getAsJsonArray();\n+\n+        final NameVersion dependencyNameVersion = extractDependencyDetails(attributeArray);\n+        final Dependency artifactDependency = haskageCompNameVersionToDependency(dependencyNameVersion.getName(), dependencyNameVersion.getVersion());\n+        try {\n+            logger.debug(String.format(\"Adding %s to graph\", artifactDependency.getExternalId().toString()));\n+            dependencyGraph.addChildToRoot(artifactDependency);\n+        } catch (final Exception e) {\n+            logger.error(String.format(\"Unable to create dependency from %s/%s\", dependencyNameVersion.getName(), dependencyNameVersion.getVersion()));\n+        }\n+    }\n+\n+    private NameVersion extractDependencyDetails(final JsonArray attributeArray) throws IntegrationException {", "originalCommit": "3a198492e8270a5c64ea1428e3c3f66f4df07e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMTYyMg==", "url": "https://github.com/blackducksoftware/synopsys-detect/pull/185#discussion_r439601622", "bodyText": "done.", "author": "stevebillings", "createdAt": "2020-06-12T19:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0MjYxOQ=="}], "type": "inlineReview"}, {"oid": "7e20586c5e8cafe19170ac5a1c8dfd02d97a6c03", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/7e20586c5e8cafe19170ac5a1c8dfd02d97a6c03", "message": "refactor: addressing code review feedback; first, a few simple changes", "committedDate": "2020-06-11T20:11:54Z", "type": "commit"}, {"oid": "df41fe04d0c14f80a87b03e5d956ef3813acf6f7", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/df41fe04d0c14f80a87b03e5d956ef3813acf6f7", "message": "refactor: split parser out from FinalStepJsonProtoHaskellCabalLibraries", "committedDate": "2020-06-11T20:43:13Z", "type": "commit"}, {"oid": "8003b59c97da4058bcf4e280ffb223039472a0db", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/8003b59c97da4058bcf4e280ffb223039472a0db", "message": "refactor(bazel): FinalStepJsonProtoHaskellCabalLibraries: inject ExternalIdFactory", "committedDate": "2020-06-11T20:57:22Z", "type": "commit"}, {"oid": "efde127ae6bb9a488aeebcd878a5fe14bb3f39f6", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/efde127ae6bb9a488aeebcd878a5fe14bb3f39f6", "message": "test: added test for bazel haskell parser", "committedDate": "2020-06-11T20:57:43Z", "type": "commit"}, {"oid": "b63f863d40eb1a258342269a93f37d5ff58ea28c", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b63f863d40eb1a258342269a93f37d5ff58ea28c", "message": "refactor: cleanup", "committedDate": "2020-06-11T21:17:33Z", "type": "commit"}, {"oid": "fc7cad88da4383c60239d44b794d66b506d38cda", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/fc7cad88da4383c60239d44b794d66b506d38cda", "message": "Merge commit '3ce52f077047fe93e76ec3279ba849179a29e73f' into sb_bazelHaskellCabalLibraryRule\n\n# Conflicts:\n#\tdocs/templates/content/90-releasenotes.ftl", "committedDate": "2020-06-12T15:35:52Z", "type": "commit"}, {"oid": "436baebef3e7a7bb3cc3d3b435799867e00253f6", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/436baebef3e7a7bb3cc3d3b435799867e00253f6", "message": "refactor(bazel): haskell: first cut at pojo based parsing", "committedDate": "2020-06-12T18:12:22Z", "type": "commit"}, {"oid": "1208ac16ebe1d67516f4391b3566fc8e4305eba8", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/1208ac16ebe1d67516f4391b3566fc8e4305eba8", "message": "refactor(bazel): refactoring", "committedDate": "2020-06-12T18:18:32Z", "type": "commit"}, {"oid": "cb74b2a93ab157cc503435547438fd70e9737d45", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/cb74b2a93ab157cc503435547438fd70e9737d45", "message": "refactor(bazel): cleanup", "committedDate": "2020-06-12T19:13:50Z", "type": "commit"}, {"oid": "ba7a46d5cef2f4467787ac9060382685fa02a9a0", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/ba7a46d5cef2f4467787ac9060382685fa02a9a0", "message": "refactor(bazel): haskell: error checking for unexpected query output", "committedDate": "2020-06-12T19:15:09Z", "type": "commit"}, {"oid": "a99560ac09e4a977e295fcadb133eed2b47b5b77", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/a99560ac09e4a977e295fcadb133eed2b47b5b77", "message": "refactor(bazel): cleanup", "committedDate": "2020-06-12T19:17:18Z", "type": "commit"}, {"oid": "b802f8ef15ae0689b3ab51126fd6ad604f335185", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/b802f8ef15ae0689b3ab51126fd6ad604f335185", "message": "refactor(bazel): addressing code smells", "committedDate": "2020-06-12T19:28:07Z", "type": "commit"}, {"oid": "90bacda8be709331ae2757c630ffd09d5e867dbe", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/90bacda8be709331ae2757c630ffd09d5e867dbe", "message": "merge from master", "committedDate": "2020-06-12T19:29:08Z", "type": "commit"}, {"oid": "1a90217a1b09cd99879c44b0c170ea048b656117", "url": "https://github.com/blackducksoftware/synopsys-detect/commit/1a90217a1b09cd99879c44b0c170ea048b656117", "message": "refactor(bazel): code smell", "committedDate": "2020-06-12T19:36:23Z", "type": "commit"}]}