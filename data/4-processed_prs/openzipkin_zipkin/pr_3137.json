{"pr_number": 3137, "pr_title": "Refactors Cassandra v1 indexing code and fixes some glitches", "pr_createdAt": "2020-07-06T01:47:10Z", "pr_url": "https://github.com/openzipkin/zipkin/pull/3137", "timeline": [{"oid": "4c4092549f941de366682ac74fb24e831a0e6b46", "url": "https://github.com/openzipkin/zipkin/commit/4c4092549f941de366682ac74fb24e831a0e6b46", "message": "Refactors Cassandra v1 indexing code and fixes some glitches\n\nThis change performs more cleanups in preparation of the move to Datastax\nJava Driver 4, mostly consolidation in nature:\n\n* Fixes bug when drop-down choices were added when span data wasn't indexed\n* Uses less auto-value by choosing Map.Entry for pair/tuple data\n* Simplify index state management by giving each indexer a separate cache\n* Moves index clash test to CassandraSpanConsumerTest\n* Adds a bunch of comments explaining loop logic of CassandraSpanConsumer", "committedDate": "2020-07-06T01:42:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk0ODg4OQ==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r449948889", "bodyText": "in reality this might not be possible to merge, as the data is used for different purposes. For example, here it is used to determine if an existing range will be extended.. not if an exact call was made prior.\nAs the main next goal is getting rid of guava, the follow-up PR may not actually merge these features into DelayLimiter, rather make a similar bounded expire-after-write map.", "author": "codefromthecrypt", "createdAt": "2020-07-06T01:52:14Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/IndexTraceId.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package zipkin2.storage.cassandra.v1;\n+\n+import com.datastax.driver.core.BoundStatement;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.ResultSetFuture;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.querybuilder.Insert;\n+import com.datastax.driver.core.querybuilder.QueryBuilder;\n+import com.google.auto.value.AutoValue;\n+import com.google.common.cache.CacheBuilder;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.storage.QueryRequest;\n+import zipkin2.storage.cassandra.internal.call.DeduplicatingVoidCallFactory;\n+import zipkin2.storage.cassandra.internal.call.ResultSetFutureCall;\n+\n+/**\n+ * Inserts index rows into a Cassandra table. This skips entries that don't improve results based on\n+ * {@link QueryRequest#endTs()} and {@link QueryRequest#lookback()}. For example, it doesn't insert\n+ * rows that only vary on timestamp and exist between timestamps of existing rows.\n+ */\n+final class IndexTraceId extends ResultSetFutureCall<Void> {\n+  static final Logger LOG = LoggerFactory.getLogger(IndexTraceId.class);\n+\n+  @AutoValue\n+  abstract static class Input {\n+    static Input create(String partitionKey, long timestamp, long traceId) {\n+      return new AutoValue_IndexTraceId_Input(partitionKey, timestamp, traceId);\n+    }\n+\n+    abstract String partitionKey(); // ends up as a partition key, ignoring bucketing\n+\n+    abstract long ts(); // microseconds at millis precision\n+\n+    abstract long trace_id(); // clustering key\n+  }\n+\n+  /** Deduplicates redundant entries upon {@link #iterator()} */\n+  interface Indexer extends Iterable<IndexTraceId.Input> {\n+    Indexer NOOP = new Indexer() {\n+      @Override public void add(Input input) {\n+      }\n+\n+      @Override public Iterator<Input> iterator() {\n+        return Collections.emptyIterator();\n+      }\n+    };\n+\n+    void add(IndexTraceId.Input input);\n+  }\n+\n+  static abstract class Factory extends DeduplicatingVoidCallFactory<Input> {\n+    final Session session;\n+    // Shared across all threads as updates can come from any thread.\n+    final Map<Entry<String, Long>, Pair> sharedState;\n+    final String table;\n+    final int bucketCount;\n+    final PreparedStatement preparedStatement;\n+    final TimestampCodec timestampCodec;\n+\n+    Factory(CassandraStorage storage, String table, int indexTtl) {\n+      super(TimeUnit.SECONDS.toMillis(storage.indexCacheTtl), storage.indexCacheTtl);\n+      session = storage.session();\n+      // TODO: this state should be merged with the DelayLimiter setup in the super class", "originalCommit": "4c4092549f941de366682ac74fb24e831a0e6b46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk0OTQxMw==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r449949413", "bodyText": "before, this saved a constant off for the value of ThreadLocalRandom.current().. I moved it here, but possibly the idea was to ensure that there's fewer clashes between the small bucket choices... that it was ThreadLocalRandom made me think I should move it here.. but perhaps it could be reverted with a comment as to why we are saving a constant like that.", "author": "codefromthecrypt", "createdAt": "2020-07-06T01:55:12Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/IndexTraceIdByServiceName.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package zipkin2.storage.cassandra.v1;\n+\n+import com.datastax.driver.core.BoundStatement;\n+import com.datastax.driver.core.querybuilder.Insert;\n+import com.datastax.driver.core.querybuilder.QueryBuilder;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+// QueryRequest.serviceName\n+final class IndexTraceIdByServiceName extends IndexTraceId.Factory {\n+\n+  IndexTraceIdByServiceName(CassandraStorage storage, int indexTtl) {\n+    super(storage, Tables.SERVICE_NAME_INDEX, indexTtl);\n+  }\n+\n+  @Override public Insert declarePartitionKey(Insert insert) {\n+    return insert\n+      .value(\"service_name\", QueryBuilder.bindMarker(\"service_name\"))\n+      .value(\"bucket\", QueryBuilder.bindMarker(\"bucket\"));\n+  }\n+\n+  @Override public BoundStatement bindPartitionKey(BoundStatement bound, String partitionKey) {\n+    return bound\n+      .setInt(\"bucket\", ThreadLocalRandom.current().nextInt(bucketCount))", "originalCommit": "4c4092549f941de366682ac74fb24e831a0e6b46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk0OTY1Nw==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r449949657", "bodyText": "specifically.. here is where we oddly saved off a \"thread local random\".. maybe the point was to save a random (regardless, it should be field not constant)", "author": "codefromthecrypt", "createdAt": "2020-07-06T01:56:39Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/InsertTraceIdByAnnotation.java", "diffHunk": "@@ -1,58 +0,0 @@\n-/*\n- * Copyright 2015-2019 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package zipkin2.storage.cassandra.v1;\n-\n-import com.datastax.driver.core.BoundStatement;\n-import com.datastax.driver.core.querybuilder.Insert;\n-import com.datastax.driver.core.querybuilder.QueryBuilder;\n-import java.util.Set;\n-import java.util.concurrent.ThreadLocalRandom;\n-import zipkin2.Span;\n-\n-import static zipkin2.storage.cassandra.v1.CassandraUtil.annotationKeys;\n-import static zipkin2.storage.cassandra.v1.CassandraUtil.toByteBuffer;\n-\n-// QueryRequest.annotations/binaryAnnotations\n-final class InsertTraceIdByAnnotation implements Indexer.IndexSupport {\n-  private static final ThreadLocalRandom RAND = ThreadLocalRandom.current();", "originalCommit": "4c4092549f941de366682ac74fb24e831a0e6b46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk1Mjg2NQ==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r449952865", "bodyText": "@michaelsembwever if you happen to remember why we did this, let me know. I've left it in for now.", "author": "codefromthecrypt", "createdAt": "2020-07-06T02:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk0OTY1Nw=="}], "type": "inlineReview"}, {"oid": "32cb91ed3a9cc0b6d77d45665952ffdc9976f624", "url": "https://github.com/openzipkin/zipkin/commit/32cb91ed3a9cc0b6d77d45665952ffdc9976f624", "message": "Fixes test drift", "committedDate": "2020-07-06T02:12:18Z", "type": "commit"}, {"oid": "129e9657532a4498134975ad1fee653c8e25a4f5", "url": "https://github.com/openzipkin/zipkin/commit/129e9657532a4498134975ad1fee653c8e25a4f5", "message": "restores legacy behavior", "committedDate": "2020-07-06T02:14:27Z", "type": "commit"}, {"oid": "8a579e83f88ff6caf7e077b241b58667500db256", "url": "https://github.com/openzipkin/zipkin/commit/8a579e83f88ff6caf7e077b241b58667500db256", "message": "comment clarification", "committedDate": "2020-07-06T02:23:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMTQwNA==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450021404", "bodyText": "This is copied from before, but seems to be weird naming convention (unless it's referring to a virus scan)", "author": "anuraaga", "createdAt": "2020-07-06T07:03:02Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/CassandraSpanConsumer.java", "diffHunk": "@@ -80,74 +97,150 @@\n    * This fans out into many requests, last count was 8 * spans.size. If any of these fail, the\n    * returned future will fail. Most callers drop or log the result.\n    */\n-  @Override\n-  public Call<Void> accept(List<Span> rawSpans) {\n+  @Override public Call<Void> accept(List<Span> spans) {\n+    int spanCount = spans.size();\n+    if (spanCount == 0) return Call.create(null);\n+\n     V2SpanConverter converter = V2SpanConverter.create();\n     V1ThriftSpanWriter encoder = new V1ThriftSpanWriter();\n \n     Set<InsertTrace.Input> insertTraces = new LinkedHashSet<>();\n-    Set<String> insertServiceNames = new LinkedHashSet<>();\n-    Set<InsertRemoteServiceName.Input> insertRemoteServiceNames = new LinkedHashSet<>();\n-    Set<InsertSpanName.Input> insertSpanNames = new LinkedHashSet<>();\n-    Set<Map.Entry<String, String>> autocompleteTags = new LinkedHashSet<>();\n \n     List<Call<Void>> calls = new ArrayList<>();\n-    for (Span v2 : rawSpans) {\n-      V1Span span = converter.convert(v2);\n-      // indexing occurs by timestamp, so derive one if not present.\n-      long ts_micro = v2.timestampAsLong();\n-      if (ts_micro == 0L) ts_micro = guessTimestamp(v2);\n+    for (int i = 0; i < spanCount; i++) {\n+      Span span = spans.get(i);\n+      V1Span v1Span = converter.convert(span);\n \n-      insertTraces.add(insertTrace.newInput(span, ByteBuffer.wrap(encoder.write(v2)), ts_micro));\n+      // trace records need an insertion timestamp, so derive one if not present.\n+      long ts_micro = span.timestampAsLong();", "originalCommit": "8a579e83f88ff6caf7e077b241b58667500db256", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyODg1MQ==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450028851", "bodyText": ":) these are the field names in the cassandra schema", "author": "codefromthecrypt", "createdAt": "2020-07-06T07:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMTg5Mg==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450021892", "bodyText": "timestampMillis", "author": "anuraaga", "createdAt": "2020-07-06T07:04:13Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/CassandraSpanConsumer.java", "diffHunk": "@@ -80,74 +97,150 @@\n    * This fans out into many requests, last count was 8 * spans.size. If any of these fail, the\n    * returned future will fail. Most callers drop or log the result.\n    */\n-  @Override\n-  public Call<Void> accept(List<Span> rawSpans) {\n+  @Override public Call<Void> accept(List<Span> spans) {\n+    int spanCount = spans.size();\n+    if (spanCount == 0) return Call.create(null);\n+\n     V2SpanConverter converter = V2SpanConverter.create();\n     V1ThriftSpanWriter encoder = new V1ThriftSpanWriter();\n \n     Set<InsertTrace.Input> insertTraces = new LinkedHashSet<>();\n-    Set<String> insertServiceNames = new LinkedHashSet<>();\n-    Set<InsertRemoteServiceName.Input> insertRemoteServiceNames = new LinkedHashSet<>();\n-    Set<InsertSpanName.Input> insertSpanNames = new LinkedHashSet<>();\n-    Set<Map.Entry<String, String>> autocompleteTags = new LinkedHashSet<>();\n \n     List<Call<Void>> calls = new ArrayList<>();\n-    for (Span v2 : rawSpans) {\n-      V1Span span = converter.convert(v2);\n-      // indexing occurs by timestamp, so derive one if not present.\n-      long ts_micro = v2.timestampAsLong();\n-      if (ts_micro == 0L) ts_micro = guessTimestamp(v2);\n+    for (int i = 0; i < spanCount; i++) {\n+      Span span = spans.get(i);\n+      V1Span v1Span = converter.convert(span);\n \n-      insertTraces.add(insertTrace.newInput(span, ByteBuffer.wrap(encoder.write(v2)), ts_micro));\n+      // trace records need an insertion timestamp, so derive one if not present.\n+      long ts_micro = span.timestampAsLong();\n+      if (ts_micro == 0L) ts_micro = guessTimestamp(span);\n \n-      if (!searchEnabled) continue;\n+      insertTraces.add(\n+        insertTrace.newInput(v1Span, ByteBuffer.wrap(encoder.write(span)), ts_micro));\n+    }\n+\n+    for (InsertTrace.Input insert : insertTraces) {\n+      calls.add(insertTrace.create(insert));\n+    }\n+\n+    if (!searchEnabled) return AggregateCall.newVoidCall(calls);\n+\n+    // Using set or other deduplication strategies helps avoid redundant writes.\n+    Set<String> insertServiceNames = new LinkedHashSet<>();\n+    Set<Entry<String, String>> insertRemoteServiceNames = new LinkedHashSet<>();\n+    Set<Entry<String, String>> insertSpanNames = new LinkedHashSet<>();\n+    Set<Entry<String, String>> insertAutocompleteTags = new LinkedHashSet<>();\n+    Indexer indexTraceIdByServiceNames = indexTraceIdByServiceName.newIndexer();\n+    Indexer indexTraceIdByRemoteServiceNames = indexTraceIdByRemoteServiceName != null\n+      ? indexTraceIdByRemoteServiceName.newIndexer()\n+      : Indexer.NOOP;\n+    Indexer indexTraceIdBySpanNames = indexTraceIdBySpanName.newIndexer();\n+    Indexer indexTraceIdByAnnotations = indexTraceIdByAnnotation.newIndexer();\n+\n+    for (int i = 0; i < spanCount; i++) {\n+      Span span = spans.get(i);\n+\n+      String serviceName = span.localServiceName();\n+\n+      // All search parameters are partitioned on service name, so we skip populating choices when\n+      // this is missing.\n+      if (serviceName == null) continue;\n+\n+      // Search in Cassandra v1 is implemented client-side, by adding rows corresponding to search\n+      // parameters. For example, a search for serviceName=app&spanName=bar will look for a\n+      // service_name_index row \"app.foo\" for the corresponding endTs and lookback. This has a few\n+      // implications:\n+      //\n+      // * timestamps need only millis precision (as query precision is millis)\n+      // * client-side indexing is pointless if there is no timestamp\n+      // * populating choices for indexes never added is also pointless\n+      //\n+      // We floor the micros timestamp to millis and skip populating choices on zero.\n+      long timestamp = 1000L * (span.timestampAsLong() / 1000L); // QueryRequest is precise to ms", "originalCommit": "8a579e83f88ff6caf7e077b241b58667500db256", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0ODIwNg==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450048206", "bodyText": "this isn't timestamp in millis it is just floored to millis\n1467676800150134L -> 1467676800150000L", "author": "codefromthecrypt", "createdAt": "2020-07-06T07:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMTg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMjU3Mw==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450022573", "bodyText": "Ditto, do we usually name our methods like this even for json?", "author": "anuraaga", "createdAt": "2020-07-06T07:05:50Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/IndexTraceId.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package zipkin2.storage.cassandra.v1;\n+\n+import com.datastax.driver.core.BoundStatement;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.ResultSetFuture;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.querybuilder.Insert;\n+import com.datastax.driver.core.querybuilder.QueryBuilder;\n+import com.google.auto.value.AutoValue;\n+import com.google.common.cache.CacheBuilder;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.storage.QueryRequest;\n+import zipkin2.storage.cassandra.internal.call.DeduplicatingVoidCallFactory;\n+import zipkin2.storage.cassandra.internal.call.ResultSetFutureCall;\n+\n+/**\n+ * Inserts index rows into a Cassandra table. This skips entries that don't improve results based on\n+ * {@link QueryRequest#endTs()} and {@link QueryRequest#lookback()}. For example, it doesn't insert\n+ * rows that only vary on timestamp and exist between timestamps of existing rows.\n+ */\n+final class IndexTraceId extends ResultSetFutureCall<Void> {\n+  static final Logger LOG = LoggerFactory.getLogger(IndexTraceId.class);\n+\n+  @AutoValue\n+  abstract static class Input {\n+    static Input create(String partitionKey, long timestamp, long traceId) {\n+      return new AutoValue_IndexTraceId_Input(partitionKey, timestamp, traceId);\n+    }\n+\n+    abstract String partitionKey(); // ends up as a partition key, ignoring bucketing\n+\n+    abstract long ts(); // microseconds at millis precision\n+\n+    abstract long trace_id(); // clustering key", "originalCommit": "8a579e83f88ff6caf7e077b241b58667500db256", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0ODcxMw==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450048713", "bodyText": "similar to above, these match the input variables in CQL. it isn't about json really, and is all over the cassandra v1 codebase.", "author": "codefromthecrypt", "createdAt": "2020-07-06T08:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMjU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyMzI2NQ==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450023265", "bodyText": "Guess we might check isDebug first", "author": "anuraaga", "createdAt": "2020-07-06T07:07:36Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/IndexTraceId.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package zipkin2.storage.cassandra.v1;\n+\n+import com.datastax.driver.core.BoundStatement;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.ResultSetFuture;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.querybuilder.Insert;\n+import com.datastax.driver.core.querybuilder.QueryBuilder;\n+import com.google.auto.value.AutoValue;\n+import com.google.common.cache.CacheBuilder;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.storage.QueryRequest;\n+import zipkin2.storage.cassandra.internal.call.DeduplicatingVoidCallFactory;\n+import zipkin2.storage.cassandra.internal.call.ResultSetFutureCall;\n+\n+/**\n+ * Inserts index rows into a Cassandra table. This skips entries that don't improve results based on\n+ * {@link QueryRequest#endTs()} and {@link QueryRequest#lookback()}. For example, it doesn't insert\n+ * rows that only vary on timestamp and exist between timestamps of existing rows.\n+ */\n+final class IndexTraceId extends ResultSetFutureCall<Void> {\n+  static final Logger LOG = LoggerFactory.getLogger(IndexTraceId.class);\n+\n+  @AutoValue\n+  abstract static class Input {\n+    static Input create(String partitionKey, long timestamp, long traceId) {\n+      return new AutoValue_IndexTraceId_Input(partitionKey, timestamp, traceId);\n+    }\n+\n+    abstract String partitionKey(); // ends up as a partition key, ignoring bucketing\n+\n+    abstract long ts(); // microseconds at millis precision\n+\n+    abstract long trace_id(); // clustering key\n+  }\n+\n+  /** Deduplicates redundant entries upon {@link #iterator()} */\n+  interface Indexer extends Iterable<IndexTraceId.Input> {\n+    Indexer NOOP = new Indexer() {\n+      @Override public void add(Input input) {\n+      }\n+\n+      @Override public Iterator<Input> iterator() {\n+        return Collections.emptyIterator();\n+      }\n+    };\n+\n+    void add(IndexTraceId.Input input);\n+  }\n+\n+  static abstract class Factory extends DeduplicatingVoidCallFactory<Input> {\n+    final Session session;\n+    /**\n+     * This ensures we only attempt to write rows that would extend the timestamp range of a trace\n+     * index query. This is shared singleton as inserts can come from any thread.\n+     */\n+    final Map<Entry<String, Long>, Pair> partitionKeyAndTraceIdToTimestampRange;\n+    final String table;\n+    final int bucketCount;\n+    final PreparedStatement preparedStatement;\n+    final TimestampCodec timestampCodec;\n+\n+    Factory(CassandraStorage storage, String table, int indexTtl) {\n+      super(TimeUnit.SECONDS.toMillis(storage.indexCacheTtl), storage.indexCacheTtl);\n+      session = storage.session();\n+      // This state looks similar to DelayLimiter, but serves a different purpose.\n+      partitionKeyAndTraceIdToTimestampRange = CacheBuilder.newBuilder()\n+        .maximumSize(storage.indexCacheMax)\n+        .expireAfterWrite(storage.indexCacheTtl, TimeUnit.SECONDS)\n+        .<Entry<String, Long>, Pair>build().asMap();\n+      this.table = table;\n+      this.bucketCount = storage.bucketCount;\n+      Insert insertQuery = declarePartitionKey(QueryBuilder.insertInto(table)\n+        .value(\"ts\", QueryBuilder.bindMarker(\"ts\"))\n+        .value(\"trace_id\", QueryBuilder.bindMarker(\"trace_id\")));\n+      if (indexTtl > 0) insertQuery.using(QueryBuilder.ttl(indexTtl));\n+      preparedStatement = session.prepare(insertQuery);\n+      timestampCodec = new TimestampCodec(session);\n+    }\n+\n+    Indexer newIndexer() {\n+      return new RealIndexer(partitionKeyAndTraceIdToTimestampRange, table);\n+    }\n+\n+    abstract Insert declarePartitionKey(Insert insert);\n+\n+    abstract BoundStatement bindPartitionKey(BoundStatement bound, String partitionKey);\n+\n+    @Override protected IndexTraceId newCall(Input input) {\n+      return new IndexTraceId(this, input);\n+    }\n+\n+    @Override public void clear() {\n+      super.clear();\n+      partitionKeyAndTraceIdToTimestampRange.clear();\n+    }\n+  }\n+\n+  final Factory factory;\n+  final Input input;\n+\n+  IndexTraceId(Factory factory, Input input) {\n+    this.factory = factory;\n+    this.input = input;\n+  }\n+\n+  @Override protected ResultSetFuture newFuture() {\n+    return factory.session.executeAsync(factory.bindPartitionKey(\n+      factory.preparedStatement.bind()\n+        .setLong(\"trace_id\", input.trace_id())\n+        .setBytesUnsafe(\"ts\", factory.timestampCodec.serialize(input.ts())), input.partitionKey()));\n+  }\n+\n+  @Override public Void map(ResultSet input) {\n+    return null;\n+  }\n+\n+  @Override public String toString() {\n+    return input.toString().replace(\"Input\", factory.getClass().getSimpleName());\n+  }\n+\n+  @Override public IndexTraceId clone() {\n+    return new IndexTraceId(factory, input);\n+  }\n+\n+  static final class RealIndexer implements Indexer {\n+    final Map<Entry<String, Long>, Pair> partitionKeyAndTraceIdToRange;\n+    final String table;\n+    final Set<Input> inputs = new LinkedHashSet<>();\n+\n+    RealIndexer(Map<Entry<String, Long>, Pair> partitionKeyAndTraceIdToRange, String table) {\n+      this.partitionKeyAndTraceIdToRange = partitionKeyAndTraceIdToRange;\n+      this.table = table;\n+    }\n+\n+    @Override public void add(IndexTraceId.Input input) {\n+      inputs.add(input);\n+    }\n+\n+    /**\n+     * The input may include inserts that already occurred, or are redundant as they don't impact\n+     * QueryRequest.endTs or QueryRequest.loopback. For example, a parsed timestamp could be between\n+     * timestamps of rows that already exist for a particular trace. Optimized results will be\n+     * smaller when the input includes traces with local spans, or when other threads indexed the\n+     * same trace.\n+     */\n+    @Override public Iterator<Input> iterator() {\n+      Set<IndexTraceId.Input> result = entriesThatIncreaseGap();\n+      if (inputs.size() > result.size() && LOG.isDebugEnabled()) {", "originalCommit": "8a579e83f88ff6caf7e077b241b58667500db256", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyNDEyNw==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450024127", "bodyText": "Since this is storage, guess we can use Java 8 computeIfAbsent(key, unused -> new LinkedHashSet<>())", "author": "anuraaga", "createdAt": "2020-07-06T07:09:33Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/IndexTraceId.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package zipkin2.storage.cassandra.v1;\n+\n+import com.datastax.driver.core.BoundStatement;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.ResultSetFuture;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.querybuilder.Insert;\n+import com.datastax.driver.core.querybuilder.QueryBuilder;\n+import com.google.auto.value.AutoValue;\n+import com.google.common.cache.CacheBuilder;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.storage.QueryRequest;\n+import zipkin2.storage.cassandra.internal.call.DeduplicatingVoidCallFactory;\n+import zipkin2.storage.cassandra.internal.call.ResultSetFutureCall;\n+\n+/**\n+ * Inserts index rows into a Cassandra table. This skips entries that don't improve results based on\n+ * {@link QueryRequest#endTs()} and {@link QueryRequest#lookback()}. For example, it doesn't insert\n+ * rows that only vary on timestamp and exist between timestamps of existing rows.\n+ */\n+final class IndexTraceId extends ResultSetFutureCall<Void> {\n+  static final Logger LOG = LoggerFactory.getLogger(IndexTraceId.class);\n+\n+  @AutoValue\n+  abstract static class Input {\n+    static Input create(String partitionKey, long timestamp, long traceId) {\n+      return new AutoValue_IndexTraceId_Input(partitionKey, timestamp, traceId);\n+    }\n+\n+    abstract String partitionKey(); // ends up as a partition key, ignoring bucketing\n+\n+    abstract long ts(); // microseconds at millis precision\n+\n+    abstract long trace_id(); // clustering key\n+  }\n+\n+  /** Deduplicates redundant entries upon {@link #iterator()} */\n+  interface Indexer extends Iterable<IndexTraceId.Input> {\n+    Indexer NOOP = new Indexer() {\n+      @Override public void add(Input input) {\n+      }\n+\n+      @Override public Iterator<Input> iterator() {\n+        return Collections.emptyIterator();\n+      }\n+    };\n+\n+    void add(IndexTraceId.Input input);\n+  }\n+\n+  static abstract class Factory extends DeduplicatingVoidCallFactory<Input> {\n+    final Session session;\n+    /**\n+     * This ensures we only attempt to write rows that would extend the timestamp range of a trace\n+     * index query. This is shared singleton as inserts can come from any thread.\n+     */\n+    final Map<Entry<String, Long>, Pair> partitionKeyAndTraceIdToTimestampRange;\n+    final String table;\n+    final int bucketCount;\n+    final PreparedStatement preparedStatement;\n+    final TimestampCodec timestampCodec;\n+\n+    Factory(CassandraStorage storage, String table, int indexTtl) {\n+      super(TimeUnit.SECONDS.toMillis(storage.indexCacheTtl), storage.indexCacheTtl);\n+      session = storage.session();\n+      // This state looks similar to DelayLimiter, but serves a different purpose.\n+      partitionKeyAndTraceIdToTimestampRange = CacheBuilder.newBuilder()\n+        .maximumSize(storage.indexCacheMax)\n+        .expireAfterWrite(storage.indexCacheTtl, TimeUnit.SECONDS)\n+        .<Entry<String, Long>, Pair>build().asMap();\n+      this.table = table;\n+      this.bucketCount = storage.bucketCount;\n+      Insert insertQuery = declarePartitionKey(QueryBuilder.insertInto(table)\n+        .value(\"ts\", QueryBuilder.bindMarker(\"ts\"))\n+        .value(\"trace_id\", QueryBuilder.bindMarker(\"trace_id\")));\n+      if (indexTtl > 0) insertQuery.using(QueryBuilder.ttl(indexTtl));\n+      preparedStatement = session.prepare(insertQuery);\n+      timestampCodec = new TimestampCodec(session);\n+    }\n+\n+    Indexer newIndexer() {\n+      return new RealIndexer(partitionKeyAndTraceIdToTimestampRange, table);\n+    }\n+\n+    abstract Insert declarePartitionKey(Insert insert);\n+\n+    abstract BoundStatement bindPartitionKey(BoundStatement bound, String partitionKey);\n+\n+    @Override protected IndexTraceId newCall(Input input) {\n+      return new IndexTraceId(this, input);\n+    }\n+\n+    @Override public void clear() {\n+      super.clear();\n+      partitionKeyAndTraceIdToTimestampRange.clear();\n+    }\n+  }\n+\n+  final Factory factory;\n+  final Input input;\n+\n+  IndexTraceId(Factory factory, Input input) {\n+    this.factory = factory;\n+    this.input = input;\n+  }\n+\n+  @Override protected ResultSetFuture newFuture() {\n+    return factory.session.executeAsync(factory.bindPartitionKey(\n+      factory.preparedStatement.bind()\n+        .setLong(\"trace_id\", input.trace_id())\n+        .setBytesUnsafe(\"ts\", factory.timestampCodec.serialize(input.ts())), input.partitionKey()));\n+  }\n+\n+  @Override public Void map(ResultSet input) {\n+    return null;\n+  }\n+\n+  @Override public String toString() {\n+    return input.toString().replace(\"Input\", factory.getClass().getSimpleName());\n+  }\n+\n+  @Override public IndexTraceId clone() {\n+    return new IndexTraceId(factory, input);\n+  }\n+\n+  static final class RealIndexer implements Indexer {\n+    final Map<Entry<String, Long>, Pair> partitionKeyAndTraceIdToRange;\n+    final String table;\n+    final Set<Input> inputs = new LinkedHashSet<>();\n+\n+    RealIndexer(Map<Entry<String, Long>, Pair> partitionKeyAndTraceIdToRange, String table) {\n+      this.partitionKeyAndTraceIdToRange = partitionKeyAndTraceIdToRange;\n+      this.table = table;\n+    }\n+\n+    @Override public void add(IndexTraceId.Input input) {\n+      inputs.add(input);\n+    }\n+\n+    /**\n+     * The input may include inserts that already occurred, or are redundant as they don't impact\n+     * QueryRequest.endTs or QueryRequest.loopback. For example, a parsed timestamp could be between\n+     * timestamps of rows that already exist for a particular trace. Optimized results will be\n+     * smaller when the input includes traces with local spans, or when other threads indexed the\n+     * same trace.\n+     */\n+    @Override public Iterator<Input> iterator() {\n+      Set<IndexTraceId.Input> result = entriesThatIncreaseGap();\n+      if (inputs.size() > result.size() && LOG.isDebugEnabled()) {\n+        int delta = inputs.size() - result.size();\n+        LOG.debug(\"optimized out {}/{} inserts into {}\", delta, inputs.size(), table);\n+      }\n+      return result.iterator();\n+    }\n+\n+    Set<IndexTraceId.Input> entriesThatIncreaseGap() {\n+      if (inputs.size() <= 1) return inputs;\n+      Set<Entry<String, Long>> toUpdate = new LinkedHashSet<>();\n+      Map<Entry<String, Long>, Set<Long>> mappedInputs = new LinkedHashMap<>();\n+\n+      // Enter a loop that affects shared state when an update widens the time interval for a key.\n+      for (IndexTraceId.Input input : inputs) {\n+        Entry<String, Long> key =\n+          new SimpleImmutableEntry<>(input.partitionKey(), input.trace_id());\n+        long timestamp = input.ts();\n+        add(mappedInputs, key, timestamp);\n+        for (; ; ) {\n+          Pair oldRange = partitionKeyAndTraceIdToRange.get(key);\n+          if (oldRange == null) {\n+            // Initial state is where this key has a single timestamp.\n+            oldRange =\n+              partitionKeyAndTraceIdToRange.putIfAbsent(key, new Pair(timestamp, timestamp));\n+\n+            // If there was no previous value, we need to update the index\n+            if (oldRange == null) {\n+              toUpdate.add(key);\n+              break;\n+            }\n+          }\n+\n+          long first = Math.min(timestamp, oldRange.left);\n+          long last = Math.max(timestamp, oldRange.right);\n+\n+          Pair newRange = new Pair(first, last);\n+          if (oldRange.equals(newRange)) {\n+            break; // the current timestamp is contained\n+          } else if (partitionKeyAndTraceIdToRange.replace(key, oldRange, newRange)) {\n+            toUpdate.add(key); // The range was extended\n+            break;\n+          }\n+        }\n+      }\n+\n+      // When the loop completes, we'll know one of our updates widened the interval of a trace, if\n+      // it is the first or last timestamp. By ignoring those between an existing interval, we can\n+      // end up with less Cassandra writes.\n+      Set<IndexTraceId.Input> result = new LinkedHashSet<>();\n+      for (Entry<String, Long> needsUpdate : toUpdate) {\n+        Pair range = partitionKeyAndTraceIdToRange.get(needsUpdate);\n+        if (containsEntry(mappedInputs, needsUpdate, range.left)) {\n+          result.add(Input.create(needsUpdate.getKey(), range.left, needsUpdate.getValue()));\n+        }\n+        if (containsEntry(mappedInputs, needsUpdate, range.right)) {\n+          result.add(Input.create(needsUpdate.getKey(), range.right, needsUpdate.getValue()));\n+        }\n+      }\n+      return result;\n+    }\n+\n+    static <K, V> void add(Map<K, Set<V>> multimap, K key, V value) {\n+      Set<V> valueContainer = multimap.get(key);", "originalCommit": "8a579e83f88ff6caf7e077b241b58667500db256", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyNDQ1MA==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450024450", "bodyText": "Do we need to preserve this?", "author": "anuraaga", "createdAt": "2020-07-06T07:10:24Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/IndexTraceIdByServiceName.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package zipkin2.storage.cassandra.v1;\n+\n+import com.datastax.driver.core.BoundStatement;\n+import com.datastax.driver.core.querybuilder.Insert;\n+import com.datastax.driver.core.querybuilder.QueryBuilder;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+// QueryRequest.serviceName\n+final class IndexTraceIdByServiceName extends IndexTraceId.Factory {\n+  // Legacy behaviour was to use a static singleton of ThreadLocalRandom for bucket selection", "originalCommit": "8a579e83f88ff6caf7e077b241b58667500db256", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyOTQ2OA==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450029468", "bodyText": "I punted to #3137 (comment) in case I'm missing something. let's carry on here?", "author": "codefromthecrypt", "createdAt": "2020-07-06T07:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyNDQ1MA=="}], "type": "inlineReview"}, {"oid": "ae9c1ab8c49261cc54e09f1cd3181c1eb46a077c", "url": "https://github.com/openzipkin/zipkin/commit/ae9c1ab8c49261cc54e09f1cd3181c1eb46a077c", "message": "Removes guava dep (except ListenableFuture)", "committedDate": "2020-07-06T09:17:51Z", "type": "commit"}, {"oid": "7f6a060166ec3545d538af67b68d5cb0be16d62c", "url": "https://github.com/openzipkin/zipkin/commit/7f6a060166ec3545d538af67b68d5cb0be16d62c", "message": "license", "committedDate": "2020-07-06T23:31:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyNDMzNQ==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450724335", "bodyText": "So IIUC, we clean up anytime we index a new batch of spans. May as well add a line of comment with that since it's not so obvious", "author": "anuraaga", "createdAt": "2020-07-07T09:16:43Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/TraceIdIndexer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package zipkin2.storage.cassandra.v1;\n+\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.internal.Nullable;\n+import zipkin2.storage.cassandra.v1.IndexTraceId.Input;\n+\n+/**\n+ * This ensures we only attempt to write rows that would extend the timestamp range of a trace index\n+ * query, by de-duplicating redundant entries upon {@link #iterator()}\n+ *\n+ * <p>This is shared singleton as inserts can come from any thread.\n+ */\n+interface TraceIdIndexer extends Iterable<Input> {\n+  TraceIdIndexer NOOP = new TraceIdIndexer() {\n+    @Override public void add(Input input) {\n+    }\n+\n+    @Override public Iterator<Input> iterator() {\n+      return Collections.emptyIterator();\n+    }\n+  };\n+\n+  void add(Input input);\n+\n+  /** This is shared singleton as inserts can come from any thread. */\n+  class Factory {\n+    final ConcurrentMap<Entry<String, Long>, Expiration<Entry<String, Long>, Pair>> cache =\n+      new ConcurrentHashMap<>();\n+    final DelayQueue<Expiration<Entry<String, Long>, Pair>> expirations = new DelayQueue<>();\n+    final long ttlNanos;\n+    final int cardinality;\n+    final String table;\n+\n+    Factory(String table, long ttlNanos, int cardinality) {\n+      this.table = table;\n+      this.ttlNanos = ttlNanos;\n+      this.cardinality = cardinality;\n+    }\n+\n+    long nanoTime() {\n+      return System.nanoTime();\n+    }\n+\n+    <K, V> Expiration<K, V> newExpiration(K key, V value) {\n+      return new Expiration<>(this, key, value, nanoTime() + ttlNanos);\n+    }\n+\n+    TraceIdIndexer newIndexer() {\n+      trimCache(); // We let the cache overfill per call to SpanConsumer.accept. This trims it back", "originalCommit": "7f6a060166ec3545d538af67b68d5cb0be16d62c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODA0OQ==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r451208049", "bodyText": "sure", "author": "codefromthecrypt", "createdAt": "2020-07-07T23:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyNDMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyNjM4Nw==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r450726387", "bodyText": "Do we need to check if existing is expired here?", "author": "anuraaga", "createdAt": "2020-07-07T09:20:13Z", "path": "zipkin-storage/cassandra-v1/src/main/java/zipkin2/storage/cassandra/v1/TraceIdIndexer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2015-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package zipkin2.storage.cassandra.v1;\n+\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.internal.Nullable;\n+import zipkin2.storage.cassandra.v1.IndexTraceId.Input;\n+\n+/**\n+ * This ensures we only attempt to write rows that would extend the timestamp range of a trace index\n+ * query, by de-duplicating redundant entries upon {@link #iterator()}\n+ *\n+ * <p>This is shared singleton as inserts can come from any thread.\n+ */\n+interface TraceIdIndexer extends Iterable<Input> {\n+  TraceIdIndexer NOOP = new TraceIdIndexer() {\n+    @Override public void add(Input input) {\n+    }\n+\n+    @Override public Iterator<Input> iterator() {\n+      return Collections.emptyIterator();\n+    }\n+  };\n+\n+  void add(Input input);\n+\n+  /** This is shared singleton as inserts can come from any thread. */\n+  class Factory {\n+    final ConcurrentMap<Entry<String, Long>, Expiration<Entry<String, Long>, Pair>> cache =\n+      new ConcurrentHashMap<>();\n+    final DelayQueue<Expiration<Entry<String, Long>, Pair>> expirations = new DelayQueue<>();\n+    final long ttlNanos;\n+    final int cardinality;\n+    final String table;\n+\n+    Factory(String table, long ttlNanos, int cardinality) {\n+      this.table = table;\n+      this.ttlNanos = ttlNanos;\n+      this.cardinality = cardinality;\n+    }\n+\n+    long nanoTime() {\n+      return System.nanoTime();\n+    }\n+\n+    <K, V> Expiration<K, V> newExpiration(K key, V value) {\n+      return new Expiration<>(this, key, value, nanoTime() + ttlNanos);\n+    }\n+\n+    TraceIdIndexer newIndexer() {\n+      trimCache(); // We let the cache overfill per call to SpanConsumer.accept. This trims it back\n+      return new RealTraceIdIndexer(this);\n+    }\n+\n+    void trimCache() {\n+      cleanupExpirations();\n+      while (cache.size() > cardinality) {\n+        removeOneExpiration();\n+      }\n+    }\n+\n+    void cleanupExpirations() {\n+      Expiration<?, ?> expiredexpiration;\n+      while ((expiredexpiration = expirations.poll()) != null) {\n+        cache.remove(expiredexpiration.getKey(), expiredexpiration);\n+      }\n+    }\n+\n+    void removeOneExpiration() {\n+      Expiration<?, ?> eldest;\n+      while ((eldest = expirations.peek()) != null) { // loop unless empty\n+        if (expirations.remove(eldest)) { // check for lost race\n+          cache.remove(eldest.getKey(), eldest);\n+          break; // to ensure we don't remove two!\n+        }\n+      }\n+    }\n+\n+    void clear() {\n+      cache.clear();\n+      expirations.clear();\n+    }\n+  }\n+\n+  final class Expiration<K, V> extends SimpleImmutableEntry<K, V> implements Delayed {\n+    final Factory factory;\n+    final long expiration;\n+\n+    Expiration(Factory factory, K key, V value, long expiration) {\n+      super(key, value);\n+      this.factory = factory;\n+      this.expiration = expiration;\n+    }\n+\n+    @Override public long getDelay(TimeUnit unit) {\n+      return unit.convert(expiration - factory.nanoTime(), TimeUnit.NANOSECONDS);\n+    }\n+\n+    @Override public int compareTo(Delayed o) {\n+      return Long.signum(expiration - ((Expiration) o).expiration);\n+    }\n+  }\n+\n+  final class RealTraceIdIndexer implements TraceIdIndexer {\n+    static final Logger LOG = LoggerFactory.getLogger(RealTraceIdIndexer.class);\n+\n+    final Factory factory;\n+    final Set<Input> inputs = new LinkedHashSet<>();\n+\n+    RealTraceIdIndexer(Factory factory) {\n+      this.factory = factory;\n+    }\n+\n+    @Override public void add(Input input) {\n+      inputs.add(input);\n+    }\n+\n+    /**\n+     * The input may include inserts that already occurred, or are redundant as they don't impact\n+     * QueryRequest.endTs or QueryRequest.loopback. For example, a parsed timestamp could be between\n+     * timestamps of rows that already exist for a particular trace. Optimized results will be\n+     * smaller when the input includes traces with local spans, or when other threads indexed the\n+     * same trace.\n+     */\n+    @Override public Iterator<Input> iterator() {\n+      Set<Input> result = entriesThatIncreaseGap();\n+      if (LOG.isDebugEnabled() && inputs.size() > result.size()) {\n+        int delta = inputs.size() - result.size();\n+        LOG.debug(\"optimized out {}/{} inserts into {}\", delta, inputs.size(), factory.table);\n+      }\n+      return result.iterator();\n+    }\n+\n+    Set<Input> entriesThatIncreaseGap() {\n+      if (inputs.isEmpty()) return inputs;\n+\n+      OnChangeUpdateMap toUpdate = new OnChangeUpdateMap(factory);\n+      Map<Entry<String, Long>, Set<Long>> mappedInputs = new LinkedHashMap<>();\n+\n+      // Enter a loop that affects shared state when an update widens the time interval for a key.\n+      for (Input input : inputs) {\n+        Entry<String, Long> key = toEntry(input);\n+        long timestamp = input.ts();\n+        add(mappedInputs, key, timestamp);\n+        toUpdate.currentTimestamp = timestamp;\n+        factory.cache.compute(key, toUpdate);\n+      }\n+\n+      // When the loop completes, we'll know one of our updates widened the interval of a trace, if\n+      // it is the first or last timestamp. By ignoring those between an existing interval, we can\n+      // end up with less Cassandra writes.\n+      Set<Input> result = new LinkedHashSet<>();\n+      for (Entry<String, Long> needsUpdate : toUpdate.keySet()) {\n+        Expiration<Entry<String, Long>, Pair> existing = factory.cache.get(needsUpdate);\n+\n+        // unexpected, but possible. Something could have purged all our cached entries\n+        Pair range = existing != null ? existing.getValue() : toUpdate.get(needsUpdate);", "originalCommit": "7f6a060166ec3545d538af67b68d5cb0be16d62c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODc1OQ==", "url": "https://github.com/openzipkin/zipkin/pull/3137#discussion_r451208759", "bodyText": "well since we just wrote it, it couldn't be purged due to expiry (expiration unit is seconds). the only thing possible is something else swamped the cache so it is not here due to the bounds of it (which is likely a tuning problem I suppose).\nIf it is expired we don't know if it is redundant or not is the main thing, so lack of knowledge means we should write it. I'll try to clarify in the comments.", "author": "codefromthecrypt", "createdAt": "2020-07-08T00:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyNjM4Nw=="}], "type": "inlineReview"}, {"oid": "6c3878ea8ce65e2bf3caaa0babc2122145306664", "url": "https://github.com/openzipkin/zipkin/commit/6c3878ea8ce65e2bf3caaa0babc2122145306664", "message": "try to fix comments", "committedDate": "2020-07-12T03:31:59Z", "type": "commit"}, {"oid": "1a6bc185551e6eb319b839910b9a8233165de67c", "url": "https://github.com/openzipkin/zipkin/commit/1a6bc185551e6eb319b839910b9a8233165de67c", "message": "sentence", "committedDate": "2020-07-12T03:33:41Z", "type": "commit"}]}