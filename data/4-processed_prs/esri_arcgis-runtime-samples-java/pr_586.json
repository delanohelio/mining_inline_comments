{"pr_number": 586, "pr_title": "Readme Status Checker Scripts", "pr_createdAt": "2020-11-12T10:46:04Z", "pr_url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586", "timeline": [{"oid": "9c390e23cfb81e38c9dbc81bc1fdfe7aa002fe6f", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/9c390e23cfb81e38c9dbc81bc1fdfe7aa002fe6f", "message": "setup status check files", "committedDate": "2020-10-14T14:56:47Z", "type": "commit"}, {"oid": "b2993f706a8e8981d8f3e958effb3d6e3fb26ba2", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/b2993f706a8e8981d8f3e958effb3d6e3fb26ba2", "message": "add main.yml", "committedDate": "2020-10-14T14:59:06Z", "type": "commit"}, {"oid": "969d72c58af50a7d6d590db5a2a05625ef9932cf", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/969d72c58af50a7d6d590db5a2a05625ef9932cf", "message": "edit branch name in main.yml", "committedDate": "2020-10-14T15:09:20Z", "type": "commit"}, {"oid": "466676383ba514a7d0870893bb563848042ca186", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/466676383ba514a7d0870893bb563848042ca186", "message": "update to java metadata checker", "committedDate": "2020-10-16T14:55:05Z", "type": "commit"}, {"oid": "2eb9596049ae37a5447feb6fb7ca89b67f03594f", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/2eb9596049ae37a5447feb6fb7ca89b67f03594f", "message": "amend entry.py and metadata style checker", "committedDate": "2020-10-21T15:42:07Z", "type": "commit"}, {"oid": "1756b5aa5855e88ed8f78ed035de50bb6550616d", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/1756b5aa5855e88ed8f78ed035de50bb6550616d", "message": "main.yml comment updates", "committedDate": "2020-10-23T09:11:39Z", "type": "commit"}, {"oid": "bd7e3b376576b33c6dbe9b3ae26e3ebdb42aeb46", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/bd7e3b376576b33c6dbe9b3ae26e3ebdb42aeb46", "message": "amend logic to exclude other directories in entry.py", "committedDate": "2020-10-23T10:45:53Z", "type": "commit"}, {"oid": "829f941f2970f1caad62510f60f34d5443b2987f", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/829f941f2970f1caad62510f60f34d5443b2987f", "message": "update readme and metadata scripts", "committedDate": "2020-10-23T11:28:09Z", "type": "commit"}, {"oid": "8fd041a7d82eb6be9905ba0a16c2898276b20caf", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/8fd041a7d82eb6be9905ba0a16c2898276b20caf", "message": "update list of proper nouns", "committedDate": "2020-10-23T13:07:40Z", "type": "commit"}, {"oid": "186261b68eecfa7e9cc3bd62f0885f20bcd0f53e", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/186261b68eecfa7e9cc3bd62f0885f20bcd0f53e", "message": "update to comments", "committedDate": "2020-10-23T14:31:01Z", "type": "commit"}, {"oid": "8ef8584841aa40775fa0622e28e124e7199fde91", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/8ef8584841aa40775fa0622e28e124e7199fde91", "message": "adding in category checking changes", "committedDate": "2020-10-26T15:13:19Z", "type": "commit"}, {"oid": "d94505c8e6b463aeec7075f141f1445d1b6ba4f1", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/d94505c8e6b463aeec7075f141f1445d1b6ba4f1", "message": "remove differ checks", "committedDate": "2020-11-03T11:23:39Z", "type": "commit"}, {"oid": "9adf71b56af423cf4aef318c56f07b41d91ff9ee", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/9adf71b56af423cf4aef318c56f07b41d91ff9ee", "message": "correction to entry.py filename checks", "committedDate": "2020-11-03T15:43:32Z", "type": "commit"}, {"oid": "94f3836583527c697097d7c42766bf2d594d10f2", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/94f3836583527c697097d7c42766bf2d594d10f2", "message": "edit entry.py to skip other files", "committedDate": "2020-11-03T15:48:25Z", "type": "commit"}, {"oid": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/4b2a66a2836be80eee8308cc0e04a893a24e3b48", "message": "add redirect from rule for metadata", "committedDate": "2020-11-10T16:50:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3NTAxMQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525075011", "bodyText": "This should be updated to main and we should add dev?", "author": "JonLavi", "createdAt": "2020-11-17T11:14:41Z", "path": ".github/workflows/main.yml", "diffHunk": "@@ -0,0 +1,61 @@\n+# The name of the job, which will be displayed for the status check in PR.\n+name: README and metadata formatting\n+\n+# Controls when the action will run.\n+# Below triggers the workflow on pull requests to the specified branches.\n+on:\n+  pull_request:\n+    branches:\n+      - jen/test-status-checks", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcwMTAxMg==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526701012", "bodyText": "Yes - helps if I push the change! Thanks", "author": "jenmerritt", "createdAt": "2020-11-19T09:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3NTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3NjMwNw==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525076307", "bodyText": "Can we change the name of the job to something more meaningful, e.g. verify-readme?", "author": "JonLavi", "createdAt": "2020-11-17T11:16:52Z", "path": ".github/workflows/main.yml", "diffHunk": "@@ -0,0 +1,61 @@\n+# The name of the job, which will be displayed for the status check in PR.\n+name: README and metadata formatting\n+\n+# Controls when the action will run.\n+# Below triggers the workflow on pull requests to the specified branches.\n+on:\n+  pull_request:\n+    branches:\n+      - jen/test-status-checks\n+\n+# A workflow run is made up of one or more jobs that can run sequentially or\n+# in parallel.\n+jobs:\n+  # This workflow contains a single job called \"changes\"\n+  changes:", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2MzgyMQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526763821", "bodyText": "Good idea. Changed to readme-metadata-stylecheck", "author": "jenmerritt", "createdAt": "2020-11-19T10:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3NjMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3ODQzMg==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525078432", "bodyText": "Printing out files and not files_modified here seems a bit counterintuitive, but the step id: file_changes might just pass the result into files? or does files include all the three commented-out categories? (modified/added/removed)?", "author": "JonLavi", "createdAt": "2020-11-17T11:20:40Z", "path": ".github/workflows/main.yml", "diffHunk": "@@ -0,0 +1,61 @@\n+# The name of the job, which will be displayed for the status check in PR.\n+name: README and metadata formatting\n+\n+# Controls when the action will run.\n+# Below triggers the workflow on pull requests to the specified branches.\n+on:\n+  pull_request:\n+    branches:\n+      - jen/test-status-checks\n+\n+# A workflow run is made up of one or more jobs that can run sequentially or\n+# in parallel.\n+jobs:\n+  # This workflow contains a single job called \"changes\"\n+  changes:\n+    name: Check README and metadata format for changed files\n+\n+    # Comment out the line below if the job is only running for certain labels.\n+    # i.e. only run the job on PRs with label \"new-sample\"\n+\n+    # if: contains(github.event.pull_request.labels.*.name, 'new-sample')\n+\n+    # The type of runner that the job will run on\n+    # supported VMs are here: https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners#supported-runners-and-hardware-resources\n+    runs-on: ubuntu-latest\n+\n+    # Steps represent a sequence of tasks that got executed as part of the job.\n+    steps:\n+\n+      # This step gets the paths to all changed files and returns an array\n+      # such as ['xxx/README.md', 'xxx/README.metadata.json', 'xxx/1.png']\n+      # https://github.com/trilom/file-changes-action\n+      - id: file_changes\n+        name: Detect changed file paths\n+        uses: trilom/file-changes-action@master\n+\n+      # Checks-out your repository under $GITHUB_WORKSPACE, so the workflow can\n+      # access the files.\n+      # https://github.com/actions/checkout\n+      - name: Checkout the repository\n+        uses: actions/checkout@v2\n+\n+      # Print out changed file paths for debugging purposes.\n+      - name: Print changed file paths\n+        run: |\n+          echo 'Below shows a list of changed file paths'\n+          echo '${{ steps.file_changes.outputs.files }}'\n+      #    echo '${{ steps.file_changes.outputs.files_modified }}'", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcwMjYwNQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526702605", "bodyText": "yes - files is all three: modified / added / removed. I'll improve the commenting here.", "author": "jenmerritt", "createdAt": "2020-11-19T09:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3ODQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTAxOQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525079019", "bodyText": "Just missing a newline here", "author": "JonLavi", "createdAt": "2020-11-17T11:21:47Z", "path": ".github/workflows/main.yml", "diffHunk": "@@ -0,0 +1,61 @@\n+# The name of the job, which will be displayed for the status check in PR.\n+name: README and metadata formatting\n+\n+# Controls when the action will run.\n+# Below triggers the workflow on pull requests to the specified branches.\n+on:\n+  pull_request:\n+    branches:\n+      - jen/test-status-checks\n+\n+# A workflow run is made up of one or more jobs that can run sequentially or\n+# in parallel.\n+jobs:\n+  # This workflow contains a single job called \"changes\"\n+  changes:\n+    name: Check README and metadata format for changed files\n+\n+    # Comment out the line below if the job is only running for certain labels.\n+    # i.e. only run the job on PRs with label \"new-sample\"\n+\n+    # if: contains(github.event.pull_request.labels.*.name, 'new-sample')\n+\n+    # The type of runner that the job will run on\n+    # supported VMs are here: https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners#supported-runners-and-hardware-resources\n+    runs-on: ubuntu-latest\n+\n+    # Steps represent a sequence of tasks that got executed as part of the job.\n+    steps:\n+\n+      # This step gets the paths to all changed files and returns an array\n+      # such as ['xxx/README.md', 'xxx/README.metadata.json', 'xxx/1.png']\n+      # https://github.com/trilom/file-changes-action\n+      - id: file_changes\n+        name: Detect changed file paths\n+        uses: trilom/file-changes-action@master\n+\n+      # Checks-out your repository under $GITHUB_WORKSPACE, so the workflow can\n+      # access the files.\n+      # https://github.com/actions/checkout\n+      - name: Checkout the repository\n+        uses: actions/checkout@v2\n+\n+      # Print out changed file paths for debugging purposes.\n+      - name: Print changed file paths\n+        run: |\n+          echo 'Below shows a list of changed file paths'\n+          echo '${{ steps.file_changes.outputs.files }}'\n+      #    echo '${{ steps.file_changes.outputs.files_modified }}'\n+      #    echo '${{ steps.file_changes.outputs.files_added }}'\n+      #    echo '${{ steps.file_changes.outputs.files_removed }}'\n+\n+      # Run the style checks using the scripts in the './Scripts/CI/README_Metadata_StyleCheck' directory\n+      # The scripts will run on any detected changed files from the 'file_changes' step\n+      - name: Run style checks\n+        uses: ./Scripts/CI/README_Metadata_StyleCheck\n+        with:\n+          FILE_PATHS: ${{ steps.file_changes.outputs.files }}\n+\n+      # Runs a single command using the runners shell\n+      # - name: Run a script with Python\n+      #   run: python ./Scripts/README-formatter.py", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTU0Nw==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525079547", "bodyText": "I think folder names in unix are traditionally written lowercase, so maybe we should change to ./scripts", "author": "JonLavi", "createdAt": "2020-11-17T11:22:39Z", "path": ".github/workflows/main.yml", "diffHunk": "@@ -0,0 +1,61 @@\n+# The name of the job, which will be displayed for the status check in PR.\n+name: README and metadata formatting\n+\n+# Controls when the action will run.\n+# Below triggers the workflow on pull requests to the specified branches.\n+on:\n+  pull_request:\n+    branches:\n+      - jen/test-status-checks\n+\n+# A workflow run is made up of one or more jobs that can run sequentially or\n+# in parallel.\n+jobs:\n+  # This workflow contains a single job called \"changes\"\n+  changes:\n+    name: Check README and metadata format for changed files\n+\n+    # Comment out the line below if the job is only running for certain labels.\n+    # i.e. only run the job on PRs with label \"new-sample\"\n+\n+    # if: contains(github.event.pull_request.labels.*.name, 'new-sample')\n+\n+    # The type of runner that the job will run on\n+    # supported VMs are here: https://docs.github.com/en/free-pro-team@latest/actions/reference/specifications-for-github-hosted-runners#supported-runners-and-hardware-resources\n+    runs-on: ubuntu-latest\n+\n+    # Steps represent a sequence of tasks that got executed as part of the job.\n+    steps:\n+\n+      # This step gets the paths to all changed files and returns an array\n+      # such as ['xxx/README.md', 'xxx/README.metadata.json', 'xxx/1.png']\n+      # https://github.com/trilom/file-changes-action\n+      - id: file_changes\n+        name: Detect changed file paths\n+        uses: trilom/file-changes-action@master\n+\n+      # Checks-out your repository under $GITHUB_WORKSPACE, so the workflow can\n+      # access the files.\n+      # https://github.com/actions/checkout\n+      - name: Checkout the repository\n+        uses: actions/checkout@v2\n+\n+      # Print out changed file paths for debugging purposes.\n+      - name: Print changed file paths\n+        run: |\n+          echo 'Below shows a list of changed file paths'\n+          echo '${{ steps.file_changes.outputs.files }}'\n+      #    echo '${{ steps.file_changes.outputs.files_modified }}'\n+      #    echo '${{ steps.file_changes.outputs.files_added }}'\n+      #    echo '${{ steps.file_changes.outputs.files_removed }}'\n+\n+      # Run the style checks using the scripts in the './Scripts/CI/README_Metadata_StyleCheck' directory", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTgxNg==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525079816", "bodyText": "newline missing here as well", "author": "JonLavi", "createdAt": "2020-11-17T11:23:05Z", "path": "Scripts/CI/README_Metadata_StyleCheck/Dockerfile", "diffHunk": "@@ -0,0 +1,16 @@\n+FROM alpine:3.12\n+MAINTAINER Ting Chen <tchen@esri.com>\n+ENV PYTHONUNBUFFERED=1\n+# Add scripts for the check.\n+ADD entry.py /entry.py\n+ADD style.rb /style.rb\n+ADD metadata_style_checker.py /metadata_style_checker.py\n+ADD README_style_checker.py /README_style_checker.py\n+# Install dependencies.\n+RUN echo \"**** Install Ruby and mdl ****\" && \\\n+    apk add --update --no-cache ruby-full && \\\n+    gem install mdl --no-document && \\\n+    echo \"**** Install Python ****\" && \\\n+    apk add --no-cache python3 && \\\n+    if [ ! -e /usr/bin/python ]; then ln -sf python3 /usr/bin/python ; fi\n+ENTRYPOINT [\"python3\", \"/entry.py\"]", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MDcxOQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525080719", "bodyText": "Is this list for sample names only, specific sections of the readme, or any word inside a readme?\nIn case of the latter, we should add KML as well, but there's probably many more that we'd add along the way", "author": "JonLavi", "createdAt": "2020-11-17T11:24:42Z", "path": "Scripts/CI/README_Metadata_StyleCheck/README_style_checker.py", "diffHunk": "@@ -0,0 +1,435 @@\n+#!/usr/bin/env python3\n+\n+\"\"\"\n+Comments in PyCharm style.\n+References\n+\"\"\"\n+\n+import os\n+import re\n+import typing\n+import argparse\n+\n+# region Global sets\n+# A set of words that get omitted during letter-case checks.\n+exception_proper_nouns = {\n+    'WmsLayer',\n+    'ArcGIS Online',\n+    'OAuth',\n+    'Web Mercator',\n+    'ArcGIS Pro',\n+    'GeoPackage',\n+    'loadStatus',\n+    'Integrated Windows Authentication',\n+    'GeoElement',\n+    'Network Link',\n+    'Network Link Control',\n+    'Open Street Map',\n+    'OpenStreetMap',\n+    'Play KML Tour',", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5NjA1Ng==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525096056", "bodyText": "In hindsight, might be good to have this in a separate file as well, so that we have a central place to refer to the keywords", "author": "JonLavi", "createdAt": "2020-11-17T11:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MDcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxODIyNg==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526718226", "bodyText": "This is specifically for the \"tags\" section and \"title\". It is for when it checks casing by comparing uppercase and lowercase so KML is ok as it will equal KML (but not kml) whereas e.g. GeoPackage will not equal GEOPACKAGE or geopackage. So in this list I've picked out all the titles that don't fit this rule (e.g. Play KML Tour) and any tags identified as not fitting this rule.\nOther sections are left alone, e.g. Relevant API where they contain a lot / almost exclusively these proper nouns.\nI've added to the commenting here too.", "author": "jenmerritt", "createdAt": "2020-11-19T09:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MDcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxOTE1OA==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526719158", "bodyText": "Ah now I follow! Thanks \ud83d\ude04", "author": "JonLavi", "createdAt": "2020-11-19T09:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NDgyNA==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525084824", "bodyText": "I can't tell if the actual number of exceptions is being used anywhere, so maybe it's possible to switch to true/false?\nI do recall there was an exit code 0/1 though, so maybe there's a technical reason for this as well.", "author": "JonLavi", "createdAt": "2020-11-17T11:32:00Z", "path": "Scripts/CI/README_Metadata_StyleCheck/README_style_checker.py", "diffHunk": "@@ -0,0 +1,435 @@\n+#!/usr/bin/env python3\n+\n+\"\"\"\n+Comments in PyCharm style.\n+References\n+\"\"\"\n+\n+import os\n+import re\n+import typing\n+import argparse\n+\n+# region Global sets\n+# A set of words that get omitted during letter-case checks.\n+exception_proper_nouns = {\n+    'WmsLayer',\n+    'ArcGIS Online',\n+    'OAuth',\n+    'Web Mercator',\n+    'ArcGIS Pro',\n+    'GeoPackage',\n+    'loadStatus',\n+    'Integrated Windows Authentication',\n+    'GeoElement',\n+    'Network Link',\n+    'Network Link Control',\n+    'Open Street Map',\n+    'OpenStreetMap',\n+    'Play KML Tour',\n+    'Local Server',\n+    'Graphics Overlay Dictionary Renderer'\n+}\n+\n+# A set of category folder names in current sample viewer.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}\n+# endregion\n+\n+\n+# region Static functions\n+def get_folder_name_from_path(path: str, index: int = -1) -> str:\n+    \"\"\"\n+    Get the folder name from a full path.\n+    :param path: A string of a full/absolute path to a folder.\n+    :param index: The index of path parts. Default to -1 to get the most\n+    trailing folder in the path; set to certain index to get other parts.\n+    :return: The folder name.\n+    \"\"\"\n+    return os.path.normpath(path).split(os.path.sep)[index]\n+\n+\n+def parse_head(head_string: str) -> (str, str):\n+    \"\"\"\n+    Parse the head of README and get title and description.\n+    :param head_string: A string containing title, description and images.\n+    :return: Stripped title and description strings.\n+    \"\"\"\n+    # Split title section and rule out empty lines.\n+    parts = list(filter(bool, head_string.splitlines()))\n+    if len(parts) < 3:\n+        raise Exception('README should contain title, description and image.')\n+    title = parts[0].lstrip('# ').rstrip()\n+    description = parts[1].strip()\n+    return title, description\n+\n+\n+def check_apis(apis_string: str) -> typing.Set[str]:\n+    \"\"\"\n+    Check the format for `Relevant API` section.\n+    :param apis_string: A multiline string containing all APIs.\n+    :return: A set of APIs. Throws if format is wrong.\n+    \"\"\"\n+    stripped = apis_string.strip()\n+    apis = list(stripped.splitlines())\n+    if not apis:\n+        raise Exception('Empty Relevant APIs.')\n+    s = set()\n+    stripped_apis = []\n+    for api in apis:\n+        # Bullet is checked by the linter, no need to check here.\n+        a = api.lstrip('*- ').rstrip()\n+        s.add(a)\n+        stripped_apis.append(a)\n+        if '`' in a:\n+            raise Exception('API should not include backticks.')\n+    if '' in s:\n+        raise Exception('Empty line in APIs.')\n+    if len(apis) > len(s):\n+        raise Exception('Duplicate APIs.')\n+    if stripped_apis != sorted(stripped_apis, key=str.casefold):\n+        raise Exception('APIs are not sorted.')\n+    return s\n+\n+\n+def check_tags(tags_string: str) -> typing.Set[str]:\n+    \"\"\"\n+    Check the format for `Tags` section.\n+    :param tags_string: A string containing all tags, with comma as delimiter.\n+    :return: A set of tags. Throws if format is wrong.\n+    \"\"\"\n+    tags = tags_string.split(',')\n+    if not tags:\n+        raise Exception('Empty tags.')\n+    s = set()\n+    stripped_tags = []\n+    for tag in tags:\n+        t = tag.strip()\n+        s.add(t)\n+        stripped_tags.append(t)\n+        if t.lower() != t and t.upper() != t and t.capitalize() != t \\\n+                and t not in exception_proper_nouns:\n+            raise Exception(f'Wrong letter case for tag: \"{t}\".')\n+    if '' in s:\n+        raise Exception('Empty char in tags.')\n+    if ', '.join(stripped_tags) != tags_string.strip():\n+        raise Exception('Extra whitespaces in tags.')\n+    if len(tags) > len(s):\n+        raise Exception('Duplicate tags.')\n+    if stripped_tags != sorted(stripped_tags, key=str.casefold):\n+        raise Exception('Tags are not sorted.')\n+    return s\n+\n+\n+def check_sentence_case(string: str) -> None:\n+    \"\"\"\n+    Check if a sentence follows 'sentence case'. A few examples below.\n+    Hello world! -> YES\n+    I'm a good guy. -> YES\n+    a man and a gun. -> NO\n+    A WMS layer -> YES, as it's allowed to include proper nouns\n+    :param string: Input sentence, typically the title string.\n+    :return: None. Throws if is not sentence case.\n+    \"\"\"\n+    # Check empty string.\n+    if not string:\n+        raise Exception('Empty title string.')\n+    # The whole sentence get excepted.\n+    if string in exception_proper_nouns:\n+        return\n+    # Split sentence into words.\n+    words = string.split()\n+    # First word should either be Title-cased or a proper noun (UPPERCASE).\n+    if words[0][0].upper() != words[0][0] and words[0].upper() != words[0] \\\n+            and words[0] not in exception_proper_nouns:\n+        raise Exception('Wrong letter case for the first word in title.')\n+    # If a word is neither lowercase nor UPPERCASE then it is not great.\n+    for word in words[1:]:\n+        word = word.strip('()')\n+        if word.lower() != word and word.upper() != word \\\n+                and word not in exception_proper_nouns:\n+            raise Exception(f'Wrong letter case for word: \"{word}\" in title.')\n+\n+\n+def check_is_subsequence(list_a: typing.List[str],\n+                         list_b: typing.List[str]) -> int:\n+    \"\"\"\n+    Check if list A is a subsequence of list B.\n+    E.g.\n+    list_a = ['a', 'b', 'c']\n+    list_b = ['a', 'h', 'b', 'g', 'd', 'c']\n+    -> returns 0, which means all elements in list_a is also in list_b\n+    :param list_a: A list of strings, presumably the section titles of a README.\n+    :param list_b: A list of strings, presumably all valid titles in order.\n+    :return: 0 if list_a is subsequence of list_b.\n+    \"\"\"\n+    # Empty list is always a subsequence of other lists.\n+    if not list_a:\n+        return True\n+    pa = len(list_a)\n+    for pb in range(len(list_b), 0, -1):\n+        pa -= 1 if list_b[pb-1] == list_a[pa-1] else 0\n+    return pa\n+# endregion\n+\n+\n+class ReadmeStyleChecker:\n+\n+    essential_headers = {\n+        'Use case',\n+        'How to use the sample',\n+        'How it works',\n+        'Relevant API',\n+        'Tags'\n+    }\n+\n+    possible_headers = [\n+        'Use case',\n+        'How to use the sample',\n+        'How it works',\n+        'Relevant API',\n+        'Offline data',\n+        'About the data',\n+        'Additional information',\n+        'Tags'\n+    ]\n+\n+    def __init__(self, folder_path: str):\n+        self.folder_path = folder_path\n+        self.folder_name = get_folder_name_from_path(folder_path)\n+        self.readme_path = os.path.join(folder_path, 'README.md')\n+        self.readme_contents = None\n+        self.readme_parts = None\n+        self.readme_headers = None\n+\n+    def populate_from_readme(self) -> None:\n+        \"\"\"\n+        Read and parse the sections from README.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            readme_file = open(self.readme_path, 'r')\n+            # read the readme content into a string\n+            contents = readme_file.read()\n+            # A regular expression that matches exactly 2 pound marks, and\n+            # capture the trailing string.\n+            pattern = re.compile(r'^#{2}(?!#)\\s(.*)', re.MULTILINE)\n+            self.readme_contents = contents\n+            # Use regex to split the README by section headers, so that they are\n+            # separated into paragraphs.\n+            self.readme_parts = re.split(pattern, contents)\n+            # Capture the section headers.\n+            self.readme_headers = re.findall(pattern, contents)\n+        except Exception as err:\n+            raise Exception(f'Error loading file - {self.readme_path} - {err}.')\n+        else:\n+            readme_file.close()\n+\n+    def check_format_heading(self) -> None:\n+        \"\"\"\n+        Check if\n+        1. essential section headers present.\n+        2. all sections are valid.\n+        3. section headers are in correct order.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        header_set = set(self.readme_headers)\n+        possible_header_set = set(self.possible_headers)\n+        # Check if all sections are valid.\n+        sets_diff = header_set - possible_header_set\n+        if sets_diff:\n+            raise Exception(\n+                f'Error header - Unexpected header or extra whitespace'\n+                f' - \"{sets_diff}\".')\n+        # Check if all essential section headers present.\n+        sets_diff = self.essential_headers - header_set\n+        if sets_diff:\n+            raise Exception(\n+                f'Error header - Missing essential header(s) - \"{sets_diff}\".')\n+        # Check if all sections are in correct order.\n+        index = check_is_subsequence(self.readme_headers, self.possible_headers)\n+        if index:\n+            raise Exception(\n+                f'Error header - Wrong order at - '\n+                f'\"{self.readme_headers[index-1]}\".')\n+\n+    def check_format_title_section(self) -> None:\n+        \"\"\"\n+        Check if\n+        1. the head has at least 3 parts (title, description and image URLs).\n+        2. the title string uses sentence case.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            title, _ = parse_head(self.readme_parts[0])\n+            check_sentence_case(title)\n+        except Exception as err:\n+            raise Exception(f'Error title - {err}')\n+\n+    def check_format_apis(self) -> None:\n+        \"\"\"\n+        Check if APIs\n+        1. do not have backticks.\n+        2. are sorted.\n+        3. do not have duplicate entries.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            api_section_index = self.readme_parts.index('Relevant API') + 1\n+            check_apis(self.readme_parts[api_section_index])\n+        except Exception as err:\n+            raise Exception(f'Error APIs - {err}')\n+\n+    def check_format_tags(self) -> None:\n+        \"\"\"\n+        Check if tags\n+        1. are in correct case.\n+        2. are sorted.\n+        3. do not have duplicate entries.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            tags_section_index = self.readme_parts.index('Tags') + 1\n+            check_tags(self.readme_parts[tags_section_index])\n+        except Exception as err:\n+            raise Exception(f'Error tags - {err}')\n+\n+    def check_redundant_apis_in_tags(self) -> None:\n+        \"\"\"\n+        Check if APIs and tags intersect.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            tags_section_index = self.readme_parts.index('Tags') + 1\n+            api_section_index = self.readme_parts.index('Relevant API') + 1\n+            api_set = check_apis(self.readme_parts[api_section_index])\n+            tag_set = check_tags(self.readme_parts[tags_section_index])\n+            if not api_set.isdisjoint(tag_set):\n+                raise Exception(f'Error tags - API should not be in tags')\n+        except Exception as err:\n+            raise Exception(f'Error checking extra tags due to previous error')\n+\n+\n+# region Main wrapper functions\n+def run_check(path: str, count: int) -> int:\n+    checker = ReadmeStyleChecker(path)\n+    # 1. Populate from README.\n+    try:\n+        checker.populate_from_readme()\n+    except Exception as err:\n+        count += 1", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2MzIwNQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526763205", "bodyText": "Yeah I think you're right. I think this is being output with the exception to show where the exception is e.g.\n1. map/display-map - Error title - README should contain title, description and image.\n1. being the count. I guess because count is only 0/1 here where it compares exception_count to 0 it could be feasible to do true/false. But it maybe works with the exit code style? I'm hesitant to break this right now but could make a note in the CS issue if you think it'd be a good tidy up / improvement to explore?", "author": "jenmerritt", "createdAt": "2020-11-19T10:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NDgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3NjMzMQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526776331", "bodyText": "No worries, it's nothing major. Might be worth having a play with it, but if the errors are printed with a 'count' then that's ok too.", "author": "JonLavi", "createdAt": "2020-11-19T11:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NzAzMw==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525087033", "bodyText": "Missing newline here as well", "author": "JonLavi", "createdAt": "2020-11-17T11:36:00Z", "path": "Scripts/CI/README_Metadata_StyleCheck/README_style_checker.py", "diffHunk": "@@ -0,0 +1,435 @@\n+#!/usr/bin/env python3\n+\n+\"\"\"\n+Comments in PyCharm style.\n+References\n+\"\"\"\n+\n+import os\n+import re\n+import typing\n+import argparse\n+\n+# region Global sets\n+# A set of words that get omitted during letter-case checks.\n+exception_proper_nouns = {\n+    'WmsLayer',\n+    'ArcGIS Online',\n+    'OAuth',\n+    'Web Mercator',\n+    'ArcGIS Pro',\n+    'GeoPackage',\n+    'loadStatus',\n+    'Integrated Windows Authentication',\n+    'GeoElement',\n+    'Network Link',\n+    'Network Link Control',\n+    'Open Street Map',\n+    'OpenStreetMap',\n+    'Play KML Tour',\n+    'Local Server',\n+    'Graphics Overlay Dictionary Renderer'\n+}\n+\n+# A set of category folder names in current sample viewer.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}\n+# endregion\n+\n+\n+# region Static functions\n+def get_folder_name_from_path(path: str, index: int = -1) -> str:\n+    \"\"\"\n+    Get the folder name from a full path.\n+    :param path: A string of a full/absolute path to a folder.\n+    :param index: The index of path parts. Default to -1 to get the most\n+    trailing folder in the path; set to certain index to get other parts.\n+    :return: The folder name.\n+    \"\"\"\n+    return os.path.normpath(path).split(os.path.sep)[index]\n+\n+\n+def parse_head(head_string: str) -> (str, str):\n+    \"\"\"\n+    Parse the head of README and get title and description.\n+    :param head_string: A string containing title, description and images.\n+    :return: Stripped title and description strings.\n+    \"\"\"\n+    # Split title section and rule out empty lines.\n+    parts = list(filter(bool, head_string.splitlines()))\n+    if len(parts) < 3:\n+        raise Exception('README should contain title, description and image.')\n+    title = parts[0].lstrip('# ').rstrip()\n+    description = parts[1].strip()\n+    return title, description\n+\n+\n+def check_apis(apis_string: str) -> typing.Set[str]:\n+    \"\"\"\n+    Check the format for `Relevant API` section.\n+    :param apis_string: A multiline string containing all APIs.\n+    :return: A set of APIs. Throws if format is wrong.\n+    \"\"\"\n+    stripped = apis_string.strip()\n+    apis = list(stripped.splitlines())\n+    if not apis:\n+        raise Exception('Empty Relevant APIs.')\n+    s = set()\n+    stripped_apis = []\n+    for api in apis:\n+        # Bullet is checked by the linter, no need to check here.\n+        a = api.lstrip('*- ').rstrip()\n+        s.add(a)\n+        stripped_apis.append(a)\n+        if '`' in a:\n+            raise Exception('API should not include backticks.')\n+    if '' in s:\n+        raise Exception('Empty line in APIs.')\n+    if len(apis) > len(s):\n+        raise Exception('Duplicate APIs.')\n+    if stripped_apis != sorted(stripped_apis, key=str.casefold):\n+        raise Exception('APIs are not sorted.')\n+    return s\n+\n+\n+def check_tags(tags_string: str) -> typing.Set[str]:\n+    \"\"\"\n+    Check the format for `Tags` section.\n+    :param tags_string: A string containing all tags, with comma as delimiter.\n+    :return: A set of tags. Throws if format is wrong.\n+    \"\"\"\n+    tags = tags_string.split(',')\n+    if not tags:\n+        raise Exception('Empty tags.')\n+    s = set()\n+    stripped_tags = []\n+    for tag in tags:\n+        t = tag.strip()\n+        s.add(t)\n+        stripped_tags.append(t)\n+        if t.lower() != t and t.upper() != t and t.capitalize() != t \\\n+                and t not in exception_proper_nouns:\n+            raise Exception(f'Wrong letter case for tag: \"{t}\".')\n+    if '' in s:\n+        raise Exception('Empty char in tags.')\n+    if ', '.join(stripped_tags) != tags_string.strip():\n+        raise Exception('Extra whitespaces in tags.')\n+    if len(tags) > len(s):\n+        raise Exception('Duplicate tags.')\n+    if stripped_tags != sorted(stripped_tags, key=str.casefold):\n+        raise Exception('Tags are not sorted.')\n+    return s\n+\n+\n+def check_sentence_case(string: str) -> None:\n+    \"\"\"\n+    Check if a sentence follows 'sentence case'. A few examples below.\n+    Hello world! -> YES\n+    I'm a good guy. -> YES\n+    a man and a gun. -> NO\n+    A WMS layer -> YES, as it's allowed to include proper nouns\n+    :param string: Input sentence, typically the title string.\n+    :return: None. Throws if is not sentence case.\n+    \"\"\"\n+    # Check empty string.\n+    if not string:\n+        raise Exception('Empty title string.')\n+    # The whole sentence get excepted.\n+    if string in exception_proper_nouns:\n+        return\n+    # Split sentence into words.\n+    words = string.split()\n+    # First word should either be Title-cased or a proper noun (UPPERCASE).\n+    if words[0][0].upper() != words[0][0] and words[0].upper() != words[0] \\\n+            and words[0] not in exception_proper_nouns:\n+        raise Exception('Wrong letter case for the first word in title.')\n+    # If a word is neither lowercase nor UPPERCASE then it is not great.\n+    for word in words[1:]:\n+        word = word.strip('()')\n+        if word.lower() != word and word.upper() != word \\\n+                and word not in exception_proper_nouns:\n+            raise Exception(f'Wrong letter case for word: \"{word}\" in title.')\n+\n+\n+def check_is_subsequence(list_a: typing.List[str],\n+                         list_b: typing.List[str]) -> int:\n+    \"\"\"\n+    Check if list A is a subsequence of list B.\n+    E.g.\n+    list_a = ['a', 'b', 'c']\n+    list_b = ['a', 'h', 'b', 'g', 'd', 'c']\n+    -> returns 0, which means all elements in list_a is also in list_b\n+    :param list_a: A list of strings, presumably the section titles of a README.\n+    :param list_b: A list of strings, presumably all valid titles in order.\n+    :return: 0 if list_a is subsequence of list_b.\n+    \"\"\"\n+    # Empty list is always a subsequence of other lists.\n+    if not list_a:\n+        return True\n+    pa = len(list_a)\n+    for pb in range(len(list_b), 0, -1):\n+        pa -= 1 if list_b[pb-1] == list_a[pa-1] else 0\n+    return pa\n+# endregion\n+\n+\n+class ReadmeStyleChecker:\n+\n+    essential_headers = {\n+        'Use case',\n+        'How to use the sample',\n+        'How it works',\n+        'Relevant API',\n+        'Tags'\n+    }\n+\n+    possible_headers = [\n+        'Use case',\n+        'How to use the sample',\n+        'How it works',\n+        'Relevant API',\n+        'Offline data',\n+        'About the data',\n+        'Additional information',\n+        'Tags'\n+    ]\n+\n+    def __init__(self, folder_path: str):\n+        self.folder_path = folder_path\n+        self.folder_name = get_folder_name_from_path(folder_path)\n+        self.readme_path = os.path.join(folder_path, 'README.md')\n+        self.readme_contents = None\n+        self.readme_parts = None\n+        self.readme_headers = None\n+\n+    def populate_from_readme(self) -> None:\n+        \"\"\"\n+        Read and parse the sections from README.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            readme_file = open(self.readme_path, 'r')\n+            # read the readme content into a string\n+            contents = readme_file.read()\n+            # A regular expression that matches exactly 2 pound marks, and\n+            # capture the trailing string.\n+            pattern = re.compile(r'^#{2}(?!#)\\s(.*)', re.MULTILINE)\n+            self.readme_contents = contents\n+            # Use regex to split the README by section headers, so that they are\n+            # separated into paragraphs.\n+            self.readme_parts = re.split(pattern, contents)\n+            # Capture the section headers.\n+            self.readme_headers = re.findall(pattern, contents)\n+        except Exception as err:\n+            raise Exception(f'Error loading file - {self.readme_path} - {err}.')\n+        else:\n+            readme_file.close()\n+\n+    def check_format_heading(self) -> None:\n+        \"\"\"\n+        Check if\n+        1. essential section headers present.\n+        2. all sections are valid.\n+        3. section headers are in correct order.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        header_set = set(self.readme_headers)\n+        possible_header_set = set(self.possible_headers)\n+        # Check if all sections are valid.\n+        sets_diff = header_set - possible_header_set\n+        if sets_diff:\n+            raise Exception(\n+                f'Error header - Unexpected header or extra whitespace'\n+                f' - \"{sets_diff}\".')\n+        # Check if all essential section headers present.\n+        sets_diff = self.essential_headers - header_set\n+        if sets_diff:\n+            raise Exception(\n+                f'Error header - Missing essential header(s) - \"{sets_diff}\".')\n+        # Check if all sections are in correct order.\n+        index = check_is_subsequence(self.readme_headers, self.possible_headers)\n+        if index:\n+            raise Exception(\n+                f'Error header - Wrong order at - '\n+                f'\"{self.readme_headers[index-1]}\".')\n+\n+    def check_format_title_section(self) -> None:\n+        \"\"\"\n+        Check if\n+        1. the head has at least 3 parts (title, description and image URLs).\n+        2. the title string uses sentence case.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            title, _ = parse_head(self.readme_parts[0])\n+            check_sentence_case(title)\n+        except Exception as err:\n+            raise Exception(f'Error title - {err}')\n+\n+    def check_format_apis(self) -> None:\n+        \"\"\"\n+        Check if APIs\n+        1. do not have backticks.\n+        2. are sorted.\n+        3. do not have duplicate entries.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            api_section_index = self.readme_parts.index('Relevant API') + 1\n+            check_apis(self.readme_parts[api_section_index])\n+        except Exception as err:\n+            raise Exception(f'Error APIs - {err}')\n+\n+    def check_format_tags(self) -> None:\n+        \"\"\"\n+        Check if tags\n+        1. are in correct case.\n+        2. are sorted.\n+        3. do not have duplicate entries.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            tags_section_index = self.readme_parts.index('Tags') + 1\n+            check_tags(self.readme_parts[tags_section_index])\n+        except Exception as err:\n+            raise Exception(f'Error tags - {err}')\n+\n+    def check_redundant_apis_in_tags(self) -> None:\n+        \"\"\"\n+        Check if APIs and tags intersect.\n+        :return: None. Throws if exception occurs.\n+        \"\"\"\n+        try:\n+            tags_section_index = self.readme_parts.index('Tags') + 1\n+            api_section_index = self.readme_parts.index('Relevant API') + 1\n+            api_set = check_apis(self.readme_parts[api_section_index])\n+            tag_set = check_tags(self.readme_parts[tags_section_index])\n+            if not api_set.isdisjoint(tag_set):\n+                raise Exception(f'Error tags - API should not be in tags')\n+        except Exception as err:\n+            raise Exception(f'Error checking extra tags due to previous error')\n+\n+\n+# region Main wrapper functions\n+def run_check(path: str, count: int) -> int:\n+    checker = ReadmeStyleChecker(path)\n+    # 1. Populate from README.\n+    try:\n+        checker.populate_from_readme()\n+    except Exception as err:\n+        count += 1\n+        print(f'{count}. {checker.folder_path} - {err}')\n+    # 2. Check format of headings, e.g. 'Use case', 'How it works', etc.\n+    try:\n+        checker.check_format_heading()\n+    except Exception as err:\n+        count += 1\n+        print(f'{count}. {checker.folder_path} - {err}')\n+    # 3. Check format of title section, i.e. title, description and image URLs.\n+    try:\n+        checker.check_format_title_section()\n+    except Exception as err:\n+        count += 1\n+        print(f'{count}. {checker.folder_path} - {err}')\n+    # 4. Check format of relevant APIs.\n+    try:\n+        checker.check_format_apis()\n+    except Exception as err:\n+        count += 1\n+        print(f'{count}. {checker.folder_path} - {err}')\n+    # 5. Check format of tags.\n+    try:\n+        checker.check_format_tags()\n+    except Exception as err:\n+        count += 1\n+        print(f'{count}. {checker.folder_path} - {err}')\n+    # 6. Check if redundant APIs in tags\n+    try:\n+        checker.check_redundant_apis_in_tags()\n+    except Exception as err:\n+        count += 1\n+        print(f'{count}. {checker.folder_path} - {err}')\n+    return count\n+\n+\n+def single(path: str):\n+    exception_count = run_check(path, 0)\n+    # Throw once if there are exceptions.\n+    if exception_count > 0:\n+        raise Exception('Error(s) occurred during checking a single design.')\n+\n+\n+def all_designs(path: str):\n+    exception_count = 0\n+    for root, dirs, files in os.walk(path):\n+        # Get parent folder name.\n+        parent_folder_name = get_folder_name_from_path(root)\n+        # If parent folder name is a valid category name.\n+        if parent_folder_name in categories:\n+            for dir_name in dirs:\n+                sample_path = os.path.join(root, dir_name)\n+                # Omit empty folders - they are omitted by Git.\n+                if len([f for f in os.listdir(sample_path)\n+                        if not f.startswith('.DS_Store')]) == 0:\n+                    continue\n+                exception_count = run_check(sample_path, exception_count)\n+\n+    # Throw once if there are exceptions.\n+    if exception_count > 0:\n+        raise Exception('Error(s) occurred during checking all samples.')\n+\n+\n+def main():\n+\n+    msg = 'README checker script. Run it against the root folder' \\\n+          'or a single sample folder. ' \\\n+          'On success: Script will exit with zero. ' \\\n+          'On failure: Style violations will print to console and the script ' \\\n+          'will exit with non-zero code.'\n+    parser = argparse.ArgumentParser(description=msg)\n+    parser.add_argument('-a', '--all', help='path to project root folder')\n+    parser.add_argument('-s', '--single', help='path to a sample folder')\n+    args = parser.parse_args()\n+    if args.all:\n+        try:\n+            all_designs(args.all)\n+        except Exception as err:\n+            raise err\n+    elif args.single:\n+        try:\n+            single(args.single)\n+        except Exception as err:\n+            raise err\n+    else:\n+        raise Exception('Invalid arguments, abort.')\n+# endregion\n+\n+\n+if __name__ == '__main__':\n+    try:\n+        main()\n+    except Exception as error:\n+        print(f'{error}')\n+        # Abort with failure if any exception occurs.\n+        exit(1)", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NzM0Nw==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525087347", "bodyText": "Should we update the email here at all?", "author": "JonLavi", "createdAt": "2020-11-17T11:36:34Z", "path": "Scripts/CI/README_Metadata_StyleCheck/action.yml", "diffHunk": "@@ -0,0 +1,20 @@\n+# The name of the step just as a reference.\n+name: \"mdl and Python style checks\"\n+description: \"This check will run several scripts to ensure the formatting.\"\n+author: \"tchen@esri.com\"", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyMjQ1Mg==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526722452", "bodyText": "I'll run this by Ting and how we can handle across each SDK", "author": "jenmerritt", "createdAt": "2020-11-19T09:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NzM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NzYyOA==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525087628", "bodyText": "Another missing newline, I won't comment on any other cases", "author": "JonLavi", "createdAt": "2020-11-17T11:37:02Z", "path": "Scripts/CI/README_Metadata_StyleCheck/action.yml", "diffHunk": "@@ -0,0 +1,20 @@\n+# The name of the step just as a reference.\n+name: \"mdl and Python style checks\"\n+description: \"This check will run several scripts to ensure the formatting.\"\n+author: \"tchen@esri.com\"\n+\n+inputs:\n+  FILE_PATHS:\n+    description: \"Files to run the checks on.\"\n+    required: true\n+\n+runs:\n+  using: \"docker\"\n+  image: \"Dockerfile\"\n+  args:\n+    - \"-s\"\n+    - ${{ inputs.FILE_PATHS }}\n+\n+branding:\n+  icon: \"mic\"\n+  color: \"purple\"", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4ODUyOA==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525088528", "bodyText": "I remember we discussed a solution for this. At the moment this list is repeated in README_style_checker.py.\nPerhaps we can store it in a text file categories.txt and read it in in both scripts, that way there's only one source of truth?", "author": "JonLavi", "createdAt": "2020-11-17T11:38:49Z", "path": "Scripts/CI/README_Metadata_StyleCheck/entry.py", "diffHunk": "@@ -0,0 +1,143 @@\n+#!/usr/bin/env python3\n+\n+import os\n+import json\n+import argparse\n+import subprocess as sp\n+\n+# A set of category folder names in current sample viewer.\n+# Only run the checks when a file path is within one of these category folders.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc0ODU4MQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526748581", "bodyText": "Definitely, I've added this along with a few of the other improvements that we discussed to an issue in CS repo for future work to improve. I'll do the tidy ups from the code reviews and leave anything that will need more thought/time to that issue for another iteration.", "author": "jenmerritt", "createdAt": "2020-11-19T10:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4ODUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4OTAwOQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525089009", "bodyText": "Some inconsistent whitespace here, might be nice to tidy it up", "author": "JonLavi", "createdAt": "2020-11-17T11:39:37Z", "path": "Scripts/CI/README_Metadata_StyleCheck/entry.py", "diffHunk": "@@ -0,0 +1,143 @@\n+#!/usr/bin/env python3\n+\n+import os\n+import json\n+import argparse\n+import subprocess as sp\n+\n+# A set of category folder names in current sample viewer.\n+# Only run the checks when a file path is within one of these category folders.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}\n+\n+def run_mdl(readme_path: str):\n+    print(\"**** markdownlint style checker (mdl) ****\")\n+    code = sp.call(f'mdl --style /style.rb \"{readme_path}\"', shell=True)\n+    return code\n+\n+def run_style_check(dirname: str):\n+    print(\"**** README_style_checker ****\")\n+    code1 = sp.call(f'python3 /README_style_checker.py -s \"{dirname}\"', shell=True)\n+    print(\"**** metadata_style_checker ****\")\n+    code2 = sp.call(f'python3 /metadata_style_checker.py -s \"{dirname}\"', shell=True)\n+    return code1 + code2\n+\n+", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4OTM2Mg==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525089362", "bodyText": "I think it would be helpful to add some comments here as to why we add together code1 + code2 and what the return value is used for?", "author": "JonLavi", "createdAt": "2020-11-17T11:40:15Z", "path": "Scripts/CI/README_Metadata_StyleCheck/entry.py", "diffHunk": "@@ -0,0 +1,143 @@\n+#!/usr/bin/env python3\n+\n+import os\n+import json\n+import argparse\n+import subprocess as sp\n+\n+# A set of category folder names in current sample viewer.\n+# Only run the checks when a file path is within one of these category folders.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}\n+\n+def run_mdl(readme_path: str):\n+    print(\"**** markdownlint style checker (mdl) ****\")\n+    code = sp.call(f'mdl --style /style.rb \"{readme_path}\"', shell=True)\n+    return code\n+\n+def run_style_check(dirname: str):", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NjQxNw==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526766417", "bodyText": "Added in \ud83d\udc4d", "author": "jenmerritt", "createdAt": "2020-11-19T10:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4OTM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5MTM0Mg==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525091342", "bodyText": "Same here, if we could read this in from a file, it would save having to update the list in three places", "author": "JonLavi", "createdAt": "2020-11-17T11:43:40Z", "path": "Scripts/CI/README_Metadata_StyleCheck/metadata_style_checker.py", "diffHunk": "@@ -0,0 +1,338 @@\n+import os\n+import re\n+import json\n+import typing\n+import argparse\n+import glob\n+from pathlib import Path\n+\n+# region Global sets\n+# A set of category folder names in current sample viewer.\n+categories = {", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5MTY0MA==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525091640", "bodyText": "Should we remove the commented out regex? It looks identical to the one below anyway?", "author": "JonLavi", "createdAt": "2020-11-17T11:44:13Z", "path": "Scripts/CI/README_Metadata_StyleCheck/metadata_style_checker.py", "diffHunk": "@@ -0,0 +1,338 @@\n+import os\n+import re\n+import json\n+import typing\n+import argparse\n+import glob\n+from pathlib import Path\n+\n+# region Global sets\n+# A set of category folder names in current sample viewer.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}\n+# endregion\n+\n+def sub_special_char(string: str) -> str:\n+    \"\"\"\n+    Check and substitute if a string contains special characters.\n+    :param string: The input string.\n+    :return: A new string\n+    \"\"\"\n+    # regex = re.compile('[@_!#$%^&*<>?|/\\\\}{~:]')", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5NDI5Ng==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r525094296", "bodyText": "I think if we use the output of this script https://devtopia.esri.com/runtime/common-samples/tree/master/tools/java\nas the source of truth, and compare it against the README.metadata.json that is uploaded in the PR, then maybe it'd be easier to run the script and just overwrite whichever comes from the PR? It does feel a bit invasive, but there wouldn't be a way to pass this check if the metadata file isn't identical to the script output anyway?\nAt this point we maybe need to consider what/where we need to make changes in case this script is stopping us from merging a metadata file as is?", "author": "JonLavi", "createdAt": "2020-11-17T11:48:43Z", "path": "Scripts/CI/README_Metadata_StyleCheck/metadata_style_checker.py", "diffHunk": "@@ -0,0 +1,338 @@\n+import os\n+import re\n+import json\n+import typing\n+import argparse\n+import glob\n+from pathlib import Path\n+\n+# region Global sets\n+# A set of category folder names in current sample viewer.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}\n+# endregion\n+\n+def sub_special_char(string: str) -> str:\n+    \"\"\"\n+    Check and substitute if a string contains special characters.\n+    :param string: The input string.\n+    :return: A new string\n+    \"\"\"\n+    # regex = re.compile('[@_!#$%^&*<>?|/\\\\}{~:]')\n+    regex = re.compile(r'[@_!#$%^&*<>?|/\\\\}{~:]')\n+    return re.sub(regex, '', string)\n+\n+def parse_head(head_string: str) -> (str, str):\n+    \"\"\"\n+    Parse the `Title` section of README file and get the title and description.\n+    :param head_string: A string containing title, description and images.\n+    :return: Stripped title and description strings.\n+    \"\"\"\n+    parts = list(filter(bool, head_string.splitlines()))\n+    if len(parts) < 3:\n+        raise Exception('README description parse failure!')\n+    title = parts[0].lstrip('# ').rstrip()\n+    description = parts[1].strip()\n+    return title, description\n+\n+def parse_apis(apis_string: str) -> typing.List[str]:\n+    \"\"\"\n+    Parse the `Relevant API` section and get a list of APIs.\n+    :param apis_string: A string containing all APIs.\n+    :return: A sorted list of stripped API names.\n+    \"\"\"\n+    apis = list(filter(bool, apis_string.splitlines()))\n+    if not apis:\n+        raise Exception('README Relevant API parse failure!')\n+\n+    expression = re.compile(r' \\(.*\\)')\n+    apis = list(map(lambda x: re.sub(expression, '', x), apis)) # remove text in brackets behind relevant api entries\n+\n+    return sorted(api.lstrip('*- ') for api in apis)\n+\n+def parse_tags(tags_string: str) -> typing.List[str]:\n+    \"\"\"\n+    Parse the `Tags` section and get a list of tags.\n+    :param tags_string: A string containing all tags, with comma as delimiter.\n+    :return: A sorted list of stripped tags.\n+    \"\"\"\n+    tags = tags_string.split(',')\n+    if not tags:\n+        raise Exception('README Tags parse failure!')\n+    return sorted([tag.strip() for tag in tags])\n+\n+def get_folder_name_from_path(path: str, index: int = -1) -> str:\n+    \"\"\"\n+    Get the folder name from a full path.\n+    :param path: A string of a full/absolute path to a folder.\n+    :return: The folder name.\n+    \"\"\"\n+    return os.path.normpath(path).split(os.path.sep)[index]\n+\n+def format_category_name_from_folder_name(folder_name: str) -> str:\n+    \"\"\"\n+    Format the category name so that it is as required by the developer site\n+    and sample viewer.\n+    e.g.  'map_view' becomes 'Map view', 'scene' becomes 'Scene'.\n+    :param folder_name: A string of the category folder name.\n+    :return: A formatted string of the category name.\n+    \"\"\"\n+    if folder_name not in categories:\n+        raise Exception(\"Invalid category folder name.\")\n+\n+    if folder_name == \"ogc\" or folder_name == \"kml\":\n+        return folder_name.upper()\n+    else:\n+        if \"_\" not in folder_name:\n+            return folder_name.capitalize()\n+        else:\n+            insert_spaces = folder_name.replace(\"_\", \" \")\n+            return insert_spaces.capitalize()\n+\n+class MetadataCreator:\n+\n+    def __init__(self, folder_path: str):\n+        \"\"\"\n+        The standard format of metadata.json. Read more at:\n+        /common-samples/wiki/README.metadata.json\n+        \"\"\"\n+        self.category = ''          # Populate from folder path.\n+        self.description = ''       # Populate from README.\n+        self.ignore = False         # Default to False.\n+        self.images = []            # Populate from folder paths.\n+        self.keywords = []          # Populate from README.\n+        self.redirect_from = \"\"     # Default to empty string.\n+        self.relevant_apis = []     # Populate from README.\n+        self.snippets = []          # Populate from folder paths.\n+        self.title = ''             # Populate from README.\n+\n+        self.folder_path = folder_path\n+        self.folder_name = get_folder_name_from_path(folder_path)\n+        self.readme_path = os.path.join(folder_path, 'README.md')\n+        self.json_path = os.path.join(folder_path, 'README.metadata.json')\n+\n+    def get_source_code_paths(self) -> typing.List[str]:\n+        \"\"\"\n+        Traverse the directory and get all filenames for source code.\n+        :return: A list of java source code filenames.\n+        \"\"\"\n+        results = []\n+\n+        paths = Path(self.folder_path).glob('**/*.java')\n+        for path in paths:\n+            results.append(os.path.relpath(path, self.folder_path))\n+\n+        paths = Path(self.folder_path).glob('**/*.fxml')\n+        for path in paths:\n+            results.append(os.path.relpath(path, self.folder_path))\n+\n+        if not results:\n+            raise Exception('Unable to get java source code paths.')\n+\n+        results = list(filter(lambda x: 'build/' not in x, results)) # exclude \\build folder\n+        results = list(filter(lambda x: 'out/' not in x, results)) # exclude \\out folder\n+        results = list(filter(lambda x: 'Launcher' not in x, results)) # exclude *Launcher.java\n+        results = list(map(lambda x: x.replace(os.sep, '/'), results)) # eliminate double backslashes in the paths\n+\n+        return sorted(results)\n+\n+    def populate_from_readme(self) -> None:\n+        \"\"\"\n+        Read and parse the sections from README, and fill in the 'title',\n+        'description', 'relevant_apis' and 'keywords' fields in the dictionary\n+        for output json.\n+        \"\"\"\n+        try:\n+            readme_file = open(self.readme_path, 'r')\n+            # read the readme content into a string\n+            readme_contents = readme_file.read()\n+        except Exception as err:\n+            print(f\"Error reading README - {self.readme_path} - {err}.\")\n+            raise err\n+        else:\n+            readme_file.close()\n+\n+        # Use regex to split the README by exactly 2 pound marks, so that they\n+        # are separated into paragraphs.\n+        pattern = re.compile(r'^#{2}(?!#)\\s(.*)', re.MULTILINE)\n+        readme_parts = re.split(pattern, readme_contents)\n+        try:\n+            api_section_index = readme_parts.index('Relevant API') + 1\n+            tags_section_index = readme_parts.index('Tags') + 1\n+            self.title, self.description = parse_head(readme_parts[0])\n+            self.relevant_apis = parse_apis(readme_parts[api_section_index])\n+            keywords = parse_tags(readme_parts[tags_section_index])\n+            # De-duplicate API names in README's Tags section.\n+            self.keywords = [w for w in keywords if w not in self.relevant_apis]\n+\n+            # \"It combines the Tags and the Relevant APIs in the README.\"\n+            # See /runtime/common-samples/wiki/README.metadata.json#keywords\n+            self.keywords += self.relevant_apis\n+        except Exception as err:\n+            print(f'Error parsing README - {self.readme_path} - {err}.')\n+            raise err\n+\n+        # extract the image hyperlink to get the image file name\n+        try:\n+        ## save the image file name\n+            image_link = re.search('\\\\!\\\\[.*\\\\]\\\\(.*\\\\.*\\\\)', readme_contents).group(0)\n+            image_name = re.sub(r'\\!\\[.*\\]\\(', '', str(image_link))\n+            image_name = re.sub(r'\\)', '', image_name)\n+            self.images = [image_name]\n+        except Exception as err:\n+            print(f'Error getting image path from README - {self.readme_path} - {err}.')\n+            raise err\n+\n+    def populate_from_paths(self) -> None:\n+        \"\"\"\n+        Populate category name and snippets from a sample's folder.\n+        \"\"\"\n+        try:\n+            category_folder = get_folder_name_from_path(self.folder_path, -2)\n+            self.category = format_category_name_from_folder_name(category_folder)\n+        except Exception as err:\n+            print(f'Error getting category folder name from path - {self.folder_path} - {err}')\n+            raise err\n+\n+        try:\n+            self.snippets = self.get_source_code_paths()\n+            self.snippets = sorted(self.snippets, key=str.lower)\n+        except Exception as err:\n+            print(f\"Error parsing paths - {self.folder_name} - {err}.\")\n+            raise err\n+\n+    def flush_to_json_string(self) -> str:\n+        \"\"\"\n+        Write the metadata to a json string.\n+        :return: json string\n+        \"\"\"\n+        data = dict()\n+\n+        data[\"category\"] = self.category\n+        data[\"description\"] = self.description\n+        data[\"ignore\"] = self.ignore\n+        data[\"images\"] = self.images\n+        data[\"keywords\"] = self.keywords\n+        data[\"redirect_from\"] = self.redirect_from\n+        data[\"relevant_apis\"] = self.relevant_apis\n+        data[\"snippets\"] = self.snippets\n+        data[\"title\"] = self.title\n+\n+        return json.dumps(data, indent=4, sort_keys=True)\n+\n+def compare_one_metadata(folder_path: str):\n+    \"\"\"\n+    A handy helper function to create 1 sample's metadata by running the script\n+    without passing in arguments, and write to a separate json for comparison.\n+    The path may look like\n+    '~/arcgis-runtime-samples-java/analysis/analyze-hotspots'\n+    \"\"\"\n+    single_updater = MetadataCreator(folder_path)\n+    try:\n+        single_updater.populate_from_readme()\n+        single_updater.populate_from_paths()\n+\n+    except Exception as err:\n+        print(f'Error populate failed for - {single_updater.folder_name}.')\n+        raise err\n+\n+    json_path = os.path.join(folder_path, 'README.metadata.json')\n+\n+    try:\n+        json_file = open(json_path, 'r')\n+        json_data = json.load(json_file)\n+    except Exception as err:\n+        print(f'Error reading JSON - {folder_path} = {err}')\n+        raise err\n+    else:\n+        json_file.close()\n+\n+    # Specific check to ensure redirect_from is not [\"\"] which breaks the website build\n+    if json_data['redirect_from'] != [\"\"]:\n+        single_updater.redirect_from = json_data['redirect_from']\n+    else:\n+        raise Exception('Error in metadata: redirect_from cannot be [\"\"]')\n+\n+    new = single_updater.flush_to_json_string()\n+    original = json.dumps(json_data, indent=4, sort_keys=True)\n+    if new != original:", "originalCommit": "4b2a66a2836be80eee8308cc0e04a893a24e3b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NDYwNw==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r526754607", "bodyText": "Definitely sounds like a good extra step towards automating - I'll add these to the notes in the issue for the next iteration, thanks \ud83d\udc4d", "author": "jenmerritt", "createdAt": "2020-11-19T10:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5NDI5Ng=="}], "type": "inlineReview"}, {"oid": "66420729b5f2a1bffae471c5f0ec8c2cac13840f", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/66420729b5f2a1bffae471c5f0ec8c2cac13840f", "message": "update branches", "committedDate": "2020-11-19T09:09:32Z", "type": "commit"}, {"oid": "f3dec7b153f7f3ccfa3f9dcd2174256b9ddcb818", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/f3dec7b153f7f3ccfa3f9dcd2174256b9ddcb818", "message": "change job name and tidy up main.yml", "committedDate": "2020-11-19T09:29:06Z", "type": "commit"}, {"oid": "c8f3105a9cbfe0541f6c99caef98dea8066b305c", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/c8f3105a9cbfe0541f6c99caef98dea8066b305c", "message": "add new lines", "committedDate": "2020-11-19T09:43:48Z", "type": "commit"}, {"oid": "3d78a79d8ef8f6928f7bb76b9d146fd50b822b89", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/3d78a79d8ef8f6928f7bb76b9d146fd50b822b89", "message": "rename folders", "committedDate": "2020-11-19T09:49:31Z", "type": "commit"}, {"oid": "1dce14ef57a73424ade49561153e6b0dff219228", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/1dce14ef57a73424ade49561153e6b0dff219228", "message": "update comment", "committedDate": "2020-11-19T10:17:35Z", "type": "commit"}, {"oid": "e0616534712416a924169c6d41a6af2d61b0f972", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/e0616534712416a924169c6d41a6af2d61b0f972", "message": "tidy up spacing", "committedDate": "2020-11-19T10:28:12Z", "type": "commit"}, {"oid": "ec92eb0d1c349ae5a3be2110e701f79c04e764db", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/ec92eb0d1c349ae5a3be2110e701f79c04e764db", "message": "remove redundant code", "committedDate": "2020-11-19T10:45:47Z", "type": "commit"}, {"oid": "c8d443a954b220942efbd695b331fe129051bfad", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/c8d443a954b220942efbd695b331fe129051bfad", "message": "add in comments", "committedDate": "2020-11-19T10:50:21Z", "type": "commit"}, {"oid": "bd8a8ec075861d420d8499fcef942a001c4a8c8d", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/bd8a8ec075861d420d8499fcef942a001c4a8c8d", "message": "merge changes from code review", "committedDate": "2020-11-19T11:39:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1MzI2NQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r530553265", "bodyText": "minor comment but stood out for me...could we make these examples a bit more inclusive and less masculine/weaponised? :D some esri related suggestions below!\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                I'm a good guy. -> YES\n          \n          \n            \n                a man and a gun. -> NO\n          \n          \n            \n                We're a mapping company. -> YES\n          \n          \n            \n                a map and a globe. -> NO", "author": "Rachael-E", "createdAt": "2020-11-25T17:53:55Z", "path": "scripts/ci/readme_metadata_style_check/README_style_checker.py", "diffHunk": "@@ -0,0 +1,435 @@\n+#!/usr/bin/env python3\n+\n+\"\"\"\n+Comments in PyCharm style.\n+References\n+\"\"\"\n+\n+import os\n+import re\n+import typing\n+import argparse\n+\n+# region Global sets\n+# A set of words that get omitted during letter-case checks for title and tags.\n+exception_proper_nouns = {\n+    'WmsLayer',\n+    'ArcGIS Online',\n+    'OAuth',\n+    'Web Mercator',\n+    'ArcGIS Pro',\n+    'GeoPackage',\n+    'loadStatus',\n+    'Integrated Windows Authentication',\n+    'GeoElement',\n+    'Network Link',\n+    'Network Link Control',\n+    'Open Street Map',\n+    'OpenStreetMap',\n+    'Play KML Tour',\n+    'Local Server',\n+    'Graphics Overlay Dictionary Renderer'\n+}\n+\n+# A set of category folder names in current sample viewer.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}\n+# endregion\n+\n+\n+# region Static functions\n+def get_folder_name_from_path(path: str, index: int = -1) -> str:\n+    \"\"\"\n+    Get the folder name from a full path.\n+    :param path: A string of a full/absolute path to a folder.\n+    :param index: The index of path parts. Default to -1 to get the most\n+    trailing folder in the path; set to certain index to get other parts.\n+    :return: The folder name.\n+    \"\"\"\n+    return os.path.normpath(path).split(os.path.sep)[index]\n+\n+\n+def parse_head(head_string: str) -> (str, str):\n+    \"\"\"\n+    Parse the head of README and get title and description.\n+    :param head_string: A string containing title, description and images.\n+    :return: Stripped title and description strings.\n+    \"\"\"\n+    # Split title section and rule out empty lines.\n+    parts = list(filter(bool, head_string.splitlines()))\n+    if len(parts) < 3:\n+        raise Exception('README should contain title, description and image.')\n+    title = parts[0].lstrip('# ').rstrip()\n+    description = parts[1].strip()\n+    return title, description\n+\n+\n+def check_apis(apis_string: str) -> typing.Set[str]:\n+    \"\"\"\n+    Check the format for `Relevant API` section.\n+    :param apis_string: A multiline string containing all APIs.\n+    :return: A set of APIs. Throws if format is wrong.\n+    \"\"\"\n+    stripped = apis_string.strip()\n+    apis = list(stripped.splitlines())\n+    if not apis:\n+        raise Exception('Empty Relevant APIs.')\n+    s = set()\n+    stripped_apis = []\n+    for api in apis:\n+        # Bullet is checked by the linter, no need to check here.\n+        a = api.lstrip('*- ').rstrip()\n+        s.add(a)\n+        stripped_apis.append(a)\n+        if '`' in a:\n+            raise Exception('API should not include backticks.')\n+    if '' in s:\n+        raise Exception('Empty line in APIs.')\n+    if len(apis) > len(s):\n+        raise Exception('Duplicate APIs.')\n+    if stripped_apis != sorted(stripped_apis, key=str.casefold):\n+        raise Exception('APIs are not sorted.')\n+    return s\n+\n+\n+def check_tags(tags_string: str) -> typing.Set[str]:\n+    \"\"\"\n+    Check the format for `Tags` section.\n+    :param tags_string: A string containing all tags, with comma as delimiter.\n+    :return: A set of tags. Throws if format is wrong.\n+    \"\"\"\n+    tags = tags_string.split(',')\n+    if not tags:\n+        raise Exception('Empty tags.')\n+    s = set()\n+    stripped_tags = []\n+    for tag in tags:\n+        t = tag.strip()\n+        s.add(t)\n+        stripped_tags.append(t)\n+        if t.lower() != t and t.upper() != t and t.capitalize() != t \\\n+                and t not in exception_proper_nouns:\n+            raise Exception(f'Wrong letter case for tag: \"{t}\".')\n+    if '' in s:\n+        raise Exception('Empty char in tags.')\n+    if ', '.join(stripped_tags) != tags_string.strip():\n+        raise Exception('Extra whitespaces in tags.')\n+    if len(tags) > len(s):\n+        raise Exception('Duplicate tags.')\n+    if stripped_tags != sorted(stripped_tags, key=str.casefold):\n+        raise Exception('Tags are not sorted.')\n+    return s\n+\n+\n+def check_sentence_case(string: str) -> None:\n+    \"\"\"\n+    Check if a sentence follows 'sentence case'. A few examples below.\n+    Hello world! -> YES\n+    I'm a good guy. -> YES\n+    a man and a gun. -> NO", "originalCommit": "bd8a8ec075861d420d8499fcef942a001c4a8c8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzk2ODc0OQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r567968749", "bodyText": "Thanks I'd skimmed the detail in these - and agree these should be updated. Adding these changes now.", "author": "jenmerritt", "createdAt": "2021-02-01T16:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1MzI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1NDI4NQ==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r530554285", "bodyText": "there are some repeats in here from essential_headers: does that matter? just wondering if there's a way to avoid repetition.", "author": "Rachael-E", "createdAt": "2020-11-25T17:55:36Z", "path": "scripts/ci/readme_metadata_style_check/README_style_checker.py", "diffHunk": "@@ -0,0 +1,435 @@\n+#!/usr/bin/env python3\n+\n+\"\"\"\n+Comments in PyCharm style.\n+References\n+\"\"\"\n+\n+import os\n+import re\n+import typing\n+import argparse\n+\n+# region Global sets\n+# A set of words that get omitted during letter-case checks for title and tags.\n+exception_proper_nouns = {\n+    'WmsLayer',\n+    'ArcGIS Online',\n+    'OAuth',\n+    'Web Mercator',\n+    'ArcGIS Pro',\n+    'GeoPackage',\n+    'loadStatus',\n+    'Integrated Windows Authentication',\n+    'GeoElement',\n+    'Network Link',\n+    'Network Link Control',\n+    'Open Street Map',\n+    'OpenStreetMap',\n+    'Play KML Tour',\n+    'Local Server',\n+    'Graphics Overlay Dictionary Renderer'\n+}\n+\n+# A set of category folder names in current sample viewer.\n+categories = {\n+    'analysis',\n+    'display_information',\n+    'editing',\n+    'feature_layers',\n+    'geometry',\n+    'group_layers',\n+    'hydrography',\n+    'image_layers',\n+    'kml',\n+    'local_server',\n+    'map',\n+    'map_view',\n+    'network_analysis',\n+    'ogc',\n+    'portal',\n+    'raster',\n+    'scene',\n+    'search',\n+    'symbology',\n+    'tiled_layers',\n+    'utility_network'\n+}\n+# endregion\n+\n+\n+# region Static functions\n+def get_folder_name_from_path(path: str, index: int = -1) -> str:\n+    \"\"\"\n+    Get the folder name from a full path.\n+    :param path: A string of a full/absolute path to a folder.\n+    :param index: The index of path parts. Default to -1 to get the most\n+    trailing folder in the path; set to certain index to get other parts.\n+    :return: The folder name.\n+    \"\"\"\n+    return os.path.normpath(path).split(os.path.sep)[index]\n+\n+\n+def parse_head(head_string: str) -> (str, str):\n+    \"\"\"\n+    Parse the head of README and get title and description.\n+    :param head_string: A string containing title, description and images.\n+    :return: Stripped title and description strings.\n+    \"\"\"\n+    # Split title section and rule out empty lines.\n+    parts = list(filter(bool, head_string.splitlines()))\n+    if len(parts) < 3:\n+        raise Exception('README should contain title, description and image.')\n+    title = parts[0].lstrip('# ').rstrip()\n+    description = parts[1].strip()\n+    return title, description\n+\n+\n+def check_apis(apis_string: str) -> typing.Set[str]:\n+    \"\"\"\n+    Check the format for `Relevant API` section.\n+    :param apis_string: A multiline string containing all APIs.\n+    :return: A set of APIs. Throws if format is wrong.\n+    \"\"\"\n+    stripped = apis_string.strip()\n+    apis = list(stripped.splitlines())\n+    if not apis:\n+        raise Exception('Empty Relevant APIs.')\n+    s = set()\n+    stripped_apis = []\n+    for api in apis:\n+        # Bullet is checked by the linter, no need to check here.\n+        a = api.lstrip('*- ').rstrip()\n+        s.add(a)\n+        stripped_apis.append(a)\n+        if '`' in a:\n+            raise Exception('API should not include backticks.')\n+    if '' in s:\n+        raise Exception('Empty line in APIs.')\n+    if len(apis) > len(s):\n+        raise Exception('Duplicate APIs.')\n+    if stripped_apis != sorted(stripped_apis, key=str.casefold):\n+        raise Exception('APIs are not sorted.')\n+    return s\n+\n+\n+def check_tags(tags_string: str) -> typing.Set[str]:\n+    \"\"\"\n+    Check the format for `Tags` section.\n+    :param tags_string: A string containing all tags, with comma as delimiter.\n+    :return: A set of tags. Throws if format is wrong.\n+    \"\"\"\n+    tags = tags_string.split(',')\n+    if not tags:\n+        raise Exception('Empty tags.')\n+    s = set()\n+    stripped_tags = []\n+    for tag in tags:\n+        t = tag.strip()\n+        s.add(t)\n+        stripped_tags.append(t)\n+        if t.lower() != t and t.upper() != t and t.capitalize() != t \\\n+                and t not in exception_proper_nouns:\n+            raise Exception(f'Wrong letter case for tag: \"{t}\".')\n+    if '' in s:\n+        raise Exception('Empty char in tags.')\n+    if ', '.join(stripped_tags) != tags_string.strip():\n+        raise Exception('Extra whitespaces in tags.')\n+    if len(tags) > len(s):\n+        raise Exception('Duplicate tags.')\n+    if stripped_tags != sorted(stripped_tags, key=str.casefold):\n+        raise Exception('Tags are not sorted.')\n+    return s\n+\n+\n+def check_sentence_case(string: str) -> None:\n+    \"\"\"\n+    Check if a sentence follows 'sentence case'. A few examples below.\n+    Hello world! -> YES\n+    I'm a good guy. -> YES\n+    a man and a gun. -> NO\n+    A WMS layer -> YES, as it's allowed to include proper nouns\n+    :param string: Input sentence, typically the title string.\n+    :return: None. Throws if is not sentence case.\n+    \"\"\"\n+    # Check empty string.\n+    if not string:\n+        raise Exception('Empty title string.')\n+    # The whole sentence get excepted.\n+    if string in exception_proper_nouns:\n+        return\n+    # Split sentence into words.\n+    words = string.split()\n+    # First word should either be Title-cased or a proper noun (UPPERCASE).\n+    if words[0][0].upper() != words[0][0] and words[0].upper() != words[0] \\\n+            and words[0] not in exception_proper_nouns:\n+        raise Exception('Wrong letter case for the first word in title.')\n+    # If a word is neither lowercase nor UPPERCASE then it is not great.\n+    for word in words[1:]:\n+        word = word.strip('()')\n+        if word.lower() != word and word.upper() != word \\\n+                and word not in exception_proper_nouns:\n+            raise Exception(f'Wrong letter case for word: \"{word}\" in title.')\n+\n+\n+def check_is_subsequence(list_a: typing.List[str],\n+                         list_b: typing.List[str]) -> int:\n+    \"\"\"\n+    Check if list A is a subsequence of list B.\n+    E.g.\n+    list_a = ['a', 'b', 'c']\n+    list_b = ['a', 'h', 'b', 'g', 'd', 'c']\n+    -> returns 0, which means all elements in list_a is also in list_b\n+    :param list_a: A list of strings, presumably the section titles of a README.\n+    :param list_b: A list of strings, presumably all valid titles in order.\n+    :return: 0 if list_a is subsequence of list_b.\n+    \"\"\"\n+    # Empty list is always a subsequence of other lists.\n+    if not list_a:\n+        return True\n+    pa = len(list_a)\n+    for pb in range(len(list_b), 0, -1):\n+        pa -= 1 if list_b[pb-1] == list_a[pa-1] else 0\n+    return pa\n+# endregion\n+\n+\n+class ReadmeStyleChecker:\n+\n+    essential_headers = {\n+        'Use case',\n+        'How to use the sample',\n+        'How it works',\n+        'Relevant API',\n+        'Tags'\n+    }\n+\n+    possible_headers = [", "originalCommit": "bd8a8ec075861d420d8499fcef942a001c4a8c8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzk3MTMwOA==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r567971308", "bodyText": "Will add this as a refactor opportunity to the open issue, as it stands the lists are both being used and compared so will leave for now \ud83d\udc4d", "author": "jenmerritt", "createdAt": "2021-02-01T16:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1NDI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0NzY1Mg==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r534147652", "bodyText": "Will we need to eventually change this when master changes to main?", "author": "sclaridge", "createdAt": "2020-12-02T12:59:37Z", "path": ".github/workflows/main.yml", "diffHunk": "@@ -0,0 +1,62 @@\n+# The name of the job, which will be displayed for the status check in PR.\n+name: README and metadata formatting\n+\n+# Controls when the action will run.\n+# Below triggers the workflow on pull requests to the specified branches.\n+on:\n+  pull_request:\n+    branches:\n+      - master", "originalCommit": "bd8a8ec075861d420d8499fcef942a001c4a8c8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzk2ODI4Ng==", "url": "https://github.com/Esri/arcgis-runtime-samples-java/pull/586#discussion_r567968286", "bodyText": "Yeah correct - it would just be a case of making that manual update. All that would happen if the branch was renamed and we didn't add it, is the scripts just would not run on that branch, so that should help us remember / it wouldn't cause any direct issues.", "author": "jenmerritt", "createdAt": "2021-02-01T16:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0NzY1Mg=="}], "type": "inlineReview"}, {"oid": "d9fe2df201fdfa7533a9c49403a45fab882bd4de", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/d9fe2df201fdfa7533a9c49403a45fab882bd4de", "message": "update language used", "committedDate": "2021-02-01T16:39:57Z", "type": "commit"}, {"oid": "dac9a1beb660aaed55d96c583fd47c18e56cce7b", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/dac9a1beb660aaed55d96c583fd47c18e56cce7b", "message": "move files into .github folder", "committedDate": "2021-02-01T17:14:09Z", "type": "commit"}, {"oid": "b4f8e6aa1644c6ea7844cb4518b53ed7f0459fb8", "url": "https://github.com/Esri/arcgis-runtime-samples-java/commit/b4f8e6aa1644c6ea7844cb4518b53ed7f0459fb8", "message": "update contact details", "committedDate": "2021-02-08T16:21:58Z", "type": "commit"}]}