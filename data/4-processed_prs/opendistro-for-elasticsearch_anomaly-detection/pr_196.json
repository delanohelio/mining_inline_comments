{"pr_number": 196, "pr_title": "AD CLI", "pr_createdAt": "2020-07-27T20:35:03Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196", "timeline": [{"oid": "0487a45ff8e0ddf3a10c71f16d7e2681d8fdc36d", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0487a45ff8e0ddf3a10c71f16d7e2681d8fdc36d", "message": "Merge ESAD CLI into anomaly-detection\n\nMerged esad from private repo to anomaly detection plugin.", "committedDate": "2020-07-27T20:36:32Z", "type": "commit"}, {"oid": "0487a45ff8e0ddf3a10c71f16d7e2681d8fdc36d", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0487a45ff8e0ddf3a10c71f16d7e2681d8fdc36d", "message": "Merge ESAD CLI into anomaly-detection\n\nMerged esad from private repo to anomaly detection plugin.", "committedDate": "2020-07-27T20:36:32Z", "type": "forcePushed"}, {"oid": "2e49d94a3242f2da3b6d469e3ebef04215164a05", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/2e49d94a3242f2da3b6d469e3ebef04215164a05", "message": "Include gitignore file", "committedDate": "2020-07-28T22:15:50Z", "type": "commit"}, {"oid": "8e314549b060963e7846cfc333273d40c93273e2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/8e314549b060963e7846cfc333273d40c93273e2", "message": "Add workflow\n\nAdded build and publish artifacts", "committedDate": "2020-07-28T22:55:44Z", "type": "commit"}, {"oid": "8e314549b060963e7846cfc333273d40c93273e2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/8e314549b060963e7846cfc333273d40c93273e2", "message": "Add workflow\n\nAdded build and publish artifacts", "committedDate": "2020-07-28T22:55:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NjcxNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461966714", "bodyText": "minor. is this expected?", "author": "wnbts", "createdAt": "2020-07-29T00:20:11Z", "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,97 @@\n+![Test Workflow](https://github.com/VijayanB/esad/workflows/Build%20and%20Test%20Anomaly%20detection%20commandline%20tool/badge.svg)", "originalCommit": "8e314549b060963e7846cfc333273d40c93273e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3NzY4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462477682", "bodyText": "Thanks for pointing it. I removed it for now.", "author": "VijayanB", "createdAt": "2020-07-29T17:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NjcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NjkyOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461966928", "bodyText": "minor. his should be This", "author": "wnbts", "createdAt": "2020-07-29T00:20:49Z", "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,97 @@\n+![Test Workflow](https://github.com/VijayanB/esad/workflows/Build%20and%20Test%20Anomaly%20detection%20commandline%20tool/badge.svg)\n+\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+his CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. ", "originalCommit": "8e314549b060963e7846cfc333273d40c93273e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3Nzk5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462477991", "bodyText": "Thanks for pointing it. I updated it.", "author": "VijayanB", "createdAt": "2020-07-29T17:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NjkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NzczOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461967738", "bodyText": "minor. AN should be An", "author": "wnbts", "createdAt": "2020-07-29T00:23:49Z", "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,97 @@\n+![Test Workflow](https://github.com/VijayanB/esad/workflows/Build%20and%20Test%20Anomaly%20detection%20commandline%20tool/badge.svg)\n+\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+his CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/\n+    ```\n+\n+## Configure\n+\n+Before using the AWS CLI, you need to configure your AWS credentials. You can do this in several ways:\n+\n+* Configuration command\n+* Config file\n+\n+The quickest way to get started is to run the `esad profile create`\n+\n+```\n+$ esad profile create\n+Enter profile's name: dev\n+ES Anomaly Detection Endpoint: https://localhost:9200\n+ES Anomaly Detection User: admin\n+ES Anomaly Detection Password:\n+```\n+\n+To use a config file, create a YAML file like this\n+```\n+profiles:\n+- endpoint: https://localhost:9200\n+  username: admin\n+  password: foobar\n+  name: default\n+- endpoint: https://odfe-node1:9200\n+  username: admin\n+  password: foobar\n+  name: dev\n+```\n+and place it on ~/.esad/config.yaml. if you wish to place the shared credentials file in a different location than the one specified above, you need to tell aws-cli where to find it. Do this by setting the appropriate environment variable:\n+\n+```\n+export ESAD_CONFIG_FILE=/path/to/config_file\n+```\n+You can have multiple profiles defined in the configuration file. You can then specify which profile to use by using the --profile option. If no profile is specified the `default` profile is used.\n+\n+\n+\n+## Basic Commands\n+\n+AN ESAD CLI has following structure", "originalCommit": "8e314549b060963e7846cfc333273d40c93273e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3ODMxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462478311", "bodyText": "Thanks for pointing it. I updated it in next commit.", "author": "VijayanB", "createdAt": "2020-07-29T17:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NzczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3MjEwNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461972107", "bodyText": "suggestion. for readability, refrain from using single letters for variable names.", "author": "wnbts", "createdAt": "2020-07-29T00:40:06Z", "path": "cli/cmd/create.go", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\thandler \"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCreate = \"create\"\n+\tinteractive   = \"interactive\"\n+\tgenerate      = \"generate-skeleton\"\n+)\n+\n+// createCmd represents the create command\n+var createCmd = &cobra.Command{\n+\tUse:   commandCreate + \" [list of file-path] [flags]\",\n+\tShort: \"Creates detectors based on configurations\",\n+\tLong:  `Creates detectors based on configurations specified by file path`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tstatus, _ := cmd.Flags().GetBool(interactive)\n+\t\tgenerate, _ := cmd.Flags().GetBool(generate)\n+\t\tif generate {\n+\t\t\terr := generateFile()\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Println(commandCreate, \"command failed\")\n+\t\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\terr := createDetectors(args, status)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(commandCreate, \"command failed\")\n+\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t}\n+\t},\n+}\n+\n+func generateFile() error {\n+\tdetector, _ := handler.GenerateAnomalyDetector()\n+\tfmt.Println(string(detector))\n+\treturn nil\n+}\n+\n+func init() {\n+\tesadCmd.AddCommand(createCmd)\n+\tcreateCmd.Flags().BoolP(interactive, \"i\", false, \"Create Detectors in an interactive way\")\n+\tcreateCmd.Flags().BoolP(generate, \"g\", false, \"Outputs Detector's configuration\")\n+\n+}\n+\n+func createDetectors(fileNames []string, status bool) error {\n+\th, err := getCommandHandler()", "originalCommit": "8e314549b060963e7846cfc333273d40c93273e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3OTczNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462479735", "bodyText": "i updated it. Nevertheless, accordingly to go style, (https://github.com/golang/go/wiki/CodeReviewComments#variable-names) it is preferred to use short variable name if it is not used below a page down .", "author": "VijayanB", "createdAt": "2020-07-29T17:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3MjEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3MzUxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461973515", "bodyText": "minor. unused code can be deleted in multiple places.", "author": "wnbts", "createdAt": "2020-07-29T00:45:27Z", "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+)\n+\n+// profilesCmd represents the profiles command\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+\t//Run: func(cmd *cobra.Command, args []string) {", "originalCommit": "8e314549b060963e7846cfc333273d40c93273e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MDYyMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462480623", "bodyText": "I deleted the commented code. Thanks for pointing out.", "author": "VijayanB", "createdAt": "2020-07-29T17:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3MzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3NTM1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461975356", "bodyText": "minor. the name should be existingprofilename as existing name is not valid for creation.", "author": "wnbts", "createdAt": "2020-07-29T00:52:22Z", "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+)\n+\n+// profilesCmd represents the profiles command\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+\t//Run: func(cmd *cobra.Command, args []string) {\n+\t//\tv, _ := cmd.Flags().GetBool(\"nameonly\")\n+\t//\tdisplayProfiles(!v)\n+\t//},\n+}\n+\n+// createProfilesCmd represents add profiles command\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+// deleteProfileCmd represents deleting profiles\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+// listProfilesCmd represents lists profiles\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+// profilesCmd represents the profiles command\n+//var updateProfileCmd = &cobra.Command{\n+//\tUse:   \"edit\",\n+//\tShort: \"edit profile\",\n+//\tLong: `A longer description that spans multiple lines and likely contains examples\n+//and usage of using your command. For example:\n+//\n+//Cobra is a CLI library for Go that empowers applications.\n+//This application is a tool to generate the needed files\n+//to quickly create a Cobra application.`,\n+//\tRun: func(cmd *cobra.Command, args []string) {\n+//\t\tupdateProfiles(args[0])\n+//\t},\n+//}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\t//profilesCmd.AddCommand(updateProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = userInput(\"profile's name\", false, false)\n+\t\tif !validProfileName(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := userInput(\"endpoint\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := userInput(\"user\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := userInput(\"password\", true, false)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func validProfileName(name string) bool {", "originalCommit": "8e314549b060963e7846cfc333273d40c93273e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MTM0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462481343", "bodyText": "i updated to isProfileExists since it returns bool. But i renamed variable names like you suggested in other place. Can you review it?", "author": "VijayanB", "createdAt": "2020-07-29T17:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3NTM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3ODcwNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461978706", "bodyText": "minor. retrieving profiles is repeated and can use refactoring.", "author": "wnbts", "createdAt": "2020-07-29T01:05:31Z", "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+)\n+\n+// profilesCmd represents the profiles command\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+\t//Run: func(cmd *cobra.Command, args []string) {\n+\t//\tv, _ := cmd.Flags().GetBool(\"nameonly\")\n+\t//\tdisplayProfiles(!v)\n+\t//},\n+}\n+\n+// createProfilesCmd represents add profiles command\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+// deleteProfileCmd represents deleting profiles\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+// listProfilesCmd represents lists profiles\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+// profilesCmd represents the profiles command\n+//var updateProfileCmd = &cobra.Command{\n+//\tUse:   \"edit\",\n+//\tShort: \"edit profile\",\n+//\tLong: `A longer description that spans multiple lines and likely contains examples\n+//and usage of using your command. For example:\n+//\n+//Cobra is a CLI library for Go that empowers applications.\n+//This application is a tool to generate the needed files\n+//to quickly create a Cobra application.`,\n+//\tRun: func(cmd *cobra.Command, args []string) {\n+//\t\tupdateProfiles(args[0])\n+//\t},\n+//}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\t//profilesCmd.AddCommand(updateProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = userInput(\"profile's name\", false, false)\n+\t\tif !validProfileName(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := userInput(\"endpoint\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := userInput(\"user\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := userInput(\"password\", true, false)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func validProfileName(name string) bool {\n+\tprofiles := getProfiles()\n+\tfor _, profile := range profiles {\n+\t\tif profile.Name == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func getText() string {\n+\tvar response string\n+\t_, err := fmt.Scanln(&response)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\treturn strings.TrimSpace(response)\n+}\n+\n+func getMaskedText() string {\n+\tmaskedValue, err := terminal.ReadPassword(0)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println()\n+\treturn fmt.Sprintf(\"%s\", maskedValue)\n+}\n+\n+func userInput(name string, mask bool, allowBlank bool) string {\n+\n+\tvar response string\n+\tif mask {\n+\t\tresponse = getMaskedText()\n+\t} else {\n+\t\tresponse = getText()\n+\t}\n+\tif !allowBlank && len(response) < 1 {\n+\t\tfmt.Printf(\"value cannot be empty. Please enter non-empty value for %s: \", name)\n+\t\treturn userInput(name, mask, allowBlank)\n+\t}\n+\treturn response\n+}\n+\n+func deleteProfiles(names []string) {\n+\n+\tvar validProfiles []string\n+\tfor _, name := range names {\n+\t\tif !validProfileName(name) {\n+\t\t\tfmt.Println(\"profile\", name, \"doesn't exists.\")\n+\t\t\tcontinue\n+\t\t}\n+\t\tvalidProfiles = append(validProfiles, name)\n+\t}\n+\n+\tvar safeProfiles []entity.Profile\n+\tprofiles := getProfiles()", "originalCommit": "8e314549b060963e7846cfc333273d40c93273e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NTE5NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462575194", "bodyText": "logic to get profiles (load file, deserialization ) is a single method, just that it is being used in multiple use cases. In this particular case, i had split logic to delete actual profile and verify whether the profile is valid or not . This will make logic easy to maintain than having both use cases entangled.", "author": "VijayanB", "createdAt": "2020-07-29T20:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3ODcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3OTE1OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461979158", "bodyText": "question. does go have libraries for data structures other than array?", "author": "wnbts", "createdAt": "2020-07-29T01:07:19Z", "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+)\n+\n+// profilesCmd represents the profiles command\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+\t//Run: func(cmd *cobra.Command, args []string) {\n+\t//\tv, _ := cmd.Flags().GetBool(\"nameonly\")\n+\t//\tdisplayProfiles(!v)\n+\t//},\n+}\n+\n+// createProfilesCmd represents add profiles command\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+// deleteProfileCmd represents deleting profiles\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+// listProfilesCmd represents lists profiles\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+// profilesCmd represents the profiles command\n+//var updateProfileCmd = &cobra.Command{\n+//\tUse:   \"edit\",\n+//\tShort: \"edit profile\",\n+//\tLong: `A longer description that spans multiple lines and likely contains examples\n+//and usage of using your command. For example:\n+//\n+//Cobra is a CLI library for Go that empowers applications.\n+//This application is a tool to generate the needed files\n+//to quickly create a Cobra application.`,\n+//\tRun: func(cmd *cobra.Command, args []string) {\n+//\t\tupdateProfiles(args[0])\n+//\t},\n+//}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\t//profilesCmd.AddCommand(updateProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = userInput(\"profile's name\", false, false)\n+\t\tif !validProfileName(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := userInput(\"endpoint\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := userInput(\"user\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := userInput(\"password\", true, false)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func validProfileName(name string) bool {\n+\tprofiles := getProfiles()\n+\tfor _, profile := range profiles {\n+\t\tif profile.Name == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func getText() string {\n+\tvar response string\n+\t_, err := fmt.Scanln(&response)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\treturn strings.TrimSpace(response)\n+}\n+\n+func getMaskedText() string {\n+\tmaskedValue, err := terminal.ReadPassword(0)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println()\n+\treturn fmt.Sprintf(\"%s\", maskedValue)\n+}\n+\n+func userInput(name string, mask bool, allowBlank bool) string {\n+\n+\tvar response string\n+\tif mask {\n+\t\tresponse = getMaskedText()\n+\t} else {\n+\t\tresponse = getText()\n+\t}\n+\tif !allowBlank && len(response) < 1 {\n+\t\tfmt.Printf(\"value cannot be empty. Please enter non-empty value for %s: \", name)\n+\t\treturn userInput(name, mask, allowBlank)\n+\t}\n+\treturn response\n+}\n+\n+func deleteProfiles(names []string) {\n+\n+\tvar validProfiles []string\n+\tfor _, name := range names {\n+\t\tif !validProfileName(name) {\n+\t\t\tfmt.Println(\"profile\", name, \"doesn't exists.\")\n+\t\t\tcontinue\n+\t\t}\n+\t\tvalidProfiles = append(validProfiles, name)\n+\t}\n+\n+\tvar safeProfiles []entity.Profile\n+\tprofiles := getProfiles()\n+\tfor _, p := range profiles {\n+\t\tsafe := true\n+\t\tfor _, name := range validProfiles {", "originalCommit": "8e314549b060963e7846cfc333273d40c93273e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ5MDc2MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462490760", "bodyText": "unfortunately no. It has map and slice(array). Usually if there is need for processing lot of data, go recommends concurrent programming by spanning multiple threads. My guess is since go is not meant for data processing and keep language simple and opinionated, it doesn't have data structures like java.", "author": "VijayanB", "createdAt": "2020-07-29T18:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3OTE1OA=="}], "type": "inlineReview"}, {"oid": "34dea763b42fce6a1d6a4f331990dc80271450c3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/34dea763b42fce6a1d6a4f331990dc80271450c3", "message": "test 1", "committedDate": "2020-07-29T01:32:24Z", "type": "commit"}, {"oid": "12659cebb8e1e3344e8c8126f2937c342dd54c4d", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/12659cebb8e1e3344e8c8126f2937c342dd54c4d", "message": "fixed workflow paths to cli directory", "committedDate": "2020-07-29T01:49:55Z", "type": "commit"}, {"oid": "a0f363df560c5276f9d0c41ebd778c11492b092e", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/a0f363df560c5276f9d0c41ebd778c11492b092e", "message": "Refactored profiles\n\nFixed Code review comments", "committedDate": "2020-07-29T17:43:52Z", "type": "commit"}, {"oid": "fb9dfc61c6749f253cbc807f385e10dab3f7bd2c", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/fb9dfc61c6749f253cbc807f385e10dab3f7bd2c", "message": "Update workflow name\n\nUpdate publish only tags are created.", "committedDate": "2020-07-29T18:35:49Z", "type": "commit"}, {"oid": "f1ccf8c740ade6e50861fc854c828d087259e619", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/f1ccf8c740ade6e50861fc854c828d087259e619", "message": "Temporarily allow publish artifact on push/pull", "committedDate": "2020-07-29T20:23:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4ODA2OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462688068", "bodyText": "question. is it also a go convention to not have a separate directory/module for test code & data?", "author": "wnbts", "createdAt": "2020-07-30T01:53:42Z", "path": "cli/internal/controller/ad/ad_test.go", "diffHunk": "@@ -0,0 +1,726 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\tesmockctrl \"esad/internal/controller/es/mocks\"\n+\tentity \"esad/internal/entity/ad\"\n+\tadgateway \"esad/internal/gateway/ad/mocks\"\n+\tmapper2 \"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"github.com/golang/mock/gomock\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+const mockDetectorID = \"m4ccEnIBTXsGi3mvMt9p\"\n+const mockDetectorName = \"detector\"\n+\n+func helperLoadBytes(t *testing.T, name string) []byte {\n+\tpath := filepath.Join(\"testdata\", name) // relative path", "originalCommit": "f1ccf8c740ade6e50861fc854c828d087259e619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY5ODU2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462698567", "bodyText": "you mean test file and implementation? Yes, go uses package oriented design, hence code/test/testdata should always be close to each other. There is no guideline but i observed this being used in many of application tool\nlike gofmt / https://golang.org/src/cmd/gofmt/", "author": "VijayanB", "createdAt": "2020-07-30T02:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4ODA2OA=="}], "type": "inlineReview"}, {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9332f7d16104de9d6b7a59378986550b0da5af55", "message": "Upload code coverage", "committedDate": "2020-07-30T02:21:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzNTMzMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463335333", "bodyText": "minor. MacOS and Linux and Windows", "author": "wnbts", "createdAt": "2020-07-31T00:01:00Z", "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.", "originalCommit": "9332f7d16104de9d6b7a59378986550b0da5af55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMTcyNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463831726", "bodyText": "Ack.\n\nsuggestion. making pr smaller helps reviewers.\n\nDefinitely, i started as proof of concept and later i added features. I will definitely create small commits and multiple PR to make sure that code is easy to review .", "author": "VijayanB", "createdAt": "2020-07-31T20:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzNTMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMjA5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464732091", "bodyText": "Forgot to add \"Windows\"  or this CLI can't support windows?", "author": "ylwu-amzn", "createdAt": "2020-08-04T00:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzNTMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NDg3Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463344876", "bodyText": "question. why execute is not needed here but needed in start?", "author": "wnbts", "createdAt": "2020-07-31T00:36:38Z", "path": "cli/cmd/stop.go", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const commandStop = \"stop\"\n+\n+var stopCmd = &cobra.Command{\n+\tUse:   commandStop + \" [flags] [list of detectors]\",\n+\tShort: \"Stop detectors\",\n+\tLong:  `Stops detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\taction := ad.StopAnomalyDetector\n+\t\tif idStatus {\n+\t\t\taction = ad.StopAnomalyDetectorByID\n+\t\t}\n+\t\terr := execute(action, args)", "originalCommit": "9332f7d16104de9d6b7a59378986550b0da5af55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMTg2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463831865", "bodyText": "Go's package scope allows us to refer to the method outside file as long as it is inside same package. I created one file per command but start and stop shares lot. Now i merged both the command in single file to keep code together.", "author": "VijayanB", "createdAt": "2020-07-31T20:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NDg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NzM1Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463347352", "bodyText": "minor. should increment be done after an operation is finished?", "author": "wnbts", "createdAt": "2020-07-31T00:46:31Z", "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/gosuri/uiprogress\"\n+\t\"io\"\n+\t\"log\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()", "originalCommit": "9332f7d16104de9d6b7a59378986550b0da5af55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMTg5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463831899", "bodyText": "Yeah. I updated it. Thanks for pointing it.", "author": "VijayanB", "createdAt": "2020-07-31T20:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NzM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MDU1MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463350550", "bodyText": "issue. the error looks like not ignored.", "author": "wnbts", "createdAt": "2020-07-31T00:57:28Z", "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/gosuri/uiprogress\"\n+\t\"io\"\n+\t\"log\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"stop\", c.StopDetector, display)\n+}\n+\n+//DeleteDetector deletes detector\n+func (c controller) DeleteDetector(ctx context.Context, id string, interactive bool, force bool) error {\n+\tif len(id) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id cannot be empty\")\n+\t}\n+\tproceed := true\n+\tif interactive {\n+\t\tproceed = c.askForConfirmation(\n+\t\t\tcmapper.StringToStringPtr(\n+\t\t\t\tfmt.Sprintf(\n+\t\t\t\t\t\"esad will delete detector: %s . Do you want to proceed? please type (y)es or (n)o and then press enter:\",\n+\t\t\t\t\tid,\n+\t\t\t\t),\n+\t\t\t),\n+\t\t)\n+\t}\n+\tif !proceed {\n+\t\treturn nil\n+\t}\n+\tif force {\n+\t\tres, err := c.gateway.StopDetector(ctx, id) // ignore error\n+\t\tif err != nil {\n+\t\t\treturn err", "originalCommit": "9332f7d16104de9d6b7a59378986550b0da5af55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMTkyOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463831928", "bodyText": "Removed the comment. Initially i was ignoring but later decided to respect and return the same", "author": "VijayanB", "createdAt": "2020-07-31T20:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MDU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTkwMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463351900", "bodyText": "issue. is it safe to continue with a fatal error?", "author": "wnbts", "createdAt": "2020-07-31T01:02:50Z", "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/gosuri/uiprogress\"\n+\t\"io\"\n+\t\"log\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"stop\", c.StopDetector, display)\n+}\n+\n+//DeleteDetector deletes detector\n+func (c controller) DeleteDetector(ctx context.Context, id string, interactive bool, force bool) error {\n+\tif len(id) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id cannot be empty\")\n+\t}\n+\tproceed := true\n+\tif interactive {\n+\t\tproceed = c.askForConfirmation(\n+\t\t\tcmapper.StringToStringPtr(\n+\t\t\t\tfmt.Sprintf(\n+\t\t\t\t\t\"esad will delete detector: %s . Do you want to proceed? please type (y)es or (n)o and then press enter:\",\n+\t\t\t\t\tid,\n+\t\t\t\t),\n+\t\t\t),\n+\t\t)\n+\t}\n+\tif !proceed {\n+\t\treturn nil\n+\t}\n+\tif force {\n+\t\tres, err := c.gateway.StopDetector(ctx, id) // ignore error\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif interactive {\n+\t\t\tfmt.Println(*res)\n+\t\t}\n+\n+\t}\n+\terr := c.gateway.DeleteDetector(ctx, id)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) askForConfirmation(message *string) bool {\n+\n+\tif message == nil {\n+\t\treturn true\n+\t}\n+\tif len(*message) > 0 {\n+\t\tfmt.Print(*message)\n+\t}\n+\n+\tvar response string\n+\t_, err := fmt.Fscanln(c.reader, &response)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}", "originalCommit": "9332f7d16104de9d6b7a59378986550b0da5af55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMTk2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463831966", "bodyText": "You are right. It is not. I updated it.", "author": "VijayanB", "createdAt": "2020-07-31T20:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NDA4MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463354081", "bodyText": "minor. this name should be undeleted.", "author": "wnbts", "createdAt": "2020-07-31T01:11:36Z", "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/gosuri/uiprogress\"\n+\t\"io\"\n+\t\"log\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"stop\", c.StopDetector, display)\n+}\n+\n+//DeleteDetector deletes detector\n+func (c controller) DeleteDetector(ctx context.Context, id string, interactive bool, force bool) error {\n+\tif len(id) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id cannot be empty\")\n+\t}\n+\tproceed := true\n+\tif interactive {\n+\t\tproceed = c.askForConfirmation(\n+\t\t\tcmapper.StringToStringPtr(\n+\t\t\t\tfmt.Sprintf(\n+\t\t\t\t\t\"esad will delete detector: %s . Do you want to proceed? please type (y)es or (n)o and then press enter:\",\n+\t\t\t\t\tid,\n+\t\t\t\t),\n+\t\t\t),\n+\t\t)\n+\t}\n+\tif !proceed {\n+\t\treturn nil\n+\t}\n+\tif force {\n+\t\tres, err := c.gateway.StopDetector(ctx, id) // ignore error\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif interactive {\n+\t\t\tfmt.Println(*res)\n+\t\t}\n+\n+\t}\n+\terr := c.gateway.DeleteDetector(ctx, id)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) askForConfirmation(message *string) bool {\n+\n+\tif message == nil {\n+\t\treturn true\n+\t}\n+\tif len(*message) > 0 {\n+\t\tfmt.Print(*message)\n+\t}\n+\n+\tvar response string\n+\t_, err := fmt.Fscanln(c.reader, &response)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tswitch strings.ToLower(response) {\n+\tcase \"y\", \"yes\":\n+\t\treturn true\n+\tcase \"n\", \"no\":\n+\t\treturn false\n+\tdefault:\n+\t\tfmt.Printf(\"I'm sorry but I didn't get what you meant, please type (y)es or (n)o and then press enter:\")\n+\t\treturn c.askForConfirmation(cmapper.StringToStringPtr(\"\"))\n+\t}\n+}\n+\n+//CreateMultiEntityAnomalyDetector creates multiple detector per entity\n+func (c controller) CreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error) {\n+\tif request.PartitionField == nil || len(*request.PartitionField) < 1 {\n+\t\tresult, err := c.CreateAnomalyDetector(ctx, request)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn []string{*result}, err\n+\t}\n+\tfilterValues, err := getFilterValues(ctx, request, c)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(filterValues) < 1 {\n+\t\treturn nil, fmt.Errorf(\n+\t\t\t\"failed to get values for partition field: %s, check whether any data is available in index %s\",\n+\t\t\t*request.PartitionField,\n+\t\t\trequest.Index,\n+\t\t)\n+\t}\n+\tproceed := true\n+\tif interactive {\n+\t\tproceed = c.askForConfirmation(\n+\t\t\tcmapper.StringToStringPtr(\n+\t\t\t\tfmt.Sprintf(\n+\t\t\t\t\t\"esad will create %d detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\",\n+\t\t\t\t\tlen(filterValues),\n+\t\t\t\t),\n+\t\t\t),\n+\t\t)\n+\t}\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(filterValues))\n+\t}\n+\tvar detectors []string\n+\tname := request.Name\n+\tfilter := request.Filter\n+\tvar createdDetectors []entity.Detector\n+\tfor _, value := range filterValues {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\trequest.Filter = buildCompoundQuery(*request.PartitionField, value, filter)\n+\t\trequest.Name = fmt.Sprintf(\"%s-%s\", name, value)\n+\t\tresult, err := c.CreateAnomalyDetector(ctx, request)\n+\t\tif err != nil {\n+\t\t\tc.cleanupCreatedDetectors(ctx, createdDetectors)\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tcreatedDetectors = append(createdDetectors, entity.Detector{\n+\t\t\tID:   *result,\n+\t\t\tName: request.Name,\n+\t\t})\n+\t\tdetectors = append(detectors, request.Name)\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func createProgressBar(total int) *uiprogress.Bar {\n+\tif total < 2 {\n+\t\treturn nil\n+\t}\n+\tuiprogress.Start()\n+\tbar := uiprogress.AddBar(total).PrependCompleted()\n+\tbar.Width = 50\n+\tbar.AppendFunc(func(b *uiprogress.Bar) string {\n+\t\treturn fmt.Sprintf(\"(%d / %d)\", b.Current(), total)\n+\t})\n+\treturn bar\n+}\n+\n+func buildCompoundQuery(field string, value interface{}, userFilter json.RawMessage) json.RawMessage {\n+\n+\tleaf1 := []byte(fmt.Sprintf(`{\n+    \t\t\t\"bool\": {\n+      \t\t\t\t\"filter\": {\n+          \t\t\t\t\"term\": {\n+\t\t\t\t\t\t\t\"%s\" : \"%v\"\n+         \t\t\t \t}\n+        \t\t\t}\n+\t\t\t\t}\n+  \t\t\t}`, field, value))\n+\tif userFilter == nil {\n+\t\treturn leaf1\n+\t}\n+\tmarshal, _ := json.Marshal(entity.Query{\n+\t\tBool: entity.Bool{\n+\t\t\tMust: []json.RawMessage{\n+\t\t\t\tleaf1, userFilter,\n+\t\t\t},\n+\t\t},\n+\t})\n+\treturn marshal\n+}\n+\n+func getFilterValues(ctx context.Context, request entity.CreateDetectorRequest, c controller) ([]interface{}, error) {\n+\tvar filterValues []interface{}\n+\tfor _, index := range request.Index {\n+\t\tv, err := c.esCtrl.GetDistinctValues(ctx, index, *request.PartitionField)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tfilterValues = append(filterValues, v...)\n+\t}\n+\treturn filterValues, nil\n+}\n+\n+func (c controller) StopDetector(ctx context.Context, ID string) error {\n+\tif len(ID) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id: %s cannot be empty\", ID)\n+\t}\n+\t_, err := c.gateway.StopDetector(ctx, ID)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StartDetector(ctx context.Context, ID string) error {\n+\tif len(ID) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id: %s cannot be empty\", ID)\n+\t}\n+\terr := c.gateway.StartDetector(ctx, ID)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) CreateAnomalyDetector(ctx context.Context, r entity.CreateDetectorRequest) (*string, error) {\n+\n+\tif err := validateCreateRequest(r); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tpayload, err := mapper.MapToCreateDetector(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse, err := c.gateway.CreateDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, processEntityError(err)\n+\t}\n+\tvar data map[string]interface{}\n+\t_ = json.Unmarshal(response, &data)\n+\n+\tdetectorID := fmt.Sprintf(\"%s\", data[\"_id\"])\n+\tif !r.Start {\n+\t\treturn cmapper.StringToStringPtr(detectorID), nil\n+\t}\n+\n+\terr = c.StartDetector(ctx, detectorID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"detector is created with id: %s, but failed to start due to %v\", detectorID, err)\n+\t}\n+\treturn cmapper.StringToStringPtr(detectorID), nil\n+}\n+\n+func processEntityError(err error) error {\n+\tvar c entity.CreateError\n+\tdata := fmt.Sprintf(\"%v\", err)\n+\tresponseErr := json.Unmarshal([]byte(data), &c)\n+\tif responseErr != nil {\n+\t\treturn err\n+\t}\n+\tif len(c.Error.Reason) > 0 {\n+\t\treturn errors.New(c.Error.Reason)\n+\t}\n+\treturn err\n+}\n+\n+func (c controller) cleanupCreatedDetectors(ctx context.Context, detectors []entity.Detector) {\n+\n+\tif len(detectors) < 1 {\n+\t\treturn\n+\t}\n+\tvar deleted []entity.Detector", "originalCommit": "9332f7d16104de9d6b7a59378986550b0da5af55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMTk5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463831999", "bodyText": "You are right. I fixed it now.", "author": "VijayanB", "createdAt": "2020-07-31T20:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NDA4MQ=="}], "type": "inlineReview"}, {"oid": "98ca1f1f18aba01b288a3b554be3d634a327c501", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/98ca1f1f18aba01b288a3b554be3d634a327c501", "message": "Fixed code review comments", "committedDate": "2020-07-31T20:47:21Z", "type": "commit"}, {"oid": "a00bc59dc4d1f4ba1b5e6d0a83c165ecad4e6dc6", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/a00bc59dc4d1f4ba1b5e6d0a83c165ecad4e6dc6", "message": "Don't print error on root command", "committedDate": "2020-08-03T18:24:15Z", "type": "commit"}, {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/924511ec3e08835237986e7550c3e0d23d0e135e", "message": "fix lint issue", "committedDate": "2020-08-03T18:42:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMjQ4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464732486", "bodyText": "What will happen if I use same name for two profiles. Will throw error or override the prior one?", "author": "ylwu-amzn", "createdAt": "2020-08-04T00:33:34Z", "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/\n+    ```\n+\n+## Configure\n+\n+Before using the AWS CLI, you need to configure your AWS credentials. You can do this in several ways:\n+\n+* Configuration command\n+* Config file\n+\n+The quickest way to get started is to run the `esad profile create`\n+\n+```\n+$ esad profile create\n+Enter profile's name: dev\n+ES Anomaly Detection Endpoint: https://localhost:9200\n+ES Anomaly Detection User: admin\n+ES Anomaly Detection Password:\n+```\n+\n+To use a config file, create a YAML file like this\n+```\n+profiles:\n+- endpoint: https://localhost:9200\n+  username: admin\n+  password: foobar\n+  name: default\n+- endpoint: https://odfe-node1:9200\n+  username: admin\n+  password: foobar\n+  name: dev", "originalCommit": "924511ec3e08835237986e7550c3e0d23d0e135e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNDMxOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464734318", "bodyText": "There is no validation if file is specified by user. We only have validation if user is creating a profile. Let's say if user has two profile with same name and this config is passed as parameter to the command, it will not override instead, it will select the first profile which matches the name.", "author": "VijayanB", "createdAt": "2020-08-04T00:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNTAxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464735011", "bodyText": "Sure, so we have error handling for this case. How about add this in readme doc and the help doc?", "author": "ylwu-amzn", "createdAt": "2020-08-04T00:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc5NTg4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464795889", "bodyText": "Added it in readme.", "author": "VijayanB", "createdAt": "2020-08-04T04:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMjQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMzY0MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464733640", "bodyText": "Seems the commands not follow same name convention. esad profile create  looks like esad <resource> <action>, but here esad start [detector-name-pattern] looks like esad <action> <resource>. Is it possible to follow same name convention? Maybe consult Carlos to confirm.", "author": "ylwu-amzn", "createdAt": "2020-08-04T00:37:56Z", "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/\n+    ```\n+\n+## Configure\n+\n+Before using the AWS CLI, you need to configure your AWS credentials. You can do this in several ways:\n+\n+* Configuration command\n+* Config file\n+\n+The quickest way to get started is to run the `esad profile create`\n+\n+```\n+$ esad profile create\n+Enter profile's name: dev\n+ES Anomaly Detection Endpoint: https://localhost:9200\n+ES Anomaly Detection User: admin\n+ES Anomaly Detection Password:\n+```\n+\n+To use a config file, create a YAML file like this\n+```\n+profiles:\n+- endpoint: https://localhost:9200\n+  username: admin\n+  password: foobar\n+  name: default\n+- endpoint: https://odfe-node1:9200\n+  username: admin\n+  password: foobar\n+  name: dev\n+```\n+and place it on ~/.esad/config.yaml. if you wish to place the shared credentials file in a different location than the one specified above, you need to tell aws-cli where to find it. Do this by setting the appropriate environment variable:\n+\n+```\n+export ESAD_CONFIG_FILE=/path/to/config_file\n+```\n+You can have multiple profiles defined in the configuration file. You can then specify which profile to use by using the --profile option. If no profile is specified the `default` profile is used.\n+\n+\n+\n+## Basic Commands\n+\n+An ESAD CLI has following structure\n+```\n+$ esad <command> <subcommand> [flags and parameters]\n+```\n+For example to start detector:\n+```\n+$ esad start [detector-name-pattern]", "originalCommit": "924511ec3e08835237986e7550c3e0d23d0e135e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNjE2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464736166", "bodyText": "Actually, esad, profile, create, start are commands. You can think like tree structure.\nesad -> profile -> create\n-> delete\n-> Create\n-> Start\nAnyway, i asked carlos to provide feedback. If i didn't receive anything related to that, i will bring this point.\nThanks for feedback.", "author": "VijayanB", "createdAt": "2020-08-04T00:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMzY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNDE1NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464734154", "bodyText": "How about adding version compatibility table in the help doc and read-me doc?", "author": "ylwu-amzn", "createdAt": "2020-08-04T00:39:50Z", "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/\n+    ```\n+\n+## Configure\n+\n+Before using the AWS CLI, you need to configure your AWS credentials. You can do this in several ways:\n+\n+* Configuration command\n+* Config file\n+\n+The quickest way to get started is to run the `esad profile create`\n+\n+```\n+$ esad profile create\n+Enter profile's name: dev\n+ES Anomaly Detection Endpoint: https://localhost:9200\n+ES Anomaly Detection User: admin\n+ES Anomaly Detection Password:\n+```\n+\n+To use a config file, create a YAML file like this\n+```\n+profiles:\n+- endpoint: https://localhost:9200\n+  username: admin\n+  password: foobar\n+  name: default\n+- endpoint: https://odfe-node1:9200\n+  username: admin\n+  password: foobar\n+  name: dev\n+```\n+and place it on ~/.esad/config.yaml. if you wish to place the shared credentials file in a different location than the one specified above, you need to tell aws-cli where to find it. Do this by setting the appropriate environment variable:\n+\n+```\n+export ESAD_CONFIG_FILE=/path/to/config_file\n+```\n+You can have multiple profiles defined in the configuration file. You can then specify which profile to use by using the --profile option. If no profile is specified the `default` profile is used.\n+\n+\n+\n+## Basic Commands\n+\n+An ESAD CLI has following structure\n+```\n+$ esad <command> <subcommand> [flags and parameters]\n+```\n+For example to start detector:\n+```\n+$ esad start [detector-name-pattern]\n+```\n+To view help documentation, use one of the following:\n+```\n+$ esad --help\n+$ esad <command> --help\n+$ esad <command> <subcommand> --help\n+```\n+To get the version of the ESAD CLI:\n+```\n+$ esad --version", "originalCommit": "924511ec3e08835237986e7550c3e0d23d0e135e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNDkxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464734911", "bodyText": "Sure. I will add it.", "author": "VijayanB", "createdAt": "2020-08-04T00:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNDE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc0MTg1MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464741850", "bodyText": "What if user set both generate and create?  How about add some comments here about difference of create/generate, so don't need to go to handler.GenerateAnomalyDetector to learn more what generate does ?", "author": "ylwu-amzn", "createdAt": "2020-08-04T01:10:43Z", "path": "cli/cmd/create.go", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\thandler \"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCreate = \"create\"\n+\tinteractive   = \"interactive\"\n+\tgenerate      = \"generate-skeleton\"\n+)\n+\n+var createCmd = &cobra.Command{\n+\tUse:   commandCreate + \" [list of file-path] [flags]\",\n+\tShort: \"Creates detectors based on configurations\",\n+\tLong:  `Creates detectors based on configurations specified by file path`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tstatus, _ := cmd.Flags().GetBool(interactive)\n+\t\tgenerate, _ := cmd.Flags().GetBool(generate)\n+\t\tif generate {\n+\t\t\terr := generateFile()\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Println(commandCreate, \"command failed\")\n+\t\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\terr := createDetectors(args, status)", "originalCommit": "924511ec3e08835237986e7550c3e0d23d0e135e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc3OTA5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464779099", "bodyText": "Thats a good point. I will add comments here.", "author": "VijayanB", "createdAt": "2020-08-04T03:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc0MTg1MA=="}], "type": "inlineReview"}, {"oid": "749fdfd91402bfa5569fc31dd680fe477ec39177", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/749fdfd91402bfa5569fc31dd680fe477ec39177", "message": "Update Readme\n\nFixed typo and added extra description about profile", "committedDate": "2020-08-04T03:16:05Z", "type": "commit"}, {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "message": "Display usage if no args is specified", "committedDate": "2020-08-04T03:29:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NTY5MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465185690", "bodyText": "This method is to get distinct value of one field. How about we rename this method as \"SearchDistinctValue\"? So I don't need to read the method implementation to learn this.", "author": "ylwu-amzn", "createdAt": "2020-08-04T16:42:15Z", "path": "cli/internal/gateway/es/es.go", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package es\n+\n+import (\n+\t\"context\"\n+\t\"esad/internal/client\"\n+\telasticsearch \"esad/internal/entity/es\"\n+\tgw \"esad/internal/gateway\"\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"net/url\"\n+)\n+\n+const search = \"_search\"\n+\n+//go:generate mockgen -destination=mocks/mock_es.go -package=mocks . Gateway\n+\n+//Gateway interface to call ES\n+type Gateway interface {\n+\tSearch(ctx context.Context, index string, field string) ([]byte, error)\n+}\n+\n+type gateway struct {\n+\tgw.HTTPGateway\n+}\n+\n+// NewESGateway returns new Gateway instance\n+func NewESGateway(c *client.Client, u *client.UserConfig) Gateway {\n+\treturn &gateway{\n+\t\t*gw.NewHTTPGateway(c, u),\n+\t}\n+}\n+func buildPayload(field string) *elasticsearch.SearchRequest {\n+\treturn &elasticsearch.SearchRequest{\n+\t\tSize: 0, // This will skip data in the response\n+\t\tAgg: elasticsearch.Aggregate{\n+\t\t\tGroup: elasticsearch.DistinctGroups{\n+\t\t\t\tTerm: elasticsearch.Terms{\n+\t\t\t\t\tField: field,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func (g *gateway) buildSearchURL(index string) (*url.URL, error) {\n+\tendpoint, err := gw.GetValidEndpoint(g.UserConfig)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tendpoint.Path = fmt.Sprintf(\"%s/%s\", index, search)\n+\treturn endpoint, nil\n+}\n+\n+func (g *gateway) Search(ctx context.Context, index string, field string) ([]byte, error) {", "originalCommit": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1ODA4NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465258084", "bodyText": "Ack", "author": "VijayanB", "createdAt": "2020-08-04T18:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NTY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5MzUyMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465193522", "bodyText": "What's the name convention for the file name? I see this ES controller named as \"controller.go\", but AD controller named as \"ad.go\". And I see five \"ad.go\" files in these folders: entity, mapper, gateway, handler, controller. Is it common practice in Go to use same file name and differentiate them with package path?", "author": "ylwu-amzn", "createdAt": "2020-08-04T16:55:12Z", "path": "cli/internal/controller/es/controller.go", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+", "originalCommit": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NzkwMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465257902", "bodyText": "I renamed to es.go. In Go, file name is not as vital as package name. I have seen in most of the popular go repositories, they use file name as same as package name. Yes, package is considered as module than file.", "author": "VijayanB", "createdAt": "2020-08-04T18:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5MzUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NzI2OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465197268", "bodyText": "Add comments for public methods ?", "author": "ylwu-amzn", "createdAt": "2020-08-04T17:01:16Z", "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/cheggaaa/pb/v3\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {", "originalCommit": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NjUyMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465256522", "bodyText": "ACk", "author": "VijayanB", "createdAt": "2020-08-04T18:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NzI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMDczOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465200738", "bodyText": "minor: how about move StartDetectorByName method before StopDetectorByName ? This can improve a little bit code readability.", "author": "ylwu-amzn", "createdAt": "2020-08-04T17:07:34Z", "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/cheggaaa/pb/v3\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {", "originalCommit": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NDg0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465254842", "bodyText": "ACk.", "author": "VijayanB", "createdAt": "2020-08-04T18:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMDczOA=="}], "type": "inlineReview"}, {"oid": "adfe6dd467f0c3d282b75a7eff43c575631a0ed6", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/adfe6dd467f0c3d282b75a7eff43c575631a0ed6", "message": "Update Readme", "committedDate": "2020-08-04T17:08:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMjAwNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465202004", "bodyText": "minor: this simple comment looks like some duplicate of the method name \"DeleteDetector\".  How about add more details like what we will do for force is true/false? Suggest to check other places too.", "author": "ylwu-amzn", "createdAt": "2020-08-04T17:09:52Z", "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/cheggaaa/pb/v3\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"stop\", c.StopDetector, display)\n+}\n+\n+//DeleteDetector deletes detector", "originalCommit": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NTA4NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465255084", "bodyText": "Ack", "author": "VijayanB", "createdAt": "2020-08-04T18:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMjAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNjAyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465206021", "bodyText": "Rename it as EsController considering we have AnomalyDetectorController?", "author": "ylwu-amzn", "createdAt": "2020-08-04T17:16:45Z", "path": "cli/internal/controller/es/controller.go", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package es\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"esad/internal/entity/es\"\n+\t\"esad/internal/gateway/es\"\n+\t\"fmt\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . Controller\n+\n+//Controller is an interface for ES Cluster to get distinct values\n+type Controller interface {", "originalCommit": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzNTc4NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465235785", "bodyText": "From Go Wiki:\nAll references to names in your package will be done using the package name, so you can omit that name from the identifiers. For example, if you are in package chubby, you don't need type ChubbyFile, which clients will write as chubby.ChubbyFile. Instead, name the type File, which clients will write as chubby.File.", "author": "VijayanB", "createdAt": "2020-08-04T18:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNjAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NTI5Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465255296", "bodyText": "I renamed adController to Controller to keep consistent.", "author": "VijayanB", "createdAt": "2020-08-04T18:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNjAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwODA0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465208045", "bodyText": "I think we should write const in uppercase letters.", "author": "ylwu-amzn", "createdAt": "2020-08-04T17:20:14Z", "path": "cli/internal/gateway/ad/ad.go", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"esad/internal/client\"\n+\tgw \"esad/internal/gateway\"\n+\tmapper2 \"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"net/url\"\n+)\n+\n+const (\n+\tbaseURL           = \"_opendistro/_anomaly_detection/detectors\"", "originalCommit": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzNTg2Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465235862", "bodyText": "Unfortunately in GO, it is recommended to write like this. If const will be exported, then we can capitalize the first character.", "author": "VijayanB", "createdAt": "2020-08-04T18:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwODA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MzQzNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465283437", "bodyText": "Sure, interesting way to use naming convention to control access.", "author": "ylwu-amzn", "createdAt": "2020-08-04T19:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwODA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMjM3MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465212370", "bodyText": "Should we change the repo ?", "author": "ylwu-amzn", "createdAt": "2020-08-04T17:27:40Z", "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,105 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS, Windows, Linux and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Version Compatibility Matrix\n+\n+| ESAD Version  | ODFE Version        |\n+| ------------- |:-------------------:|\n+| 0.1           | 1.7.X, 1.8.X, 1.9.X |\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/", "originalCommit": "adfe6dd467f0c3d282b75a7eff43c575631a0ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NTc1OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465255758", "bodyText": "Thanks for pointing it out.", "author": "VijayanB", "createdAt": "2020-08-04T18:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMjM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxODUxMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465218510", "bodyText": "Wrong comments?", "author": "ylwu-amzn", "createdAt": "2020-08-04T17:38:27Z", "path": "cli/internal/handler/ad/ad.go", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\tcontroller \"esad/internal/controller/ad\"\n+\tentity \"esad/internal/entity/ad\"\n+\tmapper2 \"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+)\n+\n+//Handler is facade for controller\n+type Handler struct {\n+\tcontroller.AnomalyDetectorController\n+}\n+\n+// New returns new Handler instance\n+func New(controller controller.AnomalyDetectorController) *Handler {\n+\treturn &Handler{\n+\t\tcontroller,\n+\t}\n+}\n+\n+//CreateAnomalyDetector creates detector based on file configurations\n+func CreateAnomalyDetector(h *Handler, fileName string, interactive bool) error {\n+\treturn h.CreateAnomalyDetector(fileName, interactive)\n+}\n+\n+//GenerateAnomalyDetector creates detector based on file configurations", "originalCommit": "adfe6dd467f0c3d282b75a7eff43c575631a0ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NjM0OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465256348", "bodyText": "ACk", "author": "VijayanB", "createdAt": "2020-08-04T18:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxODUxMA=="}], "type": "inlineReview"}, {"oid": "b32a33abde85620b09bc2097a08d343d84b344b0", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/b32a33abde85620b09bc2097a08d343d84b344b0", "message": "Rename Search to SearchDistinctValues", "committedDate": "2020-08-04T17:56:02Z", "type": "commit"}, {"oid": "d65eb8a39828520049ae568845a45dfdbf87303f", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/d65eb8a39828520049ae568845a45dfdbf87303f", "message": "rename controller to es", "committedDate": "2020-08-04T17:59:16Z", "type": "commit"}, {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9b805da939d62fb7243a4a9ee01792ed48b4a50f", "message": "Fixed following review comments\n\n1) Move methods close to help readability\n2) Add comments to exported methods\n3) Fix typo and copied comments\n4) Rename file name", "committedDate": "2020-08-04T18:51:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4NTc0OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465285748", "bodyText": "How about print all existing profile names as well? So user don't need to guess which name is not used.", "author": "ylwu-amzn", "createdAt": "2020-08-04T19:38:05Z", "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+\tesadProfile             = \"ESAD_PROFILE\"\n+)\n+\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+}\n+\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", \"----\", \"--------\", \"------------\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = getUserInput(\"profile's name\", false)\n+\t\tif !isProfileExists(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")", "originalCommit": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzOTcyNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465339725", "bodyText": "They can use list command to get profile names. Do you still think that providing all names will be good for UX?", "author": "VijayanB", "createdAt": "2020-08-04T21:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4NTc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NTc5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465345791", "bodyText": "Cool. Let's keep it as is.", "author": "ylwu-amzn", "createdAt": "2020-08-04T21:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4NTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4ODEzNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465288136", "bodyText": "How about we abstract this as validate func and pass it into getUserInput ? So it's flexible to support more parameter's validation logic in future. As currently we have only one simple validation, don't need to make it too complicated currently. Add some todo is fine. It's up to you.", "author": "ylwu-amzn", "createdAt": "2020-08-04T19:42:49Z", "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+\tesadProfile             = \"ESAD_PROFILE\"\n+)\n+\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+}\n+\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", \"----\", \"--------\", \"------------\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = getUserInput(\"profile's name\", false)\n+\t\tif !isProfileExists(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := getUserInput(\"endpoint\", false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := getUserInput(\"user\", false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := getUserInput(\"password\", true)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func isProfileExists(name string) bool {\n+\tprofiles := getProfiles()\n+\tfor _, profile := range profiles {\n+\t\tif profile.Name == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func getUserInputAsText() string {\n+\tvar response string\n+\t_, err := fmt.Scanln(&response)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\treturn strings.TrimSpace(response)\n+}\n+\n+func getUserInputAsMaskedText() string {\n+\tmaskedValue, err := terminal.ReadPassword(0)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println()\n+\treturn fmt.Sprintf(\"%s\", maskedValue)\n+}\n+\n+func getUserInput(name string, mask bool) string {\n+\n+\tvar response string\n+\tif mask {\n+\t\tresponse = getUserInputAsMaskedText()\n+\t} else {\n+\t\tresponse = getUserInputAsText()\n+\t}\n+\tif len(response) < 1 {", "originalCommit": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MDAyOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465380028", "bodyText": "Done.", "author": "VijayanB", "createdAt": "2020-08-04T23:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4ODEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MDU5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465290595", "bodyText": "Not so efficient to run isProfileExists  for every profile name, which will getProfile and do iteration to check if name exists. How about read all profiles, construct map (key: profile name, value: profile), then remove deleted profiles ?", "author": "ylwu-amzn", "createdAt": "2020-08-04T19:47:45Z", "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+\tesadProfile             = \"ESAD_PROFILE\"\n+)\n+\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+}\n+\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", \"----\", \"--------\", \"------------\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = getUserInput(\"profile's name\", false)\n+\t\tif !isProfileExists(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := getUserInput(\"endpoint\", false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := getUserInput(\"user\", false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := getUserInput(\"password\", true)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func isProfileExists(name string) bool {\n+\tprofiles := getProfiles()\n+\tfor _, profile := range profiles {\n+\t\tif profile.Name == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func getUserInputAsText() string {\n+\tvar response string\n+\t_, err := fmt.Scanln(&response)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\treturn strings.TrimSpace(response)\n+}\n+\n+func getUserInputAsMaskedText() string {\n+\tmaskedValue, err := terminal.ReadPassword(0)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println()\n+\treturn fmt.Sprintf(\"%s\", maskedValue)\n+}\n+\n+func getUserInput(name string, mask bool) string {\n+\n+\tvar response string\n+\tif mask {\n+\t\tresponse = getUserInputAsMaskedText()\n+\t} else {\n+\t\tresponse = getUserInputAsText()\n+\t}\n+\tif len(response) < 1 {\n+\t\tfmt.Printf(\"value cannot be empty. Please enter non-empty value for %s: \", name)\n+\t\treturn getUserInput(name, mask)\n+\t}\n+\treturn response\n+}\n+\n+func deleteProfiles(names []string) {\n+\n+\tvar existingProfileNames []string\n+\tfor _, name := range names {", "originalCommit": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzOTExNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465339115", "bodyText": "ACK.", "author": "VijayanB", "createdAt": "2020-08-04T21:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MDU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MjM4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465292387", "bodyText": "Wrong comment?", "author": "ylwu-amzn", "createdAt": "2020-08-04T19:51:24Z", "path": "cli/cmd/start_stop.go", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"esad/internal/client\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandStart = \"start\"\n+\tcommandStop  = \"stop\"\n+)\n+\n+// createCmd represents the create command", "originalCommit": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5ODIwNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465298204", "bodyText": "Yeah. I removed it.", "author": "VijayanB", "createdAt": "2020-08-04T20:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MjM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzOTg1NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465339854", "bodyText": "Yeah. I removed it now.", "author": "VijayanB", "createdAt": "2020-08-04T21:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MjM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Mjk0NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465292944", "bodyText": "Missing comment ? How about add comments for every command?", "author": "ylwu-amzn", "createdAt": "2020-08-04T19:52:25Z", "path": "cli/cmd/start_stop.go", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"esad/internal/client\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandStart = \"start\"\n+\tcommandStop  = \"stop\"\n+)\n+\n+// createCmd represents the create command\n+var startCmd = &cobra.Command{\n+\tUse:   commandStart + \" [flags] [list of detectors]\",\n+\tShort: \"Start detectors\",\n+\tLong:  `Start detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\taction := ad.StartAnomalyDetector\n+\t\tif idStatus {\n+\t\t\taction = ad.StartAnomalyDetectorByID\n+\t\t}\n+\t\terr := execute(action, args)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(commandStart, \"command failed\")\n+\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t}\n+\t},\n+}\n+\n+var stopCmd = &cobra.Command{", "originalCommit": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MDI1Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465340257", "bodyText": "Typically in go, comment is required for exported variables or functions. Here we are not exporting stopCmd. What do you think?", "author": "VijayanB", "createdAt": "2020-08-04T21:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Mjk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1MzE1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465353155", "bodyText": "Comments can help others include ourselves to understand code quickly. I think we should add some basic description for these commands like what the command does, what's the input/output, potential exceptions. There are already some description for this command for line 47-48. If you don't like too much comment, how about make line48 more accurate as \"Stops detectors based on detector id or detector name pattern, ....\"", "author": "ylwu-amzn", "createdAt": "2020-08-04T21:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Mjk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3OTkzNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465379935", "bodyText": "Got it. I added comments and updated help as well.", "author": "VijayanB", "createdAt": "2020-08-04T23:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Mjk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjA1NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465296054", "bodyText": "We only support minutes on AD Kibana. Should we support more unit options in AD CLI? If user use \"Hours\" to create index with CLI, then AD Kibana may not show it correctly.", "author": "ylwu-amzn", "createdAt": "2020-08-04T19:58:35Z", "path": "cli/internal/mapper/ad/ad.go", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"encoding/json\"\n+\t\"esad/internal/entity/ad\"\n+\t\"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"regexp\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+const featureCountLimit = 5\n+\n+func getFeatureAggregationQuery(name string, agg string, field string) ([]byte, error) {\n+\n+\tuserTypeToESType := make(map[string]string)\n+\tuserTypeToESType[\"average\"] = \"avg\"\n+\tuserTypeToESType[\"count\"] = \"value_count\"\n+\tuserTypeToESType[\"sum\"] = \"sum\"\n+\tuserTypeToESType[\"min\"] = \"min\"\n+\tuserTypeToESType[\"max\"] = \"max\"\n+\tval, ok := userTypeToESType[strings.ToLower(agg)]\n+\tif !ok {\n+\t\tvar allowedTypes []string\n+\t\tfor key := range userTypeToESType {\n+\t\t\tallowedTypes = append(allowedTypes, key)\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invlaid aggeration type: '%s', only allowed types are: %s \", agg, strings.Join(allowedTypes, \",\"))\n+\t}\n+\tagg = val\n+\treturn []byte(fmt.Sprintf(`{\n+        \t\t\t\"%s\": {\n+          \t\t\t\t\"%s\": {\n+            \t\t\t\t\"field\": \"%s\"\n+\t\t\t\t\t\t}\n+        \t\t\t}\n+      \t\t\t}`, name, agg, field)), nil\n+}\n+func mapToFeature(r ad.FeatureRequest) ([]ad.Feature, error) {\n+\tvar features []ad.Feature\n+\tfor _, t := range r.AggregationType {\n+\t\tfor _, f := range r.Field {\n+\t\t\tname := fmt.Sprintf(\"%s_%s\", t, f)\n+\t\t\tquery, err := getFeatureAggregationQuery(name, t, f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfeatures = append(features, ad.Feature{\n+\t\t\t\tName:             name,\n+\t\t\t\tEnabled:          r.Enabled,\n+\t\t\t\tAggregationQuery: query,\n+\t\t\t})\n+\t\t}\n+\t}\n+\treturn features, nil\n+}\n+\n+func getUnit(request string) (*string, error) {", "originalCommit": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MTE2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465341161", "bodyText": "Now, create command fails with response \"Hours is not supported\". In my opinion this is more as restriction in backend than frontend. What do you think? Do we plan to support this in future? if so then having this will have old clients to use this format.", "author": "VijayanB", "createdAt": "2020-08-04T21:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0Mzc1OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465343759", "bodyText": "Currently we have no plan to support other unit options. How about we support only minutes here to keep consistent with AD Kibana (support minutes only) and backend (supports minutes/seconds, code).", "author": "ylwu-amzn", "createdAt": "2020-08-04T21:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3Njc5Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465376793", "bodyText": "Sounds good. Will keep only minutes and will raise error for other cases", "author": "VijayanB", "createdAt": "2020-08-04T23:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjcyMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465296722", "bodyText": "minor: typo, feautes  -> features", "author": "ylwu-amzn", "createdAt": "2020-08-04T19:59:50Z", "path": "cli/internal/mapper/ad/ad.go", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"encoding/json\"\n+\t\"esad/internal/entity/ad\"\n+\t\"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"regexp\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+const featureCountLimit = 5\n+\n+func getFeatureAggregationQuery(name string, agg string, field string) ([]byte, error) {\n+\n+\tuserTypeToESType := make(map[string]string)\n+\tuserTypeToESType[\"average\"] = \"avg\"\n+\tuserTypeToESType[\"count\"] = \"value_count\"\n+\tuserTypeToESType[\"sum\"] = \"sum\"\n+\tuserTypeToESType[\"min\"] = \"min\"\n+\tuserTypeToESType[\"max\"] = \"max\"\n+\tval, ok := userTypeToESType[strings.ToLower(agg)]\n+\tif !ok {\n+\t\tvar allowedTypes []string\n+\t\tfor key := range userTypeToESType {\n+\t\t\tallowedTypes = append(allowedTypes, key)\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invlaid aggeration type: '%s', only allowed types are: %s \", agg, strings.Join(allowedTypes, \",\"))\n+\t}\n+\tagg = val\n+\treturn []byte(fmt.Sprintf(`{\n+        \t\t\t\"%s\": {\n+          \t\t\t\t\"%s\": {\n+            \t\t\t\t\"field\": \"%s\"\n+\t\t\t\t\t\t}\n+        \t\t\t}\n+      \t\t\t}`, name, agg, field)), nil\n+}\n+func mapToFeature(r ad.FeatureRequest) ([]ad.Feature, error) {\n+\tvar features []ad.Feature\n+\tfor _, t := range r.AggregationType {\n+\t\tfor _, f := range r.Field {\n+\t\t\tname := fmt.Sprintf(\"%s_%s\", t, f)\n+\t\t\tquery, err := getFeatureAggregationQuery(name, t, f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfeatures = append(features, ad.Feature{\n+\t\t\t\tName:             name,\n+\t\t\t\tEnabled:          r.Enabled,\n+\t\t\t\tAggregationQuery: query,\n+\t\t\t})\n+\t\t}\n+\t}\n+\treturn features, nil\n+}\n+\n+func getUnit(request string) (*string, error) {\n+\n+\t//extract last character\n+\tunit := strings.ToLower(request[len(request)-1:])\n+\tstringToUnitMap := make(map[string]string)\n+\tstringToUnitMap[\"s\"] = \"Seconds\"\n+\tstringToUnitMap[\"m\"] = \"Minutes\"\n+\tstringToUnitMap[\"h\"] = \"Hours\"\n+\tstringToUnitMap[\"w\"] = \"Weeks\"\n+\tstringToUnitMap[\"d\"] = \"Days\"\n+\tif val, ok := stringToUnitMap[unit]; ok {\n+\t\treturn mapper.StringToStringPtr(val), nil\n+\t}\n+\treturn nil, fmt.Errorf(\"invlaid unit: '%v' in %v\", unit, request)\n+}\n+\n+func getDuration(request string) (*int32, error) {\n+\t//extract last but one character\n+\tduration, err := strconv.Atoi(request[:len(request)-1])\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"invlaid duration: %v, due to {%v}\", request, err)\n+\t}\n+\tif duration < 0 {\n+\t\treturn nil, fmt.Errorf(\"duration must be positive integer\")\n+\t}\n+\treturn mapper.IntToInt32Ptr(duration)\n+}\n+\n+func mapToInterval(request string) (*ad.Interval, error) {\n+\tif len(request) < 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid format: %s\", request)\n+\t}\n+\tduration, err := getDuration(request)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tunit, err := getUnit(request)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &ad.Interval{\n+\t\tPeriod: ad.Period{\n+\t\t\tDuration: mapper.Int32PtrToInt32(duration),\n+\t\t\tUnit:     mapper.StringPtrToString(unit),\n+\t\t},\n+\t}, nil\n+}\n+\n+//MapToCreateDetector maps to CreateDetector\n+func MapToCreateDetector(request ad.CreateDetectorRequest) (*ad.CreateDetector, error) {\n+\n+\tvar features []ad.Feature\n+\terr := validateFeatureLimit(request.Features)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, f := range request.Features {\n+\t\tftr, err := mapToFeature(f)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tfeatures = append(features, ftr...)\n+\t}\n+\n+\tinterval, err := mapToInterval(request.Interval)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdelay, err := mapToInterval(request.Delay)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &ad.CreateDetector{\n+\t\tName:        request.Name,\n+\t\tDescription: request.Description,\n+\t\tTimeField:   request.TimeField,\n+\t\tIndex:       request.Index,\n+\t\tFeatures:    features,\n+\t\tFilter:      request.Filter,\n+\t\tInterval:    *interval,\n+\t\tDelay:       *delay,\n+\t}, nil\n+}\n+\n+func validateFeatureLimit(features []ad.FeatureRequest) error {\n+\tfeatureCount := 0\n+\tfor _, f := range features {\n+\t\tfeatureCount += len(f.AggregationType) * len(f.Field)\n+\t}\n+\tif featureCount == 0 || featureCount > featureCountLimit {\n+\t\treturn fmt.Errorf(\"trying to create %d feautes, only upto %d features are allowed\", featureCount, featureCountLimit)", "originalCommit": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MTc3NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465341774", "bodyText": "Done", "author": "VijayanB", "createdAt": "2020-08-04T21:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjcyMg=="}], "type": "inlineReview"}, {"oid": "9659ac6502ff88e96c46337b7cf09f9a140bd46d", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9659ac6502ff88e96c46337b7cf09f9a140bd46d", "message": "use map for get profiles", "committedDate": "2020-08-04T21:22:15Z", "type": "commit"}, {"oid": "2bec3bd904b8e43a1edc4bea9624893f800e5572", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/2bec3bd904b8e43a1edc4bea9624893f800e5572", "message": "Fixed typo", "committedDate": "2020-08-04T21:30:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1MzcwNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465353705", "bodyText": "How about rename as \"StopAnomalyDetectorByNamePattern\" considering this method \"StopAnomalyDetectorByID\"", "author": "ylwu-amzn", "createdAt": "2020-08-04T21:58:30Z", "path": "cli/cmd/start_stop.go", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"esad/internal/client\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandStart = \"start\"\n+\tcommandStop  = \"stop\"\n+)\n+\n+var startCmd = &cobra.Command{\n+\tUse:   commandStart + \" [flags] [list of detectors]\",\n+\tShort: \"Start detectors\",\n+\tLong:  `Start detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\taction := ad.StartAnomalyDetector\n+\t\tif idStatus {\n+\t\t\taction = ad.StartAnomalyDetectorByID\n+\t\t}\n+\t\terr := execute(action, args)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(commandStart, \"command failed\")\n+\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t}\n+\t},\n+}\n+\n+var stopCmd = &cobra.Command{\n+\tUse:   commandStop + \" [flags] [list of detectors]\",\n+\tShort: \"Stop detectors\",\n+\tLong:  `Stops detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\taction := ad.StopAnomalyDetector", "originalCommit": "2bec3bd904b8e43a1edc4bea9624893f800e5572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3OTUzMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465379530", "bodyText": "Done", "author": "VijayanB", "createdAt": "2020-08-04T23:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1MzcwNQ=="}], "type": "inlineReview"}, {"oid": "5e7336d943debc0fb9f445a0dfdbacfe6c85b895", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/5e7336d943debc0fb9f445a0dfdbacfe6c85b895", "message": "Move validation as method argument", "committedDate": "2020-08-04T22:03:26Z", "type": "commit"}, {"oid": "d92e26323c2b583d564c82941fdaae3b1460df97", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/d92e26323c2b583d564c82941fdaae3b1460df97", "message": "Fixed Review comments\n\nRename Method name to include byNamePattern\nSupport only minutes for interval\nAdded extra comments", "committedDate": "2020-08-04T23:08:45Z", "type": "commit"}, {"oid": "7bea3e682c4dde1a0547d178ecd7cf6eaaa6a32a", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/7bea3e682c4dde1a0547d178ecd7cf6eaaa6a32a", "message": "Renamed gateway", "committedDate": "2020-08-05T00:07:31Z", "type": "commit"}]}