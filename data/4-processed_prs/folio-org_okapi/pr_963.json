{"pr_number": 963, "pr_title": "Async install and Futurisation OKAPI-845 OKAPI-874", "pr_createdAt": "2020-08-27T14:59:58Z", "pr_url": "https://github.com/folio-org/okapi/pull/963", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwNDUwNw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490304507", "bodyText": "Does this mean it's possible to check the status of a sync install?  Is it worth mentioning that in the docs?", "author": "craigmcnally", "createdAt": "2020-09-17T14:42:12Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -256,11 +254,21 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.upgrade.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"", "originalCommit": "bf5ab7bfcb9304049cfd2b8b53bba92703464963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NzA4OA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490477088", "bodyText": "Yes. I can mention it.", "author": "adamdickmeiss", "createdAt": "2020-09-17T18:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwNDUwNw=="}], "type": "inlineReview"}, {"oid": "66426ba7cd63f2966f7ad684757680a21d0a8c99", "url": "https://github.com/folio-org/okapi/commit/66426ba7cd63f2966f7ad684757680a21d0a8c99", "message": "Notes on getting all install jobs", "committedDate": "2020-09-17T18:51:07Z", "type": "commit"}, {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "url": "https://github.com/folio-org/okapi/commit/92d63f729135c8ad34283fc1a02545d9ba26ce17", "message": "Merge branch 'OKAPI-804-async-install' of github.com:folio-org/okapi into OKAPI-804-async-install", "committedDate": "2020-09-17T18:51:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2OTczOA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490569738", "bodyText": "Consider to use uppercase M for manager part", "author": "hjiebsco", "createdAt": "2020-09-17T21:22:40Z", "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -214,16 +215,12 @@ public void start(Promise<Void> promise) {\n \n   private Future<Void> startModmanager() {\n     logger.info(\"startModmanager\");", "originalCommit": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgwMDU1NQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490800555", "bodyText": "ok. Renaming the function.", "author": "adamdickmeiss", "createdAt": "2020-09-18T08:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2OTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3MDQ1NA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490570454", "bodyText": "Maybe mention and explain possible stages (deploy, call, and undeploy) here?", "author": "hjiebsco", "createdAt": "2020-09-17T21:24:15Z", "path": "doc/guide.md", "diffHunk": "@@ -2621,7 +2623,71 @@ the install operation will also deploy and un-deploy as\n necessary. This will only work if the ModuleDescriptor has the\n launchDescriptor property.\n \n-### Purge\n+### Install jobs and asynchronous operations\n+\n+For Okapi 4.2.0 and later, the install operation can be asynchronous.\n+The asynchronous operation is enabled by URI parameter 'async=true'.\n+As for the \"synchronous\" operation, the dependency check is performed\n+first and install/upgrade will return 400 HTTP error upon failure.\n+\n+Following that, the install operation will create an install \"job\" on the\n+server side and return HTTP status 201 along with a location of the newly\n+created install job. The returned JSON content is defined by schema\n+([InstallJob.json](../okapi-core/src/main/raml/InstallJob.json)).\n+\n+This location can then be inspected with HTTP GET for the progress of\n+the install operation. The location is same base URI as install, but\n+with a slash + the job ID. The install job has properties such as\n+\n+ * `complete`: boolean which tells whether the job has completed\n+ * `id`: job id\n+ * `date`: start time of job in UTC ISO8601 format.\n+ * `modules`: enable/disable list of modules along with status.\n+\n+Each module entry is defined by schema\n+([TenantModuleDescriptor.json](../okapi-core/src/main/raml/TenantModuleDescriptor.json)).\n+Brief list of properties:\n+\n+ * `id`: module ID\n+ * `from`: old module ID (absent if not upgrading)\n+ * `action`: enable/disable/uptodate\n+ * `stage`: the current stage of the module\n+ * `message`: present upon error (error message)\n+\n+If `message` property is present an error has occurred and `stage`\n+indicates at which stage the error occurred.", "originalCommit": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgwNzAwMA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490807000", "bodyText": "ok", "author": "adamdickmeiss", "createdAt": "2020-09-18T09:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3MDQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3MTEwMQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490571101", "bodyText": "This is the starting date. Is it possible to add a finish date to know the duration of the install/upgrade?", "author": "hjiebsco", "createdAt": "2020-09-17T21:25:41Z", "path": "okapi-core/src/main/java/org/folio/okapi/bean/InstallJob.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.folio.okapi.bean;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import java.util.List;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class InstallJob {\n+\n+  private String id;\n+\n+  private Boolean complete;\n+\n+  private String date;", "originalCommit": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ3MDY0MQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491470641", "bodyText": "ok. done", "author": "adamdickmeiss", "createdAt": "2020-09-19T16:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3MTEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4MDE3Ng==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490580176", "bodyText": "Consider change id to tenantId", "author": "hjiebsco", "createdAt": "2020-09-17T21:46:06Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +729,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String id) {", "originalCommit": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxMDM0Ng==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490810346", "bodyText": "Good idea.", "author": "adamdickmeiss", "createdAt": "2020-09-18T09:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4MDE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NDQzOQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490584439", "bodyText": "Do we support checking the status of async upgrade?", "author": "hjiebsco", "createdAt": "2020-09-17T21:56:00Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +729,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String id) {\n \n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n-    tenantManager.installUpgradeModules(id, pc, options, null, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-        fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-      }\n-    });\n+    UUID installId = UUID.randomUUID();\n+    return tenantManager.installUpgradeCreate(id, installId.toString(), pc, options, null)\n+        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));", "originalCommit": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxMDc2NA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490810764", "bodyText": "yes. Should probably be mentioned.", "author": "adamdickmeiss", "createdAt": "2020-09-18T09:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQyNTk5Mw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493425993", "bodyText": "This /upgrade endpoint method does not return location header, so how does the caller know where to track the status?", "author": "hjiebsco", "createdAt": "2020-09-23T10:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NDQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU5ODY4Mw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490598683", "bodyText": "Typo. Should be Clone, not Close", "author": "hjiebsco", "createdAt": "2020-09-17T22:33:27Z", "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Close an entry without status (for Install without async).", "originalCommit": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxMTAwNA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490811004", "bodyText": "yep", "author": "adamdickmeiss", "createdAt": "2020-09-18T09:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU5ODY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYwNDYzMg==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490604632", "bodyText": "Should we also set stage to be pending for tm in tml2?", "author": "hjiebsco", "createdAt": "2020-09-17T22:50:20Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -982,144 +752,186 @@ void listModulesFromInterface(String tenantId,\n             }\n           }\n         }\n-        fut.handle(new Success<>(mdList));\n-      }); // modlist\n-    }); // tenant\n+        return Future.succeededFuture(mdList);\n+      });\n+    });\n   }\n \n-  void installUpgradeModules(String tenantId, ProxyContext pc,\n-                             TenantInstallOptions options, List<TenantModuleDescriptor> tml,\n-                             Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+  Future<InstallJob> installUpgradeGet(String tenantId, String installId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.getNotFound(tenantId, installId));\n+  }\n \n+  Future<List<InstallJob>> installUpgradeGetList(String tenantId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.get(tenantId).compose(list -> {\n+      if (list == null) {\n+        return Future.succeededFuture(new LinkedList<>());\n+      }\n+      return Future.succeededFuture(list);\n+    }));\n+  }\n+\n+  Future<List<TenantModuleDescriptor>> installUpgradeCreate(\n+      String tenantId, String installId, ProxyContext pc,\n+      TenantInstallOptions options, List<TenantModuleDescriptor> tml) {\n+\n+    logger.info(\"installUpgradeCreate InstallId={}\", installId);\n     if (tml != null) {\n       for (TenantModuleDescriptor tm : tml) {\n         if (tm.getAction() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10405\", tm.getId())));\n-          return;\n+          return Future.failedFuture(new OkapiError(ErrorType.USER,\n+              messages.getMessage(\"10405\", tm.getId())));\n         }\n       }\n     }\n-    tenants.get(tenantId, gres -> {\n-      if (gres.failed()) {\n-        fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        return;\n-      }\n-      Tenant t = gres.result();\n-      moduleManager.getModulesWithFilter(options.getPreRelease(),\n-          options.getNpmSnapshot(), null, mres -> {\n-            if (mres.failed()) {\n-              fut.handle(new Failure<>(mres.getType(), mres.cause()));\n-              return;\n-            }\n-            List<ModuleDescriptor> modResult = mres.result();\n-            HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modResult.size());\n-            HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n-            for (ModuleDescriptor md : modResult) {\n-              modsAvailable.put(md.getId(), md);\n-              logger.info(\"mod available: {}\", md.getId());\n-              if (t.isEnabled(md.getId())) {\n-                logger.info(\"mod enabled: {}\", md.getId());\n-                modsEnabled.put(md.getId(), md);\n+    return tenants.getNotFound(tenantId).compose(tenant ->\n+        moduleManager.getModulesWithFilter(options.getPreRelease(),\n+            options.getNpmSnapshot(), null)\n+            .compose(modules -> {\n+              HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modules.size());\n+              HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+              for (ModuleDescriptor md : modules) {\n+                modsAvailable.put(md.getId(), md);\n+                logger.info(\"mod available: {}\", md.getId());\n+                if (tenant.isEnabled(md.getId())) {\n+                  logger.info(\"mod enabled: {}\", md.getId());\n+                  modsEnabled.put(md.getId(), md);\n+                }\n               }\n-            }\n-            List<TenantModuleDescriptor> tml2\n-                = prepareTenantModuleList(modsAvailable, modsEnabled, tml);\n-            installUpgradeModules2(t, pc, options, modsAvailable, modsEnabled, tml2, fut);\n-          });\n-    });\n+              InstallJob job = new InstallJob();\n+              job.setId(installId);\n+              job.setDate(Instant.now().toString());\n+              if (tml == null) {\n+                job.setModules(upgrades(modsAvailable, modsEnabled));\n+              } else {\n+                job.setModules(tml);\n+              }\n+              job.setComplete(false);\n+              return runJob(tenant, pc, options, modsAvailable, modsEnabled, job);\n+            }));\n   }\n \n-  private List<TenantModuleDescriptor> prepareTenantModuleList(\n-      Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n-\n-    if (tml == null) { // upgrade case . Mark all newer modules for install\n-      List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n-      for (String id : modsEnabled.keySet()) {\n-        ModuleId moduleId = new ModuleId(id);\n-        String latestId = moduleId.getLatest(modsAvailable.keySet());\n-        if (!latestId.equals(id)) {\n-          TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n-          tmd.setAction(Action.enable);\n-          tmd.setId(latestId);\n-          logger.info(\"upgrade.. enable {}\", latestId);\n-          tmd.setFrom(id);\n-          tml2.add(tmd);\n-        }\n+  private List<TenantModuleDescriptor> upgrades(\n+      Map<String, ModuleDescriptor> modsAvailable, Map<String, ModuleDescriptor> modsEnabled) {\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    for (String id : modsEnabled.keySet()) {\n+      ModuleId moduleId = new ModuleId(id);\n+      String latestId = moduleId.getLatest(modsAvailable.keySet());\n+      if (!latestId.equals(id)) {\n+        TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n+        tmd.setAction(Action.enable);\n+        tmd.setId(latestId);\n+        logger.info(\"upgrade.. enable {}\", latestId);\n+        tmd.setFrom(id);\n+        tml.add(tmd);\n       }\n-      return tml2;\n-    } else {\n-      return tml;\n     }\n+    return tml;\n   }\n \n-  private void installUpgradeModules2(\n-      Tenant t, ProxyContext pc,\n-      TenantInstallOptions options,\n+  private Future<List<TenantModuleDescriptor>> runJob(\n+      Tenant t, ProxyContext pc, TenantInstallOptions options,\n       Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml,\n-      Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+      Map<String, ModuleDescriptor> modsEnabled, InstallJob job) {\n \n-    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n+    List<TenantModuleDescriptor> tml = job.getModules();\n+    return DepResolution.installSimulate(modsAvailable, modsEnabled, tml).compose(res -> {\n       if (options.getSimulate()) {\n-        fut.handle(new Success<>(tml));\n-      } else {\n-        installAutodeploy(t, pc, options, modsAvailable, tml, tml.iterator(),\n-            res1 -> {\n-              if (res1.failed()) {\n-                fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-              } else {\n-                fut.handle(new Success<>(tml));\n+        return Future.succeededFuture(tml);\n+      }\n+      return jobs.add(t.getId(), job.getId(), job).compose(res2 -> {\n+        Promise<List<TenantModuleDescriptor>> promise = Promise.promise();\n+        Future<Void> future = Future.succeededFuture();\n+        if (options.getAsync()) {\n+          List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n+          for (TenantModuleDescriptor tm : tml) {\n+            tml2.add(tm.cloneWithoutStatus());\n+          }\n+          promise.complete(tml2);", "originalCommit": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxNjM4Ng==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490816386", "bodyText": "No. That wasn't the intention. The meaning was that it would return entries without status/stage .. for the async immediate response.", "author": "adamdickmeiss", "createdAt": "2020-09-18T09:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYwNDYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxNDI1Mw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490614253", "bodyText": "Should we check async here and update tml stage to undeploy? BTW stage.undeploy has not been used anywhere in the project yet.", "author": "hjiebsco", "createdAt": "2020-09-17T23:21:18Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -982,144 +752,186 @@ void listModulesFromInterface(String tenantId,\n             }\n           }\n         }\n-        fut.handle(new Success<>(mdList));\n-      }); // modlist\n-    }); // tenant\n+        return Future.succeededFuture(mdList);\n+      });\n+    });\n   }\n \n-  void installUpgradeModules(String tenantId, ProxyContext pc,\n-                             TenantInstallOptions options, List<TenantModuleDescriptor> tml,\n-                             Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+  Future<InstallJob> installUpgradeGet(String tenantId, String installId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.getNotFound(tenantId, installId));\n+  }\n \n+  Future<List<InstallJob>> installUpgradeGetList(String tenantId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.get(tenantId).compose(list -> {\n+      if (list == null) {\n+        return Future.succeededFuture(new LinkedList<>());\n+      }\n+      return Future.succeededFuture(list);\n+    }));\n+  }\n+\n+  Future<List<TenantModuleDescriptor>> installUpgradeCreate(\n+      String tenantId, String installId, ProxyContext pc,\n+      TenantInstallOptions options, List<TenantModuleDescriptor> tml) {\n+\n+    logger.info(\"installUpgradeCreate InstallId={}\", installId);\n     if (tml != null) {\n       for (TenantModuleDescriptor tm : tml) {\n         if (tm.getAction() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10405\", tm.getId())));\n-          return;\n+          return Future.failedFuture(new OkapiError(ErrorType.USER,\n+              messages.getMessage(\"10405\", tm.getId())));\n         }\n       }\n     }\n-    tenants.get(tenantId, gres -> {\n-      if (gres.failed()) {\n-        fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        return;\n-      }\n-      Tenant t = gres.result();\n-      moduleManager.getModulesWithFilter(options.getPreRelease(),\n-          options.getNpmSnapshot(), null, mres -> {\n-            if (mres.failed()) {\n-              fut.handle(new Failure<>(mres.getType(), mres.cause()));\n-              return;\n-            }\n-            List<ModuleDescriptor> modResult = mres.result();\n-            HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modResult.size());\n-            HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n-            for (ModuleDescriptor md : modResult) {\n-              modsAvailable.put(md.getId(), md);\n-              logger.info(\"mod available: {}\", md.getId());\n-              if (t.isEnabled(md.getId())) {\n-                logger.info(\"mod enabled: {}\", md.getId());\n-                modsEnabled.put(md.getId(), md);\n+    return tenants.getNotFound(tenantId).compose(tenant ->\n+        moduleManager.getModulesWithFilter(options.getPreRelease(),\n+            options.getNpmSnapshot(), null)\n+            .compose(modules -> {\n+              HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modules.size());\n+              HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+              for (ModuleDescriptor md : modules) {\n+                modsAvailable.put(md.getId(), md);\n+                logger.info(\"mod available: {}\", md.getId());\n+                if (tenant.isEnabled(md.getId())) {\n+                  logger.info(\"mod enabled: {}\", md.getId());\n+                  modsEnabled.put(md.getId(), md);\n+                }\n               }\n-            }\n-            List<TenantModuleDescriptor> tml2\n-                = prepareTenantModuleList(modsAvailable, modsEnabled, tml);\n-            installUpgradeModules2(t, pc, options, modsAvailable, modsEnabled, tml2, fut);\n-          });\n-    });\n+              InstallJob job = new InstallJob();\n+              job.setId(installId);\n+              job.setDate(Instant.now().toString());\n+              if (tml == null) {\n+                job.setModules(upgrades(modsAvailable, modsEnabled));\n+              } else {\n+                job.setModules(tml);\n+              }\n+              job.setComplete(false);\n+              return runJob(tenant, pc, options, modsAvailable, modsEnabled, job);\n+            }));\n   }\n \n-  private List<TenantModuleDescriptor> prepareTenantModuleList(\n-      Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n-\n-    if (tml == null) { // upgrade case . Mark all newer modules for install\n-      List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n-      for (String id : modsEnabled.keySet()) {\n-        ModuleId moduleId = new ModuleId(id);\n-        String latestId = moduleId.getLatest(modsAvailable.keySet());\n-        if (!latestId.equals(id)) {\n-          TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n-          tmd.setAction(Action.enable);\n-          tmd.setId(latestId);\n-          logger.info(\"upgrade.. enable {}\", latestId);\n-          tmd.setFrom(id);\n-          tml2.add(tmd);\n-        }\n+  private List<TenantModuleDescriptor> upgrades(\n+      Map<String, ModuleDescriptor> modsAvailable, Map<String, ModuleDescriptor> modsEnabled) {\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    for (String id : modsEnabled.keySet()) {\n+      ModuleId moduleId = new ModuleId(id);\n+      String latestId = moduleId.getLatest(modsAvailable.keySet());\n+      if (!latestId.equals(id)) {\n+        TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n+        tmd.setAction(Action.enable);\n+        tmd.setId(latestId);\n+        logger.info(\"upgrade.. enable {}\", latestId);\n+        tmd.setFrom(id);\n+        tml.add(tmd);\n       }\n-      return tml2;\n-    } else {\n-      return tml;\n     }\n+    return tml;\n   }\n \n-  private void installUpgradeModules2(\n-      Tenant t, ProxyContext pc,\n-      TenantInstallOptions options,\n+  private Future<List<TenantModuleDescriptor>> runJob(\n+      Tenant t, ProxyContext pc, TenantInstallOptions options,\n       Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml,\n-      Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+      Map<String, ModuleDescriptor> modsEnabled, InstallJob job) {\n \n-    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n+    List<TenantModuleDescriptor> tml = job.getModules();\n+    return DepResolution.installSimulate(modsAvailable, modsEnabled, tml).compose(res -> {\n       if (options.getSimulate()) {\n-        fut.handle(new Success<>(tml));\n-      } else {\n-        installAutodeploy(t, pc, options, modsAvailable, tml, tml.iterator(),\n-            res1 -> {\n-              if (res1.failed()) {\n-                fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-              } else {\n-                fut.handle(new Success<>(tml));\n+        return Future.succeededFuture(tml);\n+      }\n+      return jobs.add(t.getId(), job.getId(), job).compose(res2 -> {\n+        Promise<List<TenantModuleDescriptor>> promise = Promise.promise();\n+        Future<Void> future = Future.succeededFuture();\n+        if (options.getAsync()) {\n+          List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n+          for (TenantModuleDescriptor tm : tml) {\n+            tml2.add(tm.cloneWithoutStatus());\n+          }\n+          promise.complete(tml2);\n+          future = future.compose(x -> {\n+            for (TenantModuleDescriptor tm : tml) {\n+              tm.setStage(TenantModuleDescriptor.Stage.pending);\n+            }\n+            return jobs.put(t.getId(), job.getId(), job);\n+          });\n+        }\n+        if (options.getDeploy()) {\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              for (TenantModuleDescriptor tm : tml) {\n+                tm.setStage(TenantModuleDescriptor.Stage.deploy);\n               }\n+              return jobs.put(t.getId(), job.getId(), job);\n             });\n-      }\n+          }\n+          future = future.compose(x -> autoDeploy(t, modsAvailable, tml));\n+        }\n+        for (TenantModuleDescriptor tm : tml) {\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              tm.setStage(TenantModuleDescriptor.Stage.call);\n+              return jobs.put(t.getId(), job.getId(), job);\n+            });\n+          }\n+          if (options.getIgnoreErrors()) {\n+            Promise<Void> promise1 = Promise.promise();\n+            installTenantModule(t, pc, options, modsAvailable, tm).onComplete(x -> {\n+              if (x.failed()) {\n+                logger.warn(\"Ignoring error for tenant {} module {}\",\n+                    t.getId(), tm.getId(), x.cause());\n+              }\n+              promise1.complete();\n+            });\n+            future = future.compose(x -> promise1.future());\n+          } else {\n+            future = future.compose(x -> installTenantModule(t, pc, options, modsAvailable, tm));\n+          }\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              if (tm.getMessage() == null) {\n+                tm.setStage(TenantModuleDescriptor.Stage.done);\n+              }\n+              return jobs.put(t.getId(), job.getId(), job);\n+            });\n+          }\n+        }\n+        if (options.getDeploy()) {\n+          future.compose(x -> autoUndeploy(t, modsAvailable, tml));\n+        }", "originalCommit": "92d63f729135c8ad34283fc1a02545d9ba26ce17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5NzgzMg==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490897832", "bodyText": "Yes. I have change things so that deploy and undeploy only change state for particular modules (which might be a subset of all modules in the list).", "author": "adamdickmeiss", "createdAt": "2020-09-18T11:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxNDI1Mw=="}], "type": "inlineReview"}, {"oid": "cac6dbf3b8ea1b14a7a31b94d836a29cd0f33416", "url": "https://github.com/folio-org/okapi/commit/cac6dbf3b8ea1b14a7a31b94d836a29cd0f33416", "message": "Add okapi.proxy.tenants.install.list; fix okapi.tenantmodules list", "committedDate": "2020-09-18T08:47:47Z", "type": "commit"}, {"oid": "4a5e2f2d2e3dddb2e1dd6cb1460d334632d5cb23", "url": "https://github.com/folio-org/okapi/commit/4a5e2f2d2e3dddb2e1dd6cb1460d334632d5cb23", "message": "Rename startModmanager to startModuleManager", "committedDate": "2020-09-18T08:53:00Z", "type": "commit"}, {"oid": "868c75be77fcdbfbec25a0936430e9d1b020068a", "url": "https://github.com/folio-org/okapi/commit/868c75be77fcdbfbec25a0936430e9d1b020068a", "message": "Describe stage values", "committedDate": "2020-09-18T09:04:06Z", "type": "commit"}, {"oid": "da193fd030319258a09037a0943a3197ce3b4e4a", "url": "https://github.com/folio-org/okapi/commit/da193fd030319258a09037a0943a3197ce3b4e4a", "message": "Use tenantId for tenant identifiers", "committedDate": "2020-09-18T09:09:42Z", "type": "commit"}, {"oid": "3839db34d8623836a8e5fd631adcf1289d74cdd3", "url": "https://github.com/folio-org/okapi/commit/3839db34d8623836a8e5fd631adcf1289d74cdd3", "message": "Fix typo", "committedDate": "2020-09-18T09:29:07Z", "type": "commit"}, {"oid": "b0c9e6794f45ba2ac1ac670295149db35e7b08b4", "url": "https://github.com/folio-org/okapi/commit/b0c9e6794f45ba2ac1ac670295149db35e7b08b4", "message": "Save jobs regardless of async; deploy/undeploy status", "committedDate": "2020-09-18T10:01:24Z", "type": "commit"}, {"oid": "667da414de694fad916f1ecaa95059ba7ae20580", "url": "https://github.com/folio-org/okapi/commit/667da414de694fad916f1ecaa95059ba7ae20580", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-09-18T11:50:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NDAzOA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491184038", "bodyText": "status has been renamed to stage.\nShould the javadoc been renamed to Clone an entry without stage and the method been renamed to cloneWithoutState?", "author": "julianladisch", "createdAt": "2020-09-18T20:49:24Z", "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Clone an entry without status and stage (for Install without async).\n+   * @return entry\n+   */\n+  @JsonIgnore\n+  public TenantModuleDescriptor cloneWithoutStatus() {", "originalCommit": "667da414de694fad916f1ecaa95059ba7ae20580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2NDkyMQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491464921", "bodyText": "I'll rename it again and update the information about the purpose of this function.", "author": "adamdickmeiss", "createdAt": "2020-09-19T15:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5MDM1NQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491190355", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      return add(dd).compose(x -> Future.succeededFuture(dd));\n          \n          \n            \n                      return add(dd).map(dd);", "author": "julianladisch", "createdAt": "2020-09-18T21:05:15Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));", "originalCommit": "667da414de694fad916f1ecaa95059ba7ae20580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2NTMwMA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491465300", "bodyText": "OK. Should be using map (which I haven't done before , I think)", "author": "adamdickmeiss", "createdAt": "2020-09-19T15:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5MDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5OTcxNA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491199714", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return addAndDeploy0(dd).compose(res -> {\n          \n          \n            \n                  return deploymentStore.insert(res).compose(x -> Future.succeededFuture(res));\n          \n          \n            \n                return addAndDeploy0(dd)\n          \n          \n            \n                    .compose(res -> deploymentStore.insert(res).map(res));", "author": "julianladisch", "createdAt": "2020-09-18T21:31:05Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -113,48 +94,27 @@ public void setModuleManager(ModuleManager mgr) {\n     this.moduleManager = mgr;\n   }\n \n-  void add(DeploymentDescriptor md, Handler<ExtendedAsyncResult<Void>> fut) {\n-    deployments.getKeys(res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n-      CompList<Void> futures = new CompList<>(ErrorType.INTERNAL);\n-      for (String moduleId : res.result()) {\n-        Promise<Void> promise = Promise.promise();\n-        futures.add(promise);\n-        deployments.get(moduleId, md.getInstId(), r -> {\n-          if (r.succeeded()) {\n-            promise.fail(\"dup InstId\");\n-            return;\n+  Future<Void> add(DeploymentDescriptor md) {\n+    return deployments.getKeys().compose(res -> {\n+      Future<Void> future = Future.succeededFuture();\n+      for (String moduleId : res) {\n+        future = future.compose(a -> deployments.get(moduleId, md.getInstId()).compose(b -> {\n+          if (b != null) {\n+            return Future.failedFuture(new OkapiError(ErrorType.USER,\n+                messages.getMessage(\"10809\", md.getInstId())));\n           }\n-          promise.complete();\n-        });\n+          return Future.succeededFuture();\n+        }));\n       }\n-      futures.all(res2 -> {\n-        if (res2.failed()) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10809\", md.getInstId())));\n-          return;\n-        }\n-        deployments.add(md.getSrvcId(), md.getInstId(), md, fut);\n-      });\n+      return future.compose(res2 -> {\n+        return deployments.add(md.getSrvcId(), md.getInstId(), md);\n+      }).mapEmpty();\n     });\n   }\n \n-  void addAndDeploy(DeploymentDescriptor dd,\n-                    Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-    addAndDeploy0(dd, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        deploymentStore.insert(res.result(), res1 -> {\n-          if (res1.failed()) {\n-            fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-          } else {\n-            fut.handle(new Success<>(res.result()));\n-          }\n-        });\n-      }\n+  Future<DeploymentDescriptor> addAndDeploy(DeploymentDescriptor dd) {\n+    return addAndDeploy0(dd).compose(res -> {\n+      return deploymentStore.insert(res).compose(x -> Future.succeededFuture(res));", "originalCommit": "667da414de694fad916f1ecaa95059ba7ae20580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2NTM0Mw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491465343", "bodyText": "ok", "author": "adamdickmeiss", "createdAt": "2020-09-19T15:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5OTcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMzY0NQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491223645", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return getNode(nodeId).compose(nodeDescriptor -> {\n          \n          \n            \n                  String reqData = Json.encode(dd);\n          \n          \n            \n                  Promise<DeploymentDescriptor> promise = Promise.promise();\n          \n          \n            \n                  vertx.eventBus().request(nodeDescriptor.getUrl() + \"/deploy\", reqData,\n          \n          \n            \n                      deliveryOptions).onComplete(ar -> {\n          \n          \n            \n                        if (ar.failed()) {\n          \n          \n            \n                          promise.fail(new OkapiError(ErrorType.USER, ar.cause().getMessage()));\n          \n          \n            \n                        } else {\n          \n          \n            \n                          String b = (String) ar.result().body();\n          \n          \n            \n                          DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n          \n          \n            \n                          promise.complete(pmd);\n          \n          \n            \n                        }\n          \n          \n            \n                      });\n          \n          \n            \n                  return promise.future();\n          \n          \n            \n                return getNode(nodeId)\n          \n          \n            \n                    .flatMap(nodeDescriptor -> {\n          \n          \n            \n                      String url = nodeDescriptor.getUrl() + \"/deploy\";\n          \n          \n            \n                      return vertx.eventBus().request(url, Json.encode(dd), deliveryOptions)\n          \n          \n            \n                          .recover(e -> Future.failedFuture(new OkapiError(ErrorType.USER, e.getMessage())));\n          \n          \n            \n                    })\n          \n          \n            \n                    .map(message -> Json.decodeValue((String) message.body(), DeploymentDescriptor.class));", "author": "julianladisch", "createdAt": "2020-09-18T22:40:37Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));\n         }\n       } else {\n-        fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10803\")));\n+        return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10803\")));\n       }\n     } else {\n       if (launchDesc == null) {\n-        addAndDeploy2(dd, md, fut, nodeId);\n+        return addAndDeploy2(dd, md, nodeId);\n       } else { // Have a launch descriptor already in dd\n-        callDeploy(nodeId, dd, fut);\n+        return callDeploy(nodeId, dd);\n       }\n     }\n   }\n \n-  private void addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut,\n-                             String nodeId) {\n+  private Future<DeploymentDescriptor> addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n+                                                     String nodeId) {\n     String modId = dd.getSrvcId();\n     LaunchDescriptor modLaunchDesc = md.getLaunchDescriptor();\n     if (modLaunchDesc == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10804\", modId)));\n-    } else {\n-      dd.setDescriptor(modLaunchDesc);\n-      callDeploy(nodeId, dd, fut);\n+      return Future.failedFuture(new OkapiError(ErrorType.USER,\n+          messages.getMessage(\"10804\", modId)));\n     }\n+    dd.setDescriptor(modLaunchDesc);\n+    return callDeploy(nodeId, dd);\n   }\n \n   /**\n    * Helper to actually launch (deploy) a module on a node.\n    */\n-  private void callDeploy(String nodeId, DeploymentDescriptor dd,\n-                          Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-\n-    getNode(nodeId, nodeRes -> {\n-      if (nodeRes.failed()) {\n-        fut.handle(new Failure<>(nodeRes.getType(), nodeRes.cause()));\n-      } else {\n-        String reqData = Json.encode(dd);\n-        vertx.eventBus().request(nodeRes.result().getUrl() + \"/deploy\", reqData,\n-            deliveryOptions, ar -> {\n-              if (ar.failed()) {\n-                fut.handle(new Failure<>(ErrorType.USER, ar.cause().getMessage()));\n-              } else {\n-                String b = (String) ar.result().body();\n-                DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n-                fut.handle(new Success<>(pmd));\n-              }\n-            });\n-      }\n+  private Future<DeploymentDescriptor> callDeploy(String nodeId, DeploymentDescriptor dd) {\n+    return getNode(nodeId).compose(nodeDescriptor -> {\n+      String reqData = Json.encode(dd);\n+      Promise<DeploymentDescriptor> promise = Promise.promise();\n+      vertx.eventBus().request(nodeDescriptor.getUrl() + \"/deploy\", reqData,\n+          deliveryOptions).onComplete(ar -> {\n+            if (ar.failed()) {\n+              promise.fail(new OkapiError(ErrorType.USER, ar.cause().getMessage()));\n+            } else {\n+              String b = (String) ar.result().body();\n+              DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n+              promise.complete(pmd);\n+            }\n+          });\n+      return promise.future();", "originalCommit": "667da414de694fad916f1ecaa95059ba7ae20580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2ODczOA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491468738", "bodyText": "neat", "author": "adamdickmeiss", "createdAt": "2020-09-19T16:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTAxOQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491225019", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  futures.add(callUndeploy(dd).compose(res -> {\n          \n          \n            \n                    return deploymentStore.delete(dd.getInstId());\n          \n          \n            \n                  }).mapEmpty());\n          \n          \n            \n                  futures.add(callUndeploy(dd)\n          \n          \n            \n                      .compose(res -> deploymentStore.delete(dd.getInstId()))\n          \n          \n            \n                      .mapEmpty());", "author": "julianladisch", "createdAt": "2020-09-18T22:46:15Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));\n         }\n       } else {\n-        fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10803\")));\n+        return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10803\")));\n       }\n     } else {\n       if (launchDesc == null) {\n-        addAndDeploy2(dd, md, fut, nodeId);\n+        return addAndDeploy2(dd, md, nodeId);\n       } else { // Have a launch descriptor already in dd\n-        callDeploy(nodeId, dd, fut);\n+        return callDeploy(nodeId, dd);\n       }\n     }\n   }\n \n-  private void addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut,\n-                             String nodeId) {\n+  private Future<DeploymentDescriptor> addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n+                                                     String nodeId) {\n     String modId = dd.getSrvcId();\n     LaunchDescriptor modLaunchDesc = md.getLaunchDescriptor();\n     if (modLaunchDesc == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10804\", modId)));\n-    } else {\n-      dd.setDescriptor(modLaunchDesc);\n-      callDeploy(nodeId, dd, fut);\n+      return Future.failedFuture(new OkapiError(ErrorType.USER,\n+          messages.getMessage(\"10804\", modId)));\n     }\n+    dd.setDescriptor(modLaunchDesc);\n+    return callDeploy(nodeId, dd);\n   }\n \n   /**\n    * Helper to actually launch (deploy) a module on a node.\n    */\n-  private void callDeploy(String nodeId, DeploymentDescriptor dd,\n-                          Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-\n-    getNode(nodeId, nodeRes -> {\n-      if (nodeRes.failed()) {\n-        fut.handle(new Failure<>(nodeRes.getType(), nodeRes.cause()));\n-      } else {\n-        String reqData = Json.encode(dd);\n-        vertx.eventBus().request(nodeRes.result().getUrl() + \"/deploy\", reqData,\n-            deliveryOptions, ar -> {\n-              if (ar.failed()) {\n-                fut.handle(new Failure<>(ErrorType.USER, ar.cause().getMessage()));\n-              } else {\n-                String b = (String) ar.result().body();\n-                DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n-                fut.handle(new Success<>(pmd));\n-              }\n-            });\n-      }\n+  private Future<DeploymentDescriptor> callDeploy(String nodeId, DeploymentDescriptor dd) {\n+    return getNode(nodeId).compose(nodeDescriptor -> {\n+      String reqData = Json.encode(dd);\n+      Promise<DeploymentDescriptor> promise = Promise.promise();\n+      vertx.eventBus().request(nodeDescriptor.getUrl() + \"/deploy\", reqData,\n+          deliveryOptions).onComplete(ar -> {\n+            if (ar.failed()) {\n+              promise.fail(new OkapiError(ErrorType.USER, ar.cause().getMessage()));\n+            } else {\n+              String b = (String) ar.result().body();\n+              DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n+              promise.complete(pmd);\n+            }\n+          });\n+      return promise.future();\n     });\n   }\n \n-  void removeAndUndeploy(String srvcId, String instId,\n-                         Handler<ExtendedAsyncResult<Void>> fut) {\n-\n+  Future<Void> removeAndUndeploy(String srvcId, String instId) {\n     logger.info(\"removeAndUndeploy: srvcId {} instId {}\", srvcId, instId);\n-    deployments.get(srvcId, instId, res -> {\n-      if (res.failed()) {\n-        logger.warn(\"deployment.get failed\");\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        List<DeploymentDescriptor> ddList = new LinkedList<>();\n-        ddList.add(res.result());\n-        removeAndUndeploy(ddList, fut);\n-      }\n+    return deployments.getNotFound(srvcId, instId).compose(res -> {\n+      List<DeploymentDescriptor> ddList = new LinkedList<>();\n+      ddList.add(res);\n+      return removeAndUndeploy(ddList);\n     });\n   }\n \n-  void removeAndUndeploy(String srvcId,\n-                         Handler<ExtendedAsyncResult<Void>> fut) {\n-\n+  Future<Void> removeAndUndeploy(String srvcId) {\n     logger.info(\"removeAndUndeploy: srvcId {}\", srvcId);\n-    deployments.get(srvcId, res -> {\n-      if (res.failed()) {\n-        logger.warn(\"deployment.get failed\");\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        removeAndUndeploy(res.result(), fut);\n+    return deployments.get(srvcId).compose(res -> {\n+      if (res == null) {\n+        return Future.failedFuture(new OkapiError(ErrorType.NOT_FOUND, srvcId));\n       }\n+      return removeAndUndeploy(res);\n     });\n   }\n \n-  void removeAndUndeploy(Handler<ExtendedAsyncResult<Void>> fut) {\n+  Future<Void> removeAndUndeploy() {\n     logger.info(\"removeAndUndeploy all\");\n-    this.get(res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        removeAndUndeploy(res.result(), fut);\n-      }\n-    });\n+    return this.get().compose(res -> removeAndUndeploy(res));\n   }\n \n-  private void removeAndUndeploy(List<DeploymentDescriptor> ddList,\n-                                 Handler<ExtendedAsyncResult<Void>> fut) {\n+  private Future<Void> removeAndUndeploy(List<DeploymentDescriptor> ddList) {\n \n-    CompList<List<Void>> futures = new CompList<>(ErrorType.INTERNAL);\n+    List<Future> futures = new LinkedList<>();\n     for (DeploymentDescriptor dd : ddList) {\n-      Promise<Void> promise = Promise.promise();\n       logger.info(\"removeAndUndeploy {} {}\", dd.getSrvcId(), dd.getInstId());\n-      callUndeploy(dd, res -> {\n-        if (res.succeeded()) {\n-          deploymentStore.delete(dd.getInstId(), promise::handle);\n-        } else {\n-          promise.handle(res);\n-        }\n-      });\n-      futures.add(promise);\n+      futures.add(callUndeploy(dd).compose(res -> {\n+        return deploymentStore.delete(dd.getInstId());\n+      }).mapEmpty());", "originalCommit": "667da414de694fad916f1ecaa95059ba7ae20580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2ODc1Mw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491468753", "bodyText": "done", "author": "adamdickmeiss", "createdAt": "2020-09-19T16:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTAxOQ=="}], "type": "inlineReview"}, {"oid": "a3d767ba3a7de4ef07f2fc508611026412fffd48", "url": "https://github.com/folio-org/okapi/commit/a3d767ba3a7de4ef07f2fc508611026412fffd48", "message": "Rename cloneWithoutStatus to cloneLegacy", "committedDate": "2020-09-19T15:33:56Z", "type": "commit"}, {"oid": "2d46a252b8f6a04933e1e7733c42b6ad92619e79", "url": "https://github.com/folio-org/okapi/commit/2d46a252b8f6a04933e1e7733c42b6ad92619e79", "message": "Simplifications as suggested by Julian", "committedDate": "2020-09-19T15:50:04Z", "type": "commit"}, {"oid": "5d80f3d437365801319c15618725083f09c61426", "url": "https://github.com/folio-org/okapi/commit/5d80f3d437365801319c15618725083f09c61426", "message": "More simplifications", "committedDate": "2020-09-19T15:50:21Z", "type": "commit"}, {"oid": "e850ff7fed082d65ea1a70da33a2fc358dcf4dc2", "url": "https://github.com/folio-org/okapi/commit/e850ff7fed082d65ea1a70da33a2fc358dcf4dc2", "message": "start+end date of install job", "committedDate": "2020-09-19T16:25:57Z", "type": "commit"}, {"oid": "db10a7fcf4c39551c2f5969bcebac8897e853e6d", "url": "https://github.com/folio-org/okapi/commit/db10a7fcf4c39551c2f5969bcebac8897e853e6d", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-09-21T21:35:23Z", "type": "commit"}, {"oid": "2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675", "url": "https://github.com/folio-org/okapi/commit/2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-09-22T12:48:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxMDkxOA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493410918", "bodyText": "Should we mention undeploy stage here?", "author": "hjiebsco", "createdAt": "2020-09-23T10:14:46Z", "path": "doc/guide.md", "diffHunk": "@@ -2621,7 +2623,77 @@ the install operation will also deploy and un-deploy as\n necessary. This will only work if the ModuleDescriptor has the\n launchDescriptor property.\n \n-### Purge\n+### Install jobs and asynchronous operations\n+\n+For Okapi 4.2.0 and later, the install operation can be asynchronous.\n+The asynchronous operation is enabled by URI parameter 'async=true'.\n+As for the \"synchronous\" operation, the dependency check is performed\n+first and install/upgrade will return 400 HTTP error upon failure.\n+\n+Following that, the install operation will create an install \"job\" on the\n+server side and return HTTP status 201 along with a location of the newly\n+created install job. The returned JSON content is defined by schema\n+([InstallJob.json](../okapi-core/src/main/raml/InstallJob.json)).\n+\n+This location can then be inspected with HTTP GET for the progress of\n+the install operation. The location is same base URI as install, but\n+with a slash + the job ID. The install job has properties such as\n+\n+ * `complete`: boolean which tells whether the job has completed\n+ * `id`: job id\n+ * `startDate`: start time of job in UTC ISO8601 format.\n+ * `endDate`: end time of job in UTC ISO8601 format (only present when complete)\n+ * `modules`: enable/disable list of modules along with status.\n+\n+Each module entry is defined by schema\n+([TenantModuleDescriptor.json](../okapi-core/src/main/raml/TenantModuleDescriptor.json)).\n+Brief list of properties:\n+\n+ * `id`: module ID\n+ * `from`: old module ID (absent if not upgrading)\n+ * `action`: enable/disable/uptodate\n+ * `stage`: the current stage of the module\n+ * `message`: present upon error (error message)\n+\n+If `message` property is present an error has occurred and `stage`\n+indicates at which stage the error occurred. Stage is one of\n+ * `pending`: module is yet to be upgraded/deployed/etc..\n+ * `deploy`: module is being deployed\n+ * `call`: module is being called via system interface, such as `_tenant`,\n+    `_tenantPermissions`, ..\n+ * `done`: module is fully upgraded", "originalCommit": "2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ3NDQ5NA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493474494", "bodyText": "Yep.\nShould I rename  stage call to in invoke instead? The reason would be that invoke parameter controls whether a module should be invoked/called ..", "author": "adamdickmeiss", "createdAt": "2020-09-23T11:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxMDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTMxNw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493659317", "bodyText": "either call or invoke seems fine to me.", "author": "hjiebsco", "createdAt": "2020-09-23T14:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxMDkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxNDA4OA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493414088", "bodyText": "Maybe just me, Legacy gives me an impression that this method will go away and should not be used. :)", "author": "hjiebsco", "createdAt": "2020-09-23T10:18:32Z", "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Clone an entry with only original tenant module information (Before async install).\n+   * @return entry\n+   */\n+  @JsonIgnore\n+  public TenantModuleDescriptor cloneLegacy() {", "originalCommit": "2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ3NTE1Ng==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493475156", "bodyText": "Fair. It's not going a way. I'll rename it again.", "author": "adamdickmeiss", "createdAt": "2020-09-23T11:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxNDA4OA=="}], "type": "inlineReview"}, {"oid": "615d46801c285bf238d8bfdd3c112f4d65c76796", "url": "https://github.com/folio-org/okapi/commit/615d46801c285bf238d8bfdd3c112f4d65c76796", "message": "Describe undeploy", "committedDate": "2020-09-23T11:35:19Z", "type": "commit"}, {"oid": "8a8acaa3fd6756912be9ae57f9bd9dca8b97bbd0", "url": "https://github.com/folio-org/okapi/commit/8a8acaa3fd6756912be9ae57f9bd9dca8b97bbd0", "message": "Rename cloneLegacy to cloneWithoutStage", "committedDate": "2020-09-23T13:57:52Z", "type": "commit"}, {"oid": "a76b75345e95b928fc7517fe7ae7e1e5ab373108", "url": "https://github.com/folio-org/okapi/commit/a76b75345e95b928fc7517fe7ae7e1e5ab373108", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-09-23T14:54:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY2Njc3Mg==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493666772", "bodyText": "@adamdickmeiss, I asked earlier if we support checking the status of async upgrade? You said yes. But this /upgrade endpoint method does not return location header, so how does the caller know where to track the status?", "author": "hjiebsco", "createdAt": "2020-09-23T15:02:35Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +735,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String tenantId) {\n \n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n-    tenantManager.installUpgradeModules(id, pc, options, null, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-        fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-      }\n-    });\n+    UUID installId = UUID.randomUUID();\n+    return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, null)\n+        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));", "originalCommit": "a76b75345e95b928fc7517fe7ae7e1e5ab373108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY3NDk4MQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493674981", "bodyText": "You are right. I'll fix that (so that it returns location, I mean for async=true).", "author": "adamdickmeiss", "createdAt": "2020-09-23T15:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY2Njc3Mg=="}], "type": "inlineReview"}, {"oid": "c85e2c7162b01c80a5535ffa3c5b8dc5bb0ca85f", "url": "https://github.com/folio-org/okapi/commit/c85e2c7162b01c80a5535ffa3c5b8dc5bb0ca85f", "message": "Upgrade with async option", "committedDate": "2020-09-24T08:26:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxMTEwMQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r494611101", "bodyText": "Technically right. Maybe a little bit counter intuitive. Mentioning this in the guide should help.", "author": "hjiebsco", "createdAt": "2020-09-24T21:07:38Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -766,7 +766,16 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n     UUID installId = UUID.randomUUID();\n     return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, null)\n-        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));\n+        .compose(res -> {\n+          String jsonResponse = Json.encodePrettily(res);\n+          if (options.getAsync()) {\n+            // using same location as install\n+            String baseUri = pc.getCtx().request().uri().replace(\"/upgrade\", \"/install\");\n+            return location(pc, installId.toString(), baseUri, jsonResponse);", "originalCommit": "c85e2c7162b01c80a5535ffa3c5b8dc5bb0ca85f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "666f69421b39d52d86329e1d8c810adecb3d26d5", "url": "https://github.com/folio-org/okapi/commit/666f69421b39d52d86329e1d8c810adecb3d26d5", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-09-25T08:14:44Z", "type": "commit"}, {"oid": "e134ecdb74efe4877077ad81cbed19d42cf482aa", "url": "https://github.com/folio-org/okapi/commit/e134ecdb74efe4877077ad81cbed19d42cf482aa", "message": "Rename stage call -> invoke\n\nMakes more sense since, the invoke paramerter already controls\nwhether Okapi invokes modules at all (system interfaces).", "committedDate": "2020-09-25T08:40:40Z", "type": "commit"}, {"oid": "f422f5c8baf1ce0dc0d8de04034097a9d7d23833", "url": "https://github.com/folio-org/okapi/commit/f422f5c8baf1ce0dc0d8de04034097a9d7d23833", "message": "Jobs are both install+upgrade things", "committedDate": "2020-09-25T08:41:57Z", "type": "commit"}, {"oid": "056ce4a114d55ee9fb5fb6936ff7cdb0561f81a6", "url": "https://github.com/folio-org/okapi/commit/056ce4a114d55ee9fb5fb6936ff7cdb0561f81a6", "message": "Parallel auto deploy", "committedDate": "2020-08-10T10:56:33Z", "type": "commit"}, {"oid": "30d5e08ccd6f1ac05e12e4644b4d214174ae7c55", "url": "https://github.com/folio-org/okapi/commit/30d5e08ccd6f1ac05e12e4644b4d214174ae7c55", "message": "Futurisation work", "committedDate": "2020-08-24T14:20:43Z", "type": "commit"}, {"oid": "5968c8f0358c6c54b1bbd2e17f2723bf7e37026b", "url": "https://github.com/folio-org/okapi/commit/5968c8f0358c6c54b1bbd2e17f2723bf7e37026b", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-08-25T14:23:33Z", "type": "commit"}, {"oid": "145bbaf54b4c6568a7ac8b273bd30c6fdcc7cabb", "url": "https://github.com/folio-org/okapi/commit/145bbaf54b4c6568a7ac8b273bd30c6fdcc7cabb", "message": "Futurisation work", "committedDate": "2020-08-25T16:27:12Z", "type": "commit"}, {"oid": "5ba5faba62f61c72f90a2d6e7e18e1555cd7fb06", "url": "https://github.com/folio-org/okapi/commit/5ba5faba62f61c72f90a2d6e7e18e1555cd7fb06", "message": "Futurisation work", "committedDate": "2020-08-25T17:03:54Z", "type": "commit"}, {"oid": "607b9fb9bd8b80f8a9752f5cf37fa180ec10904f", "url": "https://github.com/folio-org/okapi/commit/607b9fb9bd8b80f8a9752f5cf37fa180ec10904f", "message": "Futurisation work", "committedDate": "2020-08-26T09:08:16Z", "type": "commit"}, {"oid": "a5a3fd8f563fb81be075a8946028afeec3abcfce", "url": "https://github.com/folio-org/okapi/commit/a5a3fd8f563fb81be075a8946028afeec3abcfce", "message": "Futurisation work", "committedDate": "2020-08-26T09:25:23Z", "type": "commit"}, {"oid": "faae563054e42175a78e7624c8437d8be4860890", "url": "https://github.com/folio-org/okapi/commit/faae563054e42175a78e7624c8437d8be4860890", "message": "InstallJob, async option", "committedDate": "2020-08-26T15:24:42Z", "type": "commit"}, {"oid": "701f73e256d963c64d553010f7a771a63800765e", "url": "https://github.com/folio-org/okapi/commit/701f73e256d963c64d553010f7a771a63800765e", "message": "AsyncFactory.create returns Future", "committedDate": "2020-08-27T09:46:25Z", "type": "commit"}, {"oid": "6a09b96ab6e24406fe33c402656443556fd14776", "url": "https://github.com/folio-org/okapi/commit/6a09b96ab6e24406fe33c402656443556fd14776", "message": "addOrReplace returns Future", "committedDate": "2020-08-27T10:23:15Z", "type": "commit"}, {"oid": "dc1d912bb3fc556977573a112cf8dcf923180f67", "url": "https://github.com/folio-org/okapi/commit/dc1d912bb3fc556977573a112cf8dcf923180f67", "message": "Missing Future", "committedDate": "2020-08-27T10:24:44Z", "type": "commit"}, {"oid": "c11ddf1e2d3c7788967dff66976bb173fd68e759", "url": "https://github.com/folio-org/okapi/commit/c11ddf1e2d3c7788967dff66976bb173fd68e759", "message": "LockedTypedMap1 put returns Future", "committedDate": "2020-08-27T10:29:20Z", "type": "commit"}, {"oid": "24e4313c9a64c0f7251b7ada9497bf59182a1a37", "url": "https://github.com/folio-org/okapi/commit/24e4313c9a64c0f7251b7ada9497bf59182a1a37", "message": "First kick of real async install", "committedDate": "2020-08-27T14:59:36Z", "type": "commit"}, {"oid": "dfdaef90306b6daffe0654f2807cc8681e0d639d", "url": "https://github.com/folio-org/okapi/commit/dfdaef90306b6daffe0654f2807cc8681e0d639d", "message": "Fewer args", "committedDate": "2020-08-27T15:25:51Z", "type": "commit"}, {"oid": "ac9422186c5b88a84821a5195988ff5149d2ecb8", "url": "https://github.com/folio-org/okapi/commit/ac9422186c5b88a84821a5195988ff5149d2ecb8", "message": "Unused imports", "committedDate": "2020-08-27T15:26:01Z", "type": "commit"}, {"oid": "11e699cf6b5cddab2662518c4ffd39047999cb48", "url": "https://github.com/folio-org/okapi/commit/11e699cf6b5cddab2662518c4ffd39047999cb48", "message": "Uselogs logs; use Future", "committedDate": "2020-08-27T15:26:39Z", "type": "commit"}, {"oid": "117623ff8d4f2e90683a4f556e32eea43eecfd88", "url": "https://github.com/folio-org/okapi/commit/117623ff8d4f2e90683a4f556e32eea43eecfd88", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-08-27T15:27:11Z", "type": "commit"}, {"oid": "f360ef6f9937adabec3e2874190a06eddf46513a", "url": "https://github.com/folio-org/okapi/commit/f360ef6f9937adabec3e2874190a06eddf46513a", "message": "Futurisation work", "committedDate": "2020-08-28T10:45:30Z", "type": "commit"}, {"oid": "4b1830cbb905a29675b2e0818493df0bf9f8fb71", "url": "https://github.com/folio-org/okapi/commit/4b1830cbb905a29675b2e0818493df0bf9f8fb71", "message": "Futurisation work (DOES NOT PASS)", "committedDate": "2020-08-28T11:32:22Z", "type": "commit"}, {"oid": "423b7b5db188de565119f5c74e62fd67fa5f5b55", "url": "https://github.com/folio-org/okapi/commit/423b7b5db188de565119f5c74e62fd67fa5f5b55", "message": "Futurisation work", "committedDate": "2020-08-28T13:45:46Z", "type": "commit"}, {"oid": "6d890a121e050e5d9628d0b92c122fcd6a874562", "url": "https://github.com/folio-org/okapi/commit/6d890a121e050e5d9628d0b92c122fcd6a874562", "message": "Futurisation work", "committedDate": "2020-08-28T15:07:34Z", "type": "commit"}, {"oid": "3baee55419eb7c5ff505d3d2b7e3f78fe09e8a16", "url": "https://github.com/folio-org/okapi/commit/3baee55419eb7c5ff505d3d2b7e3f78fe09e8a16", "message": "Check tenantId for install GET", "committedDate": "2020-08-28T15:38:55Z", "type": "commit"}, {"oid": "eddfca414c74d8bdeb5b7fb8c885406fc80cb87a", "url": "https://github.com/folio-org/okapi/commit/eddfca414c74d8bdeb5b7fb8c885406fc80cb87a", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-08-31T10:33:30Z", "type": "commit"}, {"oid": "d60ce77d268b35e9e9335a9e80758a9bdbd1f8b0", "url": "https://github.com/folio-org/okapi/commit/d60ce77d268b35e9e9335a9e80758a9bdbd1f8b0", "message": "Futurisation work", "committedDate": "2020-08-31T16:24:24Z", "type": "commit"}, {"oid": "cc5aebd614d90f1729e3a6879c2262f83eacea23", "url": "https://github.com/folio-org/okapi/commit/cc5aebd614d90f1729e3a6879c2262f83eacea23", "message": "Unused imports", "committedDate": "2020-08-31T16:27:32Z", "type": "commit"}, {"oid": "0743f282eee069d5ae84fca0ccb37778d9f3c994", "url": "https://github.com/folio-org/okapi/commit/0743f282eee069d5ae84fca0ccb37778d9f3c994", "message": "Unused import", "committedDate": "2020-08-31T16:39:41Z", "type": "commit"}, {"oid": "0d876967c80607cdd13d57a521df1ca213d5ffe9", "url": "https://github.com/folio-org/okapi/commit/0d876967c80607cdd13d57a521df1ca213d5ffe9", "message": "init method for storage APIs returns Future", "committedDate": "2020-09-01T10:18:46Z", "type": "commit"}, {"oid": "85b4825cc5f7a29e7e16e385f11dac1b2ff048f5", "url": "https://github.com/folio-org/okapi/commit/85b4825cc5f7a29e7e16e385f11dac1b2ff048f5", "message": "Storage interfaces uses Future", "committedDate": "2020-09-01T14:16:59Z", "type": "commit"}, {"oid": "2594fcbbb38eab3f353ed82ce8465f45ff01e6ba", "url": "https://github.com/folio-org/okapi/commit/2594fcbbb38eab3f353ed82ce8465f45ff01e6ba", "message": "Remove redundant log", "committedDate": "2020-09-02T07:47:01Z", "type": "commit"}, {"oid": "e408e0d36d677167dba0b4cf850118f6f5c68172", "url": "https://github.com/folio-org/okapi/commit/e408e0d36d677167dba0b4cf850118f6f5c68172", "message": "Unused imports", "committedDate": "2020-09-02T07:47:09Z", "type": "commit"}, {"oid": "f00466c124062b39d053a26f2e3f64ea0a5ae0eb", "url": "https://github.com/folio-org/okapi/commit/f00466c124062b39d053a26f2e3f64ea0a5ae0eb", "message": "Remove unused ModuleStore.update", "committedDate": "2020-09-02T07:52:36Z", "type": "commit"}, {"oid": "ae490adc9cf15c2f73304e14b844453254679955", "url": "https://github.com/folio-org/okapi/commit/ae490adc9cf15c2f73304e14b844453254679955", "message": "Fix some logs", "committedDate": "2020-09-02T08:25:30Z", "type": "commit"}, {"oid": "34ff8384fd6cefa65f58fff588feb90fefaece75", "url": "https://github.com/folio-org/okapi/commit/34ff8384fd6cefa65f58fff588feb90fefaece75", "message": "Sequental test", "committedDate": "2020-09-02T09:12:41Z", "type": "commit"}, {"oid": "0e45894e87baab92bb169af28fabbc2eb8db84ff", "url": "https://github.com/folio-org/okapi/commit/0e45894e87baab92bb169af28fabbc2eb8db84ff", "message": "Get rid of LockedStringMap.getString with ExtendedAsyncResult", "committedDate": "2020-09-02T09:42:46Z", "type": "commit"}, {"oid": "5538354cdffe2f6aa5facfbeb60041fe462ca3a8", "url": "https://github.com/folio-org/okapi/commit/5538354cdffe2f6aa5facfbeb60041fe462ca3a8", "message": "Get rid of LockedStringMap.getPrefix", "committedDate": "2020-09-02T09:53:41Z", "type": "commit"}, {"oid": "ede1d56c0c03a27c06b5462a22d766547d437883", "url": "https://github.com/folio-org/okapi/commit/ede1d56c0c03a27c06b5462a22d766547d437883", "message": "Get fid of LockedStringMap.getKeys with ExtendedAsyncResult", "committedDate": "2020-09-02T10:24:04Z", "type": "commit"}, {"oid": "604128cf5bdeccbf64e6da4c5ae583eeb10859a0", "url": "https://github.com/folio-org/okapi/commit/604128cf5bdeccbf64e6da4c5ae583eeb10859a0", "message": "Simplify", "committedDate": "2020-09-02T10:41:09Z", "type": "commit"}, {"oid": "1dc52d4643c3db9374c388d0a95c996d45c00ab4", "url": "https://github.com/folio-org/okapi/commit/1dc52d4643c3db9374c388d0a95c996d45c00ab4", "message": "TenantManager.startTimers returns Future", "committedDate": "2020-09-02T10:41:32Z", "type": "commit"}, {"oid": "bc1f3e023510f4ba473ef272042bde52057e0cb0", "url": "https://github.com/folio-org/okapi/commit/bc1f3e023510f4ba473ef272042bde52057e0cb0", "message": "Sandbox for futurisation work - does not pass", "committedDate": "2020-09-02T13:43:09Z", "type": "commit"}, {"oid": "0207d6cafe5bca9057d1e12c9145febc58ba93ac", "url": "https://github.com/folio-org/okapi/commit/0207d6cafe5bca9057d1e12c9145febc58ba93ac", "message": "Fixes", "committedDate": "2020-09-03T11:25:47Z", "type": "commit"}, {"oid": "44038675c8030a7eaac627e6b41e9f62f001ac48", "url": "https://github.com/folio-org/okapi/commit/44038675c8030a7eaac627e6b41e9f62f001ac48", "message": "Partial DeploymentManager", "committedDate": "2020-09-03T11:50:30Z", "type": "commit"}, {"oid": "9b1450069e4a23c364bcb499fbb72aeea16e0681", "url": "https://github.com/folio-org/okapi/commit/9b1450069e4a23c364bcb499fbb72aeea16e0681", "message": "EnvManager uses Future", "committedDate": "2020-09-03T12:34:46Z", "type": "commit"}, {"oid": "0b0dec3a515456d48b184538430be24f5a777c79", "url": "https://github.com/folio-org/okapi/commit/0b0dec3a515456d48b184538430be24f5a777c79", "message": "Further slim-down of String Maps", "committedDate": "2020-09-03T13:30:47Z", "type": "commit"}, {"oid": "5c9162b43db4fff7c95e9db617b35af53e35d747", "url": "https://github.com/folio-org/okapi/commit/5c9162b43db4fff7c95e9db617b35af53e35d747", "message": "Futurisation", "committedDate": "2020-09-03T14:58:18Z", "type": "commit"}, {"oid": "35f3219d921e01452da590464f705b6c973f9076", "url": "https://github.com/folio-org/okapi/commit/35f3219d921e01452da590464f705b6c973f9076", "message": "LockedStringMap converted", "committedDate": "2020-09-03T15:39:02Z", "type": "commit"}, {"oid": "66145e07c5b5bbab2bd25dd59011a9f0a887a133", "url": "https://github.com/folio-org/okapi/commit/66145e07c5b5bbab2bd25dd59011a9f0a887a133", "message": "Passes", "committedDate": "2020-09-03T16:30:09Z", "type": "commit"}, {"oid": "64a97a1c2fb2a345d71a0d0b2345fbc63597a23b", "url": "https://github.com/folio-org/okapi/commit/64a97a1c2fb2a345d71a0d0b2345fbc63597a23b", "message": "Goodbye CompList", "committedDate": "2020-09-03T16:47:20Z", "type": "commit"}, {"oid": "d0d2511770f8d124059f2c3bd61536d9406c5b0c", "url": "https://github.com/folio-org/okapi/commit/d0d2511770f8d124059f2c3bd61536d9406c5b0c", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-804-async-install", "committedDate": "2020-09-03T16:48:21Z", "type": "commit"}, {"oid": "a2756e6f3f49efa760da23cc33778a5e79c140c0", "url": "https://github.com/folio-org/okapi/commit/a2756e6f3f49efa760da23cc33778a5e79c140c0", "message": "Unused import", "committedDate": "2020-09-03T17:23:27Z", "type": "commit"}, {"oid": "edf79aa2a5b32fc098e99446a1cb2ba043b3c358", "url": "https://github.com/folio-org/okapi/commit/edf79aa2a5b32fc098e99446a1cb2ba043b3c358", "message": "Make msg, type final", "committedDate": "2020-09-03T17:23:54Z", "type": "commit"}, {"oid": "4dfc1fef30bc5678845655e2dffcca0368ec84e5", "url": "https://github.com/folio-org/okapi/commit/4dfc1fef30bc5678845655e2dffcca0368ec84e5", "message": "PullManager futurized", "committedDate": "2020-09-03T17:24:09Z", "type": "commit"}, {"oid": "0ded7603ef355ef2bad34be1dbc301ffaec2bcee", "url": "https://github.com/folio-org/okapi/commit/0ded7603ef355ef2bad34be1dbc301ffaec2bcee", "message": "Remove useless test", "committedDate": "2020-09-03T17:28:08Z", "type": "commit"}, {"oid": "c44e0cc6aa6dc49f636ad2a70109f3bde0fd6ca3", "url": "https://github.com/folio-org/okapi/commit/c44e0cc6aa6dc49f636ad2a70109f3bde0fd6ca3", "message": "ModuleManager.createList returns Future", "committedDate": "2020-09-04T08:30:06Z", "type": "commit"}, {"oid": "c3a21f48ee098a704fcbf4c1c71eae4d545fb673", "url": "https://github.com/folio-org/okapi/commit/c3a21f48ee098a704fcbf4c1c71eae4d545fb673", "message": "ModuleManager futurized", "committedDate": "2020-09-04T08:51:42Z", "type": "commit"}, {"oid": "b1fed28d9411f8bd97578736f3570e82cee05ec0", "url": "https://github.com/folio-org/okapi/commit/b1fed28d9411f8bd97578736f3570e82cee05ec0", "message": "Some work on TenantManager", "committedDate": "2020-09-04T09:17:00Z", "type": "commit"}, {"oid": "e1b0e6dc6de0b0a885d44b00129e7628a73fa242", "url": "https://github.com/folio-org/okapi/commit/e1b0e6dc6de0b0a885d44b00129e7628a73fa242", "message": "Rework of tenant interface handling", "committedDate": "2020-09-04T09:55:42Z", "type": "commit"}, {"oid": "d81eed3e245c6cbec6bf16c7c3e47086f4263b82", "url": "https://github.com/folio-org/okapi/commit/d81eed3e245c6cbec6bf16c7c3e47086f4263b82", "message": "Systemcalls, permissions loading refactored", "committedDate": "2020-09-04T10:59:10Z", "type": "commit"}, {"oid": "5e4a437ea7f84724bbd59314e764f3776e23a139", "url": "https://github.com/folio-org/okapi/commit/5e4a437ea7f84724bbd59314e764f3776e23a139", "message": "DepResolution futurized", "committedDate": "2020-09-04T11:23:22Z", "type": "commit"}, {"oid": "8bb048b63a5bdce4da3bdbb52d2c7e1590569d79", "url": "https://github.com/folio-org/okapi/commit/8bb048b63a5bdce4da3bdbb52d2c7e1590569d79", "message": "TenanManager no longer uses ExtendedAsyncResult", "committedDate": "2020-09-04T12:04:18Z", "type": "commit"}, {"oid": "67f0d079f75c6bb22a1303a8c28d16d354c7b887", "url": "https://github.com/folio-org/okapi/commit/67f0d079f75c6bb22a1303a8c28d16d354c7b887", "message": "ProxyService no longer uses ExtendedAsyncResult", "committedDate": "2020-09-04T12:19:45Z", "type": "commit"}, {"oid": "a53881da4782f0320d36920c470ceadaec95a7a5", "url": "https://github.com/folio-org/okapi/commit/a53881da4782f0320d36920c470ceadaec95a7a5", "message": "Unused imports", "committedDate": "2020-09-04T12:32:03Z", "type": "commit"}, {"oid": "be8ee455616d19a802a1139557ec72352d543cfb", "url": "https://github.com/folio-org/okapi/commit/be8ee455616d19a802a1139557ec72352d543cfb", "message": "No longer necessary asyncAssertSuccess for ExtendedAsyncResult", "committedDate": "2020-09-04T12:32:33Z", "type": "commit"}, {"oid": "46fc2eee3c6b7c5feca9d54799ea902740279374", "url": "https://github.com/folio-org/okapi/commit/46fc2eee3c6b7c5feca9d54799ea902740279374", "message": "One stmt in lambda", "committedDate": "2020-09-04T18:03:58Z", "type": "commit"}, {"oid": "005fd4abbe3f826cd3db53f67770a0be91e216b6", "url": "https://github.com/folio-org/okapi/commit/005fd4abbe3f826cd3db53f67770a0be91e216b6", "message": "Use getNotFound", "committedDate": "2020-09-04T18:04:11Z", "type": "commit"}, {"oid": "edcd6bfabcc7a01bc37b84eabbb455d1ff6b292b", "url": "https://github.com/folio-org/okapi/commit/edcd6bfabcc7a01bc37b84eabbb455d1ff6b292b", "message": "Simplify TenantStorePostgres.updateModules", "committedDate": "2020-09-05T07:32:31Z", "type": "commit"}, {"oid": "087b38c27b1d7313d4e7f5a201e17eb715d297ce", "url": "https://github.com/folio-org/okapi/commit/087b38c27b1d7313d4e7f5a201e17eb715d297ce", "message": "Missing return stmts", "committedDate": "2020-09-07T08:51:40Z", "type": "commit"}, {"oid": "6cc72a001dde84bb93f12709f4b4b44fdfffdb63", "url": "https://github.com/folio-org/okapi/commit/6cc72a001dde84bb93f12709f4b4b44fdfffdb63", "message": "TenantModuleDescriptor clone without status", "committedDate": "2020-09-07T09:12:45Z", "type": "commit"}, {"oid": "8f4175602127a0e1080fe16609ae223683ba6545", "url": "https://github.com/folio-org/okapi/commit/8f4175602127a0e1080fe16609ae223683ba6545", "message": "TenantManager.runJob returns Future", "committedDate": "2020-09-07T09:39:45Z", "type": "commit"}, {"oid": "ce4d4b3b0427debd6e225f3bdca5fa959839342f", "url": "https://github.com/folio-org/okapi/commit/ce4d4b3b0427debd6e225f3bdca5fa959839342f", "message": "Refactor out enableAndDisableModuleFut", "committedDate": "2020-09-07T10:12:00Z", "type": "commit"}, {"oid": "31017a4c8fce9decff57a84d2f04b0742809ed9b", "url": "https://github.com/folio-org/okapi/commit/31017a4c8fce9decff57a84d2f04b0742809ed9b", "message": "Test tenant delete", "committedDate": "2020-09-07T10:12:14Z", "type": "commit"}, {"oid": "66a32cf348d9412e10f7f38d260d40fb70de77dc", "url": "https://github.com/folio-org/okapi/commit/66a32cf348d9412e10f7f38d260d40fb70de77dc", "message": "Refactor a few helpers into one", "committedDate": "2020-09-07T10:39:50Z", "type": "commit"}, {"oid": "0380d8befd237766a1d1284315215ddfc1198fd2", "url": "https://github.com/folio-org/okapi/commit/0380d8befd237766a1d1284315215ddfc1198fd2", "message": "Break long line", "committedDate": "2020-09-07T10:54:08Z", "type": "commit"}, {"oid": "e4ae3eeca9b83abea3fcee00ff62f2c3a1ffeec5", "url": "https://github.com/folio-org/okapi/commit/e4ae3eeca9b83abea3fcee00ff62f2c3a1ffeec5", "message": "okapi-core no longer makes direct use of ExtendedAsyncResult", "committedDate": "2020-09-07T14:40:02Z", "type": "commit"}, {"oid": "bea75d782ef4cf91b7ec281a50712212fecf71eb", "url": "https://github.com/folio-org/okapi/commit/bea75d782ef4cf91b7ec281a50712212fecf71eb", "message": "Fix not found message for Install get; set status message for module", "committedDate": "2020-09-09T11:46:51Z", "type": "commit"}, {"oid": "89a8d903d268f8ef0eb54607412136be892799b8", "url": "https://github.com/folio-org/okapi/commit/89a8d903d268f8ef0eb54607412136be892799b8", "message": "ignoreErrors=true OKAPI-845", "committedDate": "2020-09-09T14:16:54Z", "type": "commit"}, {"oid": "c871e58403ffd648614959e64435f779908130ee", "url": "https://github.com/folio-org/okapi/commit/c871e58403ffd648614959e64435f779908130ee", "message": "Break line", "committedDate": "2020-09-09T14:33:57Z", "type": "commit"}, {"oid": "929543765cb0136ce62051d66923050116f9885b", "url": "https://github.com/folio-org/okapi/commit/929543765cb0136ce62051d66923050116f9885b", "message": "Get all install jobs; permission bit", "committedDate": "2020-09-10T08:46:57Z", "type": "commit"}, {"oid": "56593949f7a08f5b2ca74f9a035acca990915814", "url": "https://github.com/folio-org/okapi/commit/56593949f7a08f5b2ca74f9a035acca990915814", "message": "Unused import", "committedDate": "2020-09-10T08:48:04Z", "type": "commit"}, {"oid": "135fde3635fa1983b8866811ab17beb19bfd369d", "url": "https://github.com/folio-org/okapi/commit/135fde3635fa1983b8866811ab17beb19bfd369d", "message": "id part of InstallJob object", "committedDate": "2020-09-10T09:21:46Z", "type": "commit"}, {"oid": "45ed071ed8d7670ae4a98e663b0bb75224861421", "url": "https://github.com/folio-org/okapi/commit/45ed071ed8d7670ae4a98e663b0bb75224861421", "message": "Store date in install job", "committedDate": "2020-09-10T10:13:49Z", "type": "commit"}, {"oid": "e9c617cdaca4fe88183694c82902860b87ce5ca3", "url": "https://github.com/folio-org/okapi/commit/e9c617cdaca4fe88183694c82902860b87ce5ca3", "message": "Unused import", "committedDate": "2020-09-10T10:14:54Z", "type": "commit"}, {"oid": "e49ad0ab53bccc8582679d1b6e91960fb302c004", "url": "https://github.com/folio-org/okapi/commit/e49ad0ab53bccc8582679d1b6e91960fb302c004", "message": "Some documentation", "committedDate": "2020-09-10T12:23:58Z", "type": "commit"}, {"oid": "07422163c4de8975b18f474608f41d3162961cab", "url": "https://github.com/folio-org/okapi/commit/07422163c4de8975b18f474608f41d3162961cab", "message": "Rename status to stage", "committedDate": "2020-09-10T12:46:00Z", "type": "commit"}, {"oid": "9b9e920266bb9677d2a210f1d1242d020783b41e", "url": "https://github.com/folio-org/okapi/commit/9b9e920266bb9677d2a210f1d1242d020783b41e", "message": "More descriptive section names", "committedDate": "2020-09-10T13:25:17Z", "type": "commit"}, {"oid": "83acc1ba758d93258d4ae68701d8160d17c0b568", "url": "https://github.com/folio-org/okapi/commit/83acc1ba758d93258d4ae68701d8160d17c0b568", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-09-11T08:55:55Z", "type": "commit"}, {"oid": "13093b08de7ead39731a2c879fb1b2321a24b532", "url": "https://github.com/folio-org/okapi/commit/13093b08de7ead39731a2c879fb1b2321a24b532", "message": "use NotFound version", "committedDate": "2020-09-11T11:41:45Z", "type": "commit"}, {"oid": "697e65d09fc959f56936fd51dc3a35bd3f469051", "url": "https://github.com/folio-org/okapi/commit/697e65d09fc959f56936fd51dc3a35bd3f469051", "message": "More coverage of LockedStringMap", "committedDate": "2020-09-11T11:42:14Z", "type": "commit"}, {"oid": "154babbca3d4568d349798de664738b7fe92ed52", "url": "https://github.com/folio-org/okapi/commit/154babbca3d4568d349798de664738b7fe92ed52", "message": "Long shot", "committedDate": "2020-09-11T12:00:32Z", "type": "commit"}, {"oid": "8c49ff628fb103563c51317cbd40b9d5c6d0a449", "url": "https://github.com/folio-org/okapi/commit/8c49ff628fb103563c51317cbd40b9d5c6d0a449", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-804-async-install", "committedDate": "2020-09-11T15:29:55Z", "type": "commit"}, {"oid": "07dc1527876b25e2217fcc29fd4839e9ddbcbe98", "url": "https://github.com/folio-org/okapi/commit/07dc1527876b25e2217fcc29fd4839e9ddbcbe98", "message": "Merge branch 'master' into OKAPI-804-async-install", "committedDate": "2020-09-12T08:00:18Z", "type": "commit"}, {"oid": "6bda3ec926d651d69e5a5075a44c7b00867f3c54", "url": "https://github.com/folio-org/okapi/commit/6bda3ec926d651d69e5a5075a44c7b00867f3c54", "message": "Merge branch 'OKAPI-804-async-install' of github.com:folio-org/okapi into OKAPI-804-async-install", "committedDate": "2020-09-14T05:59:06Z", "type": "commit"}, {"oid": "2aa18234cad4be680c6fe9201fc7cf5a1306437f", "url": "https://github.com/folio-org/okapi/commit/2aa18234cad4be680c6fe9201fc7cf5a1306437f", "message": "Wait for map to be initialized; fixes 0 ptr exception", "committedDate": "2020-09-14T06:36:51Z", "type": "commit"}, {"oid": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832", "url": "https://github.com/folio-org/okapi/commit/60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832", "message": "Clean up useless logs", "committedDate": "2020-09-14T06:39:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNTQzOA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489415438", "bodyText": "The default value is missing. We need it to display on https://dev.folio.org/reference/api/#okapi", "author": "julianladisch", "createdAt": "2020-09-16T12:57:40Z", "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false", "originalCommit": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMzM5Mw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489513393", "bodyText": "There's no default for any parameters in the Okapi RAML (but mentioned in the description in places). I'll add it.", "author": "adamdickmeiss", "createdAt": "2020-09-16T15:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNTQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNTY1MQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489415651", "bodyText": "The default value is missing. We need it to display on https://dev.folio.org/reference/api/#okapi", "author": "julianladisch", "createdAt": "2020-09-16T12:58:00Z", "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false\n           deploy:\n             description: Whether to deploy (or undeploy if disabling)\n             type: boolean\n             required: false\n+          ignoreErrors:\n+            description: Whether to ignore module init errors\n+            type: boolean\n+            required: false", "originalCommit": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMzQ1MA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489513450", "bodyText": "OK", "author": "adamdickmeiss", "createdAt": "2020-09-16T15:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxODA0NA==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489418044", "bodyText": "Should be more verbose what \"ignore\" means. The complete explanation that exists in guide.md should be included in the description here to show on the primary documentation site https://dev.folio.org/reference/api/#okapi", "author": "julianladisch", "createdAt": "2020-09-16T13:01:25Z", "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false\n           deploy:\n             description: Whether to deploy (or undeploy if disabling)\n             type: boolean\n             required: false\n+          ignoreErrors:\n+            description: Whether to ignore module init errors", "originalCommit": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzMzM2NQ==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489533365", "bodyText": "The RAML will never include all material from the guide. But I can copy the material for this one if you like.", "author": "adamdickmeiss", "createdAt": "2020-09-16T15:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxODA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxNTQ1Mw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490515453", "bodyText": "Yes, please.", "author": "julianladisch", "createdAt": "2020-09-17T19:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxODA0NA=="}], "type": "inlineReview"}, {"oid": "7b826183331b7dce9faca8143da31af5ea4ef66b", "url": "https://github.com/folio-org/okapi/commit/7b826183331b7dce9faca8143da31af5ea4ef66b", "message": "Add default value for all boolean parameters", "committedDate": "2020-09-16T15:29:57Z", "type": "commit"}, {"oid": "60b7ff1effa5d2ae1ff4c477252b2197ed0459a2", "url": "https://github.com/folio-org/okapi/commit/60b7ff1effa5d2ae1ff4c477252b2197ed0459a2", "message": "Copy description of ignoreErrors from the guide\n\nAnd add them to upgrade as well.", "committedDate": "2020-09-16T15:35:57Z", "type": "commit"}, {"oid": "bf5ab7bfcb9304049cfd2b8b53bba92703464963", "url": "https://github.com/folio-org/okapi/commit/bf5ab7bfcb9304049cfd2b8b53bba92703464963", "message": "One more compose", "committedDate": "2020-09-17T14:13:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwMzkzNg==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490303936", "bodyText": "Did you intentionally re-use this permission?", "author": "craigmcnally", "createdAt": "2020-09-17T14:41:41Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -256,11 +254,21 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.upgrade.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"\n+        + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.get\\\" ], \"\n+        + \"    \\\"type\\\" : \\\"internal\\\" \"\n+        + \"   }, {\"\n         + \"    \\\"methods\\\" :  [ \\\"POST\\\" ],\"\n         + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install/{installId}\\\",\"\n+        + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.get\\\" ], \"", "originalCommit": "bf5ab7bfcb9304049cfd2b8b53bba92703464963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NjM1Mw==", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490476353", "bodyText": "yes. But I can see that in other cases, we have used suffix \".list\" for \"get all\". I'll do that. Hope that's ok.", "author": "adamdickmeiss", "createdAt": "2020-09-17T18:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwMzkzNg=="}], "type": "inlineReview"}]}