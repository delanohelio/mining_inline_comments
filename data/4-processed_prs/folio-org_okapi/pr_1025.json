{"pr_number": 1025, "pr_title": "Okapi 916 match path using hash", "pr_createdAt": "2020-10-29T18:22:38Z", "pr_url": "https://github.com/folio-org/okapi/pull/1025", "timeline": [{"oid": "a7c160ab271941c41fb72920ad214895a9741654", "url": "https://github.com/folio-org/okapi/commit/a7c160ab271941c41fb72920ad214895a9741654", "message": "Whitespace", "committedDate": "2020-10-29T17:40:53Z", "type": "commit"}, {"oid": "223a35584edfa0e8807ccfef4f330011349f94d0", "url": "https://github.com/folio-org/okapi/commit/223a35584edfa0e8807ccfef4f330011349f94d0", "message": "Useless messages", "committedDate": "2020-10-29T17:41:05Z", "type": "commit"}, {"oid": "41b4df8a911c929a0db08f1eac6d4ac3ed51189f", "url": "https://github.com/folio-org/okapi/commit/41b4df8a911c929a0db08f1eac6d4ac3ed51189f", "message": "Might as well be static", "committedDate": "2020-10-29T17:41:15Z", "type": "commit"}, {"oid": "0ad8d47fc22d2d1cedd537291232165075c037b0", "url": "https://github.com/folio-org/okapi/commit/0ad8d47fc22d2d1cedd537291232165075c037b0", "message": "Two more static; fix npr for no module token returned by auth", "committedDate": "2020-10-29T17:42:17Z", "type": "commit"}, {"oid": "42f9510af093d3f77aa237a3582a5406ca69b049", "url": "https://github.com/folio-org/okapi/commit/42f9510af093d3f77aa237a3582a5406ca69b049", "message": "Log cause when job fails", "committedDate": "2020-10-29T17:42:32Z", "type": "commit"}, {"oid": "64ed6c09275c61d07cf2b2319a49bee4dd7a9a2c", "url": "https://github.com/folio-org/okapi/commit/64ed6c09275c61d07cf2b2319a49bee4dd7a9a2c", "message": "Deploy 104 modules and test paths", "committedDate": "2020-10-29T17:45:08Z", "type": "commit"}, {"oid": "1202237036481422d29de951632d3d5bf8a64f0a", "url": "https://github.com/folio-org/okapi/commit/1202237036481422d29de951632d3d5bf8a64f0a", "message": "Allow ProxyTest to use Metrics", "committedDate": "2020-10-30T14:44:42Z", "type": "commit"}, {"oid": "41e7c4626897fab465953f7a4d5d2373edae4c35", "url": "https://github.com/folio-org/okapi/commit/41e7c4626897fab465953f7a4d5d2373edae4c35", "message": "ModuleCache with lookup in progress", "committedDate": "2020-10-30T14:54:40Z", "type": "commit"}, {"oid": "a75d339b7b573e6da328a20daa16dc73293e33f4", "url": "https://github.com/folio-org/okapi/commit/a75d339b7b573e6da328a20daa16dc73293e33f4", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-916-match-path-using-hash", "committedDate": "2020-10-30T14:55:28Z", "type": "commit"}, {"oid": "89c4e099dfdaf9c8e490ad2ec623490e97bdeff3", "url": "https://github.com/folio-org/okapi/commit/89c4e099dfdaf9c8e490ad2ec623490e97bdeff3", "message": "Tests for ModuleCache", "committedDate": "2020-10-31T14:38:48Z", "type": "commit"}, {"oid": "dfb2ace8a9f2ff1fce85e93e76d3ec395553ce49", "url": "https://github.com/folio-org/okapi/commit/dfb2ace8a9f2ff1fce85e93e76d3ec395553ce49", "message": "ModuleCacheEntry; more testing", "committedDate": "2020-11-01T09:41:40Z", "type": "commit"}, {"oid": "0e1fc5509ce35053b3e5c140883c9a49bd5d69a8", "url": "https://github.com/folio-org/okapi/commit/0e1fc5509ce35053b3e5c140883c9a49bd5d69a8", "message": "Consider id for multi entries", "committedDate": "2020-11-02T09:43:46Z", "type": "commit"}, {"oid": "c90da2b311c556a7e27d4b0ecb014b6d6fee1dfe", "url": "https://github.com/folio-org/okapi/commit/c90da2b311c556a7e27d4b0ecb014b6d6fee1dfe", "message": "ModuleCache in use\n\nEntries of ype redirect not handled (ProxyTest.testRedirect ignored).", "committedDate": "2020-11-02T16:00:28Z", "type": "commit"}, {"oid": "147c4e1c7aff661080a6344ee7356536f4ef21b7", "url": "https://github.com/folio-org/okapi/commit/147c4e1c7aff661080a6344ee7356536f4ef21b7", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-916-match-path-using-hash", "committedDate": "2020-11-02T17:04:25Z", "type": "commit"}, {"oid": "385bcda208ffc15903594f57c639c6b0da4d85c8", "url": "https://github.com/folio-org/okapi/commit/385bcda208ffc15903594f57c639c6b0da4d85c8", "message": "Handling redirect; ModuleManager wo TenantManager", "committedDate": "2020-11-03T10:27:17Z", "type": "commit"}, {"oid": "a71c8a2b23f8100398929b1fbef7544b08cfd8f4", "url": "https://github.com/folio-org/okapi/commit/a71c8a2b23f8100398929b1fbef7544b08cfd8f4", "message": "Add ModuleUtilTest", "committedDate": "2020-11-03T11:09:04Z", "type": "commit"}, {"oid": "648bdca223fbca754c593fb18c637a074fe3e383", "url": "https://github.com/folio-org/okapi/commit/648bdca223fbca754c593fb18c637a074fe3e383", "message": "Test ModuleCache.getPatternPrefix separately", "committedDate": "2020-11-03T11:31:19Z", "type": "commit"}, {"oid": "1c2f610492a93f8ae24e9c4d5be71a6a3c4630e7", "url": "https://github.com/folio-org/okapi/commit/1c2f610492a93f8ae24e9c4d5be71a6a3c4630e7", "message": "Per tenant module cache updates\n\nTenant removal clears ModuleCache. Tenant updates during start up\nalso updates ModuleCache.", "committedDate": "2020-11-03T11:52:25Z", "type": "commit"}, {"oid": "e8aed2ba8156894efbfbcd6bbed02f1f399fb56a", "url": "https://github.com/folio-org/okapi/commit/e8aed2ba8156894efbfbcd6bbed02f1f399fb56a", "message": "Remove log info msg", "committedDate": "2020-11-03T12:20:18Z", "type": "commit"}, {"oid": "a42c5ecdadc8bd46f41fccaefd173c8e56381cd6", "url": "https://github.com/folio-org/okapi/commit/a42c5ecdadc8bd46f41fccaefd173c8e56381cd6", "message": "ModuleUtilTest SQ recommendations", "committedDate": "2020-11-03T12:25:36Z", "type": "commit"}, {"oid": "87b2f2974c22a3156338534560d49503cb555cc6", "url": "https://github.com/folio-org/okapi/commit/87b2f2974c22a3156338534560d49503cb555cc6", "message": "Metrics for ProxyService.getModulesForRequest again", "committedDate": "2020-11-03T13:44:00Z", "type": "commit"}, {"oid": "5cdb1be41fcfb37ce5e40519f3e864dca9adf35d", "url": "https://github.com/folio-org/okapi/commit/5cdb1be41fcfb37ce5e40519f3e864dca9adf35d", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-916-match-path-using-hash", "committedDate": "2020-11-03T13:44:42Z", "type": "commit"}, {"oid": "b6ad676506323184056b912d75d07985e0adead4", "url": "https://github.com/folio-org/okapi/commit/b6ad676506323184056b912d75d07985e0adead4", "message": "Delete module woes\n\nDelete module has always returned 404 on not found; but the RAML\ndidn't say so.", "committedDate": "2020-11-03T14:38:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMjUzOA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r516822538", "bodyText": "This should be replaced by\nreturn Future.succeededFuture(enabledModulesCache.computeIfAbsent(tenant.getId(), key -> new ModuleCache(new LinkedList<>())));", "author": "julianladisch", "createdAt": "2020-11-03T17:04:42Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -1044,6 +1085,68 @@ private ModuleInstance getTenantInstanceForInterface(\n     });\n   }\n \n+  /**\n+   * Get module cache for tenant.\n+   * @param tenant Tenant\n+   * @return Module Cache\n+   */\n+  public Future<ModuleCache> getModuleCache(Tenant tenant) {\n+    if (!enabledModulesCache.containsKey(tenant.getId())) {\n+      return Future.succeededFuture(new ModuleCache(new LinkedList<>()));\n+    }\n+    return Future.succeededFuture(enabledModulesCache.get(tenant.getId()));\n+  }", "originalCommit": "b6ad676506323184056b912d75d07985e0adead4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk0MDc0Nw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r516940747", "bodyText": "More elegant indeed.", "author": "adamdickmeiss", "createdAt": "2020-11-03T20:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMjUzOA=="}], "type": "inlineReview"}, {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72", "url": "https://github.com/folio-org/okapi/commit/3cc3fcd6a99e03d0a644a984067083fdc4f20e72", "message": "Merge branch 'master' into OKAPI-916-match-path-using-hash", "committedDate": "2020-11-04T07:34:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4OTI5Nw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517189297", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));\n          \n          \n            \n                      return moduleManager.delete(id).map(\"\");", "author": "julianladisch", "createdAt": "2020-11-04T09:02:15Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -904,7 +904,14 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n   }\n \n   private Future<String> deleteModule(String id) {\n-    return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));\n+    return tenantManager.getModuleUser(id)\n+        .compose(tenants -> {\n+          if (!tenants.isEmpty()) {\n+            return Future.failedFuture(new OkapiError(ErrorType.USER,\n+                messages.getMessage(\"10206\", id, tenants.get(0))));\n+          }\n+          return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));", "originalCommit": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5OTYwNw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517299607", "bodyText": "ok", "author": "adamdickmeiss", "createdAt": "2020-11-04T12:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4OTI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5NTY5MA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517195690", "bodyText": ".onComplete(cacheRes -> {\n  if (cacheRes.failed()) {\n    FAILUREBLOCK\n    return;\n  }\n  ModuleCache cache = cacheRes.result();\n  SUCCESSBLOCK\n});\n\nshould be replaced by\n.onFailure(cause -> {\n  FAILUREBLOCK\n}).onSuccess(cache -> {\n  SUCCESSBLOCK\n});", "author": "julianladisch", "createdAt": "2020-11-04T09:13:01Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -664,16 +560,16 @@ public void proxy(RoutingContext ctx) {\n         pc.responseError(400, messages.getMessage(\"10106\", tenantId));\n         return;\n       }\n-      Tenant tenant = gres.result();\n-      moduleManager.getEnabledModules(tenant).onComplete(mres -> {\n-        if (mres.failed()) {\n+      tenantManager.getModuleCache(gres.result()).onComplete(cacheRes -> {\n+        if (cacheRes.failed()) {", "originalCommit": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5OTY2Mg==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517299662", "bodyText": "ok", "author": "adamdickmeiss", "createdAt": "2020-11-04T12:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5NTY5MA=="}], "type": "inlineReview"}, {"oid": "4c54c3f68d6d4faaf9d13d5bf0f71db6a166a9d8", "url": "https://github.com/folio-org/okapi/commit/4c54c3f68d6d4faaf9d13d5bf0f71db6a166a9d8", "message": "map", "committedDate": "2020-11-04T11:39:02Z", "type": "commit"}, {"oid": "ce0eef4e2a42c62f152aca29968ace24c4109ce2", "url": "https://github.com/folio-org/okapi/commit/ce0eef4e2a42c62f152aca29968ace24c4109ce2", "message": "Refactor to use on{Failure,Success} rather than onComplete", "committedDate": "2020-11-04T11:39:33Z", "type": "commit"}, {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162", "url": "https://github.com/folio-org/okapi/commit/5e231f3db75a49c0062a339bebb7b1544e00a162", "message": "efactor to use on{Failure,Success} rather than onComplete 2", "committedDate": "2020-11-04T12:18:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzMTM0Mg==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517331342", "bodyText": "Can you extract this duplicated code into some method, for example assertEmptyReport(RestAssuredClient c)?", "author": "julianladisch", "createdAt": "2020-11-04T13:11:07Z", "path": "okapi-core/src/test/java/org/folio/okapi/ModuleTest.java", "diffHunk": "@@ -625,10 +625,22 @@ public void testFilters(TestContext context) {\n \n     // Clean up (in reverse order)\n     logger.debug(\"testFilters starting to clean up\");\n-    given().delete(locPostEnable).then().log().ifValidationFails().statusCode(204);\n-    given().delete(locationPostDeployment).then().log().ifValidationFails().statusCode(204);\n+    c = api.createRestAssured3();\n+    c.given().delete(locPostEnable).then().log().ifValidationFails().statusCode(204);\n+    Assert.assertTrue(\"raml: \" + c.getLastReport().toString(),\n+        c.getLastReport().isEmpty());", "originalCommit": "5e231f3db75a49c0062a339bebb7b1544e00a162", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MzI1OQ==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517353259", "bodyText": "ok (in use in other tests, though, so could also move it to a test util).", "author": "adamdickmeiss", "createdAt": "2020-11-04T13:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzMTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNDk0Nw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517334947", "bodyText": "You can directly provide an empty string when you use CsvSource' quoting:\n\"{id}, ''\"", "author": "julianladisch", "createdAt": "2020-11-04T13:17:19Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }", "originalCommit": "5e231f3db75a49c0062a339bebb7b1544e00a162", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjE5OA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517342198", "bodyText": "ok", "author": "adamdickmeiss", "createdAt": "2020-11-04T13:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNDk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTU4Nw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517335587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void testGetPatternPrefix(ArgumentsAccessor accessor) {\n          \n          \n            \n              void testGetPatternPrefix(String pathPattern, String expect) {", "author": "julianladisch", "createdAt": "2020-11-04T13:18:27Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {", "originalCommit": "5e231f3db75a49c0062a339bebb7b1544e00a162", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI3MA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517342270", "bodyText": "ok", "author": "adamdickmeiss", "createdAt": "2020-11-04T13:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTEyOA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517351128", "bodyText": "Is this supposed to be onSuccess or onComplete? Do you want checkSuperTenant always be done?", "author": "hjiebsco", "createdAt": "2020-11-04T13:43:14Z", "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -253,78 +250,71 @@ public void start(Promise<Void> promise) {\n     final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion);\n     final String okapiModule = md.getId();\n     final String interfaceVersion = md.getProvides()[0].getVersion();\n-    moduleManager.get(okapiModule).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.debug(\"checkInternalModules: Already have {} \"\n-            + \" with interface version {}\", okapiModule, interfaceVersion);\n-        // See Okapi-359 about version checks across the cluster\n-        checkSuperTenant(okapiModule, promise);\n-        return;\n-      }\n-      if (OkapiError.getType(gres.cause()) != ErrorType.NOT_FOUND) {\n-        promise.fail(gres.cause()); // something went badly wrong\n+    moduleManager.get(okapiModule).onSuccess(gres -> {\n+      // we already have one, go on\n+      logger.debug(\"checkInternalModules: Already have {} \"\n+          + \" with interface version {}\", okapiModule, interfaceVersion);\n+      // See Okapi-359 about version checks across the cluster\n+      checkSuperTenant(okapiModule, promise);\n+    }).onFailure(cause -> {\n+      if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) {\n+        promise.fail(cause); // something went badly wrong\n         return;\n       }\n       logger.debug(\"Creating the internal Okapi module {} with interface version {}\",\n           okapiModule, interfaceVersion);\n-      moduleManager.create(md, true, true, true).onComplete(ires -> {\n-        if (ires.failed()) {\n-          promise.fail(ires.cause()); // something went badly wrong\n-          return;\n-        }\n+      moduleManager.create(md, true, true, true).onFailure(cause1 ->\n+          promise.fail(cause1) // something went badly wrong\n+      ).onComplete(ires -> {", "originalCommit": "5e231f3db75a49c0062a339bebb7b1544e00a162", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NzE0Ng==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517357146", "bodyText": "It should be onSuccess  (and that was the existing behavior).", "author": "adamdickmeiss", "createdAt": "2020-11-04T13:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTEyOA=="}], "type": "inlineReview"}, {"oid": "c163b7873bd39612c79bcc35ee0732a71bbc08c3", "url": "https://github.com/folio-org/okapi/commit/c163b7873bd39612c79bcc35ee0732a71bbc08c3", "message": "assertEmptyReport", "committedDate": "2020-11-04T13:49:18Z", "type": "commit"}, {"oid": "b9f1540bf3939b848a933217e32345ad9600ec89", "url": "https://github.com/folio-org/okapi/commit/b9f1540bf3939b848a933217e32345ad9600ec89", "message": "Simplify test", "committedDate": "2020-11-04T13:49:33Z", "type": "commit"}, {"oid": "aa6594a1fe961147d351b6695b8356397ca68122", "url": "https://github.com/folio-org/okapi/commit/aa6594a1fe961147d351b6695b8356397ca68122", "message": "Was supposed to be onSucccess", "committedDate": "2020-11-04T13:51:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1ODAxOQ==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517358019", "bodyText": "Looks like this method is not used anymore.", "author": "hjiebsco", "createdAt": "2020-11-04T13:53:49Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -132,62 +133,13 @@ private void makeTraceHeader(ModuleInstance mi, int statusCode,\n     pc.logResponse(mi.getModuleDescriptor().getId(), url, statusCode);\n   }\n \n-  private boolean match(RoutingEntry e, HttpServerRequest req) {\n+  private static boolean match(RoutingEntry e, HttpServerRequest req) {", "originalCommit": "5e231f3db75a49c0062a339bebb7b1544e00a162", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MTcwMg==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517361702", "bodyText": "Right", "author": "adamdickmeiss", "createdAt": "2020-11-04T13:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1ODAxOQ=="}], "type": "inlineReview"}, {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c", "url": "https://github.com/folio-org/okapi/commit/9d3a75fb829a43f31e4f92cff99f320bafe5004c", "message": "Remove unused ProxyService.match", "committedDate": "2020-11-04T14:00:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDM5NQ==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517364395", "bodyText": "If you have\nFunction<ModuleInstance, RoutingEntry> routingEntry = ModuleInstance::getRoutingEntry;\n\nyou can reduce the two lines to a one-liner:\nassertThat(instances).extracting(routingEntry).containsExactly(routingEntry1);", "author": "julianladisch", "createdAt": "2020-11-04T14:02:59Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);", "originalCommit": "5e231f3db75a49c0062a339bebb7b1544e00a162", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MjA2Ng==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517372066", "bodyText": "ok.. I can tell you.. You'll be able to find many constructs  - for example in ModuleTest - that could be simplified.", "author": "adamdickmeiss", "createdAt": "2020-11-04T14:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5ODkyNA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517398924", "bodyText": "Thanks, more readable now.", "author": "julianladisch", "createdAt": "2020-11-04T14:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODM4Mw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517378383", "bodyText": "assertThat is missing", "author": "julianladisch", "createdAt": "2020-11-04T14:21:52Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id}, ''\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(String pathPattern, String expect) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(pathPattern);\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.PUT, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b/\", HttpMethod.GET, map, true, null)).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b/id/c\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry3);\n+\n+    instances = ModuleCache.lookup(\"/p/id/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry4);\n+\n+    ModuleCache.lookup(\"/p/id/z\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id/y/z\", HttpMethod.GET, map, true, null).isEmpty();", "originalCommit": "9d3a75fb829a43f31e4f92cff99f320bafe5004c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5NDMxMw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517394313", "bodyText": "yep. Corrected.", "author": "adamdickmeiss", "createdAt": "2020-11-04T14:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODczOA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517378738", "bodyText": "assertThat is missing", "author": "julianladisch", "createdAt": "2020-11-04T14:22:20Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id}, ''\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(String pathPattern, String expect) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(pathPattern);\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.PUT, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b/\", HttpMethod.GET, map, true, null)).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b/id/c\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry3);\n+\n+    instances = ModuleCache.lookup(\"/p/id/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry4);\n+\n+    ModuleCache.lookup(\"/p/id/z\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id/y/z\", HttpMethod.GET, map, true, null).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/perms/users\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    instances = ModuleCache.lookup(\"/perms/users/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    instances = ModuleCache.lookup(\"/perms/users1\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    ModuleCache.lookup(\"/perms/user\", HttpMethod.GET, map, true, null).isEmpty();", "originalCommit": "9d3a75fb829a43f31e4f92cff99f320bafe5004c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM4MTY0NQ==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517381645", "bodyText": "good catch", "author": "adamdickmeiss", "createdAt": "2020-11-04T14:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODczOA=="}], "type": "inlineReview"}, {"oid": "a10a105ab55b5afc5ff07aaf25aa3d5710791b63", "url": "https://github.com/folio-org/okapi/commit/a10a105ab55b5afc5ff07aaf25aa3d5710791b63", "message": "Simplify instance list assertions", "committedDate": "2020-11-04T14:24:51Z", "type": "commit"}, {"oid": "7ccea4e1e7b1e873ae877fc0ce0d00471ad6b436", "url": "https://github.com/folio-org/okapi/commit/7ccea4e1e7b1e873ae877fc0ce0d00471ad6b436", "message": "Missing assertThat", "committedDate": "2020-11-04T14:26:06Z", "type": "commit"}, {"oid": "eec483352002704e4c720ce3eda6e5b0abf59745", "url": "https://github.com/folio-org/okapi/commit/eec483352002704e4c720ce3eda6e5b0abf59745", "message": "Missing assertThat 2", "committedDate": "2020-11-04T14:31:01Z", "type": "commit"}, {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda", "url": "https://github.com/folio-org/okapi/commit/5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda", "message": "Use StandardCharsets.UTF_8 and avoid exception handling", "committedDate": "2020-11-04T14:45:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzgxMg==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517417812", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int index = 0;\n          \n          \n            \n                while (index < pathPattern.length()) {\n          \n          \n            \n                  if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n          \n          \n            \n                    while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n          \n          \n            \n                      --index;\n          \n          \n            \n                    }\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  index++;\n          \n          \n            \n                }\n          \n          \n            \n                return pathPattern.substring(0, index);\n          \n          \n            \n                int lastSlash = 0;\n          \n          \n            \n                for (int i = 0; i < pathPattern.length(); i++) {\n          \n          \n            \n                  switch (pathPattern.charAt(i)) {\n          \n          \n            \n                    case '*':\n          \n          \n            \n                    case '{':\n          \n          \n            \n                      return pathPattern.substring(0, lastSlash);\n          \n          \n            \n                    case '/':\n          \n          \n            \n                      lastSlash = i + 1;\n          \n          \n            \n                      break;\n          \n          \n            \n                    default:\n          \n          \n            \n                      break;\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                return pathPattern;", "author": "julianladisch", "createdAt": "2020-11-04T15:15:21Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int index = 0;\n+    while (index < pathPattern.length()) {\n+      if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n+        while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n+          --index;\n+        }\n+        break;\n+      }\n+      index++;\n+    }\n+    return pathPattern.substring(0, index);", "originalCommit": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2MDAzMw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517460033", "bodyText": "Ok. A little more lines, but perhaps more readable. In particular it avoids substring when there's no masking.", "author": "adamdickmeiss", "createdAt": "2020-11-04T16:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0MDQyNw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517440427", "bodyText": "We can use lastIndexOf:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  int index = tryUri.length() - 1;\n          \n          \n            \n                  while (index > 0 && tryUri.charAt(index - 1) != '/') {\n          \n          \n            \n                    --index;\n          \n          \n            \n                  }\n          \n          \n            \n                  if (index <= 0) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  tryUri = tryUri.substring(0, index);\n          \n          \n            \n                  int index = tryUri.lastIndexOf('/', tryUri.length() - 2);\n          \n          \n            \n                  if (index < 0) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  tryUri = tryUri.substring(0, index + 1);", "author": "julianladisch", "createdAt": "2020-11-04T15:46:05Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int index = 0;\n+    while (index < pathPattern.length()) {\n+      if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n+        while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n+          --index;\n+        }\n+        break;\n+      }\n+      index++;\n+    }\n+    return pathPattern.substring(0, index);\n+  }\n+\n+  static void add(ModuleDescriptor moduleDescriptor, Map<String, List<ModuleCacheEntry>> map,\n+                  List<RoutingEntry> entries) {\n+    for (RoutingEntry routingEntry : entries) {\n+      String prefix = getPatternPrefix(routingEntry);\n+      List<ModuleCacheEntry> list = map.get(prefix);\n+      if (list == null) {\n+        list = new LinkedList<>();\n+        map.put(prefix, list);\n+      }\n+      list.add(new ModuleCacheEntry(moduleDescriptor, routingEntry));\n+    }\n+  }\n+\n+  private void add(ModuleDescriptor moduleDescriptor) {\n+    add(moduleDescriptor, proxyMap, moduleDescriptor.getProxyRoutingEntries());\n+    add(moduleDescriptor, multiMap, moduleDescriptor.getMultiRoutingEntries());\n+    add(moduleDescriptor, filterMap, moduleDescriptor.getFilterRoutingEntries());\n+  }\n+\n+  private void resolveRedirect(List<ModuleInstance> instances, RoutingEntry re, String loop,\n+                               Set<RoutingEntry> routingEntries,\n+                               HttpMethod method, String uri) {\n+    if (re.getProxyType() != RoutingEntry.ProxyType.REDIRECT) {\n+      return;\n+    }\n+    logger.debug(\"resolveRedirect begin redirectPath={}\", re.getRedirectPath());\n+    boolean found = false;\n+    final String redirectPath = re.getRedirectPath();\n+\n+    List<ModuleInstance> lookup = lookup(redirectPath, method, filterMap, false, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, false);\n+        instances.add(mi);\n+        resolveRedirect(instances, tryre, loop + \" -> \" + redirectPath, routingEntries,\n+            method, redirectUri);\n+      } else {\n+        throw new IllegalArgumentException(messages.getMessage(\"10100\", loop, redirectPath));\n+      }\n+    }\n+    lookup = lookup(redirectPath, method, proxyMap, true, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, true);\n+        instances.add(mi);\n+      }\n+    }\n+    logger.debug(\"resolveRedirect end redirectPath={} found={}\", re.getRedirectPath(), found);\n+    if (!found) {\n+      throw new IllegalArgumentException(messages.getMessage(\"10101\", uri, redirectPath));\n+    }\n+  }\n+\n+  static List<ModuleInstance> lookup(String uri, HttpMethod method, Map<String,\n+      List<ModuleCacheEntry>> map, boolean handler, String id) {\n+    List<ModuleInstance> instances = new LinkedList<>();\n+    String tryUri = uri;\n+    for (int index = 0; index < uri.length(); index++) {\n+      if (uri.charAt(index) == '#' || uri.charAt(index) == '?') {\n+        tryUri = tryUri.substring(0, index);\n+        break;\n+      }\n+    }\n+    while (true) {\n+      List<ModuleCacheEntry> candidateInstances = map.get(tryUri);\n+      if (candidateInstances != null) {\n+        for (ModuleCacheEntry candiate : candidateInstances) {\n+          if (candiate.routingEntry.match(uri, method.name())\n+              && (id == null || id.equals(candiate.moduleDescriptor.getId()))) {\n+            instances.add(new ModuleInstance(candiate.moduleDescriptor,\n+                candiate.routingEntry, uri, method, handler));\n+            if (handler) {\n+              return instances;\n+            }\n+          }\n+        }\n+      }\n+      int index = tryUri.length() - 1;\n+      while (index > 0 && tryUri.charAt(index - 1) != '/') {\n+        --index;\n+      }\n+      if (index <= 0) {\n+        break;\n+      }\n+      tryUri = tryUri.substring(0, index);", "originalCommit": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2MzA1NQ==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517463055", "bodyText": "Definitely shorter.", "author": "adamdickmeiss", "createdAt": "2020-11-04T16:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0MDQyNw=="}], "type": "inlineReview"}, {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34", "url": "https://github.com/folio-org/okapi/commit/290e3ba0211f27b6b3a72d9912640193b2e75c34", "message": "Two simplifications for working with uris", "committedDate": "2020-11-04T16:17:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MjA1Mg==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517472052", "bodyText": "This PR did not change this part, but I am wondering if we should consider downgrade Okapi version for superteant so it matches the actual running version?", "author": "hjiebsco", "createdAt": "2020-11-04T16:29:20Z", "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -253,78 +250,71 @@ public void start(Promise<Void> promise) {\n     final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion);\n     final String okapiModule = md.getId();\n     final String interfaceVersion = md.getProvides()[0].getVersion();\n-    moduleManager.get(okapiModule).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.debug(\"checkInternalModules: Already have {} \"\n-            + \" with interface version {}\", okapiModule, interfaceVersion);\n-        // See Okapi-359 about version checks across the cluster\n-        checkSuperTenant(okapiModule, promise);\n-        return;\n-      }\n-      if (OkapiError.getType(gres.cause()) != ErrorType.NOT_FOUND) {\n-        promise.fail(gres.cause()); // something went badly wrong\n+    moduleManager.get(okapiModule).onSuccess(gres -> {\n+      // we already have one, go on\n+      logger.debug(\"checkInternalModules: Already have {} \"\n+          + \" with interface version {}\", okapiModule, interfaceVersion);\n+      // See Okapi-359 about version checks across the cluster\n+      checkSuperTenant(okapiModule, promise);\n+    }).onFailure(cause -> {\n+      if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) {\n+        promise.fail(cause); // something went badly wrong\n         return;\n       }\n       logger.debug(\"Creating the internal Okapi module {} with interface version {}\",\n           okapiModule, interfaceVersion);\n-      moduleManager.create(md, true, true, true).onComplete(ires -> {\n-        if (ires.failed()) {\n-          promise.fail(ires.cause()); // something went badly wrong\n-          return;\n-        }\n+      moduleManager.create(md, true, true, true).onFailure(cause1 ->\n+          promise.fail(cause1) // something went badly wrong\n+      ).onSuccess(ires -> {\n         checkSuperTenant(okapiModule, promise);\n       });\n     });\n     return promise.future();\n   }\n \n   private void checkSuperTenant(String okapiModule, Promise<Void> promise) {\n-    tenantManager.get(XOkapiHeaders.SUPERTENANT_ID).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.info(\"checkSuperTenant: Already have \" + XOkapiHeaders.SUPERTENANT_ID);\n-        Tenant st = gres.result();\n-        Set<String> enabledMods = st.getEnabled().keySet();\n-        if (enabledMods.contains(okapiModule)) {\n-          logger.info(\"checkSuperTenant: enabled version is {}\", okapiModule);\n-          promise.complete();\n-          return;\n-        }\n-        // Check version compatibility\n-        String enver = \"\";\n-        for (String emod : enabledMods) {\n-          if (emod.startsWith(\"okapi-\")) {\n-            enver = emod;\n-          }\n-        }\n-        final String ev = enver;\n-        logger.debug(\"checkSuperTenant: Enabled version is '{}', not '{}'\",\n-            ev, okapiModule);\n-        // See Okapi-359 about version checks across the cluster\n-        if (ModuleId.compare(ev, okapiModule) >= 4) {\n-          logger.warn(\"checkSuperTenant: This Okapi is too old,\"\n-                  + \"{} we already have {} in the database. Use that!\",\n-              okapiVersion, ev);\n-          promise.complete();\n-          return;\n+    tenantManager.get(XOkapiHeaders.SUPERTENANT_ID).onSuccess(tenant -> {\n+      // we already have one, go on\n+      logger.info(\"checkSuperTenant: Already have \" + XOkapiHeaders.SUPERTENANT_ID);\n+      Set<String> enabledMods = tenant.getEnabled().keySet();\n+      if (enabledMods.contains(okapiModule)) {\n+        logger.info(\"checkSuperTenant: enabled version is {}\", okapiModule);\n+        promise.complete();\n+        return;\n+      }\n+      // Check version compatibility\n+      String enver = \"\";\n+      for (String emod : enabledMods) {\n+        if (emod.startsWith(\"okapi-\")) {\n+          enver = emod;\n         }\n-        logger.info(\"checkSuperTenant: Need to upgrade the stored version from {} to {}\",\n-            ev, okapiModule);\n-        // Use the commit, easier interface.\n-        // the internal module can not have dependencies\n-        // See Okapi-359 about version checks across the cluster\n-        tenantManager.updateModuleCommit(st, ev, okapiModule).onComplete(ures -> {\n-          if (ures.failed()) {\n-            promise.fail(ures.cause());\n-            return;\n-          }\n-          logger.info(\"Upgraded the InternalModule version from '{}' to '{}' for {}\",\n-              ev, okapiModule, XOkapiHeaders.SUPERTENANT_ID);\n-          promise.complete();\n-        });\n+      }\n+      final String ev = enver;\n+      logger.debug(\"checkSuperTenant: Enabled version is '{}', not '{}'\",\n+          ev, okapiModule);\n+      // See Okapi-359 about version checks across the cluster\n+      if (ModuleId.compare(ev, okapiModule) >= 4) {\n+        logger.warn(\"checkSuperTenant: This Okapi is too old,\"\n+                + \"{} we already have {} in the database. Use that!\",\n+            okapiVersion, ev);\n+        promise.complete();", "originalCommit": "290e3ba0211f27b6b3a72d9912640193b2e75c34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ5NzM4Nw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517497387", "bodyText": "We could it it's just the Okapi module .. But we do have to be careful.. Eg ModuleDescriptors with new properties that suddenly will not be recognized by Okapi anymore.. I'll see what I can do as part of the \"upgrade Okapi module for all tenants\".. https://issues.folio.org/browse/OKAPI-930", "author": "adamdickmeiss", "createdAt": "2020-11-04T17:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MjA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MzA4MA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517473080", "bodyText": "Can this loop be combined with above one?", "author": "hjiebsco", "createdAt": "2020-11-04T16:30:47Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {", "originalCommit": "290e3ba0211f27b6b3a72d9912640193b2e75c34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ5ODE2NA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517498164", "bodyText": "Yes. Will do.", "author": "adamdickmeiss", "createdAt": "2020-11-04T17:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MzA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517475182", "bodyText": "Wondering if we should extract this so it won't be executed every time?", "author": "hjiebsco", "createdAt": "2020-11-04T16:33:50Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {\n+      if (!mi.isHandler()) {\n+        mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n       }\n-      MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries, name + \".loopFilterEntries\");\n     }\n-    MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules, name + \".loopEnabledModules\");\n-\n-    Timer.Sample sampleSortModuleInstances = MetricsHelper.getTimerSample();\n-    Comparator<ModuleInstance> cmp = (ModuleInstance a, ModuleInstance b)\n-        -> a.getRoutingEntry().getPhaseLevel().compareTo(b.getRoutingEntry().getPhaseLevel());\n+    Comparator<ModuleInstance> cmp = Comparator.comparing((ModuleInstance a)\n+        -> a.getRoutingEntry().getPhaseLevel());", "originalCommit": "290e3ba0211f27b6b3a72d9912640193b2e75c34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ5OTI3MQ==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517499271", "bodyText": "I don't see how we could save this sorting.. Having said that we're sorting - in most cases two modules: auth + handler module.. Suppose a few audit.. and we're up to 4.", "author": "adamdickmeiss", "createdAt": "2020-11-04T17:08:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUwNjA5Mw==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517506093", "bodyText": "I mean define it just once somewhere and then use it every time.", "author": "hjiebsco", "createdAt": "2020-11-04T17:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyMzc3NA==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517523774", "bodyText": "ok. done", "author": "adamdickmeiss", "createdAt": "2020-11-04T17:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg=="}], "type": "inlineReview"}, {"oid": "fc5dca92bc319f90e95bdb6b78c98c28510ff4e1", "url": "https://github.com/folio-org/okapi/commit/fc5dca92bc319f90e95bdb6b78c98c28510ff4e1", "message": "token cache check in one loop", "committedDate": "2020-11-04T17:09:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUwNzI4Ng==", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517507286", "bodyText": "Can remove ModuleCache prefix since it is in the same class.", "author": "hjiebsco", "createdAt": "2020-11-04T17:21:21Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int lastSlash = 0;\n+    for (int i = 0; i < pathPattern.length(); i++) {\n+      switch (pathPattern.charAt(i)) {\n+        case '*':\n+        case '{':\n+          return pathPattern.substring(0, lastSlash);\n+        case '/':\n+          lastSlash = i + 1;\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+    return pathPattern;\n+  }\n+\n+  static void add(ModuleDescriptor moduleDescriptor, Map<String, List<ModuleCacheEntry>> map,\n+                  List<RoutingEntry> entries) {\n+    for (RoutingEntry routingEntry : entries) {\n+      String prefix = getPatternPrefix(routingEntry);\n+      List<ModuleCacheEntry> list = map.get(prefix);\n+      if (list == null) {\n+        list = new LinkedList<>();\n+        map.put(prefix, list);\n+      }\n+      list.add(new ModuleCacheEntry(moduleDescriptor, routingEntry));\n+    }\n+  }\n+\n+  private void add(ModuleDescriptor moduleDescriptor) {\n+    add(moduleDescriptor, proxyMap, moduleDescriptor.getProxyRoutingEntries());\n+    add(moduleDescriptor, multiMap, moduleDescriptor.getMultiRoutingEntries());\n+    add(moduleDescriptor, filterMap, moduleDescriptor.getFilterRoutingEntries());\n+  }\n+\n+  private void resolveRedirect(List<ModuleInstance> instances, RoutingEntry re, String loop,\n+                               Set<RoutingEntry> routingEntries,\n+                               HttpMethod method, String uri) {\n+    if (re.getProxyType() != RoutingEntry.ProxyType.REDIRECT) {\n+      return;\n+    }\n+    logger.debug(\"resolveRedirect begin redirectPath={}\", re.getRedirectPath());\n+    boolean found = false;\n+    final String redirectPath = re.getRedirectPath();\n+\n+    List<ModuleInstance> lookup = lookup(redirectPath, method, filterMap, false, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, false);\n+        instances.add(mi);\n+        resolveRedirect(instances, tryre, loop + \" -> \" + redirectPath, routingEntries,\n+            method, redirectUri);\n+      } else {\n+        throw new IllegalArgumentException(messages.getMessage(\"10100\", loop, redirectPath));\n+      }\n+    }\n+    lookup = lookup(redirectPath, method, proxyMap, true, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, true);\n+        instances.add(mi);\n+      }\n+    }\n+    logger.debug(\"resolveRedirect end redirectPath={} found={}\", re.getRedirectPath(), found);\n+    if (!found) {\n+      throw new IllegalArgumentException(messages.getMessage(\"10101\", uri, redirectPath));\n+    }\n+  }\n+\n+  static List<ModuleInstance> lookup(String uri, HttpMethod method, Map<String,\n+      List<ModuleCacheEntry>> map, boolean handler, String id) {\n+    List<ModuleInstance> instances = new LinkedList<>();\n+    String tryUri = uri;\n+    for (int index = 0; index < uri.length(); index++) {\n+      if (uri.charAt(index) == '#' || uri.charAt(index) == '?') {\n+        tryUri = tryUri.substring(0, index);\n+        break;\n+      }\n+    }\n+    while (true) {\n+      List<ModuleCacheEntry> candidateInstances = map.get(tryUri);\n+      if (candidateInstances != null) {\n+        for (ModuleCacheEntry candiate : candidateInstances) {\n+          if (candiate.routingEntry.match(uri, method.name())\n+              && (id == null || id.equals(candiate.moduleDescriptor.getId()))) {\n+            instances.add(new ModuleInstance(candiate.moduleDescriptor,\n+                candiate.routingEntry, uri, method, handler));\n+            if (handler) {\n+              return instances;\n+            }\n+          }\n+        }\n+      }\n+      int index = tryUri.lastIndexOf('/', tryUri.length() - 2);\n+      if (index < 0) {\n+        break;\n+      }\n+      tryUri = tryUri.substring(0, index + 1);\n+    }\n+    return instances;\n+  }\n+\n+  /**\n+   * Find module instances for uri(path) and method.\n+   * @param uri request uri\n+   * @param method HTTP method\n+   * @param id Proxy-ID for multi lookup; otherwise null\n+   * @return module instances that match\n+   * @throws IllegalArgumentException for redirect errors\n+   */\n+  public List<ModuleInstance> lookup(String uri, HttpMethod method, String id) {\n+    logger.debug(\"lookup {} {} id={}\", () -> method.name(), () -> uri, () -> id);\n+    logger.debug(\"Available modules {}\", () -> ModuleUtil.moduleList(moduleDescriptors));\n+    // perform lookup of filters\n+    List<ModuleInstance> instances = ModuleCache.lookup(uri, method, filterMap, false, null);", "originalCommit": "fc5dca92bc319f90e95bdb6b78c98c28510ff4e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2990eb925468eb868afdc73718db2ce55dcb32ff", "url": "https://github.com/folio-org/okapi/commit/2990eb925468eb868afdc73718db2ce55dcb32ff", "message": "Omit redunt class ref", "committedDate": "2020-11-04T17:30:25Z", "type": "commit"}, {"oid": "ba73b84e4a2f0086abdecb27a0b3a89273863bbd", "url": "https://github.com/folio-org/okapi/commit/ba73b84e4a2f0086abdecb27a0b3a89273863bbd", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-916-match-path-using-hash", "committedDate": "2020-11-04T17:31:14Z", "type": "commit"}, {"oid": "9ae3f36f9e2c01077d38efedc3d133814cb773d6", "url": "https://github.com/folio-org/okapi/commit/9ae3f36f9e2c01077d38efedc3d133814cb773d6", "message": "Construct instance comparator once", "committedDate": "2020-11-04T17:48:07Z", "type": "commit"}]}