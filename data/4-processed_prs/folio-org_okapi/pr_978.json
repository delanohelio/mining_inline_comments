{"pr_number": 978, "pr_title": "Refactor Module handle to use Futurisation API OKAPI-899", "pr_createdAt": "2020-09-25T13:12:24Z", "pr_url": "https://github.com/folio-org/okapi/pull/978", "timeline": [{"oid": "fd60b8e75888f8204543f8fb474e9491297c1194", "url": "https://github.com/folio-org/okapi/commit/fd60b8e75888f8204543f8fb474e9491297c1194", "message": "Refactor Module handle to use Futurisation API OKAPI-899", "committedDate": "2020-09-25T13:10:07Z", "type": "commit"}, {"oid": "e7bafa1a540cffa6a6c5186108b4c12091a54275", "url": "https://github.com/folio-org/okapi/commit/e7bafa1a540cffa6a6c5186108b4c12091a54275", "message": "Re-enable and extend testNoDockerAtPort\n\ntestNoDockerAtPort was un-annotated by mistake in Okapi 4.0.0.", "committedDate": "2020-09-28T08:48:35Z", "type": "commit"}, {"oid": "d7d3c6d63784e34d5ead50387cabd0bf024e3ee2", "url": "https://github.com/folio-org/okapi/commit/d7d3c6d63784e34d5ead50387cabd0bf024e3ee2", "message": "DockerMock for improving test coverage for Docker handling", "committedDate": "2020-09-28T11:09:13Z", "type": "commit"}, {"oid": "215ce028a18525c4d02a4a4a2d7710a81cd39b5d", "url": "https://github.com/folio-org/okapi/commit/215ce028a18525c4d02a4a4a2d7710a81cd39b5d", "message": "Async wait; sigh", "committedDate": "2020-09-28T11:16:22Z", "type": "commit"}, {"oid": "21267a01164893126a84200faa2f4a99aa5312e8", "url": "https://github.com/folio-org/okapi/commit/21267a01164893126a84200faa2f4a99aa5312e8", "message": "Further Mock", "committedDate": "2020-09-28T16:39:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk4ODc4Mw==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r496988783", "bodyText": "if (dockerPull) {\n  return pullImage().compose(x -> prepareContainer());\n}\nreturn prepareContainer();", "author": "julianladisch", "createdAt": "2020-09-29T19:27:00Z", "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/DockerModuleHandle.java", "diffHunk": "@@ -373,64 +348,40 @@ private int getExposedPort(JsonObject b) {\n     return exposedPort;\n   }\n \n-  private void prepareContainer(Handler<AsyncResult<Void>> startFuture) {\n-    getImage(res1 -> {\n-      if (res1.failed()) {\n-        logger.warn(\"getImage failed 1 : {}\", res1.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(res1.cause()));\n-        return;\n-      }\n-      if (hostPort == 0) {\n-        startFuture.handle(Future.failedFuture(messages.getMessage(\"11300\")));\n-        return;\n-      }\n+  private Future<Void> prepareContainer() {\n+    if (hostPort == 0) {\n+      return Future.failedFuture(messages.getMessage(\"11300\"));\n+    }\n+    return getImage().compose(res1 -> {\n       int exposedPort;\n       try {\n-        exposedPort = getExposedPort(res1.result());\n-      } catch (Exception ex) {\n-        startFuture.handle(Future.failedFuture(ex));\n-        return;\n+        exposedPort = getExposedPort(res1);\n+      } catch (Exception e) {\n+        logger.warn(\"{}\", e.getMessage(), e);\n+        return Future.failedFuture(e);\n       }\n-      createContainer(exposedPort, res2 -> {\n-        if (res2.failed()) {\n-          startFuture.handle(res2);\n-          return;\n-        }\n-        startContainer(res3 -> {\n-          if (res3.failed()) {\n-            deleteContainer(x -> startFuture.handle(res3));\n-            return;\n-          }\n-          getContainerLog(res4 -> {\n-            if (res4.failed()) {\n-              this.stop(x -> startFuture.handle(res4));\n-              return;\n-            }\n-            startFuture.handle(res4);\n-          });\n-        });\n-      });\n+      return createContainer(exposedPort)\n+          .compose(res2 -> startContainer()\n+              .onFailure(cause -> deleteContainer())\n+              .compose(res3 -> getContainerLog())\n+      );\n     });\n   }\n \n   @Override\n-  public void start(Handler<AsyncResult<Void>> startFuture) {\n+  public Future<Void> start() {\n+    Future<Void> future = Future.succeededFuture();\n     if (dockerPull) {\n-      pullImage(res -> prepareContainer(startFuture));\n-    } else {\n-      prepareContainer(startFuture);\n+      future = future.compose(x -> pullImage());\n     }\n+    return future.compose(x -> prepareContainer());", "originalCommit": "21267a01164893126a84200faa2f4a99aa5312e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5OTA2NQ==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r496999065", "bodyText": "OK. The reason for existing layout was to mention prepareContainer only once.", "author": "adamdickmeiss", "createdAt": "2020-09-29T19:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk4ODc4Mw=="}], "type": "inlineReview"}, {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51", "url": "https://github.com/folio-org/okapi/commit/eed6c84ae3cc72d4e909989501a10e426f5b0e51", "message": "Refactor", "committedDate": "2020-09-29T19:42:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwNjE0MQ==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497006141", "bodyText": "No need for the promise:\nif (port == 0) {\n  return start2();\n}\n// fail if port is already in use\nNetClientOptions options = new NetClientOptions().setConnectTimeout(200);\nNetClient c = vertx.createNetClient(options);\nreturn c.connect(port, \"localhost\").compose(socket -> {\n  socket.close();\n  return Future.failedFuture(messages.getMessage(\"11502\", Integer.toString(port)));\n}, fail -> start2());", "author": "julianladisch", "createdAt": "2020-09-29T19:54:42Z", "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -73,24 +72,25 @@ public ProcessModuleHandle(Vertx vertx, LaunchDescriptor desc, String id,\n   }\n \n   @Override\n-  public void start(Handler<AsyncResult<Void>> startFuture) {\n-    if (port > 0) {\n+  public Future<Void> start() {\n+    Promise<Void> promise = Promise.promise();\n+    if (port == 0) {\n+      promise.complete();\n+    } else {\n       // fail if port is already in use\n       NetClientOptions options = new NetClientOptions().setConnectTimeout(200);\n       NetClient c = vertx.createNetClient(options);\n-      c.connect(port, \"localhost\", res -> {\n+      c.connect(port, \"localhost\").onComplete(res -> {\n         if (res.succeeded()) {\n           NetSocket socket = res.result();\n           socket.close();\n-          startFuture.handle(Future.failedFuture(\n-              messages.getMessage(\"11502\", Integer.toString(port))));\n+          promise.fail(messages.getMessage(\"11502\", Integer.toString(port)));\n         } else {\n-          start2(startFuture);\n+          promise.complete();\n         }\n       });\n-    } else {\n-      start2(startFuture);\n     }\n+    return promise.future().compose(x -> start2());", "originalCommit": "eed6c84ae3cc72d4e909989501a10e426f5b0e51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4NDY3Mw==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497484673", "bodyText": "oh .. the 2nd argument to compose is useful for \"negating\".", "author": "adamdickmeiss", "createdAt": "2020-09-30T12:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwNjE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwODU0MQ==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497008541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return tcpPortWaiting.waitReady(process).onFailure(x -> {\n          \n          \n            \n                  this.stopProcess();\n          \n          \n            \n                });\n          \n          \n            \n                return tcpPortWaiting.waitReady(process).onFailure(x -> stopProcess());", "author": "julianladisch", "createdAt": "2020-09-29T19:59:11Z", "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -175,100 +175,81 @@ private void start2(Handler<AsyncResult<Void>> startFuture) {\n         }\n       }\n       future.complete();\n-    }, false, result -> {\n-      if (result.failed()) {\n-        logger.debug(\"ProcessModuleHandle.start2() executeBlocking failed {}\",\n-            result.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(result.cause()));\n-      } else {\n-        start3(startFuture);\n-      }\n-    });\n+    }, false).compose(x -> start3());\n   }\n \n-  private void start3(Handler<AsyncResult<Void>> startFuture) {\n-    tcpPortWaiting.waitReady(process, x -> {\n-      if (x.failed()) {\n-        this.stopProcess(y -> startFuture.handle(Future.failedFuture(x.cause())));\n-      } else {\n-        startFuture.handle(Future.succeededFuture());\n-      }\n+  private Future<Void> start3() {\n+    return tcpPortWaiting.waitReady(process).onFailure(x -> {\n+      this.stopProcess();\n     });", "originalCommit": "eed6c84ae3cc72d4e909989501a10e426f5b0e51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyOTc1MQ==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497529751", "bodyText": "yep", "author": "adamdickmeiss", "createdAt": "2020-09-30T13:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwODU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNjcyOA==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497016728", "bodyText": "Using compose results in more simple code:\nNetClientOptions options = new NetClientOptions().setConnectTimeout(50);\nNetClient c = vertx.createNetClient(options);\nreturn c.connect(port, \"localhost\").compose(socket -> {\n  socket.close();\n  if (iter > 0) {\n    Promise<Void> promise = Promise.promise();\n    vertx.setTimer(100, id -> waitPortToClose(iter - 1).onComplete(promise::handle));\n    return promise.future();\n  } else {\n    return Future.failedFuture(messages.getMessage(\"11503\", Integer.toString(port)));\n  }\n}, fail -> Future.succeededFuture());", "author": "julianladisch", "createdAt": "2020-09-29T20:14:52Z", "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -175,100 +175,81 @@ private void start2(Handler<AsyncResult<Void>> startFuture) {\n         }\n       }\n       future.complete();\n-    }, false, result -> {\n-      if (result.failed()) {\n-        logger.debug(\"ProcessModuleHandle.start2() executeBlocking failed {}\",\n-            result.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(result.cause()));\n-      } else {\n-        start3(startFuture);\n-      }\n-    });\n+    }, false).compose(x -> start3());\n   }\n \n-  private void start3(Handler<AsyncResult<Void>> startFuture) {\n-    tcpPortWaiting.waitReady(process, x -> {\n-      if (x.failed()) {\n-        this.stopProcess(y -> startFuture.handle(Future.failedFuture(x.cause())));\n-      } else {\n-        startFuture.handle(Future.succeededFuture());\n-      }\n+  private Future<Void> start3() {\n+    return tcpPortWaiting.waitReady(process).onFailure(x -> {\n+      this.stopProcess();\n     });\n   }\n \n-  private void waitPortToClose(Handler<AsyncResult<Void>> stopFuture, int iter) {\n-    if (port > 0) {\n-      // fail if port is already in use\n-      NetClientOptions options = new NetClientOptions().setConnectTimeout(50);\n-      NetClient c = vertx.createNetClient(options);\n-      c.connect(port, \"localhost\", res -> {\n-        if (res.succeeded()) {\n-          NetSocket socket = res.result();\n-          socket.close();\n-          if (iter > 0) {\n-            vertx.setTimer(100, x -> waitPortToClose(stopFuture, iter - 1));\n-          } else {\n-            stopFuture.handle(Future.failedFuture(\n-                messages.getMessage(\"11503\", Integer.toString(port))));\n-          }\n+  private Future<Void> waitPortToClose(int iter) {\n+    if (port == 0) {\n+      return Future.succeededFuture();\n+    }\n+    NetClientOptions options = new NetClientOptions().setConnectTimeout(50);\n+    NetClient c = vertx.createNetClient(options);\n+    Promise<Void> promise = Promise.promise();\n+    c.connect(port, \"localhost\").onComplete(res -> {\n+      if (res.succeeded()) {\n+        NetSocket socket = res.result();\n+        socket.close();\n+        if (iter > 0) {\n+          vertx.setTimer(100, id -> waitPortToClose(iter - 1).onComplete(promise::handle));\n         } else {\n-          stopFuture.handle(Future.succeededFuture());\n+          promise.fail(messages.getMessage(\"11503\", Integer.toString(port)));\n         }\n-      });\n-    } else {\n-      stopFuture.handle(Future.succeededFuture());\n-    }\n+      } else {\n+        promise.complete();\n+      }\n+    });\n+    return promise.future();", "originalCommit": "eed6c84ae3cc72d4e909989501a10e426f5b0e51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyOTg1OA==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497529858", "bodyText": "yep", "author": "adamdickmeiss", "createdAt": "2020-09-30T13:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNjcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMTY5Mg==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497021692", "bodyText": "The @return javadoc should be removed because it does not give any additional information. (At least startFuture should be removed).", "author": "julianladisch", "createdAt": "2020-09-29T20:23:55Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/TcpPortWaiting.java", "diffHunk": "@@ -62,13 +63,12 @@ public void setMaxIterations(int maxIterations) {\n   /**\n    * Wait for process and server to be listening.\n    * @param process Process to monitor\n-   * @param startFuture async result\n+   * @return startFuture async result", "originalCommit": "eed6c84ae3cc72d4e909989501a10e426f5b0e51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1NzM2OQ==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497057369", "bodyText": "@SuppressWarnings(\"indentation\")  // indentation of fail -> {\n\n...\n  return mh.start().compose(started -> {\n    DeploymentDescriptor md2 = new DeploymentDescriptor(md1.getInstId(), md1.getSrvcId(),\n        moduleUrl, descriptor, mh);\n    md2.setNodeId(md1.getNodeId() != null ? md1.getNodeId() : host);\n    list.put(md2.getInstId(), md2);\n    return dm.add(md2).map(md2);\n  }, fail -> {\n    ports.free(usePort);\n    logger.warn(\"Deploying {} failed\", md1.getSrvcId());\n    return Future.failedFuture(new OkapiError(ErrorType.USER, fail.getMessage()));\n  });", "author": "julianladisch", "createdAt": "2020-09-29T21:03:46Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DeploymentManager.java", "diffHunk": "@@ -181,21 +179,19 @@ public DeploymentManager(Vertx vertx, DiscoveryManager dm, EnvManager em,\n       ModuleHandle mh = ModuleHandleFactory.create(vertx, descriptor,\n           md1.getSrvcId(), ports, moduleHost, usePort, config);\n       Promise<DeploymentDescriptor> promise = Promise.promise();\n-      mh.start(future -> {\n-        if (future.failed()) {\n+      mh.start().onComplete(res -> {\n+        if (res.failed()) {\n           ports.free(usePort);\n           logger.warn(\"Deploying {} failed\", md1.getSrvcId());\n-          promise.fail(new OkapiError(ErrorType.USER, future.cause().getMessage()));\n+          promise.fail(new OkapiError(ErrorType.USER, res.cause().getMessage()));\n           return;\n         }\n         DeploymentDescriptor md2\n             = new DeploymentDescriptor(md1.getInstId(), md1.getSrvcId(),\n             moduleUrl, descriptor, mh);\n         md2.setNodeId(md1.getNodeId() != null ? md1.getNodeId() : host);\n         list.put(md2.getInstId(), md2);\n-        dm.add(md2).onComplete(res -> {\n-          promise.complete(md2);\n-        });\n+        dm.add(md2).onComplete(res1 -> promise.handle(res1.map(md2)));\n       });\n       return promise.future();\n     });", "originalCommit": "eed6c84ae3cc72d4e909989501a10e426f5b0e51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzNDE0OA==", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497534148", "bodyText": "ok", "author": "adamdickmeiss", "createdAt": "2020-09-30T14:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1NzM2OQ=="}], "type": "inlineReview"}, {"oid": "06adff646c0b81a1112528c99fe6749d26dfeaaf", "url": "https://github.com/folio-org/okapi/commit/06adff646c0b81a1112528c99fe6749d26dfeaaf", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-899-module-api-futurisation", "committedDate": "2020-09-30T12:48:10Z", "type": "commit"}, {"oid": "b611286c67b629b80e65aab6ea345e9ef6602bc3", "url": "https://github.com/folio-org/okapi/commit/b611286c67b629b80e65aab6ea345e9ef6602bc3", "message": "Refactor simplications; in particular use compose with 2 arguments", "committedDate": "2020-09-30T14:04:43Z", "type": "commit"}]}