{"pr_number": 969, "pr_title": "ValidPatternVisitor now checks #INCLUDE and #EXCLUDE functions. (#787)", "pr_createdAt": "2020-10-22T14:05:13Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/969", "timeline": [{"oid": "9bafe13164594a73bc72fb5ba862ec00eb42e4ee", "url": "https://github.com/NationalSecurityAgency/datawave/commit/9bafe13164594a73bc72fb5ba862ec00eb42e4ee", "message": "ValidPatternVisitor now checks #INCLUDE and #EXCLUDE functions. (#787)\n\n* ValidPatternVisitor now checks #INCLUDE and #EXCLUDE functions.\n\n* Address PR comments.\n\n* Address PR comments.\n\nCo-authored-by: Brian Loss <brianloss@gmail.com>\nCo-authored-by: Ivan Bella <ivan@bella.name>", "committedDate": "2020-10-22T13:51:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4NTQ2MA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/969#discussion_r520085460", "bodyText": "As it turns out, the initial implementation wraps the call to getLiteralValue with a try-catch block.  This was allowing us to handle FIELD1 =~ FIELD2 constructs correctly.  Now this visitor will simply throw an exception in that case which is not what we want.  I am fixing this in the master branch.", "author": "ivakegg", "createdAt": "2020-11-09T20:01:48Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java", "diffHunk": "@@ -69,22 +59,64 @@ public Object visit(ASTERNode node, Object data) {\n      */\n     @Override\n     public Object visit(ASTNRNode node, Object data) {\n-        Object literalValue;\n+        parseAndPutPattern(node);\n+        return data;\n+    }\n+    \n+    /**\n+     * Visit an ASTFunctionNode to catch cases like #INCLUDE or #EXCLUDE that accept a regex as an argument\n+     * \n+     * @param node\n+     *            - an ASTFunctionNode\n+     * @param data\n+     *            - the data\n+     * @return\n+     */\n+    @Override\n+    public Object visit(ASTFunctionNode node, Object data) {\n         \n-        // Catch the situation where a user might enter FIELD1 !~ VALUE1\n-        try {\n-            literalValue = JexlASTHelper.getLiteralValue(node);\n-        } catch (NoSuchElementException e) {\n-            return data;\n+        // Should pull back an EvaluationPhaseFilterFunctionsDescriptor\n+        JexlArgumentDescriptor descriptor = JexlFunctionArgumentDescriptorFactory.F.getArgumentDescriptor(node);\n+        if (descriptor == null) {\n+            throw new IllegalStateException(\"Could not get descriptor for ASTFunctionNode\");\n         }\n         \n+        if (descriptor.regexArguments()) {\n+            // Extract the args for this function\n+            FunctionJexlNodeVisitor functionVisitor = new FunctionJexlNodeVisitor();\n+            functionVisitor.visit(node, null);\n+            List<JexlNode> args = functionVisitor.args();\n+            for (JexlNode arg : args) {\n+                // Only take the literals\n+                if (arg instanceof ASTStringLiteral) {\n+                    parseAndPutPattern(arg);\n+                }\n+            }\n+        }\n+        // Do not descend to children, the ValidPatternVisitor views a function node as a leaf node.\n+        return data;\n+    }\n+    \n+    /**\n+     * Parse a literal value and put into the pattern cache if it does not exist.\n+     *\n+     * @param node\n+     */\n+    public void parseAndPutPattern(JexlNode node) {\n+        // Catch the situation where a user might enter FIELD1 !~ VALUE1\n+        Object literalValue = JexlASTHelper.getLiteralValue(node);", "originalCommit": "9bafe13164594a73bc72fb5ba862ec00eb42e4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}