{"pr_number": 910, "pr_title": "Remove redundant conjunctions and disjunctions from query", "pr_createdAt": "2020-09-01T03:16:35Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/910", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzMzk1MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481033951", "bodyText": "This should be able to handle any number of terms within an OrNode", "author": "apmoriarty", "createdAt": "2020-09-01T10:21:22Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(ConjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        ConjunctionEliminationVisitor visitor = new ConjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTOrNode node, Object data) {", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxMjA5OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r483912099", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-05T05:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzMzk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNTM5MA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481035390", "bodyText": "otherScript -> otherNode", "author": "apmoriarty", "createdAt": "2020-09-01T10:24:10Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(ConjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        ConjunctionEliminationVisitor visitor = new ConjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTOrNode node, Object data) {\n+        JexlNode left = getFirstNonASTReference(node.jjtGetChild(0));\n+        JexlNode right = getFirstNonASTReference(node.jjtGetChild(1));\n+        try {\n+            if (isConjunction(left) && hasDuplicate(left, right)) {\n+                return copyChildAndUpdateParent(node, right);\n+            }\n+            if (isConjunction(right) && hasDuplicate(right, left)) {\n+                return copyChildAndUpdateParent(node, left);\n+            }\n+        } catch (ParseException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Failed to parse child node to check for equivalency\", e);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    // Return the first non-wrapped node.\n+    private JexlNode getFirstNonASTReference(JexlNode node) {\n+        if (node instanceof ASTReference || node instanceof ASTReferenceExpression) {\n+            return getFirstNonASTReference(node.jjtGetChild(0));\n+        } else {\n+            return node;\n+        }\n+    }\n+    \n+    // Return whether or not the given node is an AND.\n+    private boolean isConjunction(JexlNode node) {\n+        return node instanceof ASTAndNode;\n+    }\n+    \n+    // Return true if the conjunction node\n+    private boolean hasDuplicate(JexlNode conjunction, JexlNode otherScript) throws ParseException {", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTA0MA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171040", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNTM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNzc2NQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481037765", "bodyText": "Something like..?\n// Returns true if the conjunction contains a duplicate of the provided node", "author": "apmoriarty", "createdAt": "2020-09-01T10:28:47Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(ConjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        ConjunctionEliminationVisitor visitor = new ConjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTOrNode node, Object data) {\n+        JexlNode left = getFirstNonASTReference(node.jjtGetChild(0));\n+        JexlNode right = getFirstNonASTReference(node.jjtGetChild(1));\n+        try {\n+            if (isConjunction(left) && hasDuplicate(left, right)) {\n+                return copyChildAndUpdateParent(node, right);\n+            }\n+            if (isConjunction(right) && hasDuplicate(right, left)) {\n+                return copyChildAndUpdateParent(node, left);\n+            }\n+        } catch (ParseException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Failed to parse child node to check for equivalency\", e);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    // Return the first non-wrapped node.\n+    private JexlNode getFirstNonASTReference(JexlNode node) {\n+        if (node instanceof ASTReference || node instanceof ASTReferenceExpression) {\n+            return getFirstNonASTReference(node.jjtGetChild(0));\n+        } else {\n+            return node;\n+        }\n+    }\n+    \n+    // Return whether or not the given node is an AND.\n+    private boolean isConjunction(JexlNode node) {\n+        return node instanceof ASTAndNode;\n+    }\n+    \n+    // Return true if the conjunction node", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTIyNQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171225", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNzc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTQzNA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481049434", "bodyText": "I'm disliking that for each equivalence check we build a string, parse it, then wrap it in a ASTJexlScript to run the equality visitor. However, hacking in another TreeEqualityVisitor.isEqual() method that accepts jexl nodes instead of scripts doesn't play nicely with reference expressions.\nIn a perfect world the TreeEqualityVisitor would support evaluation of two jexl nodes that may or may not represent subtrees, with an option to descend into reference expressions. It should not force you into evaluation two jexl scripts.\nTo be clear, you are doing the correct thing here -- I'm complaining about exiting code.", "author": "apmoriarty", "createdAt": "2020-09-01T10:51:33Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(ConjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        ConjunctionEliminationVisitor visitor = new ConjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTOrNode node, Object data) {\n+        JexlNode left = getFirstNonASTReference(node.jjtGetChild(0));\n+        JexlNode right = getFirstNonASTReference(node.jjtGetChild(1));\n+        try {\n+            if (isConjunction(left) && hasDuplicate(left, right)) {\n+                return copyChildAndUpdateParent(node, right);\n+            }\n+            if (isConjunction(right) && hasDuplicate(right, left)) {\n+                return copyChildAndUpdateParent(node, left);\n+            }\n+        } catch (ParseException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Failed to parse child node to check for equivalency\", e);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    // Return the first non-wrapped node.\n+    private JexlNode getFirstNonASTReference(JexlNode node) {\n+        if (node instanceof ASTReference || node instanceof ASTReferenceExpression) {\n+            return getFirstNonASTReference(node.jjtGetChild(0));\n+        } else {\n+            return node;\n+        }\n+    }\n+    \n+    // Return whether or not the given node is an AND.\n+    private boolean isConjunction(JexlNode node) {\n+        return node instanceof ASTAndNode;\n+    }\n+    \n+    // Return true if the conjunction node\n+    private boolean hasDuplicate(JexlNode conjunction, JexlNode otherScript) throws ParseException {\n+        int totalChildren = conjunction.jjtGetNumChildren();\n+        ASTJexlScript script = getScript(otherScript);\n+        for (int i = 0; i < totalChildren; i++) {\n+            JexlNode child = conjunction.jjtGetChild(i);\n+            if (isEquivalent(child, script)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    // Copy the child node and replace the original node with it in the original node's parent.\n+    private JexlNode copyChildAndUpdateParent(JexlNode original, JexlNode child) {\n+        JexlNode copy = copy(child);\n+        copy.image = original.image;\n+        replaceChild(original.jjtGetParent(), original, copy);\n+        return copy;\n+    }\n+    \n+    // Return whether or not the two JEXL queries are equivalent.\n+    private boolean isEquivalent(JexlNode node, ASTJexlScript script) throws ParseException {\n+        ASTJexlScript nodeScript = getScript(node);\n+        return TreeEqualityVisitor.isEqual(nodeScript, script, new TreeEqualityVisitor.Reason());", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NTA2Ng==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481175066", "bodyText": "I thought about comparing the query strings similar to UniqueExpressionTermsVisitor, but I found that didn't handle the case where duplicate ANDs/ORs with sub-terms in differing order. It might be worth creating a ticket to come up with a more efficient way to check equivalency between two JexlNodes so that someone can eventually tackle that.", "author": "lbschanno", "createdAt": "2020-09-01T14:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc0MDU3OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r485740579", "bodyText": "Not a bad idea. Opened issue here #914", "author": "apmoriarty", "createdAt": "2020-09-09T16:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTYwOQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481049609", "bodyText": "disjunctions?", "author": "apmoriarty", "createdAt": "2020-09-01T10:51:51Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class DisjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(DisjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTY2Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171663", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTgyMQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481049821", "bodyText": "otherScript -> otherNode", "author": "apmoriarty", "createdAt": "2020-09-01T10:52:18Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class DisjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(DisjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        DisjunctionEliminationVisitor visitor = new DisjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTAndNode node, Object data) {\n+        JexlNode left = getFirstNonASTReference(node.jjtGetChild(0));\n+        JexlNode right = getFirstNonASTReference(node.jjtGetChild(1));\n+        try {\n+            if (isDisjunction(left) && hasDuplicate(left, right)) {\n+                return copyChildAndUpdateParent(node, right);\n+            }\n+            if (isDisjunction(right) && hasDuplicate(right, left)) {\n+                return copyChildAndUpdateParent(node, left);\n+            }\n+        } catch (ParseException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Failed to parse child node to check for equivalency\", e);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    // Return the first non-wrapped node.\n+    private JexlNode getFirstNonASTReference(JexlNode node) {\n+        if (node instanceof ASTReference || node instanceof ASTReferenceExpression) {\n+            return getFirstNonASTReference(node.jjtGetChild(0));\n+        } else {\n+            return node;\n+        }\n+    }\n+    \n+    // Return whether or not the given node is an OR.\n+    private boolean isDisjunction(JexlNode node) {\n+        return node instanceof ASTOrNode;\n+    }\n+    \n+    // Return true if the conjunction node\n+    private boolean hasDuplicate(JexlNode conjunction, JexlNode otherScript) throws ParseException {", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTc2Nw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171767", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MDA4OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481050088", "bodyText": "Don't need this class level annotation, same comment with other test.", "author": "apmoriarty", "createdAt": "2020-09-01T10:52:50Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(JUnit4.class)", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTg2OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171869", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MDA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MTIzMw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481051233", "bodyText": "A test with more than 2 top level nodes will fail, in this case the node PET == 'fluffy' was added.\n@Test\npublic void testDuplicateConjunctionWithWrappedUniqueNestedDisjunction_threeTopLevelTerms() throws ParseException {\n    String original = \"(FOO == 'bar' && (FOO == 'baz' || FOO == 'zoo')) || PET == 'fluffy' || FOO == 'bar'\";\n    String expected = \"PET == 'fluffy' || FOO == 'bar'\";\n    visitAndValidate(original, expected);\n}", "author": "apmoriarty", "createdAt": "2020-09-01T10:55:05Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(JUnit4.class)\n+public class ConjunctionEliminationVisitorTest {\n+    \n+    @Test\n+    public void testSingleTerm() throws ParseException {\n+        String original = \"FOO == 'bar'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testUniqueConjunctionInTopLevelDisjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && FOO == 'baz') || FOO == 'zoo'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testDuplicateInNestedConjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && FOO == 'baz') || FOO == 'bar'\";\n+        String expected = \"FOO == 'bar'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionInWrappedTopLevelDisjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' && FOO == 'baz') || FOO == 'bar')\";\n+        String expected = \"(FOO == 'bar')\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateNestedConjunction() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && FOO == 'bar') || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateNestedConjunctionInWrappedTopLevelDisjunction() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && FOO == 'bar') || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testMultipleNestedConjunctionsWithDuplicate() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && (FOO == 'bar' && FOO == 'dab')) || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testMultipleNestedConjunctionsWithDifferentlyOrderedDuplicate() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && (FOO == 'bar' && FOO == 'dab')) || (FOO == 'zoo' && FOO == 'baz')\";\n+        String expected = \"FOO == 'zoo' && FOO == 'baz'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionWithUniqueNestedDisjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' && FOO == 'baz') || FOO == 'zoo') || FOO == 'bar'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionWithWrappedUniqueNestedDisjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && (FOO == 'baz' || FOO == 'zoo')) || FOO == 'bar'\";\n+        String expected = \"FOO == 'bar'\";\n+        visitAndValidate(original, expected);\n+    }", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxMjA1OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r483912058", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-05T05:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MTYwOA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481051608", "bodyText": "If the original script is flattened a few test cases fail. Same comment with other test class.\noriginalScript = TreeFlatteningRebuilder.flatten(originalScript);", "author": "apmoriarty", "createdAt": "2020-09-01T10:55:57Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(JUnit4.class)\n+public class ConjunctionEliminationVisitorTest {\n+    \n+    @Test\n+    public void testSingleTerm() throws ParseException {\n+        String original = \"FOO == 'bar'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testUniqueConjunctionInTopLevelDisjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && FOO == 'baz') || FOO == 'zoo'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testDuplicateInNestedConjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && FOO == 'baz') || FOO == 'bar'\";\n+        String expected = \"FOO == 'bar'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionInWrappedTopLevelDisjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' && FOO == 'baz') || FOO == 'bar')\";\n+        String expected = \"(FOO == 'bar')\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateNestedConjunction() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && FOO == 'bar') || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateNestedConjunctionInWrappedTopLevelDisjunction() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && FOO == 'bar') || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testMultipleNestedConjunctionsWithDuplicate() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && (FOO == 'bar' && FOO == 'dab')) || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testMultipleNestedConjunctionsWithDifferentlyOrderedDuplicate() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && (FOO == 'bar' && FOO == 'dab')) || (FOO == 'zoo' && FOO == 'baz')\";\n+        String expected = \"FOO == 'zoo' && FOO == 'baz'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionWithUniqueNestedDisjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' && FOO == 'baz') || FOO == 'zoo') || FOO == 'bar'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionWithWrappedUniqueNestedDisjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && (FOO == 'baz' || FOO == 'zoo')) || FOO == 'bar'\";\n+        String expected = \"FOO == 'bar'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateDisjunctionInNestedConjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' || FOO == 'baz') && FOO == 'zoo') || (FOO == 'bar' || FOO == 'baz')\";\n+        String expected = \"FOO == 'bar' || FOO == 'baz'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    private void visitAndValidate(String original, String expected) throws ParseException {\n+        ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n+        ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxMjA2Mg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r483912062", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-05T05:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MTYwOA=="}], "type": "inlineReview"}, {"oid": "969e27568c0fd52449cbd394569590027b0dbfad", "url": "https://github.com/NationalSecurityAgency/datawave/commit/969e27568c0fd52449cbd394569590027b0dbfad", "message": "Remove redundant conjunctions and disjunctions from query\n\nRemove duplicate terms that are distributed through AND and OR nodes.\nFor example:\n\nCase 1: (A && B) || A should be reduced to A.\nCase 2: (A || B) && A should be reduced to A.\n\nCreate ConjunctionEliminationVisitor to handle case 1.\nCreate DisjunctionEliminationVisitor to handle case 2.\n\nFixes #883", "committedDate": "2020-12-15T18:08:25Z", "type": "commit"}, {"oid": "e6c72136cfc0255764b442effaa953aae01140a2", "url": "https://github.com/NationalSecurityAgency/datawave/commit/e6c72136cfc0255764b442effaa953aae01140a2", "message": "Fix checkstyle violations", "committedDate": "2020-12-15T18:08:25Z", "type": "commit"}, {"oid": "9cc9b5313feb5ba5f73744ff55e70c941c9b274c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/9cc9b5313feb5ba5f73744ff55e70c941c9b274c", "message": "Apply changes requested in review", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "3880761e8219037cb429da1c5e1b88ac948c09cb", "url": "https://github.com/NationalSecurityAgency/datawave/commit/3880761e8219037cb429da1c5e1b88ac948c09cb", "message": "Add visitor toggles to ShardQueryConfiguration", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "6baf42bb4853207a8b4fd8f72f943e40762ac9f5", "url": "https://github.com/NationalSecurityAgency/datawave/commit/6baf42bb4853207a8b4fd8f72f943e40762ac9f5", "message": "Handle flattening and multiple top-level terms", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "6b244b5891d3a320cb12d34000c00c29cb3e87c7", "url": "https://github.com/NationalSecurityAgency/datawave/commit/6b244b5891d3a320cb12d34000c00c29cb3e87c7", "message": "Fix expected number of additions", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "56773e780f1be7404617125ef189c6e14787e26c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/56773e780f1be7404617125ef189c6e14787e26c", "message": "Fix Javadoc issues", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "cae05a76f8bc244ed492342c00219454e17242b5", "url": "https://github.com/NationalSecurityAgency/datawave/commit/cae05a76f8bc244ed492342c00219454e17242b5", "message": "Ensure both visitors maintain a valid lineage", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "145ff2f2bf3f63c102d2c46a13b18537bbf1f008", "url": "https://github.com/NationalSecurityAgency/datawave/commit/145ff2f2bf3f63c102d2c46a13b18537bbf1f008", "message": "Fix code formatting", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "ed4edd767b5caf6be04bc8f039bb0a4c705f75bf", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ed4edd767b5caf6be04bc8f039bb0a4c705f75bf", "message": "Remove unnecessary traversal", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "ed4edd767b5caf6be04bc8f039bb0a4c705f75bf", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ed4edd767b5caf6be04bc8f039bb0a4c705f75bf", "message": "Remove unnecessary traversal", "committedDate": "2020-12-15T18:08:26Z", "type": "forcePushed"}, {"oid": "81c99b74aaaea52f2b15956a786f5d440f76404c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/81c99b74aaaea52f2b15956a786f5d440f76404c", "message": "Merge remote-tracking branch 'upstream/release/version3.1' into redundant-query", "committedDate": "2020-12-29T17:12:32Z", "type": "commit"}, {"oid": "19b2bb6d194946606ee73cc3ec0572166b4922c7", "url": "https://github.com/NationalSecurityAgency/datawave/commit/19b2bb6d194946606ee73cc3ec0572166b4922c7", "message": "Merge branch 'release/version3.2' into redundant-query", "committedDate": "2021-02-23T17:16:32Z", "type": "commit"}, {"oid": "acb16ff62bcb4f2e03e9d8c2c8f87ff7c1d301c1", "url": "https://github.com/NationalSecurityAgency/datawave/commit/acb16ff62bcb4f2e03e9d8c2c8f87ff7c1d301c1", "message": "Merge branch 'release/version3.2' into redundant-query", "committedDate": "2021-03-05T16:53:15Z", "type": "commit"}]}