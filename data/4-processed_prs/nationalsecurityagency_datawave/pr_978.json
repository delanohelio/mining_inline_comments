{"pr_number": 978, "pr_title": "fixes #976: Added a visitor to validate comparisons are between a field\u2026", "pr_createdAt": "2020-10-29T13:02:09Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/978", "timeline": [{"oid": "c167101a18099aa0a458be9568584cb36339b633", "url": "https://github.com/NationalSecurityAgency/datawave/commit/c167101a18099aa0a458be9568584cb36339b633", "message": "fixes #976: Added a visitor to ensure comparisons are between a field and a literal or between two fields.", "committedDate": "2020-10-29T12:59:40Z", "type": "commit"}, {"oid": "318f9e2fd469e8fb2fdd9d4bb8f4402856c5540c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/318f9e2fd469e8fb2fdd9d4bb8f4402856c5540c", "message": "Added a few more edge cases to the ValidComparisonVisitorTest.", "committedDate": "2020-10-30T04:10:21Z", "type": "commit"}, {"oid": "e78fbcd3b6fdb8074a200c9b1ab9bfcf66dc9f33", "url": "https://github.com/NationalSecurityAgency/datawave/commit/e78fbcd3b6fdb8074a200c9b1ab9bfcf66dc9f33", "message": "Merge branch 'master' into bugfix/DATAWAVE-976", "committedDate": "2020-10-30T04:11:39Z", "type": "commit"}, {"oid": "c8fef1b73aa91deaecd9f6c86fbf38c66e7509e8", "url": "https://github.com/NationalSecurityAgency/datawave/commit/c8fef1b73aa91deaecd9f6c86fbf38c66e7509e8", "message": "re #976: Simplified logic", "committedDate": "2020-11-02T14:38:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzE1OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/978#discussion_r516393158", "bodyText": "You removed the concept of passing found identifiers back up to parent nodes as I was doing with the list implementation.  Add this test and you'll see how it fails.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \n          \n          \n            \n                \n          \n          \n            \n                @Test(expected = DatawaveFatalQueryException.class)\n          \n          \n            \n                public void testMethodNodeNested() throws ParseException {\n          \n          \n            \n                    String queryString = \"(AG.greaterThan(39).size() >= 1) == 'false'\";\n          \n          \n            \n                    ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n          \n          \n            \n                    ValidComparisonVisitor.check(script);\n          \n          \n            \n                }", "author": "jwomeara", "createdAt": "2020-11-03T02:09:57Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ValidComparisonVisitorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.exceptions.DatawaveFatalQueryException;\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.junit.Test;\n+\n+public class ValidComparisonVisitorTest {\n+    \n+    @Test\n+    public void testHappyPath() throws ParseException {\n+        String queryString = \"BAR == 1 && FOO =~ '1234.*' && BAR != 'x' && FOO !~ 'why' && BAR < 'x'  && FOO > 'y' && BAR <= 'c' && FOO >= 'd'\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test\n+    public void testFieldOpField() throws ParseException {\n+        String queryString = \"BAR == FOO && FOO =~ BAR && BAR != FOO && FOO !~ BAR && BAR < FOO  && FOO > BAR && BAR <= FOO && FOO >= BAR\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidEQ() throws ParseException {\n+        String queryString = \"'BAR' == 1\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidNE() throws ParseException {\n+        String queryString = \"'BAR' != 1\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidRE() throws ParseException {\n+        String queryString = \"'BAR' =~ 'foo'\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidNR() throws ParseException {\n+        String queryString = \"'BAR' !~ 'foo'\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidLT() throws ParseException {\n+        String queryString = \"'BAR' < 1\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidLE() throws ParseException {\n+        String queryString = \"'BAR' <= 1\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidGT() throws ParseException {\n+        String queryString = \"'BAR' > 1\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidGE() throws ParseException {\n+        String queryString = \"'BAR' >= 1\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    \n+    @Test(expected = DatawaveFatalQueryException.class)\n+    public void testInvalidAssignment() throws ParseException {\n+        String queryString = \"'ASTEvaluationOnly' = true\";\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(queryString);\n+        ValidComparisonVisitor.check(script);\n+    }\n+    ", "originalCommit": "c8fef1b73aa91deaecd9f6c86fbf38c66e7509e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcwNTAxMA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/978#discussion_r516705010", "bodyText": "I contemplated that, and I don't believe that your added test query should actually fail here.  I am only trying to catch the case where it is a simple literal op literal expression where it is highly likely that the user made an error specifying the query.  If it is something more complicated like this one, then I am more inclined to believe the user knows what they are doing.", "author": "ivakegg", "createdAt": "2020-11-03T14:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzU3NA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/978#discussion_r516393574", "bodyText": "Doing something like this to pass found identifiers back up to parent nodes fixes the test case I presented...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void validateExpression(JexlNode node, Object data) {\n          \n          \n            \n                    if ((data instanceof MutableInt) && (((MutableInt) data).intValue() > 1)) {\n          \n          \n            \n                        throw new DatawaveFatalQueryException(\"Cannot compare two literals.  Invalid expression: \" + JexlStringBuildingVisitor.buildQuery(node));\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void validateExpression(JexlNode node, Object data, Object parentData) {\n          \n          \n            \n                    if ((data instanceof MutableInt)) {\n          \n          \n            \n                        if ((((MutableInt) data).intValue() > 1)) {\n          \n          \n            \n                            throw new DatawaveFatalQueryException(\"Cannot compare two literals.  Invalid expression: \" + JexlStringBuildingVisitor.buildQuery(node));\n          \n          \n            \n                        } else if (parentData instanceof MutableInt) {\n          \n          \n            \n                            ((MutableInt)parentData).add((((MutableInt) data).intValue()));\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nYou will obviously have to pass the parent data as the third argument in the various places where this is called.", "author": "jwomeara", "createdAt": "2020-11-03T02:11:43Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidComparisonVisitor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.exceptions.DatawaveFatalQueryException;\n+import org.apache.commons.jexl2.parser.ASTAdditiveNode;\n+import org.apache.commons.jexl2.parser.ASTAssignment;\n+import org.apache.commons.jexl2.parser.ASTDivNode;\n+import org.apache.commons.jexl2.parser.ASTEQNode;\n+import org.apache.commons.jexl2.parser.ASTERNode;\n+import org.apache.commons.jexl2.parser.ASTFalseNode;\n+import org.apache.commons.jexl2.parser.ASTFunctionNode;\n+import org.apache.commons.jexl2.parser.ASTGENode;\n+import org.apache.commons.jexl2.parser.ASTGTNode;\n+import org.apache.commons.jexl2.parser.ASTLENode;\n+import org.apache.commons.jexl2.parser.ASTLTNode;\n+import org.apache.commons.jexl2.parser.ASTMethodNode;\n+import org.apache.commons.jexl2.parser.ASTModNode;\n+import org.apache.commons.jexl2.parser.ASTMulNode;\n+import org.apache.commons.jexl2.parser.ASTNENode;\n+import org.apache.commons.jexl2.parser.ASTNRNode;\n+import org.apache.commons.jexl2.parser.ASTNullLiteral;\n+import org.apache.commons.jexl2.parser.ASTNumberLiteral;\n+import org.apache.commons.jexl2.parser.ASTStringLiteral;\n+import org.apache.commons.jexl2.parser.ASTTrueNode;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.lang3.mutable.MutableInt;\n+\n+/**\n+ * Validates all expressions in a query tree (e.g. literal == literal is considered invalid)\n+ */\n+public class ValidComparisonVisitor extends BaseVisitor {\n+    \n+    public static void check(JexlNode node) {\n+        ValidComparisonVisitor visitor = new ValidComparisonVisitor();\n+        node.jjtAccept(visitor, null);\n+    }\n+    \n+    @Override\n+    public Object visit(ASTFunctionNode node, Object data) {\n+        // not concerned with literals for function nodes\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTMethodNode node, Object data) {\n+        // not concerned with literals for method nodes\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTAdditiveNode node, Object data) {\n+        // not concerned with literals for additive nodes\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTMulNode node, Object data) {\n+        // not concerned with literals for mul nodes\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTDivNode node, Object data) {\n+        // not concerned with literals for div nodes\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTModNode node, Object data) {\n+        // not concerned with literals for mod nodes\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTEQNode node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTNENode node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTLTNode node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTGTNode node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTLENode node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTGENode node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTERNode node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTNRNode node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTAssignment node, Object data) {\n+        validateExpression(node, super.visit(node, new MutableInt()));\n+        return data;\n+    }\n+    \n+    /* literal visitors */\n+    @Override\n+    public Object visit(ASTNumberLiteral node, Object data) {\n+        return visitLiteral(data);\n+    }\n+    \n+    @Override\n+    public Object visit(ASTTrueNode node, Object data) {\n+        return visitLiteral(data);\n+    }\n+    \n+    @Override\n+    public Object visit(ASTFalseNode node, Object data) {\n+        return visitLiteral(data);\n+    }\n+    \n+    @Override\n+    public Object visit(ASTNullLiteral node, Object data) {\n+        return visitLiteral(data);\n+    }\n+    \n+    @Override\n+    public Object visit(ASTStringLiteral node, Object data) {\n+        return visitLiteral(data);\n+    }\n+    \n+    private Object visitLiteral(Object data) {\n+        if (data instanceof MutableInt) {\n+            ((MutableInt) data).increment();\n+        }\n+        return data;\n+    }\n+    \n+    private void validateExpression(JexlNode node, Object data) {\n+        if ((data instanceof MutableInt) && (((MutableInt) data).intValue() > 1)) {\n+            throw new DatawaveFatalQueryException(\"Cannot compare two literals.  Invalid expression: \" + JexlStringBuildingVisitor.buildQuery(node));\n+        }\n+    }", "originalCommit": "c8fef1b73aa91deaecd9f6c86fbf38c66e7509e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcwNTM4MA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/978#discussion_r516705380", "bodyText": "See previous comment.", "author": "ivakegg", "createdAt": "2020-11-03T14:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzU3NA=="}], "type": "inlineReview"}, {"oid": "291aef681546062d7244aa2ab2698699c7e52a02", "url": "https://github.com/NationalSecurityAgency/datawave/commit/291aef681546062d7244aa2ab2698699c7e52a02", "message": "Merge branch 'master' into bugfix/DATAWAVE-976", "committedDate": "2020-11-05T13:40:01Z", "type": "commit"}, {"oid": "23fe970f74e90db26d1617a51c552a6d73930f62", "url": "https://github.com/NationalSecurityAgency/datawave/commit/23fe970f74e90db26d1617a51c552a6d73930f62", "message": "Merge branch 'master' into bugfix/DATAWAVE-976", "committedDate": "2020-11-09T21:49:53Z", "type": "commit"}]}