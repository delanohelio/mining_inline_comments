{"pr_number": 926, "pr_title": "Change to mark bounded ranges in JEXL", "pr_createdAt": "2020-09-28T14:11:36Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/926", "timeline": [{"oid": "e947c218927e2fb162a7d9f701dcdb40ffb0e44b", "url": "https://github.com/NationalSecurityAgency/datawave/commit/e947c218927e2fb162a7d9f701dcdb40ffb0e44b", "message": "re #902: formatting", "committedDate": "2020-10-01T17:28:10Z", "type": "forcePushed"}, {"oid": "59a903a9cc9ee77886a3309bc807436a2d66faaa", "url": "https://github.com/NationalSecurityAgency/datawave/commit/59a903a9cc9ee77886a3309bc807436a2d66faaa", "message": "re #902: formatting", "committedDate": "2020-10-02T13:31:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5OTM0Ng==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516199346", "bodyText": "shouldn't these be LT/LTE and GT/GTE in order to detect a bounded range?", "author": "FineAndDandy", "createdAt": "2020-11-02T19:17:00Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/BoundedRangeDetectionVisitor.java", "diffHunk": "@@ -28,29 +38,45 @@ public static boolean mustExpandBoundedRange(ShardQueryConfiguration config, Met\n     }\n     \n     @Override\n-    public Object visit(ASTERNode node, Object data) {\n-        if (null != data) {\n-            AtomicBoolean hasBounded = (AtomicBoolean) data;\n-            hasBounded.set(true);\n+    public Object visit(ASTReference node, Object data) {\n+        if (BoundedRange.instanceOf(node)) {\n+            LiteralRange range = JexlASTHelper.findRange().getRange(node);\n+            try {\n+                if (helper.getNonEventFields(config.getDatatypeFilter()).contains(range.getFieldName())) {\n+                    if (null != data) {\n+                        AtomicBoolean hasBounded = (AtomicBoolean) data;\n+                        hasBounded.set(true);\n+                    }\n+                }\n+            } catch (TableNotFoundException e) {\n+                throw new DatawaveFatalQueryException(\"Cannot access metadata\", e);\n+            }\n+            \n+            return false;\n+        } else {\n+            return super.visit(node, data);\n         }\n-        \n-        return false;\n-        \n     }\n     \n     @Override\n-    public Object visit(ASTNRNode node, Object data) {\n-        if (null != data) {\n-            AtomicBoolean hasBounded = (AtomicBoolean) data;\n-            hasBounded.set(true);\n+    public Object visit(ASTERNode node, Object data) {", "originalCommit": "2bfbaeb558c97cde50dc66243bbb5ee61862bbf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI0NTkwOA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516245908", "bodyText": "All I did here was replace the visit(ASTLTNode) and visit(ASTGTNode) with the detection of the BoundedRange marker in visit(ASTReference).  If you look where this thing is used, it is also looking for ER and NR nodes.  I do concur that the initial implementation was missing LE and GE node checks.  By changing this to look for BoundedRange markers, I essentially have made that change.", "author": "ivakegg", "createdAt": "2020-11-02T20:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5OTM0Ng=="}], "type": "inlineReview"}, {"oid": "317e8815eb1948375ec4445c768189d25e789e01", "url": "https://github.com/NationalSecurityAgency/datawave/commit/317e8815eb1948375ec4445c768189d25e789e01", "message": "re #902: Change JEXL to enforce using a BoundedRange marker for bounded ranges.\n * Added a visitor to detect invalid marked bounded ranges and ranges that are not marked.\n * Unexpanded bounded ranges not ivarated are non-executable (from an index point of view)", "committedDate": "2020-11-02T18:14:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5MDg3Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516790873", "bodyText": "Looks like there are four different instances of a method with this name. Is there a need to maintain different copies? If so, what is unique about this instance?", "author": "apmoriarty", "createdAt": "2020-11-03T16:20:03Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ExpandMultiNormalizedTerms.java", "diffHunk": "@@ -356,4 +290,20 @@ protected JexlNode expandNodeForNormalizers(JexlNode node, Object data) {\n         }\n         return nodeToReturn;\n     }\n+    \n+    /**\n+     * method to return if the current node is an instance of a delayed predicate\n+     *\n+     * @param currNode\n+     * @return\n+     */\n+    protected boolean isDelayedPredicate(JexlNode currNode) {", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk2NjgwOQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545966809", "bodyText": "removed", "author": "ivakegg", "createdAt": "2020-12-18T17:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5MDg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMDYxNA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516800614", "bodyText": "Looks like this import and commented code can get removed.", "author": "apmoriarty", "createdAt": "2020-11-03T16:33:35Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/QueryPruningVisitor.java", "diffHunk": "@@ -253,6 +253,11 @@ public Object visit(ASTOrNode node, Object data) {\n     \n     @Override\n     public Object visit(ASTAndNode node, Object data) {", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMjQ4OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516802489", "bodyText": "Should this be log.error?", "author": "apmoriarty", "createdAt": "2020-11-03T16:36:16Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeConjunctionRebuildingVisitor.java", "diffHunk": "@@ -117,335 +111,43 @@ public Object visit(ASTReference node, Object data) {\n                 ExceededValueThresholdMarkerJexlNode.class, ExceededTermThresholdMarkerJexlNode.class, ExceededOrThresholdMarkerJexlNode.class});\n         if (QueryPropertyMarkerVisitor.instanceOf(node, markers, null)) {\n             return node;\n-        } else\n-            return super.visit(node, data);\n-    }\n-    \n-    @Override\n-    public Object visit(ASTLTNode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTGTNode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTLENode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTGENode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTAndNode node, Object data) {\n-        List<JexlNode> leaves = new ArrayList<>();\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = JexlASTHelper.getBoundedRanges(node, this.config.getDatatypeFilter(), this.helper, leaves, false);\n-        \n-        JexlNode andNode = JexlNodes.newInstanceOfType(node);\n-        andNode.image = node.image;\n-        andNode.jjtSetParent(node.jjtGetParent());\n-        \n-        // We have a bounded range completely inside of an AND/OR\n-        if (!ranges.isEmpty()) {\n-            andNode = expandIndexBoundedRange(ranges, leaves, node, andNode, data);\n-        } else {\n-            // We have no bounded range to replace, just proceed as normal\n-            JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n-            for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n-                JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n-                \n-                andNode.jjtAddChild(newChild, i);\n-                newChild.jjtSetParent(andNode);\n+        } else if (BoundedRange.instanceOf(node)) {\n+            LiteralRange range = JexlASTHelper.findRange().indexedOnly(this.config.getDatatypeFilter(), this.helper).notDelayed().getRange(node);\n+            if (range != null) {\n+                return expandIndexBoundedRange(range, node);\n+            } else {\n+                return super.visit(node, data);\n             }\n+        } else {\n+            return super.visit(node, data);\n         }\n-        \n-        return andNode;\n     }\n     \n-    protected JexlNode expandIndexBoundedRange(Map<LiteralRange<?>,List<JexlNode>> ranges, List<JexlNode> leaves, ASTAndNode currentNode, JexlNode newNode,\n-                    Object data) {\n-        // Add all children in this AND/OR which are not a part of the range\n-        JexlNodes.ensureCapacity(newNode, leaves.size() + ranges.size());\n-        int index = 0;\n-        for (; index < leaves.size(); index++) {\n-            log.debug(leaves.get(index).image);\n-            // Add each child which is not a part of the bounded range, visiting them first\n-            JexlNode visitedChild = (JexlNode) leaves.get(index).jjtAccept(this, null);\n-            newNode.jjtAddChild(visitedChild, index);\n-            visitedChild.jjtSetParent(newNode);\n-        }\n-        \n-        // Sanity check to ensure that we found some nodes (redundant since we couldn't have made a bounded LiteralRange in the first\n-        // place if we had found not range nodes)\n-        if (ranges.isEmpty()) {\n+    protected JexlNode expandIndexBoundedRange(LiteralRange range, ASTReference currentNode) {\n+        // Sanity check to ensure that we found a range (redundant since we couldn't have made a bounded LiteralRange in the first\n+        // place if we had found no range nodes)\n+        if (range == null) {\n             log.debug(\"Cannot find range operator nodes that encompass this query. Not proceeding with range expansion for this node.\");\n             return currentNode;\n         }\n         \n-        for (Map.Entry<LiteralRange<?>,List<JexlNode>> range : ranges.entrySet()) {\n-            IndexLookup lookup = ShardIndexQueryTableStaticMethods.expandRange(range.getKey());\n-            \n-            IndexLookupMap fieldsToTerms = null;\n-            \n-            try {\n-                fieldsToTerms = lookup.lookup(config, scannerFactory, config.getMaxIndexScanTimeMillis());\n-            } catch (IllegalRangeArgumentException e) {\n-                log.info(\"Cannot expand \"\n-                                + range\n-                                + \" because it creates an invalid Accumulo Range. This is likely due to bad user input or failed normalization. This range will be ignored.\");\n-                return RebuildingVisitor.copy(currentNode);\n-            }\n-            \n-            // If we have any terms that we expanded, wrap them in parens and add them to the parent\n-            ASTAndNode onlyRangeNodes = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-            \n-            JexlNodes.ensureCapacity(onlyRangeNodes, range.getValue().size());\n-            for (int i = 0; i < range.getValue().size(); i++) {\n-                onlyRangeNodes.jjtAddChild(range.getValue().get(i), i);\n-            }\n-            \n-            JexlNode orNode = JexlNodeFactory.createNodeTreeFromFieldsToValues(JexlNodeFactory.ContainerType.OR_NODE, new ASTEQNode(\n-                            ParserTreeConstants.JJTEQNODE), onlyRangeNodes, fieldsToTerms, expandFields, expandValues, false);\n-            \n-            // Set the parent and child pointers accordingly\n-            orNode.jjtSetParent(newNode);\n-            newNode.jjtAddChild(orNode, index++);\n-            \n-        }\n+        IndexLookup lookup = ShardIndexQueryTableStaticMethods.expandRange(range);\n         \n-        // If we had no other nodes than this bounded range, we can strip out the original parent\n-        if (newNode.jjtGetNumChildren() == 1) {\n-            newNode.jjtGetChild(0).jjtSetParent(newNode.jjtGetParent());\n-            return newNode.jjtGetChild(0);\n-        }\n+        IndexLookupMap fieldsToTerms = null;\n         \n-        return newNode;\n-    }\n-    \n-    /**\n-     * We only want to expand a range if it is more selective than a node it is ANDed with.\n-     *\n-     * @param node\n-     * @param range\n-     * @return\n-     */\n-    public boolean shouldExpandRangeBasedOnSelectivity(JexlNode node, LiteralRange<?> range) {\n-        return shouldExpandRangeBasedOnSelectivity(node, range, IndexStatsClient.DEFAULT_VALUE);\n-    }\n-    \n-    /**\n-     * We only want to expand a range if it is more selective than a node it is ANDed with.\n-     *\n-     * @param node\n-     * @param range\n-     * @param rangeSelectivity\n-     * @return\n-     */\n-    protected boolean shouldExpandRangeBasedOnSelectivity(JexlNode node, LiteralRange<?> range, Double rangeSelectivity) {\n-        switch (id(node)) {\n-            case ParserTreeConstants.JJTGENODE:\n-            case ParserTreeConstants.JJTGTNODE:\n-            case ParserTreeConstants.JJTLENODE:\n-            case ParserTreeConstants.JJTLTNODE:\n-            case ParserTreeConstants.JJTREFERENCE:\n-            case ParserTreeConstants.JJTREFERENCEEXPRESSION:\n-                // recurse up the tree\n-                return shouldExpandRangeBasedOnSelectivity(node.jjtGetParent(), range, rangeSelectivity);\n-            case ParserTreeConstants.JJTANDNODE:\n-                boolean foundChildSelectivity = false;\n-                if (rangeSelectivity.equals(IndexStatsClient.DEFAULT_VALUE)) {\n-                    // only want to fetch the range selectivity once\n-                    rangeSelectivity = JexlASTHelper.getNodeSelectivity(Sets.newHashSet(range.getFieldName()), config, stats);\n-                    if (log.isDebugEnabled())\n-                        log.debug(\"Range selectivity:\" + rangeSelectivity);\n-                }\n-                for (JexlNode child : JexlASTHelper.getEQNodes(node)) {\n-                    // Try to get selectivity for each child\n-                    Double childSelectivity = JexlASTHelper.getNodeSelectivity(child, config, stats);\n-                    \n-                    if (childSelectivity.equals(IndexStatsClient.DEFAULT_VALUE)) {\n-                        continue;\n-                    } else {\n-                        foundChildSelectivity = true;\n-                    }\n-                    \n-                    if (log.isDebugEnabled() && foundChildSelectivity)\n-                        log.debug(\"Max Child selectivity: \" + childSelectivity);\n-                    \n-                    // If the child is an EQ node, is indexed, and is more\n-                    // selective than the regex we don't need to process the regex\n-                    if (JexlASTHelper.getIdentifierOpLiteral(child) != null && JexlASTHelper.isIndexed(child, config) && rangeSelectivity < childSelectivity) {\n-                        return false;\n-                    }\n-                }\n-                \n-                return shouldExpandRangeBasedOnSelectivity(node.jjtGetParent(), range, rangeSelectivity);\n-            default:\n-                return true;\n-        }\n-    }\n-    \n-    /**\n-     * Walks up an AST and evaluates subtrees as needed. This method will fail fast if we determine we do not have to process a regex, otherwise the entire tree\n-     * will be evaluated.\n-     * \n-     * This method recurses upwards, searching for an AND or OR node in the lineage. Once of those nodes is found, then the subtree rooted at that node is\n-     * evaluated. The visit map is used to cache already evaluated subtrees, so moving to a parent will not cause a subtree to be evaluated along with its\n-     * unevaluated siblings.\n-     * \n-     * @param node\n-     *            - node to consider\n-     * \n-     * @param visited\n-     *            - a visit list that contains the computed values for subtrees already visited, in case they are needed\n-     * \n-     * @return true - if a regex has to be expanded false - if a regex doesn't have to be expanded\n-     */\n-    private boolean ascendTree(JexlNode node, Map<JexlNode,Boolean> visited) {\n-        if (node == null) {\n-            return true;\n-        } else {\n-            switch (id(node)) {\n-                case ParserTreeConstants.JJTORNODE:\n-                case ParserTreeConstants.JJTANDNODE: {\n-                    boolean expand = descendIntoSubtree(node, visited);\n-                    if (expand) {\n-                        return ascendTree(node.jjtGetParent(), visited);\n-                    } else {\n-                        return expand;\n-                    }\n-                }\n-                default:\n-                    return ascendTree(node.jjtGetParent(), visited);\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * Evaluates a subtree to see if it can prevent the expansion of a regular expression.\n-     * \n-     * This method recurses down under three conditions:\n-     * \n-     * 1) An OR is encountered. In this case the result of recursing down the subtrees rooted at each child is OR'd together and returned. 2) An AND is\n-     * encountered. In this case the result of recursing down the subtrees rooted at each child is AND'd together and returned. 3) Any node that is not an EQ\n-     * node and has only 1 child. If there are multiple children, this method returns true, indicating that the subtree cannot defeat a regex expansion.\n-     * \n-     * If an EQ node is encountered, we check if it can defeat an expansion by returning the value of a call to `doesNodeSupportRegexExpansion` on the node.\n-     * \n-     * @param node\n-     * \n-     * @return true - if a regex has to be expanded false - if a regex doesn't have to be expanded\n-     */\n-    private boolean descendIntoSubtree(JexlNode node, Map<JexlNode,Boolean> visited) {\n-        switch (id(node)) {\n-            case ParserTreeConstants.JJTORNODE: {\n-                return computeExpansionForSubtree(node, Join.OR, visited);\n-            }\n-            case ParserTreeConstants.JJTANDNODE: {\n-                return computeExpansionForSubtree(node, Join.AND, visited);\n-            }\n-            case ParserTreeConstants.JJTEQNODE: {\n-                boolean expand = doesNodeSupportRegexExpansion(node);\n-                visited.put(node, expand);\n-                return expand;\n-            }\n-            default: {\n-                JexlNode[] children = children(node);\n-                if (children.length == 1) {\n-                    boolean expand = descendIntoSubtree(children[0], visited);\n-                    visited.put(node, expand);\n-                    return expand;\n-                } else {\n-                    return true;\n-                }\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * If we have a literal equality on an indexed field, then this can be used to defeat a wild card expansion.\n-     * \n-     * @return `true` if we should expand a regular expression node given this subtree `false` if we should not expand a regular expression node given this\n-     *         subtree\n-     */\n-    private boolean doesNodeSupportRegexExpansion(JexlNode node) {\n-        return !(node instanceof ASTEQNode && JexlASTHelper.getIdentifierOpLiteral(node) != null && JexlASTHelper.isIndexed(node, config));\n-    }\n-    \n-    /**\n-     * Abstraction to indicate whether to use {@code `&=` or `|=`} when processing a node's subtrees.\n-     */\n-    enum Join {\n-        AND, OR\n-    }\n-    \n-    /**\n-     * The cases for OR and AND in `descendIntoSubtree` were almost equal, save for the initial value for expand and the operator used to join the results of\n-     * each child. I made this little macro doohickey to allow the differences between the two processes to be abstracted away.\n-     * \n-     */\n-    private boolean computeExpansionForSubtree(JexlNode node, Join join, Map<JexlNode,Boolean> visited) {\n-        boolean expand = Join.AND.equals(join);\n-        for (JexlNode child : children(node)) {\n-            Boolean computedValue = visited.get(child);\n-            if (computedValue == null) {\n-                computedValue = descendIntoSubtree(child, visited);\n-                visited.put(child, computedValue);\n-            }\n-            switch (join) {\n-                case AND:\n-                    expand &= computedValue;\n-                    break;\n-                case OR:\n-                    expand |= computedValue;\n-            }\n-        }\n-        visited.put(node, expand);\n-        return expand;\n-    }\n-    \n-    public void collapseAndSubtrees(ASTAndNode node, List<JexlNode> subTrees) {\n-        for (JexlNode child : children(node)) {\n-            if (ParserTreeConstants.JJTANDNODE == id(child)) {\n-                collapseAndSubtrees((ASTAndNode) child, subTrees);\n-            } else {\n-                subTrees.add(child);\n-            }\n+        try {\n+            fieldsToTerms = lookup.lookup(config, scannerFactory, config.getMaxIndexScanTimeMillis());\n+        } catch (IllegalRangeArgumentException e) {\n+            log.info(\"Cannot expand \"", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk2NzM4OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545967389", "bodyText": "sure, why not", "author": "ivakegg", "createdAt": "2020-12-18T17:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMjQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMDAwMw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516810003", "bodyText": "Is it temporary or not?", "author": "apmoriarty", "createdAt": "2020-11-03T16:46:52Z", "path": "warehouse/query-core/src/main/java/datawave/query/planner/DefaultQueryPlanner.java", "diffHunk": "@@ -670,6 +676,11 @@ protected ASTJexlScript updateQueryTree(ScannerFactory scannerFactory, MetadataH\n         \n         stopwatch.stop();\n         \n+        // TEMPORARY?: CHECK FOR UNMARKED BOUNDED RANGES", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMTQ3MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516811471", "bodyText": "stray import", "author": "apmoriarty", "createdAt": "2020-11-03T16:48:48Z", "path": "warehouse/query-core/src/test/java/datawave/query/DelayedIndexOnlyQueryTest.java", "diffHunk": "@@ -7,6 +7,7 @@\n import datawave.query.testframework.DataTypeHadoopConfig;\n import datawave.query.testframework.FieldConfig;\n import datawave.query.testframework.GenericCityFields;\n+import org.apache.log4j.Level;", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk2Nzg2OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545967868", "bodyText": "making not temporary", "author": "ivakegg", "createdAt": "2020-12-18T17:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMTQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMTkyOA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516811928", "bodyText": "Founded is such a fun word.", "author": "apmoriarty", "createdAt": "2020-11-03T16:49:27Z", "path": "warehouse/query-core/src/test/java/datawave/query/GroupedFlattenQueryTest.java", "diffHunk": "@@ -114,13 +114,26 @@ public void testCounty() throws Exception {\n     }\n     \n     @Test\n-    public void testFoundedRange() throws Exception {\n+    public void testFoundedRangeUnbounded() throws Exception {\n         log.info(\"------  testFoundedRange  ------\");\n         String start = \"1850\";\n         String end = \"1860\";\n         String city = \"'AuStiN'\";\n-        String query = GroupedField.CITY.name() + EQ_OP + city + AND_OP + \"(\" + GroupedField.FOUNDED.name() + GT_OP + start + AND_OP\n-                        + GroupedField.FOUNDED.name() + LT_OP + end + \")\";\n+        String query = GroupedField.CITY.name() + EQ_OP + city + AND_OP + GroupedField.FOUNDED.name() + GT_OP + start + AND_OP + GroupedField.FOUNDED.name()\n+                        + LT_OP + end;\n+        // all entries have at least one founded less than end and one founded greater than start, just not the same value.", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczNjA1OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516736058", "bodyText": "reuse JexlASTHelper.isDelayedPredicate()", "author": "FineAndDandy", "createdAt": "2020-11-03T15:06:18Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ExpandMultiNormalizedTerms.java", "diffHunk": "@@ -356,4 +290,20 @@ protected JexlNode expandNodeForNormalizers(JexlNode node, Object data) {\n         }\n         return nodeToReturn;\n     }\n+    \n+    /**\n+     * method to return if the current node is an instance of a delayed predicate\n+     *\n+     * @param currNode\n+     * @return\n+     */\n+    protected boolean isDelayedPredicate(JexlNode currNode) {", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MTI4MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516771281", "bodyText": "LiteralRange already includes Key. Do we need to do the conversions to string here?", "author": "FineAndDandy", "createdAt": "2020-11-03T15:52:49Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/PushdownLargeFieldedListsVisitor.java", "diffHunk": "@@ -216,15 +218,10 @@ private void copyChildren(Collection<JexlNode> children, Collection<JexlNode> co\n     }\n     \n     protected Range rangeNodeToRange(JexlNode node) {\n-        if (ExceededValueThresholdMarkerJexlNode.instanceOf(node)) {\n-            return rangeNodeToRange(ExceededValueThresholdMarkerJexlNode.getExceededValueThresholdSource(node));\n-        } else if ((node.jjtGetNumChildren() == 1) && (node instanceof ASTReferenceExpression || node instanceof ASTReference || node instanceof ASTAndNode)) {\n-            return rangeNodeToRange(node.jjtGetChild(0));\n-        } else if ((node.jjtGetNumChildren() == 2) && node instanceof ASTAndNode) {\n-            JexlNode leftChild = node.jjtGetChild(0);\n-            JexlNode rightChild = node.jjtGetChild(1);\n-            return new Range(new Key(String.valueOf(JexlASTHelper.getLiteralValue(leftChild))), leftChild instanceof ASTGENode, new Key(\n-                            String.valueOf(JexlASTHelper.getLiteralValue(rightChild))), rightChild instanceof ASTLENode);\n+        LiteralRange range = JexlASTHelper.findRange().getRange(node);\n+        if (range != null) {\n+            return new Range(new Key(String.valueOf(range.getLower())), range.isLowerInclusive(), new Key(String.valueOf(range.getUpper())),", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MDgyMA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545970820", "bodyText": "I don't get this comment.  LiteralRange does not include Key/", "author": "ivakegg", "createdAt": "2020-12-18T17:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1NjgxMQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546056811", "bodyText": "String.valueOf will not create a new string if the arg is already a string.", "author": "ivakegg", "createdAt": "2020-12-18T19:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MTI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4NDQ4Mg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516784482", "bodyText": "did you mean to revisit this? Or should this comment be removed?", "author": "FineAndDandy", "createdAt": "2020-11-03T16:10:54Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/QueryPruningVisitor.java", "diffHunk": "@@ -253,6 +253,11 @@ public Object visit(ASTOrNode node, Object data) {\n     \n     @Override\n     public Object visit(ASTAndNode node, Object data) {\n+        // do not process query property markers\n+        // if (QueryPropertyMarker.instanceOf(node, null)) {\n+        // return TruthState.UNKNOWN;\n+        // }\n+        ", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk3MjY4Ng==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545972686", "bodyText": "good catch.  I think I was debugging something.  I will remove or reenable as appropriate.", "author": "ivakegg", "createdAt": "2020-12-18T17:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4NDQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwNDU2Ng==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516804566", "bodyText": "can lookup ever be null?", "author": "FineAndDandy", "createdAt": "2020-11-03T16:39:11Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeConjunctionRebuildingVisitor.java", "diffHunk": "@@ -117,335 +111,43 @@ public Object visit(ASTReference node, Object data) {\n                 ExceededValueThresholdMarkerJexlNode.class, ExceededTermThresholdMarkerJexlNode.class, ExceededOrThresholdMarkerJexlNode.class});\n         if (QueryPropertyMarkerVisitor.instanceOf(node, markers, null)) {\n             return node;\n-        } else\n-            return super.visit(node, data);\n-    }\n-    \n-    @Override\n-    public Object visit(ASTLTNode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTGTNode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTLENode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTGENode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTAndNode node, Object data) {\n-        List<JexlNode> leaves = new ArrayList<>();\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = JexlASTHelper.getBoundedRanges(node, this.config.getDatatypeFilter(), this.helper, leaves, false);\n-        \n-        JexlNode andNode = JexlNodes.newInstanceOfType(node);\n-        andNode.image = node.image;\n-        andNode.jjtSetParent(node.jjtGetParent());\n-        \n-        // We have a bounded range completely inside of an AND/OR\n-        if (!ranges.isEmpty()) {\n-            andNode = expandIndexBoundedRange(ranges, leaves, node, andNode, data);\n-        } else {\n-            // We have no bounded range to replace, just proceed as normal\n-            JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n-            for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n-                JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n-                \n-                andNode.jjtAddChild(newChild, i);\n-                newChild.jjtSetParent(andNode);\n+        } else if (BoundedRange.instanceOf(node)) {\n+            LiteralRange range = JexlASTHelper.findRange().indexedOnly(this.config.getDatatypeFilter(), this.helper).notDelayed().getRange(node);\n+            if (range != null) {\n+                return expandIndexBoundedRange(range, node);\n+            } else {\n+                return super.visit(node, data);\n             }\n+        } else {\n+            return super.visit(node, data);\n         }\n-        \n-        return andNode;\n     }\n     \n-    protected JexlNode expandIndexBoundedRange(Map<LiteralRange<?>,List<JexlNode>> ranges, List<JexlNode> leaves, ASTAndNode currentNode, JexlNode newNode,\n-                    Object data) {\n-        // Add all children in this AND/OR which are not a part of the range\n-        JexlNodes.ensureCapacity(newNode, leaves.size() + ranges.size());\n-        int index = 0;\n-        for (; index < leaves.size(); index++) {\n-            log.debug(leaves.get(index).image);\n-            // Add each child which is not a part of the bounded range, visiting them first\n-            JexlNode visitedChild = (JexlNode) leaves.get(index).jjtAccept(this, null);\n-            newNode.jjtAddChild(visitedChild, index);\n-            visitedChild.jjtSetParent(newNode);\n-        }\n-        \n-        // Sanity check to ensure that we found some nodes (redundant since we couldn't have made a bounded LiteralRange in the first\n-        // place if we had found not range nodes)\n-        if (ranges.isEmpty()) {\n+    protected JexlNode expandIndexBoundedRange(LiteralRange range, ASTReference currentNode) {\n+        // Sanity check to ensure that we found a range (redundant since we couldn't have made a bounded LiteralRange in the first\n+        // place if we had found no range nodes)\n+        if (range == null) {\n             log.debug(\"Cannot find range operator nodes that encompass this query. Not proceeding with range expansion for this node.\");\n             return currentNode;\n         }\n         \n-        for (Map.Entry<LiteralRange<?>,List<JexlNode>> range : ranges.entrySet()) {\n-            IndexLookup lookup = ShardIndexQueryTableStaticMethods.expandRange(range.getKey());\n-            \n-            IndexLookupMap fieldsToTerms = null;\n-            \n-            try {\n-                fieldsToTerms = lookup.lookup(config, scannerFactory, config.getMaxIndexScanTimeMillis());\n-            } catch (IllegalRangeArgumentException e) {\n-                log.info(\"Cannot expand \"\n-                                + range\n-                                + \" because it creates an invalid Accumulo Range. This is likely due to bad user input or failed normalization. This range will be ignored.\");\n-                return RebuildingVisitor.copy(currentNode);\n-            }\n-            \n-            // If we have any terms that we expanded, wrap them in parens and add them to the parent\n-            ASTAndNode onlyRangeNodes = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-            \n-            JexlNodes.ensureCapacity(onlyRangeNodes, range.getValue().size());\n-            for (int i = 0; i < range.getValue().size(); i++) {\n-                onlyRangeNodes.jjtAddChild(range.getValue().get(i), i);\n-            }\n-            \n-            JexlNode orNode = JexlNodeFactory.createNodeTreeFromFieldsToValues(JexlNodeFactory.ContainerType.OR_NODE, new ASTEQNode(\n-                            ParserTreeConstants.JJTEQNODE), onlyRangeNodes, fieldsToTerms, expandFields, expandValues, false);\n-            \n-            // Set the parent and child pointers accordingly\n-            orNode.jjtSetParent(newNode);\n-            newNode.jjtAddChild(orNode, index++);\n-            \n-        }\n+        IndexLookup lookup = ShardIndexQueryTableStaticMethods.expandRange(range);", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4MTkzMA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545981930", "bodyText": "nope", "author": "ivakegg", "createdAt": "2020-12-18T17:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwNDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwODcyMQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516808721", "bodyText": "can you explain this case?", "author": "FineAndDandy", "createdAt": "2020-11-03T16:45:17Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/UnmarkedBoundedRangeDetectionVisitor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import datawave.query.jexl.nodes.BoundedRange;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class UnmarkedBoundedRangeDetectionVisitor extends BaseVisitor {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public static boolean findUnmarkedBoundedRanges(JexlNode script) {\n+        UnmarkedBoundedRangeDetectionVisitor visitor = new UnmarkedBoundedRangeDetectionVisitor();\n+        \n+        AtomicBoolean unmarked = new AtomicBoolean(false);\n+        script.jjtAccept(visitor, unmarked);\n+        \n+        return unmarked.get();\n+    }\n+    \n+    @Override\n+    public Object visit(ASTReference node, Object data) {\n+        if (BoundedRange.instanceOf(node)) {\n+            if (!JexlASTHelper.findRange().isRange(node)) {\n+                if (null != data) {\n+                    AtomicBoolean hasBounded = (AtomicBoolean) data;\n+                    hasBounded.set(true);\n+                }\n+            }\n+            \n+            return false;\n+        } else if (JexlASTHelper.findRange().notDelayed().notMarked().isRange(node)) {", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4MzgzNA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545983834", "bodyText": "adding comments", "author": "ivakegg", "createdAt": "2020-12-18T17:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwODcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNTI3Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546005273", "bodyText": "If I understand correctly, this case indicates that we have a bounded range, but it's not marked, and not delayed, whereas the previous case will find a bounded range that's already been marked.", "author": "jwomeara", "createdAt": "2020-12-18T18:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwODcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMTEyMw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516811123", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \n          \n          \n            \n            boolean isBounded = !lowerWildcard && !upperWildcard;\n          \n          \n            \n            if (isBounded) { \n          \n          \n            \n                sb.append(\"((BoundedRange = true) && \");\n          \n          \n            \n            }        \n          \n          \n            \n            ...\n          \n          \n            \n            \n          \n          \n            \n            if (isBounded){\n          \n          \n            \n                sb.append(\")\");\n          \n          \n            \n            }", "author": "FineAndDandy", "createdAt": "2020-11-03T16:48:17Z", "path": "warehouse/query-core/src/main/java/datawave/query/language/parser/jexl/JexlRangeNode.java", "diffHunk": "@@ -37,6 +37,10 @@ public String toString() {\n         boolean lowerWildcard = beginRange.equals(\"*\");\n         boolean upperWildcard = endRange.equals(\"*\");\n         ", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyOTg0MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516829841", "bodyText": "why has this case changed?", "author": "FineAndDandy", "createdAt": "2020-11-03T17:16:15Z", "path": "warehouse/query-core/src/test/java/datawave/query/RangeQueryTest.java", "diffHunk": "@@ -131,26 +139,28 @@ public void testSingleValueAndMultiFieldWithParens() throws Exception {\n         }\n     }\n     \n-    @Test\n+    @Test(expected = FullTableScansDisallowedException.class)", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5MjQ0Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545992443", "bodyText": "Previously this would pull together the bounds as a bounded range.  Now we required ranges to be bounded.  Hence this results only non-executable separate bounds and hence the query requires a full table scan required.", "author": "ivakegg", "createdAt": "2020-12-18T17:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyOTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNDg3OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516834879", "bodyText": "test lower is 1 and upper is 5? also inclusive/exclusive flags?", "author": "FineAndDandy", "createdAt": "2020-11-03T17:23:57Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/JexlASTHelperTest.java", "diffHunk": "@@ -247,38 +249,81 @@ public void testApplyNormalization() throws Throwable {\n     }\n     \n     @Test\n-    public void testNonRangeNodeNegation() throws Exception {\n-        ASTJexlScript script = JexlASTHelper.parseJexlQuery(\"A < 'b' && A > 'a' && !(FOO == 'bar')\");\n+    public void testFindRange() throws Exception {\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(\"((BoundedRange = true) && (A < 'b' && A > 'a')) && !(FOO == 'bar')\");\n         \n-        List<JexlNode> nonRangeChildNodes = new ArrayList<>();\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = JexlASTHelper\n-                        .getBoundedRangesIndexAgnostic((ASTAndNode) (script.jjtGetChild(0)), nonRangeChildNodes, true);\n+        LiteralRange range = JexlASTHelper.findRange().getRange(script.jjtGetChild(0));\n         \n-        Assert.assertEquals(1, ranges.size());\n-        Assert.assertEquals(2, ranges.values().iterator().next().size());\n-        Assert.assertEquals(1, nonRangeChildNodes.size());\n-        Assert.assertEquals(ASTNotNode.class, nonRangeChildNodes.get(0).getClass());\n+        Assert.assertNull(range);\n         \n-        script = JexlASTHelper.parseJexlQuery(\"A < 5 && A > 1 && !(FOO == 'bar' && !(BAR == 'foo') && BAR != 'foo')\");\n+        script = JexlASTHelper.parseJexlQuery(\"(A < 5 && A > 1)\");\n         \n-        nonRangeChildNodes.clear();\n-        ranges = JexlASTHelper.getBoundedRangesIndexAgnostic((ASTAndNode) (script.jjtGetChild(0)), nonRangeChildNodes, true);\n+        range = JexlASTHelper.findRange().getRange(script.jjtGetChild(0));\n         \n-        Assert.assertEquals(1, ranges.size());\n-        Assert.assertEquals(2, ranges.values().iterator().next().size());\n-        Assert.assertEquals(1, nonRangeChildNodes.size());\n-        Assert.assertEquals(ASTNotNode.class, nonRangeChildNodes.get(0).getClass());\n+        Assert.assertNull(range);\n         \n-        script = JexlASTHelper\n-                        .parseJexlQuery(\"A < 5 && A > 1 && !(FOO == 'term' && !(BAR =~ 'regex') && BAR !~ 'regex' && (BAR != 'term') && ! (BAR == 'term') && FOO =~ 'regex')\");\n+        script = JexlASTHelper.parseJexlQuery(\"((BoundedRange = true) && (A < 5 && A > 1))\");\n         \n-        nonRangeChildNodes.clear();\n-        ranges = JexlASTHelper.getBoundedRangesIndexAgnostic((ASTAndNode) (script.jjtGetChild(0)), nonRangeChildNodes, true);\n+        range = JexlASTHelper.findRange().getRange(script.jjtGetChild(0));\n         \n-        Assert.assertEquals(1, ranges.size());\n-        Assert.assertEquals(2, ranges.values().iterator().next().size());\n-        Assert.assertEquals(1, nonRangeChildNodes.size());\n-        Assert.assertEquals(ASTNotNode.class, nonRangeChildNodes.get(0).getClass());\n+        Assert.assertNotNull(range);\n+        Assert.assertNotNull(range.getLowerNode());\n+        Assert.assertNotNull(range.getUpperNode());", "originalCommit": "317e8815eb1948375ec4445c768189d25e789e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5Mjc4Nw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545992787", "bodyText": "good idea", "author": "ivakegg", "createdAt": "2020-12-18T17:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNDg3OQ=="}], "type": "inlineReview"}, {"oid": "1913c941c58dd01d84a7ea384d8356054a855778", "url": "https://github.com/NationalSecurityAgency/datawave/commit/1913c941c58dd01d84a7ea384d8356054a855778", "message": "re #902: Change JEXL to enforce using a BoundedRange marker for bounded ranges.\n * Added a visitor to detect invalid marked bounded ranges and ranges that are not marked.\n * Unexpanded bounded ranges not ivarated are non-executable (from an index point of view)", "committedDate": "2020-12-17T23:16:33Z", "type": "commit"}, {"oid": "1913c941c58dd01d84a7ea384d8356054a855778", "url": "https://github.com/NationalSecurityAgency/datawave/commit/1913c941c58dd01d84a7ea384d8356054a855778", "message": "re #902: Change JEXL to enforce using a BoundedRange marker for bounded ranges.\n * Added a visitor to detect invalid marked bounded ranges and ranges that are not marked.\n * Unexpanded bounded ranges not ivarated are non-executable (from an index point of view)", "committedDate": "2020-12-17T23:16:33Z", "type": "forcePushed"}, {"oid": "b61bebef50e12079a2d6d9bb23091dacd4570f00", "url": "https://github.com/NationalSecurityAgency/datawave/commit/b61bebef50e12079a2d6d9bb23091dacd4570f00", "message": "spotbug fixes", "committedDate": "2020-12-18T15:01:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNDI1Ng==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545924256", "bodyText": "Maybe 'literal' and 'literal2' to avoid 'l1'?", "author": "apmoriarty", "createdAt": "2020-12-18T15:52:43Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,364 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {\n+                node = QueryPropertyMarker.getQueryPropertySource(node, null);\n+                marked = BoundedRange.instanceOf(node);\n+            }\n+            \n+            // It must be marked\n+            if (withMarker && !marked) {\n+                return null;\n+            }\n+            \n+            // remove the marker\n+            if (marked) {\n+                node = BoundedRange.getBoundedRangeSource(node);\n+            }\n+            \n+            // remove reference and expression nodes\n+            node = dereference(node);\n+            \n+            // must be an and node at this point\n+            if (!(node instanceof ASTAndNode)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain an AND node with two bounds\");\n+                return null;\n+            }\n+            \n+            // and has exactly two children\n+            if (node.jjtGetNumChildren() != 2) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds\");\n+                return null;\n+            }\n+            \n+            JexlNode child1 = dereference(node.jjtGetChild(0));\n+            JexlNode child2 = dereference(node.jjtGetChild(1));\n+            \n+            // and the fieldnames match\n+            String fieldName1 = null;\n+            String fieldName2 = null;\n+            try {\n+                fieldName1 = JexlASTHelper.getIdentifier(child1);\n+                fieldName2 = JexlASTHelper.getIdentifier(child2);\n+            } catch (NoSuchElementException e) {}\n+            if (fieldName1 == null || fieldName2 == null || !fieldName1.equals(fieldName2)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds against the same field\");\n+                return null;\n+            }\n+            \n+            // and is indexed (if we care) {\n+            try {\n+                if (helper != null && !helper.isIndexed(fieldName1, dataTypeFilter)) {\n+                    return null;\n+                }\n+            } catch (TableNotFoundException tnfe) {\n+                NotFoundQueryException qe = new NotFoundQueryException(DatawaveErrorCode.TABLE_NOT_FOUND, tnfe);\n+                throw new DatawaveFatalQueryException(qe);\n+            }\n+            \n+            Object literal1 = null;\n+            Object literal2 = null;\n+            try {\n+                literal1 = JexlASTHelper.getLiteralValue(child1);\n+                literal2 = JexlASTHelper.getLiteralValue(child2);\n+            } catch (NoSuchElementException e) {}\n+            \n+            if (literal1 == null || literal2 == null) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds with literals\");\n+                return null;\n+            }\n             \n             LiteralRange<?> range = null;\n-            List<JexlNode> thisRangesNodes = new ArrayList<>();\n-            if (literal instanceof String) {\n-                range = getStringBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof Integer) {\n-                range = getIntegerBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof Long) {\n-                range = getLongBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof BigInteger) {\n-                range = getBigIntegerBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof Float) {\n-                range = getFloatBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof Double) {\n-                range = getDoubleBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof BigDecimal) {\n-                range = getBigDecimalBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n+            JexlNode[] children = new JexlNode[] {child1, child2};\n+            if (literal1 instanceof String || literal2 instanceof String) {", "originalCommit": "b61bebef50e12079a2d6d9bb23091dacd4570f00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NjA5Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545986093", "bodyText": "nah, I like literal1 and literal2", "author": "ivakegg", "createdAt": "2020-12-18T17:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNDI1Ng=="}], "type": "inlineReview"}, {"oid": "a3f764c18b3b56405cf296cbdcacc03000b9612a", "url": "https://github.com/NationalSecurityAgency/datawave/commit/a3f764c18b3b56405cf296cbdcacc03000b9612a", "message": "re #902: Updated per review comments", "committedDate": "2020-12-18T17:43:44Z", "type": "commit"}, {"oid": "2df4a4a08dccd327f73a7c32d255b49895eb81d1", "url": "https://github.com/NationalSecurityAgency/datawave/commit/2df4a4a08dccd327f73a7c32d255b49895eb81d1", "message": "re #902: better test case", "committedDate": "2020-12-18T17:58:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkzNDg1Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545934853", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean success = true;\n          \n          \n            \n                    if (node instanceof ASTAndNode)\n          \n          \n            \n                        for (int i = 0; i < node.jjtGetNumChildren(); i++)\n          \n          \n            \n                            success &= this.jexlNodeListLowerBound.contains(node.jjtGetChild(i)) || this.jexlNodeListUpperBound.contains(node.jjtGetChild(i));\n          \n          \n            \n                    LiteralRange range = JexlASTHelper.findRange().getRange(node);\n          \n          \n            \n                    if (range != null)\n          \n          \n            \n                        success &= this.jexlNodeListLowerBound.contains(range.getLowerNode()) && this.jexlNodeListUpperBound.contains(range.getUpperNode());\n          \n          \n            \n                    boolean success;\n          \n          \n            \n                    LiteralRange range = JexlASTHelper.findRange().getRange(node);\n          \n          \n            \n                    if (range != null)\n          \n          \n            \n                        success = this.jexlNodeListLowerBound.contains(range.getLowerNode()) && this.jexlNodeListUpperBound.contains(range.getUpperNode());", "author": "jwomeara", "createdAt": "2020-12-18T16:10:46Z", "path": "warehouse/query-core/src/main/java/datawave/query/composite/CompositeRange.java", "diffHunk": "@@ -305,9 +308,9 @@ public boolean isValid() {\n     \n     public boolean contains(JexlNode node) {\n         boolean success = true;\n-        if (node instanceof ASTAndNode)\n-            for (int i = 0; i < node.jjtGetNumChildren(); i++)\n-                success &= this.jexlNodeListLowerBound.contains(node.jjtGetChild(i)) || this.jexlNodeListUpperBound.contains(node.jjtGetChild(i));\n+        LiteralRange range = JexlASTHelper.findRange().getRange(node);\n+        if (range != null)\n+            success &= this.jexlNodeListLowerBound.contains(range.getLowerNode()) && this.jexlNodeListUpperBound.contains(range.getUpperNode());", "originalCommit": "1913c941c58dd01d84a7ea384d8356054a855778", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkzNTA0MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545935041", "bodyText": "fix my bad code, please!", "author": "jwomeara", "createdAt": "2020-12-18T16:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkzNDg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzODUwMQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546038501", "bodyText": "ok", "author": "ivakegg", "createdAt": "2020-12-18T19:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkzNDg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0MTg2NA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545941864", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {\n          \n          \n            \n                        if (includeDelayed && !marked && QueryPropertyMarker.instanceOf(node, null)) {\n          \n      \n    \n    \n  \n\nIf we already know that it's marked, let's not visit the tree a second time.", "author": "jwomeara", "createdAt": "2020-12-18T16:22:25Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,365 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {", "originalCommit": "1913c941c58dd01d84a7ea384d8356054a855778", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0MjkyMQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545942921", "bodyText": "Also, at some point we should update the QueryPropertyMarker.instanceOf method to return the marker class that was found if null is passed in for the type.  That way we can do a single pass and know exactly what we're dealing with.", "author": "jwomeara", "createdAt": "2020-12-18T16:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0MTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0NjUzMA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545946530", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (NoSuchElementException e) {}\n          \n          \n            \n                        } catch (NoSuchElementException ignored) {}\n          \n      \n    \n    \n  \n\nThis removes the warning in intellij.", "author": "jwomeara", "createdAt": "2020-12-18T16:30:14Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,365 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {\n+                node = QueryPropertyMarker.getQueryPropertySource(node, null);\n+                marked = BoundedRange.instanceOf(node);\n+            }\n+            \n+            // It must be marked\n+            if (withMarker && !marked) {\n+                return null;\n+            }\n+            \n+            // remove the marker\n+            if (marked) {\n+                node = BoundedRange.getBoundedRangeSource(node);\n+            }\n+            \n+            // remove reference and expression nodes\n+            node = dereference(node);\n+            \n+            // must be an and node at this point\n+            if (!(node instanceof ASTAndNode)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain an AND node with two bounds\");\n+                return null;\n+            }\n+            \n+            // and has exactly two children\n+            if (node.jjtGetNumChildren() != 2) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds\");\n+                return null;\n+            }\n+            \n+            JexlNode child1 = dereference(node.jjtGetChild(0));\n+            JexlNode child2 = dereference(node.jjtGetChild(1));\n+            \n+            // and the fieldnames match\n+            String fieldName1 = null;\n+            String fieldName2 = null;\n+            try {\n+                fieldName1 = JexlASTHelper.getIdentifier(child1);\n+                fieldName2 = JexlASTHelper.getIdentifier(child2);\n+            } catch (NoSuchElementException e) {}", "originalCommit": "1913c941c58dd01d84a7ea384d8356054a855778", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0Njg5MA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545946890", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (NoSuchElementException e) {}\n          \n          \n            \n                        } catch (NoSuchElementException ignored) {}", "author": "jwomeara", "createdAt": "2020-12-18T16:30:49Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,365 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {\n+                node = QueryPropertyMarker.getQueryPropertySource(node, null);\n+                marked = BoundedRange.instanceOf(node);\n+            }\n+            \n+            // It must be marked\n+            if (withMarker && !marked) {\n+                return null;\n+            }\n+            \n+            // remove the marker\n+            if (marked) {\n+                node = BoundedRange.getBoundedRangeSource(node);\n+            }\n+            \n+            // remove reference and expression nodes\n+            node = dereference(node);\n+            \n+            // must be an and node at this point\n+            if (!(node instanceof ASTAndNode)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain an AND node with two bounds\");\n+                return null;\n+            }\n+            \n+            // and has exactly two children\n+            if (node.jjtGetNumChildren() != 2) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds\");\n+                return null;\n+            }\n+            \n+            JexlNode child1 = dereference(node.jjtGetChild(0));\n+            JexlNode child2 = dereference(node.jjtGetChild(1));\n+            \n+            // and the fieldnames match\n+            String fieldName1 = null;\n+            String fieldName2 = null;\n+            try {\n+                fieldName1 = JexlASTHelper.getIdentifier(child1);\n+                fieldName2 = JexlASTHelper.getIdentifier(child2);\n+            } catch (NoSuchElementException e) {}\n+            if (fieldName1 == null || fieldName2 == null || !fieldName1.equals(fieldName2)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds against the same field\");\n+                return null;\n+            }\n+            \n+            // and is indexed (if we care) {\n+            try {\n+                if (helper != null && !helper.isIndexed(fieldName1, dataTypeFilter)) {\n+                    return null;\n+                }\n+            } catch (TableNotFoundException tnfe) {\n+                NotFoundQueryException qe = new NotFoundQueryException(DatawaveErrorCode.TABLE_NOT_FOUND, tnfe);\n+                throw new DatawaveFatalQueryException(qe);\n+            }\n+            \n+            Object literal1 = null;\n+            Object literal2 = null;\n+            try {\n+                literal1 = JexlASTHelper.getLiteralValue(child1);\n+                literal2 = JexlASTHelper.getLiteralValue(child2);\n+            } catch (NoSuchElementException e) {}", "originalCommit": "1913c941c58dd01d84a7ea384d8356054a855778", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwMjgyNw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546002827", "bodyText": "Previously, QueryPropertyMarkerVisitor.instanceOf(node, null) implied that we were searching for any delayed nodes.  Now that we have BoundedRange as an additional marker, it implies something different as that isn't delayed.  Are we sure that there aren't any other places in the code where we don't need to do a similar update to what you've done here to ensure that BoundedRange isn't treated as a delayed node?  Should we create some kind of isInstanceOfDelayed method to make this clearer?", "author": "jwomeara", "createdAt": "2020-12-18T18:11:18Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/PushdownMissingIndexRangeNodesVisitor.java", "diffHunk": "@@ -72,78 +74,43 @@ public PushdownMissingIndexRangeNodesVisitor(ShardQueryConfiguration config, Met\n     \n     @Override\n     public Object visit(ASTAndNode node, Object data) {\n-        List<JexlNode> leaves = new ArrayList<>();\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = JexlASTHelper.getBoundedRanges(node, this.dataTypeFilter, this.helper, leaves, false);\n+        LiteralRange range = JexlASTHelper.findRange().indexedOnly(this.dataTypeFilter, this.helper).notDelayed().getRange(node);\n         \n-        JexlNode andNode = JexlNodes.newInstanceOfType(node);\n-        andNode.image = node.image;\n-        andNode.jjtSetParent(node.jjtGetParent());\n-        \n-        // We have a bounded range completely inside of an AND/OR\n-        if (!ranges.isEmpty()) {\n-            andNode = delayIndexBoundedRange(ranges, leaves, node, andNode, data);\n+        if (range != null) {\n+            return delayBoundedIndexHole(range, node, data);\n         } else {\n+            JexlNode andNode = JexlNodes.newInstanceOfType(node);\n+            andNode.image = node.image;\n+            andNode.jjtSetParent(node.jjtGetParent());\n+            \n             // We have no bounded range to replace, just proceed as normal\n             JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n             for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n                 JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n                 andNode.jjtAddChild(newChild, i);\n                 newChild.jjtSetParent(andNode);\n             }\n+            return andNode;\n         }\n-        \n-        return andNode;\n     }\n     \n     /**\n      * Delay the ranges that overlap holes. The range map is expected to only be indexed ranges.\n      */\n-    protected JexlNode delayIndexBoundedRange(Map<LiteralRange<?>,List<JexlNode>> ranges, List<JexlNode> leaves, ASTAndNode currentNode, JexlNode newNode,\n-                    Object data) {\n-        // Add all children in this AND/OR which are not a part of the range\n-        JexlNodes.ensureCapacity(newNode, leaves.size() + ranges.size());\n-        int index = 0;\n-        for (; index < leaves.size(); index++) {\n-            log.debug(leaves.get(index).image);\n-            // Add each child which is not a part of the bounded range, visiting them first\n-            JexlNode visitedChild = (JexlNode) leaves.get(index).jjtAccept(this, null);\n-            newNode.jjtAddChild(visitedChild, index);\n-            visitedChild.jjtSetParent(newNode);\n-        }\n-        \n-        for (Map.Entry<LiteralRange<?>,List<JexlNode>> range : ranges.entrySet()) {\n-            // If we have any terms that we expanded, wrap them in parens and add them to the parent\n-            ASTAndNode rangeNodes = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-            \n-            JexlNodes.ensureCapacity(rangeNodes, range.getValue().size());\n-            for (int i = 0; i < range.getValue().size(); i++) {\n-                rangeNodes.jjtAddChild(range.getValue().get(i), i);\n-            }\n-            \n-            JexlNode child = rangeNodes;\n-            if (missingIndexRange(range.getKey())) {\n-                child = IndexHoleMarkerJexlNode.create(rangeNodes);\n-            } else {\n-                child = JexlNodes.wrap(rangeNodes);\n-            }\n-            \n-            newNode.jjtAddChild(child, index++);\n-            child.jjtSetParent(newNode);\n-        }\n+    protected JexlNode delayBoundedIndexHole(LiteralRange range, ASTAndNode currentNode, Object data) {\n         \n-        // If we had no other nodes than this bounded range, we can strip out the original parent\n-        if (newNode.jjtGetNumChildren() == 1) {\n-            newNode.jjtGetChild(0).jjtSetParent(newNode.jjtGetParent());\n-            return newNode.jjtGetChild(0);\n+        if (missingIndexRange(range)) {\n+            return IndexHoleMarkerJexlNode.create(currentNode);\n+        } else {\n+            return currentNode;\n         }\n         \n-        return newNode;\n     }\n     \n     @Override\n     public Object visit(ASTReferenceExpression node, Object data) {\n         // if not already delayed somehow\n-        if (!QueryPropertyMarker.instanceOf(node, null)) {\n+        if (!QueryPropertyMarkerVisitor.instanceOfAnyExcept(node, Collections.singletonList(BoundedRange.class))) {", "originalCommit": "1913c941c58dd01d84a7ea384d8356054a855778", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0NjE4Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546046183", "bodyText": "Agreed.  I did validate all calls as such.", "author": "ivakegg", "createdAt": "2020-12-18T19:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwMjgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzk1Mg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546007952", "bodyText": "This is going to blow up our query plans for geo queries.  Gulp...", "author": "jwomeara", "createdAt": "2020-12-18T18:19:15Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/functions/GeoFunctionsDescriptorTest.java", "diffHunk": "@@ -28,7 +29,7 @@ public void antiMeridianTest2() throws Exception {\n         JexlArgumentDescriptor argDesc = new GeoFunctionsDescriptor().getArgumentDescriptor((ASTFunctionNode) node.jjtGetChild(0).jjtGetChild(0));\n         JexlNode queryNode = argDesc.getIndexQuery(null, null, null, null);\n         Assert.assertEquals(\n-                        \"(((LON_FIELD >= '170.0' && LON_FIELD <= '180') && (LAT_FIELD >= '40.0' && LAT_FIELD <= '50.0')) && ((LON_FIELD >= '-180' && LON_FIELD <= '-170.0') && (LAT_FIELD >= '40.0' && LAT_FIELD <= '50.0')))\",\n+                        \"((((BoundedRange = true) && (LON_FIELD >= '170.0' && LON_FIELD <= '180')) && ((BoundedRange = true) && (LAT_FIELD >= '40.0' && LAT_FIELD <= '50.0'))) && (((BoundedRange = true) && (LON_FIELD >= '-180' && LON_FIELD <= '-170.0')) && ((BoundedRange = true) && (LAT_FIELD >= '40.0' && LAT_FIELD <= '50.0'))))\",", "originalCommit": "1913c941c58dd01d84a7ea384d8356054a855778", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0MDUwMA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546040500", "bodyText": "I think you create a ticket for that.....", "author": "ivakegg", "createdAt": "2020-12-18T19:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzk1Mg=="}], "type": "inlineReview"}, {"oid": "49915c9507a77707b1431b0ec4cecfa388e408d4", "url": "https://github.com/NationalSecurityAgency/datawave/commit/49915c9507a77707b1431b0ec4cecfa388e408d4", "message": "formatting", "committedDate": "2020-12-18T19:09:22Z", "type": "commit"}, {"oid": "6c617e496f0020bce5099e5b369ec15c9de19036", "url": "https://github.com/NationalSecurityAgency/datawave/commit/6c617e496f0020bce5099e5b369ec15c9de19036", "message": "re #902: review updates", "committedDate": "2020-12-18T19:45:58Z", "type": "commit"}]}