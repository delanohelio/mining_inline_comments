{"pr_number": 15775, "pr_title": "Transactional batch for Java", "pr_createdAt": "2020-09-28T14:25:42Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/15775", "timeline": [{"oid": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "message": "Transactional batch seperate\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-09-28T13:56:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDE0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496074141", "bodyText": "4.4.0 is already released. please check what's the next available version. here and other places.", "author": "moderakh", "createdAt": "2020-09-28T16:17:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -493,6 +496,88 @@ public String getId() {\n         return Utils.getSimpleObjectMapper().convertValue(object, classType);\n     }\n \n+    /**\n+     * Executes the transactional batch at the Azure Cosmos service as an asynchronous operation.\n+     *\n+     * @param transactionalBatch Batch having list of operation and partition key which will be executed by this container.\n+     *\n+     * @return A Mono response which contains details of execution of the transactional batch.\n+     * <p>\n+     * If the transactional batch executes successfully, the value returned by {@link\n+     * TransactionalBatchResponse#getResponseStatus} on the response returned will be set to 200}.\n+     * <p>\n+     * If an operation within the transactional batch fails during execution, no changes from the batch will be\n+     * committed and the status of the failing operation is made available by {@link\n+     * TransactionalBatchResponse#getResponseStatus}. To obtain information about the operations that failed, the\n+     * response can be enumerated. This returns {@link TransactionalBatchOperationResult} instances corresponding to\n+     * each operation in the transactional batch in the order they were added to the transactional batch. For a result\n+     * corresponding to an operation within the transactional batch, use\n+     * {@link TransactionalBatchOperationResult#getResponseStatus}\n+     * to access the status of the operation. If the operation was not executed or it was aborted due to the failure of\n+     * another operation within the transactional batch, the value of this field will be 424;\n+     * for the operation that caused the batch to abort, the value of this field\n+     * will indicate the cause of failure.\n+     * <p>\n+     * The value returned by {@link TransactionalBatchResponse#getResponseStatus} on the response returned may also have\n+     * values such as 500 in case of server errors and 429.\n+     * <p>\n+     * Use {@link TransactionalBatchResponse#isSuccessStatusCode} on the response returned to ensure that the\n+     * transactional batch succeeded.\n+     */\n+    @Beta(Beta.SinceVersion.V4_4_0)", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1ODc3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496658779", "bodyText": "4.6.0 Will be the next minor release version if you are able to merge within the next 24 hours (4.6.0 will ship with AAD support for Walgreens on Thursday) - otherwise 4.7.0 is a safe bet.", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T11:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3ODEzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498178133", "bodyText": "Ack. changed it to 4.7.0 now.", "author": "rakkuma", "createdAt": "2020-10-01T11:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NTkyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496265928", "bodyText": "is this method needed for implementation (other implementation classes accessing the operations list) or is that needed as part of the public api?", "author": "moderakh", "createdAt": "2020-09-28T22:14:46Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatch.java", "diffHunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+\n+import java.util.ArrayList;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a batch of operations against items with the same {@link PartitionKey} in a container that will be performed\n+ * in a transactional manner at the Azure Cosmos DB service.\n+ * <p>\n+ * Use {@link TransactionalBatch#createTransactionalBatch(PartitionKey)} or new {@link #TransactionalBatch(PartitionKey)}\n+ * to create an instance of TransactionalBatch\n+ * <b>Example</b>\n+ * This example atomically modifies a set of documents as a batch.\n+ * <pre>{@code\n+ * public class ToDoActivity {\n+ *     public final String type;\n+ *     public final String id;\n+ *     public final String status;\n+ *     public ToDoActivity(String type, String id, String status) {\n+ *         this.type = type;\n+ *         this.id = id;\n+ *         this.status = status;\n+ *     }\n+ * }\n+ *\n+ * String activityType = \"personal\";\n+ *\n+ * ToDoActivity test1 = new ToDoActivity(activityType, \"learning\", \"ToBeDone\");\n+ * ToDoActivity test2 = new ToDoActivity(activityType, \"shopping\", \"Done\");\n+ * ToDoActivity test3 = new ToDoActivity(activityType, \"swimming\", \"ToBeDone\");\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .createItem<ToDoActivity>(test1)\n+ *     .replaceItem<ToDoActivity>(test2.id, test2)\n+ *     .upsertItem<ToDoActivity>(test3)\n+ *     .deleteItem(\"reading\");\n+ *\n+ * try (TransactionalBatchResponse response = container.executeTransactionalBatch(batch) {\n+ *\n+ *     if (!response.IsSuccessStatusCode) {\n+ *        // Handle and log exception\n+ *        return;\n+ *     }\n+ *\n+ *     // Look up interested results - e.g., via typed access on operation results\n+ *\n+ *     TransactionalBatchOperationResult<ToDoActivity> result = response.getOperationResultAtIndex<ToDoActivity>(0, ToDoActivity.class);\n+ *     ToDoActivity readActivity = result.getItem();\n+ * }\n+ * }</pre>\n+ *\n+ * <b>Example</b>\n+ * <p>This example atomically reads a set of documents as a batch.\n+ * <pre>{@code\n+ * String activityType = \"personal\";\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .readItem(\"playing\")\n+ *     .readItem(\"walking\")\n+ *     .readItem(\"jogging\")\n+ *     .readItem(\"running\")\n+ *\n+ * try (TransactionalBatchResponse response = container.executeTransactionalBatch(new Cosmos.PartitionKey(activityType)) {\n+ *\n+ *     // Look up interested results - eg. via direct access to operation result stream\n+ *\n+ *     List<String> resultItems = new ArrayList<String>();\n+ *\n+ *     for (TransactionalBatchOperationResult result : response) {\n+ *         resultItems.add(result.getResourceObject().toString())\n+ *     }\n+ * }\n+ * }</pre>\n+ * <p>\n+ * <b>See:</b>\n+ * <a href=\"https://docs.microsoft.com/azure/cosmos-db/concepts-limits\">Limits on TransactionalBatch requests</a>.\n+ */\n+public final class TransactionalBatch {\n+\n+    private final ArrayList<ItemBatchOperation<?>> operations;\n+    private final PartitionKey partitionKey;\n+\n+    public TransactionalBatch(PartitionKey partitionKey) {\n+        this.operations = new ArrayList<>();\n+        this.partitionKey = partitionKey;\n+    }\n+\n+    /**\n+     * Initializes a new instance of {@link TransactionalBatch}\n+     * that will contain operations to be performed across multiple items in the container with the provided partition\n+     * key in a transactional manner\n+     *\n+     * @param partitionKey the partition key for all items in the batch.\n+     *\n+     * @return A new instance of {@link TransactionalBatch}.\n+     */\n+    public static TransactionalBatch createTransactionalBatch(PartitionKey partitionKey) {\n+        return new TransactionalBatch(partitionKey);\n+    }\n+\n+    /**\n+     * Adds an operation to create an item into the batch.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param <T> The type of item to be created.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> TransactionalBatch createItem(T item) {\n+        checkNotNull(item, \"expected non-null item\");\n+        return this.createItem(item, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to create an item into the batch.\n+     *\n+     * @param <T> The type of item to be created.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param requestOptions The options for the item request.\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> TransactionalBatch createItem(T item, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(item, \"expected non-null item\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        this.operations.add(\n+            new ItemBatchOperation.Builder<T>(\n+                OperationType.Create,\n+                this.operations.size())\n+                .requestOptions(requestOptions.toRequestOptions())\n+                .resource(item)\n+                .build());\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Adds an operation to delete an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public TransactionalBatch deleteItem(String id) {\n+        checkNotNull(id, \"expected non-null id\");\n+        return this.deleteItem(id, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to delete an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     * @param requestOptions The options for the item request.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public TransactionalBatch deleteItem(String id, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(id, \"expected non-null id\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        this.operations.add(new ItemBatchOperation.Builder<Void>(OperationType.Delete, this.operations.size())\n+            .requestOptions(requestOptions.toRequestOptions())\n+            .id(id)\n+            .build());\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Adds an operation to read an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public TransactionalBatch readItem(String id) {\n+        checkNotNull(id, \"expected non-null id\");\n+        return this.readItem(id, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to read an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     * @param requestOptions The options for the item request.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public TransactionalBatch readItem(String id, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(id, \"expected non-null id\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        this.operations.add(new ItemBatchOperation.Builder<Void>(OperationType.Read, this.operations.size())\n+            .requestOptions(requestOptions.toRequestOptions())\n+            .id(id)\n+            .build());\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Adds an operation to replace an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param <T> The type of item to be replaced.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> TransactionalBatch replaceItem(String id, T item) {\n+        checkNotNull(id, \"expected non-null id\");\n+        checkNotNull(item, \"expected non-null item\");\n+        return this.replaceItem(id, item, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to replace an item into the batch.\n+     *\n+     * @param <T> The type of item to be replaced.\n+     *\n+     * @param id The unique id of the item.\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param requestOptions The options for the item request.\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> TransactionalBatch replaceItem(\n+        String id, T item, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(id, \"expected non-null id\");\n+        checkNotNull(item, \"expected non-null item\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        this.operations.add(new ItemBatchOperation.Builder<T>(OperationType.Replace, this.operations.size())\n+            .requestOptions(requestOptions.toRequestOptions())\n+            .resource(item)\n+            .id(id)\n+            .build());\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Adds an operation to upsert an item into the batch.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param <T> The type of item to be upserted.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> TransactionalBatch upsertItem(T item) {\n+        checkNotNull(item, \"expected non-null item\");\n+        return this.upsertItem(item, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to upsert an item into the batch.\n+     *\n+     * @param <T> The type of item to be upserted.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param requestOptions The options for the item request.\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> TransactionalBatch upsertItem(T item, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(item, \"expected non-null item\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        this.operations.add(new ItemBatchOperation.Builder<T>(OperationType.Upsert, this.operations.size())\n+            .requestOptions(requestOptions.toRequestOptions())\n+            .resource(item)\n+            .build());\n+\n+        return this;\n+    }\n+\n+    public ArrayList<ItemBatchOperation<?>> getOperations() {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2NTYyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496665625", "bodyText": "If it stays public surface area (for example to allow customers to log etc. I would definitely return a copy of the private field instead to disallow callers to make direct modifications to the underlying collection.", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T12:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MDg5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496670891", "bodyText": "Or may be an instance of Unmodifiable List. But I am not sure if it is required to return to the user . Also the TransactionalBatchResponse does have the operations, we use it in Bulk to keep track, but may be that can suffice for user logging?", "author": "rakkuma", "createdAt": "2020-09-29T12:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY4NDQ3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496684472", "bodyText": "Yes - i think it is perfectly fine to make this method package internal for now.", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T12:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NjU5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496266592", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RequestOptions toRequestOptions() {\n          \n          \n            \n                       RequestOptions toRequestOptions() {\n          \n      \n    \n    \n  \n\nRequestOptions is an internal type, we should not expose this as a public API.", "author": "moderakh", "createdAt": "2020-09-28T22:16:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchItemRequestOptions.java", "diffHunk": "@@ -0,0 +1,58 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+\n+public final class TransactionalBatchItemRequestOptions {\n+    private String ifMatchETag;\n+    private String ifNoneMatchETag;\n+\n+    /**\n+     * Gets the If-Match (ETag) associated with the request in the Azure Cosmos DB service.\n+     *\n+     * @return ifMatchETag the ifMatchETag associated with the request.\n+     */\n+    public String getIfMatchETag() {\n+        return this.ifMatchETag;\n+    }\n+\n+    /**\n+     * Sets the If-Match (ETag) associated with the request in the Azure Cosmos DB service.\n+     *\n+     * @param ifMatchETag the ifMatchETag associated with the request.\n+     * @return the current request options\n+     */\n+    public TransactionalBatchItemRequestOptions setIfMatchETag(final String ifMatchETag) {\n+        this.ifMatchETag = ifMatchETag;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the If-None-Match (ETag) associated with the request in the Azure Cosmos DB service.\n+     *\n+     * @return the ifNoneMatchETag associated with the request.\n+     */\n+    public String getIfNoneMatchETag() {\n+        return this.ifNoneMatchETag;\n+    }\n+\n+    /**\n+     * Sets the If-None-Match (ETag) associated with the request in the Azure Cosmos DB service.\n+     *\n+     * @param ifNoneMatchEtag the ifNoneMatchETag associated with the request.\n+     * @return the current request options\n+     */\n+    public TransactionalBatchItemRequestOptions setIfNoneMatchETag(final String ifNoneMatchEtag) {\n+        this.ifNoneMatchETag = ifNoneMatchEtag;\n+        return this;\n+    }\n+\n+    public RequestOptions toRequestOptions() {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNjYxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497836615", "bodyText": "Ack. Fixed it. Thanks.", "author": "rakkuma", "createdAt": "2020-09-30T22:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NjU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NzIzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496267235", "bodyText": "I suspect the constructors are only used by the internal implementation. correct?\nif so we shouldn't expose them as public.\nsame for the other constructors in this class.", "author": "moderakh", "createdAt": "2020-09-28T22:18:20Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,224 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+public final class TransactionalBatchOperationResult<TResource> implements AutoCloseable {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchOperationResult.class);\n+\n+    private String eTag;\n+    private double requestCharge;\n+    private TResource item;\n+    private ObjectNode resourceObject;\n+    private int responseStatus;\n+    private Duration retryAfter;\n+    private int subStatusCode;\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result.\n+     *\n+     * @param responseStatus the response status\n+     */\n+    public TransactionalBatchOperationResult(final int responseStatus) {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3Nzk1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498177951", "bodyText": "Have removed these kind of individual setters. Only constructor and that too package private. Thanks!!", "author": "rakkuma", "createdAt": "2020-10-01T11:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NzIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2ODI4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496268286", "bodyText": "I believe only the getters are used by the end user correct?\nthe setter should only be used by the public API.\nif that so we should not make any of the setter a public api. change visibility to package level. for this setter and for other setters in this class.", "author": "moderakh", "createdAt": "2020-09-28T22:21:06Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,224 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+public final class TransactionalBatchOperationResult<TResource> implements AutoCloseable {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchOperationResult.class);\n+\n+    private String eTag;\n+    private double requestCharge;\n+    private TResource item;\n+    private ObjectNode resourceObject;\n+    private int responseStatus;\n+    private Duration retryAfter;\n+    private int subStatusCode;\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result.\n+     *\n+     * @param responseStatus the response status\n+     */\n+    public TransactionalBatchOperationResult(final int responseStatus) {\n+        this.responseStatus = responseStatus;\n+    }\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result.\n+     *\n+     * @param other the other\n+     */\n+    public TransactionalBatchOperationResult(final TransactionalBatchOperationResult<?> other) {\n+\n+        checkNotNull(other, \"expected non-null other\");\n+\n+        this.responseStatus = other.responseStatus;\n+        this.subStatusCode = other.subStatusCode;\n+        this.eTag = other.eTag;\n+        this.requestCharge = other.requestCharge;\n+        this.retryAfter = other.retryAfter;\n+        this.resourceObject = other.resourceObject;\n+    }\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result.\n+     *\n+     * @param result the result\n+     * @param item the item\n+     */\n+    public TransactionalBatchOperationResult(TransactionalBatchOperationResult<?> result, TResource item) {\n+        this(result);\n+        this.item = item;\n+    }\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchOperationResult} class.\n+     */\n+    public TransactionalBatchOperationResult() {\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     * <p>\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Sets e tag.\n+     *\n+     * @param value the value\n+     *\n+     * @return the e tag\n+     */\n+    public TransactionalBatchOperationResult<?> setETag(final String value) {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0NDM2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498044360", "bodyText": "Yeah. Now have kept the init in BridgeInternal.", "author": "rakkuma", "createdAt": "2020-10-01T07:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2ODI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2OTA5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496269093", "bodyText": "I am guessing as in Dotnet we have auto-closable this is a 1-1 translation of that to java. correct?\nWhat I am not sure about is when item can be an instance of AutoClosable? can you make an example with a usage scenario code sample?", "author": "moderakh", "createdAt": "2020-09-28T22:23:29Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,224 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+public final class TransactionalBatchOperationResult<TResource> implements AutoCloseable {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchOperationResult.class);\n+\n+    private String eTag;\n+    private double requestCharge;\n+    private TResource item;\n+    private ObjectNode resourceObject;\n+    private int responseStatus;\n+    private Duration retryAfter;\n+    private int subStatusCode;\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result.\n+     *\n+     * @param responseStatus the response status\n+     */\n+    public TransactionalBatchOperationResult(final int responseStatus) {\n+        this.responseStatus = responseStatus;\n+    }\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result.\n+     *\n+     * @param other the other\n+     */\n+    public TransactionalBatchOperationResult(final TransactionalBatchOperationResult<?> other) {\n+\n+        checkNotNull(other, \"expected non-null other\");\n+\n+        this.responseStatus = other.responseStatus;\n+        this.subStatusCode = other.subStatusCode;\n+        this.eTag = other.eTag;\n+        this.requestCharge = other.requestCharge;\n+        this.retryAfter = other.retryAfter;\n+        this.resourceObject = other.resourceObject;\n+    }\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result.\n+     *\n+     * @param result the result\n+     * @param item the item\n+     */\n+    public TransactionalBatchOperationResult(TransactionalBatchOperationResult<?> result, TResource item) {\n+        this(result);\n+        this.item = item;\n+    }\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchOperationResult} class.\n+     */\n+    public TransactionalBatchOperationResult() {\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     * <p>\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Sets e tag.\n+     *\n+     * @param value the value\n+     *\n+     * @return the e tag\n+     */\n+    public TransactionalBatchOperationResult<?> setETag(final String value) {\n+        this.eTag = value;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the request charge in request units for the current operation.\n+     *\n+     * @return Request charge in request units for the current operation.\n+     */\n+    public double getRequestCharge() {\n+        return requestCharge;\n+    }\n+\n+    /**\n+     * Sets request charge.\n+     *\n+     * @param value the value\n+     *\n+     * @return the request charge\n+     */\n+    public TransactionalBatchOperationResult<?> setRequestCharge(final double value) {\n+        this.requestCharge = value;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @return Resource associated with the current result.\n+     */\n+    public TResource getItem() {\n+        return this.item;\n+    }\n+\n+    /**\n+     * Sets item.\n+     *\n+     * @param value the value\n+     *\n+     * @return the item\n+     */\n+    public TransactionalBatchOperationResult<TResource> setItem(final TResource value) {\n+        this.item = value;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets retry after.\n+     *\n+     * @return the retry after\n+     */\n+    public Duration getRetryAfter() {\n+        return this.retryAfter;\n+    }\n+\n+    /**\n+     * Sets retry after.\n+     *\n+     * @param value the value\n+     *\n+     * @return the retry after\n+     */\n+    public TransactionalBatchOperationResult<?> setRetryAfter(final Duration value) {\n+        this.retryAfter = value;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets sub status code.\n+     *\n+     * @return the sub status code\n+     */\n+    public int getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Sets sub status code.\n+     *\n+     * @param value the value\n+     *\n+     * @return the sub status code\n+     */\n+    public TransactionalBatchOperationResult<?> setSubStatusCode(final int value) {\n+        this.subStatusCode = value;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the current operation completed successfully.\n+     *\n+     * @return {@code true} if the current operation completed successfully; {@code false} otherwise.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return 200 <= this.responseStatus && this.responseStatus <= 299;\n+    }\n+\n+    /**\n+     * Gets response status.\n+     *\n+     * @return the response status\n+     */\n+    public int getResponseStatus() {\n+        return this.responseStatus;\n+    }\n+\n+    public void setResponseStatus(int value) {\n+        this.responseStatus = value;\n+    }\n+\n+    public ObjectNode getResourceObject() {\n+        return resourceObject;\n+    }\n+\n+    public void setResourceObject(ObjectNode resourceObject) {\n+        this.resourceObject = resourceObject;\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            if (this.item instanceof AutoCloseable) {\n+                ((AutoCloseable) this.item).close();  // assumes an idempotent close implementation", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUwMTk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497501940", "bodyText": "Yes it is a copy for dotnet disposable. And seeing the use case of AutoClosable at other places in Java(mostly for stopping time or some shutdowns) here it seems out of pattern. I will remove it.\nThanks.", "author": "rakkuma", "createdAt": "2020-09-30T13:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2OTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2OTI4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496269285", "bodyText": "please see my comment on close() if the comment is relevant then we should consider dropping implements AutoClosable here.", "author": "moderakh", "createdAt": "2020-09-28T22:24:08Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,224 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+public final class TransactionalBatchOperationResult<TResource> implements AutoCloseable {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNTQ3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497835472", "bodyText": "Disposable is not used in same way as it is used in dotnet. so removing here. Thanks.", "author": "rakkuma", "createdAt": "2020-09-30T22:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2OTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2OTc2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496269768", "bodyText": "ditto RequestOptions is an internal type public api should not expose it.", "author": "moderakh", "createdAt": "2020-09-28T22:25:24Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchRequestOptions.java", "diffHunk": "@@ -0,0 +1,133 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.models.IndexingDirective;\n+\n+public final class TransactionalBatchRequestOptions {\n+    private ConsistencyLevel consistencyLevel;\n+    private IndexingDirective indexingDirective;\n+    private String sessionToken;\n+    private String ifMatchETag;\n+    private String ifNoneMatchETag;\n+\n+    /**\n+     * Constructor\n+     */\n+    public TransactionalBatchRequestOptions() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets the If-Match (ETag) associated with the request in the Azure Cosmos DB service.\n+     *\n+     * @return the ifMatchETag associated with the request.\n+     */\n+    public String getIfMatchETag() {\n+        return this.ifMatchETag;\n+    }\n+\n+    /**\n+     * Sets the If-Match (ETag) associated with the request in the Azure Cosmos DB service.\n+     *\n+     * @param ifMatchETag the ifMatchETag associated with the request.\n+     * @return the current request options\n+     */\n+    public TransactionalBatchRequestOptions setIfMatchETag(String ifMatchETag) {\n+        this.ifMatchETag = ifMatchETag;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the If-None-Match (ETag) associated with the request in the Azure Cosmos DB service.\n+     *\n+     * @return the ifNoneMatchETag associated with the request.\n+     */\n+    public String getIfNoneMatchETag() {\n+        return this.ifNoneMatchETag;\n+    }\n+\n+    /**\n+     * Sets the If-None-Match (ETag) associated with the request in the Azure Cosmos DB service.\n+     *\n+     * @param ifNoneMatchETag the ifNoneMatchETag associated with the request.\n+     * @return the current request options\n+     */\n+    public TransactionalBatchRequestOptions setIfNoneMatchETag(String ifNoneMatchETag) {\n+        this.ifNoneMatchETag = ifNoneMatchETag;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the consistency level required for the request.\n+     *\n+     * @return the consistency level.\n+     */\n+\n+    public ConsistencyLevel getConsistencyLevel() {\n+        return consistencyLevel;\n+    }\n+\n+    /**\n+     * Sets the consistency level required for the request.\n+     *\n+     * @param consistencyLevel the consistency level.\n+     * @return the CosmosItemRequestOptions.\n+     */\n+    TransactionalBatchRequestOptions setConsistencyLevel(ConsistencyLevel consistencyLevel) {\n+        this.consistencyLevel = consistencyLevel;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the indexing directive (index, do not index etc).\n+     *\n+     * @return the indexing directive.\n+     */\n+    public IndexingDirective getIndexingDirective() {\n+        return indexingDirective;\n+    }\n+\n+    /**\n+     * Sets the indexing directive (index, do not index etc).\n+     *\n+     * @param indexingDirective the indexing directive.\n+     * @return the CosmosItemRequestOptions.\n+     */\n+    public TransactionalBatchRequestOptions setIndexingDirective(IndexingDirective indexingDirective) {\n+        this.indexingDirective = indexingDirective;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the token for use with session consistency.\n+     *\n+     * @return the session token.\n+     */\n+    public String getSessionToken() {\n+        return sessionToken;\n+    }\n+\n+    /**\n+     * Sets the token for use with session consistency.\n+     *\n+     * @param sessionToken the session token.\n+     * @return the CosmosItemRequestOptions.\n+     */\n+    public TransactionalBatchRequestOptions setSessionToken(String sessionToken) {\n+        this.sessionToken = sessionToken;\n+        return this;\n+    }\n+\n+    public RequestOptions toRequestOptions() {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNTU3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497835576", "bodyText": "yeah. Fixed it. Thanks.", "author": "rakkuma", "createdAt": "2020-09-30T22:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2OTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3MDEzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496270136", "bodyText": "ditto as for TransactionalBatchOperationResult regarding implementing AutoClosable and close method.", "author": "moderakh", "createdAt": "2020-09-28T22:26:21Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,340 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+public class TransactionalBatchResponse implements AutoCloseable, List<TransactionalBatchOperationResult<?>> {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3MDMxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496270317", "bodyText": "ditto as for TransactionalBatchOperationResult regarding implementing AutoClosable and close method.", "author": "moderakh", "createdAt": "2020-09-28T22:26:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,340 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+public class TransactionalBatchResponse implements AutoCloseable, List<TransactionalBatchOperationResult<?>> {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchResponse.class);\n+\n+    private Map<String, String> responseHeaders;\n+    private final int responseStatus;\n+    private String errorMessage;\n+    private List<TransactionalBatchOperationResult<?>> results;\n+    private int subStatusCode;\n+    private List<ItemBatchOperation<?>> operations;\n+    private CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchResponse} class.\n+     *\n+     * @param responseStatus the  response status.\n+     * @param subStatusCode the response sub-status code.\n+     * @param errorMessage an error message or {@code null}.\n+     * @param responseHeaders the response http headers\n+     * @param cosmosDiagnostics the diagnostic\n+     * @param operations a {@link List list} of {@link ItemBatchOperation batch operations}.\n+     */\n+    public TransactionalBatchResponse(\n+        final int responseStatus,\n+        final int subStatusCode,\n+        final String errorMessage,\n+        final Map<String, String> responseHeaders,\n+        final CosmosDiagnostics cosmosDiagnostics,\n+        final List<ItemBatchOperation<?>> operations) {\n+\n+        checkNotNull(responseStatus, \"expected non-null responseStatus\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+        checkNotNull(operations, \"expected non-null operations\");\n+\n+        this.responseStatus = responseStatus;\n+        this.subStatusCode = subStatusCode;\n+        this.errorMessage = errorMessage;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+        this.operations = UnmodifiableList.unmodifiableList(operations);\n+        this.results = new ArrayList<>();\n+    }\n+\n+    public void createAndPopulateResults(final List<ItemBatchOperation<?>> operations, final int retryAfterMilliseconds) {\n+        for (int i = 0; i < operations.size(); i++) {\n+            this.results.add(\n+                new TransactionalBatchOperationResult<>(this.getResponseStatus())\n+                    .setSubStatusCode(this.getSubStatusCode())\n+                    .setRetryAfter(Duration.ofMillis(retryAfterMilliseconds)));\n+        }\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the current {@link TransactionalBatchResponse batch}.\n+     * <p>\n+     * @param <T> the type parameter.\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     * de-serialized, when present.\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return TransactionalBatchOperationResult containing the individual result of operation.\n+     * @throws IOException if the body of the resource cannot be read.\n+     */\n+    public <T> TransactionalBatchOperationResult<T> getOperationResultAtIndex(\n+        final int index,\n+        final Class<T> type) throws IOException {\n+\n+        checkArgument(index >= 0, \"expected non-negative index\");\n+        checkNotNull(type, \"expected non-null type\");\n+\n+        final TransactionalBatchOperationResult<?> result = this.results.get(index);\n+        T item = null;\n+\n+        if (result.getResourceObject() != null) {\n+            item = new JsonSerializable(result.getResourceObject()).toObject(type);\n+        }\n+\n+        return new TransactionalBatchOperationResult<T>(result, item);\n+    }\n+\n+    public CosmosDiagnostics getCosmosDiagnostics() {\n+        return cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the number of operation results.\n+     */\n+    public int size() {\n+        return this.results == null ? 0 : this.results.size();\n+    }\n+\n+    /**\n+     * Returns a value indicating whether the batch was successfully processed.\n+     *\n+     * @return a value indicating whether the batch was successfully processed.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return this.responseStatus >= 200 && this.responseStatus <= 299;\n+    }\n+\n+    /**\n+     * Gets all the activity IDs associated with the response.\n+     *\n+     * @return an enumerable that contains the activity IDs.\n+     */\n+    public Iterable<String> getActivityIds() {\n+        return Stream.of(this.getActivityId())::iterator;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute the batch.\n+     *\n+     * @return the activity ID that identifies the server request made to execute the batch.\n+     */\n+    public String getActivityId() {\n+        return this.responseHeaders.get(HttpConstants.HttpHeaders.ACTIVITY_ID);\n+    }\n+\n+    public final List<ItemBatchOperation<?>> getBatchOperations() {\n+        return this.operations;\n+    }\n+\n+    /**\n+     * Gets the reason for the failure of the batch request, if any, or {@code null}.\n+     *\n+     * @return the reason for the failure of the batch request, if any, or {@code null}.\n+     */\n+    public String getErrorMessage() {\n+        return this.errorMessage;\n+    }\n+\n+    public void setErrorMessage(String value) {\n+        this.errorMessage = value;\n+    }\n+\n+    /**\n+     * Gets the request charge for the batch request.\n+     *\n+     * @return the request charge measured in request units.\n+     */\n+    public double getRequestCharge() {\n+        final String value = this.responseHeaders.get(HttpConstants.HttpHeaders.REQUEST_CHARGE);\n+        try {\n+            return Double.valueOf(value);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"INVALID x-ms-request-charge value {}.\", value);\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Gets the response status code of the batch request.\n+     *\n+     * @return the response status code of the batch request.\n+     */\n+    public int getResponseStatus() {\n+        return this.responseStatus;\n+    }\n+\n+    /**\n+     * Gets the response headers.\n+     *\n+     * @return the response header map.\n+     */\n+    public Map<String, String> getResponseHeaders() {\n+        return responseHeaders;\n+    }\n+\n+    /**\n+     * Gets the amount of time to wait before retrying this or any other request due to throttling.\n+     *\n+     * @return the amount of time to wait before retrying this or any other request due to throttling.\n+     */\n+    public Duration getRetryAfter() {\n+        if (this.responseHeaders.containsKey(HttpConstants.HttpHeaders.RETRY_AFTER)) {\n+            return Duration.parse(this.responseHeaders.get(HttpConstants.HttpHeaders.RETRY_AFTER));\n+        }\n+\n+        return null;\n+    }\n+\n+    public int getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the batch.\n+     *\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     *\n+     * @return Result of operation at the provided index in the batch.\n+     */\n+    @Override\n+    public TransactionalBatchOperationResult<?> get(int index) {\n+        return this.results.get(index);\n+    }\n+\n+    @Override\n+    public int indexOf(Object o) {\n+        return this.results.indexOf(o);\n+    }\n+\n+    @Override\n+    public Iterator<TransactionalBatchOperationResult<?>> iterator() {\n+        return this.results.iterator();\n+    }\n+\n+    @Override\n+    public int lastIndexOf(Object o) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public ListIterator<TransactionalBatchOperationResult<?>> listIterator() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ListIterator<TransactionalBatchOperationResult<?>> listIterator(int index) {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean remove(Object result) {\n+        return this.results.remove(result);\n+    }\n+\n+    @Override\n+    public TransactionalBatchOperationResult<?> remove(int index) {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> collection) {\n+        return this.results.removeAll(collection);\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> collection) {\n+        return this.results.retainAll(collection);\n+    }\n+\n+    @Override\n+    public TransactionalBatchOperationResult<?> set(int index, TransactionalBatchOperationResult<?> result) {\n+        return this.results.set(index, result);\n+    }\n+\n+    @Override\n+    public List<TransactionalBatchOperationResult<?>> subList(int fromIndex, int toIndex) {\n+        return this.results.subList(fromIndex, toIndex);\n+    }\n+\n+    @Override\n+    public Object[] toArray() {\n+        return this.results.toArray();\n+    }\n+\n+    @Override\n+    public <T> T[] toArray(T[] a) {\n+        return this.results.toArray(a);\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return this.results.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean add(TransactionalBatchOperationResult<?> result) {\n+        return this.results.add(result);\n+    }\n+\n+    @Override\n+    public void add(int index, TransactionalBatchOperationResult<?> element) {\n+        this.results.add(index, element);\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends TransactionalBatchOperationResult<?>> collection) {\n+        return this.results.addAll(collection);\n+    }\n+\n+    @Override\n+    public boolean addAll(int index, Collection<? extends TransactionalBatchOperationResult<?>> collection) {\n+        return this.results.addAll(index, collection);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        this.results.clear();\n+    }\n+\n+    @Override\n+    public boolean contains(Object result) {\n+        return this.results.contains(result);\n+    }\n+\n+    @Override\n+    public boolean containsAll(Collection<?> c) {\n+        return false;\n+    }\n+\n+    /**\n+     * Closes the current {@link TransactionalBatchResponse}.\n+     */\n+    public void close() {\n+        this.operations = null;\n+        this.responseHeaders = null;\n+        this.results = null;\n+        this.cosmosDiagnostics = null;", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3MDgxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496270811", "bodyText": "doesn't seem to me that sub-classing from List is a right choice. now you have many methods to re-implement.", "author": "moderakh", "createdAt": "2020-09-28T22:28:13Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,340 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+public class TransactionalBatchResponse implements AutoCloseable, List<TransactionalBatchOperationResult<?>> {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchResponse.class);\n+\n+    private Map<String, String> responseHeaders;\n+    private final int responseStatus;\n+    private String errorMessage;\n+    private List<TransactionalBatchOperationResult<?>> results;\n+    private int subStatusCode;\n+    private List<ItemBatchOperation<?>> operations;\n+    private CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchResponse} class.\n+     *\n+     * @param responseStatus the  response status.\n+     * @param subStatusCode the response sub-status code.\n+     * @param errorMessage an error message or {@code null}.\n+     * @param responseHeaders the response http headers\n+     * @param cosmosDiagnostics the diagnostic\n+     * @param operations a {@link List list} of {@link ItemBatchOperation batch operations}.\n+     */\n+    public TransactionalBatchResponse(\n+        final int responseStatus,\n+        final int subStatusCode,\n+        final String errorMessage,\n+        final Map<String, String> responseHeaders,\n+        final CosmosDiagnostics cosmosDiagnostics,\n+        final List<ItemBatchOperation<?>> operations) {\n+\n+        checkNotNull(responseStatus, \"expected non-null responseStatus\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+        checkNotNull(operations, \"expected non-null operations\");\n+\n+        this.responseStatus = responseStatus;\n+        this.subStatusCode = subStatusCode;\n+        this.errorMessage = errorMessage;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+        this.operations = UnmodifiableList.unmodifiableList(operations);\n+        this.results = new ArrayList<>();\n+    }\n+\n+    public void createAndPopulateResults(final List<ItemBatchOperation<?>> operations, final int retryAfterMilliseconds) {\n+        for (int i = 0; i < operations.size(); i++) {\n+            this.results.add(\n+                new TransactionalBatchOperationResult<>(this.getResponseStatus())\n+                    .setSubStatusCode(this.getSubStatusCode())\n+                    .setRetryAfter(Duration.ofMillis(retryAfterMilliseconds)));\n+        }\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the current {@link TransactionalBatchResponse batch}.\n+     * <p>\n+     * @param <T> the type parameter.\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     * de-serialized, when present.\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return TransactionalBatchOperationResult containing the individual result of operation.\n+     * @throws IOException if the body of the resource cannot be read.\n+     */\n+    public <T> TransactionalBatchOperationResult<T> getOperationResultAtIndex(\n+        final int index,\n+        final Class<T> type) throws IOException {\n+\n+        checkArgument(index >= 0, \"expected non-negative index\");\n+        checkNotNull(type, \"expected non-null type\");\n+\n+        final TransactionalBatchOperationResult<?> result = this.results.get(index);\n+        T item = null;\n+\n+        if (result.getResourceObject() != null) {\n+            item = new JsonSerializable(result.getResourceObject()).toObject(type);\n+        }\n+\n+        return new TransactionalBatchOperationResult<T>(result, item);\n+    }\n+\n+    public CosmosDiagnostics getCosmosDiagnostics() {\n+        return cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the number of operation results.\n+     */\n+    public int size() {\n+        return this.results == null ? 0 : this.results.size();\n+    }\n+\n+    /**\n+     * Returns a value indicating whether the batch was successfully processed.\n+     *\n+     * @return a value indicating whether the batch was successfully processed.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return this.responseStatus >= 200 && this.responseStatus <= 299;\n+    }\n+\n+    /**\n+     * Gets all the activity IDs associated with the response.\n+     *\n+     * @return an enumerable that contains the activity IDs.\n+     */\n+    public Iterable<String> getActivityIds() {\n+        return Stream.of(this.getActivityId())::iterator;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute the batch.\n+     *\n+     * @return the activity ID that identifies the server request made to execute the batch.\n+     */\n+    public String getActivityId() {\n+        return this.responseHeaders.get(HttpConstants.HttpHeaders.ACTIVITY_ID);\n+    }\n+\n+    public final List<ItemBatchOperation<?>> getBatchOperations() {\n+        return this.operations;\n+    }\n+\n+    /**\n+     * Gets the reason for the failure of the batch request, if any, or {@code null}.\n+     *\n+     * @return the reason for the failure of the batch request, if any, or {@code null}.\n+     */\n+    public String getErrorMessage() {\n+        return this.errorMessage;\n+    }\n+\n+    public void setErrorMessage(String value) {\n+        this.errorMessage = value;\n+    }\n+\n+    /**\n+     * Gets the request charge for the batch request.\n+     *\n+     * @return the request charge measured in request units.\n+     */\n+    public double getRequestCharge() {\n+        final String value = this.responseHeaders.get(HttpConstants.HttpHeaders.REQUEST_CHARGE);\n+        try {\n+            return Double.valueOf(value);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"INVALID x-ms-request-charge value {}.\", value);\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Gets the response status code of the batch request.\n+     *\n+     * @return the response status code of the batch request.\n+     */\n+    public int getResponseStatus() {\n+        return this.responseStatus;\n+    }\n+\n+    /**\n+     * Gets the response headers.\n+     *\n+     * @return the response header map.\n+     */\n+    public Map<String, String> getResponseHeaders() {\n+        return responseHeaders;\n+    }\n+\n+    /**\n+     * Gets the amount of time to wait before retrying this or any other request due to throttling.\n+     *\n+     * @return the amount of time to wait before retrying this or any other request due to throttling.\n+     */\n+    public Duration getRetryAfter() {\n+        if (this.responseHeaders.containsKey(HttpConstants.HttpHeaders.RETRY_AFTER)) {\n+            return Duration.parse(this.responseHeaders.get(HttpConstants.HttpHeaders.RETRY_AFTER));\n+        }\n+\n+        return null;\n+    }\n+\n+    public int getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the batch.\n+     *\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     *\n+     * @return Result of operation at the provided index in the batch.\n+     */\n+    @Override\n+    public TransactionalBatchOperationResult<?> get(int index) {\n+        return this.results.get(index);\n+    }\n+\n+    @Override\n+    public int indexOf(Object o) {\n+        return this.results.indexOf(o);\n+    }\n+\n+    @Override\n+    public Iterator<TransactionalBatchOperationResult<?>> iterator() {\n+        return this.results.iterator();\n+    }\n+\n+    @Override\n+    public int lastIndexOf(Object o) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public ListIterator<TransactionalBatchOperationResult<?>> listIterator() {\n+        return null;\n+    }", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0NDA4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498044085", "bodyText": "Agreed.", "author": "rakkuma", "createdAt": "2020-10-01T07:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3MDgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3MTAwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496271003", "bodyText": "doesn't seem to me that sub-classing from List is a right choice. now you have many methods to re-implement.\nWhy don't we just add only the relevant methods without subclassing List?", "author": "moderakh", "createdAt": "2020-09-28T22:28:53Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,340 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+public class TransactionalBatchResponse implements AutoCloseable, List<TransactionalBatchOperationResult<?>> {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0MzUzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498043537", "bodyText": "Yeah. Make sense. removed it.", "author": "rakkuma", "createdAt": "2020-10-01T07:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3MTAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3MTIzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496271239", "bodyText": "this is implementation api, correct. don't expose implementation api as part of public api.", "author": "moderakh", "createdAt": "2020-09-28T22:29:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,340 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+public class TransactionalBatchResponse implements AutoCloseable, List<TransactionalBatchOperationResult<?>> {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchResponse.class);\n+\n+    private Map<String, String> responseHeaders;\n+    private final int responseStatus;\n+    private String errorMessage;\n+    private List<TransactionalBatchOperationResult<?>> results;\n+    private int subStatusCode;\n+    private List<ItemBatchOperation<?>> operations;\n+    private CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchResponse} class.\n+     *\n+     * @param responseStatus the  response status.\n+     * @param subStatusCode the response sub-status code.\n+     * @param errorMessage an error message or {@code null}.\n+     * @param responseHeaders the response http headers\n+     * @param cosmosDiagnostics the diagnostic\n+     * @param operations a {@link List list} of {@link ItemBatchOperation batch operations}.\n+     */\n+    public TransactionalBatchResponse(\n+        final int responseStatus,\n+        final int subStatusCode,\n+        final String errorMessage,\n+        final Map<String, String> responseHeaders,\n+        final CosmosDiagnostics cosmosDiagnostics,\n+        final List<ItemBatchOperation<?>> operations) {\n+\n+        checkNotNull(responseStatus, \"expected non-null responseStatus\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+        checkNotNull(operations, \"expected non-null operations\");\n+\n+        this.responseStatus = responseStatus;\n+        this.subStatusCode = subStatusCode;\n+        this.errorMessage = errorMessage;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+        this.operations = UnmodifiableList.unmodifiableList(operations);\n+        this.results = new ArrayList<>();\n+    }\n+\n+    public void createAndPopulateResults(final List<ItemBatchOperation<?>> operations, final int retryAfterMilliseconds) {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0Mzk4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498043981", "bodyText": "Agreed. Have moved it to the parser. Thanks.", "author": "rakkuma", "createdAt": "2020-10-01T07:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3MTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3Mjc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496272793", "bodyText": "we are not using testng for assertion.\nPlease use assertj here and everywhere else. See one of the existing tests (e.g, CosmosDatabaseTest) as example.\nPlease fix here and in all other tests.", "author": "moderakh", "createdAt": "2020-09-28T22:33:56Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/BatchTestBase.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.ISessionToken;\n+import com.azure.cosmos.implementation.SessionTokenHelper;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.implementation.directconnectivity.WFConstants;\n+import com.azure.cosmos.models.CosmosContainerResponse;\n+import com.azure.cosmos.models.CosmosDatabaseResponse;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+\n+import java.util.Random;\n+import java.util.UUID;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class BatchTestBase extends TestSuiteBase {\n+\n+    private Random random = new Random();\n+    String partitionKey1 = \"TBD1\";\n+\n+    // Documents in partitionKey1\n+    TestDoc TestDocPk1ExistingA;\n+    TestDoc TestDocPk1ExistingB ;\n+    TestDoc TestDocPk1ExistingC;\n+    TestDoc TestDocPk1ExistingD;\n+\n+    public BatchTestBase(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    CosmosAsyncContainer createSharedThroughputContainer(CosmosAsyncClient client) {\n+        CosmosAsyncContainer sharedThroughputContainer = null;\n+        CosmosDatabaseResponse cosmosDatabaseResponse = client.createDatabaseIfNotExists(\n+            \"Shared_\" + UUID.randomUUID().toString(),\n+            ThroughputProperties.createManualThroughput(12000)).block();\n+\n+        CosmosAsyncDatabase db = client.getDatabase(cosmosDatabaseResponse.getProperties().getId());\n+\n+        for (int index = 0; index < 5; index++) {\n+\n+            CosmosContainerResponse cosmosContainerResponse = db.createContainerIfNotExists(getCollectionDefinition()).block();\n+            assertTrue(Boolean.parseBoolean(cosmosContainerResponse.getResponseHeaders().get(WFConstants.BackendHeaders.SHARE_THROUGHPUT)));\n+\n+            if (index == 2) {\n+                sharedThroughputContainer = db.getContainer(cosmosContainerResponse.getProperties().getId());\n+            }\n+        }\n+\n+        return sharedThroughputContainer;\n+    }\n+\n+    void createJsonTestDocsAsync(CosmosAsyncContainer container) {\n+        this.TestDocPk1ExistingA =  this.createJsonTestDocAsync(container, this.partitionKey1);\n+        this.TestDocPk1ExistingB =  this.createJsonTestDocAsync(container, this.partitionKey1);\n+        this.TestDocPk1ExistingC =  this.createJsonTestDocAsync(container, this.partitionKey1);\n+        this.TestDocPk1ExistingD =  this.createJsonTestDocAsync(container, this.partitionKey1);\n+    }\n+\n+    TestDoc populateTestDoc(String partitionKey) {\n+        return populateTestDoc(partitionKey, 20);\n+    }\n+\n+    TestDoc populateTestDoc(String partitionKey, int minDesiredSize) {\n+        String description = StringUtils.repeat(\"x\", minDesiredSize);\n+        return new TestDoc(UUID.randomUUID().toString(), this.random.nextInt(), description, partitionKey);\n+    }\n+\n+    public TestDoc populateTestDoc(String id, String partitionKey) {\n+        String description = StringUtils.repeat(\"x\", 20);\n+        return new TestDoc(id, this.random.nextInt(), description, partitionKey);\n+    }\n+\n+    TestDoc getTestDocCopy(TestDoc testDoc) {\n+        return new TestDoc(testDoc.getId(), testDoc.getCost(), testDoc.getDescription(), testDoc.getStatus());\n+    }\n+\n+    void verifyByReadAsync(CosmosAsyncContainer container, TestDoc doc) {\n+        verifyByReadAsync(container, doc, null);\n+    }\n+\n+    void verifyByReadAsync(CosmosAsyncContainer container, TestDoc doc, String eTag) {\n+        PartitionKey partitionKey = this.getPartitionKey(doc.getStatus());\n+\n+        CosmosItemResponse<TestDoc> response = container.readItem(doc.getId(), partitionKey, TestDoc.class).block();\n+\n+        assertEquals(HttpResponseStatus.OK.code(), response.getStatusCode());", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0Mzc0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498043748", "bodyText": "Yeah. Fixed it in all the test cases. Thanks.", "author": "rakkuma", "createdAt": "2020-10-01T07:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3Mjc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3NDM3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496274373", "bodyText": "shouldn't we capture the exception stacktrace in the TransactionBatchResponse?\nOtherwise without the exception stacktrace it will become hard to diagnose. no?", "author": "moderakh", "createdAt": "2020-09-28T22:38:49Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchResponseParser.java", "diffHunk": "@@ -0,0 +1,245 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS;\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.SUB_STATUS;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+\n+public final class BatchResponseParser {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BatchResponseParser.class);\n+    private final static char HYBRID_V1 = 129;\n+\n+    /** Creates a transactional batch response} from a exception\n+     *\n+     * @param throwable the {@link Throwable error}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link TransactionalBatchResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromErrorResponseAsync(\n+        final Throwable throwable,\n+        final ServerBatchRequest request) {\n+\n+        if (throwable instanceof CosmosException) {\n+            final CosmosException cosmosException = (CosmosException) throwable;\n+            final TransactionalBatchResponse response =  new TransactionalBatchResponse(\n+                cosmosException.getStatusCode(),\n+                cosmosException.getSubStatusCode(),\n+                cosmosException.getMessage(),\n+                cosmosException.getResponseHeaders(),\n+                cosmosException.getDiagnostics(),\n+                request.getOperations());", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNTEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497835103", "bodyText": "Have modified .getmessage() to .toString(). toString() has the message, stack trace. So that can be sufficient.", "author": "rakkuma", "createdAt": "2020-09-30T22:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3NDM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3NjkzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496276930", "bodyText": "can this happen in Java? other than Partition Key can the end user set effective partition key?\nin which scenario this happens?", "author": "moderakh", "createdAt": "2020-09-28T22:46:35Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchExecUtils.java", "diffHunk": "@@ -0,0 +1,113 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.implementation.directconnectivity.WFConstants;\n+import io.netty.buffer.ByteBufUtil;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.batch.BatchRequestResponseConstant.OPERATION_CREATE;\n+import static com.azure.cosmos.implementation.batch.BatchRequestResponseConstant.OPERATION_DELETE;\n+import static com.azure.cosmos.implementation.batch.BatchRequestResponseConstant.OPERATION_READ;\n+import static com.azure.cosmos.implementation.batch.BatchRequestResponseConstant.OPERATION_REPLACE;\n+import static com.azure.cosmos.implementation.batch.BatchRequestResponseConstant.OPERATION_UPSERT;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava27.Strings.lenientFormat;\n+\n+/**\n+ * Util methods for batch requests/response.\n+ */\n+public class BatchExecUtils {\n+\n+    static void ensureValid(\n+        final List<ItemBatchOperation<?>> operations,\n+        final RequestOptions options) {\n+\n+        final String errorMessage = BatchExecUtils.isValid(operations, options);\n+        checkArgument(errorMessage == null, errorMessage);\n+    }\n+\n+    public static String isValid(final List<ItemBatchOperation<?>> operations, final RequestOptions batchOptions) {\n+\n+        String errorMessage = null;\n+\n+        if (operations == null) {\n+            errorMessage = \"expected non-null operations\";\n+        }\n+\n+        if (errorMessage == null && operations.size() == 0) {\n+            errorMessage = \"expected operations.size > 0\";\n+        }\n+\n+        if (errorMessage == null && batchOptions != null) {\n+          if (batchOptions.getIfMatchETag() != null || batchOptions.getIfNoneMatchETag() != null) {\n+              errorMessage = \"one or more request options provided on the batch request are not supported\";\n+          }\n+        }\n+\n+        if (errorMessage == null) {\n+            for (ItemBatchOperation<?> operation : operations) {\n+\n+                final RequestOptions batchOperationOptions = operation.getRequestOptions();\n+                final Map<String, Object> batchOperationProperties = batchOperationOptions != null ? batchOperationOptions.getProperties() : null;\n+\n+                if (batchOperationProperties != null\n+                    && (batchOperationProperties.containsKey(WFConstants.BackendHeaders.EFFECTIVE_PARTITION_KEY)\n+                    || batchOperationProperties.containsKey(WFConstants.BackendHeaders.EFFECTIVE_PARTITION_KEY_STRING)\n+                    || batchOperationProperties.containsKey(HttpConstants.HttpHeaders.PARTITION_KEY))) {\n+\n+                    final String epkString = (String) batchOperationProperties.computeIfPresent(\n+                        WFConstants.BackendHeaders.EFFECTIVE_PARTITION_KEY_STRING,\n+                        (k, v) -> v instanceof String ? v : null);\n+\n+                    final byte[] epk = (byte[]) batchOperationProperties.computeIfPresent(\n+                        WFConstants.BackendHeaders.EFFECTIVE_PARTITION_KEY,\n+                        (k, v) -> v instanceof byte[] ? v : null);\n+\n+                    final String pkString = (String) batchOperationProperties.computeIfPresent(\n+                        HttpConstants.HttpHeaders.PARTITION_KEY,\n+                        (k, v) -> v instanceof String ? v : null);\n+\n+                    if ((epk == null && pkString == null) || epkString == null) {\n+                        return lenientFormat(\n+                            \"expected byte[] value for %s and string value for %s, not (%s, %s)\",\n+                            WFConstants.BackendHeaders.EFFECTIVE_PARTITION_KEY,\n+                            WFConstants.BackendHeaders.EFFECTIVE_PARTITION_KEY_STRING,\n+                            epk == null\n+                                ? (pkString == null ? \"null\" : pkString)\n+                                : ByteBufUtil.hexDump(epk), epkString == null ? \"null\" : epkString);\n+                    }\n+\n+                    if (operation.getPartitionKey() != null ) {\n+                        errorMessage = \"partition key and effective partition key may not both be set.\";", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUxODM2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497518367", "bodyText": "Agreed. My fault. Not likely. Since Java has specific request options and they don't extent request options class which has this property that can have all kind of header set, we don't need to validate this much here.  Will make it shorter.", "author": "rakkuma", "createdAt": "2020-09-30T13:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3NjkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNDg1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497834859", "bodyText": "Remove these functions. They are of no use with no property map.", "author": "rakkuma", "createdAt": "2020-09-30T22:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3NjkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3ODAwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496278003", "bodyText": "use documentServiceResponse.getResponseBodyAsByteArray()  instead it is more efficient also jackson mapper is more optimized to parse from byte array instead of string.", "author": "moderakh", "createdAt": "2020-09-28T22:49:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchResponseParser.java", "diffHunk": "@@ -0,0 +1,245 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS;\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.SUB_STATUS;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+\n+public final class BatchResponseParser {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BatchResponseParser.class);\n+    private final static char HYBRID_V1 = 129;\n+\n+    /** Creates a transactional batch response} from a exception\n+     *\n+     * @param throwable the {@link Throwable error}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link TransactionalBatchResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromErrorResponseAsync(\n+        final Throwable throwable,\n+        final ServerBatchRequest request) {\n+\n+        if (throwable instanceof CosmosException) {\n+            final CosmosException cosmosException = (CosmosException) throwable;\n+            final TransactionalBatchResponse response =  new TransactionalBatchResponse(\n+                cosmosException.getStatusCode(),\n+                cosmosException.getSubStatusCode(),\n+                cosmosException.getMessage(),\n+                cosmosException.getResponseHeaders(),\n+                cosmosException.getDiagnostics(),\n+                request.getOperations());\n+\n+            response.createAndPopulateResults(request.getOperations(), 0);\n+            return Mono.just(response);\n+        } else {\n+            return Mono.error(throwable);\n+        }\n+    }\n+\n+    /** Creates a transactional batch response} from a response message\n+     *\n+     * @param documentServiceResponse the {@link RxDocumentServiceResponse response message}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     * @param shouldPromoteOperationStatus indicates whether the operation status should be promoted.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link RxDocumentServiceResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromDocumentServiceResponseAsync(\n+        final RxDocumentServiceResponse documentServiceResponse,\n+        final ServerBatchRequest request,\n+        final boolean shouldPromoteOperationStatus) {\n+\n+        TransactionalBatchResponse response = null;\n+        final String responseContent = documentServiceResponse.getResponseBodyAsString();\n+\n+        if (StringUtils.isNotEmpty(responseContent)) {\n+            response = BatchResponseParser.populateFromResponseContentAsync(documentServiceResponse, request, shouldPromoteOperationStatus);\n+\n+            if (response == null) {\n+                // Convert any payload read failures as InternalServerError\n+                response = new TransactionalBatchResponse(\n+                    HttpResponseStatus.INTERNAL_SERVER_ERROR.code(),\n+                    0,\n+                    \"ServerResponseDeserializationFailure\",\n+                    documentServiceResponse.getResponseHeaders(),\n+                    documentServiceResponse.getCosmosDiagnostics(),\n+                    request.getOperations());\n+            }\n+        }\n+\n+        int responseStatusCode = documentServiceResponse.getStatusCode();\n+        int responseSubStatusCode = Integer.parseInt(\n+            documentServiceResponse.getResponseHeaders().getOrDefault(SUB_STATUS, String.valueOf(0)));\n+\n+        if (response == null) {\n+            response = new TransactionalBatchResponse(\n+                responseStatusCode,\n+                responseSubStatusCode,\n+                null,\n+                documentServiceResponse.getResponseHeaders(),\n+                documentServiceResponse.getCosmosDiagnostics(),\n+                request.getOperations());\n+        }\n+\n+        if (response.size() != request.getOperations().size()) {\n+            if (responseStatusCode >= 200 && responseStatusCode <= 299)  {\n+                // Server should be guaranteeing number of results equal to operations when\n+                // batch request is successful - so fail as InternalServerError if this is not the case.\n+                response = new TransactionalBatchResponse(\n+                    HttpResponseStatus.INTERNAL_SERVER_ERROR.code(),\n+                    0,\n+                    \"Invalid server response\",\n+                    documentServiceResponse.getResponseHeaders(),\n+                    documentServiceResponse.getCosmosDiagnostics(),\n+                    request.getOperations());\n+            }\n+\n+            // When the overall response status code is TooManyRequests, propagate the RetryAfter into the individual operations.\n+            int retryAfterMilliseconds = 0;\n+\n+            if (responseStatusCode == HttpResponseStatus.TOO_MANY_REQUESTS.code()) {\n+                String retryResponseValue = documentServiceResponse.getResponseHeaders().getOrDefault(RETRY_AFTER_IN_MILLISECONDS, null);\n+                if (StringUtils.isNotEmpty(retryResponseValue)) {\n+                    try {\n+                        retryAfterMilliseconds = Integer.parseInt(retryResponseValue);\n+                    } catch (NumberFormatException ex) {\n+                        // Do nothing. It's number format exception\n+                    }\n+                }\n+            }\n+\n+            response.createAndPopulateResults(request.getOperations(), retryAfterMilliseconds);\n+        }\n+\n+        checkState(response.size() == request.getOperations().size(),\n+            \"Number of responses should be equal to number of operations in request.\");\n+\n+        return Mono.just(response);\n+    }\n+\n+    private static TransactionalBatchResponse populateFromResponseContentAsync(\n+        final RxDocumentServiceResponse documentServiceResponse,\n+        final ServerBatchRequest request,\n+        final boolean shouldPromoteOperationStatus) {\n+\n+        final ArrayList<TransactionalBatchOperationResult<?>> results = new ArrayList<>();\n+        final String responseContent = documentServiceResponse.getResponseBodyAsString();", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNDY1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497834652", "bodyText": "Thanks. Fixed it.", "author": "rakkuma", "createdAt": "2020-09-30T22:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3ODAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3ODUxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496278511", "bodyText": "as you have ServerBatchRequest you should have access to the number of operations in the request and that should be the same as the number or results in the response.. so can we reserve size in ArrayList?\nnew ArrayList<>(request.size());", "author": "moderakh", "createdAt": "2020-09-28T22:51:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchResponseParser.java", "diffHunk": "@@ -0,0 +1,245 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS;\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.SUB_STATUS;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+\n+public final class BatchResponseParser {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BatchResponseParser.class);\n+    private final static char HYBRID_V1 = 129;\n+\n+    /** Creates a transactional batch response} from a exception\n+     *\n+     * @param throwable the {@link Throwable error}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link TransactionalBatchResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromErrorResponseAsync(\n+        final Throwable throwable,\n+        final ServerBatchRequest request) {\n+\n+        if (throwable instanceof CosmosException) {\n+            final CosmosException cosmosException = (CosmosException) throwable;\n+            final TransactionalBatchResponse response =  new TransactionalBatchResponse(\n+                cosmosException.getStatusCode(),\n+                cosmosException.getSubStatusCode(),\n+                cosmosException.getMessage(),\n+                cosmosException.getResponseHeaders(),\n+                cosmosException.getDiagnostics(),\n+                request.getOperations());\n+\n+            response.createAndPopulateResults(request.getOperations(), 0);\n+            return Mono.just(response);\n+        } else {\n+            return Mono.error(throwable);\n+        }\n+    }\n+\n+    /** Creates a transactional batch response} from a response message\n+     *\n+     * @param documentServiceResponse the {@link RxDocumentServiceResponse response message}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     * @param shouldPromoteOperationStatus indicates whether the operation status should be promoted.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link RxDocumentServiceResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromDocumentServiceResponseAsync(\n+        final RxDocumentServiceResponse documentServiceResponse,\n+        final ServerBatchRequest request,\n+        final boolean shouldPromoteOperationStatus) {\n+\n+        TransactionalBatchResponse response = null;\n+        final String responseContent = documentServiceResponse.getResponseBodyAsString();\n+\n+        if (StringUtils.isNotEmpty(responseContent)) {\n+            response = BatchResponseParser.populateFromResponseContentAsync(documentServiceResponse, request, shouldPromoteOperationStatus);\n+\n+            if (response == null) {\n+                // Convert any payload read failures as InternalServerError\n+                response = new TransactionalBatchResponse(\n+                    HttpResponseStatus.INTERNAL_SERVER_ERROR.code(),\n+                    0,\n+                    \"ServerResponseDeserializationFailure\",\n+                    documentServiceResponse.getResponseHeaders(),\n+                    documentServiceResponse.getCosmosDiagnostics(),\n+                    request.getOperations());\n+            }\n+        }\n+\n+        int responseStatusCode = documentServiceResponse.getStatusCode();\n+        int responseSubStatusCode = Integer.parseInt(\n+            documentServiceResponse.getResponseHeaders().getOrDefault(SUB_STATUS, String.valueOf(0)));\n+\n+        if (response == null) {\n+            response = new TransactionalBatchResponse(\n+                responseStatusCode,\n+                responseSubStatusCode,\n+                null,\n+                documentServiceResponse.getResponseHeaders(),\n+                documentServiceResponse.getCosmosDiagnostics(),\n+                request.getOperations());\n+        }\n+\n+        if (response.size() != request.getOperations().size()) {\n+            if (responseStatusCode >= 200 && responseStatusCode <= 299)  {\n+                // Server should be guaranteeing number of results equal to operations when\n+                // batch request is successful - so fail as InternalServerError if this is not the case.\n+                response = new TransactionalBatchResponse(\n+                    HttpResponseStatus.INTERNAL_SERVER_ERROR.code(),\n+                    0,\n+                    \"Invalid server response\",\n+                    documentServiceResponse.getResponseHeaders(),\n+                    documentServiceResponse.getCosmosDiagnostics(),\n+                    request.getOperations());\n+            }\n+\n+            // When the overall response status code is TooManyRequests, propagate the RetryAfter into the individual operations.\n+            int retryAfterMilliseconds = 0;\n+\n+            if (responseStatusCode == HttpResponseStatus.TOO_MANY_REQUESTS.code()) {\n+                String retryResponseValue = documentServiceResponse.getResponseHeaders().getOrDefault(RETRY_AFTER_IN_MILLISECONDS, null);\n+                if (StringUtils.isNotEmpty(retryResponseValue)) {\n+                    try {\n+                        retryAfterMilliseconds = Integer.parseInt(retryResponseValue);\n+                    } catch (NumberFormatException ex) {\n+                        // Do nothing. It's number format exception\n+                    }\n+                }\n+            }\n+\n+            response.createAndPopulateResults(request.getOperations(), retryAfterMilliseconds);\n+        }\n+\n+        checkState(response.size() == request.getOperations().size(),\n+            \"Number of responses should be equal to number of operations in request.\");\n+\n+        return Mono.just(response);\n+    }\n+\n+    private static TransactionalBatchResponse populateFromResponseContentAsync(\n+        final RxDocumentServiceResponse documentServiceResponse,\n+        final ServerBatchRequest request,\n+        final boolean shouldPromoteOperationStatus) {\n+\n+        final ArrayList<TransactionalBatchOperationResult<?>> results = new ArrayList<>();", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0MzE0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498043143", "bodyText": "Yes. Fixed. Thanks.", "author": "rakkuma", "createdAt": "2020-10-01T07:39:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3ODUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI4MDA3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496280073", "bodyText": "as our CI tests are running against prod endpoint we are stingy on how many databases and containers we create and also their cleanup.\nCan you use the shared database and containers created in TestSuiteBase? see CosmosItemTest as example.\nAny reason we have to create dedicated database and containers here and not reuse the shared ones for all tests?", "author": "moderakh", "createdAt": "2020-09-28T22:56:25Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/BatchTestBase.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.ISessionToken;\n+import com.azure.cosmos.implementation.SessionTokenHelper;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.implementation.directconnectivity.WFConstants;\n+import com.azure.cosmos.models.CosmosContainerResponse;\n+import com.azure.cosmos.models.CosmosDatabaseResponse;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+\n+import java.util.Random;\n+import java.util.UUID;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class BatchTestBase extends TestSuiteBase {\n+\n+    private Random random = new Random();\n+    String partitionKey1 = \"TBD1\";\n+\n+    // Documents in partitionKey1\n+    TestDoc TestDocPk1ExistingA;\n+    TestDoc TestDocPk1ExistingB ;\n+    TestDoc TestDocPk1ExistingC;\n+    TestDoc TestDocPk1ExistingD;\n+\n+    public BatchTestBase(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    CosmosAsyncContainer createSharedThroughputContainer(CosmosAsyncClient client) {\n+        CosmosAsyncContainer sharedThroughputContainer = null;\n+        CosmosDatabaseResponse cosmosDatabaseResponse = client.createDatabaseIfNotExists(\n+            \"Shared_\" + UUID.randomUUID().toString(),", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NjY1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496546655", "bodyText": "This was a shared throughput database, which I couldn't find. All the other batch test cases are reusing old ones.", "author": "rakkuma", "createdAt": "2020-09-29T08:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI4MDA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2NDE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496664162", "bodyText": "I think usually we throw an IllegalArguemntException when doing null-validation of parameters in public surface area - this one will throw a NullPointerException instead.\n@moderakh / @kushagraThapar - I haven't found clear guidance on this in the Java world in the past (NPE vs. IllegalArgumentException for null-checks). Are the Azure SDK common guidelines? If not do you have a strong preference for one over the other?", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T12:09:41Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatch.java", "diffHunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+\n+import java.util.ArrayList;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a batch of operations against items with the same {@link PartitionKey} in a container that will be performed\n+ * in a transactional manner at the Azure Cosmos DB service.\n+ * <p>\n+ * Use {@link TransactionalBatch#createTransactionalBatch(PartitionKey)} or new {@link #TransactionalBatch(PartitionKey)}\n+ * to create an instance of TransactionalBatch\n+ * <b>Example</b>\n+ * This example atomically modifies a set of documents as a batch.\n+ * <pre>{@code\n+ * public class ToDoActivity {\n+ *     public final String type;\n+ *     public final String id;\n+ *     public final String status;\n+ *     public ToDoActivity(String type, String id, String status) {\n+ *         this.type = type;\n+ *         this.id = id;\n+ *         this.status = status;\n+ *     }\n+ * }\n+ *\n+ * String activityType = \"personal\";\n+ *\n+ * ToDoActivity test1 = new ToDoActivity(activityType, \"learning\", \"ToBeDone\");\n+ * ToDoActivity test2 = new ToDoActivity(activityType, \"shopping\", \"Done\");\n+ * ToDoActivity test3 = new ToDoActivity(activityType, \"swimming\", \"ToBeDone\");\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .createItem<ToDoActivity>(test1)\n+ *     .replaceItem<ToDoActivity>(test2.id, test2)\n+ *     .upsertItem<ToDoActivity>(test3)\n+ *     .deleteItem(\"reading\");\n+ *\n+ * try (TransactionalBatchResponse response = container.executeTransactionalBatch(batch) {\n+ *\n+ *     if (!response.IsSuccessStatusCode) {\n+ *        // Handle and log exception\n+ *        return;\n+ *     }\n+ *\n+ *     // Look up interested results - e.g., via typed access on operation results\n+ *\n+ *     TransactionalBatchOperationResult<ToDoActivity> result = response.getOperationResultAtIndex<ToDoActivity>(0, ToDoActivity.class);\n+ *     ToDoActivity readActivity = result.getItem();\n+ * }\n+ * }</pre>\n+ *\n+ * <b>Example</b>\n+ * <p>This example atomically reads a set of documents as a batch.\n+ * <pre>{@code\n+ * String activityType = \"personal\";\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .readItem(\"playing\")\n+ *     .readItem(\"walking\")\n+ *     .readItem(\"jogging\")\n+ *     .readItem(\"running\")\n+ *\n+ * try (TransactionalBatchResponse response = container.executeTransactionalBatch(new Cosmos.PartitionKey(activityType)) {\n+ *\n+ *     // Look up interested results - eg. via direct access to operation result stream\n+ *\n+ *     List<String> resultItems = new ArrayList<String>();\n+ *\n+ *     for (TransactionalBatchOperationResult result : response) {\n+ *         resultItems.add(result.getResourceObject().toString())\n+ *     }\n+ * }\n+ * }</pre>\n+ * <p>\n+ * <b>See:</b>\n+ * <a href=\"https://docs.microsoft.com/azure/cosmos-db/concepts-limits\">Limits on TransactionalBatch requests</a>.\n+ */\n+public final class TransactionalBatch {\n+\n+    private final ArrayList<ItemBatchOperation<?>> operations;\n+    private final PartitionKey partitionKey;\n+\n+    public TransactionalBatch(PartitionKey partitionKey) {\n+        this.operations = new ArrayList<>();\n+        this.partitionKey = partitionKey;\n+    }\n+\n+    /**\n+     * Initializes a new instance of {@link TransactionalBatch}\n+     * that will contain operations to be performed across multiple items in the container with the provided partition\n+     * key in a transactional manner\n+     *\n+     * @param partitionKey the partition key for all items in the batch.\n+     *\n+     * @return A new instance of {@link TransactionalBatch}.\n+     */\n+    public static TransactionalBatch createTransactionalBatch(PartitionKey partitionKey) {\n+        return new TransactionalBatch(partitionKey);\n+    }\n+\n+    /**\n+     * Adds an operation to create an item into the batch.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param <T> The type of item to be created.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> TransactionalBatch createItem(T item) {\n+        checkNotNull(item, \"expected non-null item\");", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxNDAyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497614027", "bodyText": "Discussed in-person - we aren't consistent right now - tendency was to use NullPointerException instead of IllegalArgumentException going forward.", "author": "FabianMeiswinkel", "createdAt": "2020-09-30T15:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2NDE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTUzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496669538", "bodyText": "This leaks an implementation class into the public surface area. Either ItemBatchOperation needs to be moved to public area (com.azure.cosmos.model) or not be exposed here.", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T12:18:48Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,340 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+public class TransactionalBatchResponse implements AutoCloseable, List<TransactionalBatchOperationResult<?>> {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchResponse.class);\n+\n+    private Map<String, String> responseHeaders;\n+    private final int responseStatus;\n+    private String errorMessage;\n+    private List<TransactionalBatchOperationResult<?>> results;\n+    private int subStatusCode;\n+    private List<ItemBatchOperation<?>> operations;\n+    private CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchResponse} class.\n+     *\n+     * @param responseStatus the  response status.\n+     * @param subStatusCode the response sub-status code.\n+     * @param errorMessage an error message or {@code null}.\n+     * @param responseHeaders the response http headers\n+     * @param cosmosDiagnostics the diagnostic\n+     * @param operations a {@link List list} of {@link ItemBatchOperation batch operations}.\n+     */\n+    public TransactionalBatchResponse(\n+        final int responseStatus,\n+        final int subStatusCode,\n+        final String errorMessage,\n+        final Map<String, String> responseHeaders,\n+        final CosmosDiagnostics cosmosDiagnostics,\n+        final List<ItemBatchOperation<?>> operations) {", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMxMDUzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497310531", "bodyText": "This can be required for bulk with current implementation, but ItemBatchOperation is how we keep operation In TransactionalBatch. May be it can be moved in Model then.", "author": "rakkuma", "createdAt": "2020-09-30T07:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMxMzA3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r497313075", "bodyText": "But if the get functions are package private in TransactionalBatchResponse and TransactionalBatch, then is it needed to keep it in public ?", "author": "rakkuma", "createdAt": "2020-09-30T07:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyMzcwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498323700", "bodyText": "All good now - as long as it is only exposed in package private API it isn't a problem", "author": "FabianMeiswinkel", "createdAt": "2020-10-01T15:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0ODY2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498348660", "bodyText": "Cool. Thanks!!", "author": "rakkuma", "createdAt": "2020-10-01T15:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MzQyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496673425", "bodyText": "RxDocumentServiceRequest today has a method isReadOnlyScript and isReadOnlyRequest - they are basically used to decide whether CosnistencyReader or ConsistencyWriter is used - currently you would treat all transactional bacthes as writes - even if they only contain ReadItem calls. I think that is a bug/problem - because it means even reads would always be targeting the master replica. It is possible that .Net has the same issue today - but I think it is worth fixing in Java form the beginning?", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T12:25:12Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/OperationType.java", "diffHunk": "@@ -10,6 +10,7 @@\n     AbortPartitionMigration,\n     AbortSplit,\n     AddComputeGatewayRequestCharges,\n+    Batch,", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3Mzc2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496673766", "bodyText": "@kirankumarkolli  / @moderakh  / @kushagraThapar  - what are your thoughts on this?", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T12:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MzQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODExMTg0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498111848", "bodyText": "This is something we do know and it's not a bug. It's also in my TODOs, but don't know if customer requirement is for read only batch/bulk. However a nice to have feature. Enabling read should work without any backend changes, but of-course verification is needed.", "author": "rakkuma", "createdAt": "2020-10-01T09:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MzQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEzMDg4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498130881", "bodyText": "agree that this is not functionally blocking. It becomes relevant only when comparing perf between the custom ReadMany API vs. Bulk with just read-operations. I think it is ok to move forward with this PR without addressing it - needs to be addressed across Java and .Net as a perf improvement at some point", "author": "FabianMeiswinkel", "createdAt": "2020-10-01T10:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MzQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3NzY0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496677648", "bodyText": "Please file a github work item to track this work and add the item number here / link here.", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T12:32:06Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchResponseParser.java", "diffHunk": "@@ -0,0 +1,245 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS;\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.SUB_STATUS;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+\n+public final class BatchResponseParser {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BatchResponseParser.class);\n+    private final static char HYBRID_V1 = 129;\n+\n+    /** Creates a transactional batch response} from a exception\n+     *\n+     * @param throwable the {@link Throwable error}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link TransactionalBatchResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromErrorResponseAsync(\n+        final Throwable throwable,\n+        final ServerBatchRequest request) {\n+\n+        if (throwable instanceof CosmosException) {\n+            final CosmosException cosmosException = (CosmosException) throwable;\n+            final TransactionalBatchResponse response =  new TransactionalBatchResponse(\n+                cosmosException.getStatusCode(),\n+                cosmosException.getSubStatusCode(),\n+                cosmosException.getMessage(),\n+                cosmosException.getResponseHeaders(),\n+                cosmosException.getDiagnostics(),\n+                request.getOperations());\n+\n+            response.createAndPopulateResults(request.getOperations(), 0);\n+            return Mono.just(response);\n+        } else {\n+            return Mono.error(throwable);\n+        }\n+    }\n+\n+    /** Creates a transactional batch response} from a response message\n+     *\n+     * @param documentServiceResponse the {@link RxDocumentServiceResponse response message}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     * @param shouldPromoteOperationStatus indicates whether the operation status should be promoted.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link RxDocumentServiceResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromDocumentServiceResponseAsync(\n+        final RxDocumentServiceResponse documentServiceResponse,\n+        final ServerBatchRequest request,\n+        final boolean shouldPromoteOperationStatus) {\n+\n+        TransactionalBatchResponse response = null;\n+        final String responseContent = documentServiceResponse.getResponseBodyAsString();\n+\n+        if (StringUtils.isNotEmpty(responseContent)) {\n+            response = BatchResponseParser.populateFromResponseContentAsync(documentServiceResponse, request, shouldPromoteOperationStatus);\n+\n+            if (response == null) {\n+                // Convert any payload read failures as InternalServerError\n+                response = new TransactionalBatchResponse(\n+                    HttpResponseStatus.INTERNAL_SERVER_ERROR.code(),\n+                    0,\n+                    \"ServerResponseDeserializationFailure\",\n+                    documentServiceResponse.getResponseHeaders(),\n+                    documentServiceResponse.getCosmosDiagnostics(),\n+                    request.getOperations());\n+            }\n+        }\n+\n+        int responseStatusCode = documentServiceResponse.getStatusCode();\n+        int responseSubStatusCode = Integer.parseInt(\n+            documentServiceResponse.getResponseHeaders().getOrDefault(SUB_STATUS, String.valueOf(0)));\n+\n+        if (response == null) {\n+            response = new TransactionalBatchResponse(\n+                responseStatusCode,\n+                responseSubStatusCode,\n+                null,\n+                documentServiceResponse.getResponseHeaders(),\n+                documentServiceResponse.getCosmosDiagnostics(),\n+                request.getOperations());\n+        }\n+\n+        if (response.size() != request.getOperations().size()) {\n+            if (responseStatusCode >= 200 && responseStatusCode <= 299)  {\n+                // Server should be guaranteeing number of results equal to operations when\n+                // batch request is successful - so fail as InternalServerError if this is not the case.\n+                response = new TransactionalBatchResponse(\n+                    HttpResponseStatus.INTERNAL_SERVER_ERROR.code(),\n+                    0,\n+                    \"Invalid server response\",\n+                    documentServiceResponse.getResponseHeaders(),\n+                    documentServiceResponse.getCosmosDiagnostics(),\n+                    request.getOperations());\n+            }\n+\n+            // When the overall response status code is TooManyRequests, propagate the RetryAfter into the individual operations.\n+            int retryAfterMilliseconds = 0;\n+\n+            if (responseStatusCode == HttpResponseStatus.TOO_MANY_REQUESTS.code()) {\n+                String retryResponseValue = documentServiceResponse.getResponseHeaders().getOrDefault(RETRY_AFTER_IN_MILLISECONDS, null);\n+                if (StringUtils.isNotEmpty(retryResponseValue)) {\n+                    try {\n+                        retryAfterMilliseconds = Integer.parseInt(retryResponseValue);\n+                    } catch (NumberFormatException ex) {\n+                        // Do nothing. It's number format exception\n+                    }\n+                }\n+            }\n+\n+            response.createAndPopulateResults(request.getOperations(), retryAfterMilliseconds);\n+        }\n+\n+        checkState(response.size() == request.getOperations().size(),\n+            \"Number of responses should be equal to number of operations in request.\");\n+\n+        return Mono.just(response);\n+    }\n+\n+    private static TransactionalBatchResponse populateFromResponseContentAsync(\n+        final RxDocumentServiceResponse documentServiceResponse,\n+        final ServerBatchRequest request,\n+        final boolean shouldPromoteOperationStatus) {\n+\n+        final ArrayList<TransactionalBatchOperationResult<?>> results = new ArrayList<>();\n+        final String responseContent = documentServiceResponse.getResponseBodyAsString();\n+\n+        if (responseContent.charAt(0) != HYBRID_V1) {\n+            // Read from a json response body. To enable hybrid row just complete the else part\n+            final ObjectMapper mapper = Utils.getSimpleObjectMapper();\n+\n+            try{\n+                final ObjectNode[] objectNodes = mapper.readValue(documentServiceResponse.getResponseBodyAsString(), ObjectNode[].class);\n+                for (ObjectNode objectInArray : objectNodes) {\n+                    final TransactionalBatchOperationResult<?> batchOperationResult = BatchResponseParser.createBatchOperationResultFromJson(objectInArray);\n+                    results.add(batchOperationResult);\n+                }\n+            } catch (IOException ex) {\n+                logger.error(\"Exception in parsing response\", ex);\n+            }\n+\n+        } else {\n+            // TODO(rakkuma): Implement hybrid row response parsing logic here. Parse the response hybrid row buffer", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NzM5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498177394", "bodyText": "Created and added the workitem. Thanks.", "author": "rakkuma", "createdAt": "2020-10-01T11:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3NzY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3NzgxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r496677817", "bodyText": "dito", "author": "FabianMeiswinkel", "createdAt": "2020-09-29T12:32:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchResponseParser.java", "diffHunk": "@@ -0,0 +1,245 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS;\n+import static com.azure.cosmos.implementation.HttpConstants.HttpHeaders.SUB_STATUS;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+\n+public final class BatchResponseParser {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BatchResponseParser.class);\n+    private final static char HYBRID_V1 = 129;\n+\n+    /** Creates a transactional batch response} from a exception\n+     *\n+     * @param throwable the {@link Throwable error}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link TransactionalBatchResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromErrorResponseAsync(\n+        final Throwable throwable,\n+        final ServerBatchRequest request) {\n+\n+        if (throwable instanceof CosmosException) {\n+            final CosmosException cosmosException = (CosmosException) throwable;\n+            final TransactionalBatchResponse response =  new TransactionalBatchResponse(\n+                cosmosException.getStatusCode(),\n+                cosmosException.getSubStatusCode(),\n+                cosmosException.getMessage(),\n+                cosmosException.getResponseHeaders(),\n+                cosmosException.getDiagnostics(),\n+                request.getOperations());\n+\n+            response.createAndPopulateResults(request.getOperations(), 0);\n+            return Mono.just(response);\n+        } else {\n+            return Mono.error(throwable);\n+        }\n+    }\n+\n+    /** Creates a transactional batch response} from a response message\n+     *\n+     * @param documentServiceResponse the {@link RxDocumentServiceResponse response message}.\n+     * @param request the {@link ServerBatchRequest batch request} that produced {@code message}.\n+     * @param shouldPromoteOperationStatus indicates whether the operation status should be promoted.\n+     *\n+     * @return a Mono that provides the {@link TransactionalBatchResponse transactional batch response} created\n+     * from {@link RxDocumentServiceResponse message} when the asynchronous operation completes.\n+     */\n+    public static Mono<TransactionalBatchResponse> fromDocumentServiceResponseAsync(\n+        final RxDocumentServiceResponse documentServiceResponse,\n+        final ServerBatchRequest request,\n+        final boolean shouldPromoteOperationStatus) {\n+\n+        TransactionalBatchResponse response = null;\n+        final String responseContent = documentServiceResponse.getResponseBodyAsString();\n+\n+        if (StringUtils.isNotEmpty(responseContent)) {\n+            response = BatchResponseParser.populateFromResponseContentAsync(documentServiceResponse, request, shouldPromoteOperationStatus);\n+\n+            if (response == null) {\n+                // Convert any payload read failures as InternalServerError\n+                response = new TransactionalBatchResponse(\n+                    HttpResponseStatus.INTERNAL_SERVER_ERROR.code(),\n+                    0,\n+                    \"ServerResponseDeserializationFailure\",\n+                    documentServiceResponse.getResponseHeaders(),\n+                    documentServiceResponse.getCosmosDiagnostics(),\n+                    request.getOperations());\n+            }\n+        }\n+\n+        int responseStatusCode = documentServiceResponse.getStatusCode();\n+        int responseSubStatusCode = Integer.parseInt(\n+            documentServiceResponse.getResponseHeaders().getOrDefault(SUB_STATUS, String.valueOf(0)));\n+\n+        if (response == null) {\n+            response = new TransactionalBatchResponse(\n+                responseStatusCode,\n+                responseSubStatusCode,\n+                null,\n+                documentServiceResponse.getResponseHeaders(),\n+                documentServiceResponse.getCosmosDiagnostics(),\n+                request.getOperations());\n+        }\n+\n+        if (response.size() != request.getOperations().size()) {\n+            if (responseStatusCode >= 200 && responseStatusCode <= 299)  {\n+                // Server should be guaranteeing number of results equal to operations when\n+                // batch request is successful - so fail as InternalServerError if this is not the case.\n+                response = new TransactionalBatchResponse(\n+                    HttpResponseStatus.INTERNAL_SERVER_ERROR.code(),\n+                    0,\n+                    \"Invalid server response\",\n+                    documentServiceResponse.getResponseHeaders(),\n+                    documentServiceResponse.getCosmosDiagnostics(),\n+                    request.getOperations());\n+            }\n+\n+            // When the overall response status code is TooManyRequests, propagate the RetryAfter into the individual operations.\n+            int retryAfterMilliseconds = 0;\n+\n+            if (responseStatusCode == HttpResponseStatus.TOO_MANY_REQUESTS.code()) {\n+                String retryResponseValue = documentServiceResponse.getResponseHeaders().getOrDefault(RETRY_AFTER_IN_MILLISECONDS, null);\n+                if (StringUtils.isNotEmpty(retryResponseValue)) {\n+                    try {\n+                        retryAfterMilliseconds = Integer.parseInt(retryResponseValue);\n+                    } catch (NumberFormatException ex) {\n+                        // Do nothing. It's number format exception\n+                    }\n+                }\n+            }\n+\n+            response.createAndPopulateResults(request.getOperations(), retryAfterMilliseconds);\n+        }\n+\n+        checkState(response.size() == request.getOperations().size(),\n+            \"Number of responses should be equal to number of operations in request.\");\n+\n+        return Mono.just(response);\n+    }\n+\n+    private static TransactionalBatchResponse populateFromResponseContentAsync(\n+        final RxDocumentServiceResponse documentServiceResponse,\n+        final ServerBatchRequest request,\n+        final boolean shouldPromoteOperationStatus) {\n+\n+        final ArrayList<TransactionalBatchOperationResult<?>> results = new ArrayList<>();\n+        final String responseContent = documentServiceResponse.getResponseBodyAsString();\n+\n+        if (responseContent.charAt(0) != HYBRID_V1) {\n+            // Read from a json response body. To enable hybrid row just complete the else part\n+            final ObjectMapper mapper = Utils.getSimpleObjectMapper();\n+\n+            try{\n+                final ObjectNode[] objectNodes = mapper.readValue(documentServiceResponse.getResponseBodyAsString(), ObjectNode[].class);\n+                for (ObjectNode objectInArray : objectNodes) {\n+                    final TransactionalBatchOperationResult<?> batchOperationResult = BatchResponseParser.createBatchOperationResultFromJson(objectInArray);\n+                    results.add(batchOperationResult);\n+                }\n+            } catch (IOException ex) {\n+                logger.error(\"Exception in parsing response\", ex);\n+            }\n+\n+        } else {\n+            // TODO(rakkuma): Implement hybrid row response parsing logic here. Parse the response hybrid row buffer\n+            //  into array list of TransactionalBatchOperationResult. Remaining part is taken care from the caller function.\n+            logger.error(\"Hybrid row is not implemented right now\");\n+            return null;\n+        }\n+\n+        int responseStatusCode = documentServiceResponse.getStatusCode();\n+        int responseSubStatusCode = Integer.parseInt(\n+            documentServiceResponse.getResponseHeaders().getOrDefault(SUB_STATUS, String.valueOf(HttpConstants.SubStatusCodes.UNKNOWN)));\n+\n+        // Status code of the exact operation which failed.\n+        if (responseStatusCode ==  HttpResponseStatus.MULTI_STATUS.code()\n+            && shouldPromoteOperationStatus) {\n+            for (TransactionalBatchOperationResult<?> result : results) {\n+                if (result.getResponseStatus()!=  HttpResponseStatus.FAILED_DEPENDENCY.code()) {\n+                    responseStatusCode = result.getResponseStatus();\n+                    responseSubStatusCode = result.getSubStatusCode();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        final TransactionalBatchResponse response = new TransactionalBatchResponse(\n+            responseStatusCode,\n+            responseSubStatusCode,\n+            null,\n+            documentServiceResponse.getResponseHeaders(),\n+            documentServiceResponse.getCosmosDiagnostics(),\n+            request.getOperations());\n+\n+        response.addAll(results);\n+\n+        return response;\n+    }\n+\n+    /**\n+     * Read batch operation result result.\n+     *\n+     *  TODO(rakkuma): Similarly hybrid row result needs to be parsed.\n+     *\n+     * @param objectNode having response for a single operation.", "originalCommit": "1ce5af2a0fcdd35701399f9800c1dfcf14a26b5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d8865398ced1e9abeb107f1d5759a54cfeff76e6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d8865398ced1e9abeb107f1d5759a54cfeff76e6", "message": "Code review changes\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-09-30T18:55:08Z", "type": "commit"}, {"oid": "752ab934d290a00898b3227c84de3a7935ef5f8f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/752ab934d290a00898b3227c84de3a7935ef5f8f", "message": "Merge branch 'master' into users/rakkuma/transactional-batch", "committedDate": "2020-09-30T19:00:09Z", "type": "commit"}, {"oid": "a8103d833ae50ecc6a58abc408d8855f91fa63e5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a8103d833ae50ecc6a58abc408d8855f91fa63e5", "message": "Few more fixes\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-09-30T21:51:01Z", "type": "commit"}, {"oid": "57868b518b82307b2aad304e2e0539c9acced56a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/57868b518b82307b2aad304e2e0539c9acced56a", "message": "Merging with master\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-09-30T22:07:31Z", "type": "commit"}, {"oid": "55ac0c568a941cadb6e9c93cfd98ba823310c7af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/55ac0c568a941cadb6e9c93cfd98ba823310c7af", "message": "Fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-09-30T22:11:51Z", "type": "commit"}, {"oid": "136c20cb3af818cb5bcef55dd07e4281cd21e26c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/136c20cb3af818cb5bcef55dd07e4281cd21e26c", "message": "fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-01T07:35:44Z", "type": "commit"}, {"oid": "24633c980f08de87372b7ed8fa401d29f2d1a6ae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/24633c980f08de87372b7ed8fa401d29f2d1a6ae", "message": "Added issue link\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-01T10:07:02Z", "type": "commit"}, {"oid": "9d0bdeea79bbbf3ecafb75e7822765e01f012a62", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9d0bdeea79bbbf3ecafb75e7822765e01f012a62", "message": "Merge branch 'master' into users/rakkuma/transactional-batch", "committedDate": "2020-10-01T10:07:42Z", "type": "commit"}, {"oid": "6cd936358e28cff3de85b8dccb0d21e7d7eae620", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6cd936358e28cff3de85b8dccb0d21e7d7eae620", "message": "beta version change\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-01T10:09:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNzA2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498307062", "bodyText": "The class and all public members should have the 4_7_0 Beta tag as well", "author": "FabianMeiswinkel", "createdAt": "2020-10-01T14:52:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatch.java", "diffHunk": "@@ -0,0 +1,320 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a batch of operations against items with the same {@link PartitionKey} in a container that will be performed\n+ * in a transactional manner at the Azure Cosmos DB service.\n+ * <p>\n+ * Use {@link TransactionalBatch#createTransactionalBatch(PartitionKey)} or new {@link #TransactionalBatch(PartitionKey)}\n+ * to create an instance of TransactionalBatch\n+ * <b>Example</b>\n+ * This example atomically modifies a set of documents as a batch.\n+ * <pre>{@code\n+ * public class ToDoActivity {\n+ *     public final String type;\n+ *     public final String id;\n+ *     public final String status;\n+ *     public ToDoActivity(String type, String id, String status) {\n+ *         this.type = type;\n+ *         this.id = id;\n+ *         this.status = status;\n+ *     }\n+ * }\n+ *\n+ * String activityType = \"personal\";\n+ *\n+ * ToDoActivity test1 = new ToDoActivity(activityType, \"learning\", \"ToBeDone\");\n+ * ToDoActivity test2 = new ToDoActivity(activityType, \"shopping\", \"Done\");\n+ * ToDoActivity test3 = new ToDoActivity(activityType, \"swimming\", \"ToBeDone\");\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .createItem<ToDoActivity>(test1)\n+ *     .replaceItem<ToDoActivity>(test2.id, test2)\n+ *     .upsertItem<ToDoActivity>(test3)\n+ *     .deleteItem(\"reading\");\n+ *\n+ * try (TransactionalBatchResponse response = container.executeTransactionalBatch(batch) {\n+ *\n+ *     if (!response.IsSuccessStatusCode) {\n+ *        // Handle and log exception\n+ *        return;\n+ *     }\n+ *\n+ *     // Look up interested results - e.g., via typed access on operation results\n+ *\n+ *     TransactionalBatchOperationResult<ToDoActivity> result = response.getOperationResultAtIndex<ToDoActivity>(0, ToDoActivity.class);\n+ *     ToDoActivity readActivity = result.getItem();\n+ * }\n+ * }</pre>\n+ *\n+ * <b>Example</b>\n+ * <p>This example atomically reads a set of documents as a batch.\n+ * <pre>{@code\n+ * String activityType = \"personal\";\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .readItem(\"playing\")\n+ *     .readItem(\"walking\")\n+ *     .readItem(\"jogging\")\n+ *     .readItem(\"running\")\n+ *\n+ * try (TransactionalBatchResponse response = container.executeTransactionalBatch(batch) {\n+ *\n+ *     // Look up interested results - eg. via direct access to operation result stream\n+ *\n+ *     List<String> resultItems = new ArrayList<String>();\n+ *\n+ *     for (TransactionalBatchOperationResult result : response) {\n+ *         resultItems.add(result.getResourceObject().toString())\n+ *     }\n+ * }\n+ * }</pre>\n+ * <p>\n+ * <b>See:</b>\n+ * <a href=\"https://docs.microsoft.com/azure/cosmos-db/concepts-limits\">Limits on TransactionalBatch requests</a>.\n+ */\n+public final class TransactionalBatch {", "originalCommit": "6cd936358e28cff3de85b8dccb0d21e7d7eae620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3OTYyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498379621", "bodyText": "Oh. Fixed. Thanks!", "author": "rakkuma", "createdAt": "2020-10-01T16:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNzA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNzg5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498307891", "bodyText": "@beta(Beta.SinceVersion.V4_7_0) missing for class and public members", "author": "FabianMeiswinkel", "createdAt": "2020-10-01T14:53:45Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchItemRequestOptions.java", "diffHunk": "@@ -0,0 +1,58 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+\n+public final class TransactionalBatchItemRequestOptions {", "originalCommit": "6cd936358e28cff3de85b8dccb0d21e7d7eae620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4MDE0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498380140", "bodyText": "Fixed.", "author": "rakkuma", "createdAt": "2020-10-01T16:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwODM3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498308370", "bodyText": "Dito -  @beta(Beta.SinceVersion.V4_7_0) missing", "author": "FabianMeiswinkel", "createdAt": "2020-10-01T14:54:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+public final class TransactionalBatchOperationResult<TResource> {", "originalCommit": "6cd936358e28cff3de85b8dccb0d21e7d7eae620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4MDIzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498380236", "bodyText": "Fixed.", "author": "rakkuma", "createdAt": "2020-10-01T16:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwODM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyMTI5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498321294", "bodyText": "Beta tags missing", "author": "FabianMeiswinkel", "createdAt": "2020-10-01T15:11:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchRequestOptions.java", "diffHunk": "@@ -0,0 +1,66 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+\n+public final class TransactionalBatchRequestOptions {", "originalCommit": "6cd936358e28cff3de85b8dccb0d21e7d7eae620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4MDMxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498380317", "bodyText": "Fixed,", "author": "rakkuma", "createdAt": "2020-10-01T16:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyMTI5NA=="}], "type": "inlineReview"}, {"oid": "d9500e05e9e241a658b4d1ec572792dabbd48a7f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d9500e05e9e241a658b4d1ec572792dabbd48a7f", "message": "Add Beta change to public classes\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-01T16:21:00Z", "type": "commit"}, {"oid": "5afc339455bda424646f29143d608f83436c9a90", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5afc339455bda424646f29143d608f83436c9a90", "message": "Minor fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-01T18:22:36Z", "type": "commit"}, {"oid": "35dcc74b357999ab8ca48d3c537b68dff6a9d9d7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/35dcc74b357999ab8ca48d3c537b68dff6a9d9d7", "message": "Merge branch 'master' into users/rakkuma/transactional-batch", "committedDate": "2020-10-01T18:33:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4Njg4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498486886", "bodyText": "we are not a document store anymore. please don't mention document in the javadoc. here and elsewhere.", "author": "moderakh", "createdAt": "2020-10-01T20:09:14Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatch.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a batch of operations against items with the same {@link PartitionKey} in a container that will be performed\n+ * in a transactional manner at the Azure Cosmos DB service.\n+ * <p>\n+ * Use {@link TransactionalBatch#createTransactionalBatch(PartitionKey)} or new {@link #TransactionalBatch(PartitionKey)}\n+ * to create an instance of TransactionalBatch\n+ * <b>Example</b>\n+ * This example atomically modifies a set of documents as a batch.", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDg5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r499760897", "bodyText": "Yeah. Fixed. Thanks.", "author": "rakkuma", "createdAt": "2020-10-05T17:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4Njg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4NzExOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498487119", "bodyText": "ditto.", "author": "moderakh", "createdAt": "2020-10-01T20:09:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatch.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a batch of operations against items with the same {@link PartitionKey} in a container that will be performed\n+ * in a transactional manner at the Azure Cosmos DB service.\n+ * <p>\n+ * Use {@link TransactionalBatch#createTransactionalBatch(PartitionKey)} or new {@link #TransactionalBatch(PartitionKey)}\n+ * to create an instance of TransactionalBatch\n+ * <b>Example</b>\n+ * This example atomically modifies a set of documents as a batch.\n+ * <pre>{@code\n+ * public class ToDoActivity {\n+ *     public final String type;\n+ *     public final String id;\n+ *     public final String status;\n+ *     public ToDoActivity(String type, String id, String status) {\n+ *         this.type = type;\n+ *         this.id = id;\n+ *         this.status = status;\n+ *     }\n+ * }\n+ *\n+ * String activityType = \"personal\";\n+ *\n+ * ToDoActivity test1 = new ToDoActivity(activityType, \"learning\", \"ToBeDone\");\n+ * ToDoActivity test2 = new ToDoActivity(activityType, \"shopping\", \"Done\");\n+ * ToDoActivity test3 = new ToDoActivity(activityType, \"swimming\", \"ToBeDone\");\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .createItem<ToDoActivity>(test1)\n+ *     .replaceItem<ToDoActivity>(test2.id, test2)\n+ *     .upsertItem<ToDoActivity>(test3)\n+ *     .deleteItem(\"reading\");\n+ *\n+ * TransactionalBatchResponse response = container.executeTransactionalBatch(batch);\n+ *\n+ * if (!response.IsSuccessStatusCode) {\n+ *      // Handle and log exception\n+ *      return;\n+ * }\n+ *\n+ * // Look up interested results - e.g., via typed access on operation results\n+ *\n+ * TransactionalBatchOperationResult<ToDoActivity> result = response.getOperationResultAtIndex<ToDoActivity>(0, ToDoActivity.class);\n+ * ToDoActivity readActivity = result.getItem();\n+ *\n+ * }</pre>\n+ *\n+ * <b>Example</b>\n+ * <p>This example atomically reads a set of documents as a batch.", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4Nzg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498487862", "bodyText": "this does the same thing as createTransactionalBatch(). why do we need to have both as public?\nIf createTransactionalBatch is the public method then this one should be package private.", "author": "moderakh", "createdAt": "2020-10-01T20:11:26Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatch.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a batch of operations against items with the same {@link PartitionKey} in a container that will be performed\n+ * in a transactional manner at the Azure Cosmos DB service.\n+ * <p>\n+ * Use {@link TransactionalBatch#createTransactionalBatch(PartitionKey)} or new {@link #TransactionalBatch(PartitionKey)}\n+ * to create an instance of TransactionalBatch\n+ * <b>Example</b>\n+ * This example atomically modifies a set of documents as a batch.\n+ * <pre>{@code\n+ * public class ToDoActivity {\n+ *     public final String type;\n+ *     public final String id;\n+ *     public final String status;\n+ *     public ToDoActivity(String type, String id, String status) {\n+ *         this.type = type;\n+ *         this.id = id;\n+ *         this.status = status;\n+ *     }\n+ * }\n+ *\n+ * String activityType = \"personal\";\n+ *\n+ * ToDoActivity test1 = new ToDoActivity(activityType, \"learning\", \"ToBeDone\");\n+ * ToDoActivity test2 = new ToDoActivity(activityType, \"shopping\", \"Done\");\n+ * ToDoActivity test3 = new ToDoActivity(activityType, \"swimming\", \"ToBeDone\");\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .createItem<ToDoActivity>(test1)\n+ *     .replaceItem<ToDoActivity>(test2.id, test2)\n+ *     .upsertItem<ToDoActivity>(test3)\n+ *     .deleteItem(\"reading\");\n+ *\n+ * TransactionalBatchResponse response = container.executeTransactionalBatch(batch);\n+ *\n+ * if (!response.IsSuccessStatusCode) {\n+ *      // Handle and log exception\n+ *      return;\n+ * }\n+ *\n+ * // Look up interested results - e.g., via typed access on operation results\n+ *\n+ * TransactionalBatchOperationResult<ToDoActivity> result = response.getOperationResultAtIndex<ToDoActivity>(0, ToDoActivity.class);\n+ * ToDoActivity readActivity = result.getItem();\n+ *\n+ * }</pre>\n+ *\n+ * <b>Example</b>\n+ * <p>This example atomically reads a set of documents as a batch.\n+ * <pre>{@code\n+ * String activityType = \"personal\";\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType))\n+ *     .readItem(\"playing\")\n+ *     .readItem(\"walking\")\n+ *     .readItem(\"jogging\")\n+ *     .readItem(\"running\")\n+ *\n+ * TransactionalBatchResponse response = container.executeTransactionalBatch(batch);\n+ *\n+ * // Look up interested results - eg. via direct access to operation result stream\n+ *\n+ * List<String> resultItems = new ArrayList<String>();\n+ *\n+ * for (TransactionalBatchOperationResult result : response) {\n+ *     resultItems.add(result.getResourceObject().toString())\n+ * }\n+ *\n+ * }</pre>\n+ * <p>\n+ * <b>See:</b>\n+ * <a href=\"https://docs.microsoft.com/azure/cosmos-db/concepts-limits\">Limits on TransactionalBatch requests</a>.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class TransactionalBatch {\n+\n+    private final ArrayList<ItemBatchOperation<?>> operations;\n+    private final PartitionKey partitionKey;\n+\n+    public TransactionalBatch(PartitionKey partitionKey) {", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTQ4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r499761482", "bodyText": "Yeah. Just thought of keeping two constructors. But yeah it's cool to have only one. So made it package private.", "author": "rakkuma", "createdAt": "2020-10-05T17:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4Nzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwOTYzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498909639", "bodyText": "why is this non primitive?\nsee CosmosItemResponse which returns double.", "author": "moderakh", "createdAt": "2020-10-02T15:57:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class TransactionalBatchOperationResult<TResource> {\n+\n+    private String eTag;\n+    private Double requestCharge;\n+    private TResource item;\n+    private ObjectNode resourceObject;\n+    private int responseStatus;\n+    private Duration retryAfter;\n+    private Integer subStatusCode;\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result using a TransactionalBatchOperationResult.\n+     *\n+     * @param other the other TransactionalBatchOperationResult.\n+     */\n+    TransactionalBatchOperationResult(final TransactionalBatchOperationResult<?> other) {\n+\n+        checkNotNull(other, \"expected non-null other\");\n+\n+        this.responseStatus = other.responseStatus;\n+        this.subStatusCode = other.subStatusCode;\n+        this.eTag = other.eTag;\n+        this.requestCharge = other.requestCharge;\n+        this.retryAfter = other.retryAfter;\n+        this.resourceObject = other.resourceObject;\n+    }\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result using a TransactionalBatchOperationResult and item.\n+     *\n+     * @param result the TransactionalBatchOperationResult.\n+     * @param item the item.\n+     */\n+    TransactionalBatchOperationResult(TransactionalBatchOperationResult<?> result, TResource item) {\n+        this(result);\n+        this.item = item;\n+    }\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchOperationResult} class.\n+     */\n+    TransactionalBatchOperationResult(String eTag,\n+                                      Double requestCharge,\n+                                      ObjectNode resourceObject,\n+                                      int responseStatus,\n+                                      Duration retryAfter,\n+                                      Integer subStatusCode) {\n+        checkNotNull(responseStatus, \"expected non-null responseStatus\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.responseStatus = responseStatus;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge in request units for the current operation.\n+     *\n+     * @return Request charge in request units for the current operation.\n+     */\n+    public Double getRequestCharge() {", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDI5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498950293", "bodyText": "Yeah, I think for few cases it was null mostly due to paring response in case of failures, so made it non primitive. Will fix it.", "author": "rakkuma", "createdAt": "2020-10-02T17:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwOTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMDM1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498910359", "bodyText": "you already have getItem as a public method.\nthis doesn't seem to be needed as public here. move to package private.", "author": "moderakh", "createdAt": "2020-10-02T15:59:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class TransactionalBatchOperationResult<TResource> {\n+\n+    private String eTag;\n+    private Double requestCharge;\n+    private TResource item;\n+    private ObjectNode resourceObject;\n+    private int responseStatus;\n+    private Duration retryAfter;\n+    private Integer subStatusCode;\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result using a TransactionalBatchOperationResult.\n+     *\n+     * @param other the other TransactionalBatchOperationResult.\n+     */\n+    TransactionalBatchOperationResult(final TransactionalBatchOperationResult<?> other) {\n+\n+        checkNotNull(other, \"expected non-null other\");\n+\n+        this.responseStatus = other.responseStatus;\n+        this.subStatusCode = other.subStatusCode;\n+        this.eTag = other.eTag;\n+        this.requestCharge = other.requestCharge;\n+        this.retryAfter = other.retryAfter;\n+        this.resourceObject = other.resourceObject;\n+    }\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result using a TransactionalBatchOperationResult and item.\n+     *\n+     * @param result the TransactionalBatchOperationResult.\n+     * @param item the item.\n+     */\n+    TransactionalBatchOperationResult(TransactionalBatchOperationResult<?> result, TResource item) {\n+        this(result);\n+        this.item = item;\n+    }\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchOperationResult} class.\n+     */\n+    TransactionalBatchOperationResult(String eTag,\n+                                      Double requestCharge,\n+                                      ObjectNode resourceObject,\n+                                      int responseStatus,\n+                                      Duration retryAfter,\n+                                      Integer subStatusCode) {\n+        checkNotNull(responseStatus, \"expected non-null responseStatus\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.responseStatus = responseStatus;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge in request units for the current operation.\n+     *\n+     * @return Request charge in request units for the current operation.\n+     */\n+    public Double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public TResource getItem() {\n+        return this.item;\n+    }\n+\n+    /**\n+     * Gets retry after.\n+     *\n+     * @return the retry after\n+     */\n+    public Duration getRetryAfter() {\n+        return this.retryAfter;\n+    }\n+\n+    /**\n+     * Gets sub status code.\n+     *\n+     * @return the sub status code\n+     */\n+    public Integer getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the current operation completed successfully.\n+     *\n+     * @return {@code true} if the current operation completed successfully; {@code false} otherwise.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return 200 <= this.responseStatus && this.responseStatus <= 299;\n+    }\n+\n+    /**\n+     * Gets response status.\n+     *\n+     * @return the response status\n+     */\n+    public int getResponseStatus() {\n+        return this.responseStatus;\n+    }\n+\n+    public ObjectNode getResourceObject() {", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0OTc3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498949774", "bodyText": "Cool. Will remove it. Not used anywhere right now except when de-serialzing.", "author": "rakkuma", "createdAt": "2020-10-02T17:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMDM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMDg0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498910843", "bodyText": "the method names should match the relevant methods of CosmosItemResponse\nwe have CosmosItemResponse.getStatusCode() any reason this one is named differently?", "author": "moderakh", "createdAt": "2020-10-02T16:00:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class TransactionalBatchOperationResult<TResource> {\n+\n+    private String eTag;\n+    private Double requestCharge;\n+    private TResource item;\n+    private ObjectNode resourceObject;\n+    private int responseStatus;\n+    private Duration retryAfter;\n+    private Integer subStatusCode;\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result using a TransactionalBatchOperationResult.\n+     *\n+     * @param other the other TransactionalBatchOperationResult.\n+     */\n+    TransactionalBatchOperationResult(final TransactionalBatchOperationResult<?> other) {\n+\n+        checkNotNull(other, \"expected non-null other\");\n+\n+        this.responseStatus = other.responseStatus;\n+        this.subStatusCode = other.subStatusCode;\n+        this.eTag = other.eTag;\n+        this.requestCharge = other.requestCharge;\n+        this.retryAfter = other.retryAfter;\n+        this.resourceObject = other.resourceObject;\n+    }\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result using a TransactionalBatchOperationResult and item.\n+     *\n+     * @param result the TransactionalBatchOperationResult.\n+     * @param item the item.\n+     */\n+    TransactionalBatchOperationResult(TransactionalBatchOperationResult<?> result, TResource item) {\n+        this(result);\n+        this.item = item;\n+    }\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchOperationResult} class.\n+     */\n+    TransactionalBatchOperationResult(String eTag,\n+                                      Double requestCharge,\n+                                      ObjectNode resourceObject,\n+                                      int responseStatus,\n+                                      Duration retryAfter,\n+                                      Integer subStatusCode) {\n+        checkNotNull(responseStatus, \"expected non-null responseStatus\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.responseStatus = responseStatus;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge in request units for the current operation.\n+     *\n+     * @return Request charge in request units for the current operation.\n+     */\n+    public Double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public TResource getItem() {\n+        return this.item;\n+    }\n+\n+    /**\n+     * Gets retry after.\n+     *\n+     * @return the retry after\n+     */\n+    public Duration getRetryAfter() {\n+        return this.retryAfter;\n+    }\n+\n+    /**\n+     * Gets sub status code.\n+     *\n+     * @return the sub status code\n+     */\n+    public Integer getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the current operation completed successfully.\n+     *\n+     * @return {@code true} if the current operation completed successfully; {@code false} otherwise.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return 200 <= this.responseStatus && this.responseStatus <= 299;\n+    }\n+\n+    /**\n+     * Gets response status.\n+     *\n+     * @return the response status\n+     */\n+    public int getResponseStatus() {", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0OTQ5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498949492", "bodyText": "No. Will change it. Thanks!", "author": "rakkuma", "createdAt": "2020-10-02T17:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMDg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMTkxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498911916", "bodyText": "for CosmosItemRequestOption we didn't allow setting consistency level per request. To be consistent we shouldn't have that public method here either. if we decide to enable this feature we should consistently enable this everywhere.", "author": "moderakh", "createdAt": "2020-10-02T16:02:25Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchRequestOptions.java", "diffHunk": "@@ -0,0 +1,63 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.util.Beta;\n+\n+/**\n+ * Encapsulates options that can be specified for a {@link TransactionalBatch}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class TransactionalBatchRequestOptions {\n+    private ConsistencyLevel consistencyLevel;\n+    private String sessionToken;\n+\n+    /**\n+     * Gets the consistency level required for the request.\n+     *\n+     * @return the consistency level.\n+     */\n+    public ConsistencyLevel getConsistencyLevel() {\n+        return consistencyLevel;\n+    }\n+\n+    /**\n+     * Sets the consistency level required for the request.\n+     *\n+     * @param consistencyLevel the consistency level.\n+     * @return the TransactionalBatchRequestOptions.\n+     */\n+    TransactionalBatchRequestOptions setConsistencyLevel(ConsistencyLevel consistencyLevel) {", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0OTI5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498949293", "bodyText": "We do have consistencyLevel in CosmosItemRequestOption", "author": "rakkuma", "createdAt": "2020-10-02T17:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDE3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498950177", "bodyText": "the ones in CosmosItemRequestOption are not public.\nhere getConsistencyLevel is public. the ask is to make it non-public.", "author": "moderakh", "createdAt": "2020-10-02T17:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MTE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498951190", "bodyText": "Oh!!! My apologies. Misunderstood it. Will make the change. Thanks!", "author": "rakkuma", "createdAt": "2020-10-02T17:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMzMzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r499733339", "bodyText": "Done", "author": "rakkuma", "createdAt": "2020-10-05T16:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMTkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMjMxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498912319", "bodyText": "please make the fields final.", "author": "moderakh", "createdAt": "2020-10-02T16:03:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,219 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.util.Beta;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public class TransactionalBatchResponse {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchResponse.class);\n+\n+    private Map<String, String> responseHeaders;\n+    private final int responseStatus;\n+    private String errorMessage;\n+    private List<TransactionalBatchOperationResult<?>> results;\n+    private Integer subStatusCode;\n+    private List<ItemBatchOperation<?>> operations;\n+    private CosmosDiagnostics cosmosDiagnostics;", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDI5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r499760296", "bodyText": "Ack. Fixed. Thanks.", "author": "rakkuma", "createdAt": "2020-10-05T17:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDg1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498914858", "bodyText": "can these fields be made final?", "author": "moderakh", "createdAt": "2020-10-02T16:08:13Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ItemBatchOperation.java", "diffHunk": "@@ -0,0 +1,163 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.models.PartitionKey;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents an operation on an item which will be executed as part of a batch request on a container.\n+ */\n+public final class ItemBatchOperation<TResource> {\n+\n+    private TResource resource;\n+\n+    private String id;\n+    private int operationIndex;\n+    private PartitionKey partitionKey;\n+    private String partitionKeyJson;\n+    private final OperationType operationType;\n+    private RequestOptions requestOptions;", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDAwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r499760000", "bodyText": "Ack. Fixed. Thanks.", "author": "rakkuma", "createdAt": "2020-10-05T17:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMTMyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498921322", "bodyText": "This shouldn't be the case.\ncontainer.readItem() either return a result or throw exception. 404 should never be returned as status code.", "author": "moderakh", "createdAt": "2020-10-02T16:20:45Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/BatchTestBase.java", "diffHunk": "@@ -0,0 +1,185 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.ISessionToken;\n+import com.azure.cosmos.implementation.SessionTokenHelper;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+\n+import java.util.Random;\n+import java.util.UUID;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class BatchTestBase extends TestSuiteBase {\n+\n+    private Random random = new Random();\n+    String partitionKey1 = \"TBD1\";\n+\n+    // Documents in partitionKey1\n+    TestDoc TestDocPk1ExistingA;\n+    TestDoc TestDocPk1ExistingB ;\n+    TestDoc TestDocPk1ExistingC;\n+    TestDoc TestDocPk1ExistingD;\n+\n+    public BatchTestBase(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    void createJsonTestDocsAsync(CosmosContainer container) {\n+        this.TestDocPk1ExistingA =  this.createJsonTestDocAsync(container, this.partitionKey1);\n+        this.TestDocPk1ExistingB =  this.createJsonTestDocAsync(container, this.partitionKey1);\n+        this.TestDocPk1ExistingC =  this.createJsonTestDocAsync(container, this.partitionKey1);\n+        this.TestDocPk1ExistingD =  this.createJsonTestDocAsync(container, this.partitionKey1);\n+    }\n+\n+    TestDoc populateTestDoc(String partitionKey) {\n+        return populateTestDoc(partitionKey, 20);\n+    }\n+\n+    TestDoc populateTestDoc(String partitionKey, int minDesiredSize) {\n+        String description = StringUtils.repeat(\"x\", minDesiredSize);\n+        return new TestDoc(UUID.randomUUID().toString(), this.random.nextInt(), description, partitionKey);\n+    }\n+\n+    TestDoc getTestDocCopy(TestDoc testDoc) {\n+        return new TestDoc(testDoc.getId(), testDoc.getCost(), testDoc.getDescription(), testDoc.getStatus());\n+    }\n+\n+    void verifyByReadAsync(CosmosContainer container, TestDoc doc) {\n+        verifyByReadAsync(container, doc, null);\n+    }\n+\n+    void verifyByReadAsync(CosmosContainer container, TestDoc doc, String eTag) {\n+        PartitionKey partitionKey = this.getPartitionKey(doc.getStatus());\n+\n+        CosmosItemResponse<TestDoc> response = container.readItem(doc.getId(), partitionKey, TestDoc.class);\n+\n+        assertThat(response.getStatusCode()).isEqualTo(HttpResponseStatus.OK.code());\n+        assertThat(response.getItem()).isEqualTo(doc);\n+\n+        if (eTag != null) {\n+            assertThat(response.getETag()).isEqualTo(eTag);\n+        }\n+    }\n+\n+    void verifyNotFoundAsync(CosmosContainer container, TestDoc doc) {\n+        String id = doc.getId();\n+        PartitionKey partitionKey = this.getPartitionKey(doc.getStatus());\n+\n+        try {\n+            CosmosItemResponse<TestDoc> response =  container.readItem(id, partitionKey, TestDoc.class);\n+\n+            // Gateway returns response instead of exception", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NTk2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r499785960", "bodyText": "Yeah. I tried it again, it is now throwing exception for gateway too.. must have been some mixup.", "author": "rakkuma", "createdAt": "2020-10-05T18:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzEzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498923131", "bodyText": "you are mixing the async hierarchy with non-async hierarchy.\nthe usage expectation is once a user decide async vs non-async with stick to that decision everywhere and never mixes the usage of the two.\nAs these tests might get used by the end user as sample code we should ensure we are following above guideline.", "author": "moderakh", "createdAt": "2020-10-02T16:24:22Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/TransactionalBatchTest.java", "diffHunk": "@@ -0,0 +1,379 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.ISessionToken;\n+import com.azure.cosmos.implementation.guava25.base.Function;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.assertj.core.data.Offset;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.UUID;\n+\n+import static com.azure.cosmos.implementation.batch.BatchRequestResponseConstant.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TransactionalBatchTest extends BatchTestBase {\n+\n+    private CosmosClient batchClient;\n+    private CosmosContainer batchContainer;\n+    private CosmosAsyncContainer batchAsyncContainer;", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1OTM0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r499759342", "bodyText": "Ack. Have removed that test case.", "author": "rakkuma", "createdAt": "2020-10-05T17:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzg0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498923845", "bodyText": "CosmosContainer provides sync API where as batchAsyncContainer provides async api.\nyou are mixing the async hierarchy with non-async hierarchy.\nthe usage expectation is once a user decide async vs non-async with stick to that decision everywhere and never mixes the usage of the two.\nAs these tests might get used by the end user as sample code we should ensure we are following above guideline.\nplease fix these in all tests. each test class should only stick to one single pattern and not mixes the two patterns", "author": "moderakh", "createdAt": "2020-10-02T16:25:48Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/TransactionalBatchTest.java", "diffHunk": "@@ -0,0 +1,379 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.ISessionToken;\n+import com.azure.cosmos.implementation.guava25.base.Function;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.assertj.core.data.Offset;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.UUID;\n+\n+import static com.azure.cosmos.implementation.batch.BatchRequestResponseConstant.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TransactionalBatchTest extends BatchTestBase {\n+\n+    private CosmosClient batchClient;\n+    private CosmosContainer batchContainer;\n+    private CosmosAsyncContainer batchAsyncContainer;\n+\n+    @Factory(dataProvider = \"simpleClientBuildersWithDirect\")\n+    public TransactionalBatchTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @BeforeClass(groups = {\"simple\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_TransactionalBatchTest() {\n+        assertThat(this.batchClient).isNull();\n+        this.batchClient = getClientBuilder().buildClient();\n+        batchAsyncContainer = getSharedMultiPartitionCosmosContainer(this.batchClient.asyncClient());\n+        batchContainer = batchClient.getDatabase(batchAsyncContainer.getDatabase().getId()).getContainer(batchAsyncContainer.getId());\n+    }\n+\n+    @AfterClass(groups = {\"simple\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        safeCloseSyncClient(this.batchClient);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void batchExecutionRepeat() {\n+        CosmosContainer container = this.batchContainer;\n+        this.createJsonTestDocsAsync(container);\n+\n+        TestDoc firstDoc = this.populateTestDoc(this.partitionKey1);\n+        TestDoc replaceDoc = this.getTestDocCopy(firstDoc);\n+        replaceDoc.setCost(replaceDoc.getCost() + 1);\n+\n+        Mono<TransactionalBatchResponse> batchResponseMono = batchAsyncContainer.executeTransactionalBatch(\n+            TransactionalBatch.createTransactionalBatch(this.getPartitionKey(this.partitionKey1))\n+                .createItem(firstDoc)\n+                .replaceItem(replaceDoc.getId(), replaceDoc));", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NjIyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498946229", "bodyText": "All the other test sticks to sync container, as that verifies both sync and async. This test was to ensure that double block on Mono works as expected. But if users do see our test, I will move it to a separate class.", "author": "rakkuma", "createdAt": "2020-10-02T17:11:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyODczNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498928735", "bodyText": "container.createItem() will always either succeed and returns a CosmosItemResponse or will throw on failure.\nhowever here it seems we are allowing returning a TransactionalBatchResponse even if the whole batch fails. this is not consistent with the above. any reason for the deviation?\nshouldn't we follow the same pattern here?\n/CC @FabianMeiswinkel  @kirankumarkolli", "author": "moderakh", "createdAt": "2020-10-02T16:35:24Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,219 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.util.Beta;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public class TransactionalBatchResponse {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchResponse.class);\n+\n+    private Map<String, String> responseHeaders;\n+    private final int responseStatus;\n+    private String errorMessage;\n+    private List<TransactionalBatchOperationResult<?>> results;\n+    private Integer subStatusCode;\n+    private List<ItemBatchOperation<?>> operations;\n+    private CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchResponse} class.\n+     *\n+     * @param responseStatus the  response status.\n+     * @param subStatusCode the response sub-status code.\n+     * @param errorMessage an error message or {@code null}.\n+     * @param responseHeaders the response http headers\n+     * @param cosmosDiagnostics the diagnostic\n+     * @param operations a {@link List list} of {@link ItemBatchOperation batch operations}.\n+     */\n+    TransactionalBatchResponse(\n+        final int responseStatus,\n+        final Integer subStatusCode,\n+        final String errorMessage,\n+        final Map<String, String> responseHeaders,\n+        final CosmosDiagnostics cosmosDiagnostics,\n+        final List<ItemBatchOperation<?>> operations) {\n+\n+        checkNotNull(responseStatus, \"expected non-null responseStatus\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+        checkNotNull(operations, \"expected non-null operations\");\n+\n+        this.responseStatus = responseStatus;\n+        this.subStatusCode = subStatusCode;\n+        this.errorMessage = errorMessage;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+        this.operations = UnmodifiableList.unmodifiableList(operations);\n+        this.results = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the current {@link TransactionalBatchResponse batch}.\n+     * <p>\n+     * @param <T> the type parameter.\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     * de-serialized, when present.\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return TransactionalBatchOperationResult containing the individual result of operation.\n+     */\n+    public <T> TransactionalBatchOperationResult<T> getOperationResultAtIndex(\n+        final int index,\n+        final Class<T> type) {\n+\n+        checkArgument(index >= 0, \"expected non-negative index\");\n+        checkNotNull(type, \"expected non-null type\");\n+\n+        final TransactionalBatchOperationResult<?> result = this.results.get(index);\n+        T item = null;\n+\n+        if (result.getResourceObject() != null) {\n+            item = new JsonSerializable(result.getResourceObject()).toObject(type);\n+        }\n+\n+        return new TransactionalBatchOperationResult<T>(result, item);\n+    }\n+\n+    public CosmosDiagnostics getCosmosDiagnostics() {\n+        return cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the number of operation results.\n+     *\n+     * @return the number of operations results in this response.\n+     */\n+    public int size() {\n+        return this.results == null ? 0 : this.results.size();\n+    }\n+\n+    /**\n+     * Returns a value indicating whether the batch was successfully processed.\n+     *\n+     * @return a value indicating whether the batch was successfully processed.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return this.responseStatus >= 200 && this.responseStatus <= 299;", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1OTEzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r499759130", "bodyText": "As discussed, user failure will have no exception. So it make sense to keep a function for checking if it succeeded.", "author": "rakkuma", "createdAt": "2020-10-05T17:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyODczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMTUzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498931533", "bodyText": "container.createItem() will always either succeed and returns a CosmosItemResponse or will throw an exception on failure.\nhowever here it seems we are allowing returning a TransactionalBatchResponse even if the whole batch fails (you provided error methods such as (TransactionalBatchResponse.getErrorMessage()).\nthis is not consistent with our existing apis where on failure we throw.\nshouldn't we follow the same pattern here?\n/CC @FabianMeiswinkel @kirankumarkolli", "author": "moderakh", "createdAt": "2020-10-02T16:40:58Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -493,6 +496,93 @@ public String getId() {\n         return Utils.getSimpleObjectMapper().convertValue(object, classType);\n     }\n \n+    /**\n+     * Executes the transactional batch.\n+     *\n+     * @param transactionalBatch Batch having list of operation and partition key which will be executed by this container.\n+     *\n+     * @return A Mono response which contains details of execution of the transactional batch.\n+     * <p>\n+     * If the transactional batch executes successfully, the value returned by {@link\n+     * TransactionalBatchResponse#getResponseStatus} on the response returned will be set to 200}.\n+     * <p>\n+     * If an operation within the transactional batch fails during execution, no changes from the batch will be\n+     * committed and the status of the failing operation is made available by {@link\n+     * TransactionalBatchResponse#getResponseStatus}. To obtain information about the operations that failed, the\n+     * response can be enumerated. This returns {@link TransactionalBatchOperationResult} instances corresponding to\n+     * each operation in the transactional batch in the order they were added to the transactional batch. For a result\n+     * corresponding to an operation within the transactional batch, use\n+     * {@link TransactionalBatchOperationResult#getResponseStatus}\n+     * to access the status of the operation. If the operation was not executed or it was aborted due to the failure of\n+     * another operation within the transactional batch, the value of this field will be 424;\n+     * for the operation that caused the batch to abort, the value of this field\n+     * will indicate the cause of failure.\n+     * <p>\n+     * The value returned by {@link TransactionalBatchResponse#getResponseStatus} on the response returned may also have\n+     * values such as 500 in case of server errors and 429.\n+     * <p>\n+     * Use {@link TransactionalBatchResponse#isSuccessStatusCode} on the response returned to ensure that the\n+     * transactional batch succeeded.\n+     */\n+    @Beta(Beta.SinceVersion.V4_7_0)\n+    public Mono<TransactionalBatchResponse> executeTransactionalBatch(TransactionalBatch transactionalBatch) {", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDU1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498944552", "bodyText": "This is something backend is doing here, in case of a user error like conflict or not found, backend returns overall status as 207 with individual status code having the failure status codes.\nSo if we are to throw an exception, that has to be triggered by SDK. And if we do throw an exception by SDK, results of individual operations will be lost and user won't be able to determine that which particular operation failed as all they will get is a cosmos exception.", "author": "rakkuma", "createdAt": "2020-10-02T17:08:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMTUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NTYwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498945601", "bodyText": "so there are two types of failure\n\nindividual operation failure (as you said 404 or 409 for individual operation)\nwhen the whole batch fails (network error, 500, etc)\n\nit makes sense to return the result on 1. but we should throw on 2.\nthought?", "author": "moderakh", "createdAt": "2020-10-02T17:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMTUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0ODAxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498948013", "bodyText": "Yeah we can do that. Will make the change. Thanks.", "author": "rakkuma", "createdAt": "2020-10-02T17:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MjY1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498952652", "bodyText": "you have a check if the transactional batch request size is non zero. So we never can get a response with zero length. correct?\nif so please remove this method as it is redundant.", "author": "moderakh", "createdAt": "2020-10-02T17:24:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,219 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.util.Beta;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public class TransactionalBatchResponse {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(TransactionalBatchResponse.class);\n+\n+    private Map<String, String> responseHeaders;\n+    private final int responseStatus;\n+    private String errorMessage;\n+    private List<TransactionalBatchOperationResult<?>> results;\n+    private Integer subStatusCode;\n+    private List<ItemBatchOperation<?>> operations;\n+    private CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchResponse} class.\n+     *\n+     * @param responseStatus the  response status.\n+     * @param subStatusCode the response sub-status code.\n+     * @param errorMessage an error message or {@code null}.\n+     * @param responseHeaders the response http headers\n+     * @param cosmosDiagnostics the diagnostic\n+     * @param operations a {@link List list} of {@link ItemBatchOperation batch operations}.\n+     */\n+    TransactionalBatchResponse(\n+        final int responseStatus,\n+        final Integer subStatusCode,\n+        final String errorMessage,\n+        final Map<String, String> responseHeaders,\n+        final CosmosDiagnostics cosmosDiagnostics,\n+        final List<ItemBatchOperation<?>> operations) {\n+\n+        checkNotNull(responseStatus, \"expected non-null responseStatus\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+        checkNotNull(operations, \"expected non-null operations\");\n+\n+        this.responseStatus = responseStatus;\n+        this.subStatusCode = subStatusCode;\n+        this.errorMessage = errorMessage;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+        this.operations = UnmodifiableList.unmodifiableList(operations);\n+        this.results = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the current {@link TransactionalBatchResponse batch}.\n+     * <p>\n+     * @param <T> the type parameter.\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     * de-serialized, when present.\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return TransactionalBatchOperationResult containing the individual result of operation.\n+     */\n+    public <T> TransactionalBatchOperationResult<T> getOperationResultAtIndex(\n+        final int index,\n+        final Class<T> type) {\n+\n+        checkArgument(index >= 0, \"expected non-negative index\");\n+        checkNotNull(type, \"expected non-null type\");\n+\n+        final TransactionalBatchOperationResult<?> result = this.results.get(index);\n+        T item = null;\n+\n+        if (result.getResourceObject() != null) {\n+            item = new JsonSerializable(result.getResourceObject()).toObject(type);\n+        }\n+\n+        return new TransactionalBatchOperationResult<T>(result, item);\n+    }\n+\n+    public CosmosDiagnostics getCosmosDiagnostics() {\n+        return cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the number of operation results.\n+     *\n+     * @return the number of operations results in this response.\n+     */\n+    public int size() {\n+        return this.results == null ? 0 : this.results.size();\n+    }\n+\n+    /**\n+     * Returns a value indicating whether the batch was successfully processed.\n+     *\n+     * @return a value indicating whether the batch was successfully processed.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return this.responseStatus >= 200 && this.responseStatus <= 299;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute the batch.\n+     *\n+     * @return the activity ID that identifies the server request made to execute the batch.\n+     */\n+    public String getActivityId() {\n+        return this.responseHeaders.get(HttpConstants.HttpHeaders.ACTIVITY_ID);\n+    }\n+\n+    /**\n+     * Gets the reason for the failure of the batch request, if any, or {@code null}.\n+     *\n+     * @return the reason for the failure of the batch request, if any, or {@code null}.\n+     */\n+    public String getErrorMessage() {\n+        return this.errorMessage;\n+    }\n+\n+    /**\n+     * Gets the request charge for the batch request.\n+     *\n+     * @return the request charge measured in request units.\n+     */\n+    public double getRequestCharge() {\n+        final String value = this.responseHeaders.get(HttpConstants.HttpHeaders.REQUEST_CHARGE);\n+        if (StringUtils.isEmpty(value)) {\n+            return 0;\n+        }\n+\n+        try {\n+            return Double.valueOf(value);\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"INVALID x-ms-request-charge value {}.\", value);\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Gets the response status code of the batch request.\n+     *\n+     * @return the response status code of the batch request.\n+     */\n+    public int getResponseStatus() {\n+        return this.responseStatus;\n+    }\n+\n+    /**\n+     * Gets the response headers.\n+     *\n+     * @return the response header map.\n+     */\n+    public Map<String, String> getResponseHeaders() {\n+        return this.responseHeaders;\n+    }\n+\n+    /**\n+     * Gets the amount of time to wait before retrying this or any other request due to throttling.\n+     *\n+     * @return the amount of time to wait before retrying this or any other request due to throttling.\n+     */\n+    public Duration getRetryAfter() {\n+        if (this.responseHeaders.containsKey(HttpConstants.HttpHeaders.RETRY_AFTER)) {\n+            return Duration.parse(this.responseHeaders.get(HttpConstants.HttpHeaders.RETRY_AFTER));\n+        }\n+\n+        return null;\n+    }\n+\n+    public Integer getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Get all the results of the operations in batch.\n+     *\n+     * @return Results of operation in batch.\n+     */\n+    public List<TransactionalBatchOperationResult<?>> getResults() {\n+        return this.results;\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the batch.\n+     *\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     *\n+     * @return Result of operation at the provided index in the batch.\n+     */\n+    public TransactionalBatchOperationResult<?> get(int index) {\n+        return this.results.get(index);\n+    }\n+\n+    public boolean isEmpty() {", "originalCommit": "5afc339455bda424646f29143d608f83436c9a90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzEzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r498953131", "bodyText": "Agreed. I am checking it too. Cool. Will remove this.", "author": "rakkuma", "createdAt": "2020-10-02T17:25:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MjY1Mg=="}], "type": "inlineReview"}, {"oid": "47353b5128286eb4788a3c99eab7286d34e10fe0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/47353b5128286eb4788a3c99eab7286d34e10fe0", "message": "Code review\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-05T15:22:49Z", "type": "commit"}, {"oid": "8413c9e8cbbef0bbe752a8c43403bbb7f9bfee10", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8413c9e8cbbef0bbe752a8c43403bbb7f9bfee10", "message": "Merge branch 'master' into users/rakkuma/transactional-batch", "committedDate": "2020-10-05T15:35:56Z", "type": "commit"}, {"oid": "439604677fe9d76df317810916f6910bd22edbf6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/439604677fe9d76df317810916f6910bd22edbf6", "message": "Fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-05T17:03:00Z", "type": "commit"}, {"oid": "3e8dbc18e8e0707ef90769d2521957e3fa4f18ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3e8dbc18e8e0707ef90769d2521957e3fa4f18ab", "message": "Minor fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-05T20:46:23Z", "type": "commit"}, {"oid": "ed02b3eb706345d4a433016c11854d28d823996b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed02b3eb706345d4a433016c11854d28d823996b", "message": "Session token fix and test cases\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-06T13:25:50Z", "type": "commit"}, {"oid": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "message": "Merge branch 'master' into users/rakkuma/transactional-batch", "committedDate": "2020-10-06T14:11:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1OTkxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500459910", "bodyText": "we should have a section on the complete failure. Essentially on the network failure or if the service returns a 5xx code then the results in the batch is not valid, and hence the Mono will return error.", "author": "moderakh", "createdAt": "2020-10-06T17:07:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -493,6 +496,89 @@ public String getId() {\n         return Utils.getSimpleObjectMapper().convertValue(object, classType);\n     }\n \n+    /**\n+     * Executes the transactional batch.\n+     *\n+     * @param transactionalBatch Batch having list of operation and partition key which will be executed by this container.\n+     *\n+     * @return A Mono response which contains details of execution of the transactional batch.\n+     * <p>\n+     * If the transactional batch executes successfully, the value returned by {@link\n+     * TransactionalBatchResponse#getStatusCode} on the response returned will be set to 200}.\n+     * <p>\n+     * If an operation within the transactional batch fails during execution, no changes from the batch will be\n+     * committed and the status of the failing operation is made available by {@link\n+     * TransactionalBatchResponse#getStatusCode} or by the exception. To obtain information about the operations\n+     * that failed in case of some user error like conflict, not found etc, the response can be enumerated.\n+     * This returns {@link TransactionalBatchOperationResult} instances corresponding to each operation in the\n+     * transactional batch in the order they were added to the transactional batch.\n+     * For a result corresponding to an operation within the transactional batch, use\n+     * {@link TransactionalBatchOperationResult#getStatusCode}\n+     * to access the status of the operation. If the operation was not executed or it was aborted due to the failure of\n+     * another operation within the transactional batch, the value of this field will be 424;\n+     * for the operation that caused the batch to abort, the value of this field\n+     * will indicate the cause of failure.\n+     * <p>\n+     * Use {@link TransactionalBatchResponse#isSuccessStatusCode} on the response returned to ensure that the\n+     * transactional batch succeeded.", "originalCommit": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2MDE0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500460149", "bodyText": "ditto for the javadoc as above.", "author": "moderakh", "createdAt": "2020-10-06T17:07:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -493,6 +496,89 @@ public String getId() {\n         return Utils.getSimpleObjectMapper().convertValue(object, classType);\n     }\n \n+    /**\n+     * Executes the transactional batch.\n+     *\n+     * @param transactionalBatch Batch having list of operation and partition key which will be executed by this container.\n+     *\n+     * @return A Mono response which contains details of execution of the transactional batch.\n+     * <p>\n+     * If the transactional batch executes successfully, the value returned by {@link\n+     * TransactionalBatchResponse#getStatusCode} on the response returned will be set to 200}.\n+     * <p>\n+     * If an operation within the transactional batch fails during execution, no changes from the batch will be\n+     * committed and the status of the failing operation is made available by {@link\n+     * TransactionalBatchResponse#getStatusCode} or by the exception. To obtain information about the operations\n+     * that failed in case of some user error like conflict, not found etc, the response can be enumerated.\n+     * This returns {@link TransactionalBatchOperationResult} instances corresponding to each operation in the\n+     * transactional batch in the order they were added to the transactional batch.\n+     * For a result corresponding to an operation within the transactional batch, use\n+     * {@link TransactionalBatchOperationResult#getStatusCode}\n+     * to access the status of the operation. If the operation was not executed or it was aborted due to the failure of\n+     * another operation within the transactional batch, the value of this field will be 424;\n+     * for the operation that caused the batch to abort, the value of this field\n+     * will indicate the cause of failure.\n+     * <p>\n+     * Use {@link TransactionalBatchResponse#isSuccessStatusCode} on the response returned to ensure that the\n+     * transactional batch succeeded.\n+     */\n+    @Beta(Beta.SinceVersion.V4_7_0)\n+    public Mono<TransactionalBatchResponse> executeTransactionalBatch(TransactionalBatch transactionalBatch) {\n+        return executeTransactionalBatch(transactionalBatch, new TransactionalBatchRequestOptions());\n+    }\n+\n+    /**\n+     * Executes the transactional batch.\n+     *\n+     * @param transactionalBatch Batch having list of operation and partition key which will be executed by this container.\n+     * @param requestOptions Options that apply specifically to batch request.\n+     *\n+     * @return A Mono response which contains details of execution of the transactional batch.\n+     * <p>\n+     * If the transactional batch executes successfully, the value returned by {@link\n+     * TransactionalBatchResponse#getStatusCode} on the response returned will be set to 200}.\n+     * <p>\n+     * If an operation within the transactional batch fails during execution, no changes from the batch will be\n+     * committed and the status of the failing operation is made available by {@link\n+     * TransactionalBatchResponse#getStatusCode} or by the exception. To obtain information about the operations\n+     * that failed in case of some user error like conflict, not found etc, the response can be enumerated.\n+     * This returns {@link TransactionalBatchOperationResult} instances corresponding to each operation in the\n+     * transactional batch in the order they were added to the transactional batch.\n+     * For a result corresponding to an operation within the transactional batch, use\n+     * {@link TransactionalBatchOperationResult#getStatusCode}\n+     * to access the status of the operation. If the operation was not executed or it was aborted due to the failure of\n+     * another operation within the transactional batch, the value of this field will be 424;\n+     * for the operation that caused the batch to abort, the value of this field\n+     * will indicate the cause of failure.", "originalCommit": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4MzI5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500483294", "bodyText": "in CosmosException this is called CosmosException:getRetryAfterDuration()\nwe should be consistent on naming.", "author": "moderakh", "createdAt": "2020-10-06T17:45:47Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchOperationResult.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.time.Duration;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a result for a specific operation that was part of a {@link TransactionalBatch} request.\n+ *\n+ * @param <TResource> the type parameter\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class TransactionalBatchOperationResult<TResource> {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private TResource item;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result using a TransactionalBatchOperationResult.\n+     *\n+     * @param other the other TransactionalBatchOperationResult.\n+     */\n+    TransactionalBatchOperationResult(final TransactionalBatchOperationResult<?> other) {\n+\n+        checkNotNull(other, \"expected non-null other\");\n+\n+        this.statusCode = other.statusCode;\n+        this.subStatusCode = other.subStatusCode;\n+        this.eTag = other.eTag;\n+        this.requestCharge = other.requestCharge;\n+        this.retryAfter = other.retryAfter;\n+        this.resourceObject = other.resourceObject;\n+    }\n+\n+    /**\n+     * Instantiates a new Transactional batch operation result using a TransactionalBatchOperationResult and item.\n+     *\n+     * @param result the TransactionalBatchOperationResult.\n+     * @param item the item.\n+     */\n+    TransactionalBatchOperationResult(TransactionalBatchOperationResult<?> result, TResource item) {\n+        this(result);\n+        this.item = item;\n+    }\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchOperationResult} class.\n+     */\n+    TransactionalBatchOperationResult(String eTag,\n+                                      double requestCharge,\n+                                      ObjectNode resourceObject,\n+                                      int statusCode,\n+                                      Duration retryAfter,\n+                                      int subStatusCode) {\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public TResource getItem() {\n+        return this.item;\n+    }\n+\n+    /**\n+     * Gets retry after.\n+     *\n+     * @return the retry after\n+     */\n+    public Duration getRetryAfter() {", "originalCommit": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NjU1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500486553", "bodyText": "getRetryAfterDuration to be consistent with CosmosException:getRetryAfterDuration?", "author": "moderakh", "createdAt": "2020-10-06T17:51:09Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public class TransactionalBatchResponse {\n+\n+    private final Map<String, String> responseHeaders;\n+    private final int statusCode;\n+    private final String errorMessage;\n+    private final List<TransactionalBatchOperationResult<?>> results;\n+    private final int subStatusCode;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchResponse} class.\n+     *\n+     * @param statusCode the response status code.\n+     * @param subStatusCode the response sub-status code.\n+     * @param errorMessage an error message or {@code null}.\n+     * @param responseHeaders the response http headers\n+     * @param cosmosDiagnostics the diagnostic\n+     */\n+    TransactionalBatchResponse(\n+        final int statusCode,\n+        final int subStatusCode,\n+        final String errorMessage,\n+        final Map<String, String> responseHeaders,\n+        final CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.statusCode = statusCode;\n+        this.subStatusCode = subStatusCode;\n+        this.errorMessage = errorMessage;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+        this.results = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the current {@link TransactionalBatchResponse batch}.\n+     * <p>\n+     * @param <T> the type parameter.\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     * de-serialized, when present.\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return TransactionalBatchOperationResult containing the individual result of operation.\n+     */\n+    public <T> TransactionalBatchOperationResult<T> getOperationResultAtIndex(\n+        final int index,\n+        final Class<T> type) {\n+\n+        checkArgument(index >= 0, \"expected non-negative index\");\n+        checkNotNull(type, \"expected non-null type\");\n+\n+        final TransactionalBatchOperationResult<?> result = this.results.get(index);\n+        T item = null;\n+\n+        if (result.getResourceObject() != null) {\n+            item = new JsonSerializable(result.getResourceObject()).toObject(type);\n+        }\n+\n+        return new TransactionalBatchOperationResult<T>(result, item);\n+    }\n+\n+    /**\n+     * Gets the diagnostics information for the current request to Azure Cosmos DB service.\n+     *\n+     * @return diagnostics information for the current request to Azure Cosmos DB service.\n+     */\n+    public CosmosDiagnostics getDiagnostics() {\n+        return cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the number of operation results.\n+     *\n+     * @return the number of operations results in this response.\n+     */\n+    public int size() {\n+        return this.results == null ? 0 : this.results.size();\n+    }\n+\n+    /**\n+     * Returns a value indicating whether the batch was successfully processed.\n+     *\n+     * @return a value indicating whether the batch was successfully processed.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return this.statusCode >= 200 && this.statusCode <= 299;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute the batch.\n+     *\n+     * @return the activity ID that identifies the server request made to execute the batch.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the reason for the failure of the batch request, if any, or {@code null}.\n+     *\n+     * @return the reason for the failure of the batch request, if any, or {@code null}.\n+     */\n+    public String getErrorMessage() {\n+        return this.errorMessage;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the batch operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+       return BatchExecUtils.getRequestCharge(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the HTTP status code associated with the response.\n+     *\n+     * @return the status code.\n+     */\n+    public int getStatusCode() {\n+        return this.statusCode;\n+    }\n+\n+    /**\n+     * Gets the token used for managing client's consistency requirements.\n+     *\n+     * @return the session token.\n+     */\n+    public String getSessionToken() {\n+        return BatchExecUtils.getSessionToken(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the headers associated with the response.\n+     *\n+     * @return the response headers.\n+     */\n+    public Map<String, String> getResponseHeaders() {\n+        return this.responseHeaders;\n+    }\n+\n+    /**\n+     * Gets the amount of time to wait before retrying this or any other request due to throttling.\n+     *\n+     * @return the amount of time to wait before retrying this or any other request due to throttling.\n+     */\n+    public Duration getRetryAfter() {", "originalCommit": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxNzk1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500517950", "bodyText": "FYI, this is not the length byte, if the string contains unicode the byte encoding len will be more than this.", "author": "moderakh", "createdAt": "2020-10-06T18:41:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ServerBatchRequest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+\n+/**\n+ * This class represents a server batch request.\n+ */\n+public abstract class ServerBatchRequest {\n+\n+    private final int maxBodyLength;\n+    private final int maxOperationCount;\n+\n+    private String requestBody;\n+    private List<ItemBatchOperation<?>> operations;\n+    private boolean isAtomicBatch = false;\n+    private boolean shouldContinueOnError = false;\n+\n+    /**\n+     * Initializes a new {@link ServerBatchRequest request} instance.\n+     *\n+     * @param maxBodyLength Maximum length allowed for the request body.\n+     * @param maxOperationCount Maximum number of operations allowed in the request.\n+     */\n+    ServerBatchRequest(int maxBodyLength, int maxOperationCount) {\n+        this.maxBodyLength = maxBodyLength;\n+        this.maxOperationCount = maxOperationCount;\n+    }\n+\n+    /**\n+     * Adds as many operations as possible from the given list of operations.\n+     * TODO(rakkuma): Similarly for hybrid row, request needs to be parsed to create a request body in any form.\n+     * Issue: https://github.com/Azure/azure-sdk-for-java/issues/15856\n+     *\n+     * Operations are added in order while ensuring the request body never exceeds {@link #maxBodyLength}.\n+     *\n+     * @param operations operations to be added; read-only.\n+     *\n+     * @return Any pending operations that were not included in the request.\n+     */\n+    final List<ItemBatchOperation<?>> createBodyOfBatchRequest(final List<ItemBatchOperation<?>> operations) {\n+\n+        checkNotNull(operations, \"expected non-null operations\");\n+\n+        int totalSerializedLength = 0;\n+        int totalOperationCount = 0;\n+\n+        final ArrayNode arrayNode =  Utils.getSimpleObjectMapper().createArrayNode();\n+\n+        for(ItemBatchOperation<?> operation : operations) {\n+\n+            final JsonSerializable operationJsonSerializable = ItemBatchOperation.writeOperation(operation);\n+            final int operationSerializedLength = operationJsonSerializable.toString().length();", "originalCommit": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ2OTAyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502469022", "bodyText": "+1  - i think it is ok fixing this later - outside the scope of this PR - but please track it via a GitHub item and link the ID here", "author": "FabianMeiswinkel", "createdAt": "2020-10-09T14:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxNzk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzczNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502557734", "bodyText": "Yeah. Created a issue and added the link here. Thanks.", "author": "rakkuma", "createdAt": "2020-10-09T16:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxNzk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxOTUxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500519517", "bodyText": "(optimization for later, out of scope of this PR, please track this).\nhere you are translating the jsonArrayNode to String. later on the encoding over wire you are translating the string to byte array/bytebuf.\nThe more optimized way is to translate directly to byte array.", "author": "moderakh", "createdAt": "2020-10-06T18:44:00Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ServerBatchRequest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+\n+/**\n+ * This class represents a server batch request.\n+ */\n+public abstract class ServerBatchRequest {\n+\n+    private final int maxBodyLength;\n+    private final int maxOperationCount;\n+\n+    private String requestBody;\n+    private List<ItemBatchOperation<?>> operations;\n+    private boolean isAtomicBatch = false;\n+    private boolean shouldContinueOnError = false;\n+\n+    /**\n+     * Initializes a new {@link ServerBatchRequest request} instance.\n+     *\n+     * @param maxBodyLength Maximum length allowed for the request body.\n+     * @param maxOperationCount Maximum number of operations allowed in the request.\n+     */\n+    ServerBatchRequest(int maxBodyLength, int maxOperationCount) {\n+        this.maxBodyLength = maxBodyLength;\n+        this.maxOperationCount = maxOperationCount;\n+    }\n+\n+    /**\n+     * Adds as many operations as possible from the given list of operations.\n+     * TODO(rakkuma): Similarly for hybrid row, request needs to be parsed to create a request body in any form.\n+     * Issue: https://github.com/Azure/azure-sdk-for-java/issues/15856\n+     *\n+     * Operations are added in order while ensuring the request body never exceeds {@link #maxBodyLength}.\n+     *\n+     * @param operations operations to be added; read-only.\n+     *\n+     * @return Any pending operations that were not included in the request.\n+     */\n+    final List<ItemBatchOperation<?>> createBodyOfBatchRequest(final List<ItemBatchOperation<?>> operations) {\n+\n+        checkNotNull(operations, \"expected non-null operations\");\n+\n+        int totalSerializedLength = 0;\n+        int totalOperationCount = 0;\n+\n+        final ArrayNode arrayNode =  Utils.getSimpleObjectMapper().createArrayNode();\n+\n+        for(ItemBatchOperation<?> operation : operations) {\n+\n+            final JsonSerializable operationJsonSerializable = ItemBatchOperation.writeOperation(operation);\n+            final int operationSerializedLength = operationJsonSerializable.toString().length();\n+\n+            if (totalOperationCount != 0 &&\n+                (totalSerializedLength + operationSerializedLength > this.maxBodyLength || totalOperationCount + 1 > this.maxOperationCount)) {\n+                // Apply the limit only if at least there is one operation in selected operations.\n+                break;\n+            }\n+\n+            totalSerializedLength += operationSerializedLength;\n+            totalOperationCount++;\n+\n+            arrayNode.add(operationJsonSerializable.getPropertyBag());\n+        }\n+\n+        this.requestBody = arrayNode.toString();", "originalCommit": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MTY1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500551657", "bodyText": "Oh. Ok. Will make this change. This is a small one, so will make it here only.", "author": "rakkuma", "createdAt": "2020-10-06T19:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxOTUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MTgyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502561825", "bodyText": "I am saving ByteBuf now instead of byte[]. returning byte[] gives following error:\u00a0\n'com.azure.cosmos.implementation.batch.ServerBatchRequest.getRequestBodyAsByteArray() may expose internal representation by returning ServerBatchRequest.requestBody [com.azure.cosmos.implementation.batch.ServerBatchRequest] At ServerBatchRequest.java:[line 90] EI_EXPOSE_REP'\nWe are not modifying ByteBuf later right?", "author": "rakkuma", "createdAt": "2020-10-09T17:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxOTUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMDMzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500520337", "bodyText": "very good test :-) thanks.", "author": "moderakh", "createdAt": "2020-10-06T18:45:28Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/TransactionalBatchAsyncContainerTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.assertj.core.api.Assertions;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TransactionalBatchAsyncContainerTest extends BatchTestBase {\n+\n+    private CosmosAsyncClient batchClient;\n+    private CosmosAsyncContainer batchAsyncContainer;\n+\n+    @Factory(dataProvider = \"clientBuildersWithDirectSession\")\n+    public TransactionalBatchAsyncContainerTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @BeforeClass(groups = {\"simple\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_TransactionalBatchAsyncContainerTest() {\n+        assertThat(this.batchClient).isNull();\n+        this.batchClient = getClientBuilder().buildAsyncClient();\n+        batchAsyncContainer = getSharedMultiPartitionCosmosContainer(this.batchClient);\n+    }\n+\n+    @AfterClass(groups = {\"simple\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        safeCloseAsync(this.batchClient);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void batchExecutionRepeat() {\n+        CosmosAsyncContainer container = this.batchAsyncContainer;\n+        this.createJsonTestDocs(container);\n+\n+        TestDoc firstDoc = this.populateTestDoc(this.partitionKey1);\n+        TestDoc replaceDoc = this.getTestDocCopy(firstDoc);\n+        replaceDoc.setCost(replaceDoc.getCost() + 1);\n+\n+        Mono<TransactionalBatchResponse> batchResponseMono = batchAsyncContainer.executeTransactionalBatch(\n+            TransactionalBatch.createTransactionalBatch(this.getPartitionKey(this.partitionKey1))\n+                .createItem(firstDoc)\n+                .replaceItem(replaceDoc.getId(), replaceDoc));\n+\n+        TransactionalBatchResponse batchResponse1 = batchResponseMono.block();\n+        this.verifyBatchProcessed(batchResponse1, 2);\n+\n+        assertThat(batchResponse1.get(0).getStatusCode()).isEqualTo(HttpResponseStatus.CREATED.code());\n+        assertThat(batchResponse1.get(1).getStatusCode()).isEqualTo(HttpResponseStatus.OK.code());\n+\n+        // Block again.\n+        TransactionalBatchResponse batchResponse2 = batchResponseMono.block();\n+        assertThat(batchResponse2.getStatusCode()).isEqualTo(HttpResponseStatus.CONFLICT.code());\n+        assertThat(batchResponse2.get(0).getStatusCode()).isEqualTo(HttpResponseStatus.CONFLICT.code());\n+        assertThat(batchResponse2.get(1).getStatusCode()).isEqualTo(HttpResponseStatus.FAILED_DEPENDENCY.code());\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT * 100)\n+    public void batchInvalidSessionToken() throws Exception {\n+        CosmosAsyncContainer container = batchAsyncContainer;\n+        this.createJsonTestDocs(container);\n+\n+        CosmosItemResponse<TestDoc> readResponse = container.readItem(\n+            this.TestDocPk1ExistingC.getId(),\n+            this.getPartitionKey(this.partitionKey1),\n+            TestDoc.class).block();\n+\n+        assertThat(readResponse.getStatusCode()).isEqualTo(HttpResponseStatus.OK.code());\n+        String invalidSessionToken = this.getDifferentLSNToken(readResponse.getSessionToken(), 2000);\n+\n+        {\n+            // Batch without Read operation\n+            TestDoc testDocToCreate = this.populateTestDoc(this.partitionKey1);\n+            TestDoc testDocToReplace = this.getTestDocCopy(this.TestDocPk1ExistingA);\n+            testDocToReplace.setCost(testDocToReplace.getCost() + 1);\n+            TestDoc testDocToUpsert = this.populateTestDoc(this.partitionKey1);\n+\n+            TransactionalBatchResponse batchResponse = container.executeTransactionalBatch(\n+                TransactionalBatch.createTransactionalBatch(this.getPartitionKey(this.partitionKey1))\n+                    .createItem(testDocToCreate)\n+                    .replaceItem(testDocToReplace.getId(), testDocToReplace)\n+                    .upsertItem(testDocToUpsert)\n+                    .deleteItem(this.TestDocPk1ExistingC.getId()), new TransactionalBatchRequestOptions().setSessionToken(invalidSessionToken)).block();\n+\n+            this.verifyBatchProcessed(batchResponse, 4);\n+\n+            assertThat(batchResponse.get(0).getStatusCode()).isEqualTo(HttpResponseStatus.CREATED.code());\n+            assertThat(batchResponse.get(1).getStatusCode()).isEqualTo(HttpResponseStatus.OK.code());\n+            assertThat(batchResponse.get(2).getStatusCode()).isEqualTo(HttpResponseStatus.CREATED.code());\n+            assertThat(batchResponse.get(3).getStatusCode()).isEqualTo(HttpResponseStatus.NO_CONTENT.code());\n+        }\n+\n+        {\n+            // Batch with Read operation\n+            TestDoc testDocToCreate = this.populateTestDoc(this.partitionKey1);\n+            TestDoc testDocToReplace = this.getTestDocCopy(this.TestDocPk1ExistingB);\n+            testDocToReplace.setCost(testDocToReplace.getCost() + 1);\n+            TestDoc testDocToUpsert = this.populateTestDoc(this.partitionKey1);\n+\n+            try {\n+                container.executeTransactionalBatch(\n+                    TransactionalBatch.createTransactionalBatch(this.getPartitionKey(this.partitionKey1))\n+                        .createItem(testDocToCreate)\n+                        .replaceItem(testDocToReplace.getId(), testDocToReplace)\n+                        .upsertItem(testDocToUpsert)\n+                        .deleteItem(this.TestDocPk1ExistingD.getId())\n+                        .readItem(this.TestDocPk1ExistingA.getId()), new TransactionalBatchRequestOptions().setSessionToken(invalidSessionToken)).block();\n+\n+                Assertions.fail(\"Should throw NOT_FOUND/READ_SESSION_NOT_AVAILABLE exception\");", "originalCommit": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMzgwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r500523809", "bodyText": "I think we should move the logic for decoding the ObjectNode from TransactionalBatchResponse to TransactionalBatchOperationResult.\nI propose the following:\n\nwe remove TransactionalBatchResponse:getOperationResultAtIndex(int index, Class<T> type)\nwe remove TransactionalBatchOperationResult:getItem()\nwe add TransactionalBatchOperationResult.getItem(Class<T> type)\nchange TransactionalBatchOperationResult<TResource> to be typeless as: TransactionalBatchOperationResult", "author": "moderakh", "createdAt": "2020-10-06T18:51:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link TransactionalBatch} request.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public class TransactionalBatchResponse {\n+\n+    private final Map<String, String> responseHeaders;\n+    private final int statusCode;\n+    private final String errorMessage;\n+    private final List<TransactionalBatchOperationResult<?>> results;\n+    private final int subStatusCode;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link TransactionalBatchResponse} class.\n+     *\n+     * @param statusCode the response status code.\n+     * @param subStatusCode the response sub-status code.\n+     * @param errorMessage an error message or {@code null}.\n+     * @param responseHeaders the response http headers\n+     * @param cosmosDiagnostics the diagnostic\n+     */\n+    TransactionalBatchResponse(\n+        final int statusCode,\n+        final int subStatusCode,\n+        final String errorMessage,\n+        final Map<String, String> responseHeaders,\n+        final CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.statusCode = statusCode;\n+        this.subStatusCode = subStatusCode;\n+        this.errorMessage = errorMessage;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+        this.results = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Gets the result of the operation at the provided index in the current {@link TransactionalBatchResponse batch}.\n+     * <p>\n+     * @param <T> the type parameter.\n+     * @param index 0-based index of the operation in the batch whose result needs to be returned.\n+     * de-serialized, when present.\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return TransactionalBatchOperationResult containing the individual result of operation.\n+     */\n+    public <T> TransactionalBatchOperationResult<T> getOperationResultAtIndex(", "originalCommit": "1d7fb3b1745e8357178d508cb06aeadbbeeec0aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE3NDI0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r501174249", "bodyText": "@kirankumarkolli @FabianMeiswinkel @kushagraThapar please provide your input on this. Does this api look good to you?\nI am still undecided on this one.", "author": "moderakh", "createdAt": "2020-10-07T17:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMzgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4Mzg1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r501183852", "bodyText": "The two options/patterns used are\n\nIndexed based correlation\nIteration model with (request, response)\n\nBetween the two I am for #2, for Bulk #2 is used. For consistency also #2", "author": "kirankumarkolli", "createdAt": "2020-10-07T17:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMzgwOQ=="}], "type": "inlineReview"}, {"oid": "6d8ea0d24ef2c8a8960aa87d7526b639ecf00830", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6d8ea0d24ef2c8a8960aa87d7526b639ecf00830", "message": "code review changes\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-06T20:55:57Z", "type": "commit"}, {"oid": "22633c1bbb81f4075a30e5be451b4e65888854a9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/22633c1bbb81f4075a30e5be451b4e65888854a9", "message": "Merge branch 'master' into users/rakkuma/transactional-batch", "committedDate": "2020-10-06T22:11:33Z", "type": "commit"}, {"oid": "04ca2396502f73abe13838fdea5dc54c3584b34e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/04ca2396502f73abe13838fdea5dc54c3584b34e", "message": "Removing one test case\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-07T06:31:07Z", "type": "commit"}, {"oid": "2735e339d39f4a4796eafb7fe3c00cd20ba93c40", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2735e339d39f4a4796eafb7fe3c00cd20ba93c40", "message": "test\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-07T09:12:36Z", "type": "commit"}, {"oid": "3fc3eef6f4460fccd8c230be913d083db4b32c39", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3fc3eef6f4460fccd8c230be913d083db4b32c39", "message": "Merge branch 'master' into users/rakkuma/transactional-batch", "committedDate": "2020-10-07T14:32:00Z", "type": "commit"}, {"oid": "d605ba10aa3032025ac81ad80103568707a1a171", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d605ba10aa3032025ac81ad80103568707a1a171", "message": "Fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-07T16:53:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxOTQ1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r501219452", "bodyText": "Please make sure that the user can call executeAsync multiple time if 429 or other transient failure is returned.", "author": "j82w", "createdAt": "2020-10-07T18:20:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchExecutor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosBridgeInternal;\n+import com.azure.cosmos.TransactionalBatch;\n+import com.azure.cosmos.TransactionalBatchRequestOptions;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+\n+public final class BatchExecutor {\n+\n+    private final CosmosAsyncContainer container;\n+    private final TransactionalBatchRequestOptions options;\n+    private final TransactionalBatch transactionalBatch;\n+\n+    public BatchExecutor(\n+        final CosmosAsyncContainer container,\n+        final TransactionalBatch transactionalBatch,\n+        final TransactionalBatchRequestOptions options) {\n+\n+        this.container = container;\n+        this.transactionalBatch = transactionalBatch;\n+        this.options = options;\n+    }\n+\n+    /**\n+     * Create a batch request from list of operations and executes it.\n+     *\n+     * @return Response from the server.\n+     */\n+    public final Mono<TransactionalBatchResponse> executeAsync() {", "originalCommit": "d605ba10aa3032025ac81ad80103568707a1a171", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyNTIzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r501225235", "bodyText": "It is inside the context and every time block is called, executeAsync will be called.", "author": "rakkuma", "createdAt": "2020-10-07T18:29:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxOTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ2NzM4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502467384", "bodyText": "Yeah - the github issue for .Net is a non-issue here.", "author": "FabianMeiswinkel", "createdAt": "2020-10-09T14:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxOTQ1Mg=="}], "type": "inlineReview"}, {"oid": "668c0e36300035e8b9f566d83c149badd8ed7053", "url": "https://github.com/Azure/azure-sdk-for-java/commit/668c0e36300035e8b9f566d83c149badd8ed7053", "message": "API change\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-09T09:27:26Z", "type": "commit"}, {"oid": "269c13ce72fbd23dbed16cfe9264e4db0b08d78d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/269c13ce72fbd23dbed16cfe9264e4db0b08d78d", "message": "Merge branch 'master' into users/rakkuma/transactional-batch", "committedDate": "2020-10-09T09:29:41Z", "type": "commit"}, {"oid": "e67348a64a1ec87361d0599c3a9a6f93505a9e44", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e67348a64a1ec87361d0599c3a9a6f93505a9e44", "message": "Adding CosmosItemoperation interface\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-09T11:58:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ3MDg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502470898", "bodyText": "NIT - as discussed I think naming the factory methods xxxItemOperation here - like createItemOperation or upsertItemOperation would be clearer.", "author": "FabianMeiswinkel", "createdAt": "2020-10-09T14:34:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatch.java", "diffHunk": "@@ -0,0 +1,351 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a batch of operations against items with the same {@link PartitionKey} in a container that will be performed\n+ * in a transactional manner at the Azure Cosmos DB service.\n+ * <p>\n+ * Use {@link TransactionalBatch#createTransactionalBatch(PartitionKey)} to create an instance of TransactionalBatch.\n+ * <b>Example</b>\n+ * This example atomically modifies a set of items as a batch.\n+ * <pre>{@code\n+ * public class ToDoActivity {\n+ *     public final String type;\n+ *     public final String id;\n+ *     public final String status;\n+ *     public ToDoActivity(String type, String id, String status) {\n+ *         this.type = type;\n+ *         this.id = id;\n+ *         this.status = status;\n+ *     }\n+ * }\n+ *\n+ * String activityType = \"personal\";\n+ *\n+ * ToDoActivity test1 = new ToDoActivity(activityType, \"learning\", \"ToBeDone\");\n+ * ToDoActivity test2 = new ToDoActivity(activityType, \"shopping\", \"Done\");\n+ * ToDoActivity test3 = new ToDoActivity(activityType, \"swimming\", \"ToBeDone\");\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType));\n+ * batch.createItem<ToDoActivity>(test1);\n+ * batch.replaceItem<ToDoActivity>(test2.id, test2);\n+ * batch.upsertItem<ToDoActivity>(test3);\n+ * batch.deleteItem(\"reading\");\n+ *\n+ * TransactionalBatchResponse response = container.executeTransactionalBatch(batch);\n+ *\n+ * if (!response.isSuccessStatusCode()) {\n+ *      // Handle and log exception\n+ *      return;\n+ * }\n+ *\n+ * // Look up interested results - e.g., via typed access on operation results\n+ *\n+ * TransactionalBatchOperationResult result = response.get(0);\n+ * ToDoActivity readActivity = result.getItem(ToDoActivity.class);\n+ *\n+ * }</pre>\n+ *\n+ * <b>Example</b>\n+ * <p>This example atomically reads a set of items as a batch.\n+ * <pre>{@code\n+ * String activityType = \"personal\";\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType));\n+ * batch.readItem(\"playing\");\n+ * batch.readItem(\"walking\");\n+ * batch.readItem(\"jogging\");\n+ * batch.readItem(\"running\")v\n+ *\n+ * TransactionalBatchResponse response = container.executeTransactionalBatch(batch);\n+ * List<ToDoActivity> resultItems = new ArrayList<ToDoActivity>();\n+ *\n+ * for (int i = 0; i < response.size(); i++) {\n+ *     TransactionalBatchOperationResult result = response.get(0);\n+ *     resultItems.add(result.getItem(ToDoActivity.class));\n+ * }\n+ *\n+ * }</pre>\n+ * <p>\n+ * <b>See:</b>\n+ * <a href=\"https://docs.microsoft.com/azure/cosmos-db/concepts-limits\">Limits on TransactionalBatch requests</a>.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class TransactionalBatch {\n+\n+    private final List<ItemBatchOperation<?>> operations;\n+    private final PartitionKey partitionKey;\n+\n+    TransactionalBatch(PartitionKey partitionKey) {\n+        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n+\n+        this.operations = new ArrayList<>();\n+        this.partitionKey = partitionKey;\n+    }\n+\n+    /**\n+     * Initializes a new instance of {@link TransactionalBatch}\n+     * that will contain operations to be performed across multiple items in the container with the provided partition\n+     * key in a transactional manner\n+     *\n+     * @param partitionKey the partition key for all items in the batch.\n+     *\n+     * @return A new instance of {@link TransactionalBatch}.\n+     */\n+    public static TransactionalBatch createTransactionalBatch(PartitionKey partitionKey) {\n+        return new TransactionalBatch(partitionKey);\n+    }\n+\n+    /**\n+     * Adds an operation to create an item into the batch.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param <T> The type of item to be created.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> CosmosItemOperation createItem(T item) {", "originalCommit": "e67348a64a1ec87361d0599c3a9a6f93505a9e44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MzgwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502553807", "bodyText": "java enum all all upper case\nCreate -> CREATE.\nwe should follow this for the new public enum.", "author": "moderakh", "createdAt": "2020-10-09T16:47:20Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosItemOperationType.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.BatchRequestResponseConstant;\n+\n+public enum CosmosItemOperationType {\n+\n+    Create(BatchRequestResponseConstant.OPERATION_CREATE),", "originalCommit": "e67348a64a1ec87361d0599c3a9a6f93505a9e44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MTQ0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502561449", "bodyText": "Yeah. Fixed.", "author": "rakkuma", "createdAt": "2020-10-09T17:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MzgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NDM1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502554358", "bodyText": "beta tag as well\n@beta(Beta.SinceVersion.V4_7_0)", "author": "moderakh", "createdAt": "2020-10-09T16:48:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosItemOperationType.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.BatchRequestResponseConstant;\n+\n+public enum CosmosItemOperationType {", "originalCommit": "e67348a64a1ec87361d0599c3a9a6f93505a9e44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzI3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502557273", "bodyText": "Yeah. Fixed. Thanks.", "author": "rakkuma", "createdAt": "2020-10-09T16:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NDM1OA=="}], "type": "inlineReview"}, {"oid": "17ea44b3779d14183752e31322b7540bb44292da", "url": "https://github.com/Azure/azure-sdk-for-java/commit/17ea44b3779d14183752e31322b7540bb44292da", "message": "Fixing comment\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-09T16:53:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MjQwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502562403", "bodyText": "duplicate.\nyou can rely on getOperations() public method.", "author": "moderakh", "createdAt": "2020-10-09T17:03:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/TransactionalBatch.java", "diffHunk": "@@ -0,0 +1,351 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.batch.ItemBatchOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Represents a batch of operations against items with the same {@link PartitionKey} in a container that will be performed\n+ * in a transactional manner at the Azure Cosmos DB service.\n+ * <p>\n+ * Use {@link TransactionalBatch#createTransactionalBatch(PartitionKey)} to create an instance of TransactionalBatch.\n+ * <b>Example</b>\n+ * This example atomically modifies a set of items as a batch.\n+ * <pre>{@code\n+ * public class ToDoActivity {\n+ *     public final String type;\n+ *     public final String id;\n+ *     public final String status;\n+ *     public ToDoActivity(String type, String id, String status) {\n+ *         this.type = type;\n+ *         this.id = id;\n+ *         this.status = status;\n+ *     }\n+ * }\n+ *\n+ * String activityType = \"personal\";\n+ *\n+ * ToDoActivity test1 = new ToDoActivity(activityType, \"learning\", \"ToBeDone\");\n+ * ToDoActivity test2 = new ToDoActivity(activityType, \"shopping\", \"Done\");\n+ * ToDoActivity test3 = new ToDoActivity(activityType, \"swimming\", \"ToBeDone\");\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType));\n+ * batch.createItemOperation<ToDoActivity>(test1);\n+ * batch.replaceItemOperation<ToDoActivity>(test2.id, test2);\n+ * batch.upsertItemOperation<ToDoActivity>(test3);\n+ * batch.deleteItemOperation(\"reading\");\n+ *\n+ * TransactionalBatchResponse response = container.executeTransactionalBatch(batch);\n+ *\n+ * if (!response.isSuccessStatusCode()) {\n+ *      // Handle and log exception\n+ *      return;\n+ * }\n+ *\n+ * // Look up interested results - e.g., via typed access on operation results\n+ *\n+ * TransactionalBatchOperationResult result = response.get(0);\n+ * ToDoActivity readActivity = result.getItem(ToDoActivity.class);\n+ *\n+ * }</pre>\n+ *\n+ * <b>Example</b>\n+ * <p>This example atomically reads a set of items as a batch.\n+ * <pre>{@code\n+ * String activityType = \"personal\";\n+ *\n+ * TransactionalBatch batch = TransactionalBatch.createTransactionalBatch(new Cosmos.PartitionKey(activityType));\n+ * batch.readItemOperation(\"playing\");\n+ * batch.readItemOperation(\"walking\");\n+ * batch.readItemOperation(\"jogging\");\n+ * batch.readItemOperation(\"running\");\n+ *\n+ * TransactionalBatchResponse response = container.executeTransactionalBatch(batch);\n+ * List<ToDoActivity> resultItems = new ArrayList<ToDoActivity>();\n+ *\n+ * for (int i = 0; i < response.size(); i++) {\n+ *     TransactionalBatchOperationResult result = response.get(0);\n+ *     resultItems.add(result.getItem(ToDoActivity.class));\n+ * }\n+ *\n+ * }</pre>\n+ * <p>\n+ * <b>See:</b>\n+ * <a href=\"https://docs.microsoft.com/azure/cosmos-db/concepts-limits\">Limits on TransactionalBatch requests</a>.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class TransactionalBatch {\n+\n+    private final List<ItemBatchOperation<?>> operations;\n+    private final PartitionKey partitionKey;\n+\n+    TransactionalBatch(PartitionKey partitionKey) {\n+        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n+\n+        this.operations = new ArrayList<>();\n+        this.partitionKey = partitionKey;\n+    }\n+\n+    /**\n+     * Initializes a new instance of {@link TransactionalBatch}\n+     * that will contain operations to be performed across multiple items in the container with the provided partition\n+     * key in a transactional manner\n+     *\n+     * @param partitionKey the partition key for all items in the batch.\n+     *\n+     * @return A new instance of {@link TransactionalBatch}.\n+     */\n+    public static TransactionalBatch createTransactionalBatch(PartitionKey partitionKey) {\n+        return new TransactionalBatch(partitionKey);\n+    }\n+\n+    /**\n+     * Adds an operation to create an item into the batch.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param <T> The type of item to be created.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> CosmosItemOperation createItemOperation(T item) {\n+        checkNotNull(item, \"expected non-null item\");\n+        return this.createItemOperation(item, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to create an item into the batch.\n+     *\n+     * @param <T> The type of item to be created.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param requestOptions The options for the item request.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> CosmosItemOperation createItemOperation(T item, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(item, \"expected non-null item\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        ItemBatchOperation<T> operation = new ItemBatchOperation<T>(\n+            CosmosItemOperationType.CREATE,\n+            null,\n+            this.getPartitionKeyValue(),\n+            requestOptions.toRequestOptions(),\n+            item\n+        );\n+\n+        this.operations.add(operation);\n+\n+        return operation;\n+    }\n+\n+    /**\n+     * Adds an operation to delete an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public CosmosItemOperation deleteItemOperation(String id) {\n+        checkNotNull(id, \"expected non-null id\");\n+        return this.deleteItemOperation(id, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to delete an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     * @param requestOptions The options for the item request.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public CosmosItemOperation deleteItemOperation(String id, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(id, \"expected non-null id\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        ItemBatchOperation<?> operation = new ItemBatchOperation<>(\n+            CosmosItemOperationType.DELETE,\n+            id,\n+            this.getPartitionKeyValue(),\n+            requestOptions.toRequestOptions(),\n+            null\n+        );\n+\n+        this.operations.add(operation);\n+\n+        return operation;\n+    }\n+\n+    /**\n+     * Adds an operation to read an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public CosmosItemOperation readItemOperation(String id) {\n+        checkNotNull(id, \"expected non-null id\");\n+        return this.readItemOperation(id, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to read an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     * @param requestOptions The options for the item request.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public CosmosItemOperation readItemOperation(String id, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(id, \"expected non-null id\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        ItemBatchOperation<?> operation = new ItemBatchOperation<>(\n+            CosmosItemOperationType.READ,\n+            id,\n+            this.getPartitionKeyValue(),\n+            requestOptions.toRequestOptions(),\n+            null\n+        );\n+\n+        this.operations.add(operation);\n+\n+        return operation;\n+    }\n+\n+    /**\n+     * Adds an operation to replace an item into the batch.\n+     *\n+     * @param id The unique id of the item.\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param <T> The type of item to be replaced.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> CosmosItemOperation replaceItemOperation(String id, T item) {\n+        checkNotNull(id, \"expected non-null id\");\n+        checkNotNull(item, \"expected non-null item\");\n+        return this.replaceItemOperation(id, item, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to replace an item into the batch.\n+     *\n+     * @param <T> The type of item to be replaced.\n+     *\n+     * @param id The unique id of the item.\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param requestOptions The options for the item request.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> CosmosItemOperation replaceItemOperation(\n+        String id, T item, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(id, \"expected non-null id\");\n+        checkNotNull(item, \"expected non-null item\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        ItemBatchOperation<T> operation = new ItemBatchOperation<T>(\n+            CosmosItemOperationType.REPLACE,\n+            id,\n+            this.getPartitionKeyValue(),\n+            requestOptions.toRequestOptions(),\n+            item\n+        );\n+\n+        this.operations.add(operation);\n+\n+        return operation;\n+    }\n+\n+    /**\n+     * Adds an operation to upsert an item into the batch.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param <T> The type of item to be upserted.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> CosmosItemOperation upsertItemOperation(T item) {\n+        checkNotNull(item, \"expected non-null item\");\n+        return this.upsertItemOperation(item, new TransactionalBatchItemRequestOptions());\n+    }\n+\n+    /**\n+     * Adds an operation to upsert an item into the batch.\n+     *\n+     * @param <T> The type of item to be upserted.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param requestOptions The options for the item request.\n+     *\n+     * @return The transactional batch instance with the operation added.\n+     */\n+    public <T> CosmosItemOperation upsertItemOperation(T item, TransactionalBatchItemRequestOptions requestOptions) {\n+\n+        checkNotNull(item, \"expected non-null item\");\n+        if (requestOptions == null) {\n+            requestOptions = new TransactionalBatchItemRequestOptions();\n+        }\n+\n+        ItemBatchOperation<T> operation = new ItemBatchOperation<T>(\n+            CosmosItemOperationType.UPSERT,\n+            null,\n+            this.getPartitionKeyValue(),\n+            requestOptions.toRequestOptions(),\n+            item\n+        );\n+\n+        this.operations.add(operation);\n+\n+        return operation;\n+    }\n+\n+    /**\n+     * Return the list of operation in an unmodifiable instance  so no one can change it in the down path.\n+     *\n+     * @return The list of operations which are to be executed.\n+     */\n+    List<ItemBatchOperation<?>> getOperationsInternal() {\n+        return UnmodifiableList.unmodifiableList(operations);", "originalCommit": "17ea44b3779d14183752e31322b7540bb44292da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NDIwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15775#discussion_r502594209", "bodyText": "Yeah changed it to use CosmosItemOperation everywhere except when serializing it.", "author": "rakkuma", "createdAt": "2020-10-09T18:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MjQwMw=="}], "type": "inlineReview"}, {"oid": "4c4893d8b4ee66d57b9f2b0db9295252809bbd88", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4c4893d8b4ee66d57b9f2b0db9295252809bbd88", "message": "Fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-09T17:50:59Z", "type": "commit"}, {"oid": "b70749589b0d1c23cf9b832fd75544fb0e9eafdf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b70749589b0d1c23cf9b832fd75544fb0e9eafdf", "message": "Reverting byte buffer change\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-10-09T19:45:56Z", "type": "commit"}]}