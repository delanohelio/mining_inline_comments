{"pr_number": 9615, "pr_title": "Adds synchronous receiver", "pr_createdAt": "2020-03-26T21:54:35Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9615", "timeline": [{"oid": "288e4a359727c40370c7d28e50d213a8db0a2bea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/288e4a359727c40370c7d28e50d213a8db0a2bea", "message": "Adding topicName.", "committedDate": "2020-03-26T21:53:09Z", "type": "commit"}, {"oid": "bfc1075dfe1749fa5508b86c98fe189095462ab2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bfc1075dfe1749fa5508b86c98fe189095462ab2", "message": "Reorganizing methods alphabetically.", "committedDate": "2020-03-26T21:53:09Z", "type": "commit"}, {"oid": "8bd3d5a74f703d9bb49a4a72ed9c76ee1769cc80", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bd3d5a74f703d9bb49a4a72ed9c76ee1769cc80", "message": "Update documentation.", "committedDate": "2020-03-26T21:53:10Z", "type": "commit"}, {"oid": "21e3ac8c55707f388276f16a4c73aeb380f2fd1a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21e3ac8c55707f388276f16a4c73aeb380f2fd1a", "message": "Adding documentation.", "committedDate": "2020-03-26T21:53:10Z", "type": "commit"}, {"oid": "6827acc1ecc720d1c4151209f9c49f7553a9f24c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6827acc1ecc720d1c4151209f9c49f7553a9f24c", "message": "Adding synchronous receive methods.", "committedDate": "2020-03-26T21:53:11Z", "type": "commit"}, {"oid": "abea9f25f3e24b9ccdf42851cf93065b1fc8e9d3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/abea9f25f3e24b9ccdf42851cf93065b1fc8e9d3", "message": "Adding tests.", "committedDate": "2020-03-26T21:53:11Z", "type": "commit"}, {"oid": "68fcc6e2ddf1d5405fe73669cff4bc23b195dc7a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/68fcc6e2ddf1d5405fe73669cff4bc23b195dc7a", "message": "Fixing API docs.", "committedDate": "2020-03-26T22:43:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyODc1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9615#discussion_r398928757", "bodyText": "According to APIVIEW :  we should change to peekAt in sync and Async receiver.", "author": "hemanttanwar", "createdAt": "2020-03-26T22:24:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -15,10 +30,291 @@\n  */\n @ServiceClient(builder = ServiceBusClientBuilder.class)\n public class ServiceBusReceiverClient implements AutoCloseable {\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClient.class);\n+    private final AtomicInteger idGenerator = new AtomicInteger();\n     private final ServiceBusReceiverAsyncClient asyncClient;\n+    private final Duration operationTimeout;\n+\n+    /**\n+     * Creates a synchronous receiver given its asynchronous counterpart.\n+     *\n+     * @param asyncClient Asynchronous receiver.\n+     */\n+    ServiceBusReceiverClient(ServiceBusReceiverAsyncClient asyncClient, Duration operationTimeout) {\n+        this.asyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+        this.operationTimeout = Objects.requireNonNull(operationTimeout, \"'operationTimeout' cannot be null.\");\n+    }\n+\n+    /**\n+     * Gets the fully qualified Service Bus namespace that the connection is associated with. This is likely similar to\n+     * {@code {yournamespace}.servicebus.windows.net}.\n+     *\n+     * @return The fully qualified Service Bus namespace that the connection is associated with.\n+     */\n+    public String getFullyQualifiedNamespace() {\n+        return asyncClient.getFullyQualifiedNamespace();\n+    }\n+\n+    /**\n+     * Gets the Service Bus resource this client interacts with.\n+     *\n+     * @return The Service Bus resource this client interacts with.\n+     */\n+    public String getEntityPath() {\n+        return asyncClient.getEntityPath();\n+    }\n+\n+    /**\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token. This will make the message available\n+     * again for processing. Abandoning a message will increase the delivery count on the message.\n+     *\n+     * @param lockToken Lock token of the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     */\n+    public void abandon(MessageLockToken lockToken) {\n+        asyncClient.abandon(lockToken).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token and updates the message's properties.\n+     * This will make the message available again for processing. Abandoning a message will increase the delivery count\n+     * on the message.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param propertiesToModify Properties to modify on the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     */\n+    public void abandon(MessageLockToken lockToken, Map<String, Object> propertiesToModify) {\n+        asyncClient.abandon(lockToken, propertiesToModify).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Completes a {@link ServiceBusReceivedMessage message} using its lock token. This will delete the message from the\n+     * service.\n+     *\n+     * @param lockToken Lock token of the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     */\n+    public void complete(MessageLockToken lockToken) {\n+        asyncClient.complete(lockToken).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Defers a {@link ServiceBusReceivedMessage message} using its lock token. This will move message into the deferred\n+     * subqueue.\n+     *\n+     * @param lockToken Lock token of the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-deferral>Message deferral</a>\n+     */\n+    public void defer(MessageLockToken lockToken) {\n+        asyncClient.defer(lockToken).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Defers a {@link ServiceBusReceivedMessage message} using its lock token with modified message property. This will\n+     * move message into the deferred subqueue.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param propertiesToModify Message properties to modify.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-deferral>Message deferral</a>\n+     */\n+    public void defer(MessageLockToken lockToken, Map<String, Object> propertiesToModify) {\n+        asyncClient.defer(lockToken, propertiesToModify).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Moves a {@link ServiceBusReceivedMessage message} to the deadletter sub-queue.\n+     *\n+     * @param lockToken Lock token of the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\">Dead letter\n+     *     queues</a>\n+     */\n+    public void deadLetter(MessageLockToken lockToken) {\n+        asyncClient.deadLetter(lockToken).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Moves a {@link ServiceBusReceivedMessage message} to the deadletter subqueue with deadletter reason, error\n+     * description, and/or modified properties.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param deadLetterOptions The options to specify when moving message to the deadletter sub-queue.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     */\n+    public void deadLetter(MessageLockToken lockToken, DeadLetterOptions deadLetterOptions) {\n+        asyncClient.deadLetter(lockToken, deadLetterOptions).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Reads the next active message without changing the state of the receiver or the message source. The first call to\n+     * {@code peek()} fetches the first active message for this receiver. Each subsequent call fetches the subsequent\n+     * message in the entity.\n+     *\n+     * @return A peeked {@link ServiceBusReceivedMessage}.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n+     */\n+    public ServiceBusReceivedMessage peek() {\n+        return asyncClient.peek().block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starting from the given sequence number, reads next the active message without changing the state of the receiver\n+     * or the message source.\n+     *\n+     * @param fromSequenceNumber The sequence number from where to read the message.\n+     *\n+     * @return A peeked {@link ServiceBusReceivedMessage}.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n+     */\n+    public ServiceBusReceivedMessage peek(long fromSequenceNumber) {\n+        return asyncClient.peek(fromSequenceNumber).block(operationTimeout);", "originalCommit": "abea9f25f3e24b9ccdf42851cf93065b1fc8e9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyOTYwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9615#discussion_r398929607", "bodyText": "change to peekBatchAt ?", "author": "hemanttanwar", "createdAt": "2020-03-26T22:26:23Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -15,10 +30,291 @@\n  */\n @ServiceClient(builder = ServiceBusClientBuilder.class)\n public class ServiceBusReceiverClient implements AutoCloseable {\n+    private final ClientLogger logger = new ClientLogger(ServiceBusReceiverClient.class);\n+    private final AtomicInteger idGenerator = new AtomicInteger();\n     private final ServiceBusReceiverAsyncClient asyncClient;\n+    private final Duration operationTimeout;\n+\n+    /**\n+     * Creates a synchronous receiver given its asynchronous counterpart.\n+     *\n+     * @param asyncClient Asynchronous receiver.\n+     */\n+    ServiceBusReceiverClient(ServiceBusReceiverAsyncClient asyncClient, Duration operationTimeout) {\n+        this.asyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+        this.operationTimeout = Objects.requireNonNull(operationTimeout, \"'operationTimeout' cannot be null.\");\n+    }\n+\n+    /**\n+     * Gets the fully qualified Service Bus namespace that the connection is associated with. This is likely similar to\n+     * {@code {yournamespace}.servicebus.windows.net}.\n+     *\n+     * @return The fully qualified Service Bus namespace that the connection is associated with.\n+     */\n+    public String getFullyQualifiedNamespace() {\n+        return asyncClient.getFullyQualifiedNamespace();\n+    }\n+\n+    /**\n+     * Gets the Service Bus resource this client interacts with.\n+     *\n+     * @return The Service Bus resource this client interacts with.\n+     */\n+    public String getEntityPath() {\n+        return asyncClient.getEntityPath();\n+    }\n+\n+    /**\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token. This will make the message available\n+     * again for processing. Abandoning a message will increase the delivery count on the message.\n+     *\n+     * @param lockToken Lock token of the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     */\n+    public void abandon(MessageLockToken lockToken) {\n+        asyncClient.abandon(lockToken).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token and updates the message's properties.\n+     * This will make the message available again for processing. Abandoning a message will increase the delivery count\n+     * on the message.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param propertiesToModify Properties to modify on the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     */\n+    public void abandon(MessageLockToken lockToken, Map<String, Object> propertiesToModify) {\n+        asyncClient.abandon(lockToken, propertiesToModify).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Completes a {@link ServiceBusReceivedMessage message} using its lock token. This will delete the message from the\n+     * service.\n+     *\n+     * @param lockToken Lock token of the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     */\n+    public void complete(MessageLockToken lockToken) {\n+        asyncClient.complete(lockToken).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Defers a {@link ServiceBusReceivedMessage message} using its lock token. This will move message into the deferred\n+     * subqueue.\n+     *\n+     * @param lockToken Lock token of the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-deferral>Message deferral</a>\n+     */\n+    public void defer(MessageLockToken lockToken) {\n+        asyncClient.defer(lockToken).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Defers a {@link ServiceBusReceivedMessage message} using its lock token with modified message property. This will\n+     * move message into the deferred subqueue.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param propertiesToModify Message properties to modify.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-deferral>Message deferral</a>\n+     */\n+    public void defer(MessageLockToken lockToken, Map<String, Object> propertiesToModify) {\n+        asyncClient.defer(lockToken, propertiesToModify).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Moves a {@link ServiceBusReceivedMessage message} to the deadletter sub-queue.\n+     *\n+     * @param lockToken Lock token of the message.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\">Dead letter\n+     *     queues</a>\n+     */\n+    public void deadLetter(MessageLockToken lockToken) {\n+        asyncClient.deadLetter(lockToken).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Moves a {@link ServiceBusReceivedMessage message} to the deadletter subqueue with deadletter reason, error\n+     * description, and/or modified properties.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param deadLetterOptions The options to specify when moving message to the deadletter sub-queue.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     */\n+    public void deadLetter(MessageLockToken lockToken, DeadLetterOptions deadLetterOptions) {\n+        asyncClient.deadLetter(lockToken, deadLetterOptions).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Reads the next active message without changing the state of the receiver or the message source. The first call to\n+     * {@code peek()} fetches the first active message for this receiver. Each subsequent call fetches the subsequent\n+     * message in the entity.\n+     *\n+     * @return A peeked {@link ServiceBusReceivedMessage}.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n+     */\n+    public ServiceBusReceivedMessage peek() {\n+        return asyncClient.peek().block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starting from the given sequence number, reads next the active message without changing the state of the receiver\n+     * or the message source.\n+     *\n+     * @param fromSequenceNumber The sequence number from where to read the message.\n+     *\n+     * @return A peeked {@link ServiceBusReceivedMessage}.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n+     */\n+    public ServiceBusReceivedMessage peek(long fromSequenceNumber) {\n+        return asyncClient.peek(fromSequenceNumber).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Reads the next batch of active messages without changing the state of the receiver or the message source.\n+     *\n+     * @param maxMessages The number of messages.\n+     *\n+     * @return An {@link IterableStream} of {@link ServiceBusReceivedMessage messages} that are peeked.\n+     * @throws IllegalArgumentException if {@code maxMessages} is not a positive integer.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n+     */\n+    public IterableStream<ServiceBusReceivedMessage> peekBatch(int maxMessages) {\n+        if (maxMessages <= 0) {\n+            throw new IllegalArgumentException(\"'maxMessages' cannot be less than or equal to 0. maxMessages: \"\n+                + maxMessages);\n+        }\n+\n+        final Flux<ServiceBusReceivedMessage> messages = asyncClient.peekBatch(maxMessages)\n+            .timeout(operationTimeout);\n+\n+        // Subscribe so we can kick off this operation.\n+        messages.subscribe();\n \n-    ServiceBusReceiverClient(ServiceBusReceiverAsyncClient asyncClient) {\n-        this.asyncClient = asyncClient;\n+        return new IterableStream<>(messages);\n+    }\n+\n+    /**\n+     * Starting from the given sequence number, reads the next batch of active messages without changing the state of\n+     * the receiver or the message source.\n+     *\n+     * @param maxMessages The number of messages.\n+     * @param fromSequenceNumber The sequence number from where to start reading messages.\n+     *\n+     * @return An {@link IterableStream} of {@link ServiceBusReceivedMessage} peeked.\n+     * @throws IllegalArgumentException if {@code maxMessages} is not a positive integer.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n+     */\n+    public IterableStream<ServiceBusReceivedMessage> peekBatch(int maxMessages, long fromSequenceNumber) {\n+        if (maxMessages <= 0) {", "originalCommit": "abea9f25f3e24b9ccdf42851cf93065b1fc8e9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkzMzMzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9615#discussion_r398933338", "bodyText": "peekBatchAt", "author": "hemanttanwar", "createdAt": "2020-03-26T22:36:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -105,231 +107,286 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Receives a stream of {@link ServiceBusReceivedMessage}.\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token. This will make the message available\n+     * again for processing. Abandoning a message will increase the delivery count on the message.\n+     *\n+     * @param lockToken Lock token of the message.\n      *\n-     * @return A stream of messages from Service Bus.\n+     * @return A {@link Mono} that completes when the Service Bus operation finishes.\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n      */\n-    public Flux<ServiceBusReceivedMessage> receive() {\n-        if (isDisposed.get()) {\n-            return Flux.error(logger.logExceptionAsError(\n-                new IllegalStateException(\"Cannot receive from a client that is already closed.\")));\n-        }\n-\n-        if (receiveMode != ReceiveMode.PEEK_LOCK && receiveOptions.isAutoComplete()) {\n-            return Flux.error(logger.logExceptionAsError(new UnsupportedOperationException(\n-                \"Autocomplete is not supported on a receiver opened in ReceiveMode.RECEIVE_AND_DELETE.\")));\n-        }\n-\n-        // TODO (conniey): This returns the same consumer instance because the entityPath is not unique.\n-        //  Python and .NET does not have the same behaviour.\n-        return Flux.usingWhen(\n-            Mono.fromCallable(() -> getOrCreateConsumer(entityPath)),\n-            consumer -> consumer.receive(),\n-            consumer -> {\n-                final String linkName = consumer.getLinkName();\n-                logger.info(\"{}: Receiving completed. Disposing\", linkName);\n-\n-                final ServiceBusAsyncConsumer removed = openConsumers.remove(linkName);\n-                if (removed == null) {\n-                    logger.warning(\"Could not find consumer to remove for: {}\", linkName);\n-                } else {\n-                    removed.close();\n-                }\n-\n-                return Mono.empty();\n-            });\n+    public Mono<Void> abandon(MessageLockToken lockToken) {\n+        return abandon(lockToken, null);\n     }\n \n     /**\n-     * Abandon {@link ServiceBusMessage} with lock token. This will make the message available again for processing.\n-     * Abandoning a message will increase the delivery count on the message.\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token and updates the message's properties.\n+     * This will make the message available again for processing. Abandoning a message will increase the delivery count\n+     * on the message.\n      *\n-     * @param message to be used.\n+     * @param lockToken Lock token of the message.\n+     * @param propertiesToModify Properties to modify on the message.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A {@link Mono} that completes when the Service Bus operation finishes.\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n      */\n-    public Mono<Void> abandon(ServiceBusReceivedMessage message) {\n-        return abandon(message, null);\n+    public Mono<Void> abandon(MessageLockToken lockToken, Map<String, Object> propertiesToModify) {\n+        return updateDisposition(lockToken, DispositionStatus.ABANDONED, null, null, propertiesToModify);\n     }\n \n     /**\n-     * Abandon {@link ServiceBusMessage} with lock token and updated message property. This will make the message\n-     * available again for processing. Abandoning a message will increase the delivery count on the message.\n+     * Completes a {@link ServiceBusReceivedMessage message} using its lock token. This will delete the message from the\n+     * service.\n      *\n-     * @param message to be used.\n-     * @param propertiesToModify Message properties to modify.\n+     * @param lockToken Lock token of the message.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A {@link Mono} that completes when the Service Bus operation finishes.\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n      */\n-    public Mono<Void> abandon(ServiceBusReceivedMessage message, Map<String, Object> propertiesToModify) {\n-        return updateDisposition(message, DispositionStatus.ABANDONED, null, null, propertiesToModify);\n+    public Mono<Void> complete(MessageLockToken lockToken) {\n+        return updateDisposition(lockToken, DispositionStatus.COMPLETED, null, null, null);\n     }\n \n     /**\n-     * Completes a {@link ServiceBusMessage} using its lock token. This will delete the message from the service.\n+     * Defers a {@link ServiceBusReceivedMessage message} using its lock token. This will move message into the deferred\n+     * subqueue.\n      *\n-     * @param message Message to be completed.\n+     * @param lockToken Lock token of the message.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A {@link Mono} that completes when the Service Bus operation finishes.\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-deferral>Message deferral</a>\n      */\n-    public Mono<Void> complete(ServiceBusReceivedMessage message) {\n-        return updateDisposition(message, DispositionStatus.COMPLETED, null, null, null);\n+    public Mono<Void> defer(MessageLockToken lockToken) {\n+        return defer(lockToken, null);\n     }\n \n     /**\n-     * Defers a {@link ServiceBusMessage} using its lock token. This will move message into deferred subqueue.\n+     * Defers a {@link ServiceBusReceivedMessage message} using its lock token with modified message property. This will\n+     * move message into the deferred subqueue.\n      *\n-     * @param message to be used.\n+     * @param lockToken Lock token of the message.\n+     * @param propertiesToModify Message properties to modify.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A {@link Mono} that completes when the Service Bus operation finishes.\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-deferral>Message deferral</a>\n      */\n-    public Mono<Void> defer(ServiceBusReceivedMessage message) {\n-        return defer(message, null);\n+    public Mono<Void> defer(MessageLockToken lockToken, Map<String, Object> propertiesToModify) {\n+        return updateDisposition(lockToken, DispositionStatus.DEFERRED, null, null, propertiesToModify);\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n-     * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n-     * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n-     * lock is reset to the entity's LockDuration value.\n+     * Moves a {@link ServiceBusReceivedMessage message} to the deadletter sub-queue.\n      *\n-     * @param receivedMessage to be used to renew.\n+     * @param lockToken Lock token of the message.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A {@link Mono} that completes when the Service Bus operation finishes.\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\">Dead letter\n+     *     queues</a>\n      */\n-    public Mono<Instant> renewMessageLock(ServiceBusReceivedMessage receivedMessage) {\n-        Objects.requireNonNull(receivedMessage, \"'receivedMessage' cannot be null.\");\n-\n-        return connectionProcessor\n-            .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n-            .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(receivedMessage.getLockToken()))\n-            .map(instant -> {\n-                receivedMessage.setLockedUntil(instant);\n-                return instant;\n-            });\n+    public Mono<Void> deadLetter(MessageLockToken lockToken) {\n+        return deadLetter(lockToken, DEFAULT_DEAD_LETTER_OPTIONS);\n     }\n \n     /**\n-     * Defers a {@link ServiceBusMessage} using its lock token with modified message property. This will move message\n-     * into deferred subqueue.\n+     * Moves a {@link ServiceBusReceivedMessage message} to the deadletter subqueue with deadletter reason, error\n+     * description, and/or modified properties.\n      *\n-     * @param message to be used.\n-     * @param propertiesToModify Message properties to modify.\n+     * @param lockToken Lock token of the message.\n+     * @param deadLetterOptions The options to specify when moving message to the deadletter sub-queue.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A {@link Mono} that completes when the Service Bus operation finishes.\n+     * @throws NullPointerException if {@code lockToken} or {@code deadLetterOptions} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n      */\n-    public Mono<Void> defer(ServiceBusReceivedMessage message, Map<String, Object> propertiesToModify) {\n-        return updateDisposition(message, DispositionStatus.DEFERRED, null, null, propertiesToModify);\n+    public Mono<Void> deadLetter(MessageLockToken lockToken, DeadLetterOptions deadLetterOptions) {\n+        if (Objects.isNull(deadLetterOptions)) {\n+            return monoError(logger, new NullPointerException(\"'deadLetterOptions' cannot be null.\"));\n+        }\n+\n+        return updateDisposition(lockToken, DispositionStatus.SUSPENDED, deadLetterOptions.getDeadLetterReason(),\n+            deadLetterOptions.getDeadLetterErrorDescription(), deadLetterOptions.getPropertiesToModify());\n     }\n \n     /**\n-     * Moves a {@link ServiceBusMessage} to the deadletter sub-queue.\n-     *\n-     * @param message to be used.\n+     * Reads the next active message without changing the state of the receiver or the message source. The first call to\n+     * {@code peek()} fetches the first active message for this receiver. Each subsequent call fetches the subsequent\n+     * message in the entity.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A peeked {@link ServiceBusReceivedMessage}.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n      */\n-    public Mono<Void> deadLetter(ServiceBusReceivedMessage message) {\n-        return deadLetter(message, DEFAULT_DEAD_LETTER_OPTIONS);\n+    public Mono<ServiceBusReceivedMessage> peek() {\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n+            .flatMap(ServiceBusManagementNode::peek);\n     }\n \n     /**\n-     * Moves a {@link ServiceBusMessage} to the deadletter sub-queue with deadletter reason, error description and\n-     * modifided properties.\n+     * Starting from the given sequence number, reads next the active message without changing the state of the receiver\n+     * or the message source.\n      *\n-     * @param message to be used.\n-     * @param deadLetterOptions The options to specify while moving message to the deadletter sub-queue.\n+     * @param fromSequenceNumber The sequence number from where to read the message.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A peeked {@link ServiceBusReceivedMessage}.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n      */\n-    public Mono<Void> deadLetter(ServiceBusReceivedMessage message, DeadLetterOptions deadLetterOptions) {\n-        Objects.requireNonNull(deadLetterOptions, \"'deadLetterOptions' cannot be null.\");\n-\n-        return updateDisposition(message, DispositionStatus.SUSPENDED, deadLetterOptions.getDeadLetterReason(),\n-            deadLetterOptions.getDeadLetterErrorDescription(), deadLetterOptions.getPropertiesToModify());\n-\n+    public Mono<ServiceBusReceivedMessage> peek(long fromSequenceNumber) {\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n+            .flatMap(node -> node.peek(fromSequenceNumber));\n     }\n \n     /**\n-     * Receives a deferred {@link ServiceBusMessage}. Deferred messages can only be received by using sequence number.\n+     * Reads the next batch of active messages without changing the state of the receiver or the message source.\n      *\n-     * @param sequenceNumber The {@link ServiceBusReceivedMessage#getSequenceNumber()}.\n+     * @param maxMessages The number of messages.\n      *\n-     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     * @return A {@link Flux} of {@link ServiceBusReceivedMessage messages} that are peeked.\n+     * @throws IllegalArgumentException if {@code maxMessages} is not a positive integer.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n      */\n-    public Mono<ServiceBusReceivedMessage> receiveDeferredMessage(long sequenceNumber) {\n+    public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages) {\n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n-            .flatMap(node -> node.receiveDeferredMessage(receiveMode, sequenceNumber));\n+            .flatMapMany(node -> node.peekBatch(maxMessages));\n     }\n \n     /**\n-     * Reads the next active message without changing the state of the receiver or the message source. The first call to\n-     * {@code peek()} fetches the first active message for this receiver. Each subsequent call fetches the subsequent\n-     * message in the entity.\n+     * Starting from the given sequence number, reads the next batch of active messages without changing the state of\n+     * the receiver or the message source.\n      *\n-     * @return Single {@link ServiceBusReceivedMessage} peeked.\n+     * @param maxMessages The number of messages.\n+     * @param fromSequenceNumber The sequence number from where to start reading messages.\n+     *\n+     * @return A {@link Flux} of {@link ServiceBusReceivedMessage} peeked.\n+     * @throws IllegalArgumentException if {@code maxMessages} is not a positive integer.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n      */\n-    public Mono<ServiceBusReceivedMessage> peek() {\n+    public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages, long fromSequenceNumber) {", "originalCommit": "abea9f25f3e24b9ccdf42851cf93065b1fc8e9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "831f2be836cf6f15804b3c23bf42f31d0f3ddc83", "url": "https://github.com/Azure/azure-sdk-for-java/commit/831f2be836cf6f15804b3c23bf42f31d0f3ddc83", "message": "Fixing method names.", "committedDate": "2020-03-26T22:59:54Z", "type": "commit"}, {"oid": "f1a05e82948eb1ed703f10ee1f780c16a232c280", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f1a05e82948eb1ed703f10ee1f780c16a232c280", "message": "Fixing checkstyle issues.", "committedDate": "2020-03-27T04:34:01Z", "type": "commit"}]}