{"pr_number": 18027, "pr_title": "Updates RetryUtil to use RetrySpec. Adds log information on expiration.", "pr_createdAt": "2020-12-08T22:26:26Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/18027", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NDczNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538854734", "bodyText": "can we remove this?", "author": "conniey", "createdAt": "2020-12-08T22:26:45Z", "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -177,6 +177,7 @@ com.microsoft:microsoft-opentelemetry-exporter-azuremonitor;1.0.0-beta.1;1.0.0-b\n # unreleased_<groupId>:<artifactId>;dependency-version\n # note: The unreleased dependencies will not be manipulated with the automatic PR creation code.\n unreleased_com.azure:azure-messaging-servicebus;7.0.0", "originalCommit": "a58e16ccb09a3ae41599349f1494329a63a4c5e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NjM3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538856377", "bodyText": "We should as this has been released", "author": "alzimmermsft", "createdAt": "2020-12-08T22:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NDczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1ODgwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538858808", "bodyText": "This change is happening because we want to run the connectionMono and activeEndpointState publishers concurrently?", "author": "alzimmermsft", "createdAt": "2020-12-08T22:34:04Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -138,12 +138,11 @@ public ReactorConnection(String connectionId, ConnectionOptions connectionOption\n                 \"connectionId[%s]: Connection is disposed. Cannot get CBS node.\", connectionId))));\n         }\n \n-        final Mono<ClaimsBasedSecurityNode> cbsNodeMono =\n-            RetryUtil.withRetry(getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE),\n-                connectionOptions.getRetry().getTryTimeout(), retryPolicy)\n-            .then(Mono.fromCallable(this::getOrCreateCBSNode));\n+        final Flux<AmqpEndpointState> activeEndpointState = RetryUtil.withRetry(\n+            getEndpointStates().takeUntil(x -> x == AmqpEndpointState.ACTIVE), connectionOptions.getRetry(),\n+            \"ReactorConnection: Retries exhausted waiting for ACTIVE endpoint state on CBS node.\");\n \n-        return connectionMono.then(cbsNodeMono);\n+        return Mono.when(connectionMono, activeEndpointState).then(Mono.fromCallable(() -> getOrCreateCBSNode()));", "originalCommit": "a58e16ccb09a3ae41599349f1494329a63a4c5e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjExMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r539526112", "bodyText": "Yes. It is. When I first wrote this code, I thought it had to sequential but it doesn't. :)", "author": "conniey", "createdAt": "2020-12-09T17:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1ODgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MTAxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538861014", "bodyText": "Is this needed? Looks like we are just assigning a constant to a local constant", "author": "alzimmermsft", "createdAt": "2020-12-08T22:38:10Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -228,108 +228,25 @@ public boolean removeLink(String linkName) {\n             return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n                 \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n         }\n-        TransactionCoordinator existing = transactionCoordinator.get();\n+\n+        final TransactionCoordinator existing = transactionCoordinator.get();\n         if (existing != null) {\n             logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n             return Mono.just(existing);\n         }\n \n-        return createCoordinatorSendLink(openTimeout, retryPolicy)\n-            .map(sendLink -> {\n-                TransactionCoordinator newCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+        final String linkName = TRANSACTION_LINK_NAME;", "originalCommit": "a58e16ccb09a3ae41599349f1494329a63a4c5e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538863162", "bodyText": "I've been seeing this pattern in a lot of locations, do we want to centralize it anywhere?", "author": "alzimmermsft", "createdAt": "2020-12-08T22:42:27Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -563,6 +507,30 @@ protected ReactorReceiver createConsumer(String entityPath, Receiver receiver,\n         return new LinkSubscription<>(reactorReceiver, subscription);\n     }\n \n+    /**\n+     * Asynchronously waits for the session's active endpoint state.\n+     *\n+     * @return A mono that completes when the session is active.\n+     */\n+    private Mono<Void> onActiveEndpoint() {\n+        return RetryUtil.withRetry(getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE),", "originalCommit": "a58e16ccb09a3ae41599349f1494329a63a4c5e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjM0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r539526340", "bodyText": "I don't think this is required to be centralised.", "author": "conniey", "createdAt": "2020-12-09T18:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NDE5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538864194", "bodyText": "Does the AMQP response contain any information on backoff when the server is busy and this is a best approximation default?", "author": "alzimmermsft", "createdAt": "2020-12-08T22:44:32Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -22,6 +22,10 @@\n  * Helper class to help with retry policies.\n  */\n public class RetryUtil {\n+    private static final double JITTER_FACTOR = 0.08;\n+    // Base sleep wait time.\n+    private static final Duration SERVER_BUSY_WAIT_TIME = Duration.ofSeconds(4);", "originalCommit": "a58e16ccb09a3ae41599349f1494329a63a4c5e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc3ODE4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564778189", "bodyText": "Yes", "author": "conniey", "createdAt": "2021-01-26T19:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NDE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NTE2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538865167", "bodyText": "When there is no delay we won't attempt retries? Would we want this instead?\nreturn Retry.max(options.getMaxRetries());", "author": "alzimmermsft", "createdAt": "2020-12-08T22:46:29Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,52 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    private static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {\n+            return Retry.max(0L);", "originalCommit": "a58e16ccb09a3ae41599349f1494329a63a4c5e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNTc0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r539635744", "bodyText": "Yes, that is already covered in general. But part of the existing logic was if the Duration was 0, we'd also not try again.", "author": "conniey", "createdAt": "2020-12-09T20:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2NjU4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r538866581", "bodyText": "nit: Mind adding parentheses around the && block for easier reading", "author": "alzimmermsft", "createdAt": "2020-12-08T22:49:05Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,52 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout()).retryWhen(createRetry(retryOptions))\n+            .doOnError(TimeoutException.class, error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    private static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {\n+            return Retry.max(0L);\n+        }\n \n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else {\n-                    LOGGER.warning(\"Error is not a TimeoutException nor is it a retryable AMQP exception.\", error);\n+        final Duration delay = options.getDelay().plus(SERVER_BUSY_WAIT_TIME);\n+        final RetryBackoffSpec retrySpec;\n+        switch (options.getMode()) {\n+            case FIXED:\n+                retrySpec = Retry.fixedDelay(options.getMaxRetries(), delay);\n+                break;\n+            case EXPONENTIAL:\n+                retrySpec = Retry.backoff(options.getMaxRetries(), delay);\n+                break;\n+            default:\n+                LOGGER.warning(\"Unknown: '{}'. Using exponential delay. Delay: {}. Max Delay: {}. Max Retries: {}.\",\n+                    options.getMode(), options.getDelay(), options.getMaxDelay(), options.getMaxRetries());\n+                retrySpec = Retry.backoff(options.getMaxRetries(), delay);\n+                break;\n+        }\n \n-                    throw Exceptions.propagate(error);\n-                }\n-            })\n-            .flatMap(Mono::delay);\n+        return retrySpec.jitter(JITTER_FACTOR)\n+            .maxBackoff(options.getMaxDelay())\n+            .filter(error -> error instanceof TimeoutException\n+                || error instanceof AmqpException && ((AmqpException) error).isTransient());", "originalCommit": "a58e16ccb09a3ae41599349f1494329a63a4c5e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de9b2a9f8d5978040e3fa40a78cfbc112aadfbc8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/de9b2a9f8d5978040e3fa40a78cfbc112aadfbc8", "message": "(WIP)", "committedDate": "2021-01-20T20:25:00Z", "type": "commit"}, {"oid": "2cf3cc825466edbd2a9e9df4c3ecbb22f793f01d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2cf3cc825466edbd2a9e9df4c3ecbb22f793f01d", "message": "Change from protected to public.", "committedDate": "2021-01-20T20:25:01Z", "type": "commit"}, {"oid": "b81bfb01b239a70fcec6b7af9cc6df25af7203ba", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b81bfb01b239a70fcec6b7af9cc6df25af7203ba", "message": "Aggregate new RetryUtil to use RetrySpec.", "committedDate": "2021-01-20T20:25:01Z", "type": "commit"}, {"oid": "a2d98fa067ea503062f31610b4eca9f99eca5cc1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a2d98fa067ea503062f31610b4eca9f99eca5cc1", "message": "Fixing test break.", "committedDate": "2021-01-20T20:25:02Z", "type": "commit"}, {"oid": "c891b088cdf7cbb0f2716617125f6d0044e218c1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c891b088cdf7cbb0f2716617125f6d0044e218c1", "message": "Fixing test failures.", "committedDate": "2021-01-20T20:25:03Z", "type": "commit"}, {"oid": "fa3e1476848359424ead3030bb3ec959b001decf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fa3e1476848359424ead3030bb3ec959b001decf", "message": "Fixing checkstyle issues.", "committedDate": "2021-01-20T20:25:03Z", "type": "commit"}, {"oid": "4ad0707884986e8f39a18136971d5052247e5d57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4ad0707884986e8f39a18136971d5052247e5d57", "message": "Add amqp as unreleased dependency", "committedDate": "2021-01-20T20:28:05Z", "type": "commit"}, {"oid": "c08a4de2a1bc860ac5baddef038165f883f505e7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c08a4de2a1bc860ac5baddef038165f883f505e7", "message": "Fixing build break in Event Hubs.", "committedDate": "2021-01-20T20:28:08Z", "type": "commit"}, {"oid": "6a8fec3361ce38efbbf57f63145ede493c45d0b7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6a8fec3361ce38efbbf57f63145ede493c45d0b7", "message": "Fix build breaks in ReactorConnection.", "committedDate": "2021-01-20T20:28:08Z", "type": "commit"}, {"oid": "cd84c225ae55563b7f9b22a019b086e7766645e6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cd84c225ae55563b7f9b22a019b086e7766645e6", "message": "Move log message.", "committedDate": "2021-01-20T20:28:09Z", "type": "commit"}, {"oid": "7d126e63bf614ba69a71673151eef29feba6f307", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7d126e63bf614ba69a71673151eef29feba6f307", "message": "Fix log messages", "committedDate": "2021-01-20T20:28:10Z", "type": "commit"}, {"oid": "80aab863d919374080a1794e8df9885020569c5e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/80aab863d919374080a1794e8df9885020569c5e", "message": "Removing link name.", "committedDate": "2021-01-20T20:28:11Z", "type": "commit"}, {"oid": "a4000df77f20934aa7aeaf6e09f6a8e73654caf9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a4000df77f20934aa7aeaf6e09f6a8e73654caf9", "message": "Fixing test issues.", "committedDate": "2021-01-20T20:28:11Z", "type": "commit"}, {"oid": "a4000df77f20934aa7aeaf6e09f6a8e73654caf9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a4000df77f20934aa7aeaf6e09f6a8e73654caf9", "message": "Fixing test issues.", "committedDate": "2021-01-20T20:28:11Z", "type": "forcePushed"}, {"oid": "27082f78f3f8b59ec598d0f239cdc131a2c2b18c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/27082f78f3f8b59ec598d0f239cdc131a2c2b18c", "message": "Adding more tests to retryUtil", "committedDate": "2021-01-21T01:10:32Z", "type": "commit"}, {"oid": "8292774c80d796263b40073e503883181c41270b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8292774c80d796263b40073e503883181c41270b", "message": "(WIP)", "committedDate": "2021-01-23T16:28:16Z", "type": "commit"}, {"oid": "8fa0dff105e0dffc6e951bc4b873102dc8078b37", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8fa0dff105e0dffc6e951bc4b873102dc8078b37", "message": "Fix tests.", "committedDate": "2021-01-26T19:26:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4MTc3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564781776", "bodyText": "Would changing this to a Mono.error return be a breaking change? Or does something further up the stack handle converting this into a Mono.error?", "author": "alzimmermsft", "createdAt": "2021-01-26T19:38:57Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java", "diffHunk": "@@ -155,7 +162,8 @@ protected RequestResponseChannel(String connectionId, String fullyQualifiedNames\n                 receiveLink.open();\n             });\n         } catch (IOException e) {\n-            throw logger.logExceptionAsError(new RuntimeException(\"Unable to open send and receive link.\", e));\n+            throw logger.logExceptionAsError(new RuntimeException(String.format(", "originalCommit": "8fa0dff105e0dffc6e951bc4b873102dc8078b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgxOTg1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564819859", "bodyText": "This occurs in the constructor for RequestResponseChannel. It wouldn't be able to return a Mono.error.", "author": "conniey", "createdAt": "2021-01-26T20:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4MTc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564788190", "bodyText": "This is for a larger discussion\nShould we guard timeouts on timeout periods that are zero or negative? Timeout schedules a task on the parallel scheduler by default to propagate an exception if it runs before an emission is made from the reactive stream. From this could an instantly scheduled exception operation result in side affect/unexpected behavior?\ncc: @srnagar @JonathanGiles", "author": "alzimmermsft", "createdAt": "2021-01-26T19:49:50Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,54 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())", "originalCommit": "8fa0dff105e0dffc6e951bc4b873102dc8078b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgwNzYwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564807603", "bodyText": "Timeout periods that are zero or negative are invalid inputs and should be validated when it's set. If the timeout is null then we should use a default (if applicable) or never timeout.", "author": "srnagar", "createdAt": "2021-01-26T20:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyNTQ1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564825457", "bodyText": "In our existing logic for AmqpRetryOptions, if the duration is zero, then we don't retry at all. But negative is invalid.", "author": "conniey", "createdAt": "2021-01-26T20:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc4ODk2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r564788968", "bodyText": "Based on the previous topic of no delay or zero delay resulting in no retrying, should we also check if the delay is negative?", "author": "alzimmermsft", "createdAt": "2021-01-26T19:51:07Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetryUtil.java", "diffHunk": "@@ -51,51 +56,54 @@ public static AmqpRetryPolicy getRetryPolicy(AmqpRetryOptions options) {\n      * Given a {@link Flux} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Flux<T> withRetry(Flux<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Flux.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Flux<T> withRetry(Flux<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())\n+            .retryWhen(createRetry(retryOptions))\n+            .doOnError(error -> LOGGER.error(timeoutMessage, error));\n     }\n \n     /**\n      * Given a {@link Mono} will apply the retry policy to it when the operation times out.\n      *\n      * @param source The publisher to apply the retry policy to.\n+     *\n      * @return A publisher that returns the results of the {@link Flux} if any of the retry attempts are successful.\n-     *         Otherwise, propagates a {@link TimeoutException}.\n+     *     Otherwise, propagates a {@link TimeoutException}.\n      */\n-    public static <T> Mono<T> withRetry(Mono<T> source, Duration operationTimeout, AmqpRetryPolicy retryPolicy) {\n-        return Mono.defer(() -> source.timeout(operationTimeout))\n-            .retryWhen(Retry.withThrowable(errors -> retry(errors, retryPolicy)));\n+    public static <T> Mono<T> withRetry(Mono<T> source, AmqpRetryOptions retryOptions, String timeoutMessage) {\n+        return source.timeout(retryOptions.getTryTimeout())\n+            .retryWhen(createRetry(retryOptions))\n+            .doOnError(error -> LOGGER.error(timeoutMessage, error));\n     }\n \n-    private static Flux<Long> retry(Flux<Throwable> source, AmqpRetryPolicy retryPolicy) {\n-        return source.zipWith(Flux.range(1, retryPolicy.getMaxRetries() + 1),\n-            (error, attempt) -> {\n-                if (attempt > retryPolicy.getMaxRetries()) {\n-                    LOGGER.warning(\"Retry attempts are exhausted. Current: {}. Max: {}.\", attempt,\n-                        retryPolicy.getMaxRetries());\n-                    throw Exceptions.propagate(error);\n-                }\n-\n-                if (error instanceof TimeoutException) {\n-                    LOGGER.info(\"TimeoutException error occurred. Retrying operation. Attempt: {}.\",\n-                        attempt, error);\n-\n-                    return retryPolicy.calculateRetryDelay(error, attempt);\n-                } else if (error instanceof AmqpException && (((AmqpException) error).isTransient())) {\n-                    LOGGER.info(\"Retryable error occurred. Retrying operation. Attempt: {}. Error condition: {}\",\n-                        attempt, ((AmqpException) error).getErrorCondition(), error);\n+    static Retry createRetry(AmqpRetryOptions options) {\n+        if (options.getDelay() == null || options.getDelay().equals(Duration.ZERO)) {", "originalCommit": "8fa0dff105e0dffc6e951bc4b873102dc8078b37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8dcaac203e2c282f8547b29a71d9eca68ff33e9e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8dcaac203e2c282f8547b29a71d9eca68ff33e9e", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into try-attempt-i", "committedDate": "2021-01-26T21:32:00Z", "type": "commit"}, {"oid": "5414c94deef7b762368e7131c4cafe3206741f69", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5414c94deef7b762368e7131c4cafe3206741f69", "message": "Add checks for null or zero durations.", "committedDate": "2021-01-28T22:41:51Z", "type": "commit"}, {"oid": "fe158467883cc0522227f9a0095f71cb5ea72eed", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe158467883cc0522227f9a0095f71cb5ea72eed", "message": "Adding more tests for retry.", "committedDate": "2021-01-28T23:02:55Z", "type": "commit"}, {"oid": "2595a4bebdbac99d4d0fa47d55d4280707a37495", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2595a4bebdbac99d4d0fa47d55d4280707a37495", "message": "Adding opens for testing and cleaning up imports.", "committedDate": "2021-01-28T23:47:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ4NjczOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566486739", "bodyText": "Removing duplicated code for creating a transaction link.", "author": "conniey", "createdAt": "2021-01-28T23:53:05Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -228,108 +228,25 @@ public boolean removeLink(String linkName) {\n             return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n                 \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n         }\n-        TransactionCoordinator existing = transactionCoordinator.get();\n+\n+        final TransactionCoordinator existing = transactionCoordinator.get();\n         if (existing != null) {\n             logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n             return Mono.just(existing);\n         }\n \n-        return createCoordinatorSendLink(openTimeout, retryPolicy)\n-            .map(sendLink -> {\n-                TransactionCoordinator newCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+        return createProducer(TRANSACTION_LINK_NAME, TRANSACTION_LINK_NAME, new Coordinator(), retryOptions, null,\n+            false)\n+            .map(link -> {\n+                final TransactionCoordinator newCoordinator = new TransactionCoordinator(link, messageSerializer);\n                 if (transactionCoordinator.compareAndSet(null, newCoordinator)) {\n-                    logger.info(\"Coordinator[{}]: Created transaction coordinator.\", TRANSACTION_LINK_NAME);\n+                    return newCoordinator;\n                 } else {\n-                    logger.info(\"linkName[{}]: Another transaction coordinator exists.\", TRANSACTION_LINK_NAME);\n+                    return transactionCoordinator.get();\n                 }\n-                return transactionCoordinator.get();\n             });\n     }\n ", "originalCommit": "2595a4bebdbac99d4d0fa47d55d4280707a37495", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9e56fbb88dbfa5c363b95987b1299c8587c5555", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a9e56fbb88dbfa5c363b95987b1299c8587c5555", "message": "Adding opens", "committedDate": "2021-01-29T00:29:01Z", "type": "forcePushed"}, {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1b1a249a4b42a1da111dcc94264be5372d02226e", "message": "Removing opens. Fixing visibility.", "committedDate": "2021-01-29T00:39:23Z", "type": "commit"}, {"oid": "1b1a249a4b42a1da111dcc94264be5372d02226e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1b1a249a4b42a1da111dcc94264be5372d02226e", "message": "Removing opens. Fixing visibility.", "committedDate": "2021-01-29T00:39:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUwNTc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566505777", "bodyText": "Check for isZero() as well and update the javadoc, error message.", "author": "srnagar", "createdAt": "2021-01-29T00:47:07Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpRetryOptions.java", "diffHunk": "@@ -72,8 +82,15 @@ public AmqpRetryOptions setMaxRetries(int numberOfRetries) {\n      *\n      * @param delay The delay between retry attempts.\n      * @return The updated {@link AmqpRetryOptions} object.\n+     * @throws NullPointerException When {@code delay} is null.\n+     * @throws IllegalArgumentException When {@code delay} is negative.\n      */\n     public AmqpRetryOptions setDelay(Duration delay) {\n+        Objects.requireNonNull(delay, \"'delay' cannot be null.\");\n+        if (delay.isNegative()) {", "originalCommit": "1b1a249a4b42a1da111dcc94264be5372d02226e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUwNTkwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566505908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws IllegalArgumentException When {@code maximumDelay} is negative.\n          \n          \n            \n                 * @throws IllegalArgumentException When {@code maximumDelay} is negative or zero.", "author": "srnagar", "createdAt": "2021-01-29T00:47:30Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpRetryOptions.java", "diffHunk": "@@ -94,8 +119,16 @@ public AmqpRetryOptions setMaxDelay(Duration maximumDelay) {\n      *\n      * @param tryTimeout The maximum duration to wait for completion.\n      * @return The updated {@link AmqpRetryOptions} object.\n+     *\n+     * @throws NullPointerException When {@code maximumDelay} is null.\n+     * @throws IllegalArgumentException When {@code maximumDelay} is negative.", "originalCommit": "1b1a249a4b42a1da111dcc94264be5372d02226e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUxMDY3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566510675", "bodyText": "Log at debug level instead of deleting this.", "author": "srnagar", "createdAt": "2021-01-29T01:01:15Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AzureTokenManagerProvider.java", "diffHunk": "@@ -46,8 +46,6 @@ public AzureTokenManagerProvider(CbsAuthorizationType authorizationType, String\n     public TokenManager getTokenManager(Mono<ClaimsBasedSecurityNode> cbsNodeMono, String resource) {\n         final String scopes = getScopesFromResource(resource);\n         final String tokenAudience = String.format(Locale.US, TOKEN_AUDIENCE_FORMAT, fullyQualifiedNamespace, resource);\n-\n-        logger.info(\"Creating new token manager for audience[{}], resource[{}]\", tokenAudience, resource);", "originalCommit": "1b1a249a4b42a1da111dcc94264be5372d02226e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUxMzM1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r566513351", "bodyText": "So, we no longer need retries for this?", "author": "srnagar", "createdAt": "2021-01-29T01:09:03Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -368,34 +285,32 @@ public boolean removeLink(String linkName) {\n         }\n \n         final TokenManager tokenManager = tokenManagerProvider.getTokenManager(cbsNodeSupplier, entityPath);\n-        return RetryUtil.withRetry(\n-            getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE), timeout, retry)\n-            .then(tokenManager.authorize().then(Mono.create(sink -> {\n-                try {\n-                    // This has to be executed using reactor dispatcher because it's possible to run into race\n-                    // conditions with proton-j.\n-                    provider.getReactorDispatcher().invoke(() -> {\n-                        final LinkSubscription<AmqpReceiveLink> computed = openReceiveLinks.compute(linkName,\n-                            (linkNameKey, existing) -> {\n-                                if (existing != null) {\n-                                    logger.info(\"linkName[{}]: Another receive link exists. Disposing of new one.\",\n-                                        linkName);\n-                                    tokenManager.close();\n-\n-                                    return existing;\n-                                }\n-\n-                                logger.info(\"Creating a new receiver link with linkName {}\", linkName);\n-                                return getSubscription(linkNameKey, entityPath, sourceFilters, receiverProperties,\n-                                    receiverDesiredCapabilities, senderSettleMode, receiverSettleMode, tokenManager);\n-                            });\n-\n-                        sink.success(computed.getLink());\n-                    });\n-                } catch (IOException e) {\n-                    sink.error(e);\n-                }\n-            })));\n+        return Mono.when(onActiveEndpoint(), tokenManager.authorize()).then(Mono.create(sink -> {", "originalCommit": "1b1a249a4b42a1da111dcc94264be5372d02226e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODA3MzY1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18027#discussion_r568073659", "bodyText": "The onActiveEndpoint() method uses retries.", "author": "conniey", "createdAt": "2021-02-01T19:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUxMzM1MQ=="}], "type": "inlineReview"}, {"oid": "ae273fecedec4cb4ee763b9ca0f9b1908d5ccd15", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae273fecedec4cb4ee763b9ca0f9b1908d5ccd15", "message": "Updating code based on feedback.", "committedDate": "2021-02-01T19:13:26Z", "type": "commit"}, {"oid": "015749a1973e92c422e94f011fd5d66402994980", "url": "https://github.com/Azure/azure-sdk-for-java/commit/015749a1973e92c422e94f011fd5d66402994980", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into try-attempt-i", "committedDate": "2021-02-01T19:18:13Z", "type": "commit"}]}