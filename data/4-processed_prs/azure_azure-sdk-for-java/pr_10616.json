{"pr_number": 10616, "pr_title": "Direct TCP | Address socket leak", "pr_createdAt": "2020-04-30T02:57:25Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10616", "timeline": [{"oid": "84a37ab329525ae52d7c1adc6e7ba3c33625c5c7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/84a37ab329525ae52d7c1adc6e7ba3c33625c5c7", "message": "Port from v4", "committedDate": "2019-11-07T04:36:56Z", "type": "commit"}, {"oid": "d218925e1dff21266697a27e4271d34dfcc3b6a7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d218925e1dff21266697a27e4271d34dfcc3b6a7", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2019-11-08T01:46:09Z", "type": "commit"}, {"oid": "11cbbf37bf63bf50e94f67fe30300ac39c72ed4f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/11cbbf37bf63bf50e94f67fe30300ac39c72ed4f", "message": "Merge branch 'master' of github.com:David-Noble-at-work/azure-sdk-for-java", "committedDate": "2019-11-08T03:20:35Z", "type": "commit"}, {"oid": "05c7e0551ffb6fd1ed80c15d1068cb32e734007e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/05c7e0551ffb6fd1ed80c15d1068cb32e734007e", "message": "Corrected package misspelling in log4j.properties and removed System.exit from Main.java", "committedDate": "2019-11-09T00:07:30Z", "type": "commit"}, {"oid": "8dfa3dbf03ae2addeddcb34ffc67c362670a164c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8dfa3dbf03ae2addeddcb34ffc67c362670a164c", "message": "Merge branch 'master' of github.com:David-Noble-at-work/azure-sdk-for-java", "committedDate": "2019-11-09T00:07:47Z", "type": "commit"}, {"oid": "e6e71f5e6b292cac17b6a9687d04ad858f02a8a1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e6e71f5e6b292cac17b6a9687d04ad858f02a8a1", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2019-11-09T18:42:20Z", "type": "commit"}, {"oid": "e082d817a13d64ed57e5243cbc1da5b4ef0ab58e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e082d817a13d64ed57e5243cbc1da5b4ef0ab58e", "message": "Merge branch 'master' of github.com:David-Noble-at-work/azure-sdk-for-java", "committedDate": "2019-11-17T00:51:11Z", "type": "commit"}, {"oid": "069c822e997087f384cf1a1864e7efec331e69f8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/069c822e997087f384cf1a1864e7efec331e69f8", "message": "Merge branch 'master' of github.com:David-Noble-at-work/azure-sdk-for-java", "committedDate": "2019-11-23T22:36:47Z", "type": "commit"}, {"oid": "3ead1cca230e56b61e5376e73bd1481f7a7b81e6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ead1cca230e56b61e5376e73bd1481f7a7b81e6", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2019-12-03T18:58:37Z", "type": "commit"}, {"oid": "669ba8b28ed6ae321fda445e0e167ff027cc6481", "url": "https://github.com/Azure/azure-sdk-for-java/commit/669ba8b28ed6ae321fda445e0e167ff027cc6481", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2019-12-04T19:34:26Z", "type": "commit"}, {"oid": "735f57269d45a3497a66d47d594b7efac88179ff", "url": "https://github.com/Azure/azure-sdk-for-java/commit/735f57269d45a3497a66d47d594b7efac88179ff", "message": "Responded to code review comments", "committedDate": "2019-12-04T19:36:31Z", "type": "commit"}, {"oid": "6db330d843c4cdbb80b90c6f734f69a59afb9183", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6db330d843c4cdbb80b90c6f734f69a59afb9183", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2020-01-04T00:31:23Z", "type": "commit"}, {"oid": "48855b55564f6f216ee6a156f7a64ff5991ee2e6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/48855b55564f6f216ee6a156f7a64ff5991ee2e6", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2020-01-04T02:07:38Z", "type": "commit"}, {"oid": "2367f50dd69e8f4d1ba123c3b42ad4388caeaa66", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2367f50dd69e8f4d1ba123c3b42ad4388caeaa66", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2020-01-17T20:51:14Z", "type": "commit"}, {"oid": "fb9cac0c12e21f09e3c45580bf324bef7733b8c1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb9cac0c12e21f09e3c45580bf324bef7733b8c1", "message": "Updated sdk/cosmos/README.md with info on using system properties to modify default Direct TCP options", "committedDate": "2020-01-23T01:18:46Z", "type": "commit"}, {"oid": "1dd708ef9e753607040a6bb1f2b69c863dda8a0a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1dd708ef9e753607040a6bb1f2b69c863dda8a0a", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2020-01-23T01:21:11Z", "type": "commit"}, {"oid": "203507a249705593b04dec3e36566537d15da4e2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/203507a249705593b04dec3e36566537d15da4e2", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2020-03-16T00:12:48Z", "type": "commit"}, {"oid": "368b10f9893cdf49e95545e8ae4ec5ff03450f60", "url": "https://github.com/Azure/azure-sdk-for-java/commit/368b10f9893cdf49e95545e8ae4ec5ff03450f60", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2020-03-16T17:10:04Z", "type": "commit"}, {"oid": "f7544aa31e210fe20d9939c26b17c9dbb4d7d72f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f7544aa31e210fe20d9939c26b17c9dbb4d7d72f", "message": "Ported memory leak from v2.6.X and bumped version number.", "committedDate": "2020-03-17T01:24:39Z", "type": "commit"}, {"oid": "4cd3a139255f258d20b3c56ce9d00462add02b2b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4cd3a139255f258d20b3c56ce9d00462add02b2b", "message": "Removed a file that was mistakenly committed", "committedDate": "2020-03-18T01:32:58Z", "type": "commit"}, {"oid": "8f58a9c7b813cc0f1d39071c8dd64e667681e2ec", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8f58a9c7b813cc0f1d39071c8dd64e667681e2ec", "message": "Space adjustments for readability", "committedDate": "2020-03-18T05:41:03Z", "type": "commit"}, {"oid": "49baa6abd3e5ee01571b05c776ef43ff6efe7620", "url": "https://github.com/Azure/azure-sdk-for-java/commit/49baa6abd3e5ee01571b05c776ef43ff6efe7620", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/memory-leak", "committedDate": "2020-03-19T00:30:26Z", "type": "commit"}, {"oid": "f70e844575c77ef9906cc109a44c06e1366a3ad5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f70e844575c77ef9906cc109a44c06e1366a3ad5", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-03-24T00:46:33Z", "type": "commit"}, {"oid": "163c66d1a858ade5c179488ee9b7fb9798147e03", "url": "https://github.com/Azure/azure-sdk-for-java/commit/163c66d1a858ade5c179488ee9b7fb9798147e03", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-03-26T02:47:43Z", "type": "commit"}, {"oid": "01a3661f189abc1cf6f582083bbba44126aa8719", "url": "https://github.com/Azure/azure-sdk-for-java/commit/01a3661f189abc1cf6f582083bbba44126aa8719", "message": "DCDocumentCrudTest passes. Performance, reliability, and scalability tuning/testing work remains.", "committedDate": "2020-04-05T01:57:34Z", "type": "commit"}, {"oid": "be7b3d88e28d214ed79d686bcd4349f00d0b3c7a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/be7b3d88e28d214ed79d686bcd4349f00d0b3c7a", "message": "Enabled channel acquisition timeout interval default: 100 ms\n\nVerified: direct tests pass modulo a mockito issue that breaks a number of direct tests. Root cause analysis on the mockito break is TBD.", "committedDate": "2020-04-07T04:54:30Z", "type": "commit"}, {"oid": "7446c7aa03a788401d61900188ebfb357c0fea00", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7446c7aa03a788401d61900188ebfb357c0fea00", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-04-08T00:34:05Z", "type": "commit"}, {"oid": "5f263570653c07bc9f077cae2307061ad0d286ac", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5f263570653c07bc9f077cae2307061ad0d286ac", "message": "Removed some newlines", "committedDate": "2020-04-08T22:37:00Z", "type": "commit"}, {"oid": "dfb2ba4826880e5152658bab479b34f5f490a5bd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dfb2ba4826880e5152658bab479b34f5f490a5bd", "message": "Added a newline at the end of file", "committedDate": "2020-04-08T22:37:31Z", "type": "commit"}, {"oid": "34baf33d1a8a05c4f04091b8ef963209f1ed949f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/34baf33d1a8a05c4f04091b8ef963209f1ed949f", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-04-08T22:37:58Z", "type": "commit"}, {"oid": "5d7bf22c9ec045ec56683dc94f5879de003fdf40", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5d7bf22c9ec045ec56683dc94f5879de003fdf40", "message": "Ensured that RntbdClientChannelPool.release never throws and never releases a channel prematurely. This change addresses occassional point read failures (~0.0015% of the time in local testing) when slamming a partition with read requests. This change also ensures that unhandled exceptions during release do not cause thread deaths.", "committedDate": "2020-04-11T20:56:20Z", "type": "commit"}, {"oid": "c5a8e7b75b7ff126eac016d28738f937951aa4a1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c5a8e7b75b7ff126eac016d28738f937951aa4a1", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-04-15T16:20:21Z", "type": "commit"}, {"oid": "05f141039211010d76a20a070dc864df979759b6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/05f141039211010d76a20a070dc864df979759b6", "message": "Revised channel acquisition algorithm such that no timer acquisition task timeout is used by default and we allow maxRequestsPerChannel to go above limit when maxChannels are allocated", "committedDate": "2020-04-16T00:26:34Z", "type": "commit"}, {"oid": "e767404f56822dab79896d35ff73e584b3e018f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e767404f56822dab79896d35ff73e584b3e018f1", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-04-18T20:26:30Z", "type": "commit"}, {"oid": "3425d0b8e13d32afcb8684f0d9d344509cd90007", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3425d0b8e13d32afcb8684f0d9d344509cd90007", "message": "Attempt to resolve scalability issue that causes performance degradation about about 500 concurrent requests", "committedDate": "2020-04-18T20:58:40Z", "type": "commit"}, {"oid": "f7a6cdad8597ff80a6209ecc37b093f4934eb2b2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f7a6cdad8597ff80a6209ecc37b093f4934eb2b2", "message": "Code/documentation tweaks", "committedDate": "2020-04-19T19:56:19Z", "type": "commit"}, {"oid": "0a04ad8bc10d8ad3a809ff52e7aac120147620a9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0a04ad8bc10d8ad3a809ff52e7aac120147620a9", "message": "Idle endpoint timeout task now detects idleEndpointTimeout and\u2014unless the endpoint is found to be idle\u2014runs tasks in the pendingAcquisitionQueue.", "committedDate": "2020-04-20T04:03:27Z", "type": "commit"}, {"oid": "fb81f3e7458759d7fadb237c71c2db4b0ae7f19d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb81f3e7458759d7fadb237c71c2db4b0ae7f19d", "message": "Updated a comment", "committedDate": "2020-04-20T04:09:56Z", "type": "commit"}, {"oid": "7f23efd6299bf6989eecc5dcbc1b9b14276e83ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7f23efd6299bf6989eecc5dcbc1b9b14276e83ca", "message": "Code tweak", "committedDate": "2020-04-20T05:57:42Z", "type": "commit"}, {"oid": "78f0e55d2001b90ba72450b6854c83ac3baba8e6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/78f0e55d2001b90ba72450b6854c83ac3baba8e6", "message": "Switch to HashedWheelTimer implementation for RntbdClientChannelPool.acquisitionAndIdleEndpointDetectionTimeout and revised RntbdClientChannelPool.acquireChannel. Local testing indicates that this significatnly reduces P95-P99.9 latencies", "committedDate": "2020-04-21T04:27:48Z", "type": "commit"}, {"oid": "12b5981b89ec39d52b45117e29835401358a5ba5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/12b5981b89ec39d52b45117e29835401358a5ba5", "message": "Tweaked log message", "committedDate": "2020-04-22T18:04:19Z", "type": "commit"}, {"oid": "e5ff54c36b6cc35e63cecaccc287abff95b202e0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e5ff54c36b6cc35e63cecaccc287abff95b202e0", "message": "Addressed a number of threading-related issues in RntbdClientChannelPool; tweaked the RntbdReporter; and added a CsvReporter feature to the benchmark tool. They latter may be a temporary addition", "committedDate": "2020-04-24T00:22:21Z", "type": "commit"}, {"oid": "fc7637be1cebb5f6a8b4df3395600996c9b50ca4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fc7637be1cebb5f6a8b4df3395600996c9b50ca4", "message": "Streamlined RntbdServiceEndpoint.write for performance/readability. In local testing this change resulted in a significant performance gain in these configurations:\n* concurrency=2048.documentCount=000001.operation=ReadLatency.operation-count=1000000\n* concurrency=2048.documentCount=100000.operation=ReadLatency.operation-count=1000000\nSpecificallly, the P99 values moved to P99.9 and throughput increased by at least 11% as measured by (lowest[with-change] - highest[sans-change]) / highest[sans-change])", "committedDate": "2020-04-25T20:23:13Z", "type": "commit"}, {"oid": "488291ed705a9cc6552b2326c794268e1785442f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/488291ed705a9cc6552b2326c794268e1785442f", "message": "Tweaks tested extensively--full test suite plus point read benchmarks (1 and 10,0000 documents with 2,048 concurrent requests) locally in prep for PR", "committedDate": "2020-04-28T15:11:38Z", "type": "commit"}, {"oid": "02293fc5c0952a9615a29a1992e08d87b461567a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/02293fc5c0952a9615a29a1992e08d87b461567a", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-04-28T15:15:58Z", "type": "commit"}, {"oid": "2375baab4d6b8dc533a38405294ed21fa247f648", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2375baab4d6b8dc533a38405294ed21fa247f648", "message": "Tweaked AsyncBenchmark for verifying the direct tcp \u201cconnection timeout\u201d issue raised by T-Mobile.", "committedDate": "2020-04-28T21:53:39Z", "type": "commit"}, {"oid": "46f5dd1bd9ebfac572044b3f2a104c6b37267103", "url": "https://github.com/Azure/azure-sdk-for-java/commit/46f5dd1bd9ebfac572044b3f2a104c6b37267103", "message": "Moved a misplaced statement in AsyncBenchmark that produced a lot of logger noise.", "committedDate": "2020-04-29T20:59:51Z", "type": "commit"}, {"oid": "3d0c00772d1c79f4b3ba82add514132660d5ae31", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d0c00772d1c79f4b3ba82add514132660d5ae31", "message": "Updated version numbers in an attempt to get past CI version checks", "committedDate": "2020-04-30T03:52:52Z", "type": "commit"}, {"oid": "fb7273bd375723f5a065eb0a511c8df935201245", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb7273bd375723f5a065eb0a511c8df935201245", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-04-30T03:54:21Z", "type": "commit"}, {"oid": "02d7ed00304e953d15119c35358bc2497e162a0a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/02d7ed00304e953d15119c35358bc2497e162a0a", "message": "Tweaked RntbdRequestTimer.close for readability", "committedDate": "2020-04-30T04:06:27Z", "type": "commit"}, {"oid": "44c7ea7ded34c1141e28fc8866326c296639d2b7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/44c7ea7ded34c1141e28fc8866326c296639d2b7", "message": "Removed README.md which seems to have been removed from master after being edited by me", "committedDate": "2020-04-30T05:32:22Z", "type": "commit"}, {"oid": "350db568ea82a310993c3d9f4860d7897ad50afc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/350db568ea82a310993c3d9f4860d7897ad50afc", "message": "Fixed a build issue that CI complains about.", "committedDate": "2020-04-30T06:09:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDk3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419484972", "bodyText": "@kushagraThapar\ncom.azure:azure-cosmos-examples and azure-cosmos-benchmark are in the process is being removed as libraries. Further, they're intentionally not part of the Artifacts cosmos' ci.yml which makes them incapable of being released (this was intentional as these are never supposed to be released). There is no version change necessary here and it should be reverted.", "author": "JimSuplizio", "createdAt": "2020-05-04T14:36:40Z", "path": "eng/versioning/version_client.txt", "diffHunk": "@@ -17,8 +17,8 @@ com.azure:azure-core-serializer-json-jackson;1.0.0-beta.1;1.0.0-beta.1\n com.azure:azure-core-test;1.2.0;1.3.0-beta.1\n com.azure:azure-core-tracing-opentelemetry;1.0.0-beta.4;1.0.0-beta.5\n com.azure:azure-cosmos;4.0.1-beta.2;4.0.1-beta.3\n-com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.1\n-com.azure:azure-cosmos-benchmark;4.0.1-beta.1;4.0.1-beta.1\n+com.azure:azure-cosmos-examples;4.0.1-beta.1;4.0.1-beta.3", "originalCommit": "350db568ea82a310993c3d9f4860d7897ad50afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1Njc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419556793", "bodyText": "@JimSuplizio - yes this is unintentional, should be reverted.\n@David-Noble-at-work - can we please revert the changes related to pom.xml ?", "author": "kushagraThapar", "createdAt": "2020-05-04T16:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MzkwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419753900", "bodyText": "@kushagraThapar @JimSuplizio yep", "author": "David-Noble-at-work", "createdAt": "2020-05-04T21:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDk3Mg=="}], "type": "inlineReview"}, {"oid": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "message": "Reverting version bump for benchmark and examples as these are in the process of being removed as libraries", "committedDate": "2020-05-04T22:17:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNTAyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420505020", "bodyText": "Nit : Though the error message should say \"Collection {} creation failed due to ... \" instead of Database :)", "author": "kushagraThapar", "createdAt": "2020-05-06T01:51:39Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -83,11 +88,18 @@\n         }\n \n         try {\n-            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(this.configuration.getCollectionId()).read().block().getContainer();\n+            cosmosAsyncContainer = cosmosAsyncDatabase.getContainer(\n+                this.configuration.getCollectionId()\n+            ).read().doOnError(error ->\n+                logger.error(\"Database {} creation failed due to \", this.configuration.getDatabaseId(), error)", "originalCommit": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxNDM2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424814366", "bodyText": "This one bothers me and I corrected it on my local branch. I would update the PR if the benchmark tool was shipping code.", "author": "David-Noble-at-work", "createdAt": "2020-05-14T01:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNTAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxNDk2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424814962", "bodyText": "And I updated the terminology. Collection is now container.", "author": "David-Noble-at-work", "createdAt": "2020-05-14T01:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjA4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506084", "bodyText": "Some dead code ?\nOr do you need it later ?", "author": "kushagraThapar", "createdAt": "2020-05-06T01:55:57Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -27,172 +34,253 @@\n import java.net.SocketAddress;\n import java.nio.channels.ClosedChannelException;\n import java.time.Duration;\n-import java.util.ArrayDeque;\n+import java.time.OffsetDateTime;\n+import java.util.Deque;\n import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.azure.cosmos.implementation.directconnectivity.rntbd.RntbdReporter.reportIssueUnless;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkState;\n+import static com.azure.cosmos.implementation.guava27.Strings.lenientFormat;\n \n /**\n- * {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections\n+ * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n  */\n @JsonSerialize(using = RntbdClientChannelPool.JsonSerializer.class)\n-public final class RntbdClientChannelPool extends SimpleChannelPool {\n+public final class RntbdClientChannelPool implements ChannelPool {\n \n     private static final TimeoutException ACQUISITION_TIMEOUT = ThrowableUtil.unknownStackTrace(\n-        new TimeoutException(\"Acquisition took longer than the configured maximum time\"),\n+        new TimeoutException(\"acquisition took longer than the configured maximum time\"),\n         RntbdClientChannelPool.class, \"<init>\");\n \n     private static final ClosedChannelException CHANNEL_CLOSED_ON_ACQUIRE = ThrowableUtil.unknownStackTrace(\n-        new ClosedChannelException(), RntbdClientChannelPool.class, \"acquire0(...)\");\n+        new ClosedChannelException(), RntbdClientChannelPool.class, \"acquire\");\n \n     private static final IllegalStateException POOL_CLOSED_ON_ACQUIRE = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"RntbdClientChannelPool was closed\"),\n-        RntbdClientChannelPool.class, \"acquire0\");\n+        new StacklessIllegalStateException(\"service endpoint was closed\"),\n+        RntbdClientChannelPool.class, \"acquire\");\n \n     private static final IllegalStateException POOL_CLOSED_ON_RELEASE = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"RntbdClientChannelPool was closed\"),\n+        new StacklessIllegalStateException(\"service endpoint was closed\"),\n         RntbdClientChannelPool.class, \"release\");\n \n+    private static final AttributeKey<RntbdClientChannelPool> POOL_KEY = AttributeKey.newInstance(\n+        RntbdClientChannelPool.class.getName());\n+\n     private static final IllegalStateException TOO_MANY_PENDING_ACQUISITIONS = ThrowableUtil.unknownStackTrace(\n-        new IllegalStateException(\"Too many outstanding acquire operations\"),\n-        RntbdClientChannelPool.class, \"acquire0\");\n+        new StacklessIllegalStateException(\"too many outstanding acquire operations\"),\n+        RntbdClientChannelPool.class, \"acquire\");\n+\n+    private static final EventExecutor closer = new DefaultEventExecutor(new RntbdThreadFactory(\n+        \"channel-pool-closer\",\n+        true,\n+        Thread.NORM_PRIORITY));\n+\n+    private static final HashedWheelTimer acquisitionAndIdleEndpointDetectionTimer =\n+        new HashedWheelTimer(new RntbdThreadFactory(\n+            \"channel-acquisition-timer\",\n+            true,\n+            Thread.NORM_PRIORITY));\n \n     private static final Logger logger = LoggerFactory.getLogger(RntbdClientChannelPool.class);\n \n-    private final long acquisitionTimeoutNanos;\n+    private final long acquisitionTimeoutInNanos;\n+    private final Runnable acquisitionTimeoutTask;\n     private final PooledByteBufAllocatorMetric allocatorMetric;\n+    private final Bootstrap bootstrap;\n     private final EventExecutor executor;\n-    private final ScheduledFuture<?> idleStateDetectionScheduledFuture;\n+    private final ChannelHealthChecker healthChecker;\n+    // private final ScheduledFuture<?> idleStateDetectionScheduledFuture;\n     private final int maxChannels;\n     private final int maxPendingAcquisitions;\n     private final int maxRequestsPerChannel;\n+    private final ChannelPoolHandler poolHandler;\n+    private final boolean releaseHealthCheck;\n \n-    // No need to worry about synchronization as everything that modified the queue or counts is done by this.executor\n-\n-    private final Queue<AcquireTask> pendingAcquisitionQueue = new ArrayDeque<AcquireTask>();\n-    private final Runnable acquisitionTimeoutTask;\n-\n-    // Because these values can be requested on any thread...\n+    // Because state from these fields can be requested on any thread...\n \n-    private final AtomicInteger acquiredChannelCount = new AtomicInteger();\n-    private final AtomicInteger availableChannelCount = new AtomicInteger();\n+    private final AtomicReference<Timeout> acquisitionAndIdleEndpointDetectionTimeout = new AtomicReference<>();\n+    private final ConcurrentHashMap<Channel, Channel> acquiredChannels = new ConcurrentHashMap<>();\n+    private final Deque<Channel> availableChannels = new ConcurrentLinkedDeque<>();\n     private final AtomicBoolean closed = new AtomicBoolean();\n+    private final AtomicBoolean connecting = new AtomicBoolean();\n+    private final Queue<AcquireTask> pendingAcquisitions = new ConcurrentLinkedQueue<>();\n \n     /**\n-     * Initializes a newly created {@link RntbdClientChannelPool} object\n-     *  @param bootstrap the\u00a0{@link Bootstrap} that is used for connections\n-     * @param config    the {@link Config} that is used for the channel pool instance created\n+     * Initializes a newly created {@link RntbdClientChannelPool} instance.\n+     *\n+     * @param bootstrap the\u00a0{@link Bootstrap} that is used for connections.\n+     * @param config the {@link Config} that is used for the channel pool instance created.\n      */\n     RntbdClientChannelPool(final RntbdServiceEndpoint endpoint, final Bootstrap bootstrap, final Config config) {\n         this(endpoint, bootstrap, config, new RntbdClientChannelHealthChecker(config));\n     }\n \n     private RntbdClientChannelPool(\n-        final RntbdServiceEndpoint endpoint, final Bootstrap bootstrap, final Config config,\n-        final RntbdClientChannelHealthChecker healthChecker\n-    ) {\n+        final RntbdServiceEndpoint endpoint,\n+        final Bootstrap bootstrap,\n+        final Config config,\n+        final RntbdClientChannelHealthChecker healthChecker) {\n \n-        super(bootstrap, new RntbdClientChannelHandler(config, healthChecker), healthChecker, true, true);\n+        checkNotNull(endpoint, \"expected non-null endpoint\");\n+        checkNotNull(bootstrap, \"expected non-null bootstrap\");\n+        checkNotNull(config, \"expected non-null config\");\n+        checkNotNull(healthChecker, \"expected non-null healthChecker\");\n \n-        this.allocatorMetric = config.allocator().metric();\n+        this.poolHandler = new RntbdClientChannelHandler(config, healthChecker);\n         this.executor = bootstrap.config().group().next();\n-        this.maxChannels = config.maxChannelsPerEndpoint();\n-        this.maxPendingAcquisitions = Integer.MAX_VALUE;\n-        this.maxRequestsPerChannel = config.maxRequestsPerChannel();\n-\n-        // TODO: DANOBLE: Add RntbdEndpoint.Config settings for acquisition timeout and acquisition timeout action\n-        //  Alternatively: drop acquisition timeout and acquisition timeout action\n-        //  Decision should be based on performance, reliability, and usability considerations\n+        this.healthChecker = healthChecker;\n \n-        final AcquisitionTimeoutAction acquisitionTimeoutAction = null;\n-        final long acquisitionTimeoutNanos = -1L;\n-\n-        if (acquisitionTimeoutAction == null) {\n-\n-            this.acquisitionTimeoutNanos = -1L;\n-            this.acquisitionTimeoutTask = null;\n-\n-        } else {\n-\n-            this.acquisitionTimeoutNanos = acquisitionTimeoutNanos;\n-\n-            switch (acquisitionTimeoutAction) {\n-                case FAIL:\n-                    this.acquisitionTimeoutTask = new AcquireTimeoutTask(this) {\n-                        @Override\n-                        public void onTimeout(AcquireTask task) {\n-                            task.promise.setFailure(ACQUISITION_TIMEOUT);\n-                        }\n-                    };\n-                    break;\n-                case NEW:\n-                    this.acquisitionTimeoutTask = new AcquireTimeoutTask(this) {\n-                        @Override\n-                        public void onTimeout(AcquireTask task) {\n-                            // Increment the acquire count and get a new Channel by delegating to super.acquire\n-                            task.acquired();\n-                            RntbdClientChannelPool.super.acquire(task.promise);\n-                        }\n-                    };\n-                    break;\n-                default:\n-                    throw new Error();\n+        this.bootstrap = bootstrap.clone().handler(new ChannelInitializer<Channel>() {\n+            @Override\n+            protected void initChannel(final Channel channel) throws Exception {\n+            checkState(channel.eventLoop().inEventLoop());\n+            RntbdClientChannelPool.this.poolHandler.channelCreated(channel);\n             }\n-        }\n-\n-        final long idleEndpointTimeout = config.idleEndpointTimeoutInNanos();\n-\n-        this.idleStateDetectionScheduledFuture = this.executor.scheduleAtFixedRate(\n-            () -> {\n-\n-                final long currentTime = System.nanoTime();\n-                final long lastRequestTime = endpoint.lastRequestTime();\n-                final long elapsedTime = currentTime - lastRequestTime;\n-\n-                if (elapsedTime > idleEndpointTimeout) {\n+        });\n \n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\n-                            \"{} closing due to inactivity (time elapsed since last request: {} > idleEndpointTimeout: {})\",\n-                            endpoint, Duration.ofNanos(elapsedTime), Duration.ofNanos(idleEndpointTimeout));\n-                    }\n+        // TODO (DANOBLE) Consider moving or removing this.allocatorMetric\n+        //  This metric is redundant in the scope of this class and should be pulled up to RntbdServiceEndpoint or\n+        //  entirely removed.\n \n-                    endpoint.close();\n-                }\n+        this.acquisitionTimeoutInNanos = config.connectionAcquisitionTimeoutInNanos();\n+        this.allocatorMetric = config.allocator().metric();\n+        this.maxChannels = config.maxChannelsPerEndpoint();\n+        this.maxRequestsPerChannel = config.maxRequestsPerChannel();\n \n-            }, idleEndpointTimeout, idleEndpointTimeout, TimeUnit.NANOSECONDS);\n+        this.maxPendingAcquisitions = Integer.MAX_VALUE;\n+        this.releaseHealthCheck = true;\n+\n+        this.acquisitionTimeoutTask = acquisitionTimeoutInNanos <= 0 ? null : new AcquireTimeoutTask(this) {\n+            /**\n+             * Fails a request due to a channel acquisition timeout.\n+             *\n+             * @param task a {@link AcquireTask channel acquisition task} that has timed out.\n+             */\n+            @Override\n+            public void onTimeout(AcquireTask task) {\n+                task.promise.setFailure(ACQUISITION_TIMEOUT);\n+            }\n+        };\n+\n+        newTimeout(endpoint, config.idleEndpointTimeoutInNanos(), config.requestTimerResolutionInNanos());\n+\n+//        this.idleStateDetectionScheduledFuture = this.executor.scheduleAtFixedRate(\n+//            () -> {\n+//                final long elapsedTimeInNanos = System.nanoTime() - endpoint.lastRequestNanoTime();\n+//\n+//                if (idleEndpointTimeoutInNanos - elapsedTimeInNanos <= 0) {\n+//                    if (logger.isDebugEnabled()) {\n+//                        logger.debug(\n+//                            \"{} closing endpoint due to inactivity (elapsedTime: {} > idleEndpointTimeout: {})\",\n+//                            endpoint,\n+//                            Duration.ofNanos(elapsedTimeInNanos),\n+//                            Duration.ofNanos(idleEndpointTimeoutInNanos));\n+//                    }\n+//                    endpoint.close();\n+//                    return;\n+//                }\n+//\n+//                this.runTasksInPendingAcquisitionQueue();\n+//\n+//            }, requestTimerResolutionInNanos, requestTimerResolutionInNanos, TimeUnit.NANOSECONDS);", "originalCommit": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMzg0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424813842", "bodyText": "Dead code that's now removed on my local branch. We'll get this in on my next PR which will wire up DirectConnectionConfig.", "author": "David-Noble-at-work", "createdAt": "2020-05-14T01:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjU5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506599", "bodyText": "Explanation required ?\nIf not, remove the check as per the comment :)", "author": "kushagraThapar", "createdAt": "2020-05-06T01:58:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -233,45 +349,87 @@ public boolean isClosed() {\n     public void close() {\n         if (this.closed.compareAndSet(false, true)) {\n             if (this.executor.inEventLoop()) {\n-                this.close0();\n+                this.doClose();\n             } else {\n-                this.executor.submit(this::close0).awaitUninterruptibly();\n+                this.executor.submit(this::doClose).awaitUninterruptibly(); // block until complete\n             }\n         }\n     }\n \n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     *\n+     * @return asynchronous result of the operation. If the operation fails, {@code channel} will be closed\n+     * automatically.\n+     */\n+    @Override\n+    public Future<Void> release(final Channel channel) {\n+        return this.release(channel, channel.eventLoop().newPromise());\n+    }\n+\n+    /**\n+     * Releases a {@link Channel channel} back to the current {@link RntbdClientChannelPool pool}.\n+     * <p>\n+     * TODO (DANOBLE) Javadoc for {@link RntbdClientChannelPool#release}.\n+     *\n+     * @param channel a {@link Channel channel} to release back to the  {@link RntbdClientChannelPool channel pool}.\n+     * @param promise a {@link Promise promise} to be notified once the release is successful; failed otherwise.\n+     *\n+     * @return a reference to {@code promise}. If the operation fails, {@code channel} will be closed automatically.\n+     */\n     @Override\n     public Future<Void> release(final Channel channel, final Promise<Void> promise) {\n \n         // We do not call this.throwIfClosed because a channel may be released back to the pool during close\n \n-        super.release(channel, this.executor.<Void>newPromise().addListener((FutureListener<Void>)future -> {\n+        checkNotNull(channel, \"expected non-null channel\");\n+        checkNotNull(promise, \"expected non-null promise\");\n \n-            checkState(this.executor.inEventLoop());\n+        Promise<Void> anotherPromise = this.executor.newPromise(); // ensures we finish in our executor's event loop\n+\n+        try {\n+            final EventLoop loop = channel.eventLoop();\n+            if (loop.inEventLoop()) {\n+                this.releaseChannel(channel, anotherPromise);\n+            } else {\n+                loop.execute(() -> this.releaseChannel(channel, anotherPromise));\n+            }\n+        } catch (Throwable cause) {\n+            if (this.executor.inEventLoop()) {\n+                this.closeChannelAndFail(channel, cause, anotherPromise);\n+            } else {\n+                this.executor.submit(() -> this.closeChannelAndFail(channel, cause, anotherPromise));\n+            }\n+        }\n+\n+        anotherPromise.addListener((FutureListener<Void>) future -> {\n+\n+            this.ensureValidRunState();\n \n             if (this.isClosed()) {\n-                // Since the pool is closed, we have no choice but to close the channel\n+                // We have no choice but to close the channel\n                 promise.setFailure(POOL_CLOSED_ON_RELEASE);\n-                channel.close();\n+                this.closeChannel(channel);\n                 return;\n             }\n \n             if (future.isSuccess()) {\n-\n-                this.decrementAndRunTaskQueue();\n+                this.runTasksInPendingAcquisitionQueue();\n                 promise.setSuccess(null);\n-\n             } else {\n-\n+                // TODO (DANOBLE) Is this check for an IllegalArgumentException required?\n+                //  Explain here, if so; otherwise remove the check.", "originalCommit": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMzUwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424813509", "bodyText": "I'd like to leave this in the code for now due to my uncertainty around why the netty devs put this into the base class from which RntbdClientChannelPool used to inherit.", "author": "David-Noble-at-work", "createdAt": "2020-05-14T01:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMzYyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424813623", "bodyText": "I made a note to remove it with my next PR.", "author": "David-Noble-at-work", "createdAt": "2020-05-14T01:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjc1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420506754", "bodyText": "Is this intended to have no message and only params / values ?", "author": "kushagraThapar", "createdAt": "2020-05-06T01:59:00Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -281,126 +439,286 @@ public String toString() {\n         return RntbdObjectMapper.toString(this);\n     }\n \n+    // endregion\n+\n+    // region Privates\n+\n     /**\n-     * Offer a {@link Channel} back to the internal storage\n+     * Acquires a serviceable channel from the {@link RntbdClientChannelPool pool}.\n      * <p>\n-     * Maintainers: Implementations of this method must be thread-safe.\n+     * This method acquires the first channel that's both available and serviceable in LIFO order. A new channel is\n+     * created and added to the pool if and only if:\n+     * <ul>\n+     * <li>fewer than {@link #maxChannels} channels have been created ({@link #channels} < {@link #maxChannels()}))\n+     * and</li>\n+     * <li>there are no acquired channels pending release ({@link #channelsAcquired} == 0).</li>\n+     * </ul>\n+     * Under load it is possible that:\n+     * <ul>\n+     * <li>no available channels are serviceable ({@link RntbdRequestManager#pendingRequestCount()} ==\n+     * {@link #maxChannels()})</li>\n+     * <li>there are acquired channels pending release, and</li>\n+     * <li>{@link #maxChannels} channels have been created.</li>\n+     * </ul>\n+     * Under these circumstances a request to acquire a channel will be satisfied by the\n+     * {@link #acquisitionTimeoutTask} which will:\n+     * <ul>\n+     * <li>process items in the {@link #pendingAcquisitions} on each call to {@link #acquire} or {@link #release},\n+     * and</li>\n+     * <li>each {@link #acquisitionTimeoutInNanos} nanoseconds\n+     * </ul>\n+     * until a channel is acquired.\n+     *\n+     * @param promise the promise of a {@link Channel channel}.\n      *\n-     * @param channel the {@link Channel} to return to internal storage\n-     * @return {@code true}, if the {@link Channel} could be added to internal storage; otherwise {@code false}\n+     * @see #isChannelServiceable(Channel)\n+     * @see AcquireTimeoutTask\n      */\n-    @Override\n-    protected boolean offerChannel(final Channel channel) {\n-        if (super.offerChannel(channel)) {\n-            this.availableChannelCount.incrementAndGet();\n-            return true;\n+    private void acquireChannel(final Promise<Channel> promise) {\n+\n+        this.ensureValidRunState();\n+\n+        if (this.isClosed()) {\n+            promise.setFailure(POOL_CLOSED_ON_ACQUIRE);\n+            return;\n+        }\n+\n+        try {\n+            Channel candidate = this.pollChannel();\n+\n+            if (candidate != null) {\n+\n+                // Fulfill this request with our candidate, assuming it's healthy\n+                // If our candidate is unhealthy, notifyChannelHealthCheck will call us again\n+\n+                doAcquireChannel(promise, candidate);\n+                return;\n+            }\n+\n+            final int channelCount = this.channels();\n+\n+            if (channelCount < this.maxChannels) {\n+\n+                if (this.connecting.compareAndSet(false, true)) {\n+\n+                    // Fulfill this request with a new channel, assuming we can connect one\n+                    // If our connection attempt fails, notifyChannelConnect will call us again\n+\n+                    final Promise<Channel> anotherPromise = this.newChannelPromise(promise);\n+                    final ChannelFuture future = this.bootstrap.clone().attr(POOL_KEY, this).connect();\n+\n+                    if (future.isDone()) {\n+                        this.notifyChannelConnect(future, anotherPromise);\n+                    } else {\n+                        future.addListener(ignored -> this.notifyChannelConnect(future, anotherPromise));\n+                    }\n+\n+                    return;\n+                }\n+\n+            } else if (this.computeLoadFactor() > 0.90D) {\n+\n+                // All channels are swamped and we'll pick the one with the lowest pending request count\n+\n+                long pendingRequestCountMin = Long.MAX_VALUE;\n+\n+                for (Channel channel : this.availableChannels) {\n+\n+                    final RntbdRequestManager manager = channel.pipeline().get(RntbdRequestManager.class);\n+                    final long pendingRequestCount = manager.pendingRequestCount();\n+\n+                    if (pendingRequestCount < pendingRequestCountMin) {\n+                        pendingRequestCountMin = pendingRequestCount;\n+                        candidate = channel;\n+                    }\n+                }\n+\n+                assert candidate != null;\n+\n+                this.availableChannels.remove(candidate);\n+                doAcquireChannel(promise, candidate);\n+\n+                return;\n+            }\n+\n+            this.addTaskToPendingAcquisitionQueue(promise);\n+\n+        } catch (Throwable cause) {\n+            promise.tryFailure(cause);\n         }\n-        return false;\n     }\n \n     /**\n-     * Poll a {@link Channel} out of internal storage to reuse it\n+     * Add a task to the pending acquisition queue to fulfill the request for a {@link Channel channel} later.\n      * <p>\n-     * Maintainers: Implementations of this method must be thread-safe and this type ensures thread safety by calling\n-     * this method serially on a single-threaded EventExecutor. As a result this method need not (and should not) be\n-     * synchronized.\n+     * Tasks in the pending acquisition queue are run whenever a channel is released. This ensures that pending requests\n+     * for channels are fulfilled as soon as possible.\n      *\n-     * @return a value of {@code null}, if no {@link Channel} is ready to be reused\n-     * @see #acquire(Promise)\n+     * @param promise a {@link Promise promise} that will be completed when a {@link Channel channel} is acquired or an\n+     * error is encountered.\n+     *\n+     * @see #runTasksInPendingAcquisitionQueue\n      */\n-    @Override\n-    protected Channel pollChannel() {\n-\n-        final Channel first = super.pollChannel();\n-\n-        if (first == null) {\n-            return null;\n+    private void addTaskToPendingAcquisitionQueue(Promise<Channel> promise) {\n+\n+        this.ensureValidRunState();\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"{}, {}, {}, {}, {}, {}\",", "originalCommit": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMTc4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424811785", "bodyText": "Here's what I see in the code:\n            logger.debug(\"{}, {}, {}, {}, {}, {}\",\n                OffsetDateTime.now(),\n                this.remoteAddress(),\n                this.channels(),\n                this.channelsAcquired(),\n                this.channelsAvailable(),\n                this.requestQueueLength());", "author": "David-Noble-at-work", "createdAt": "2020-05-14T00:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzA3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420507074", "bodyText": "Another TODO. Stale code ?", "author": "kushagraThapar", "createdAt": "2020-05-06T02:00:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -411,48 +729,389 @@ private void close0() {\n             task.promise.setFailure(new ClosedChannelException());\n         }\n \n-        // Ensure we dispatch this on another Thread as close0 will be called from the EventExecutor and we need\n-        // to ensure we will not block in an EventExecutor\n+        // NOTE: we must dispatch this request on another thread--the closer thread--as this.doClose is called on\n+        // this.executor and we need to ensure we will not block it.\n+\n+        closer.submit(() -> {\n+\n+            this.availableChannels.addAll(this.acquiredChannels.values());\n+            this.acquiredChannels.clear();\n+\n+            for (; ; ) {\n+                final Channel channel = this.pollChannel();\n+                if (channel == null) {\n+                    break;\n+                }\n+                channel.close().awaitUninterruptibly(); // block and ignore errors reported back from channel.close\n+            }\n+\n+            assert this.acquiredChannels.isEmpty() && this.availableChannels.isEmpty();\n+\n+        }).addListener(closed -> {\n+            if (!closed.isSuccess()) {\n+                logger.error(\"[{}] close failed due to \", this, closed.cause());\n+            } else {\n+                logger.debug(\"[{}] closed\", this);\n+            }\n+        });\n+    }\n+\n+    private void ensureInEventLoop() {\n+        reportIssueUnless(logger, this.executor.inEventLoop(), this,\n+            \"expected to be in event loop {}, not thread {}\",\n+            this.executor,\n+            Thread.currentThread());\n+    }\n \n-        GlobalEventExecutor.INSTANCE.execute(RntbdClientChannelPool.super::close);\n+    /**\n+     * Checks that the state of this {@link RntbdClientChannelPool pool} is a valid run state and returns the {@link\n+     * #availableChannels} available channel count.\n+     * <p>\n+     * This method reports an issue to be addressed if the state is invalid. It does not throw.\n+     */\n+    private void ensureValidRunState() {\n+\n+        this.ensureInEventLoop();\n+// TODO (DANOBLE) remove or restore this code:\n+//        final int channelsAvailable = this.channelsAvailable();\n+//        final int channelsAcquired = this.channelsAcquired();\n+//        final int channelCount = this.channels();\n+//\n+//        reportIssueUnless(logger, 0 <= channelCount && channelCount <= this.maxChannels, this,\n+//            \"expected channelCount in range [0, {}], not {}\",\n+//            this.maxChannels,\n+//            channelCount,\n+//            channelsAcquired);\n+//\n+//        return channelsAvailable;", "originalCommit": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMTUyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424811526", "bodyText": "I will remove this in my next PR which will wire up the DirectConnectionConfig. The change is made on my local branch right now.", "author": "David-Noble-at-work", "createdAt": "2020-05-14T00:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzM3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r420507377", "bodyText": "Love this. \u2764\ufe0f", "author": "kushagraThapar", "createdAt": "2020-05-06T02:01:45Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -667,12 +1329,24 @@ public void serialize(final RntbdClientChannelPool value, final JsonGenerator ge\n             generator.writeNumberField(\"channelsAcquired\", value.channelsAcquired());\n             generator.writeNumberField(\"channelsAvailable\", value.channelsAvailable());\n             generator.writeNumberField(\"requestQueueLength\", value.requestQueueLength());\n-            generator.writeNumberField(\"usedDirectMemory\", value.usedDirectMemory());\n-            generator.writeNumberField(\"usedHeapMemory\", value.usedHeapMemory());\n             generator.writeEndObject();\n             generator.writeEndObject();\n         }\n     }\n \n+    private static class StacklessIllegalStateException extends IllegalStateException {", "originalCommit": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgxMDA2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r424810069", "bodyText": "thank you.", "author": "David-Noble-at-work", "createdAt": "2020-05-14T00:47:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2NTMyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10616#discussion_r419765324", "bodyText": "nice addition. thank you", "author": "moderakh", "createdAt": "2020-05-04T22:25:49Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -11,6 +11,7 @@\n import com.azure.cosmos.CosmosClientException;\n import com.azure.cosmos.implementation.HttpConstants;\n import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;", "originalCommit": "cf9e4d2b49a5adc63665888e6231470fbc1c04e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2a747ce328164ae53f261958300d23f3f7eea42b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a747ce328164ae53f261958300d23f3f7eea42b", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into issue/cosmos-4.X/direct-tcp/socket-leak", "committedDate": "2020-05-14T00:11:00Z", "type": "commit"}]}