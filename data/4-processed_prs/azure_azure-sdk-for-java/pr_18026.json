{"pr_number": 18026, "pr_title": "Conflict read/query support.", "pr_createdAt": "2020-12-08T22:25:35Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/18026", "timeline": [{"oid": "7b8e80caf7aeea4938c88dd8c7c511209201745b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7b8e80caf7aeea4938c88dd8c7c511209201745b", "message": "Initial commit for conflict support in V4 java", "committedDate": "2020-12-08T00:16:18Z", "type": "commit"}, {"oid": "39471ac555293c4327a1472f5904fdc4fccf29ea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/39471ac555293c4327a1472f5904fdc4fccf29ea", "message": "refactoring test cases", "committedDate": "2020-12-08T21:47:06Z", "type": "commit"}, {"oid": "6e2608d40e9f2c6932f95e64ca5e3a6c9464be3d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6e2608d40e9f2c6932f95e64ca5e3a6c9464be3d", "message": "Merge branch 'latest-master' into users/nakumars/conflictApiSupport", "committedDate": "2020-12-08T21:54:10Z", "type": "commit"}, {"oid": "9d30afe9a0be59a9285e3296b71faaca0233ce80", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9d30afe9a0be59a9285e3296b71faaca0233ce80", "message": "adding timeout in test", "committedDate": "2020-12-08T21:54:59Z", "type": "commit"}, {"oid": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/70d8b6a8f7365683559c1f7be9b87f653f24eea2", "message": "fixing documentation", "committedDate": "2020-12-08T22:03:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NTY2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538855662", "bodyText": "Idea of this api is customer can use their own serializer to read conflict resource . But I am doubtful as we don't support this kind of api in item read. Thoughts ?", "author": "simplynaveen20", "createdAt": "2020-12-08T22:28:14Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosConflictProperties.java", "diffHunk": "@@ -55,6 +55,24 @@ Resource getResource() {\n         return this.conflict;\n     }\n \n+    /**\n+     * Gets the conflicting resource in the Azure Cosmos DB service.\n+     * @param <T> the type of the object.\n+     * @param klass The returned type of conflicting resource.\n+     * @return The conflicting resource.\n+     */\n+    public <T> T getItem(Class<T> klass) {\n+        return this.conflict.getItem(klass);\n+    }\n+\n+    /**\n+     * Gets the json content of the conflict.\n+     * @return The content string.\n+     */\n+    public String getItemAsJson() {", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMjQ0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538922444", "bodyText": "I suggest we don't introduce this API for now. as you said we currently do not support getting string content from the CosmosItemResponse.\ngetItem(ObjectNode.class) should work the customer need.\nLater when we add the support for getting content from CosmosItemResponse we can revisit this.", "author": "moderakh", "createdAt": "2020-12-09T00:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzNjIzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539536232", "bodyText": "Removed the api getItemAsJson", "author": "simplynaveen20", "createdAt": "2020-12-09T18:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwODM4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r540408389", "bodyText": "^Agree with this. As I understand it we don't currently support customer serializer in general.", "author": "anfeldma-ms", "createdAt": "2020-12-10T18:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1Njc0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538856742", "bodyText": "Adding this api because as of now customer need to pass the self link by themselves, and in V4 we don't have a way of getting self link from resources. Only way for user is if they manually create the URL.", "author": "simplynaveen20", "createdAt": "2020-12-08T22:30:12Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -128,6 +132,54 @@ public static ConflictResolutionPolicy createCustomPolicy(String conflictResolut\n         return policy;\n     }\n \n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosStoredProcedure storedProcedure) {", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTMwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r540255307", "bodyText": "removed this api", "author": "simplynaveen20", "createdAt": "2020-12-10T15:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1Njc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NzMyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538857325", "bodyText": "Adding this api because as of now customer need to pass the self link by themselves, and in V4 we don't have a way of getting self link from resources. Only way for user is if they manually create the URL.", "author": "simplynaveen20", "createdAt": "2020-12-08T22:31:24Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -128,6 +132,54 @@ public static ConflictResolutionPolicy createCustomPolicy(String conflictResolut\n         return policy;\n     }\n \n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosStoredProcedure storedProcedure) {\n+        ConflictResolutionPolicy policy = new ConflictResolutionPolicy();\n+        policy.setMode(ConflictResolutionMode.CUSTOM);\n+        if (storedProcedure != null) {\n+            policy.setConflictResolutionProcedure(getLink(storedProcedure));\n+        }\n+        return policy;\n+    }\n+\n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosAsyncStoredProcedure storedProcedure) {", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTE4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r540255180", "bodyText": "removed this api", "author": "simplynaveen20", "createdAt": "2020-12-10T15:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxODQ1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538918451", "bodyText": "nit: remove additional empty line", "author": "moderakh", "createdAt": "2020-12-09T00:46:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -641,6 +641,17 @@ public static RequestOptions toRequestOptions(TransactionalBatchRequestOptions t\n         return transactionalBatchRequestOptions.toRequestOptions();\n     }\n \n+", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxODYyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538918625", "bodyText": "nice catch. thank you.", "author": "moderakh", "createdAt": "2020-12-09T00:46:45Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncConflict.java", "diffHunk": "@@ -71,15 +71,15 @@ CosmosAsyncConflict setId(String id) {\n     }\n \n     /**\n-     * Reads all conflicts in a container.\n+     * Deletes a conflict.", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxOTI2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538919268", "bodyText": "fix the indentation. 4 spaces per indentation as similar to other places.", "author": "moderakh", "createdAt": "2020-12-09T00:48:29Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Conflict.java", "diffHunk": "@@ -74,4 +78,32 @@ public String getSourceResourceId() {\n             return null;\n         }\n     }\n+\n+    /**\n+     * Gets the conflicting resource in the Azure Cosmos DB service.\n+     * @param <T> the type of the object.\n+     * @param klass The returned type of conflicting resource.\n+     * @return The conflicting resource.\n+     */\n+    public <T > T getItem(Class<T> klass) {\n+        String resourceAsString = super.getString(Constants.Properties.CONTENT);\n+\n+        if (!Strings.isNullOrEmpty(resourceAsString)) {\n+                try {", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzNzIwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539537201", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-12-09T18:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxOTI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxOTY2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538919663", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getItemAsJson() {\n          \n          \n            \n                public String getItemAsJsonString() {", "author": "moderakh", "createdAt": "2020-12-09T00:49:35Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Conflict.java", "diffHunk": "@@ -74,4 +78,32 @@ public String getSourceResourceId() {\n             return null;\n         }\n     }\n+\n+    /**\n+     * Gets the conflicting resource in the Azure Cosmos DB service.\n+     * @param <T> the type of the object.\n+     * @param klass The returned type of conflicting resource.\n+     * @return The conflicting resource.\n+     */\n+    public <T > T getItem(Class<T> klass) {\n+        String resourceAsString = super.getString(Constants.Properties.CONTENT);\n+\n+        if (!Strings.isNullOrEmpty(resourceAsString)) {\n+                try {\n+                    return mapper.readValue(resourceAsString, klass);\n+                } catch (JsonProcessingException ex) {\n+                    throw new IllegalStateException(\"Failed to deserialize  class object.\", ex);\n+                }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Gets the json content of the conflicting resource.\n+     * @return The content string.\n+     */\n+    public String getItemAsJson() {", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzNjc1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539536750", "bodyText": "Removed the api", "author": "simplynaveen20", "createdAt": "2020-12-09T18:16:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxOTY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMDgyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538920822", "bodyText": "our data-model classes are free of notion of async-ness vs sync-ness.\nThis breaks that existing design and brings async-ness into the data-models. We should find a different approach for this.", "author": "moderakh", "createdAt": "2020-12-09T00:52:34Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -128,6 +132,54 @@ public static ConflictResolutionPolicy createCustomPolicy(String conflictResolut\n         return policy;\n     }\n \n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosStoredProcedure storedProcedure) {\n+        ConflictResolutionPolicy policy = new ConflictResolutionPolicy();\n+        policy.setMode(ConflictResolutionMode.CUSTOM);\n+        if (storedProcedure != null) {\n+            policy.setConflictResolutionProcedure(getLink(storedProcedure));\n+        }\n+        return policy;\n+    }\n+\n+    /**\n+     * Creates a CUSTOM {@link ConflictResolutionPolicy} which uses the specified stored procedure\n+     * to perform conflict resolution\n+     * <p>\n+     * This stored procedure may be created after the {@link CosmosContainerProperties} is created and can be changed as\n+     * required.\n+     *\n+     * <ul>\n+     * <li>In case the stored procedure fails or throws an exception,\n+     * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n+     * </ul>\n+     *\n+     * @param storedProcedure stored procedure to perform conflict resolution.\n+     * @return ConflictResolutionPolicy.\n+     */\n+    public static ConflictResolutionPolicy createCustomPolicy(CosmosAsyncStoredProcedure storedProcedure) {", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNTkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538925911", "bodyText": "blocking on this one.\nadding @FabianMeiswinkel @kushagraThapar @kirankumarkolli for further discussion.", "author": "moderakh", "createdAt": "2020-12-09T01:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMDgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539739103", "bodyText": "Resolving as per the meeting update -\n\nWe will create overload of method createCustomPolicy(String db, String containerName, String SprocName)\nChange the existing api createCustomPolicy paramenter name conflictResolutionStoredProcName -> conflictResolutionStoredProcFullPath , update documentation , link reference to above api if user dont want to create the full path them self", "author": "simplynaveen20", "createdAt": "2020-12-09T23:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMDgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNDMxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538924317", "bodyText": "please use TestSuiteBase:safeClose that will do the null check.", "author": "moderakh", "createdAt": "2020-12-09T01:00:50Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosConflictsTest.java", "diffHunk": "@@ -0,0 +1,461 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DatabaseAccount;\n+import com.azure.cosmos.implementation.DatabaseAccountLocation;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.ConflictResolutionPolicy;\n+import com.azure.cosmos.models.CosmosConflictProperties;\n+import com.azure.cosmos.models.CosmosConflictRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.apache.commons.io.IOUtils;\n+import org.assertj.core.util.Strings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+public class CosmosConflictsTest extends TestSuiteBase {\n+    private static final int CONFLICT_TIMEOUT = 120000;\n+    private static Logger logger = LoggerFactory.getLogger(CosmosConflictsTest.class);\n+    private String sprocBody;\n+    private CosmosAsyncClient globalClient;\n+    private List<CosmosAsyncClient> regionalClients;\n+\n+    @BeforeClass(groups = {\"multi-master\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_ConflictTests() throws Exception {\n+        sprocBody = IOUtils.toString(\n+            getClass().getClassLoader().getResourceAsStream(\"conflict-resolver-sproc\"), \"UTF-8\");\n+        globalClient = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .contentResponseOnWriteEnabled(true)\n+            .endpointDiscoveryEnabled(false)\n+            .directMode()\n+            .buildAsyncClient();\n+\n+        GlobalEndpointManager globalEndpointManager =\n+            ReflectionUtils.getGlobalEndpointManager((RxDocumentClientImpl) globalClient.getContextClient());\n+        DatabaseAccount databaseAccount = globalEndpointManager.getLatestDatabaseAccount();\n+        Iterator<DatabaseAccountLocation> locationIterator = databaseAccount.getWritableLocations().iterator();\n+        regionalClients = new ArrayList<>();\n+        while (locationIterator.hasNext()) {\n+            DatabaseAccountLocation accountLocation = locationIterator.next();\n+            CosmosAsyncClient regionalClient = new CosmosClientBuilder()\n+                .endpoint(accountLocation.getEndpoint())\n+                .key(TestConfigurations.MASTER_KEY)\n+                .contentResponseOnWriteEnabled(true)\n+                .endpointDiscoveryEnabled(false)\n+                .directMode()\n+                .buildAsyncClient();\n+            regionalClients.add(regionalClient);\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictDefaultLWW() throws InterruptedException {\n+        String conflictId = \"conflict\";\n+        CosmosAsyncContainer asyncContainer = getSharedMultiPartitionCosmosContainer(globalClient);\n+        if (this.regionalClients.size() > 1) {\n+            List<CosmosAsyncContainer> containers = new ArrayList<>();\n+            warmingUpClient(containers, asyncContainer.getDatabase().getId(), asyncContainer.getId());\n+            createItemsInParallelForConflicts(containers, conflictId);\n+            Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+            Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+            List<ConflictTestPojo> testPojos = new ArrayList<>();\n+            readConflicts(iterator, testPojos, null);\n+            assertThat(testPojos.size()).isEqualTo(0);\n+\n+            CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+\n+            //Verify delete should always win\n+            replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+            Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+            try {\n+                containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                fail(\"Delete should always win in conflict scenerio\");\n+            } catch (CosmosException ex) {\n+                assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictCustomLWW() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\"conflictCustomLWWContainer\"\n+                , \"/mypk\");\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createLastWriterWinsPolicy(\n+                \"/regionId\");\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                //Creating conflict by creating item in every region simultaneously\n+                String conflictId = \"conflict\";\n+                createItemsInParallelForConflicts(containers, conflictId);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                readConflicts(iterator, testPojos, null);\n+                //There should be no conflict\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Higher regionId item should win.\n+                assertThat(itemResponse.getItem().getRegionId()).isEqualTo(containers.size() - 1);\n+\n+                //Verify delete should always win\n+                replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                try {\n+                    containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null,\n+                        ConflictTestPojo.class).block();\n+                    fail(\"Delete should always win in conflict scenerio\");\n+                } catch (CosmosException ex) {\n+                    assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+                }\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictCustomSproc() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+\n+            //Creating container with sproc as conflict resolver\n+            String sprocId = \"conflictCustomSproc\";\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\"conflictSprocContainer\",\n+                \"/mypk\");\n+            CosmosAsyncStoredProcedure storedProcedure =\n+                database.getContainer(containerProperties.getId()).getScripts().getStoredProcedure(sprocId);\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createCustomPolicy(storedProcedure);\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                //create the sproc\n+                CosmosAsyncContainer asyncContainer = database.getContainer(containerProperties.getId());\n+                CosmosStoredProcedureProperties procedureProperties = new CosmosStoredProcedureProperties(sprocId,\n+                    sprocBody);\n+                asyncContainer.getScripts().createStoredProcedure(procedureProperties).block();\n+\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                //Creating conflict by creating item in every region simultaneously\n+                String conflictId = \"conflict\";\n+                createItemsInParallelForConflicts(containers, conflictId);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                readConflicts(iterator, testPojos, null);\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Lower regionId item should win as per sproc.\n+                assertThat(itemResponse.getItem().getRegionId()).isEqualTo(0);\n+\n+                //Verify delete should always win\n+                replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                try {\n+                    containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null,\n+                        ConflictTestPojo.class).block();\n+                    fail(\"Delete should always win in conflict scenerio\");\n+                } catch (CosmosException ex) {\n+                    assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+                }\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictNonExistingCustomSproc() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+\n+            //Creating container with sproc as conflict resolver\n+            String sprocId = \"conflictNonExistingCustomSproc\";\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\n+                \"conflictNonExistingSprocContainer\",\n+                \"/mypk\");\n+            CosmosAsyncStoredProcedure storedProcedure =\n+                database.getContainer(containerProperties.getId()).getScripts().getStoredProcedure(sprocId);\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createCustomPolicy(storedProcedure);\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                String conflictId = \"conflict\";\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                List<String> conflictIds = new ArrayList<>();\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator = null;\n+                for (int j = 0; j < 5; j++) {\n+                    conflictId = conflictId + j;\n+                    boolean conflictCreated = false;\n+                    createItemsInParallelForConflicts(containers, conflictId);\n+\n+                    Thread.sleep(5000); // Wait for conflict item to replicate\n+\n+                    for (int i = 1; i < 4; i++) {\n+                        //Testing readAllConflicts()\n+                        iterator =\n+                            containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+\n+                        readConflicts(iterator, testPojos, conflictIds);\n+                        if (testPojos.size() == 0) {\n+                            logger.error(\"Conflict on {} insert operation has not reflected yet, retrying read after \" +\n+                                    \"5 sec\",\n+                                containers.get(0).getId());\n+                            Thread.sleep(5000); // retry after 5 sec\n+                        } else {\n+                            conflictCreated = true;\n+                            break;\n+                        }\n+                    }\n+                    if (conflictCreated) {\n+                        break;\n+                    }\n+                    logger.error(\"Conflict on {} not created, retrying again\",\n+                        containers.get(0).getId());\n+                }\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+                //Testing queryConflicts(String query, CosmosQueryRequestOptions cosmosQueryRequestOptions)\n+                testPojos.clear();\n+                String query = String.format(\"SELECT * from c where c.id in (%s)\",\n+                    Strings.join(conflictIds.stream().map(s -> \"'\" + s + \"'\").collect(Collectors.toList())).with(\",\"));\n+                CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+                options.setPartitionKey(new PartitionKey(conflictId));\n+                iterator = containers.get(0).queryConflicts(query, options).byPage().toIterable().iterator();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+\n+                //Testing queryConflicts(String query)\n+                testPojos.clear();\n+                iterator = containers.get(0).queryConflicts(query).byPage().toIterable().iterator();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+                for (String id : conflictIds) {\n+                    CosmosConflictRequestOptions requestOptions =\n+                        new CosmosConflictRequestOptions(new PartitionKey(conflictId));\n+                    containers.get(0).getConflict(id).delete(requestOptions).block();\n+                }\n+                Thread.sleep(5000); // Wait for conflict item to replicate\n+\n+                iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                testPojos.clear();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //Making sure all conflicts are deleted\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Verifying during conflict on create we will have one winner item saved\n+                assertThat(itemResponse.getItem().getId()).isEqualTo(conflictId);\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @AfterClass(groups = {\"multi-master\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        if (this.globalClient != null) {\n+            this.globalClient.close();", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzNjkwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539536905", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-12-09T18:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNDMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNDM0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r538924342", "bodyText": "ditto.", "author": "moderakh", "createdAt": "2020-12-09T01:00:56Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosConflictsTest.java", "diffHunk": "@@ -0,0 +1,461 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DatabaseAccount;\n+import com.azure.cosmos.implementation.DatabaseAccountLocation;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.ConflictResolutionPolicy;\n+import com.azure.cosmos.models.CosmosConflictProperties;\n+import com.azure.cosmos.models.CosmosConflictRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.apache.commons.io.IOUtils;\n+import org.assertj.core.util.Strings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+public class CosmosConflictsTest extends TestSuiteBase {\n+    private static final int CONFLICT_TIMEOUT = 120000;\n+    private static Logger logger = LoggerFactory.getLogger(CosmosConflictsTest.class);\n+    private String sprocBody;\n+    private CosmosAsyncClient globalClient;\n+    private List<CosmosAsyncClient> regionalClients;\n+\n+    @BeforeClass(groups = {\"multi-master\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_ConflictTests() throws Exception {\n+        sprocBody = IOUtils.toString(\n+            getClass().getClassLoader().getResourceAsStream(\"conflict-resolver-sproc\"), \"UTF-8\");\n+        globalClient = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .contentResponseOnWriteEnabled(true)\n+            .endpointDiscoveryEnabled(false)\n+            .directMode()\n+            .buildAsyncClient();\n+\n+        GlobalEndpointManager globalEndpointManager =\n+            ReflectionUtils.getGlobalEndpointManager((RxDocumentClientImpl) globalClient.getContextClient());\n+        DatabaseAccount databaseAccount = globalEndpointManager.getLatestDatabaseAccount();\n+        Iterator<DatabaseAccountLocation> locationIterator = databaseAccount.getWritableLocations().iterator();\n+        regionalClients = new ArrayList<>();\n+        while (locationIterator.hasNext()) {\n+            DatabaseAccountLocation accountLocation = locationIterator.next();\n+            CosmosAsyncClient regionalClient = new CosmosClientBuilder()\n+                .endpoint(accountLocation.getEndpoint())\n+                .key(TestConfigurations.MASTER_KEY)\n+                .contentResponseOnWriteEnabled(true)\n+                .endpointDiscoveryEnabled(false)\n+                .directMode()\n+                .buildAsyncClient();\n+            regionalClients.add(regionalClient);\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictDefaultLWW() throws InterruptedException {\n+        String conflictId = \"conflict\";\n+        CosmosAsyncContainer asyncContainer = getSharedMultiPartitionCosmosContainer(globalClient);\n+        if (this.regionalClients.size() > 1) {\n+            List<CosmosAsyncContainer> containers = new ArrayList<>();\n+            warmingUpClient(containers, asyncContainer.getDatabase().getId(), asyncContainer.getId());\n+            createItemsInParallelForConflicts(containers, conflictId);\n+            Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+            Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+            List<ConflictTestPojo> testPojos = new ArrayList<>();\n+            readConflicts(iterator, testPojos, null);\n+            assertThat(testPojos.size()).isEqualTo(0);\n+\n+            CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+\n+            //Verify delete should always win\n+            replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+            Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+            try {\n+                containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                fail(\"Delete should always win in conflict scenerio\");\n+            } catch (CosmosException ex) {\n+                assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictCustomLWW() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\"conflictCustomLWWContainer\"\n+                , \"/mypk\");\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createLastWriterWinsPolicy(\n+                \"/regionId\");\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                //Creating conflict by creating item in every region simultaneously\n+                String conflictId = \"conflict\";\n+                createItemsInParallelForConflicts(containers, conflictId);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                readConflicts(iterator, testPojos, null);\n+                //There should be no conflict\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Higher regionId item should win.\n+                assertThat(itemResponse.getItem().getRegionId()).isEqualTo(containers.size() - 1);\n+\n+                //Verify delete should always win\n+                replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                try {\n+                    containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null,\n+                        ConflictTestPojo.class).block();\n+                    fail(\"Delete should always win in conflict scenerio\");\n+                } catch (CosmosException ex) {\n+                    assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+                }\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictCustomSproc() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+\n+            //Creating container with sproc as conflict resolver\n+            String sprocId = \"conflictCustomSproc\";\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\"conflictSprocContainer\",\n+                \"/mypk\");\n+            CosmosAsyncStoredProcedure storedProcedure =\n+                database.getContainer(containerProperties.getId()).getScripts().getStoredProcedure(sprocId);\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createCustomPolicy(storedProcedure);\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                //create the sproc\n+                CosmosAsyncContainer asyncContainer = database.getContainer(containerProperties.getId());\n+                CosmosStoredProcedureProperties procedureProperties = new CosmosStoredProcedureProperties(sprocId,\n+                    sprocBody);\n+                asyncContainer.getScripts().createStoredProcedure(procedureProperties).block();\n+\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                //Creating conflict by creating item in every region simultaneously\n+                String conflictId = \"conflict\";\n+                createItemsInParallelForConflicts(containers, conflictId);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                readConflicts(iterator, testPojos, null);\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Lower regionId item should win as per sproc.\n+                assertThat(itemResponse.getItem().getRegionId()).isEqualTo(0);\n+\n+                //Verify delete should always win\n+                replaceDeleteItemInParallelForConflicts(containers, itemResponse);\n+                Thread.sleep(10000); // Wait for conflict item to replicate\n+\n+                try {\n+                    containers.get(0).readItem(conflictId, new PartitionKey(conflictId), null,\n+                        ConflictTestPojo.class).block();\n+                    fail(\"Delete should always win in conflict scenerio\");\n+                } catch (CosmosException ex) {\n+                    assertThat(ex.getStatusCode()).isEqualTo(HttpConstants.StatusCodes.NOTFOUND);\n+                }\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @Test(groups = {\"multi-master\"}, timeOut = CONFLICT_TIMEOUT)\n+    public void conflictNonExistingCustomSproc() throws InterruptedException {\n+        if (this.regionalClients.size() > 1) {\n+            CosmosAsyncDatabase database = getSharedCosmosDatabase(globalClient);\n+            //getSharedCosmosDatabase(this.regionalClients.get(0));\n+\n+            //Creating container with sproc as conflict resolver\n+            String sprocId = \"conflictNonExistingCustomSproc\";\n+            CosmosContainerProperties containerProperties = new CosmosContainerProperties(\n+                \"conflictNonExistingSprocContainer\",\n+                \"/mypk\");\n+            CosmosAsyncStoredProcedure storedProcedure =\n+                database.getContainer(containerProperties.getId()).getScripts().getStoredProcedure(sprocId);\n+            ConflictResolutionPolicy resolutionPolicy = ConflictResolutionPolicy.createCustomPolicy(storedProcedure);\n+            containerProperties.setConflictResolutionPolicy(resolutionPolicy);\n+            database.createContainer(containerProperties, ThroughputProperties.createManualThroughput(400)).block();\n+            Thread.sleep(5000); //waiting for container to get available across multi region\n+\n+            try {\n+                List<CosmosAsyncContainer> containers = new ArrayList<>();\n+                warmingUpClient(containers, database.getId(), containerProperties.getId());\n+\n+                String conflictId = \"conflict\";\n+                List<ConflictTestPojo> testPojos = new ArrayList<>();\n+                List<String> conflictIds = new ArrayList<>();\n+                Iterator<FeedResponse<CosmosConflictProperties>> iterator = null;\n+                for (int j = 0; j < 5; j++) {\n+                    conflictId = conflictId + j;\n+                    boolean conflictCreated = false;\n+                    createItemsInParallelForConflicts(containers, conflictId);\n+\n+                    Thread.sleep(5000); // Wait for conflict item to replicate\n+\n+                    for (int i = 1; i < 4; i++) {\n+                        //Testing readAllConflicts()\n+                        iterator =\n+                            containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+\n+                        readConflicts(iterator, testPojos, conflictIds);\n+                        if (testPojos.size() == 0) {\n+                            logger.error(\"Conflict on {} insert operation has not reflected yet, retrying read after \" +\n+                                    \"5 sec\",\n+                                containers.get(0).getId());\n+                            Thread.sleep(5000); // retry after 5 sec\n+                        } else {\n+                            conflictCreated = true;\n+                            break;\n+                        }\n+                    }\n+                    if (conflictCreated) {\n+                        break;\n+                    }\n+                    logger.error(\"Conflict on {} not created, retrying again\",\n+                        containers.get(0).getId());\n+                }\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+                //Testing queryConflicts(String query, CosmosQueryRequestOptions cosmosQueryRequestOptions)\n+                testPojos.clear();\n+                String query = String.format(\"SELECT * from c where c.id in (%s)\",\n+                    Strings.join(conflictIds.stream().map(s -> \"'\" + s + \"'\").collect(Collectors.toList())).with(\",\"));\n+                CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+                options.setPartitionKey(new PartitionKey(conflictId));\n+                iterator = containers.get(0).queryConflicts(query, options).byPage().toIterable().iterator();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+\n+                //Testing queryConflicts(String query)\n+                testPojos.clear();\n+                iterator = containers.get(0).queryConflicts(query).byPage().toIterable().iterator();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //We will see some conflicts, as there is no sproc to resolve\n+                assertThat(testPojos.size()).isEqualTo(containers.size() - 1);\n+\n+                for (String id : conflictIds) {\n+                    CosmosConflictRequestOptions requestOptions =\n+                        new CosmosConflictRequestOptions(new PartitionKey(conflictId));\n+                    containers.get(0).getConflict(id).delete(requestOptions).block();\n+                }\n+                Thread.sleep(5000); // Wait for conflict item to replicate\n+\n+                iterator =\n+                    containers.get(0).readAllConflicts(new CosmosQueryRequestOptions()).byPage().toIterable().iterator();\n+                testPojos.clear();\n+                readConflicts(iterator, testPojos, null);\n+\n+                //Making sure all conflicts are deleted\n+                assertThat(testPojos.size()).isEqualTo(0);\n+\n+                CosmosItemResponse<ConflictTestPojo> itemResponse = containers.get(0).readItem(conflictId,\n+                    new PartitionKey(conflictId), null, ConflictTestPojo.class).block();\n+                //Verifying during conflict on create we will have one winner item saved\n+                assertThat(itemResponse.getItem().getId()).isEqualTo(conflictId);\n+            } finally {\n+                database.getContainer(containerProperties.getId()).delete().block();\n+            }\n+        } else {\n+            fail(\"Unable to find multi master account\");\n+        }\n+    }\n+\n+    @AfterClass(groups = {\"multi-master\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        if (this.globalClient != null) {\n+            this.globalClient.close();\n+        }\n+        for (CosmosAsyncClient asyncClient : this.regionalClients)\n+            if (asyncClient != null) {\n+                asyncClient.close();", "originalCommit": "70d8b6a8f7365683559c1f7be9b87f653f24eea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzNzA4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539537080", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-12-09T18:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNDM0Mg=="}], "type": "inlineReview"}, {"oid": "a24a51a8441016214e9af1fa8e84c5199b3c94b7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a24a51a8441016214e9af1fa8e84c5199b3c94b7", "message": "resolving comments", "committedDate": "2020-12-09T18:14:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MDcwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539540708", "bodyText": "you shouldn't pass the regional account endpoint to the CosmosClientBuilder.\ninstead you should pass the global account endpoint and set the preferred region to be the local region of interest.", "author": "moderakh", "createdAt": "2020-12-09T18:21:47Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosConflictsTest.java", "diffHunk": "@@ -0,0 +1,457 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DatabaseAccount;\n+import com.azure.cosmos.implementation.DatabaseAccountLocation;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.ConflictResolutionPolicy;\n+import com.azure.cosmos.models.CosmosConflictProperties;\n+import com.azure.cosmos.models.CosmosConflictRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.apache.commons.io.IOUtils;\n+import org.assertj.core.util.Strings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+public class CosmosConflictsTest extends TestSuiteBase {\n+    private static final int CONFLICT_TIMEOUT = 120000;\n+    private static Logger logger = LoggerFactory.getLogger(CosmosConflictsTest.class);\n+    private String sprocBody;\n+    private CosmosAsyncClient globalClient;\n+    private List<CosmosAsyncClient> regionalClients;\n+\n+    @BeforeClass(groups = {\"multi-master\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_ConflictTests() throws Exception {\n+        sprocBody = IOUtils.toString(\n+            getClass().getClassLoader().getResourceAsStream(\"conflict-resolver-sproc\"), \"UTF-8\");\n+        globalClient = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .contentResponseOnWriteEnabled(true)\n+            .endpointDiscoveryEnabled(false)\n+            .directMode()\n+            .buildAsyncClient();\n+\n+        GlobalEndpointManager globalEndpointManager =\n+            ReflectionUtils.getGlobalEndpointManager((RxDocumentClientImpl) globalClient.getContextClient());\n+        DatabaseAccount databaseAccount = globalEndpointManager.getLatestDatabaseAccount();\n+        Iterator<DatabaseAccountLocation> locationIterator = databaseAccount.getWritableLocations().iterator();\n+        regionalClients = new ArrayList<>();\n+        while (locationIterator.hasNext()) {\n+            DatabaseAccountLocation accountLocation = locationIterator.next();\n+            CosmosAsyncClient regionalClient = new CosmosClientBuilder()\n+                .endpoint(accountLocation.getEndpoint())", "originalCommit": "a24a51a8441016214e9af1fa8e84c5199b3c94b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMTg5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539601890", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-12-09T19:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MjE5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539542191", "bodyText": "we had different multi-master CI accounts. One CI uses an account with multi-master enabled in the account but with a single region.\nYou should validate that if the account is single region this test class should be skipped.", "author": "moderakh", "createdAt": "2020-12-09T18:23:58Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosConflictsTest.java", "diffHunk": "@@ -0,0 +1,457 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DatabaseAccount;\n+import com.azure.cosmos.implementation.DatabaseAccountLocation;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.ConflictResolutionPolicy;\n+import com.azure.cosmos.models.CosmosConflictProperties;\n+import com.azure.cosmos.models.CosmosConflictRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.apache.commons.io.IOUtils;\n+import org.assertj.core.util.Strings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+public class CosmosConflictsTest extends TestSuiteBase {\n+    private static final int CONFLICT_TIMEOUT = 120000;\n+    private static Logger logger = LoggerFactory.getLogger(CosmosConflictsTest.class);\n+    private String sprocBody;\n+    private CosmosAsyncClient globalClient;\n+    private List<CosmosAsyncClient> regionalClients;\n+\n+    @BeforeClass(groups = {\"multi-master\"}, timeOut = SETUP_TIMEOUT)", "originalCommit": "a24a51a8441016214e9af1fa8e84c5199b3c94b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMTc1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r539601758", "bodyText": "Skipping single region mm account.", "author": "simplynaveen20", "createdAt": "2020-12-09T19:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MjE5MQ=="}], "type": "inlineReview"}, {"oid": "a1682d9985d9a8cddb12b3ff797808d110e30e1b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a1682d9985d9a8cddb12b3ff797808d110e30e1b", "message": "resolving comments", "committedDate": "2020-12-09T19:29:15Z", "type": "commit"}, {"oid": "9df24556f2ee787fea0eab8e2dba622bacd5a341", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9df24556f2ee787fea0eab8e2dba622bacd5a341", "message": "Skipping test for single region multi master account", "committedDate": "2020-12-09T19:48:11Z", "type": "commit"}, {"oid": "367e2e4f6de4fa952f9a6a65178820e8806f92b8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/367e2e4f6de4fa952f9a6a65178820e8806f92b8", "message": "resolving comments", "committedDate": "2020-12-09T23:49:16Z", "type": "commit"}, {"oid": "298bfa378c5e14741bc86cf895b38ff9225f0adc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/298bfa378c5e14741bc86cf895b38ff9225f0adc", "message": "removing unnessary change", "committedDate": "2020-12-09T23:55:21Z", "type": "commit"}, {"oid": "920df6c6ac31c5f6bc71cd6f8ddb33455e55641f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/920df6c6ac31c5f6bc71cd6f8ddb33455e55641f", "message": "adding sproc file", "committedDate": "2020-12-10T18:57:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0Njg4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r540546886", "bodyText": "is this meant to be self link or name link?", "author": "moderakh", "createdAt": "2020-12-10T22:34:39Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ConflictResolutionPolicy.java", "diffHunk": "@@ -111,23 +112,47 @@ public static ConflictResolutionPolicy createLastWriterWinsPolicy(String conflic\n      * required.\n      *\n      * <ul>\n+     * <li>This method requires conflictResolutionStoredProcFullPath in format\n+     * dbs/%s/colls/%s/sprocs/%s. User can also use equivalent method {@link #createCustomPolicy(String, String, String)}</li>\n      * <li>In case the stored procedure fails or throws an exception,\n      * the conflict resolution will default to registering conflicts in the conflicts feed</li>\n      * <li>The user can provide the stored procedure @see {@link Resource#getId()} </li>\n      * </ul>\n      *\n-     * @param conflictResolutionStoredProcName stored procedure to perform conflict resolution.\n+     * @param conflictResolutionStoredProcFullPath stored procedure full path to perform conflict resolution.\n      * @return ConflictResolutionPolicy.\n      */\n-    public static ConflictResolutionPolicy createCustomPolicy(String conflictResolutionStoredProcName) {\n+    public static ConflictResolutionPolicy createCustomPolicy(String conflictResolutionStoredProcFullPath) {", "originalCommit": "920df6c6ac31c5f6bc71cd6f8ddb33455e55641f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0NzMzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r540547339", "bodyText": "why do we need to provide this? if we have the other method:\npublic static ConflictResolutionPolicy createCustomPolicy(String dbName, String containerName, String sprocName) {", "author": "moderakh", "createdAt": "2020-12-10T22:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0Njg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NDM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18026#discussion_r540574391", "bodyText": "this will be breaking change,  createCustomPolicy(String conflictResolutionStoredProcName) is already public, we are just changing name of parameter for clarity , we can remove in V5.", "author": "simplynaveen20", "createdAt": "2020-12-10T23:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0Njg4Ng=="}], "type": "inlineReview"}]}