{"pr_number": 14597, "pr_title": "Handle OData property types", "pr_createdAt": "2020-08-28T23:21:54Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14597", "timeline": [{"oid": "5e7925cabe7a19fd65cda874f55335b2b86c3dcb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e7925cabe7a19fd65cda874f55335b2b86c3dcb", "message": "Add @odata.type properties in TableEntity.addProperty", "committedDate": "2020-08-29T00:26:58Z", "type": "forcePushed"}, {"oid": "cb8d2b6ec7c36ed34f36d17faad25a66ff5608f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cb8d2b6ec7c36ed34f36d17faad25a66ff5608f1", "message": "Add @odata.type properties in TableEntity.addProperty", "committedDate": "2020-08-29T01:03:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NjgyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r479886821", "bodyText": "I think the convention is valueOf", "author": "conniey", "createdAt": "2020-08-31T04:53:02Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/EntityDataModelType.java", "diffHunk": "@@ -0,0 +1,151 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables.implementation;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Entity Data Model (EDM) types\n+ */\n+public enum EntityDataModelType {\n+    /**\n+     * <strong>Edm.Binary</strong> Represents fixed- or variable-length binary data\n+     */\n+    BINARY(\"Edm.Binary\", Stream.of(byte[].class, Byte[].class), EntityDataModelUtil::parseEdmBinary),\n+\n+    /**\n+     * <strong>Edm.Boolean</strong> Represents the mathematical concept of binary-valued logic\n+     */\n+    BOOLEAN(\"Edm.Boolean\", Stream.of(boolean.class, Boolean.class), Boolean::parseBoolean),\n+\n+    /**\n+     * <strong>Edm.Byte</strong> Represents a unsigned 8-bit integer value\n+     */\n+    BYTE(\"Edm.Byte\", Collections.emptySet(), Short::parseShort), // No unsigned byte in Java\n+\n+    /**\n+     * <strong>Edm.DateTime</strong> Represents date and time with values ranging from 12:00:00 midnight, January 1,\n+     * 1753 A.D. through 11:59:59 P.M, December 9999 A.D.\n+     */\n+    DATE_TIME(\"Edm.DateTime\", Stream.of(LocalDateTime.class, LocalDate.class, Date.class), s ->\n+        DateTimeFormatter.ISO_DATE_TIME.parseBest(s, OffsetDateTime::from, LocalDateTime::from)),\n+\n+    /**\n+     * <strong>Edm.DateTimeOffset</strong> Represents date and time as an Offset in minutes from GMT, with values\n+     * ranging from 12:00:00 midnight, January 1, 1753 A.D. through 11:59:59 P.M, December 9999 A.D\n+     */\n+    DATE_TIME_OFFSET(\"Edm.DateTimeOffset\", Stream.of(OffsetDateTime.class, ZonedDateTime.class, Instant.class),\n+        OffsetDateTime::parse),\n+\n+    /**\n+     * <strong>Edm.Decimal</strong> Represents numeric values with fixed precision and scale. This type can describe a\n+     * numeric value ranging from negative 10^255 + 1 to positive 10^255 -1\n+     */\n+    DECIMAL(\"Edm.Decimal\", Collections.singleton(BigDecimal.class), BigDecimal::new),\n+\n+    /**\n+     * <strong>Edm.Double</strong> Represents a floating point number with 15 digits precision that can represent values\n+     * with approximate range of +/- 2.23e -308 through +/- 1.79e +308\n+     */\n+    DOUBLE(\"Edm.Double\", Stream.of(double.class, Double.class), Double::parseDouble),\n+\n+    /**\n+     * <strong>Edm.Single</strong> Represents a floating point number with 7 digits precision that can represent values\n+     * with approximate range of +/- 1.18e -38 through +/- 3.40e +38\n+     */\n+    SINGLE(\"Edm.Single\", Stream.of(float.class, Float.class), Float::parseFloat),\n+\n+    /**\n+     * <strong>Edm.Guid</strong> Represents a 16-byte (128-bit) unique identifier value\n+     */\n+    GUID(\"Edm.Guid\", Collections.singleton(UUID.class), UUID::fromString),\n+\n+    /**\n+     * <strong>Edm.Int16</strong> Represents a signed 16-bit integer value\n+     */\n+    INT16(\"Edm.Int16\", Stream.of(short.class, Short.class), Short::parseShort),\n+\n+    /**\n+     * <strong>Edm.Int32</strong> Represents a signed 32-bit integer value\n+     */\n+    INT32(\"Edm.Int32\", Stream.of(int.class, Integer.class), Integer::parseInt),\n+\n+    /**\n+     * <strong>Edm.Int64</strong> Represents a signed 64-bit integer value\n+     */\n+    INT64(\"Edm.Int64\", Stream.of(long.class, Long.class), Long::parseLong),\n+\n+    /**\n+     * <strong>Edm.SByte</strong> Represents a signed 8-bit integer value\n+     */\n+    SBYTE(\"Edm.SByte\", Stream.of(byte.class, Byte.class), Byte::parseByte),\n+\n+    /**\n+     * <strong>Edm.String</strong> Represents fixed- or variable-length character data\n+     */\n+    STRING(\"Edm.String\", Collections.singleton(String.class), s -> s),\n+\n+    /**\n+     * <strong>Edm.Time</strong> Represents the time of day with values ranging from 0:00:00.x to 23:59:59.y, where x\n+     * and y depend upon the precision\n+     */\n+    TIME(\"Edm.Time\", Stream.of(LocalTime.class, OffsetTime.class), s ->\n+        DateTimeFormatter.ISO_DATE_TIME.parseBest(s, OffsetTime::from, LocalTime::from)\n+    );\n+\n+    private final String edmType;\n+    private final Set<Class<?>> serializeFrom;\n+    private final Function<String, Object> deserializer;\n+\n+    EntityDataModelType(String edmType, Set<Class<?>> serializeFrom, Function<String, Object> deserializer) {\n+        this.edmType = edmType;\n+        this.serializeFrom = serializeFrom;\n+        this.deserializer = deserializer;\n+    }\n+\n+    EntityDataModelType(String edmType, Stream<Class<?>> serializeFrom, Function<String, Object> deserializer) {\n+        this(edmType, (Set<Class<?>>) serializeFrom.collect(Collectors.toCollection(HashSet::new)), deserializer);\n+    }\n+\n+    public static EntityDataModelType parse(String edmType) {", "originalCommit": "cb8d2b6ec7c36ed34f36d17faad25a66ff5608f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI2NTY2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r480265661", "bodyText": "There is already a valueOf(String) method which is provided automatically for all Enums, but it takes the string value of the enum literal (and loads it by reflection). E.g. \"BINARY\". I would be open to other names for this method though.", "author": "bsiegel", "createdAt": "2020-08-31T17:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NjgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1ODgwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r480358806", "bodyText": "Resolved by changing to fromString which matches what Autorest does.", "author": "bsiegel", "createdAt": "2020-08-31T19:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NjgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NzU4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r479887586", "bodyText": "I think this can be made static. It doesn't rely on any state in the class, iirc.i", "author": "conniey", "createdAt": "2020-08-31T04:56:23Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesJacksonSerializer.java", "diffHunk": "@@ -27,71 +25,117 @@\n public class TablesJacksonSerializer extends JacksonAdapter {\n     private final ClientLogger logger = new ClientLogger(TablesJacksonSerializer.class);\n \n-    @Override\n-    public String serialize(Object object, SerializerEncoding serializerEncoding) throws IOException {\n-        return super.serialize(object, serializerEncoding);\n-    }\n-\n-    @Override\n-    public String serializeRaw(Object object) {\n-        return super.serializeRaw(object);\n-    }\n-\n-    @Override\n-    public String serializeList(List<?> list, CollectionFormat format) {\n-        return super.serializeList(list, format);\n-    }\n-\n     @Override\n     public <U> U deserialize(String value, Type type, SerializerEncoding serializerEncoding) throws IOException {\n-        return deserialize(new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8)), type, serializerEncoding);\n+        if (type == TableEntityQueryResponse.class) {\n+            return deserialize(new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8)), type,\n+                serializerEncoding);\n+        } else {\n+            return super.deserialize(value, type, serializerEncoding);\n+        }\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public <U> U deserialize(InputStream inputStream, Type type, SerializerEncoding serializerEncoding)\n         throws IOException {\n-        if (type != TableEntityQueryResponse.class) {\n+        if (type == TableEntityQueryResponse.class) {\n+            return deserializeTableEntityQueryResponse(inputStream);\n+        } else {\n             return super.deserialize(inputStream, type, serializerEncoding);\n         }\n+    }\n \n-        // Force to deserialize as a Map by using Object.class\n+    @SuppressWarnings(\"unchecked\")\n+    private <U> U deserializeTableEntityQueryResponse(InputStream inputStream) throws IOException {\n         String odataMetadata = null;\n         List<Map<String, Object>> values = new ArrayList<>();\n \n+        // Represents the entries in the response. It's possible that it is a single or multiple response.\n         final JsonNode node = super.serializer().readTree(inputStream);\n-        final Map<String, Object> rootObject = new HashMap<>();\n+        Map<String, Object> singleValue = null;\n+\n         for (Iterator<Map.Entry<String, JsonNode>> it = node.fields(); it.hasNext();) {\n             final Map.Entry<String, JsonNode> entry = it.next();\n+            final String fieldName = entry.getKey();\n             final JsonNode childNode = entry.getValue();\n \n-            if (entry.getKey().equals(TableConstants.ODATA_METADATA_KEY)) {\n+            if (fieldName.equals(TablesConstants.ODATA_METADATA_KEY)) {\n                 odataMetadata = childNode.asText();\n-                continue;\n-            }\n-\n-            // Represents the entries in the response. It's possible that it is a single or multiple response.\n-            if (entry.getKey().equals(\"value\")) {\n+            } else if (fieldName.equals(\"value\")) {\n                 if (childNode.isArray()) {\n-                    logger.info(\"Node is an array of items.\");\n+                    // This is a multiple-entity response.\n+                    for (JsonNode childEntry : childNode) {\n+                        values.add(getEntityFieldsAsMap(childEntry));\n+                    }\n+                } else {\n+                    // This is a single-entity response where the user just happened to use the key \"value\".\n+                    if (singleValue == null) {\n+                        singleValue = new HashMap<>();\n+                    }\n+                    singleValue.put(fieldName, getEntityFieldAsObject(node, fieldName));\n                 }\n-\n-                throw logger.logExceptionAsError(\n-                    new UnsupportedOperationException(\"Multiple return values not supported yet.\"));\n+            } else {\n+                // This is a single-entity response.\n+                if (singleValue == null) {\n+                    singleValue = new HashMap<>();\n+                }\n+                singleValue.put(fieldName, getEntityFieldAsObject(node, fieldName));\n             }\n-\n-            rootObject.put(entry.getKey(), entry.getValue().asText());\n         }\n \n-        values.add(0, rootObject);\n+        if (singleValue != null) {\n+            if (values.size() > 0) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Unexpected response format. Response containing a 'value' array must not contain other properties.\"\n+                ));\n+            }\n+            values.add(singleValue);\n+        }\n \n         return (U) new TableEntityQueryResponse()\n             .setOdataMetadata(odataMetadata)\n             .setValue(values);\n     }\n \n-    @Override\n-    public <U> U deserialize(HttpHeaders httpHeaders, Type type) throws IOException {\n-        return super.deserialize(httpHeaders, type);\n+    private Map<String, Object> getEntityFieldsAsMap(JsonNode node) {", "originalCommit": "cb8d2b6ec7c36ed34f36d17faad25a66ff5608f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1NjY2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r480356661", "bodyText": "Definitely doable, but I would have to have a static logger for those methods and I'd prefer to reuse the existing logger unless there's a significant benefit to using static methods here.", "author": "bsiegel", "createdAt": "2020-08-31T19:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NzU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4ODAzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r479888038", "bodyText": "The multi nested if loops is hard to reason about.. is it possible to flatten it and return early?\nif (TablesConstants.METADATA_KEYS.contains(fieldName) ....  ) {\n   return valueNode.asText();\n}", "author": "conniey", "createdAt": "2020-08-31T04:58:27Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesJacksonSerializer.java", "diffHunk": "@@ -27,71 +25,117 @@\n public class TablesJacksonSerializer extends JacksonAdapter {\n     private final ClientLogger logger = new ClientLogger(TablesJacksonSerializer.class);\n \n-    @Override\n-    public String serialize(Object object, SerializerEncoding serializerEncoding) throws IOException {\n-        return super.serialize(object, serializerEncoding);\n-    }\n-\n-    @Override\n-    public String serializeRaw(Object object) {\n-        return super.serializeRaw(object);\n-    }\n-\n-    @Override\n-    public String serializeList(List<?> list, CollectionFormat format) {\n-        return super.serializeList(list, format);\n-    }\n-\n     @Override\n     public <U> U deserialize(String value, Type type, SerializerEncoding serializerEncoding) throws IOException {\n-        return deserialize(new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8)), type, serializerEncoding);\n+        if (type == TableEntityQueryResponse.class) {\n+            return deserialize(new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8)), type,\n+                serializerEncoding);\n+        } else {\n+            return super.deserialize(value, type, serializerEncoding);\n+        }\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public <U> U deserialize(InputStream inputStream, Type type, SerializerEncoding serializerEncoding)\n         throws IOException {\n-        if (type != TableEntityQueryResponse.class) {\n+        if (type == TableEntityQueryResponse.class) {\n+            return deserializeTableEntityQueryResponse(inputStream);\n+        } else {\n             return super.deserialize(inputStream, type, serializerEncoding);\n         }\n+    }\n \n-        // Force to deserialize as a Map by using Object.class\n+    @SuppressWarnings(\"unchecked\")\n+    private <U> U deserializeTableEntityQueryResponse(InputStream inputStream) throws IOException {\n         String odataMetadata = null;\n         List<Map<String, Object>> values = new ArrayList<>();\n \n+        // Represents the entries in the response. It's possible that it is a single or multiple response.\n         final JsonNode node = super.serializer().readTree(inputStream);\n-        final Map<String, Object> rootObject = new HashMap<>();\n+        Map<String, Object> singleValue = null;\n+\n         for (Iterator<Map.Entry<String, JsonNode>> it = node.fields(); it.hasNext();) {\n             final Map.Entry<String, JsonNode> entry = it.next();\n+            final String fieldName = entry.getKey();\n             final JsonNode childNode = entry.getValue();\n \n-            if (entry.getKey().equals(TableConstants.ODATA_METADATA_KEY)) {\n+            if (fieldName.equals(TablesConstants.ODATA_METADATA_KEY)) {\n                 odataMetadata = childNode.asText();\n-                continue;\n-            }\n-\n-            // Represents the entries in the response. It's possible that it is a single or multiple response.\n-            if (entry.getKey().equals(\"value\")) {\n+            } else if (fieldName.equals(\"value\")) {\n                 if (childNode.isArray()) {\n-                    logger.info(\"Node is an array of items.\");\n+                    // This is a multiple-entity response.\n+                    for (JsonNode childEntry : childNode) {\n+                        values.add(getEntityFieldsAsMap(childEntry));\n+                    }\n+                } else {\n+                    // This is a single-entity response where the user just happened to use the key \"value\".\n+                    if (singleValue == null) {\n+                        singleValue = new HashMap<>();\n+                    }\n+                    singleValue.put(fieldName, getEntityFieldAsObject(node, fieldName));\n                 }\n-\n-                throw logger.logExceptionAsError(\n-                    new UnsupportedOperationException(\"Multiple return values not supported yet.\"));\n+            } else {\n+                // This is a single-entity response.\n+                if (singleValue == null) {\n+                    singleValue = new HashMap<>();\n+                }\n+                singleValue.put(fieldName, getEntityFieldAsObject(node, fieldName));\n             }\n-\n-            rootObject.put(entry.getKey(), entry.getValue().asText());\n         }\n \n-        values.add(0, rootObject);\n+        if (singleValue != null) {\n+            if (values.size() > 0) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Unexpected response format. Response containing a 'value' array must not contain other properties.\"\n+                ));\n+            }\n+            values.add(singleValue);\n+        }\n \n         return (U) new TableEntityQueryResponse()\n             .setOdataMetadata(odataMetadata)\n             .setValue(values);\n     }\n \n-    @Override\n-    public <U> U deserialize(HttpHeaders httpHeaders, Type type) throws IOException {\n-        return super.deserialize(httpHeaders, type);\n+    private Map<String, Object> getEntityFieldsAsMap(JsonNode node) {\n+        Map<String, Object> result = new HashMap<>();\n+        for (Iterator<String> it = node.fieldNames(); it.hasNext();) {\n+            String fieldName = it.next();\n+            result.put(fieldName, getEntityFieldAsObject(node, fieldName));\n+\n+            // If there is a field with \"<name>@odata.type\" = \"Null\",\n+            // we need to insert a property with \"<name>\" = null.\n+            if (fieldName.endsWith(TablesConstants.ODATA_TYPE_KEY_SUFFIX)\n+                && TablesConstants.ODATA_TYPE_NULL.equals(node.get(fieldName).asText())) {\n+\n+                String nullFieldName = fieldName.substring(0, fieldName.length()\n+                    - TablesConstants.ODATA_TYPE_KEY_SUFFIX.length());\n+                result.put(nullFieldName, null);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private Object getEntityFieldAsObject(JsonNode parentNode, String fieldName) {\n+        JsonNode valueNode = parentNode.get(fieldName);\n+        if (!TablesConstants.METADATA_KEYS.contains(fieldName)", "originalCommit": "cb8d2b6ec7c36ed34f36d17faad25a66ff5608f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1NTc3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r480355772", "bodyText": "Fixed", "author": "bsiegel", "createdAt": "2020-08-31T19:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4ODAzOA=="}], "type": "inlineReview"}, {"oid": "e48b4f8af10bd7cd7fc48cda43d2f159ae5f9ace", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e48b4f8af10bd7cd7fc48cda43d2f159ae5f9ace", "message": "Rename parse to fromString", "committedDate": "2020-08-31T19:41:44Z", "type": "forcePushed"}, {"oid": "91d432dc3d0593e3eb63a005c7e5c312a78488e6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/91d432dc3d0593e3eb63a005c7e5c312a78488e6", "message": "Add OData type test", "committedDate": "2020-09-01T09:12:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzOTcyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r481339721", "bodyText": "Does that mean we can just delete the other serializer now?", "author": "conniey", "createdAt": "2020-09-01T18:16:16Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableServiceClientBuilder.java", "diffHunk": "@@ -29,7 +29,7 @@\n @ServiceClientBuilder(serviceClients = {TableServiceClient.class, TableServiceAsyncClient.class})\n public class TableServiceClientBuilder {\n     private final ClientLogger logger = new ClientLogger(TableServiceClientBuilder.class);\n-    private final SerializerAdapter serializerAdapter = new TablesJacksonSerializer();\n+    private final SerializerAdapter serializerAdapter = new JacksonAdapter();", "originalCommit": "91d432dc3d0593e3eb63a005c7e5c312a78488e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0NjY1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r481346654", "bodyText": "No, we still need it for the TableClient, but the TableServiceClient doesn't need any customization so it can just use the default JacksonAdapter.", "author": "bsiegel", "createdAt": "2020-09-01T18:28:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzOTcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0Njk3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r481346979", "bodyText": "Sweet thanks! I think there is a static method they use a lot SerializerAdapter.createDefault() to get whatever the default is.", "author": "conniey", "createdAt": "2020-09-01T18:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzOTcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5ODQ2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14597#discussion_r481498460", "bodyText": "Fixed", "author": "bsiegel", "createdAt": "2020-09-02T00:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzOTcyMQ=="}], "type": "inlineReview"}, {"oid": "6462818e28a0d73d151f7f482f82c470a3b7ac6c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6462818e28a0d73d151f7f482f82c470a3b7ac6c", "message": "Handle OData types when deserializing", "committedDate": "2020-09-02T00:05:53Z", "type": "commit"}, {"oid": "07d853581992e836733aad836055da55e02644dc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/07d853581992e836733aad836055da55e02644dc", "message": "Insert OData metadata properties when serializing", "committedDate": "2020-09-02T00:05:53Z", "type": "commit"}, {"oid": "734bf07838b5e2c31ca63138dd44bff043efa392", "url": "https://github.com/Azure/azure-sdk-for-java/commit/734bf07838b5e2c31ca63138dd44bff043efa392", "message": "Add OData type test", "committedDate": "2020-09-02T00:05:53Z", "type": "commit"}, {"oid": "734bf07838b5e2c31ca63138dd44bff043efa392", "url": "https://github.com/Azure/azure-sdk-for-java/commit/734bf07838b5e2c31ca63138dd44bff043efa392", "message": "Add OData type test", "committedDate": "2020-09-02T00:05:53Z", "type": "forcePushed"}]}