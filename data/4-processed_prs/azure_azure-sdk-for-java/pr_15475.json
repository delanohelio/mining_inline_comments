{"pr_number": 15475, "pr_title": "Mgmt: update Samples and migration guide", "pr_createdAt": "2020-09-22T07:24:48Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/15475", "timeline": [{"oid": "93e31ccbd8536e64e87b2c4b659110e1ea1fd268", "url": "https://github.com/Azure/azure-sdk-for-java/commit/93e31ccbd8536e64e87b2c4b659110e1ea1fd268", "message": "update sample in migration guide", "committedDate": "2020-09-22T07:12:40Z", "type": "commit"}, {"oid": "1ab3a03b332eee45af73398174ac59121cf9d38a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1ab3a03b332eee45af73398174ac59121cf9d38a", "message": "update migration guide", "committedDate": "2020-09-22T07:22:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUyMzcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15475#discussion_r492523711", "bodyText": "Will update it after this PR merged.", "author": "ChenTanyi", "createdAt": "2020-09-22T07:25:09Z", "path": "sdk/resourcemanager/docs/MIGRATION_GUIDE.md", "diffHunk": "@@ -170,113 +170,95 @@ In new version (`com.azure.resourcemanager.**`), we have adopted `Reactor` as th\n **In old version (`com.microsoft.azure.management.**`)**\n \n ```java\n-azure.publicIPAddresses()\n-    .define(publicIpName)\n-    .withRegion(region)\n-    .withExistingResourceGroup(rgName)\n-    .withLeafDomainLabel(publicIpName)\n-    .createAsync().flatMap(new Func1 < Indexable, Observable < Indexable >> () {\n-        @Override\n-        public Observable < Indexable > call(Indexable indexable) {\n-            if (indexable instanceof PublicIPAddress) {\n-                PublicIPAddress publicIp = (PublicIPAddress) indexable;\n-                //=============================================================\n-                // Create an Internet facing load balancer with\n-                // One frontend IP address\n-                // Two backend address pools which contain network interfaces for the virtual\n-                //  machines to receive HTTP and HTTPS network traffic from the load balancer\n-                // Two load balancing rules for HTTP and HTTPS to map public ports on the load\n-                //  balancer to ports in the backend address pool\n-                // Two probes which contain HTTP and HTTPS health probes used to check availability\n-                //  of virtual machines in the backend address pool\n-                // Three inbound NAT rules which contain rules that map a public port on the load\n-                //  balancer to a port for a specific virtual machine in the backend address pool\n-                //  - this provides direct VM connectivity for SSH to port 22 and TELNET to port 23\n-                \n-                return Observable.merge(\n-                    Observable.just(indexable), azure.loadBalancers().define(loadBalancerName1).withRegion(region).withExistingResourceGroup(rgName)\n-                    // Add two rules that uses above backend and probe     \n-                    .defineLoadBalancingRule(httpLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(80).toBackend(backendPoolName1).withProbe(httpProbe).attach().defineLoadBalancingRule(httpsLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(443).toBackend(backendPoolName2).withProbe(httpsProbe).attach()\n-                    // Add nat pools to enable direct VM connectivity for\n-                    // SSH to port 22 and TELNET to port 23\n-\n-                    .defineInboundNatPool(natPool50XXto22).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(5000, 5099).toBackendPort(22).attach().defineInboundNatPool(natPool60XXto23).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(6000, 6099).toBackendPort(23).attach()\n-\n-                    // Explicitly define the frontend\n-                    .definePublicFrontend(frontendName).withExistingPublicIPAddress(publicIp).attach\n-\n-                    // Add two probes one per rule\n-                    .defineHttpProbe(httpProbe).withRequestPath(\"/\").withPort(80).attach().defineHttpProbe(httpsProbe).withRequestPath(\"/\").withPort(443).attach()\n-                    .createAsync());\n+Observable.merge(\n+    azure.networks().define(vnetName)\n+        .withRegion(region)\n+        .withNewResourceGroup(rgName)\n+        .withAddressSpace(\"172.16.0.0/16\")\n+        .defineSubnet(\"Front-end\").withAddressPrefix(\"172.16.1.0/24\").attach()\n+        .createAsync(),\n+    azure.publicIPAddresses().define(publicIpName)\n+        .withRegion(region)\n+        .withExistingResourceGroup(rgName)\n+        .withLeafDomainLabel(publicIpName)\n+        .createAsync()\n+        .flatMap(new Func1<Indexable, Observable<Indexable>>() {\n+            @Override\n+            public Observable<Indexable> call(Indexable indexable) {\n+                if (indexable instanceof PublicIPAddress) {\n+                    PublicIPAddress publicIp = (PublicIPAddress) indexable;\n+                    return Observable.merge(\n+                        Observable.just(indexable),\n+                        azure.loadBalancers().define(loadBalancerName1)\n+                            .withRegion(region)\n+                            .withExistingResourceGroup(rgName)\n+                            // Add two rules that uses above backend and probe\n+                            .defineLoadBalancingRule(httpLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(80).toBackend(backendPoolName1).withProbe(httpProbe).attach()\n+                            .defineLoadBalancingRule(httpsLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(443).toBackend(backendPoolName2).withProbe(httpsProbe).attach()\n+                            // Add nat pools to enable direct VM connectivity for SSH to port 22 and TELNET to port 23\n+                            .defineInboundNatPool(natPool50XXto22).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(5000, 5099).toBackendPort(22).attach()\n+                            .defineInboundNatPool(natPool60XXto23).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(6000, 6099).toBackendPort(23).attach()\n+                            // Explicitly define the frontend\n+                            .definePublicFrontend(frontendName).withExistingPublicIPAddress(publicIp).attach()\n+                            // Add two probes one per rule\n+                            .defineHttpProbe(httpProbe).withRequestPath(\"/\").withPort(80).attach()\n+                            .defineHttpProbe(httpsProbe).withRequestPath(\"/\").withPort(443).attach()\n+                            .createAsync());\n+                }\n+                return Observable.just(indexable);\n             }\n-            return Observable.just(indexable);\n-        }\n-    })).toBlocking().subscribe(new Action1 < Indexable > () {\n+        }))\n+.toBlocking()\n+.subscribe(new Action1<Indexable>() {\n     @Override\n     public void call(Indexable indexable) {\n         createdResources.add(indexable);\n     }\n });\n ``` \n \n-[**Link to full sample**](https://github.com/Azure/azure-libraries-for-java/blob/master/azure-samples/src/main/java/com/microsoft/azure/management/compute/samples/ManageVirtualMachineScaleSetAsync.java#L100)\n+[**Link to full sample**](https://github.com/Azure/azure-libraries-for-java/blob/master/azure-samples/src/main/java/com/microsoft/azure/management/compute/samples/ManageVirtualMachineScaleSetAsync.java#L91)\n       \n \n **Equivalent in new version (`com.azure.resourcemanager.**`)**\n \n ```java\n-final List < Indexable > createdResources = new ArrayList < > ();\n+final List<Object> createdResources = new ArrayList<>();\n azure.resourceGroups().define(rgName).withRegion(region).create();\n Flux.merge(\n-    azure.networks()\n-    .define(vnetName)\n-    .withRegion(region)\n-    .withExistingResourceGroup(rgName)\n-    .withAddressSpace(\"172.16.0.0/16\")\n-    .defineSubnet(\"Front-end\")\n-    .withAddressPrefix(\"172.16.1.0/24\")\n-    .attach()\n-    .createAsync(),\n-    azure.publicIpAddresses()\n-    .define(publicIpName)\n-    .withRegion(region)\n-    .withExistingResourceGroup(rgName)\n-    .withLeafDomainLabel(publicIpName)\n-    .createAsync().flatMap(indexable - > {\n-        if (indexable instanceof PublicIpAddress) {\n-            PublicIpAddress publicIp = (PublicIpAddress) indexable;\n-            //=============================================================\n-            // Create an Internet facing load balancer with\n-            // One frontend IP address\n-            // Two backend address pools which contain network interfaces for the virtual\n-            //  machines to receive HTTP and HTTPS network traffic from the load balancer\n-            // Two load balancing rules for HTTP and HTTPS to map public ports on the load\n-            //  balancer to ports in the backend address pool\n-            // Two probes which contain HTTP and HTTPS health probes used to check availability\n-            //  of virtual machines in the backend address pool\n-            // Three inbound NAT rules which contain rules that map a public port on the load\n-            //  balancer to a port for a specific virtual machine in the backend address pool\n-            //  - this provides direct VM connectivity for SSH to port 22 and TELNET to port 23\n-            \n+    azureResourceManager.networks().define(vnetName)\n+        .withRegion(region)\n+        .withExistingResourceGroup(rgName)\n+        .withAddressSpace(\"172.16.0.0/16\")\n+        .defineSubnet(\"Front-end\").withAddressPrefix(\"172.16.1.0/24\").attach()\n+        .createAsync(),\n+    azureResourceManager.publicIpAddresses().define(publicIpName)\n+        .withRegion(region)\n+        .withExistingResourceGroup(rgName)\n+        .withLeafDomainLabel(publicIpName)\n+        .createAsync()\n+        .flatMapMany(publicIp -> {\n             return Flux.merge(\n-                Flux.just(indexable), azure.loadBalancers().define(loadBalancerName1).withRegion(region).withExistingResourceGroup(rgName)\n-                // Add two rules that uses above backend and probe\n-                .defineLoadBalancingRule(httpLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(80).toBackend(backendPoolName1).withProbe(httpProbe).attach().defineLoadBalancingRule(httpsLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(443).toBackend(backendPoolName2).withProbe(httpsProbe).attach()\n-                // Add nat pools to enable direct VM connectivity for\n-                //  SSH to port 22 and TELNET to port 23\n-                .defineInboundNatPool(natPool50XXto22).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(5000, 5099).toBackendPort(22).attach().defineInboundNatPool(natPool60XXto23).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(6000, 6099).toBackendPort(23).attach()\n-\n-                // Explicitly define the frontend\n-                .definePublicFrontend(frontendName).withExistingPublicIpAddress(publicIp).attach()\n-\n-                // Add two probes one per rule\n-                .defineHttpProbe(httpProbe).withRequestPath(\"/\").withPort(80).attach().defineHttpProbe(httpsProbe).withRequestPath(\"/\").withPort(443).attach().createAsync());\n-        }\n-        return Flux.just(indexable);\n-    })).flatMap(indexable - > {\n-    createdResources.add(indexable);\n-    return Flux.just(indexable);\n-}).last().block();\n+                Flux.just(publicIp),\n+                azureResourceManager.loadBalancers().define(loadBalancerName1)\n+                    .withRegion(region)\n+                    .withExistingResourceGroup(rgName)\n+                    // Add two rules that uses above backend and probe\n+                    .defineLoadBalancingRule(httpLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(80).toBackend(backendPoolName1).withProbe(httpProbe).attach()\n+                    .defineLoadBalancingRule(httpsLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(443).toBackend(backendPoolName2).withProbe(httpsProbe).attach()\n+                    // Add nat pools to enable direct VM connectivity for SSH to port 22 and TELNET to port 23\n+                    .defineInboundNatPool(natPool50XXto22).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(5000, 5099).toBackendPort(22).attach()\n+                    .defineInboundNatPool(natPool60XXto23).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(6000, 6099).toBackendPort(23).attach()\n+                    // Explicitly define the frontend\n+                    .definePublicFrontend(frontendName).withExistingPublicIpAddress(publicIp).attach()\n+                    // Add two probes one per rule\n+                    .defineHttpProbe(httpProbe).withRequestPath(\"/\").withPort(80).attach()\n+                    .defineHttpProbe(httpsProbe).withRequestPath(\"/\").withPort(443).attach()\n+                    .createAsync());\n+            })\n+)\n+.doOnNext(createdResources::add)\n+.blockLast();\n ```\n \n [**Link to full sample**](https://github.com/Azure/azure-sdk-for-java/blob/7beda69/sdk/management/samples/src/main/java/com/azure/resourcemanager/compute/samples/ManageVirtualMachineScaleSetAsync.java#L98)", "originalCommit": "1ab3a03b332eee45af73398174ac59121cf9d38a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIwNzYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15475#discussion_r493207609", "bodyText": "azure or azureResourceManager?", "author": "weidongxu-microsoft", "createdAt": "2020-09-23T05:33:51Z", "path": "sdk/resourcemanager/docs/MIGRATION_GUIDE.md", "diffHunk": "@@ -170,113 +170,95 @@ In new version (`com.azure.resourcemanager.**`), we have adopted `Reactor` as th\n **In old version (`com.microsoft.azure.management.**`)**\n \n ```java\n-azure.publicIPAddresses()\n-    .define(publicIpName)\n-    .withRegion(region)\n-    .withExistingResourceGroup(rgName)\n-    .withLeafDomainLabel(publicIpName)\n-    .createAsync().flatMap(new Func1 < Indexable, Observable < Indexable >> () {\n-        @Override\n-        public Observable < Indexable > call(Indexable indexable) {\n-            if (indexable instanceof PublicIPAddress) {\n-                PublicIPAddress publicIp = (PublicIPAddress) indexable;\n-                //=============================================================\n-                // Create an Internet facing load balancer with\n-                // One frontend IP address\n-                // Two backend address pools which contain network interfaces for the virtual\n-                //  machines to receive HTTP and HTTPS network traffic from the load balancer\n-                // Two load balancing rules for HTTP and HTTPS to map public ports on the load\n-                //  balancer to ports in the backend address pool\n-                // Two probes which contain HTTP and HTTPS health probes used to check availability\n-                //  of virtual machines in the backend address pool\n-                // Three inbound NAT rules which contain rules that map a public port on the load\n-                //  balancer to a port for a specific virtual machine in the backend address pool\n-                //  - this provides direct VM connectivity for SSH to port 22 and TELNET to port 23\n-                \n-                return Observable.merge(\n-                    Observable.just(indexable), azure.loadBalancers().define(loadBalancerName1).withRegion(region).withExistingResourceGroup(rgName)\n-                    // Add two rules that uses above backend and probe     \n-                    .defineLoadBalancingRule(httpLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(80).toBackend(backendPoolName1).withProbe(httpProbe).attach().defineLoadBalancingRule(httpsLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(443).toBackend(backendPoolName2).withProbe(httpsProbe).attach()\n-                    // Add nat pools to enable direct VM connectivity for\n-                    // SSH to port 22 and TELNET to port 23\n-\n-                    .defineInboundNatPool(natPool50XXto22).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(5000, 5099).toBackendPort(22).attach().defineInboundNatPool(natPool60XXto23).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(6000, 6099).toBackendPort(23).attach()\n-\n-                    // Explicitly define the frontend\n-                    .definePublicFrontend(frontendName).withExistingPublicIPAddress(publicIp).attach\n-\n-                    // Add two probes one per rule\n-                    .defineHttpProbe(httpProbe).withRequestPath(\"/\").withPort(80).attach().defineHttpProbe(httpsProbe).withRequestPath(\"/\").withPort(443).attach()\n-                    .createAsync());\n+Observable.merge(\n+    azure.networks().define(vnetName)\n+        .withRegion(region)\n+        .withNewResourceGroup(rgName)\n+        .withAddressSpace(\"172.16.0.0/16\")\n+        .defineSubnet(\"Front-end\").withAddressPrefix(\"172.16.1.0/24\").attach()\n+        .createAsync(),\n+    azure.publicIPAddresses().define(publicIpName)\n+        .withRegion(region)\n+        .withExistingResourceGroup(rgName)\n+        .withLeafDomainLabel(publicIpName)\n+        .createAsync()\n+        .flatMap(new Func1<Indexable, Observable<Indexable>>() {\n+            @Override\n+            public Observable<Indexable> call(Indexable indexable) {\n+                if (indexable instanceof PublicIPAddress) {\n+                    PublicIPAddress publicIp = (PublicIPAddress) indexable;\n+                    return Observable.merge(\n+                        Observable.just(indexable),\n+                        azure.loadBalancers().define(loadBalancerName1)\n+                            .withRegion(region)\n+                            .withExistingResourceGroup(rgName)\n+                            // Add two rules that uses above backend and probe\n+                            .defineLoadBalancingRule(httpLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(80).toBackend(backendPoolName1).withProbe(httpProbe).attach()\n+                            .defineLoadBalancingRule(httpsLoadBalancingRule).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPort(443).toBackend(backendPoolName2).withProbe(httpsProbe).attach()\n+                            // Add nat pools to enable direct VM connectivity for SSH to port 22 and TELNET to port 23\n+                            .defineInboundNatPool(natPool50XXto22).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(5000, 5099).toBackendPort(22).attach()\n+                            .defineInboundNatPool(natPool60XXto23).withProtocol(TransportProtocol.TCP).fromFrontend(frontendName).fromFrontendPortRange(6000, 6099).toBackendPort(23).attach()\n+                            // Explicitly define the frontend\n+                            .definePublicFrontend(frontendName).withExistingPublicIPAddress(publicIp).attach()\n+                            // Add two probes one per rule\n+                            .defineHttpProbe(httpProbe).withRequestPath(\"/\").withPort(80).attach()\n+                            .defineHttpProbe(httpsProbe).withRequestPath(\"/\").withPort(443).attach()\n+                            .createAsync());\n+                }\n+                return Observable.just(indexable);\n             }\n-            return Observable.just(indexable);\n-        }\n-    })).toBlocking().subscribe(new Action1 < Indexable > () {\n+        }))\n+.toBlocking()\n+.subscribe(new Action1<Indexable>() {\n     @Override\n     public void call(Indexable indexable) {\n         createdResources.add(indexable);\n     }\n });\n ``` \n \n-[**Link to full sample**](https://github.com/Azure/azure-libraries-for-java/blob/master/azure-samples/src/main/java/com/microsoft/azure/management/compute/samples/ManageVirtualMachineScaleSetAsync.java#L100)\n+[**Link to full sample**](https://github.com/Azure/azure-libraries-for-java/blob/master/azure-samples/src/main/java/com/microsoft/azure/management/compute/samples/ManageVirtualMachineScaleSetAsync.java#L91)\n       \n \n **Equivalent in new version (`com.azure.resourcemanager.**`)**\n \n ```java\n-final List < Indexable > createdResources = new ArrayList < > ();\n+final List<Object> createdResources = new ArrayList<>();\n azure.resourceGroups().define(rgName).withRegion(region).create();", "originalCommit": "1ab3a03b332eee45af73398174ac59121cf9d38a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0402da6682d7ca492ecb3cacd3a920fb72465847", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0402da6682d7ca492ecb3cacd3a920fb72465847", "message": "change azureResourceManager to azure", "committedDate": "2020-09-23T05:39:04Z", "type": "commit"}, {"oid": "edc5aaa83ee630d1e7cfd49fd034bef53c067637", "url": "https://github.com/Azure/azure-sdk-for-java/commit/edc5aaa83ee630d1e7cfd49fd034bef53c067637", "message": "Merge branch 'master' into samples", "committedDate": "2020-09-23T05:49:44Z", "type": "commit"}]}