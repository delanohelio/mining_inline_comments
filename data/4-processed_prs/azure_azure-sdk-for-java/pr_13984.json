{"pr_number": 13984, "pr_title": "Adds support for auto-lock renewal.", "pr_createdAt": "2020-08-11T17:53:30Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/13984", "timeline": [{"oid": "504317f62ed5dab91deab4f229ccaf6a8be5a7ac", "url": "https://github.com/Azure/azure-sdk-for-java/commit/504317f62ed5dab91deab4f229ccaf6a8be5a7ac", "message": "Add LockRenewalOperation and LockRenewalStatus", "committedDate": "2020-08-08T04:46:37Z", "type": "commit"}, {"oid": "19e2f2e3836268e0a251354cc6e2904d4cc71da6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/19e2f2e3836268e0a251354cc6e2904d4cc71da6", "message": "Fixing bug in lock renewal where it could be negative.", "committedDate": "2020-08-08T17:54:57Z", "type": "commit"}, {"oid": "8765fdeca038a10c341d5b89af34db73fbce568e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8765fdeca038a10c341d5b89af34db73fbce568e", "message": "Fixing deprecated method call.", "committedDate": "2020-08-08T17:55:13Z", "type": "commit"}, {"oid": "ca191b5a7b5149cf0d5fbc948309511a51da42d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ca191b5a7b5149cf0d5fbc948309511a51da42d2", "message": "Adding lock renewal operation.", "committedDate": "2020-08-10T11:45:31Z", "type": "commit"}, {"oid": "90392d458fba98ae4d075e5f0c20ac4a1e3a3a75", "url": "https://github.com/Azure/azure-sdk-for-java/commit/90392d458fba98ae4d075e5f0c20ac4a1e3a3a75", "message": "Add test for zero renewal.", "committedDate": "2020-08-10T18:40:44Z", "type": "commit"}, {"oid": "c16bdbda6315ea6bade31256888cffff42f383f0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c16bdbda6315ea6bade31256888cffff42f383f0", "message": "Reuse LockRenewalOperation for UnnamedSessionReceiver.", "committedDate": "2020-08-10T21:28:04Z", "type": "commit"}, {"oid": "5e3246ea047ae4973e8f190a56db4c933759c1b7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e3246ea047ae4973e8f190a56db4c933759c1b7", "message": "Fixing subscription.", "committedDate": "2020-08-10T21:46:52Z", "type": "commit"}, {"oid": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "message": "Adding overload for public constructors.", "committedDate": "2020-08-11T17:51:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwNzg2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468807864", "bodyText": "It will be good to put some  embeded code samples in java doc on how to use this API.", "author": "hemanttanwar", "createdAt": "2020-08-11T19:15:11Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessageUtils;\n+import com.azure.messaging.servicebus.models.LockRenewalStatus;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoProcessor;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Represents a renewal session or message lock renewal operation that.\n+ */", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwOTUxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468809518", "bodyText": "Lock ->  Message lock : To make it clear that it is message lock.", "author": "hemanttanwar", "createdAt": "2020-08-11T19:18:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessageUtils;\n+import com.azure.messaging.servicebus.models.LockRenewalStatus;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoProcessor;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Represents a renewal session or message lock renewal operation that.\n+ */\n+public class LockRenewalOperation implements AutoCloseable {\n+    private final ClientLogger logger = new ClientLogger(LockRenewalOperation.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final AtomicReference<Instant> lockedUntil = new AtomicReference<>();\n+    private final AtomicReference<Throwable> throwable = new AtomicReference<>();\n+    private final AtomicReference<LockRenewalStatus> status = new AtomicReference<>(LockRenewalStatus.RUNNING);\n+    private final MonoProcessor<Void> cancellationProcessor = MonoProcessor.create();\n+\n+    private final String lockToken;\n+    private final boolean isSession;\n+    private final Function<String, Mono<Instant>> renewalOperation;\n+    private final Disposable subscription;\n+\n+    /**\n+     * Creates a new lock renewal operation. The lock is initially renewed.\n+     *\n+     * @param lockToken Lock or session id to renew.", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxMjQ2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468812461", "bodyText": "isZero() | isNegative() ?", "author": "hemanttanwar", "createdAt": "2020-08-11T19:23:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessageUtils;\n+import com.azure.messaging.servicebus.models.LockRenewalStatus;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoProcessor;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Represents a renewal session or message lock renewal operation that.\n+ */\n+public class LockRenewalOperation implements AutoCloseable {\n+    private final ClientLogger logger = new ClientLogger(LockRenewalOperation.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final AtomicReference<Instant> lockedUntil = new AtomicReference<>();\n+    private final AtomicReference<Throwable> throwable = new AtomicReference<>();\n+    private final AtomicReference<LockRenewalStatus> status = new AtomicReference<>(LockRenewalStatus.RUNNING);\n+    private final MonoProcessor<Void> cancellationProcessor = MonoProcessor.create();\n+\n+    private final String lockToken;\n+    private final boolean isSession;\n+    private final Function<String, Mono<Instant>> renewalOperation;\n+    private final Disposable subscription;\n+\n+    /**\n+     * Creates a new lock renewal operation. The lock is initially renewed.\n+     *\n+     * @param lockToken Lock or session id to renew.\n+     * @param maxLockRenewalDuration The maximum duration this lock should be renewed.\n+     * @param isSession Whether the lock represents a session lock or message lock.\n+     * @param renewalOperation The renewal operation to call.\n+     */\n+    LockRenewalOperation(String lockToken, Duration maxLockRenewalDuration, boolean isSession,\n+        Function<String, Mono<Instant>> renewalOperation) {\n+        this(lockToken, maxLockRenewalDuration, isSession, renewalOperation, Instant.now());\n+    }\n+\n+    /**\n+     * Creates a new lock renewal operation.\n+     *\n+     * @param lockToken Lock or session id to renew.\n+     * @param lockedUntil The initial period the message or session is locked until.\n+     * @param maxLockRenewalDuration The maximum duration this lock should be renewed.\n+     * @param isSession Whether the lock represents a session lock or message lock.\n+     * @param renewalOperation The renewal operation to call.\n+     */\n+    LockRenewalOperation(String lockToken, Duration maxLockRenewalDuration, boolean isSession,\n+        Function<String, Mono<Instant>> renewalOperation, Instant lockedUntil) {\n+        this.lockToken = Objects.requireNonNull(lockToken, \"'lockToken' cannot be null.\");\n+        this.renewalOperation = Objects.requireNonNull(renewalOperation, \"'renewalOperation' cannot be null.\");\n+        this.isSession = isSession;\n+\n+        Objects.requireNonNull(lockedUntil, \"'lockedUntil cannot be null.'\");\n+        Objects.requireNonNull(maxLockRenewalDuration, \"'maxLockRenewalDuration' cannot be null.\");\n+\n+        if (maxLockRenewalDuration.isNegative()) {\n+            throw logger.logThrowableAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' cannot be negative.\"));\n+        }\n+\n+        this.lockedUntil.set(lockedUntil);\n+        this.subscription = getRenewLockOperation(lockedUntil, maxLockRenewalDuration);\n+    }\n+\n+    /**\n+     * Gets the current instant the message or session is locked until.\n+     *\n+     * @return the instant the message or session is locked until.\n+     */\n+    public Instant getLockedUntil() {\n+        return lockedUntil.get();\n+    }\n+\n+    /**\n+     * Gets the message lock token for the renewal operation.\n+     *\n+     * @return The message lock token or {@code null} if a session is being renewed instead.\n+     */\n+    public String getLockToken() {\n+        return isSession ? null : lockToken;\n+    }\n+\n+    /**\n+     * Gets the session id for this lock renewal operation.\n+     *\n+     * @return The session id or {@code null} if it is not a session renewal.\n+     */\n+    public String getSessionId() {\n+        return isSession ? lockToken : null;\n+    }\n+\n+    /**\n+     * Gets the current status of the renewal operation.\n+     *\n+     * @return The current status of the renewal operation.\n+     */\n+    public LockRenewalStatus getStatus() {\n+        return status.get();\n+    }\n+\n+    /**\n+     * Gets the exception if an error occurred whilst renewing the message or session lock.\n+     *\n+     * @return the exception if an error occurred whilst renewing the message or session lock, otherwise {@code null}.\n+     */\n+    public Throwable getThrowable() {\n+        return throwable.get();\n+    }\n+\n+    /**\n+     * Cancels the lock renewal operation.\n+     */\n+    @Override\n+    public void close() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+\n+        if (status.compareAndSet(LockRenewalStatus.RUNNING, LockRenewalStatus.CANCELLED)) {\n+            logger.verbose(\"token[{}] Cancelled operation.\", lockToken);\n+        }\n+\n+        cancellationProcessor.onComplete();\n+        subscription.dispose();\n+    }\n+\n+    /**\n+     * Gets the lock renewal operation. if the {@code maxLockRenewalDuration} is {@link Duration#isZero()}, then the\n+     * lock is never renewed.\n+     *\n+     * @param initialLockedUntil When the initial call is locked until.\n+     * @param maxLockRenewalDuration Duration to renew lock for.\n+     * @return The subscription for the operation.\n+     */\n+    private Disposable getRenewLockOperation(Instant initialLockedUntil, Duration maxLockRenewalDuration) {\n+        if (maxLockRenewalDuration.isZero()) {", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MjU3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468842577", "bodyText": "IsNegative is an invalid operation. I'll throw before it even gets here.", "author": "conniey", "createdAt": "2020-08-11T20:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxMjQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxNDMxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468814314", "bodyText": "is this messaging correct ?, the lockToken can be for Message Lock or session id.", "author": "hemanttanwar", "createdAt": "2020-08-11T19:27:33Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessageUtils;\n+import com.azure.messaging.servicebus.models.LockRenewalStatus;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoProcessor;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Represents a renewal session or message lock renewal operation that.\n+ */\n+public class LockRenewalOperation implements AutoCloseable {\n+    private final ClientLogger logger = new ClientLogger(LockRenewalOperation.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final AtomicReference<Instant> lockedUntil = new AtomicReference<>();\n+    private final AtomicReference<Throwable> throwable = new AtomicReference<>();\n+    private final AtomicReference<LockRenewalStatus> status = new AtomicReference<>(LockRenewalStatus.RUNNING);\n+    private final MonoProcessor<Void> cancellationProcessor = MonoProcessor.create();\n+\n+    private final String lockToken;\n+    private final boolean isSession;\n+    private final Function<String, Mono<Instant>> renewalOperation;\n+    private final Disposable subscription;\n+\n+    /**\n+     * Creates a new lock renewal operation. The lock is initially renewed.\n+     *\n+     * @param lockToken Lock or session id to renew.\n+     * @param maxLockRenewalDuration The maximum duration this lock should be renewed.\n+     * @param isSession Whether the lock represents a session lock or message lock.\n+     * @param renewalOperation The renewal operation to call.\n+     */\n+    LockRenewalOperation(String lockToken, Duration maxLockRenewalDuration, boolean isSession,\n+        Function<String, Mono<Instant>> renewalOperation) {\n+        this(lockToken, maxLockRenewalDuration, isSession, renewalOperation, Instant.now());\n+    }\n+\n+    /**\n+     * Creates a new lock renewal operation.\n+     *\n+     * @param lockToken Lock or session id to renew.\n+     * @param lockedUntil The initial period the message or session is locked until.\n+     * @param maxLockRenewalDuration The maximum duration this lock should be renewed.\n+     * @param isSession Whether the lock represents a session lock or message lock.\n+     * @param renewalOperation The renewal operation to call.\n+     */\n+    LockRenewalOperation(String lockToken, Duration maxLockRenewalDuration, boolean isSession,\n+        Function<String, Mono<Instant>> renewalOperation, Instant lockedUntil) {\n+        this.lockToken = Objects.requireNonNull(lockToken, \"'lockToken' cannot be null.\");\n+        this.renewalOperation = Objects.requireNonNull(renewalOperation, \"'renewalOperation' cannot be null.\");\n+        this.isSession = isSession;\n+\n+        Objects.requireNonNull(lockedUntil, \"'lockedUntil cannot be null.'\");\n+        Objects.requireNonNull(maxLockRenewalDuration, \"'maxLockRenewalDuration' cannot be null.\");\n+\n+        if (maxLockRenewalDuration.isNegative()) {\n+            throw logger.logThrowableAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' cannot be negative.\"));\n+        }\n+\n+        this.lockedUntil.set(lockedUntil);\n+        this.subscription = getRenewLockOperation(lockedUntil, maxLockRenewalDuration);\n+    }\n+\n+    /**\n+     * Gets the current instant the message or session is locked until.\n+     *\n+     * @return the instant the message or session is locked until.\n+     */\n+    public Instant getLockedUntil() {\n+        return lockedUntil.get();\n+    }\n+\n+    /**\n+     * Gets the message lock token for the renewal operation.\n+     *\n+     * @return The message lock token or {@code null} if a session is being renewed instead.\n+     */\n+    public String getLockToken() {\n+        return isSession ? null : lockToken;\n+    }\n+\n+    /**\n+     * Gets the session id for this lock renewal operation.\n+     *\n+     * @return The session id or {@code null} if it is not a session renewal.\n+     */\n+    public String getSessionId() {\n+        return isSession ? lockToken : null;\n+    }\n+\n+    /**\n+     * Gets the current status of the renewal operation.\n+     *\n+     * @return The current status of the renewal operation.\n+     */\n+    public LockRenewalStatus getStatus() {\n+        return status.get();\n+    }\n+\n+    /**\n+     * Gets the exception if an error occurred whilst renewing the message or session lock.\n+     *\n+     * @return the exception if an error occurred whilst renewing the message or session lock, otherwise {@code null}.\n+     */\n+    public Throwable getThrowable() {\n+        return throwable.get();\n+    }\n+\n+    /**\n+     * Cancels the lock renewal operation.\n+     */\n+    @Override\n+    public void close() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+\n+        if (status.compareAndSet(LockRenewalStatus.RUNNING, LockRenewalStatus.CANCELLED)) {\n+            logger.verbose(\"token[{}] Cancelled operation.\", lockToken);\n+        }\n+\n+        cancellationProcessor.onComplete();\n+        subscription.dispose();\n+    }\n+\n+    /**\n+     * Gets the lock renewal operation. if the {@code maxLockRenewalDuration} is {@link Duration#isZero()}, then the\n+     * lock is never renewed.\n+     *\n+     * @param initialLockedUntil When the initial call is locked until.\n+     * @param maxLockRenewalDuration Duration to renew lock for.\n+     * @return The subscription for the operation.\n+     */\n+    private Disposable getRenewLockOperation(Instant initialLockedUntil, Duration maxLockRenewalDuration) {\n+        if (maxLockRenewalDuration.isZero()) {\n+            status.set(LockRenewalStatus.COMPLETE);\n+            return Disposables.single();\n+        }\n+\n+        final Instant now = Instant.now();\n+        Duration initialInterval = Duration.between(now, initialLockedUntil);\n+\n+        if (initialInterval.isNegative()) {\n+            logger.info(\"Duration was negative. now[{}] lockedUntil[{}]\", now, initialLockedUntil);\n+            initialInterval = Duration.ZERO;\n+        } else {\n+            // Adjust the interval, so we can buffer time for the time it'll take to refresh.\n+            final Duration adjusted = MessageUtils.adjustServerTimeout(initialInterval);\n+            if (adjusted.isNegative()) {\n+                logger.info(\"Adjusted duration is negative. Adjusted: {}ms\", initialInterval.toMillis());\n+            } else {\n+                initialInterval = adjusted;\n+            }\n+        }\n+\n+        final EmitterProcessor<Duration> emitterProcessor = EmitterProcessor.create();\n+        final FluxSink<Duration> sink = emitterProcessor.sink();\n+\n+        sink.next(initialInterval);\n+\n+        final Flux<Object> cancellationSignals = Flux.first(cancellationProcessor, Mono.delay(maxLockRenewalDuration));\n+\n+        return Flux.switchOnNext(emitterProcessor.map(Flux::interval))\n+            .takeUntilOther(cancellationSignals)\n+            .flatMap(delay -> {\n+                final String id = lockToken;\n+                logger.info(\"token[{}]. now[{}]. Starting lock renewal.\", id, Instant.now());\n+                if (CoreUtils.isNullOrEmpty(id)) {\n+                    return Mono.error(new IllegalStateException(\"Cannot renew session lock without session id.\"));", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxODIwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468818208", "bodyText": "Shouldn't we check for empty or null session id and throw Exception as needed?", "author": "hemanttanwar", "createdAt": "2020-08-11T19:34:53Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -658,6 +659,59 @@ public String getEntityPath() {\n             transactionContext);\n     }\n \n+    /**\n+     * Gets and starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @return A lock renewal operation for the message.\n+     */\n+    public LockRenewalOperation getAutoRenewMessageLock(String lockToken, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logThrowableAsError(new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(lockToken)) {\n+            throw logger.logThrowableAsError(new NullPointerException(\"'lockToken' cannot be null.\"));\n+        } else if (lockToken.isEmpty()) {\n+            throw logger.logThrowableAsError(new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (receiverOptions.isSessionReceiver()) {\n+            throw logger.logThrowableAsError(new IllegalStateException(\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+        } else if (maxLockRenewalDuration == null) {\n+            throw logger.logThrowableAsError(new NullPointerException(\"'maxLockRenewalDuration' cannot be null.\"));\n+        } else if (maxLockRenewalDuration.isNegative()) {\n+            throw logger.logThrowableAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' cannot be negative.\"));\n+        }\n+\n+        return new LockRenewalOperation(lockToken, maxLockRenewalDuration, false, this::renewMessageLock);\n+    }\n+\n+    /**\n+     * Gets and starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @return A lock renewal operation for the message.\n+     * @throws IllegalStateException if the receiver is a non-session receiver or the receiver is disposed.\n+     */\n+    public LockRenewalOperation getAutoRenewSessionLock(String sessionId, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logThrowableAsError(new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewSessionLock\")));", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MzQwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468843409", "bodyText": "It's checked in the constructor for LockRenewalOperation.", "author": "conniey", "createdAt": "2020-08-11T20:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxODIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxODU0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468818540", "bodyText": "Document NPE", "author": "hemanttanwar", "createdAt": "2020-08-11T19:35:34Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -658,6 +659,59 @@ public String getEntityPath() {\n             transactionContext);\n     }\n \n+    /**\n+     * Gets and starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @return A lock renewal operation for the message.\n+     */\n+    public LockRenewalOperation getAutoRenewMessageLock(String lockToken, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logThrowableAsError(new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(lockToken)) {\n+            throw logger.logThrowableAsError(new NullPointerException(\"'lockToken' cannot be null.\"));\n+        } else if (lockToken.isEmpty()) {\n+            throw logger.logThrowableAsError(new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (receiverOptions.isSessionReceiver()) {\n+            throw logger.logThrowableAsError(new IllegalStateException(\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+        } else if (maxLockRenewalDuration == null) {\n+            throw logger.logThrowableAsError(new NullPointerException(\"'maxLockRenewalDuration' cannot be null.\"));\n+        } else if (maxLockRenewalDuration.isNegative()) {\n+            throw logger.logThrowableAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' cannot be negative.\"));\n+        }\n+\n+        return new LockRenewalOperation(lockToken, maxLockRenewalDuration, false, this::renewMessageLock);\n+    }\n+\n+    /**\n+     * Gets and starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @return A lock renewal operation for the message.\n+     * @throws IllegalStateException if the receiver is a non-session receiver or the receiver is disposed.\n+     */", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxOTAzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468819033", "bodyText": "document NPE, and also if  sessionId validation checks .", "author": "hemanttanwar", "createdAt": "2020-08-11T19:36:39Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -450,6 +450,30 @@ public void deadLetter(String lockToken, DeadLetterOptions deadLetterOptions, St\n         asyncClient.deadLetter(lockToken, deadLetterOptions, sessionId, transactionContext).block(operationTimeout);\n     }\n \n+    /**\n+     * Gets and starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @return A lock renewal operation for the message.\n+     * @throws IllegalStateException if the receiver is a non-session receiver or the receiver is disposed.\n+     */\n+    public LockRenewalOperation getAutoRenewMessageLock(String lockToken, Duration maxLockRenewalDuration) {\n+        return asyncClient.getAutoRenewMessageLock(lockToken, maxLockRenewalDuration);\n+    }\n+\n+    /**\n+     * Gets and starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @return A lock renewal operation for the message.\n+     * @throws IllegalStateException if the receiver is a non-session receiver or the receiver is disposed.", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyMjM2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468822368", "bodyText": "Instant.now() :  This would mean, renew until , current time. is this right ?", "author": "hemanttanwar", "createdAt": "2020-08-11T19:43:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessageUtils;\n+import com.azure.messaging.servicebus.models.LockRenewalStatus;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoProcessor;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Represents a renewal session or message lock renewal operation that.\n+ */\n+public class LockRenewalOperation implements AutoCloseable {\n+    private final ClientLogger logger = new ClientLogger(LockRenewalOperation.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final AtomicReference<Instant> lockedUntil = new AtomicReference<>();\n+    private final AtomicReference<Throwable> throwable = new AtomicReference<>();\n+    private final AtomicReference<LockRenewalStatus> status = new AtomicReference<>(LockRenewalStatus.RUNNING);\n+    private final MonoProcessor<Void> cancellationProcessor = MonoProcessor.create();\n+\n+    private final String lockToken;\n+    private final boolean isSession;\n+    private final Function<String, Mono<Instant>> renewalOperation;\n+    private final Disposable subscription;\n+\n+    /**\n+     * Creates a new lock renewal operation. The lock is initially renewed.\n+     *\n+     * @param lockToken Lock or session id to renew.\n+     * @param maxLockRenewalDuration The maximum duration this lock should be renewed.\n+     * @param isSession Whether the lock represents a session lock or message lock.\n+     * @param renewalOperation The renewal operation to call.\n+     */\n+    LockRenewalOperation(String lockToken, Duration maxLockRenewalDuration, boolean isSession,\n+        Function<String, Mono<Instant>> renewalOperation) {\n+        this(lockToken, maxLockRenewalDuration, isSession, renewalOperation, Instant.now());\n+    }", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0NTA5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468845099", "bodyText": "Yes. This is correct. It'll force a lock renewal.", "author": "conniey", "createdAt": "2020-08-11T20:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyMjM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyODM5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13984#discussion_r468828392", "bodyText": "Are we also taking care of situation when , user complete a message but renew operation still try to renew and keep getting error in logs.\nAfter settlement of the message by user, How does that lock is not renewing automatically in background and filling the logs ?", "author": "hemanttanwar", "createdAt": "2020-08-11T19:55:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/LockRenewalOperationTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.models.LockRenewalStatus;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.Mockito.atMost;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Represents a renewal session or message lock renewal operation that.\n+ */\n+class LockRenewalOperationTest {\n+    private static final String A_LOCK_TOKEN = \"a-lock-token\";\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewalOperationTest.class);\n+    private LockRenewalOperation operation;\n+\n+    @Mock\n+    private Function<String, Mono<Instant>> renewalOperation;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (operation != null) {\n+            operation.close();\n+        }\n+    }\n+\n+    @ValueSource(booleans = {true, false})\n+    @ParameterizedTest\n+    void constructor(boolean isSession) {\n+        // Arrange\n+        final Duration renewalPeriod = Duration.ofSeconds(4);\n+        final Instant lockedUntil = Instant.now().plus(renewalPeriod);\n+        final Duration maxDuration = Duration.ofSeconds(20);\n+        when(renewalOperation.apply(A_LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> Instant.now().plus(renewalPeriod)));\n+\n+        // Act\n+        operation = new LockRenewalOperation(A_LOCK_TOKEN, maxDuration, isSession, renewalOperation, lockedUntil);\n+\n+        // Assert\n+        if (isSession) {\n+            assertEquals(A_LOCK_TOKEN, operation.getSessionId());\n+            assertNull(operation.getLockToken());\n+        } else {\n+            assertEquals(A_LOCK_TOKEN, operation.getLockToken());\n+            assertNull(operation.getSessionId());\n+        }\n+\n+        assertEquals(lockedUntil, operation.getLockedUntil());\n+        assertEquals(LockRenewalStatus.RUNNING, operation.getStatus());\n+        assertNull(operation.getThrowable());\n+    }\n+\n+    /**\n+     * Verify that when an error occurs, it is displayed.\n+     */\n+    @Test\n+    void errors() throws InterruptedException {\n+        // Arrange", "originalCommit": "7fd95bbbe5d4ae757b3a76cf7715d52493cfcc2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "81447b28b24e923474fac082ac2fc417c1a4963d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/81447b28b24e923474fac082ac2fc417c1a4963d", "message": "Add tests for receiver.", "committedDate": "2020-08-11T20:22:13Z", "type": "commit"}, {"oid": "96c13ee14c1bcecbac5b27f31d3a880abd90b91b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/96c13ee14c1bcecbac5b27f31d3a880abd90b91b", "message": "Add documentation.", "committedDate": "2020-08-11T20:28:36Z", "type": "commit"}, {"oid": "08eb7792d994441354eed7f618343e048d8c13aa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/08eb7792d994441354eed7f618343e048d8c13aa", "message": "Add LockContainer<T>", "committedDate": "2020-08-11T22:58:03Z", "type": "commit"}, {"oid": "db2172cc0150c1665324d1d19dbf6fdc8586156e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/db2172cc0150c1665324d1d19dbf6fdc8586156e", "message": "Fixing build breaks.", "committedDate": "2020-08-11T23:35:00Z", "type": "commit"}, {"oid": "079897abb8445c4dc1873a96147a2328f75ccf3c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/079897abb8445c4dc1873a96147a2328f75ccf3c", "message": "Adding renewaltoken.", "committedDate": "2020-08-12T05:55:50Z", "type": "commit"}, {"oid": "1c74d1b28b55cd02b7f3b9f571a4a502f820c4e8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1c74d1b28b55cd02b7f3b9f571a4a502f820c4e8", "message": "Fixing lock renewal to not head into an infinite loop.", "committedDate": "2020-08-12T20:42:41Z", "type": "commit"}, {"oid": "ff93a9c2b216defa86537edba568c85d7da48b8b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ff93a9c2b216defa86537edba568c85d7da48b8b", "message": "Fix checkstyle issues.", "committedDate": "2020-08-12T20:58:25Z", "type": "commit"}, {"oid": "3a25b1dcbced0dfcd656c61fa0554a6bdfc31b24", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a25b1dcbced0dfcd656c61fa0554a6bdfc31b24", "message": "Only add to token when there is locked until.", "committedDate": "2020-08-12T21:18:30Z", "type": "commit"}, {"oid": "9ad37d225ebc1a58e25dc41c4fe78d906a1405ae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9ad37d225ebc1a58e25dc41c4fe78d906a1405ae", "message": "Fixing lock container test.", "committedDate": "2020-08-12T21:30:47Z", "type": "commit"}, {"oid": "82d69aae6f980913ccbf9be3095a3e721f38ef18", "url": "https://github.com/Azure/azure-sdk-for-java/commit/82d69aae6f980913ccbf9be3095a3e721f38ef18", "message": "Fixing test failures.", "committedDate": "2020-08-12T21:45:44Z", "type": "commit"}, {"oid": "30d4fe016db5ba89368becd752605e84417bcbd9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30d4fe016db5ba89368becd752605e84417bcbd9", "message": "Fix test assertion", "committedDate": "2020-08-12T21:57:19Z", "type": "commit"}, {"oid": "25c1d295acff330b41648741685ee87599d54cd0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/25c1d295acff330b41648741685ee87599d54cd0", "message": "Fix warnings.", "committedDate": "2020-08-12T22:17:57Z", "type": "commit"}]}