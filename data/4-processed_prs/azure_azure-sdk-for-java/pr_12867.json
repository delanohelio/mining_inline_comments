{"pr_number": 12867, "pr_title": "Merging back Tracer PR without conditional check on withContext()", "pr_createdAt": "2020-07-07T15:10:37Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/12867", "timeline": [{"oid": "089307a3a8167f96dd38ecbf3c3a1ca6a1ca32b2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/089307a3a8167f96dd38ecbf3c3a1ca6a1ca32b2", "message": "initial commit", "committedDate": "2020-04-08T14:36:47Z", "type": "commit"}, {"oid": "175222e616cf0ff1026ff70735fcc36377d05054", "url": "https://github.com/Azure/azure-sdk-for-java/commit/175222e616cf0ff1026ff70735fcc36377d05054", "message": "changing sample", "committedDate": "2020-04-08T14:46:01Z", "type": "commit"}, {"oid": "fe03e665cc2fdbef20b5aab7961a690854d8f48c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe03e665cc2fdbef20b5aab7961a690854d8f48c", "message": "adding query api tracer support", "committedDate": "2020-04-13T16:29:48Z", "type": "commit"}, {"oid": "9f9cce807228f3e8cbe3ec9654a58823f432ad4f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9f9cce807228f3e8cbe3ec9654a58823f432ad4f", "message": "merging with master", "committedDate": "2020-04-14T18:46:05Z", "type": "commit"}, {"oid": "e2e8e9e468a8a8c038ea4c1cf70e33414395b775", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2e8e9e468a8a8c038ea4c1cf70e33414395b775", "message": "reverting change for jaeger ui local testing", "committedDate": "2020-04-14T19:25:12Z", "type": "commit"}, {"oid": "c2fc40f3a35df2381104f88817209804491ae329", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c2fc40f3a35df2381104f88817209804491ae329", "message": "adding tracers in trigger udf and sproc", "committedDate": "2020-04-15T19:11:27Z", "type": "commit"}, {"oid": "eb82b61e1ff3d7c78d68435cc485f452fbe41b2d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb82b61e1ff3d7c78d68435cc485f452fbe41b2d", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-04-21T13:41:47Z", "type": "commit"}, {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e614db5d38ff2f4947900fa0174774f8c13f37fe", "message": "adding test case and refactoring code", "committedDate": "2020-04-21T21:13:25Z", "type": "commit"}, {"oid": "c4ae21b2d1031f572abd8ba9c46b2e591a167b25", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c4ae21b2d1031f572abd8ba9c46b2e591a167b25", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-04-24T18:49:27Z", "type": "commit"}, {"oid": "eabbec95e6c61b20fa9365824e0944c5c5dcaf1a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eabbec95e6c61b20fa9365824e0944c5c5dcaf1a", "message": "refactoring code with PR ready version", "committedDate": "2020-04-24T20:05:35Z", "type": "commit"}, {"oid": "36dde959516c9db168cca34023a105bbb19aa5da", "url": "https://github.com/Azure/azure-sdk-for-java/commit/36dde959516c9db168cca34023a105bbb19aa5da", "message": "ending span on doOnComplete", "committedDate": "2020-04-24T21:06:40Z", "type": "commit"}, {"oid": "36743ca506ec2fca6e25fe1c80062abcaba04688", "url": "https://github.com/Azure/azure-sdk-for-java/commit/36743ca506ec2fca6e25fe1c80062abcaba04688", "message": "resolving error", "committedDate": "2020-05-04T15:02:31Z", "type": "commit"}, {"oid": "cff33addaf0ee49c7ec153f0a6a8d6474f3870ef", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cff33addaf0ee49c7ec153f0a6a8d6474f3870ef", "message": "merging with master", "committedDate": "2020-05-04T15:33:04Z", "type": "commit"}, {"oid": "8ca24ec529a3e6ea073cde068f3e46b2173cc6e5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ca24ec529a3e6ea073cde068f3e46b2173cc6e5", "message": "perf improvement", "committedDate": "2020-05-05T20:06:26Z", "type": "commit"}, {"oid": "21034b55d17e22f587a0a9004359423c21959d4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21034b55d17e22f587a0a9004359423c21959d4b", "message": "resolving merge conflict", "committedDate": "2020-05-06T16:07:20Z", "type": "commit"}, {"oid": "1f9f1397b3ef30c383800bd32e6ebc1986c2567b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f9f1397b3ef30c383800bd32e6ebc1986c2567b", "message": "fixing build error", "committedDate": "2020-05-06T16:37:16Z", "type": "commit"}, {"oid": "aab85a6184c6ceda774df0b0ae055ee78af29289", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aab85a6184c6ceda774df0b0ae055ee78af29289", "message": "resolving merge conflict", "committedDate": "2020-05-11T14:27:12Z", "type": "commit"}, {"oid": "d14a0bb5ee30f455dd35b545f564ec6b0ee5beb7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d14a0bb5ee30f455dd35b545f564ec6b0ee5beb7", "message": "resolving merge conflict", "committedDate": "2020-05-11T14:29:15Z", "type": "commit"}, {"oid": "8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "message": "check non opentelementry jar non existence in starting of all api", "committedDate": "2020-05-11T14:36:28Z", "type": "commit"}, {"oid": "6b09e5c2504b94e80788d30048c96836bd20c1cb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b09e5c2504b94e80788d30048c96836bd20c1cb", "message": "fixing checkstyle", "committedDate": "2020-05-11T15:18:52Z", "type": "commit"}, {"oid": "81040b270c3a369ae5289428143c144b9e57d54c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/81040b270c3a369ae5289428143c144b9e57d54c", "message": "resolving comments", "committedDate": "2020-05-11T18:09:41Z", "type": "commit"}, {"oid": "dbc74c8f7ea56fdcf88c1bc35032d81139302805", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbc74c8f7ea56fdcf88c1bc35032d81139302805", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-05-11T18:20:59Z", "type": "commit"}, {"oid": "806cdf154862a36147c6bc3cfebe582e6fa323b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/806cdf154862a36147c6bc3cfebe582e6fa323b3", "message": "check style fix as per java 8", "committedDate": "2020-05-11T18:56:09Z", "type": "commit"}, {"oid": "d061db5abcbf948ae4159576f7ee94a75eca574f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d061db5abcbf948ae4159576f7ee94a75eca574f", "message": "adding azure-core-tracing-opentelemetry in test scope", "committedDate": "2020-05-11T21:11:36Z", "type": "commit"}, {"oid": "32d9172690f0c9bb71a539f3b6cbca1a7cfd19d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/32d9172690f0c9bb71a539f3b6cbca1a7cfd19d2", "message": "resolving conflict", "committedDate": "2020-05-11T23:17:04Z", "type": "commit"}, {"oid": "0fc0cc923557735ac777c7037e5a5491e6675467", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0fc0cc923557735ac777c7037e5a5491e6675467", "message": "build error fix", "committedDate": "2020-05-11T23:38:49Z", "type": "commit"}, {"oid": "1290ae13cd5eb1995ddd3a4bbc9a705456fafd9a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1290ae13cd5eb1995ddd3a4bbc9a705456fafd9a", "message": "test failure fix", "committedDate": "2020-05-12T01:19:20Z", "type": "commit"}, {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d2a815459cf553a0f24126b0765e5b3a375ccd4b", "message": "test fix", "committedDate": "2020-05-12T02:00:54Z", "type": "commit"}, {"oid": "30c2f8962f070e59790585b7abee6aa5e5a136a1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30c2f8962f070e59790585b7abee6aa5e5a136a1", "message": "resolving comments", "committedDate": "2020-05-13T15:56:57Z", "type": "commit"}, {"oid": "e7fa831bfcdc284440ff14a26ec84bd02732c79c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7fa831bfcdc284440ff14a26ec84bd02732c79c", "message": "complie error fix", "committedDate": "2020-05-13T17:38:31Z", "type": "commit"}, {"oid": "3aa851d64c0ee1d43d1d86994d4e19a677ac7dc8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3aa851d64c0ee1d43d1d86994d4e19a677ac7dc8", "message": "removing query text from tracer", "committedDate": "2020-05-15T14:51:03Z", "type": "commit"}, {"oid": "0debac080b3ff04085ed11f0fdaa2a482a8eb096", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0debac080b3ff04085ed11f0fdaa2a482a8eb096", "message": "resolving merge conflict", "committedDate": "2020-05-15T16:14:16Z", "type": "commit"}, {"oid": "8efa4514350b03035400964d817e4136b4e03486", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8efa4514350b03035400964d817e4136b4e03486", "message": "merge with master and removing subscriber context for perf gain", "committedDate": "2020-05-26T23:17:29Z", "type": "commit"}, {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7fe8bb66384a0999cb137e3d0476540cf419c84", "message": "resolving merge conflict", "committedDate": "2020-05-26T23:20:33Z", "type": "commit"}, {"oid": "3461604e14d02caffdb2e6df5e9755702bf658c6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3461604e14d02caffdb2e6df5e9755702bf658c6", "message": "resolving merge conflict after GA", "committedDate": "2020-06-11T18:04:42Z", "type": "commit"}, {"oid": "0984a9ceadd61b2c0862a4a6ae3b968693952d57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0984a9ceadd61b2c0862a4a6ae3b968693952d57", "message": "code formating change and some comment resolution", "committedDate": "2020-06-11T22:11:06Z", "type": "commit"}, {"oid": "b9c60a2431add13e597f3c7874f590cc8695945f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9c60a2431add13e597f3c7874f590cc8695945f", "message": "resolving comments", "committedDate": "2020-06-11T23:30:10Z", "type": "commit"}, {"oid": "aaabc72ed458360d2e758f05e8744f2ba22d2d8e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aaabc72ed458360d2e758f05e8744f2ba22d2d8e", "message": "moving AZ_TRACING_NAMESPACE_KEY to context from span attribute", "committedDate": "2020-06-15T16:33:48Z", "type": "commit"}, {"oid": "8024999b269086cdc804cf1b2212abde9f21ca6a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8024999b269086cdc804cf1b2212abde9f21ca6a", "message": "updating core opentelementry jar", "committedDate": "2020-06-15T18:40:41Z", "type": "commit"}, {"oid": "210185126bcf0d44a8b74cf21d0780e7bed06c5f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/210185126bcf0d44a8b74cf21d0780e7bed06c5f", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-07-06T13:18:25Z", "type": "commit"}, {"oid": "1f4c6ac37696c0ce0b7e15677955ede58afcf04b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f4c6ac37696c0ce0b7e15677955ede58afcf04b", "message": "Tracer code without conditional check for withContext", "committedDate": "2020-07-07T14:41:19Z", "type": "commit"}, {"oid": "1b0becb11e94eed93ac2ec15ae893ef94c5d2385", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1b0becb11e94eed93ac2ec15ae893ef94c5d2385", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-07-07T15:01:00Z", "type": "commit"}, {"oid": "3548215370fea7ff0fb9b4e6a79c0130f629cb37", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3548215370fea7ff0fb9b4e6a79c0130f629cb37", "message": "formating chage", "committedDate": "2020-07-07T15:03:37Z", "type": "commit"}, {"oid": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb398d9091cf47354129e61a5d90040fadd6f0d0", "message": "formating chage", "committedDate": "2020-07-07T15:07:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMDMzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451000335", "bodyText": "What is the timeline for GA of this package - Seems weird if a part of the SDK officially GAed (azure-cosmos) takes a dependency on a component still in Beta.", "author": "FabianMeiswinkel", "createdAt": "2020-07-07T16:41:15Z", "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -128,7 +128,18 @@ Licensed under the MIT License.\n         </exclusion>\n       </exclusions>\n     </dependency>\n-\n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core-tracing-opentelemetry</artifactId>\n+      <scope>test</scope>\n+      <version>1.0.0-beta.5</version> <!-- {x-version-update;com.azure:azure-core-tracing-opentelemetry;dependency} -->", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMDEyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451010124", "bodyText": "@FabianMeiswinkel Since this is a test dependency  -> <scope>tests<scope>.I think we should be fine, right @simplynaveen20  ?", "author": "kushagraThapar", "createdAt": "2020-07-07T16:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMDMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTUyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451015522", "bodyText": "That is correct, this is test dependency . Mostly users gonna onboard tracing with GA version version only . And once we have that we can move this test dependency to GA as well . So overall we should be good now,", "author": "simplynaveen20", "createdAt": "2020-07-07T17:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMDMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5ODc2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453098769", "bodyText": "we are now not using this test dependency", "author": "simplynaveen20", "createdAt": "2020-07-10T22:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMDMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTk2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451085967", "bodyText": "Not sure if I understand why would we need this to be a context object. Could this be a Map or an optional object?", "author": "samvaity", "createdAt": "2020-07-07T19:14:19Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +450,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryDatabases\";\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MTE0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452471146", "bodyText": "So this is to avoid nesting tracer call. Initially we were using subscriberContext for this purpose, and found some perf regression. Then we moved to this model, we already have internal methods that are taking context, and eventually we can filter the nesting call in TracerProvide.  If we have taken map, this logic would be more complex in code readability and we have to handle this case by changing code at many places, and also it is more efficient .\nAnd we are using optional when we are reading it back, please check this", "author": "simplynaveen20", "createdAt": "2020-07-09T20:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUxNDkzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452514933", "bodyText": "I was just suggesting if we could use a different data structure than the Context type here since the Context object is a linked list representation and if its populated enough could result the getData to get slower.", "author": "samvaity", "createdAt": "2020-07-09T22:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1ODkwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452558903", "bodyText": "This is only used for api with nested call , and putting just one data. This is the proper way as nested call will be treated as user send context,  and tracer provider will filter it. This code flow is inline with non nested call, and code readability is also good here.\nAlso did the perf testing with this approach and numbers look good. I fear if we change anything we might introduce some perf regression as current approach is working best for us.", "author": "simplynaveen20", "createdAt": "2020-07-10T00:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NDc0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453084743", "bodyText": "We will go by this approach,i.e adding nested data only on the api it needed , as this gave the best perf result, and adding data on all api might have an impact .", "author": "simplynaveen20", "createdAt": "2020-07-10T21:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NjQwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451086407", "bodyText": "Could store database.getId() in a variable.\nAlso, some places below.", "author": "samvaity", "createdAt": "2020-07-07T19:15:08Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +450,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryDatabases\";\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseIfNotExistsInternal(database.readInternal(new CosmosDatabaseRequestOptions(), nestedContext), database, throughputProperties, nestedContext);\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,\n+            spanName,\n+            database.getId(),\n+            this.serviceEndpoint);\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(Mono<CosmosDatabaseResponse> responseMono, CosmosAsyncDatabase database, ThroughputProperties throughputProperties, Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if(throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    if (context != null) {\n+                        Database wrappedDatabase = new Database();\n+                        wrappedDatabase.setId(database.getId());\n+                        return createDatabaseInternal(wrappedDatabase,\n+                            requestOptions, context);\n+                    }\n+\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        requestOptions);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseInternal(Database database, CosmosDatabaseRequestOptions options,\n+                                                             Context context) {\n+        String spanName = \"createDatabase.\" + database.getId();", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2NzIyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452467226", "bodyText": "We cant store database.getId() as database object is coming from user in each api. User can have multiple database sin a single client.", "author": "simplynaveen20", "createdAt": "2020-07-09T20:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NjQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1Mjg3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452552877", "bodyText": "Oh I was suggesting in the same method.", "author": "samvaity", "createdAt": "2020-07-10T00:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NjQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1OTk5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452559992", "bodyText": "Ohk got it , still I don't see any benefit of using extra variable in this private method to hold database.getId().", "author": "simplynaveen20", "createdAt": "2020-07-10T00:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NjQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NzEzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452567130", "bodyText": "It doesn't have to be computed twice.", "author": "samvaity", "createdAt": "2020-07-10T00:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NjQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3MTU1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453071555", "bodyText": "getId doesn't compute anything, it just returns an instance variable, so we should be good here.", "author": "kushagraThapar", "createdAt": "2020-07-10T20:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NjQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NzI4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451087284", "bodyText": "Is the getId() on L111 the same database Id as on this line?", "author": "samvaity", "createdAt": "2020-07-07T19:16:45Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncConflict.java", "diffHunk": "@@ -106,4 +106,33 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosConflictResponse> readInternal(RequestOptions options, Context context) {\n+        String spanName = \"readConflict.\" + getId();\n+        Mono<CosmosConflictResponse> responseMono = this.readInternal(options);\n+        return this.container.getDatabase().getClient().getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            this.container.getDatabase().getId(),", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2NjQyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452466420", "bodyText": "getId() on L111 is conflict id and not database id", "author": "simplynaveen20", "createdAt": "2020-07-09T20:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NzI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNDE5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451104194", "bodyText": "nit: space before .", "author": "samvaity", "createdAt": "2020-07-07T19:49:30Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -628,35 +673,13 @@ public CosmosAsyncConflict getConflict(String id) {\n     }\n \n     /**\n-     * Replace the throughput provisioned for the current container.\n+     * Replace the throughput .", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2NTgzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452465837", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-09T20:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNDE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451105797", "bodyText": "Do we need to define these here if they are only used once?", "author": "samvaity", "createdAt": "2020-07-07T19:52:25Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -43,12 +46,40 @@\n     private final CosmosAsyncDatabase database;\n     private final String id;\n     private final String link;\n+    private final String replaceContainerSpanName;\n+    private final String deleteContainerSpanName;\n+    private final String replaceThroughputSpanName;\n+    private final String readThroughputSpanName;\n+    private final String readContainerSpanName;\n+    private final String readItemSpanName;\n+    private final String upsertItemSpanName;\n+    private final String deleteItemSpanName;\n+    private final String replaceItemSpanName;\n+    private final String createItemSpanName;\n+    private final String readAllItemsSpanName;\n+    private final String queryItemsSpanName;\n+    private final String readAllConflictsSpanName;\n+    private final String queryConflictsSpanName;\n     private CosmosAsyncScripts scripts;\n \n     CosmosAsyncContainer(String id, CosmosAsyncDatabase database) {\n         this.id = id;\n         this.database = database;\n         this.link = getParentLink() + \"/\" + getURIPathSegment() + \"/\" + getId();\n+        this.replaceContainerSpanName = \"replaceContainer.\" + this.id;\n+        this.deleteContainerSpanName = \"deleteContainer.\" + this.id;\n+        this.replaceThroughputSpanName = \"replaceThroughput.\" + this.id;\n+        this.readThroughputSpanName = \"readThroughput.\" + this.id;\n+        this.readContainerSpanName = \"readContainer.\" + this.id;\n+        this.readItemSpanName = \"readItem.\" + this.id;\n+        this.upsertItemSpanName = \"upsertItem.\" + this.id;\n+        this.deleteItemSpanName = \"deleteItem.\" + this.id;", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2NTc1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452465753", "bodyText": "This is intentionally done here , to avoid string computation on each api call.  This class has most used apis so it will save us some computation.", "author": "simplynaveen20", "createdAt": "2020-07-09T20:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MDQ2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452560461", "bodyText": "It would rather help with computation being per api call than on instantiating this model?", "author": "samvaity", "createdAt": "2020-07-10T00:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MzU5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452563592", "bodyText": "Yes we dont want per api computation", "author": "simplynaveen20", "createdAt": "2020-07-10T00:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NjQ0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452566441", "bodyText": "I was saying it is better if we have computation on per api call as it would just create one span name, rthaer than all of them that the user wouldn't end up using anyway.\nAlso, this seems to be deviating from the approach we have followed in other places.\nAlso, it is a per API property vs class level?", "author": "samvaity", "createdAt": "2020-07-10T00:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzOTkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452939936", "bodyText": "We are doing trade off all initializing in the starting vs computing in each api. And reason why we are doing only here , as this class has majority of customer workflow, so any gain in computation in each api will be helpful.", "author": "simplynaveen20", "createdAt": "2020-07-10T16:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NTA3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453085074", "bodyText": "Cosmos will use this approach for container api for better perf", "author": "simplynaveen20", "createdAt": "2020-07-10T21:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwNTc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDg2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451850866", "bodyText": "Not completely sure if we need this dependency. I don't see it being used in the Tests either.", "author": "samvaity", "createdAt": "2020-07-08T22:04:43Z", "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -128,7 +128,18 @@ Licensed under the MIT License.\n         </exclusion>\n       </exclusions>\n     </dependency>\n-\n+    <dependency>", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2NDk5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452464999", "bodyText": "This is needed in CosmosTracerTest., we are actually doing the integration testing there. And the Mockito.verify you noticed in  CosmosTracerTest is the spy tracer to valid the tracer pipeline, but the request are actual backend call.", "author": "simplynaveen20", "createdAt": "2020-07-09T20:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NTE1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453085154", "bodyText": "Removed the dependency", "author": "simplynaveen20", "createdAt": "2020-07-10T21:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MTU0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451851541", "bodyText": "Could we update these tests to check for the attributes that are needed to be set for the particular request, rather than just checking for anyString()?", "author": "samvaity", "createdAt": "2020-07-08T22:06:24Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ServiceLoader;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+                \"/pk\", 5000).block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        try {\n+            cosmosAsyncDatabase.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+\n+        Mockito.verify(tracer, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.readAllUsers().byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.readAllContainers().byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncContainer() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        cosmosAsyncContainer.read().block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        try {\n+            cosmosAsyncContainer.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+        Mockito.verify(tracer, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        InternalObjectNode item = new InternalObjectNode();\n+        item.setId(ITEM_ID);\n+        cosmosAsyncContainer.createItem(item).block();\n+        Mockito.verify(tracer, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.upsertItem(item,\n+            new CosmosItemRequestOptions()).block();\n+        Mockito.verify(tracer, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.readItem(ITEM_ID, PartitionKey.NONE,\n+            InternalObjectNode.class).block();\n+        Mockito.verify(tracer, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.deleteItem(ITEM_ID, PartitionKey.NONE).block();\n+        Mockito.verify(tracer, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        cosmosAsyncContainer.readAllItems(new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        String query = \"select * from c where c.id = '\" + ITEM_ID + \"'\";\n+        cosmosAsyncContainer.queryItems(query, new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncScripts() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        cosmosAsyncContainer.getScripts().readAllStoredProcedures(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        CosmosUserDefinedFunctionProperties cosmosUserDefinedFunctionProperties =\n+            getCosmosUserDefinedFunctionProperties();\n+        CosmosUserDefinedFunctionProperties resultUdf =\n+            cosmosAsyncContainer.getScripts().createUserDefinedFunction(cosmosUserDefinedFunctionProperties).block().getProperties();\n+        Mockito.verify(tracer, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).read().block();\n+        Mockito.verify(tracer, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosUserDefinedFunctionProperties.setBody(\"function() {var x = 15;}\");\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(resultUdf.getId()).replace(resultUdf).block();\n+        Mockito.verify(tracer, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).delete().block();\n+        Mockito.verify(tracer, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        CosmosTriggerProperties cosmosTriggerProperties = getCosmosTriggerProperties();\n+        CosmosTriggerProperties resultTrigger =\n+            cosmosAsyncContainer.getScripts().createTrigger(cosmosTriggerProperties).block().getProperties();\n+        Mockito.verify(tracer, Mockito.times(9)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).read().block();\n+        Mockito.verify(tracer, Mockito.times(10)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).replace(resultTrigger).block();\n+        Mockito.verify(tracer, Mockito.times(11)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracer, Mockito.times(12)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).delete().block();\n+        Mockito.verify(tracer, Mockito.times(13)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        CosmosStoredProcedureProperties procedureProperties = getCosmosStoredProcedureProperties();\n+        CosmosStoredProcedureProperties resultSproc =\n+            cosmosAsyncContainer.getScripts().createStoredProcedure(procedureProperties).block().getProperties();\n+        Mockito.verify(tracer, Mockito.times(14)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getStoredProcedure(procedureProperties.getId()).read().block();\n+        Mockito.verify(tracer, Mockito.times(15)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MzU3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452463573", "bodyText": "This comment was also there in last pr which was reverted , and as I stated earlier we will do much more attributes check once we will have the diagnostic tracer support pr , which is next in line. And also as mentioned in the description of this PR that scope of this pr is basically re merging earlier PR without short circuiting.\nCan we please this take this in next PR unless this is blocker. Also I manually verified  the attributes in Jagger UI .", "author": "simplynaveen20", "createdAt": "2020-07-09T20:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MTY5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452561694", "bodyText": "Also I manually verified the attributes in Jagger UI .\n\nSuggesting the same attributes to be checked when making the tracer calls. Sill related to this PR work and not so concerned about the diagnostic information which should be future work PR items.\nIf you want to do it ina follow up PR, please open an issue to track it. But it is still a part of this feature testing and think could go in the same PR as we already have tests that just need to be updated.\nIt should help us validate the tracing changes.", "author": "samvaity", "createdAt": "2020-07-10T00:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NDc1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452564750", "bodyText": "Checking attributes will be extension of this test class. It will be non minimal work, created github issue which is assigned to me\n#12988", "author": "simplynaveen20", "createdAt": "2020-07-10T00:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwODc2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r458108761", "bodyText": "Attributes checking is added in the test case", "author": "simplynaveen20", "createdAt": "2020-07-21T13:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MjAyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451852023", "bodyText": "what update is this related to?\nWe don't validate anything related to tracing here.", "author": "samvaity", "createdAt": "2020-07-08T22:07:32Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ReadFeedExceptionHandlingTest.java", "diffHunk": "@@ -46,7 +49,10 @@ public void readFeedException() throws Exception {\n                                                                     .mergeWith(Flux.fromIterable(frps));\n \n         final CosmosAsyncClientWrapper mockedClientWrapper = Mockito.spy(new CosmosAsyncClientWrapper(client));\n-        Mockito.when(mockedClientWrapper.readAllDatabases()).thenReturn(UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> response));\n+        Mockito.when(mockedClientWrapper.readAllDatabases()).thenReturn(UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(new TracerProvider(ServiceLoader.load(Tracer.class)), \"testSpan\", \"testEndpoint,\", \"testDb\");\n+            return response;\n+        }));", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MTE3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452461174", "bodyText": "This is mock readAllDatabases() api which does not set tracer information. With the new tracer code all the query should go through tracer code pipeline and this is mandatory. If we dont do this, it will return null pointer  in page flux here .\nWe can avoid this by doing null check in page flux, but the problem comes if someone add new query api , there are chances they will forget to send the request via tracer pipeline, and we don't want this.", "author": "simplynaveen20", "createdAt": "2020-07-09T20:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MjAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NTI3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453085274", "bodyText": "Explained offline", "author": "simplynaveen20", "createdAt": "2020-07-10T21:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MjAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxOTIwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451919206", "bodyText": "From a code style perspective, it would be better to do lines 255-257 and 260 on a single line:\nfinal CosmosDatabaseRequestOptions requestOptions = options == null ? new CosmosDatabaseRequestOptions() : options;", "author": "JonathanGiles", "createdAt": "2020-07-09T01:53:53Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -274,9 +257,8 @@ boolean isContentResponseOnWriteEnabled() {\n         }\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseProperties.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosDatabaseResponse(databaseResourceResponse))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ1NjgzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452456830", "bodyText": "done, here and other places", "author": "simplynaveen20", "createdAt": "2020-07-09T19:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxOTIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4OTIxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453989216", "bodyText": "Any possibility of including such as style guides?\nVS has some (only works in IDE) but not as gates as of now.", "author": "kirankumarkolli", "createdAt": "2020-07-13T22:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxOTIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxOTQ2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451919460", "bodyText": "Could you save a variable declaration and set by just directly passing the string into the method call?", "author": "JonathanGiles", "createdAt": "2020-07-09T01:54:47Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -397,12 +378,14 @@ boolean isContentResponseOnWriteEnabled() {\n      */\n     CosmosPagedFlux<CosmosDatabaseProperties> readAllDatabases(CosmosQueryRequestOptions options) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"readAllDatabases\";\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MDI2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452560260", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-10T00:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxOTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkyMDQ4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451920482", "bodyText": "Why are you removing full stops? We should keep them", "author": "JonathanGiles", "createdAt": "2020-07-09T01:58:37Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -628,35 +673,13 @@ public CosmosAsyncConflict getConflict(String id) {\n     }\n \n     /**\n-     * Replace the throughput provisioned for the current container.\n+     * Replace the throughput .\n      *\n-     * @param throughputProperties the throughput properties.\n-     * @return the mono containing throughput response.\n+     * @param throughputProperties the throughput properties\n+     * @return the mono containing throughput response", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ1NjU4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452456586", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-09T19:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkyMDQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkyNzk3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r451927977", "bodyText": "This feels out of place, but because it is implementation API it is fine.", "author": "JonathanGiles", "createdAt": "2020-07-09T02:27:17Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/CosmosPagedFluxOptions.java", "diffHunk": "@@ -57,4 +64,43 @@ public CosmosPagedFluxOptions setMaxItemCount(Integer maxItemCount) {\n         this.maxItemCount = maxItemCount;\n         return this;\n     }\n+\n+    /**\n+     * Gets the tracer provider\n+     * @return tracerProvider\n+     */\n+    public TracerProvider getTracerProvider() {\n+        return this.tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the tracer span name\n+     * @return tracerSpanName\n+     */\n+    public String getTracerSpanName() {\n+        return tracerSpanName;\n+    }\n+\n+    /**\n+     * Gets the databaseId\n+     * @return databaseId\n+     */\n+    public String getDatabaseId() {\n+        return databaseId;\n+    }\n+\n+    /**\n+     * Gets the service end point\n+     * @return serviceEndpoint\n+     */\n+    public String getServiceEndpoint() {\n+        return serviceEndpoint;\n+    }\n+\n+    public void setTracerInformation(TracerProvider tracerProvider, String tracerSpanName, String serviceEndpoint, String databaseId) {\n+        this.databaseId = databaseId;\n+        this.serviceEndpoint = serviceEndpoint;\n+        this.tracerSpanName = tracerSpanName;\n+        this.tracerProvider = tracerProvider;\n+    }", "originalCommit": "eb398d9091cf47354129e61a5d90040fadd6f0d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ1NjUyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452456526", "bodyText": "Yes this is  an implementation api.", "author": "simplynaveen20", "createdAt": "2020-07-09T19:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkyNzk3Nw=="}], "type": "inlineReview"}, {"oid": "b168fd28c8799ec139edfef9dfd55bfff4f67e69", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b168fd28c8799ec139edfef9dfd55bfff4f67e69", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-07-09T18:54:13Z", "type": "commit"}, {"oid": "9c1d31f8b46f43c312fbb3dfcecc3837369d5e08", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9c1d31f8b46f43c312fbb3dfcecc3837369d5e08", "message": "resolving comments", "committedDate": "2020-07-09T19:55:35Z", "type": "commit"}, {"oid": "0703a2810d684c09b7738f1c5695df0f823a362a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0703a2810d684c09b7738f1c5695df0f823a362a", "message": "build error fix", "committedDate": "2020-07-09T20:31:59Z", "type": "commit"}, {"oid": "c5283fe5ba3c3d18bb4d55f64aa4c59590c2f0cd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c5283fe5ba3c3d18bb4d55f64aa4c59590c2f0cd", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-07-09T23:24:19Z", "type": "commit"}, {"oid": "deb6978f7642675623ae06dcb34d2a186d66cadf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/deb6978f7642675623ae06dcb34d2a186d66cadf", "message": "resolving comment", "committedDate": "2020-07-10T00:15:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MzQ1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452563451", "bodyText": "Can this method call the method on L204", "author": "samvaity", "createdAt": "2020-07-10T00:41:55Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -209,21 +217,7 @@ boolean isContentResponseOnWriteEnabled() {\n      * an error.\n      */\n     public Mono<CosmosDatabaseResponse> createDatabaseIfNotExists(String id) {\n-        return createDatabaseIfNotExistsInternal(getDatabase(id));\n-    }\n-\n-    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database) {\n-        return database.read().onErrorResume(exception -> {\n-            final Throwable unwrappedException = Exceptions.unwrap(exception);\n-            if (unwrappedException instanceof CosmosException) {\n-                final CosmosException cosmosException = (CosmosException) unwrappedException;\n-                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n-                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n-                        new CosmosDatabaseRequestOptions());\n-                }\n-            }\n-            return Mono.error(unwrappedException);\n-        });\n+        return withContext(context -> createDatabaseIfNotExistsInternal(getDatabase(id), null, context));", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNzQ2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452937468", "bodyText": "We could do that, but avoiding nesting call in public api. Also it would be easier to read and debug. And our tracer goal getting fulfill with current design, so if you don't mind, can we keep current state?", "author": "simplynaveen20", "createdAt": "2020-07-10T16:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MzQ1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3MjkyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453072925", "bodyText": "@kushagraThapar Could you clarify if this is a design decision to not reuse the methods here?\nAnd if it is, why is it followed in some files and not all the time?\nMore context - #12867 (comment)", "author": "samvaity", "createdAt": "2020-07-10T20:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MzQ1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3MzU3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453073577", "bodyText": "Sure we can, but we should not touch public surface implementations here as this PR should only target the tracing APIs.\nI have created a work item for this refactor work : #13031", "author": "kushagraThapar", "createdAt": "2020-07-10T20:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MzQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NDQ1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452564457", "bodyText": "same here.\nSome methods could be reused instead of having the code repetition of withContext", "author": "samvaity", "createdAt": "2020-07-10T00:46:07Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -240,19 +234,8 @@ boolean isContentResponseOnWriteEnabled() {\n      * @return the mono.\n      */\n     public Mono<CosmosDatabaseResponse> createDatabaseIfNotExists(String id, ThroughputProperties throughputProperties) {", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzODI5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452938294", "bodyText": "We could do that, but avoiding nesting call in public api. Also it would be easier to read and debug. And our tracer goal getting fulfill with current design, so if you don't mind, can we keep it in current state?", "author": "simplynaveen20", "createdAt": "2020-07-10T16:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NDQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3MzczNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453073737", "bodyText": "same here, tracking the work item here: #13031", "author": "kushagraThapar", "createdAt": "2020-07-10T20:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NDY3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452564672", "bodyText": "same here.", "author": "samvaity", "createdAt": "2020-07-10T00:47:04Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -328,12 +307,12 @@ boolean isContentResponseOnWriteEnabled() {\n         if (options == null) {\n             options = new CosmosDatabaseRequestOptions();\n         }\n+\n         ModelBridgeInternal.setThroughputProperties(options, throughputProperties);\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseProperties.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosDatabaseResponse(databaseResourceResponse))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;\n+        return withContext(context -> createDatabaseInternal(wrappedDatabase, requestOptions, context));", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Mzc4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453073785", "bodyText": "same here.", "author": "kushagraThapar", "createdAt": "2020-07-10T20:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NDY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NTE5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452565193", "bodyText": "Cannot comment but the package-private method on L348 doesn't seem to be used anywhere?", "author": "samvaity", "createdAt": "2020-07-10T00:49:10Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -397,12 +376,13 @@ boolean isContentResponseOnWriteEnabled() {\n      */\n     CosmosPagedFlux<CosmosDatabaseProperties> readAllDatabases(CosmosQueryRequestOptions options) {", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2ODYwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452968601", "bodyText": "it was there in master too , however delete it now", "author": "simplynaveen20", "createdAt": "2020-07-10T17:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NDk2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453074968", "bodyText": "We need to keep those APIs @samvaity  - because they will be introduced later.\nWe intentionally made them package-private. They will be introduced in upcoming versions once we have the correct \"read feed\" implementation.\n@simplynaveen20 - please introduce it back.", "author": "kushagraThapar", "createdAt": "2020-07-10T21:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5Nzc4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453797787", "bodyText": "I think Sameekha was taking about createDatabase on L348 , it is not needed . so we good here", "author": "simplynaveen20", "createdAt": "2020-07-13T17:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NTc0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452565746", "bodyText": "This public API seems to be missing tracing instrumentation?", "author": "samvaity", "createdAt": "2020-07-10T00:51:18Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -432,7 +412,7 @@ boolean isContentResponseOnWriteEnabled() {\n      * @return a {@link CosmosPagedFlux} containing one or several feed response pages of read databases or an error.\n      */\n     public CosmosPagedFlux<CosmosDatabaseProperties> queryDatabases(String query, CosmosQueryRequestOptions options) {", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyOTQzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452929433", "bodyText": "This is query code and all tracer logic in query is here", "author": "simplynaveen20", "createdAt": "2020-07-10T15:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2NTc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2Nzg3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452567872", "bodyText": "I see we don't set the context object with nested data info for this method.\nI was wondering if it would be a better approach to always set the key but the value should determine if the call is nested or not. That should give us a more robust way to future developer don't miss this out.", "author": "samvaity", "createdAt": "2020-07-10T01:00:09Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +447,76 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, \"queryDatabases\", this.serviceEndpoint, null);", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyODg4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452928889", "bodyText": "I think this comment is misplaced, please clarify. This is query code and all tracer logic in query is here", "author": "simplynaveen20", "createdAt": "2020-07-10T15:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2Nzg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NTY4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453085685", "bodyText": "We will go by this approach,i.e adding nested data only on the api it needed , as this gave the best perf result, and adding data on all api might have an impact .", "author": "simplynaveen20", "createdAt": "2020-07-10T21:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2Nzg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzExODYxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453118615", "bodyText": "@samvaity - agreed, we can add nested / non-nested information on context always irrespective of the API if it doesn't result in a perf hit. Added it to this issue: #13031", "author": "kushagraThapar", "createdAt": "2020-07-10T23:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2Nzg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2ODU4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452568586", "bodyText": "nit: doesn;t need the extra variable assignment.", "author": "samvaity", "createdAt": "2020-07-10T01:03:26Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +447,76 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, \"queryDatabases\", this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseIfNotExistsInternal(database.readInternal(new CosmosDatabaseRequestOptions(), nestedContext), database, throughputProperties, nestedContext);\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,\n+            spanName,\n+            database.getId(),\n+            this.serviceEndpoint);\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(Mono<CosmosDatabaseResponse> responseMono, CosmosAsyncDatabase database, ThroughputProperties throughputProperties, Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if(throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    if (context != null) {\n+                        Database wrappedDatabase = new Database();\n+                        wrappedDatabase.setId(database.getId());\n+                        return createDatabaseInternal(wrappedDatabase,\n+                            requestOptions, context);\n+                    }\n+\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        requestOptions);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseInternal(Database database, CosmosDatabaseRequestOptions options,\n+                                                             Context context) {\n+        String spanName = \"createDatabase.\" + database.getId();\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseInternal(database, options);", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyNzEwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452927104", "bodyText": "Would like to keep it for readability", "author": "simplynaveen20", "createdAt": "2020-07-10T15:49:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2ODU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTY4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453075685", "bodyText": "@samvaity - we want more readability in these scenarios, where we are doing string concatenation inside the APIs.\nThis doesn't cause any perf hits, since this spanName will just reference the already created string.", "author": "kushagraThapar", "createdAt": "2020-07-10T21:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2ODU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2OTczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452569736", "bodyText": "When do we expect this context to be null?", "author": "samvaity", "createdAt": "2020-07-10T01:08:05Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +447,76 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, \"queryDatabases\", this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = createDatabaseIfNotExistsInternal(database.readInternal(new CosmosDatabaseRequestOptions(), nestedContext), database, throughputProperties, nestedContext);\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,\n+            spanName,\n+            database.getId(),\n+            this.serviceEndpoint);\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(Mono<CosmosDatabaseResponse> responseMono, CosmosAsyncDatabase database, ThroughputProperties throughputProperties, Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if(throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    if (context != null) {", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyNjg1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452926858", "bodyText": "it was needed when shortcuit was there. Not needed anymore, removed it.", "author": "simplynaveen20", "createdAt": "2020-07-10T15:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2OTczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3MzI4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452573287", "bodyText": "nit:  withContext(this::readThroughputInternal)", "author": "samvaity", "createdAt": "2020-07-10T01:22:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -665,30 +672,9 @@ public CosmosAsyncConflict getConflict(String id) {\n      * @return the mono containing throughput response.\n      */\n     public Mono<ThroughputResponse> readThroughput() {\n-        return this.read()\n-                   .flatMap(response -> this.database.getDocClientWrapper()\n-                                            .queryOffers(database.getOfferQuerySpecFromResourceId(response.getProperties()\n-                                                                                                      .getResourceId())\n-                                                , new CosmosQueryRequestOptions())\n-                                            .single()\n-                                            .flatMap(offerFeedResponse -> {\n-                                                if (offerFeedResponse.getResults().isEmpty()) {\n-                                                    return Mono.error(BridgeInternal\n-                                                                          .createCosmosException(\n-                                                                              HttpConstants.StatusCodes.BADREQUEST,\n-                                                                              \"No offers found for the resource \"\n-                                                                                  + this.getId()));\n-                                                }\n-                                                return this.database.getDocClientWrapper()\n-                                                           .readOffer(offerFeedResponse.getResults()\n-                                                                          .get(0)\n-                                                                          .getSelfLink())\n-                                                           .single();\n-                                            })\n-                                            .map(ModelBridgeInternal::createThroughputRespose));\n+        return withContext(context -> readThroughputInternal(context));", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyNjIyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452926229", "bodyText": "Would like to keep it in current state as it will be in line with other withContext having more parameter apart from context", "author": "simplynaveen20", "createdAt": "2020-07-10T15:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3MzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NDA0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452574049", "bodyText": "Don't need to create an extra variable for options.\nreturn withContext(context -> readInternal(options == null ? new CosmosDatabaseRequestOptions() : options,\n            context));\nMore instances in the PR for this update.", "author": "samvaity", "createdAt": "2020-07-10T01:25:29Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -79,11 +82,8 @@ public String getId() {\n      * the read database or an error.\n      */\n     public Mono<CosmosDatabaseResponse> read(CosmosDatabaseRequestOptions options) {\n-        if (options == null) {\n-            options = new CosmosDatabaseRequestOptions();\n-        }\n-        return getDocClientWrapper().readDatabase(getLink(), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosDatabaseResponse(response)).single();\n+        final CosmosDatabaseRequestOptions requestOptions = options == null ? new CosmosDatabaseRequestOptions() : options;\n+        return withContext(context -> readInternal(requestOptions, context));", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyNTY0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452925646", "bodyText": "We do need a final variable if we are using in labda. Otherwise it gives compile error", "author": "simplynaveen20", "createdAt": "2020-07-10T15:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NDA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NDk0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452574943", "bodyText": "Rather than calling the withContext you can call the method on L342.", "author": "samvaity", "createdAt": "2020-07-10T01:29:04Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -328,7 +323,8 @@ public String getId() {\n         CosmosContainerRequestOptions options = new CosmosContainerRequestOptions();\n         ModelBridgeInternal.setThroughputProperties(options, throughputProperties);\n         CosmosAsyncContainer container = getContainer(containerProperties.getId());\n-        return createContainerIfNotExistsInternal(containerProperties, container, options);\n+        return withContext(context -> createContainerIfNotExistsInternal(containerProperties, container, options,", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyNTE2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452925161", "bodyText": "Api mentioned at L342 is different. Current one take throughput from user", "author": "simplynaveen20", "createdAt": "2020-07-10T15:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NDk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjMyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453076324", "bodyText": "Tracking this refactor API issue here: #13031\nNo need to block the tracing PR for this.", "author": "kushagraThapar", "createdAt": "2020-07-10T21:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NDk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTE5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452575191", "bodyText": "therefor --> therefore/hence", "author": "samvaity", "createdAt": "2020-07-10T01:29:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -345,76 +341,61 @@ public String getId() {\n      */\n     public Mono<CosmosContainerResponse> createContainerIfNotExists(String id, String partitionKeyPath) {\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath),\n-                                                  container,\n-                                                  null);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,\n+                partitionKeyPath), container, null,\n+            context));\n     }\n \n     /**\n      * Creates a Cosmos container if it does not exist on the service.\n      * <p>\n-     * The throughput setting will only be used if the specified container\n-     * does not exist and a new container will be created.\n+     * The throughput properties will only be used if the specified container\n+     * does not exist and therefor a new container will be created.", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyNDM0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452924349", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-10T15:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTM0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452575346", "bodyText": "This API was made public, intentional?", "author": "samvaity", "createdAt": "2020-07-10T01:30:29Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -345,76 +341,61 @@ public String getId() {\n      */\n     public Mono<CosmosContainerResponse> createContainerIfNotExists(String id, String partitionKeyPath) {\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath),\n-                                                  container,\n-                                                  null);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,\n+                partitionKeyPath), container, null,\n+            context));\n     }\n \n     /**\n      * Creates a Cosmos container if it does not exist on the service.\n      * <p>\n-     * The throughput setting will only be used if the specified container\n-     * does not exist and a new container will be created.\n+     * The throughput properties will only be used if the specified container\n+     * does not exist and therefor a new container will be created.\n      *\n      * After subscription the operation will be performed. The {@link Mono} upon\n      * successful completion will contain a cosmos container response with the\n      * created container. In case of failure the {@link Mono} will error.\n      *\n      * @param id the cosmos container id.\n      * @param partitionKeyPath the partition key path.\n-     * @param throughput the throughput for the container.\n+     * @param throughputProperties the throughput properties for the container.\n      * @return a {@link Mono} containing the cosmos container response with the\n      * created container or an error.\n      */\n-    Mono<CosmosContainerResponse> createContainerIfNotExists(\n+    public Mono<CosmosContainerResponse> createContainerIfNotExists(", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyNDI4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452924280", "bodyText": "Havent made it public. Your are seeing this due to git hub diff. Check both are different api with different parameters.", "author": "simplynaveen20", "createdAt": "2020-07-10T15:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTY4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452575681", "bodyText": "same with the withContext call can it be deferred to the last/final internal call.", "author": "samvaity", "createdAt": "2020-07-10T01:31:49Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -345,76 +341,61 @@ public String getId() {\n      */\n     public Mono<CosmosContainerResponse> createContainerIfNotExists(String id, String partitionKeyPath) {\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath),\n-                                                  container,\n-                                                  null);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,\n+                partitionKeyPath), container, null,\n+            context));\n     }\n \n     /**\n      * Creates a Cosmos container if it does not exist on the service.\n      * <p>\n-     * The throughput setting will only be used if the specified container\n-     * does not exist and a new container will be created.\n+     * The throughput properties will only be used if the specified container\n+     * does not exist and therefor a new container will be created.\n      *\n      * After subscription the operation will be performed. The {@link Mono} upon\n      * successful completion will contain a cosmos container response with the\n      * created container. In case of failure the {@link Mono} will error.\n      *\n      * @param id the cosmos container id.\n      * @param partitionKeyPath the partition key path.\n-     * @param throughput the throughput for the container.\n+     * @param throughputProperties the throughput properties for the container.\n      * @return a {@link Mono} containing the cosmos container response with the\n      * created container or an error.\n      */\n-    Mono<CosmosContainerResponse> createContainerIfNotExists(\n+    public Mono<CosmosContainerResponse> createContainerIfNotExists(\n         String id, String partitionKeyPath,\n-        int throughput) {\n+        ThroughputProperties throughputProperties) {\n         CosmosContainerRequestOptions options = new CosmosContainerRequestOptions();\n-        ModelBridgeInternal.setThroughputProperties(options, ThroughputProperties.createManualThroughput(throughput));\n+        ModelBridgeInternal.setThroughputProperties(options, throughputProperties);\n         CosmosAsyncContainer container = getContainer(id);\n-        return createContainerIfNotExistsInternal(new CosmosContainerProperties(id, partitionKeyPath), container,\n-                                                  options);\n+        return withContext(context -> createContainerIfNotExistsInternal(new CosmosContainerProperties(id,", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODgwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452578808", "bodyText": "and below", "author": "samvaity", "createdAt": "2020-07-10T01:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjQ5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453076497", "bodyText": "Internal implementation change : #13031", "author": "kushagraThapar", "createdAt": "2020-07-10T21:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NTY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjExMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452576113", "bodyText": "readAllContainers missing tracing/withContext intrumentation.", "author": "samvaity", "createdAt": "2020-07-10T01:33:50Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -464,7 +448,7 @@ public String getId() {\n      * obtained containers or an error.\n      */\n     public CosmosPagedFlux<CosmosContainerProperties> queryContainers(String query) {", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjk1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452922952", "bodyText": "All query instrumentation with tracer are at single place in CosmosPageFlux , where we are using fluxContext", "author": "simplynaveen20", "createdAt": "2020-07-10T15:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452576620", "bodyText": "CosmosQueryRequestOptions options could be null resulting in NPE?", "author": "samvaity", "createdAt": "2020-07-10T01:36:02Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -627,7 +604,7 @@ public CosmosAsyncContainer getContainer(String id) {\n      * obtained users or an error.\n      */\n     public CosmosPagedFlux<CosmosUserProperties> queryUsers(String query, CosmosQueryRequestOptions options) {\n-        return queryUsers(new SqlQuerySpec(query), options);\n+        return queryUsersInternal(new SqlQuerySpec(query), options);", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjc5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452922794", "bodyText": "There are two apis  for queryUsers, with option and without . With option, it need to be non null. Existing design", "author": "simplynaveen20", "createdAt": "2020-07-10T15:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NzMzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453077339", "bodyText": "This was discussed in API review versions earlier, we want these overriding APIs to provide better public surface access to end user.\nIf the user provides null with this API, its their fault, because the overriding API exists which doesn't take CosmosQueryRequestOptions", "author": "kushagraThapar", "createdAt": "2020-07-10T21:06:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NDExMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453084111", "bodyText": "[Not Blocking for this PR]\nInteresting..So by \"user fault\" you mean its acceptable for Cosmos API's to throw an NPE?\nJust curious why don't we do a null check upfront and let it flow through the code.  If it is an expected param, you could use a  Objects.requireNonNull(..)", "author": "samvaity", "createdAt": "2020-07-10T21:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyNDI1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456324252", "bodyText": "A method that returns a reactor publisher (CosmosPagedFlux here) should not throw an exception directly. The error has to flow through the error channel and the user should be able to use onError handler to gracefully handle exceptions. Also, since options are optional, the user should still be able to pass a null value and this method should not throw.", "author": "srnagar", "createdAt": "2020-07-17T09:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNzk3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r458107972", "bodyText": "tracking in #13298", "author": "simplynaveen20", "createdAt": "2020-07-21T13:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NzIxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452577213", "bodyText": "Don't need to an extra variable here, can directly be replaced by \"createUser.\" + this.getId().", "author": "samvaity", "createdAt": "2020-07-10T01:38:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -768,4 +697,219 @@ String getLink() {\n         return this.link;\n     }\n \n+    private CosmosPagedFlux<CosmosContainerProperties> queryContainersInternal(SqlQuerySpec querySpec\n+        , CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryContainers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryCollections(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosContainerPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+    private CosmosPagedFlux<CosmosUserProperties> queryUsersInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryUsers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryUsers(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponseWithQueryMetrics(\n+                    ModelBridgeInternal.getCosmosUserPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders(),\n+                    ModelBridgeInternal.queryMetrics(response)));\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosAsyncContainer container,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainerIfNotExistsInternal.\" + containerProperties.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        if (options == null) {\n+            options = new CosmosContainerRequestOptions();\n+        }\n+\n+        Mono<CosmosContainerResponse> responseMono = createContainerIfNotExistsInternal(container.read(options, nestedContext), containerProperties, options, nestedContext);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        Mono<CosmosContainerResponse> responseMono,\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    if(context != null) {\n+                        return createContainerInternal(containerProperties, options, context);\n+                    }\n+\n+                    return createContainer(containerProperties, options);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainer.\" + containerProperties.getId();\n+        Mono<CosmosContainerResponse> responseMono = createContainerInternal(containerProperties, options);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options) {\n+        return getDocClientWrapper()\n+            .createCollection(this.getLink(), ModelBridgeInternal.getV2Collection(containerProperties),\n+                ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosContainerResponse(response)).single();\n+    }\n+\n+    Mono<CosmosDatabaseResponse> readInternal(CosmosDatabaseRequestOptions options, Context context) {\n+        String spanName = \"readDatabase.\" + this.getId();\n+        Mono<CosmosDatabaseResponse> responseMono = readInternal(options);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> readInternal(CosmosDatabaseRequestOptions options) {\n+        return getDocClientWrapper().readDatabase(getLink(),\n+            ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosDatabaseResponse(response)).single();\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> deleteInternal(CosmosDatabaseRequestOptions options, Context context) {\n+        String spanName = \"deleteDatabase.\" + this.getId();\n+        Mono<CosmosDatabaseResponse> responseMono = deleteInternal(options);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosDatabaseResponse> deleteInternal(CosmosDatabaseRequestOptions options) {\n+        return getDocClientWrapper().deleteDatabase(getLink(),\n+            ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosDatabaseResponse(response)).single();\n+    }\n+\n+    private Mono<CosmosUserResponse> createUserInternal(CosmosUserProperties userProperties, Context context) {\n+        String spanName = \"createUser.\" + this.getId();\n+        Mono<CosmosUserResponse> responseMono = createUserInternal(userProperties);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMTgyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452921826", "bodyText": "We could remove the extra variable span name , but we would like to keep a separate, as it is more readable .", "author": "simplynaveen20", "createdAt": "2020-07-10T15:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NzIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NzQ5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453077499", "bodyText": "Readability is concern here, lets keep it as it is.", "author": "kushagraThapar", "createdAt": "2020-07-10T21:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NzIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODUwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452578507", "bodyText": "Same with queryContainers, don't seem to be having withContext update.", "author": "samvaity", "createdAt": "2020-07-10T01:44:39Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -464,7 +448,7 @@ public String getId() {\n      * obtained containers or an error.\n      */\n     public CosmosPagedFlux<CosmosContainerProperties> queryContainers(String query) {\n-        return queryContainers(new SqlQuerySpec(query));", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMTU0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452921544", "bodyText": "All query instrumentation with tracer are at single place in CosmosPageFlux , where we are using fluxContext", "author": "simplynaveen20", "createdAt": "2020-07-10T15:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTE0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452579148", "bodyText": "Same here, does not have context propagation of withContext", "author": "samvaity", "createdAt": "2020-07-10T01:47:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -642,7 +619,7 @@ public CosmosAsyncContainer getContainer(String id) {\n      * obtained users or an error.\n      */\n     public CosmosPagedFlux<CosmosUserProperties> queryUsers(SqlQuerySpec querySpec) {\n-        return queryUsers(querySpec, new CosmosQueryRequestOptions());\n+        return queryUsersInternal(querySpec, new CosmosQueryRequestOptions());", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTUyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452579527", "bodyText": "Why two methods for createContainerIfNotExistsInternal?\nCould we combine them?", "author": "samvaity", "createdAt": "2020-07-10T01:49:06Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -768,4 +697,219 @@ String getLink() {\n         return this.link;\n     }\n \n+    private CosmosPagedFlux<CosmosContainerProperties> queryContainersInternal(SqlQuerySpec querySpec\n+        , CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryContainers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryCollections(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosContainerPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+    private CosmosPagedFlux<CosmosUserProperties> queryUsersInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryUsers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryUsers(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponseWithQueryMetrics(\n+                    ModelBridgeInternal.getCosmosUserPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders(),\n+                    ModelBridgeInternal.queryMetrics(response)));\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosAsyncContainer container,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainerIfNotExistsInternal.\" + containerProperties.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        if (options == null) {\n+            options = new CosmosContainerRequestOptions();\n+        }\n+\n+        Mono<CosmosContainerResponse> responseMono = createContainerIfNotExistsInternal(container.read(options, nestedContext), containerProperties, options, nestedContext);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMTA2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452921065", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-07-10T15:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTg5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452579894", "bodyText": "This wouldn't be a good idea to be checking for context, since it can be anything and expected to be a property bag.\nRather check for a specific property/property value for which you would like to call a different method.", "author": "samvaity", "createdAt": "2020-07-10T01:50:39Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -768,4 +697,219 @@ String getLink() {\n         return this.link;\n     }\n \n+    private CosmosPagedFlux<CosmosContainerProperties> queryContainersInternal(SqlQuerySpec querySpec\n+        , CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryContainers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryCollections(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosContainerPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+    private CosmosPagedFlux<CosmosUserProperties> queryUsersInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryUsers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryUsers(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponseWithQueryMetrics(\n+                    ModelBridgeInternal.getCosmosUserPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders(),\n+                    ModelBridgeInternal.queryMetrics(response)));\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosAsyncContainer container,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainerIfNotExistsInternal.\" + containerProperties.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        if (options == null) {\n+            options = new CosmosContainerRequestOptions();\n+        }\n+\n+        Mono<CosmosContainerResponse> responseMono = createContainerIfNotExistsInternal(container.read(options, nestedContext), containerProperties, options, nestedContext);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        Mono<CosmosContainerResponse> responseMono,\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    if(context != null) {", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMDg5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452920891", "bodyText": "Removed the null check , it was getting used when we were doing short circuiting.", "author": "simplynaveen20", "createdAt": "2020-07-10T15:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3OTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MDEwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452580107", "bodyText": "general comment, spanNames don't need to be created outside of the method.", "author": "samvaity", "createdAt": "2020-07-10T01:51:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncDatabase.java", "diffHunk": "@@ -768,4 +697,219 @@ String getLink() {\n         return this.link;\n     }\n \n+    private CosmosPagedFlux<CosmosContainerProperties> queryContainersInternal(SqlQuerySpec querySpec\n+        , CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryContainers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryCollections(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosContainerPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+    private CosmosPagedFlux<CosmosUserProperties> queryUsersInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryUsers.\" + this.getId();\n+            pagedFluxOptions.setTracerInformation(this.getClient().getTracerProvider(), spanName,\n+                this.getClient().getServiceEndpoint(), getId());\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryUsers(getLink(), querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponseWithQueryMetrics(\n+                    ModelBridgeInternal.getCosmosUserPropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders(),\n+                    ModelBridgeInternal.queryMetrics(response)));\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosAsyncContainer container,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainerIfNotExistsInternal.\" + containerProperties.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        if (options == null) {\n+            options = new CosmosContainerRequestOptions();\n+        }\n+\n+        Mono<CosmosContainerResponse> responseMono = createContainerIfNotExistsInternal(container.read(options, nestedContext), containerProperties, options, nestedContext);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            getId(),\n+            getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerIfNotExistsInternal(\n+        Mono<CosmosContainerResponse> responseMono,\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        return responseMono.onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    if(context != null) {\n+                        return createContainerInternal(containerProperties, options, context);\n+                    }\n+\n+                    return createContainer(containerProperties, options);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+    }\n+\n+    private Mono<CosmosContainerResponse> createContainerInternal(\n+        CosmosContainerProperties containerProperties,\n+        CosmosContainerRequestOptions options,\n+        Context context) {\n+        String spanName = \"createContainer.\" + containerProperties.getId();\n+        Mono<CosmosContainerResponse> responseMono = createContainerInternal(containerProperties, options);\n+        return this.client.getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkxOTQ4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452919480", "bodyText": "Here it is inside the method", "author": "simplynaveen20", "createdAt": "2020-07-10T15:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MDEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NzY4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453077684", "bodyText": "Readability is concern here, lets keep it as it is.", "author": "kushagraThapar", "createdAt": "2020-07-10T21:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MDEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTA3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452581077", "bodyText": "Same comment about the span name.", "author": "samvaity", "createdAt": "2020-07-10T01:55:24Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncPermission.java", "diffHunk": "@@ -126,4 +121,67 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosPermissionResponse> readInternal(CosmosPermissionRequestOptions options, Context context) {\n+\n+        String spanName = \"readPermission.\" + cosmosUser.getId();\n+        Mono<CosmosPermissionResponse> responseMono = readInternal(options);\n+        return cosmosUser.getDatabase().getClient().getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMDQwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452920408", "bodyText": "We could remove the extra variable span name , but we would like to keep a separate, as it is more readable .", "author": "simplynaveen20", "createdAt": "2020-07-10T15:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Nzk1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453077951", "bodyText": "Readability is concern here, lets keep it as it is.", "author": "kushagraThapar", "createdAt": "2020-07-10T21:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTM3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452581374", "bodyText": "No too inclined on these two internal functions. If only called once could they be combined to a single method?", "author": "samvaity", "createdAt": "2020-07-10T01:56:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncPermission.java", "diffHunk": "@@ -126,4 +121,67 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosPermissionResponse> readInternal(CosmosPermissionRequestOptions options, Context context) {\n+\n+        String spanName = \"readPermission.\" + cosmosUser.getId();\n+        Mono<CosmosPermissionResponse> responseMono = readInternal(options);\n+        return cosmosUser.getDatabase().getClient().getTracerProvider().traceEnabledCosmosResponsePublisher(responseMono, context,\n+            spanName,\n+            cosmosUser.getDatabase().getId(),\n+            cosmosUser.getDatabase().getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosPermissionResponse> readInternal(CosmosPermissionRequestOptions options) {", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkxODg0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452918841", "bodyText": "it was done previously for short circuit ,  combined now", "author": "simplynaveen20", "createdAt": "2020-07-10T15:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTcxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452581717", "bodyText": "readAllStoredProcedures doesn't have withContext instrumentation.", "author": "samvaity", "createdAt": "2020-07-10T01:58:03Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncScripts.java", "diffHunk": "@@ -108,6 +108,11 @@\n      */\n     CosmosPagedFlux<CosmosStoredProcedureProperties> readAllStoredProcedures(CosmosQueryRequestOptions options) {", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkxNjcwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452916708", "bodyText": "All query instrumentation with tracer are at single place in CosmosPageFlux", "author": "simplynaveen20", "createdAt": "2020-07-10T15:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MjYwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452582605", "bodyText": "Don't see this used in the class.", "author": "samvaity", "createdAt": "2020-07-10T02:01:18Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private Tracer tracer;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkxNTU4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452915582", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-10T15:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MjYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MzY1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452583659", "bodyText": "Rather than this defaulting to 0 we should get the error status code from the Throwable itself.", "author": "samvaity", "createdAt": "2020-07-10T02:05:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private Tracer tracer;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final int ERROR_CODE = 0;\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        if (tracers.iterator().hasNext()) {\n+            tracer = tracers.iterator().next();\n+        }\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracer != null;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        local = local.addData(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME);\n+        local = tracer.start(methodName, local); // start the span and return the started span\n+        if (databaseId != null) {\n+            tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+        }\n+\n+        tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+        tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+        tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName,databaseId, endpoint,\n+            (T response) -> response.getStatusCode());\n+    }\n+\n+    public <T> Mono<CosmosItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosItemResponse<T>> resultPublisher,\n+                                                                                   Context context,\n+                                                                                   String spanName,\n+                                                                                   String databaseId,\n+                                                                                   String endpoint) {\n+        return traceEnabledPublisher(resultPublisher, context, spanName,databaseId, endpoint,\n+            CosmosItemResponse::getStatusCode);\n+    }\n+\n+    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n+                                             Context context,\n+                                             String spanName,\n+                                             String databaseId,\n+                                             String endpoint,\n+                                             Function<T, Integer> statusCodeFunc) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        Optional<Object> callDepth = context.getData(COSMOS_CALL_DEPTH);\n+        final boolean isNestedCall = callDepth.isPresent();\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isEnabled() && !isNestedCall) {\n+                    parentContext.set(this.startSpan(spanName, databaseId, endpoint,\n+                        context));\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isEnabled() && !isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), statusCodeFunc.apply(response));\n+                }\n+            }).doOnError(throwable -> {\n+                if (isEnabled() && !isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), ERROR_CODE);", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkxNTQ3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452915476", "bodyText": "We are already doing at the end by converting throwable to cosmos here  . And if it is non cosmos error , this 0 will be used", "author": "simplynaveen20", "createdAt": "2020-07-10T15:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MzY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4Mzg3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452583878", "bodyText": "Need unit tests for this class.", "author": "samvaity", "createdAt": "2020-07-10T02:06:50Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.", "originalCommit": "deb6978f7642675623ae06dcb34d2a186d66cadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkxMzkwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r452913903", "bodyText": "Can you please give the specifics, what all scenario would be good for unit testing.", "author": "simplynaveen20", "createdAt": "2020-07-10T15:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4Mzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3OTIyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453079220", "bodyText": "@samvaity - good idea, can you please suggest some ideas on how other SDKs are testing this and the coverage of TracerProvider?\nI am tracking the issue here : #13032\nCan you please provide the context on the issue and we will take care of it.\n@simplynaveen20 - please take this up on a follow up PR.", "author": "kushagraThapar", "createdAt": "2020-07-10T21:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4Mzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NzQwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453087402", "bodyText": "Some existing examples of unit testing this class could be found here https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TracerProviderTest.java\nIt may need to be updated (or not) to fit Cosmos scenarios.", "author": "samvaity", "createdAt": "2020-07-10T21:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4Mzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNjc3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r458106771", "bodyText": "as mentioned by Kushagra , tracking in #13032", "author": "simplynaveen20", "createdAt": "2020-07-21T13:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4Mzg3OA=="}], "type": "inlineReview"}, {"oid": "8af1cc9d56a405a9ec2bb72bac142b9d8c02890e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8af1cc9d56a405a9ec2bb72bac142b9d8c02890e", "message": "resolving comments", "committedDate": "2020-07-10T15:24:50Z", "type": "commit"}, {"oid": "798839c218d086be39a3463b17a681d39c179084", "url": "https://github.com/Azure/azure-sdk-for-java/commit/798839c218d086be39a3463b17a681d39c179084", "message": "resolving comment", "committedDate": "2020-07-10T15:33:32Z", "type": "commit"}, {"oid": "21c5743709725058254427079d898d2ad810da90", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21c5743709725058254427079d898d2ad810da90", "message": "resolving comment", "committedDate": "2020-07-10T15:34:00Z", "type": "commit"}, {"oid": "42e97890b47c2cfb06745bc4593003bd8f944b47", "url": "https://github.com/Azure/azure-sdk-for-java/commit/42e97890b47c2cfb06745bc4593003bd8f944b47", "message": "removing extra method", "committedDate": "2020-07-10T17:06:25Z", "type": "commit"}, {"oid": "be8d7ebbdd6ca856946093d058fa3045b56316fd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/be8d7ebbdd6ca856946093d058fa3045b56316fd", "message": "removing tets dependency", "committedDate": "2020-07-10T20:16:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3OTA1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453079056", "bodyText": "missing space before context", "author": "samvaity", "createdAt": "2020-07-10T21:11:13Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -500,11 +530,8 @@ public String getId() {\n         ModelBridgeInternal.setPartitionKey(options, partitionKey);\n         @SuppressWarnings(\"unchecked\")\n         Class<T> itemType = (Class<T>) item.getClass();\n-        return this.getDatabase()\n-                   .getDocClientWrapper()\n-                   .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n-                   .single();\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> replaceItemInternal(itemType, itemId, doc, requestOptions,context));", "originalCommit": "be8d7ebbdd6ca856946093d058fa3045b56316fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5ODczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453798736", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-07-13T17:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3OTA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwMjAzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453802031", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-07-13T17:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3OTA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MTM3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453081377", "bodyText": "@simplynaveen20 Was thinking about this a little bit. Would it be acceptable for Cosmos behavior to throw an NPE if the tracer failed to load?\nAs tracing being an added functionality would it rather be acceptable to log that the tracer could not be loaded rather than to throw and make it completely impossible for the users to use this functionality just because we want to mandate a code pattern for the developers?", "author": "samvaity", "createdAt": "2020-07-10T21:17:46Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -580,11 +603,14 @@ public CosmosAsyncScripts getScripts() {\n      */\n     public CosmosPagedFlux<CosmosConflictProperties> readAllConflicts(CosmosQueryRequestOptions options) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.getDatabase().getClient().getTracerProvider(),", "originalCommit": "be8d7ebbdd6ca856946093d058fa3045b56316fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NzU4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453087589", "bodyText": "Its not about tracer , its about tracerProvider. Null pointer wont come for non tracer user. It will only come for dev who will not use the tracer pipeline, irrespective of tracer present or not", "author": "simplynaveen20", "createdAt": "2020-07-10T21:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MTM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwOTQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453109418", "bodyText": "Null pointer exceptions should be an eager check.\ncc: @kushagraThapar", "author": "samvaity", "createdAt": "2020-07-10T22:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MTM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzExNTExNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453115116", "bodyText": "Agreed, we should check them upfront.\nUpdated the tracking issue to include this as well - #13031", "author": "kushagraThapar", "createdAt": "2020-07-10T23:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwOTgzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453109831", "bodyText": "Can the internal methods be combined here?", "author": "samvaity", "createdAt": "2020-07-10T22:47:35Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncConflict.java", "diffHunk": "@@ -106,4 +106,33 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosConflictResponse> readInternal(RequestOptions options, Context context) {", "originalCommit": "be8d7ebbdd6ca856946093d058fa3045b56316fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5ODgwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453798808", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-07-13T17:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwOTgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwMTgxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453801810", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-07-13T17:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwOTgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyMTk3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453121970", "bodyText": "@simplynaveen20 Non-blocking, what are your thoughts about combing these?", "author": "samvaity", "createdAt": "2020-07-10T23:37:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -709,4 +695,214 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        Mono<CosmosItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context,\n+            this.deleteItemSpanName,\n+            database.getId(),\n+            database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions) {\n+        return this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        Mono<CosmosItemResponse<T>> responseMono = replaceItemInternal(itemType, itemId, doc, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.replaceItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options) {\n+       return this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        Mono<CosmosItemResponse<T>> responseMono = upsertItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context,\n+            this.upsertItemSpanName,\n+            database.getId(),\n+            database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> itemType = (Class<T>) item.getClass();\n+        return this.getDatabase().getDocClientWrapper()\n+            .upsertDocument(this.getLink(), item,\n+                ModelBridgeInternal.toRequestOptions(options),\n+                true)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> readItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions, Class<T> itemType,\n+        Context context) {\n+        Mono<CosmosItemResponse<T>> responseMono = readItemInternal(itemId, requestOptions, itemType);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context,\n+            this.readItemSpanName,\n+            database.getId(),\n+            database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> readItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions, Class<T> itemType) {\n+        return this.getDatabase().getDocClientWrapper()\n+            .readDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    Mono<CosmosContainerResponse> read(CosmosContainerRequestOptions options, Context context) {", "originalCommit": "be8d7ebbdd6ca856946093d058fa3045b56316fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwMDUzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453800530", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-13T17:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyMTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwMTkyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453801925", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-07-13T17:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyMTk3MA=="}], "type": "inlineReview"}, {"oid": "1f9725c8608fb80cbb446f5f4f0c94b5754b97db", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f9725c8608fb80cbb446f5f4f0c94b5754b97db", "message": "adding span attribute unit test", "committedDate": "2020-07-13T17:02:12Z", "type": "commit"}, {"oid": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fc1296f69012aaf51b1b229ed1e36625cec14bc6", "message": "resolving comments", "committedDate": "2020-07-13T17:09:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgxMjUzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453812538", "bodyText": "same here, can combine these.", "author": "samvaity", "createdAt": "2020-07-13T17:29:14Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -221,16 +241,31 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosItemRequestOptions();\n         }\n+\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> createItemInternal(item, requestOptions, context));\n+    }\n+\n+    private <T> Mono<CosmosItemResponse<T>> createItemInternal(T item, CosmosItemRequestOptions options, Context context) {", "originalCommit": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNTkyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r458105928", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-21T13:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgxMjUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgxMzI2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453813263", "bodyText": "same here combine these internal methods.", "author": "samvaity", "createdAt": "2020-07-13T17:30:25Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -709,4 +695,210 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        Mono<CosmosItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context,\n+            this.deleteItemSpanName,\n+            database.getId(),\n+            database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosItemResponse<Object>> deleteItemInternal(", "originalCommit": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNTgzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r458105830", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-21T13:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgxMzI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0NzQzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453947434", "bodyText": "What is happening here, why are we setting attributes in a method that's verifying tracer attributes?", "author": "samvaity", "createdAt": "2020-07-13T21:35:43Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+            \"/pk\", 5000).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createContainerIfNotExists.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncDatabase.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncDatabase.readAllUsers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUsers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncDatabase.readAllContainers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllContainers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncContainer() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.read().block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readContainer.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncContainer.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        InternalObjectNode item = new InternalObjectNode();\n+        item.setId(ITEM_ID);\n+        cosmosAsyncContainer.createItem(item).block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncContainer.upsertItem(item,\n+            new CosmosItemRequestOptions()).block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"upsertItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.readItem(ITEM_ID, PartitionKey.NONE,\n+            InternalObjectNode.class).block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 5);\n+\n+        cosmosAsyncContainer.deleteItem(ITEM_ID, PartitionKey.NONE).block();\n+        Mockito.verify(tracerProvider, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 6);\n+\n+        cosmosAsyncContainer.readAllItems(new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllItems.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 7);\n+\n+        String query = \"select * from c where c.id = '\" + ITEM_ID + \"'\";\n+        cosmosAsyncContainer.queryItems(query, new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryItems.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 8);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncScripts() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllStoredProcedures(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Context context = tracerProviderCapture.getResult();\n+\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllStoredProcedures.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllTriggers.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUserDefinedFunctions.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        CosmosUserDefinedFunctionProperties cosmosUserDefinedFunctionProperties =\n+            getCosmosUserDefinedFunctionProperties();\n+        CosmosUserDefinedFunctionProperties resultUdf =\n+            cosmosAsyncContainer.getScripts().createUserDefinedFunction(cosmosUserDefinedFunctionProperties).block().getProperties();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createUserDefinedFunction.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).read().block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readUDF.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 5);\n+\n+        cosmosUserDefinedFunctionProperties.setBody(\"function() {var x = 15;}\");\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(resultUdf.getId()).replace(resultUdf).block();\n+        Mockito.verify(tracerProvider, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"replaceUDF.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 6);\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).delete().block();\n+        Mockito.verify(tracerProvider, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteUDF.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 8);\n+\n+        CosmosTriggerProperties cosmosTriggerProperties = getCosmosTriggerProperties();\n+        CosmosTriggerProperties resultTrigger =\n+            cosmosAsyncContainer.getScripts().createTrigger(cosmosTriggerProperties).block().getProperties();\n+        Mockito.verify(tracerProvider, Mockito.times(9)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createTrigger.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 9);\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).read().block();\n+        Mockito.verify(tracerProvider, Mockito.times(10)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readTrigger.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 10);\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).replace(resultTrigger).block();\n+        Mockito.verify(tracerProvider, Mockito.times(11)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"replaceTrigger.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 11);\n+\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(12)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().getTrigger(cosmosTriggerProperties.getId()).delete().block();\n+        Mockito.verify(tracerProvider, Mockito.times(13)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteTrigger.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 13);\n+\n+        CosmosStoredProcedureProperties procedureProperties = getCosmosStoredProcedureProperties();\n+        CosmosStoredProcedureProperties resultSproc =\n+            cosmosAsyncContainer.getScripts().createStoredProcedure(procedureProperties).block().getProperties();\n+        Mockito.verify(tracerProvider, Mockito.times(14)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createStoredProcedure.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 14);\n+\n+        cosmosAsyncContainer.getScripts().getStoredProcedure(procedureProperties.getId()).read().block();\n+        Mockito.verify(tracerProvider, Mockito.times(15)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readStoredProcedure.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 15);\n+\n+\n+        cosmosAsyncContainer.getScripts().getStoredProcedure(procedureProperties.getId()).replace(resultSproc).block();\n+        Mockito.verify(tracerProvider, Mockito.times(16)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"replaceStoredProcedure.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 16);\n+\n+        cosmosAsyncContainer.getScripts().readAllStoredProcedures(new CosmosQueryRequestOptions()).byPage().single().block();\n+\n+        cosmosAsyncContainer.getScripts().getStoredProcedure(procedureProperties.getId()).delete().block();\n+        Mockito.verify(tracerProvider, Mockito.times(18)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteStoredProcedure.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 18);\n+    }\n+\n+    @AfterClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void afterClass() {\n+        LifeCycleUtils.closeQuietly(client);\n+    }\n+\n+    private static CosmosUserDefinedFunctionProperties getCosmosUserDefinedFunctionProperties() {\n+        CosmosUserDefinedFunctionProperties udf =\n+            new CosmosUserDefinedFunctionProperties(UUID.randomUUID().toString(), \"function() {var x = 10;}\");\n+        return udf;\n+    }\n+\n+    private static CosmosTriggerProperties getCosmosTriggerProperties() {\n+        CosmosTriggerProperties trigger = new CosmosTriggerProperties(UUID.randomUUID().toString(), \"function() {var \" +\n+            \"x = 10;}\");\n+        trigger.setTriggerOperation(TriggerOperation.CREATE);\n+        trigger.setTriggerType(TriggerType.PRE);\n+        return trigger;\n+    }\n+\n+    private static CosmosStoredProcedureProperties getCosmosStoredProcedureProperties() {\n+        CosmosStoredProcedureProperties storedProcedureDef =\n+            new CosmosStoredProcedureProperties(UUID.randomUUID().toString(), \"function() {var x = 10;}\");\n+        return storedProcedureDef;\n+    }\n+\n+    private List<Tracer> getMockTracer(Tracer tracer) {\n+        List<Tracer> tracerList = new ArrayList<>();\n+        tracerList.add(tracer);\n+        Mockito.when(tracer.start(Matchers.anyString(), Matchers.any(Context.class))).thenReturn(Context.NONE);\n+        return tracerList;\n+    }\n+\n+    private void verifyTracerAttributes(Tracer mockTracer, String methodName, Context context, String databaseName,\n+                                        int numberOfTimesCalledWithinTest) {\n+        if (databaseName != null) {\n+            Mockito.verify(mockTracer, Mockito.times(numberOfTimesCalledWithinTest)).setAttribute(TracerProvider.DB_INSTANCE,\n+                databaseName, context);", "originalCommit": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1OTk0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453959944", "bodyText": "This   will not set any attribute,it is just mockito verify.", "author": "simplynaveen20", "createdAt": "2020-07-13T21:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0NzQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODQyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453948425", "bodyText": "We shouldn't be grouping more than one use case in a testing scenario. Please consider breaking this up, to be unit testing cases.", "author": "samvaity", "createdAt": "2020-07-13T21:37:54Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {", "originalCommit": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2MDk5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453960992", "bodyText": "We will cover unit tests  and refactoring as discuss in #13032", "author": "simplynaveen20", "createdAt": "2020-07-13T21:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODk1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453948957", "bodyText": "Does this mean we are expecting, there would be 5 spans for a single readItem?", "author": "samvaity", "createdAt": "2020-07-13T21:39:09Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+            \"/pk\", 5000).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createContainerIfNotExists.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncDatabase.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncDatabase.readAllUsers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUsers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncDatabase.readAllContainers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllContainers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncContainer() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.read().block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readContainer.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncContainer.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        InternalObjectNode item = new InternalObjectNode();\n+        item.setId(ITEM_ID);\n+        cosmosAsyncContainer.createItem(item).block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncContainer.upsertItem(item,\n+            new CosmosItemRequestOptions()).block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"upsertItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.readItem(ITEM_ID, PartitionKey.NONE,\n+            InternalObjectNode.class).block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),", "originalCommit": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2MTg4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453961889", "bodyText": "No there will be only 1 span for readItem. This is to verify how many times this method is called in test function.", "author": "simplynaveen20", "createdAt": "2020-07-13T22:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3NDgzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453974837", "bodyText": "Then that is an incorrect representation of the use case. As unit testing, the test should ideally be expecting 1 span for a single API call?", "author": "samvaity", "createdAt": "2020-07-13T22:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNTYwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r458105601", "bodyText": "We are checking incremental invocation based on api calls in single test case , which is clubbed together as per our object model , like all container apis are under one test", "author": "simplynaveen20", "createdAt": "2020-07-21T13:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0OTUyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453949528", "bodyText": "I thought we got rid of the span name readUDF and should be using the same public API name for user -API visibility concerns.", "author": "samvaity", "createdAt": "2020-07-13T21:40:23Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+            \"/pk\", 5000).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createContainerIfNotExists.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncDatabase.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncDatabase.readAllUsers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUsers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncDatabase.readAllContainers().byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllContainers.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncContainer() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.read().block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readContainer.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        try {\n+            cosmosAsyncContainer.readThroughput().block();\n+        } catch (CosmosException ex) {\n+            //do nothing\n+        }\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readThroughput.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        InternalObjectNode item = new InternalObjectNode();\n+        item.setId(ITEM_ID);\n+        cosmosAsyncContainer.createItem(item).block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        cosmosAsyncContainer.upsertItem(item,\n+            new CosmosItemRequestOptions()).block();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"upsertItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.readItem(ITEM_ID, PartitionKey.NONE,\n+            InternalObjectNode.class).block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 5);\n+\n+        cosmosAsyncContainer.deleteItem(ITEM_ID, PartitionKey.NONE).block();\n+        Mockito.verify(tracerProvider, Mockito.times(6)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"deleteItem.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 6);\n+\n+        cosmosAsyncContainer.readAllItems(new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(7)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllItems.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 7);\n+\n+        String query = \"select * from c where c.id = '\" + ITEM_ID + \"'\";\n+        cosmosAsyncContainer.queryItems(query, new CosmosQueryRequestOptions(), CosmosItemRequestOptions.class).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(8)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryItems.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 8);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncScripts() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncContainer.getScripts().readAllStoredProcedures(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Context context = tracerProviderCapture.getResult();\n+\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllStoredProcedures.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        cosmosAsyncContainer.getScripts().readAllTriggers(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllTriggers.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 2);\n+\n+        cosmosAsyncContainer.getScripts().readAllUserDefinedFunctions(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllUserDefinedFunctions.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 3);\n+\n+        CosmosUserDefinedFunctionProperties cosmosUserDefinedFunctionProperties =\n+            getCosmosUserDefinedFunctionProperties();\n+        CosmosUserDefinedFunctionProperties resultUdf =\n+            cosmosAsyncContainer.getScripts().createUserDefinedFunction(cosmosUserDefinedFunctionProperties).block().getProperties();\n+        Mockito.verify(tracerProvider, Mockito.times(4)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createUserDefinedFunction.\" + cosmosAsyncContainer.getId(), context,\n+            cosmosAsyncDatabase.getId(), 4);\n+\n+        cosmosAsyncContainer.getScripts().getUserDefinedFunction(cosmosUserDefinedFunctionProperties.getId()).read().block();\n+        Mockito.verify(tracerProvider, Mockito.times(5)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readUDF.\" + cosmosAsyncContainer.getId(), context,", "originalCommit": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NTY1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453965651", "bodyText": "we can do readUDF -> readUserDefinedFunction  ?, but cant do just read() as we have hierarchy model in cosmos and all resources use read() api", "author": "simplynaveen20", "createdAt": "2020-07-13T22:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0OTUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1MDMxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453950316", "bodyText": "Suggestion can be updated to check for the span name here\nMockito.verify(tracerProvider, Mockito.times(1)).startSpan(eq(\"createContainerIfNotExists\"), Matchers.anyString()", "author": "samvaity", "createdAt": "2020-07-13T21:42:04Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        cosmosAsyncDatabase.createContainerIfNotExists(cosmosAsyncContainer.getId(),\n+            \"/pk\", 5000).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),", "originalCommit": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1Njg3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453956877", "bodyText": "Mockito does not work with partial matching, it will give runtime error , and anyway we are checking span name on mock tracer so this does not needed", "author": "simplynaveen20", "createdAt": "2020-07-13T21:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1MDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2MDA0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453960042", "bodyText": "Not sure what you mean, an example of what I am suggesting https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/eventhubs/azure-messaging-eventhubs/src/test/java/com/azure/messaging/eventhubs/EventHubProducerAsyncClientTest.java#L426", "author": "samvaity", "createdAt": "2020-07-13T21:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1MDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAwMjU4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r454002581", "bodyText": "@simplynaveen20 - we should an incrementing counter instead of using numeral literal values in Mockito.times(1) call - so that it is much clear to us.", "author": "kushagraThapar", "createdAt": "2020-07-13T23:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1MDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNDQzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r458104434", "bodyText": "added incremental variable instead of numeral literal", "author": "simplynaveen20", "createdAt": "2020-07-21T13:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1MDMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NDUzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r453964534", "bodyText": "Do we need the spy if we have a mock of tracer list for a valid tracerProvider object?\nnit: Consider adding static import for Mockito methods.", "author": "samvaity", "createdAt": "2020-07-13T22:04:02Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,375 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.InternalObjectNode;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));\n+        ReflectionUtils.setTracerProvider(client, tracerProvider);\n+\n+        TracerProviderCapture tracerProviderCapture = new TracerProviderCapture();\n+        Mockito.doAnswer(tracerProviderCapture).when(tracerProvider).startSpan(Matchers.anyString(),\n+            Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Context context = tracerProviderCapture.getResult();\n+        Mockito.verify(tracerProvider, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"createDatabaseIfNotExists.\" + cosmosAsyncDatabase.getId(), context,\n+            cosmosAsyncDatabase.getId(), 1);\n+\n+        client.readAllDatabases(new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(2)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"readAllDatabases\", context, null, 2);\n+\n+\n+        String query = \"select * from c where c.id = '\" + cosmosAsyncDatabase.getId() + \"'\";\n+        client.queryDatabases(query, new CosmosQueryRequestOptions()).byPage().single().block();\n+        Mockito.verify(tracerProvider, Mockito.times(3)).startSpan(Matchers.anyString(), Matchers.anyString(),\n+            Matchers.anyString(), Matchers.any(Context.class));\n+        verifyTracerAttributes(mockTracer, \"queryDatabases\", context, null, 3);\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncDatabase() {\n+        Tracer mockTracer = Mockito.mock(Tracer.class);\n+        TracerProvider tracerProvider = Mockito.spy(new TracerProvider(getMockTracer(mockTracer)));", "originalCommit": "fc1296f69012aaf51b1b229ed1e36625cec14bc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzg1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r458103857", "bodyText": "we need spy to get the context from startSpan  to verify attributes , and also we are checking on number of timer startSpan is called on provider", "author": "simplynaveen20", "createdAt": "2020-07-21T13:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NDUzNA=="}], "type": "inlineReview"}, {"oid": "0a7aab07efdce2088ef79cd27ad62576d6064a25", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0a7aab07efdce2088ef79cd27ad62576d6064a25", "message": "resolving comments", "committedDate": "2020-07-14T18:33:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4MzUwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456283506", "bodyText": "Calling ServiceLoader.load() for each instance of the client is not required. This can be done once as the result of the loader doesn't change during the lifespan of the application.", "author": "srnagar", "createdAt": "2020-07-17T08:00:39Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -65,6 +71,7 @@\n         this.sessionCapturingOverride = builder.isSessionCapturingOverrideEnabled();\n         this.enableTransportClientSharing = builder.isConnectionSharingAcrossClientsEnabled();\n         this.contentResponseOnWriteEnabled = builder.isContentResponseOnWriteEnabled();\n+        this.tracerProvider = new TracerProvider(ServiceLoader.load(Tracer.class));", "originalCommit": "0a7aab07efdce2088ef79cd27ad62576d6064a25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzOTU3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r457439570", "bodyText": "Moved to static , during class load", "author": "simplynaveen20", "createdAt": "2020-07-20T14:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4MzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4Nzg5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456287894", "bodyText": "Should this be using the nestedContext instead since a new key, value pair is added to the original context?", "author": "srnagar", "createdAt": "2020-07-17T08:09:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -473,4 +429,63 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(SqlQuerySpec querySpec, CosmosQueryRequestOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, \"queryDatabases\", this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                           ThroughputProperties throughputProperties, Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Context nestedContext = context.addData(TracerProvider.COSMOS_CALL_DEPTH, TracerProvider.COSMOS_CALL_DEPTH_VAL);\n+        Mono<CosmosDatabaseResponse> responseMono = database.readInternal(new CosmosDatabaseRequestOptions(),\n+            nestedContext).onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosException) {\n+                final CosmosException cosmosException = (CosmosException) unwrappedException;\n+                if (cosmosException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    CosmosDatabaseRequestOptions requestOptions = new CosmosDatabaseRequestOptions();\n+                    if (throughputProperties != null) {\n+                        ModelBridgeInternal.setThroughputProperties(requestOptions, throughputProperties);\n+                    }\n+\n+                    Database wrappedDatabase = new Database();\n+                    wrappedDatabase.setId(database.getId());\n+                    return createDatabaseInternal(wrappedDatabase,\n+                        requestOptions, nestedContext);\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });\n+        return tracerProvider.traceEnabledCosmosResponsePublisher(responseMono,\n+            context,", "originalCommit": "0a7aab07efdce2088ef79cd27ad62576d6064a25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4OTUwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456689504", "bodyText": "This to to avoid tracing for internal public api. Parent context is not affected by this. Initially we used subscriber context on all apis to filter nested/non nested apis, but due to perf hit moved to this model. Also explained  Srikanta offline", "author": "simplynaveen20", "createdAt": "2020-07-17T21:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4Nzg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyOTQ4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456329481", "bodyText": "nit: fix formatting.", "author": "srnagar", "createdAt": "2020-07-17T09:28:04Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private Tracer tracer;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final int ERROR_CODE = 0;\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        if (tracers.iterator().hasNext()) {\n+            tracer = tracers.iterator().next();\n+        }\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracer != null;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        local = local.addData(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME);\n+        local = tracer.start(methodName, local); // start the span and return the started span\n+        if (databaseId != null) {\n+            tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+        }\n+\n+        tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+        tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+        tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {", "originalCommit": "0a7aab07efdce2088ef79cd27ad62576d6064a25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8292a8342d170644c4fcc3fe91087008183b9ac1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8292a8342d170644c4fcc3fe91087008183b9ac1", "message": "resolving merge conflic and comments", "committedDate": "2020-07-17T21:47:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5MDE2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456690168", "bodyText": "what happens if there are multiple implementation for Tracer on the classpath? is that possible?", "author": "moderakh", "createdAt": "2020-07-17T21:54:19Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -52,8 +58,20 @@\n     private final AzureKeyCredential credential;\n     private final boolean sessionCapturingOverride;\n     private final boolean enableTransportClientSharing;\n+    private final TracerProvider tracerProvider;\n     private final DataEncryptionKeyProvider dataEncryptionKeyProvider;\n     private final boolean contentResponseOnWriteEnabled;\n+    private static final Tracer TRACER;\n+\n+    static {\n+        ServiceLoader<Tracer> serviceLoader = ServiceLoader.load(Tracer.class);\n+        Iterator<?> iterator = serviceLoader.iterator();\n+        if (iterator.hasNext()) {\n+            TRACER = serviceLoader.iterator().next();", "originalCommit": "8292a8342d170644c4fcc3fe91087008183b9ac1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5Mzk2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12867#discussion_r456693963", "bodyText": "There can be multiple implementations in the classpath. But there is no real use case to support multiple implementations as the user will always tie a specific implementation to an exporter.", "author": "samvaity", "createdAt": "2020-07-17T22:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5MDE2OA=="}], "type": "inlineReview"}]}