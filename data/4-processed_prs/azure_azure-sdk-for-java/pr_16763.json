{"pr_number": 16763, "pr_title": "Bulk API in Java", "pr_createdAt": "2020-10-23T15:42:38Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16763", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MTYwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513571600", "bodyText": "4.8.0 is out", "author": "moderakh", "createdAt": "2020-10-28T16:08:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.util.Beta;\n+\n+/**\n+ * Encapsulates options that can be specified for an operation used in Bulk execution. It can be passed while\n+ * creating bulk request using {@link BulkProcessingUtil}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjI0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412247", "bodyText": "Ack. Changed. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T03:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MTYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MzM4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513573386", "bodyText": "I don't see the api for CosmosContianer (sync version). could you please add that too.", "author": "moderakh", "createdAt": "2020-10-28T16:10:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -585,6 +586,71 @@ public String getId() {\n             });\n     }\n \n+    /**\n+     * Executes flux of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     *\n+     * @param operations Flux of operation which will be executed by this container.\n+     *\n+     * @return A Flux of {@link CosmosBulkOperationRequestAndResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkProcessingUtil}. For eg.\n+     *     for a upsert operation use {@link BulkProcessingUtil#getBulkUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationRequestAndResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationRequestAndResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationRequestAndResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_7_0)\n+    public <TContext> Flux<CosmosBulkOperationRequestAndResponse<TContext>> processBulkOperations(", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0OTU0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513649547", "bodyText": "Yeah I meant to ask you, should be take a list of operations there(without flux) and pass it to async one?", "author": "rakkuma", "createdAt": "2020-10-28T17:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MzM4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjMyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412325", "bodyText": "Have added sync api which takes list of operation and return list of responses.", "author": "rakkuma", "createdAt": "2020-11-03T03:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MzM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3NjY3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513576677", "bodyText": "please eat the \"Assertions\" into static import similar to other tests. here and elsewhere.", "author": "moderakh", "createdAt": "2020-10-28T16:15:16Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java", "diffHunk": "@@ -0,0 +1,401 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.models.PartitionKey;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.assertj.core.api.Assertions;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class CosmosBulkTest extends BatchTestBase {\n+\n+    private CosmosAsyncClient bulkClient;\n+    private CosmosAsyncContainer bulkAsyncContainer;\n+\n+    @Factory(dataProvider = \"clientBuildersWithDirectSession\")\n+    public CosmosBulkTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @BeforeClass(groups = {\"simple\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_CosmosBulkTest() {\n+        assertThat(this.bulkClient).isNull();\n+        this.bulkClient = getClientBuilder().buildAsyncClient();\n+        bulkAsyncContainer = getSharedMultiPartitionCosmosContainer(this.bulkClient);\n+    }\n+\n+    @AfterClass(groups = {\"simple\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        safeCloseAsync(this.bulkClient);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void createItem_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        Flux<CosmosItemOperation> cosmosItemOperationFlux = Flux.merge(\n+            Flux.range(0, totalRequest).map(i -> {\n+                String partitionKey = UUID.randomUUID().toString();\n+                TestDoc testDoc = this.populateTestDoc(partitionKey);\n+\n+                return BulkProcessingUtil.getBulkCreateItemOperation(testDoc, new PartitionKey(partitionKey));\n+            }),\n+            Flux.range(0, totalRequest).map(i -> {\n+                String partitionKey = UUID.randomUUID().toString();\n+                EventDoc eventDoc = new EventDoc(UUID.randomUUID().toString(), 2, 4, \"type1\", partitionKey);\n+\n+                return BulkProcessingUtil.getBulkCreateItemOperation(eventDoc, new PartitionKey(partitionKey));\n+            }));\n+\n+        BulkProcessingOptions<CosmosBulkTest> bulkProcessingOptions = new BulkProcessingOptions<>();\n+        bulkProcessingOptions.setMaxMicroBatchSize(100);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(5);\n+\n+        Flux<CosmosBulkOperationRequestAndResponse<CosmosBulkTest>> responseFlux = bulkAsyncContainer\n+            .processBulkOperations(cosmosItemOperationFlux, bulkProcessingOptions);\n+\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+        responseFlux\n+            .flatMap((CosmosBulkOperationRequestAndResponse<CosmosBulkTest> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.CREATED.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                return Mono.just(cosmosBulkItemResponse);\n+            }).blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest * 2);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void upsertItem_withbulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        List<CosmosItemOperation> cosmosItemOperations = new ArrayList<>();\n+\n+        for (int i = 0; i < totalRequest; i++) {\n+            String partitionKey = UUID.randomUUID().toString();\n+\n+            // use i as a identifier for re check.\n+            TestDoc testDoc = this.populateTestDoc(partitionKey, i, 20);\n+\n+            cosmosItemOperations.add(BulkProcessingUtil.getBulkUpsertItemOperation(testDoc, new PartitionKey(partitionKey)));\n+        }\n+\n+        BulkProcessingOptions<Object> bulkProcessingOptions = new BulkProcessingOptions<>();\n+        bulkProcessingOptions.setMaxMicroBatchSize(100);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(1);\n+\n+        Flux<CosmosBulkOperationRequestAndResponse<Object>> responseFlux = bulkAsyncContainer\n+            .processBulkOperations(Flux.fromIterable(cosmosItemOperations));\n+\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+        responseFlux\n+            .flatMap((CosmosBulkOperationRequestAndResponse<Object> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.CREATED.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                // Using cost as list index like we assigned\n+                TestDoc testDoc = cosmosBulkItemResponse.getItem(TestDoc.class);\n+                Assertions.assertThat(cosmosBulkOperationRequestAndResponse.getOperation()).isEqualTo(cosmosItemOperations.get(testDoc.getCost()));\n+                Assertions.assertThat(testDoc).isEqualTo(cosmosBulkOperationRequestAndResponse.getOperation().getItem());\n+                Assertions.assertThat(testDoc).isEqualTo(cosmosItemOperations.get(testDoc.getCost()).getItem());\n+\n+                return Mono.just(cosmosBulkItemResponse);\n+            }).blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void deleteItem_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        List<CosmosItemOperation> cosmosItemOperations = new ArrayList<>();\n+\n+        for (int i = 0; i < totalRequest; i++) {\n+            String partitionKey = UUID.randomUUID().toString();\n+\n+            // use i as a identifier for re check.\n+            TestDoc testDoc = this.populateTestDoc(partitionKey, i, 20);\n+\n+            cosmosItemOperations.add(BulkProcessingUtil.getBulkCreateItemOperation(testDoc, new PartitionKey(partitionKey)));\n+        }\n+        createItemsAndVerify(cosmosItemOperations);\n+\n+        Flux<CosmosItemOperation> deleteCosmosItemOperationFlux =\n+            Flux.fromIterable(cosmosItemOperations).map((CosmosItemOperation cosmosItemOperation) -> {\n+                TestDoc testDoc = cosmosItemOperation.getItem();\n+                return BulkProcessingUtil.getBulkDeleteItemOperation(testDoc.getId(), cosmosItemOperation.getPartitionKeyValue());\n+            });\n+\n+        BulkProcessingOptions<TestDoc> bulkProcessingOptions = new BulkProcessingOptions<>();\n+        bulkProcessingOptions.setMaxMicroBatchSize(30);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(1);\n+\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+        bulkAsyncContainer\n+            .processBulkOperations(deleteCosmosItemOperationFlux, bulkProcessingOptions)\n+            .flatMap((CosmosBulkOperationRequestAndResponse<TestDoc> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.NO_CONTENT.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                return Mono.just(cosmosBulkItemResponse);\n+            }).blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void readItem_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        List<CosmosItemOperation> cosmosItemOperations = new ArrayList<>();\n+\n+        for (int i = 0; i < totalRequest; i++) {\n+            String partitionKey = UUID.randomUUID().toString();\n+\n+            // use i as a identifier for re check.\n+            TestDoc testDoc = this.populateTestDoc(partitionKey, i, 20);\n+\n+            cosmosItemOperations.add(BulkProcessingUtil.getBulkUpsertItemOperation(testDoc, new PartitionKey(partitionKey)));\n+        }\n+\n+        createItemsAndVerify(cosmosItemOperations);\n+\n+        Flux<CosmosItemOperation> readCosmosItemOperationFlux =\n+            Flux.fromIterable(cosmosItemOperations).map((CosmosItemOperation cosmosItemOperation) -> {\n+                TestDoc testDoc = cosmosItemOperation.getItem();\n+                return BulkProcessingUtil.getBulkReadItemOperation(testDoc.getId(), cosmosItemOperation.getPartitionKeyValue());\n+            });\n+\n+        BulkProcessingOptions<Object> bulkProcessingOptions = new BulkProcessingOptions<>(Object.class);\n+        bulkProcessingOptions.setMaxMicroBatchSize(30);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(5);\n+\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+        bulkAsyncContainer\n+            .processBulkOperations(readCosmosItemOperationFlux, bulkProcessingOptions)\n+            .flatMap((CosmosBulkOperationRequestAndResponse<Object> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.OK.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                // Using cost as list index like we assigned\n+                TestDoc testDoc = cosmosBulkItemResponse.getItem(TestDoc.class);\n+                Assertions.assertThat(testDoc).isEqualTo(cosmosItemOperations.get(testDoc.getCost()).getItem());\n+\n+                return Mono.just(cosmosBulkItemResponse);\n+            }).blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void readItemMultipleTimes_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        List<CosmosItemOperation> cosmosItemOperations = new ArrayList<>();\n+\n+        for (int i = 0; i < totalRequest; i++) {\n+            String partitionKey = UUID.randomUUID().toString();\n+\n+            // use i as a identifier for re check.\n+            TestDoc testDoc = this.populateTestDoc(partitionKey, i, 20);\n+\n+            cosmosItemOperations.add(BulkProcessingUtil.getBulkUpsertItemOperation(testDoc, new PartitionKey(partitionKey)));\n+        }\n+\n+        createItemsAndVerify(cosmosItemOperations);\n+\n+        Flux<CosmosItemOperation> readCosmosItemOperationFlux =\n+            Flux.fromIterable(cosmosItemOperations).map((CosmosItemOperation cosmosItemOperation) -> {\n+                TestDoc testDoc = cosmosItemOperation.getItem();\n+                return BulkProcessingUtil.getBulkReadItemOperation(testDoc.getId(), cosmosItemOperation.getPartitionKeyValue());\n+            });\n+\n+        BulkProcessingOptions<Object> bulkProcessingOptions = new BulkProcessingOptions<>(Object.class);\n+        bulkProcessingOptions.setMaxMicroBatchSize(30);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(5);\n+\n+        HashSet<TestDoc> distinctDocs = new HashSet<>();\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+\n+        Flux<CosmosBulkOperationRequestAndResponse<Object>> readResponseFlux = bulkAsyncContainer\n+            .processBulkOperations(readCosmosItemOperationFlux, bulkProcessingOptions)\n+            .flatMap((CosmosBulkOperationRequestAndResponse<Object> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.OK.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                // Using cost as list index like we assigned\n+                TestDoc testDoc = cosmosBulkItemResponse.getItem(TestDoc.class);\n+                distinctDocs.add(testDoc);\n+                Assertions.assertThat(testDoc).isEqualTo(cosmosItemOperations.get(testDoc.getCost()).getItem());\n+\n+                return Mono.just(cosmosBulkOperationRequestAndResponse);\n+            });\n+\n+        // Subscribe first time\n+        readResponseFlux\n+            .blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest);", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjM1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412356", "bodyText": "Ack. Done. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T03:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3NjY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513622703", "bodyText": "@FabianMeiswinkel @kushagraThapar @kirankumarkolli thought on the naming?", "author": "moderakh", "createdAt": "2020-10-28T17:16:10Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingUtil.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.ItemBulkOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Utility for creating bulk operations which can be executed by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} .\n+ *\n+ * Also while creating these operation, if some options which are only for individual operation can be provided by passing\n+ * a {@link BulkItemRequestOptions} while creating the bulk operation.\n+ *\n+ * See also {@link BulkProcessingOptions}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class BulkProcessingUtil {", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MTAwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515891001", "bodyText": "My preference would be:\nBulkOperations as the class name\nFactory method names as newCreateItemOperation(T item, PartitionKey partitionKey) or newReadItemOperation(String id, PartitionKey partitionKey)\nI think the bulk can get removed because that is clear from the class name of the factory\nI like the newXXX naming convention for factory methods beter than createXXX - but would prefer either of them over getXXX", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T10:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412762", "bodyText": "Have changed class to BulkOperations, seems better actually. Have changed function names too. CreateXXX is confusing to me too as we have create as an operation too. newXXX seems fine, so changed it for now.", "author": "rakkuma", "createdAt": "2020-11-03T03:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0MjY5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518042690", "bodyText": "LGTM now - thanks!", "author": "FabianMeiswinkel", "createdAt": "2020-11-05T13:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNzAxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518437013", "bodyText": "BulkOperations looks good to me too.", "author": "kushagraThapar", "createdAt": "2020-11-05T23:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNTUyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513625527", "bodyText": "if the input operations Flux sends error signal, what is the expected behaviour?\nWe should have a test for this scenario to validate the behaviour.", "author": "moderakh", "createdAt": "2020-10-28T17:20:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -585,6 +586,71 @@ public String getId() {\n             });\n     }\n \n+    /**\n+     * Executes flux of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     *\n+     * @param operations Flux of operation which will be executed by this container.\n+     *\n+     * @return A Flux of {@link CosmosBulkOperationRequestAndResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkProcessingUtil}. For eg.\n+     *     for a upsert operation use {@link BulkProcessingUtil#getBulkUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationRequestAndResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationRequestAndResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationRequestAndResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_7_0)\n+    public <TContext> Flux<CosmosBulkOperationRequestAndResponse<TContext>> processBulkOperations(\n+        Flux<CosmosItemOperation> operations) {", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NTQ1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513655457", "bodyText": "Ack. Will do that. Thanks.", "author": "rakkuma", "createdAt": "2020-10-28T18:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNTUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513627941", "bodyText": "Could you paste a sample CosmosDiagnostics for bulk operation somewhere in the PR description? I wonder with all the newly introduced retries how it will look like.", "author": "moderakh", "createdAt": "2020-10-28T17:23:12Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,189 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @param <T> the type parameter\n+     *\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public <T> T getItem(final Class<T> type) {\n+        T item = null;\n+\n+        if (this.getResourceObject() != null) {\n+            item = new JsonSerializable(this.getResourceObject()).toObject(type);\n+        }\n+\n+        return item;\n+    }\n+\n+    /**\n+     * Gets retry after.\n+     *\n+     * @return the retry after\n+     */\n+    public Duration getRetryAfterDuration() {\n+        return this.retryAfter;\n+    }\n+\n+    /**\n+     * Gets sub status code associated with the current result.\n+     *\n+     * @return the sub status code\n+     */\n+    public int getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the current operation completed successfully.\n+     *\n+     * @return {@code true} if the current operation completed successfully; {@code false} otherwise.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return 200 <= this.statusCode && this.statusCode <= 299;\n+    }\n+\n+    /**\n+     * Gets the HTTP status code associated with the current result.\n+     *\n+     * @return the status code.\n+     */\n+    public int getStatusCode() {\n+        return this.statusCode;\n+    }\n+\n+    /**\n+     * Gets the cosmos diagnostic for this operation.\n+     *\n+     * @return the CosmosDiagnostics{@link CosmosDiagnostics}\n+     */\n+    public CosmosDiagnostics getCosmosDiagnostics() {", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1MjI1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513652252", "bodyText": "Right now in case there is a partial retry, it will have diagnostic for the last successful batch request as we don't have diagnostic operation wise.\nIf it's permissible to initialize one diagnostic operation wise then we can do some sort of merging there every time a batch request is executed? This will also help in adding diagnostic for getting partition key range id.", "author": "rakkuma", "createdAt": "2020-10-28T17:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5Mjk3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515892974", "bodyText": "Let's start with providing the sample here - then we can review whether it is sufficient or how we want to evolve it - makes sense?", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T10:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyNzMxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516727318", "bodyText": "Sure. So this is the sample for a direct TCP. You can see operation type batch and it's headers here. The response has session token and all.\n{\"userAgent\":\"azsdk-java-cosmos/4.9.0-beta.1 Windows10/10.0 JRE/1.8.0_211\",\"requestLatencyInMs\":3533,\"requestStartTimeUTC\":\"2020-11-03T14:09:54.676Z\",\"requestEndTimeUTC\":\"2020-11-03T14:09:58.209Z\",\"connectionMode\":\"DIRECT\",\"responseStatisticsList\":[{\"storeResult\":{\"storePhysicalAddress\":\"rntbd://cdb-ms-stage-eastus2-fd4.documents-staging.windows-ppe.net:14013/apps/b5716ed2-296e-4856-89aa-03d65f8dd46b/services/715cd67d-5ed6-4dd0-a256-bc574a605d13/partitions/6fb56c52-6f2f-4a37-a578-199d36bac8d2/replicas/132488385023590763p/\",\"lsn\":4,\"globalCommittedLsn\":3,\"partitionKeyRangeId\":\"1\",\"isValid\":true,\"statusCode\":200,\"subStatusCode\":0,\"isGone\":false,\"isNotFound\":false,\"isInvalidPartition\":false,\"requestCharge\":606.67,\"itemLSN\":-1,\"sessionToken\":\"-1#4\",\"exception\":null,\"transportRequestTimeline\":[{\"eventName\":\"created\",\"startTimeUTC\":\"2020-11-03T14:09:55.567Z\"},{\"eventName\":\"queued\",\"startTimeUTC\":\"2020-11-03T14:09:55.652Z\"},{\"eventName\":\"channelAcquisitionStarted\",\"startTimeUTC\":\"2020-11-03T14:09:55.652Z\"},{\"eventName\":\"pipelined\",\"startTimeUTC\":\"2020-11-03T14:09:57.185Z\"},{\"eventName\":\"transitTime\",\"startTimeUTC\":\"2020-11-03T14:09:57.256Z\"},{\"eventName\":\"received\",\"startTimeUTC\":\"2020-11-03T14:09:58.195Z\"},{\"eventName\":\"completed\",\"startTimeUTC\":\"2020-11-03T14:09:58.209Z\"}],\"rntbdRequestLengthInBytes\":22674,\"rntbdResponseLengthInBytes\":43263,\"requestPayloadLengthInBytes\":22186,\"responsePayloadLengthInBytes\":42934,\"channelTaskQueueSize\":0,\"pendingRequestsCount\":0,\"serviceEndpointStatistics\":{\"availableChannels\":0,\"acquiredChannels\":0,\"executorTaskQueueSize\":0,\"inflightRequests\":1,\"lastSuccessfulRequestTime\":\"2020-11-03T14:09:55.600Z\",\"lastRequestTime\":\"2020-11-03T14:09:55.600Z\",\"createdTime\":\"2020-11-03T14:09:55.578Z\",\"isClosed\":false}},\"requestResponseTimeUTC\":\"2020-11-03T14:09:58.209Z\",\"requestResourceType\":\"Document\",\"requestOperationType\":\"Batch\"}],\"supplementalResponseStatisticsList\":[],\"addressResolutionStatistics\":{\"3fa7837d-1dde-11eb-804d-03762526cb03\":{\"startTimeUTC\":\"2020-11-03T14:09:55.282Z\",\"endTimeUTC\":\"2020-11-03T14:09:55.561Z\",\"targetEndpoint\":\"https://rakkumastage-eastus2.documents-staging.windows-ppe.net:443/addresses/?$resolveFor=dbs%2FwEo8AA%3D%3D%2Fcolls%2FwEo8AJyCb1o%3D%2Fdocs&$filter=protocol%20eq%20rntbd&$partitionKeyRangeIds=1\",\"errorMessage\":null,\"inflightRequest\":false}},\"regionsContacted\":[\"https://rakkumastage-eastus2.documents-staging.windows-ppe.net:443/\"],\"retryContext\":{\"retryCount\":0,\"statusAndSubStatusCodes\":null,\"retryLatency\":0},\"metadataDiagnosticsContext\":{\"metadataDiagnosticList\":[{\"metaDataName\":\"CONTAINER_LOOK_UP\",\"startTimeUTC\":\"2020-11-03T14:09:54.676Z\",\"endTimeUTC\":\"2020-11-03T14:09:55.281Z\",\"durationinMS\":605},{\"metaDataName\":\"SERVER_ADDRESS_LOOKUP\",\"startTimeUTC\":\"2020-11-03T14:09:55.282Z\",\"endTimeUTC\":\"2020-11-03T14:09:55.561Z\",\"durationinMS\":279}]},\"serializationDiagnosticsContext\":{\"serializationDiagnosticsList\":[{\"serializationType\":\"ITEM_SERIALIZATION\",\"startTimeUTC\":\"2020-11-03T14:09:54.676Z\",\"endTimeUTC\":\"2020-11-03T14:09:54.676Z\",\"durationInMicroSec\":0}]},\"gatewayStatistics\":null,\"systemInformation\":{\"usedMemory\":\"46861 KB\",\"availableMemory\":\"1817331 KB\",\"systemCpuLoad\":\"(2020-11-03T14:09:49.474Z 12.9%), (2020-11-03T14:09:49.474Z 12.9%), (2020-11-03T14:09:49.474Z 12.9%), (2020-11-03T14:09:49.474Z 12.9%), (2020-11-03T14:09:49.588Z 12.9%), (2020-11-03T14:09:54.596Z 8.6%)\"},\"clientCfgs\":{\"id\":-3,\"numberOfClients\":4,\"connCfg\":{\"rntbd\":\"(cto:PT5S, rto:PT5S, icto:PT0S, ieto:PT1H, mcpe:130, mrpc:30, cer:false)\",\"gw\":\"(cps:1000, rto:PT5S, icto:null, p:false)\",\"other\":\"(ed: true, cs: false)\"},\"consistencyCfg\":\"(consistency: Session, mm: true, prgns: [])\"}}\nFor a gone exception(changed the pk range in code to get a gone):\nException:\nPartitionKeyRangeGoneException{userAgent=azsdk-java-cosmos/4.9.0-beta.1 Windows10/10.0 JRE/1.8.0_211, error={\"Errors\":[\"The requested resource is no longer available at the server.\"]}, resourceAddress='null', requestUri='null', statusCode=410, message=[\"The requested resource is no longer available at the server.\"], {\"userAgent\":\"azsdk-java-cosmos/4.9.0-beta.1 Windows10/10.0 JRE/1.8.0_211\",\"requestLatencyInMs\":0,\"requestStartTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"requestEndTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"connectionMode\":\"DIRECT\",\"responseStatisticsList\":[],\"supplementalResponseStatisticsList\":[],\"addressResolutionStatistics\":{},\"regionsContacted\":[],\"retryContext\":{\"retryCount\":0,\"statusAndSubStatusCodes\":null,\"retryLatency\":0},\"metadataDiagnosticsContext\":{\"metadataDiagnosticList\":null},\"serializationDiagnosticsContext\":{\"serializationDiagnosticsList\":[{\"serializationType\":\"ITEM_SERIALIZATION\",\"startTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"endTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"durationInMicroSec\":0}]},\"gatewayStatistics\":null,\"systemInformation\":{\"usedMemory\":\"59794 KB\",\"availableMemory\":\"1804398 KB\",\"systemCpuLoad\":\"(2020-11-03T14:48:01.426Z 20.5%), (2020-11-03T14:48:05.116Z 9.8%), (2020-11-03T14:48:10.120Z 16.0%)\"},\"clientCfgs\":{\"id\":-1,\"numberOfClients\":2,\"connCfg\":{\"rntbd\":\"(cto:PT5S, rto:PT5S, icto:PT0S, ieto:PT1H, mcpe:130, mrpc:30, cer:false)\",\"gw\":\"(cps:1000, rto:PT5S, icto:null, p:false)\",\"other\":\"(ed: true, cs: false)\"},\"consistencyCfg\":\"(consistency: Session, mm: true, prgns: [])\"}}, causeInfo=null, responseHeaders={x-ms-current-replica-set-size=4, x-ms-last-state-change-utc=Fri, 30 Oct 2020 16:31:52.563 GMT, lsn=1, x-ms-request-charge=0.00, x-ms-schemaversion=1.10, x-ms-transport-request-id=2, x-ms-number-of-read-regions=0, x-ms-current-write-quorum=3, x-ms-cosmos-quorum-acked-llsn=1, x-ms-quorum-acked-lsn=1, x-ms-activity-id=98d2de0c-1de3-11eb-8335-5de6f3380958, x-ms-xp-role=1, x-ms-global-Committed-lsn=1, x-ms-item-count=10, x-ms-cosmos-llsn=1, x-ms-serviceversion= version=2.11.0.0, x-ms-substatus=1002}, requestHeaders=null}\nDiagnostic for the same:\n{\"userAgent\":\"azsdk-java-cosmos/4.9.0-beta.1 Windows10/10.0 JRE/1.8.0_211\",\"requestLatencyInMs\":0,\"requestStartTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"requestEndTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"connectionMode\":\"DIRECT\",\"responseStatisticsList\":[],\"supplementalResponseStatisticsList\":[],\"addressResolutionStatistics\":{},\"regionsContacted\":[],\"retryContext\":{\"retryCount\":0,\"statusAndSubStatusCodes\":null,\"retryLatency\":0},\"metadataDiagnosticsContext\":{\"metadataDiagnosticList\":null},\"serializationDiagnosticsContext\":{\"serializationDiagnosticsList\":[{\"serializationType\":\"ITEM_SERIALIZATION\",\"startTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"endTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"durationInMicroSec\":0}]},\"gatewayStatistics\":null,\"systemInformation\":{\"usedMemory\":\"59794 KB\",\"availableMemory\":\"1804398 KB\",\"systemCpuLoad\":\"(2020-11-03T14:48:01.426Z 20.5%), (2020-11-03T14:48:05.116Z 9.8%), (2020-11-03T14:48:10.120Z 16.0%)\"},\"clientCfgs\":{\"id\":-1,\"numberOfClients\":2,\"connCfg\":{\"rntbd\":\"(cto:PT5S, rto:PT5S, icto:PT0S, ieto:PT1H, mcpe:130, mrpc:30, cer:false)\",\"gw\":\"(cps:1000, rto:PT5S, icto:null, p:false)\",\"other\":\"(ed: true, cs: false)\"},\"consistencyCfg\":\"(consistency: Session, mm: true, prgns: [])\"}}", "author": "rakkuma", "createdAt": "2020-11-03T14:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyOTEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516729103", "bodyText": "The retry logic works in gone, have tested all the test case with a one time gone exception such that if retry attempt is one, keep the valid pk range. But we need to fix the diagnostic such that it tracks this retry and any retry due to partial  throttling.", "author": "rakkuma", "createdAt": "2020-11-03T14:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513635788", "bodyText": "now that we are setting partitionKeyRangeId explicitly how do we support partition split scenario?\nIf after populating pkrangeId here partition gets splitted how do we react? what would be the the sequence of actions on partition split?", "author": "moderakh", "createdAt": "2020-10-28T17:34:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1330,8 @@ private RxDocumentServiceRequest addBatchHeaders(RxDocumentServiceRequest reques\n \n             request.setPartitionKeyInternal(partitionKeyInternal);\n             request.getHeaders().put(HttpConstants.HttpHeaders.PARTITION_KEY, Utils.escapeNonAscii(partitionKeyInternal.toJson()));\n+        } else if(serverBatchRequest instanceof PartitionKeyRangeServerBatchRequest) {\n+            request.setPartitionKeyRangeIdentity(new PartitionKeyRangeIdentity(((PartitionKeyRangeServerBatchRequest) serverBatchRequest).getPartitionKeyRangeId()));", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1MzY0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513653643", "bodyText": "Right now we will just return a gone and we can expect user to retry. To support that retry we have to move sink before grouping operations or keep two sinks for different retries i.e. one for throttling and one for gone.", "author": "rakkuma", "createdAt": "2020-10-28T18:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NTI5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515895299", "bodyText": "I think we need to provide that retry-logic out-of-the-box (vs. expecting users to do it)", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwNzAyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520307025", "bodyText": "The older bulk executor has support for partition splits... we should try to get at least the same with the new implementation.\nI think this whole retry logic might need some careful thought; ideally for any CosmosItemOperation that needs to be retried, it gets added back into the producer (Flux) after some initial logic that will take care of delays or handling partition splitting...", "author": "milismsft", "createdAt": "2020-11-10T06:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMxNTc2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520315767", "bodyText": "Do we get any delay information for split case? If yes we can add logic for it, otherwise we have retry for individual operations and does it only once.", "author": "rakkuma", "createdAt": "2020-11-10T06:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyMTk0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520321943", "bodyText": "Yes, there's a substatus code that indicates the failure is caused by a split; see https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorImpl.java#L128", "author": "milismsft", "createdAt": "2020-11-10T06:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyMzc3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520323776", "bodyText": "Yeah, so we are using it to put the operation in correct sink or if retry option is exhausted, return the exception.", "author": "rakkuma", "createdAt": "2020-11-10T06:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzMDUyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520930527", "bodyText": "physical partitioning of data and partition split are internal details of our service implementation. We should not expose this to the end user as contract.\nThe sdk needs to retry on partition spit internally. we do this for other operations today.\nThis can go to a different PR, but without it we can't announce bulk as feature.", "author": "moderakh", "createdAt": "2020-11-10T23:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4MDcxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r521080714", "bodyText": "we are retrying here. And I am keeping the retry policy in ItemBulkOperation but we are not returning ItemBulkOperation, we are returning CosmosItemOperation.", "author": "rakkuma", "createdAt": "2020-11-11T03:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODQ4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513638484", "bodyText": "previously RxClientCollectionCache was only used in RxDocumentClientImp and we always ensured that the passed connectionLink is normalized on leading or ending \"/\".\nThat's important as it ensures due to a mismatch on leading or ending \"/\" we don't get a mismatch.\nWe should ensure we are doing normalization of the containerLink similarly here.\nCould you validate this?", "author": "moderakh", "createdAt": "2020-10-28T17:38:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java", "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.ThrottlingRetryOptions;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.implementation.AsyncDocumentClient;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.caches.RxClientCollectionCache;\n+import com.azure.cosmos.implementation.routing.CollectionRoutingMap;\n+import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+import static com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper.getEffectivePartitionKeyString;\n+\n+final class BulkExecutorUtil {\n+\n+    static ServerOperationBatchRequest createBatchRequest(List<CosmosItemOperation> operations, String partitionKeyRangeId) {\n+\n+        return PartitionKeyRangeServerBatchRequest.createBatchRequest(\n+            partitionKeyRangeId,\n+            operations,\n+            BatchRequestResponseConstant.MAX_DIRECT_MODE_BATCH_REQUEST_BODY_SIZE_IN_BYTES,\n+            BatchRequestResponseConstant.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST);\n+    }\n+\n+    static void setRetryPolicyForBulk(CosmosItemOperation cosmosItemOperation, ThrottlingRetryOptions throttlingRetryOptions) {\n+        if(cosmosItemOperation instanceof ItemBulkOperation<?>) {\n+            final ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) cosmosItemOperation;\n+\n+            ResourceThrottleRetryPolicy resourceThrottleRetryPolicy = new ResourceThrottleRetryPolicy(\n+                throttlingRetryOptions.getMaxRetryAttemptsOnThrottledRequests(),\n+                throttlingRetryOptions.getMaxRetryWaitTime());\n+\n+            itemBulkOperation.setRetryPolicy(resourceThrottleRetryPolicy);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    static Mono<IRetryPolicy.ShouldRetryResult> shouldRetryForOperationResult(TransactionalBatchOperationResult result) {\n+\n+        checkNotNull(result, \"expected non-null result\");\n+        CosmosItemOperation cosmosItemOperation = result.getOperation();\n+\n+        if(cosmosItemOperation instanceof ItemBulkOperation<?>) {\n+\n+            // Create CosmosException for the next retry policy to understand:\n+            CosmosException exception = BridgeInternal.createCosmosException(\n+                result.getStatusCode(),\n+                null,\n+                BulkExecutorUtil.getResponseHeadersFromBatchOperationResult(result));\n+\n+            ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) cosmosItemOperation;\n+            return itemBulkOperation.getRetryPolicy().shouldRetry(exception);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    private static Map<String, String> getResponseHeadersFromBatchOperationResult(TransactionalBatchOperationResult result) {\n+        final Map<String, String> headers = new HashMap<>();\n+\n+        headers.put(HttpConstants.HttpHeaders.SUB_STATUS, String.valueOf(result.getSubStatusCode()));\n+        headers.put(HttpConstants.HttpHeaders.E_TAG, result.getETag());\n+        headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, String.valueOf(result.getRequestCharge()));\n+\n+        if (result.getRetryAfterDuration() != null) {\n+            headers.put(HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS, String.valueOf(result.getRetryAfterDuration().toMillis()));\n+        }\n+\n+        return headers;\n+    }\n+\n+    // TODO: metaDataDiagnosticContext is passed as null. Better way is to add this context to the cosmos diagnostic.\n+    static Mono<String> resolvePartitionKeyRangeId(\n+        AsyncDocumentClient docClientWrapper,\n+        CosmosAsyncContainer container,\n+        CosmosItemOperation operation) {\n+\n+        checkNotNull(operation, \"expected non-null operation\");\n+\n+        if(operation instanceof ItemBulkOperation<?>) {\n+            final ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) operation;\n+\n+            final Mono<String> pkRangeIdMono = BulkExecutorUtil.getCollectionInfoAsync(docClientWrapper, container)\n+                .flatMap(collection -> {\n+                    final PartitionKeyDefinition definition = collection.getPartitionKey();\n+                    final PartitionKeyInternal partitionKeyInternal = getPartitionKeyInternal(operation, definition);\n+                    itemBulkOperation.setPartitionKeyJson(partitionKeyInternal.toJson());\n+\n+                    return docClientWrapper.getPartitionKeyRangeCache()\n+                        .tryLookupAsync(null, collection.getResourceId(), null, null)\n+                        .map((Utils.ValueHolder<CollectionRoutingMap> routingMap) -> {\n+\n+                            return routingMap.v.getRangeByEffectivePartitionKey(\n+                                getEffectivePartitionKeyString(\n+                                    partitionKeyInternal,\n+                                    definition)).getId();\n+                        });\n+                });\n+\n+            return pkRangeIdMono;\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    private static PartitionKeyInternal getPartitionKeyInternal(\n+        final CosmosItemOperation operation,\n+        final PartitionKeyDefinition partitionKeyDefinition) {\n+\n+        checkNotNull(operation, \"expected non-null operation\");\n+\n+        final PartitionKey partitionKey = operation.getPartitionKeyValue();\n+        if (partitionKey == null) {\n+            return ModelBridgeInternal.getNonePartitionKey(partitionKeyDefinition);\n+        } else {\n+            return BridgeInternal.getPartitionKeyInternal(partitionKey);\n+        }\n+    }\n+\n+    private static Mono<DocumentCollection> getCollectionInfoAsync(AsyncDocumentClient documentClient,\n+                                                                   CosmosAsyncContainer container) {\n+        final RxClientCollectionCache clientCollectionCache = documentClient.getCollectionCache();\n+        return clientCollectionCache\n+            .resolveByNameAsync(\n+                null,\n+                BridgeInternal.getLink(container),", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY0MDg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516640862", "bodyText": "Have used the same way we sanitize in RxDocumentClientImp, using Utils.joinPath(BridgeInternal.getLink(container), null). This should ensure the above condition is always satisified.", "author": "rakkuma", "createdAt": "2020-11-03T12:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODc5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513638797", "bodyText": "doesn't passing null, result in missing to add this step to request diagnostics?", "author": "moderakh", "createdAt": "2020-10-28T17:38:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java", "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.ThrottlingRetryOptions;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.implementation.AsyncDocumentClient;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.caches.RxClientCollectionCache;\n+import com.azure.cosmos.implementation.routing.CollectionRoutingMap;\n+import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+import static com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper.getEffectivePartitionKeyString;\n+\n+final class BulkExecutorUtil {\n+\n+    static ServerOperationBatchRequest createBatchRequest(List<CosmosItemOperation> operations, String partitionKeyRangeId) {\n+\n+        return PartitionKeyRangeServerBatchRequest.createBatchRequest(\n+            partitionKeyRangeId,\n+            operations,\n+            BatchRequestResponseConstant.MAX_DIRECT_MODE_BATCH_REQUEST_BODY_SIZE_IN_BYTES,\n+            BatchRequestResponseConstant.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST);\n+    }\n+\n+    static void setRetryPolicyForBulk(CosmosItemOperation cosmosItemOperation, ThrottlingRetryOptions throttlingRetryOptions) {\n+        if(cosmosItemOperation instanceof ItemBulkOperation<?>) {\n+            final ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) cosmosItemOperation;\n+\n+            ResourceThrottleRetryPolicy resourceThrottleRetryPolicy = new ResourceThrottleRetryPolicy(\n+                throttlingRetryOptions.getMaxRetryAttemptsOnThrottledRequests(),\n+                throttlingRetryOptions.getMaxRetryWaitTime());\n+\n+            itemBulkOperation.setRetryPolicy(resourceThrottleRetryPolicy);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    static Mono<IRetryPolicy.ShouldRetryResult> shouldRetryForOperationResult(TransactionalBatchOperationResult result) {\n+\n+        checkNotNull(result, \"expected non-null result\");\n+        CosmosItemOperation cosmosItemOperation = result.getOperation();\n+\n+        if(cosmosItemOperation instanceof ItemBulkOperation<?>) {\n+\n+            // Create CosmosException for the next retry policy to understand:\n+            CosmosException exception = BridgeInternal.createCosmosException(\n+                result.getStatusCode(),\n+                null,\n+                BulkExecutorUtil.getResponseHeadersFromBatchOperationResult(result));\n+\n+            ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) cosmosItemOperation;\n+            return itemBulkOperation.getRetryPolicy().shouldRetry(exception);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    private static Map<String, String> getResponseHeadersFromBatchOperationResult(TransactionalBatchOperationResult result) {\n+        final Map<String, String> headers = new HashMap<>();\n+\n+        headers.put(HttpConstants.HttpHeaders.SUB_STATUS, String.valueOf(result.getSubStatusCode()));\n+        headers.put(HttpConstants.HttpHeaders.E_TAG, result.getETag());\n+        headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, String.valueOf(result.getRequestCharge()));\n+\n+        if (result.getRetryAfterDuration() != null) {\n+            headers.put(HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS, String.valueOf(result.getRetryAfterDuration().toMillis()));\n+        }\n+\n+        return headers;\n+    }\n+\n+    // TODO: metaDataDiagnosticContext is passed as null. Better way is to add this context to the cosmos diagnostic.\n+    static Mono<String> resolvePartitionKeyRangeId(\n+        AsyncDocumentClient docClientWrapper,\n+        CosmosAsyncContainer container,\n+        CosmosItemOperation operation) {\n+\n+        checkNotNull(operation, \"expected non-null operation\");\n+\n+        if(operation instanceof ItemBulkOperation<?>) {\n+            final ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) operation;\n+\n+            final Mono<String> pkRangeIdMono = BulkExecutorUtil.getCollectionInfoAsync(docClientWrapper, container)\n+                .flatMap(collection -> {\n+                    final PartitionKeyDefinition definition = collection.getPartitionKey();\n+                    final PartitionKeyInternal partitionKeyInternal = getPartitionKeyInternal(operation, definition);\n+                    itemBulkOperation.setPartitionKeyJson(partitionKeyInternal.toJson());\n+\n+                    return docClientWrapper.getPartitionKeyRangeCache()\n+                        .tryLookupAsync(null, collection.getResourceId(), null, null)\n+                        .map((Utils.ValueHolder<CollectionRoutingMap> routingMap) -> {\n+\n+                            return routingMap.v.getRangeByEffectivePartitionKey(\n+                                getEffectivePartitionKeyString(\n+                                    partitionKeyInternal,\n+                                    definition)).getId();\n+                        });\n+                });\n+\n+            return pkRangeIdMono;\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    private static PartitionKeyInternal getPartitionKeyInternal(\n+        final CosmosItemOperation operation,\n+        final PartitionKeyDefinition partitionKeyDefinition) {\n+\n+        checkNotNull(operation, \"expected non-null operation\");\n+\n+        final PartitionKey partitionKey = operation.getPartitionKeyValue();\n+        if (partitionKey == null) {\n+            return ModelBridgeInternal.getNonePartitionKey(partitionKeyDefinition);\n+        } else {\n+            return BridgeInternal.getPartitionKeyInternal(partitionKey);\n+        }\n+    }\n+\n+    private static Mono<DocumentCollection> getCollectionInfoAsync(AsyncDocumentClient documentClient,\n+                                                                   CosmosAsyncContainer container) {\n+        final RxClientCollectionCache clientCollectionCache = documentClient.getCollectionCache();\n+        return clientCollectionCache\n+            .resolveByNameAsync(\n+                null,", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzMDk3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520930978", "bodyText": "I still see that this hasn't been done. could you please add a TODO in the code with your alias?", "author": "moderakh", "createdAt": "2020-11-10T23:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4NzkwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r521087904", "bodyText": "Apologise Mo. Will add one. This all should be handled when we are adding diagnostic operation wise.", "author": "rakkuma", "createdAt": "2020-11-11T03:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0MzA1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513643052", "bodyText": "still we are passing RxDocumentServiceRequest to the lower part of stack.\nPartitionKeyRangeServerBatchRequest at some point will be translated to a RxDocumentServiceRequest. am I right?", "author": "moderakh", "createdAt": "2020-10-28T17:44:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosItemOperation;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+public final class PartitionKeyRangeServerBatchRequest extends ServerBatchRequest {", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NDk5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513654994", "bodyText": "Yeah, this is just a container to get values when we are converting to RxDocumentServiceRequest.", "author": "rakkuma", "createdAt": "2020-10-28T18:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0MzA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513645455", "bodyText": "PartitionKeyRangeServerBatchRequest at some point will be translated to a RxDocumentServiceRequest. right? how does partition split proofing work?\nPartitionKeyRangeServerBatchRequest may contain multiple documents. we create one RxDocumentServiceRequest out of all those documents. now if a partition split happens we cannot just retry the same RxDocumentServiceRequest as some documents may go to a left child some to the right child partition. how are we handling that scenario with retries?", "author": "moderakh", "createdAt": "2020-10-28T17:48:21Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosItemOperation;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+public final class PartitionKeyRangeServerBatchRequest extends ServerBatchRequest {\n+\n+    private final String partitionKeyRangeId;", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwOTA5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515909092", "bodyText": "+1 - we need a separate retry policy that will cover splitting the individual operations into the \"right\" partition. I assume this means we need to back-channel documents impacted into a GoneRetryQueue (which is handled in parallel with the incoming flux of operations). Bulk executor library is handling this similarly...", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNTEyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515935123", "bodyText": "Have handled it using a sink, which will re-evaluate the partition key range id. And we definitely need sink for overflows as handling overflow parallelly can multiple the parallelism factor, so seems fine to use it in case of Gone also.", "author": "rakkuma", "createdAt": "2020-11-02T12:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzMzA2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520933062", "bodyText": "@rakkuma we need tests for partition split. please add TODO and create github item to track this.\nwithout partition split support we cannot announce bulk.\n\nmocked unit tests: see DocumentProducerTest as a mocked unit tests for partition split on quer.\nend to end integration tests. see ReadMyWritesConsistencyTest as a e2e tests which tests partition split. essentially some of our CIs target prod, you can scale the throughput of the cosmos container which will result in partition split.\n\nI think tests for partition split and its implementation require more work. please capture this work after this PR gets in.", "author": "moderakh", "createdAt": "2020-11-10T23:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4ODcwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r521088707", "bodyText": "Partition split is handled already. Yeah the test case is remaining. I will try to add those in this PR only. Thanks.", "author": "rakkuma", "createdAt": "2020-11-11T03:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NjUxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513646512", "bodyText": "could you please also add tests for case when the input flux cosmosItemOperationFlux errors.", "author": "moderakh", "createdAt": "2020-10-28T17:49:50Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java", "diffHunk": "@@ -0,0 +1,401 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.models.PartitionKey;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.assertj.core.api.Assertions;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class CosmosBulkTest extends BatchTestBase {\n+\n+    private CosmosAsyncClient bulkClient;\n+    private CosmosAsyncContainer bulkAsyncContainer;\n+\n+    @Factory(dataProvider = \"clientBuildersWithDirectSession\")\n+    public CosmosBulkTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @BeforeClass(groups = {\"simple\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_CosmosBulkTest() {\n+        assertThat(this.bulkClient).isNull();\n+        this.bulkClient = getClientBuilder().buildAsyncClient();\n+        bulkAsyncContainer = getSharedMultiPartitionCosmosContainer(this.bulkClient);\n+    }\n+\n+    @AfterClass(groups = {\"simple\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        safeCloseAsync(this.bulkClient);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void createItem_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        Flux<CosmosItemOperation> cosmosItemOperationFlux = Flux.merge(\n+            Flux.range(0, totalRequest).map(i -> {\n+                String partitionKey = UUID.randomUUID().toString();\n+                TestDoc testDoc = this.populateTestDoc(partitionKey);\n+\n+                return BulkProcessingUtil.getBulkCreateItemOperation(testDoc, new PartitionKey(partitionKey));\n+            }),\n+            Flux.range(0, totalRequest).map(i -> {\n+                String partitionKey = UUID.randomUUID().toString();\n+                EventDoc eventDoc = new EventDoc(UUID.randomUUID().toString(), 2, 4, \"type1\", partitionKey);\n+\n+                return BulkProcessingUtil.getBulkCreateItemOperation(eventDoc, new PartitionKey(partitionKey));\n+            }));\n+\n+        BulkProcessingOptions<CosmosBulkTest> bulkProcessingOptions = new BulkProcessingOptions<>();\n+        bulkProcessingOptions.setMaxMicroBatchSize(100);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(5);\n+\n+        Flux<CosmosBulkOperationRequestAndResponse<CosmosBulkTest>> responseFlux = bulkAsyncContainer\n+            .processBulkOperations(cosmosItemOperationFlux, bulkProcessingOptions);", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjE0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412143", "bodyText": "Have added one Mo and will make it better. Right now we are eating up the errors passed, and I cannot find another way. I wanted to have a response for it too, with the operation/response null and user passed exception in CosmosBulkOperationResponse. Is ignoring the error signal a valid way?", "author": "rakkuma", "createdAt": "2020-11-03T03:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NjUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MjQ0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515892446", "bodyText": "200 >= instead of <=", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T10:56:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,189 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @param <T> the type parameter\n+     *\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public <T> T getItem(final Class<T> type) {\n+        T item = null;\n+\n+        if (this.getResourceObject() != null) {\n+            item = new JsonSerializable(this.getResourceObject()).toObject(type);\n+        }\n+\n+        return item;\n+    }\n+\n+    /**\n+     * Gets retry after.\n+     *\n+     * @return the retry after\n+     */\n+    public Duration getRetryAfterDuration() {\n+        return this.retryAfter;\n+    }\n+\n+    /**\n+     * Gets sub status code associated with the current result.\n+     *\n+     * @return the sub status code\n+     */\n+    public int getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the current operation completed successfully.\n+     *\n+     * @return {@code true} if the current operation completed successfully; {@code false} otherwise.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return 200 <= this.statusCode && this.statusCode <= 299;", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTc0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516639742", "bodyText": "Done. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T12:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5Mzk3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515893977", "bodyText": "IMO CosmosBulkOperationResposne is sufficient - like in HttpClient's API HttpResponseMessage also has a link back to request.", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T10:59:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Request, response and the exception(if any) for a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class CosmosBulkOperationRequestAndResponse<TContext> {", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTkwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516639907", "bodyText": "Fixed. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T12:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5Mzk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NDQ0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515894446", "bodyText": "Do we have to keep this as Throwable - or can we make it CosmosException? When would it ever contain a Throwable which is not wrapped as CosmosException?", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:00:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Request, response and the exception(if any) for a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class CosmosBulkOperationRequestAndResponse<TContext> {\n+\n+    private final CosmosItemOperation operation;\n+    private final CosmosBulkItemResponse response;\n+    private final Throwable throwable;\n+    private final TContext batchContext;\n+\n+    /**\n+     * Initialises a new instance of {@link CosmosBulkOperationRequestAndResponse}.\n+     *\n+     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n+     * @param response the {@link CosmosBulkItemResponse} the bulk response.\n+     * @param batchContext the context of this bulk request.\n+     */\n+    CosmosBulkOperationRequestAndResponse(CosmosItemOperation operation, CosmosBulkItemResponse response, TContext batchContext) {\n+        this.operation = operation;\n+        this.response = response;\n+        this.throwable = null;\n+        this.batchContext = batchContext;\n+    }\n+\n+    /**\n+     * Initialises a new instance of {@link CosmosBulkOperationRequestAndResponse}.\n+     *\n+     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n+     * @param throwable the {@link Throwable} for this request.\n+     * @param batchContext the context of this bulk request.\n+     */\n+    CosmosBulkOperationRequestAndResponse(CosmosItemOperation operation, Throwable throwable, TContext batchContext) {\n+        this.operation = operation;\n+        this.response = null;\n+        this.throwable = throwable;\n+        this.batchContext = batchContext;\n+    }\n+\n+    public CosmosItemOperation getOperation() {\n+        return operation;\n+    }\n+\n+    public CosmosBulkItemResponse getResponse() {\n+        return response;\n+    }\n+\n+    public Throwable getThrowable() {", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0OTY5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515949691", "bodyText": "Ideally we can keep CosmosException. But At most of the places I can see in try/catch we put Exception instead of CosmosException. So I am not sure if we should keep CosmosException?", "author": "rakkuma", "createdAt": "2020-11-02T12:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NDQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDI5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520934299", "bodyText": "I think it would be better to translate to CosmosException or at least Exception.\nthere are very few errors which are Throwable but not Exception. (e.g. StackOverFlowError or OutofMemeryError).\nif you get a throwable which is not exception you should fail the whole operation rather than the individual request/response.", "author": "moderakh", "createdAt": "2020-11-10T23:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NDQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg0NTk0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525845943", "bodyText": "Sure. Exception is cool. will do it. Thanks.", "author": "rakkuma", "createdAt": "2020-11-18T06:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NDQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwNTgxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515905810", "bodyText": "Shouldn't this retry policy also inherit from RetryPolicyWithDiagnostics?", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:21:47Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.implementation.HttpConstants.StatusCodes;\n+import com.azure.cosmos.implementation.HttpConstants.SubStatusCodes;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * A container to keep retry policies and functions for bulk.\n+ */\n+final class BulkOperationRetryPolicy {", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1NTQyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515955426", "bodyText": "Yeah, can help if/when we add some diagnostic info op wise.", "author": "rakkuma", "createdAt": "2020-11-02T13:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwNTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwOTQwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515909404", "bodyText": "Please fix this before check-in", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:28:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ServerBatchRequest.java", "diffHunk": "@@ -59,27 +59,31 @@\n         final ArrayNode arrayNode =  Utils.getSimpleObjectMapper().createArrayNode();\n \n         for(CosmosItemOperation operation : operations) {\n+            JsonSerializable operationJsonSerializable;\n+\n             if (operation instanceof ItemBatchOperation<?>) {\n-                final ItemBatchOperation<?> itemBatchOperation = (ItemBatchOperation<?>) operation;\n-                final JsonSerializable operationJsonSerializable = itemBatchOperation.serializeOperation();\n+                operationJsonSerializable = ((ItemBatchOperation<?>) operation).serializeOperation();\n+            } else if (operation instanceof ItemBulkOperation<?>) {\n+                operationJsonSerializable = ((ItemBulkOperation<?>) operation).serializeOperation();\n+            } else {\n+                throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+            }\n \n-                // TODO(rakkuma): If the string contains unicode the byte encoding len will be more. Fix it.\n-                // Issue: https://github.com/Azure/azure-sdk-for-java/issues/16112\n-                final int operationSerializedLength = operationJsonSerializable.toString().length();\n+            // TODO(rakkuma): If the string contains unicode the byte encoding len will be more. Fix it.", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMTM4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516411389", "bodyText": "Done. Have added test cases too to verify size overflow. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T03:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwOTQwNA=="}], "type": "inlineReview"}, {"oid": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "message": "Bulk\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-02T17:12:48Z", "type": "commit"}, {"oid": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "message": "Bulk\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-02T17:12:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0MTg2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518041860", "bodyText": "Needs to be 4.9.0 now - 4.8.0 was already released - Non-blocking of course - just make sure to update this before merging.", "author": "FabianMeiswinkel", "createdAt": "2020-11-05T13:16:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.util.Beta;\n+\n+/**\n+ * Encapsulates options that can be specified for an operation used in Bulk execution. It can be passed while\n+ * creating bulk request using {@link BulkOperations}.\n+ */\n+@Beta(Beta.SinceVersion.V4_8_0)", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0OTUwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518049506", "bodyText": "NIT: normalize indentation", "author": "FabianMeiswinkel", "createdAt": "2020-11-05T13:28:27Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequestTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.CosmosItemOperationType;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.models.PartitionKey;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class PartitionKeyRangeServerBatchRequestTests {\n+\n+    private static final int TIMEOUT = 40000;\n+\n+    private CosmosItemOperation createItemBulkOperation(String id) {\n+        ItemBulkOperation<?> operation = new ItemBulkOperation<>(\n+            CosmosItemOperationType.CREATE,\n+            id,\n+            PartitionKey.NONE,\n+            null,\n+            null\n+        );\n+\n+        return operation;\n+    }\n+\n+    @Test(groups = {\"unit\"}, timeOut = TIMEOUT)\n+    public void fitsAllOperations() {\n+        List<CosmosItemOperation> operations = new ArrayList<CosmosItemOperation>() {{\n+            createItemBulkOperation(\"\");\n+            createItemBulkOperation(\"\");\n+        }};\n+\n+        ServerOperationBatchRequest serverOperationBatchRequest = PartitionKeyRangeServerBatchRequest.createBatchRequest(\n+        \"0\",\n+            operations,\n+        200000,", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518181884", "bodyText": "nit: should it be BatchRequestResponseConstants?", "author": "xinlian12", "createdAt": "2020-11-05T16:23:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchRequestResponseConstant.java", "diffHunk": "@@ -7,12 +7,15 @@\n  * This contains all the extra constants needed for batch/bulk. This will be usefull even if Hybrid row comes in.\n  * This contains all the constants we have in Backend. Any addition to backend should be added here.\n  */\n-public class BatchRequestResponseConstant {\n+public final class BatchRequestResponseConstant {", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNDY3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518204671", "bodyText": "So technically bulk is also a batching, just that it is non-txn, and internally we use batch API.", "author": "rakkuma", "createdAt": "2020-11-05T16:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwOTc1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518209756", "bodyText": "oh, sorry, I was more around the naming part. Since this class contains multiple constants, so i think it should also reflect on the class name as well, *Constant -> *Constants", "author": "xinlian12", "createdAt": "2020-11-05T17:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMzY1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518213651", "bodyText": "Oh. Apologies. Will change it. Nice catch! Thanks.", "author": "rakkuma", "createdAt": "2020-11-05T17:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM5NjQzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518396430", "bodyText": "thanks", "author": "xinlian12", "createdAt": "2020-11-05T22:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4ODUxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518188518", "bodyText": "nit: statusCode is int, so may never be null?", "author": "xinlian12", "createdAt": "2020-11-05T16:32:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,189 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_8_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNTA4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518205086", "bodyText": "Agreed. Will remove the check. Thanks.", "author": "rakkuma", "createdAt": "2020-11-05T16:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4ODUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NjcyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518196724", "bodyText": "not sure, but just thinking should isContentResponseOnWriteEnabled add here?", "author": "xinlian12", "createdAt": "2020-11-05T16:43:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.util.Beta;\n+\n+/**\n+ * Encapsulates options that can be specified for an operation used in Bulk execution. It can be passed while\n+ * creating bulk request using {@link BulkOperations}.\n+ */\n+@Beta(Beta.SinceVersion.V4_8_0)\n+public final class BulkItemRequestOptions {\n+    private ConsistencyLevel consistencyLevel;\n+    private String sessionToken;\n+\n+    /**\n+     * Gets the consistency level required for the request.\n+     *\n+     * @return the consistency level.\n+     */\n+    ConsistencyLevel getConsistencyLevel() {\n+        return consistencyLevel;\n+    }\n+\n+    /**\n+     * Sets the consistency level required for the request.\n+     *\n+     * @param consistencyLevel the consistency level.\n+     * @return the BulkItemRequestOptions.\n+     */\n+    BulkItemRequestOptions setConsistencyLevel(ConsistencyLevel consistencyLevel) {\n+        this.consistencyLevel = consistencyLevel;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the token for use with session consistency.\n+     *\n+     * @return the session token.\n+     */\n+    public String getSessionToken() {\n+        return sessionToken;\n+    }\n+\n+    /**\n+     * Sets the token for use with session consistency.\n+     *\n+     * @param sessionToken the session token.\n+     * @return the BulkItemRequestOptions.\n+     */\n+    public BulkItemRequestOptions setSessionToken(String sessionToken) {\n+        this.sessionToken = sessionToken;\n+        return this;\n+    }\n+\n+    RequestOptions toRequestOptions() {", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwOTEzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518209136", "bodyText": "Yeah that should be added. Will add it. Thanks.", "author": "rakkuma", "createdAt": "2020-11-05T17:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NjcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMjc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518402762", "bodyText": "thanks~", "author": "xinlian12", "createdAt": "2020-11-05T22:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NjcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTcyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518235724", "bodyText": "This is a purely question.\nWhen I check the UnicastProcessor documentation, it says it will be removed in 3.5. Should we change to something else just in case in the future we upgrade to > 3.5.0? Currently we are using 3.3.9\n\"Deprecated.\nto be removed in 3.5, prefer clear cut usage of Sinks through variations under Sinks.many().unicast().\"", "author": "xinlian12", "createdAt": "2020-11-05T17:38:57Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.BulkProcessingOptions;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosBridgeInternal;\n+import com.azure.cosmos.CosmosBulkItemResponse;\n+import com.azure.cosmos.CosmosBulkOperationResponse;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.ThrottlingRetryOptions;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.AsyncDocumentClient;\n+import com.azure.cosmos.implementation.apachecommons.lang.tuple.Pair;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.GroupedFlux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.UnicastProcessor;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+public final class BulkExecutor<TContext> {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BulkExecutor.class);\n+\n+    private final CosmosAsyncContainer container;\n+    private final AsyncDocumentClient docClientWrapper;\n+    private final ThrottlingRetryOptions throttlingRetryOptions;\n+    private final Flux<CosmosItemOperation> inputOperations;\n+\n+    // Options for bulk execution.\n+    private final int maxMicroBatchSize;\n+    private final int maxMicroBatchConcurrency;\n+    private final Duration maxMicroBatchInterval;\n+    private final TContext batchContext;\n+\n+    // Handle gone error:\n+    private final AtomicBoolean mainSourceCompleted;\n+    private final AtomicInteger totalCount;\n+    private final FluxProcessor<CosmosItemOperation, CosmosItemOperation> mainFluxProcessor;\n+    private final FluxSink<CosmosItemOperation> mainSink;\n+    private final List<FluxSink<CosmosItemOperation>> groupSinks;\n+\n+    public BulkExecutor(CosmosAsyncContainer container,\n+                        Flux<CosmosItemOperation> inputOperations,\n+                        BulkProcessingOptions<TContext> bulkOptions) {\n+\n+        checkNotNull(container, \"expected non-null container\");\n+        checkNotNull(inputOperations, \"expected non-null inputOperations\");\n+        checkNotNull(bulkOptions, \"expected non-null bulkOptions\");\n+\n+        this.container = container;\n+        this.inputOperations = inputOperations;\n+        this.docClientWrapper = CosmosBridgeInternal.getAsyncDocumentClient(container.getDatabase());\n+        this.throttlingRetryOptions = docClientWrapper.getConnectionPolicy().getThrottlingRetryOptions();\n+\n+        // Fill the option first, to make the BulkProcessingOptions immutable, as if accessed directly, we might get\n+        // different values when a new group is created.\n+        maxMicroBatchSize = bulkOptions.getMaxMicroBatchSize();\n+        maxMicroBatchConcurrency = bulkOptions.getMaxMicroBatchConcurrency();\n+        maxMicroBatchInterval = bulkOptions.getMaxMicroBatchInterval();\n+        batchContext = bulkOptions.getBatchContext();\n+\n+        // Initialize sink for handling gone error.\n+        mainSourceCompleted = new AtomicBoolean(false);\n+        totalCount = new AtomicInteger(0);\n+        mainFluxProcessor = UnicastProcessor.<CosmosItemOperation>create().serialize();", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1MDA2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518250061", "bodyText": "As far as I know, they are just making it bit easy to use. SInk.Many.Unicast I think will serve this purpose (i.e. multiple producer one consumer). New one also have complete and emit options, so should be few init changes when we bump up the version.", "author": "rakkuma", "createdAt": "2020-11-05T17:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1NjI4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518256283", "bodyText": "https://github.com/reactor/reactor-core/blob/master/docs/asciidoc/processors.adoc", "author": "rakkuma", "createdAt": "2020-11-05T18:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMzA2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518403067", "bodyText": "I see, thanks for sharing the doc and sharing the details~", "author": "xinlian12", "createdAt": "2020-11-05T22:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NTUwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518285503", "bodyText": "We can optimize this by not serializing and converting everytime this method is called. Also, I see that diagnostics are added at some places. So if that is in scope of this PR, we could add serialization diagnostic here.  Refer CosmosItemResponse#getItem() for ideas", "author": "mbhaskar", "createdAt": "2020-11-05T18:52:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,189 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_8_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @param <T> the type parameter\n+     *\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public <T> T getItem(final Class<T> type) {", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5OTc5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518299795", "bodyText": "That optimization we thought we can do it later possibly. For the diagnostic part, the issue is for all the operations which were executed in same batch will have one instance of diagnostic, so any addition will get reflected in all the other responses which will be confusing to debug. To have a different diagnostic we need to have some kind of merge context where each bulk item response has a separate instance and the batch execution diag. context is merged in that, similarly this serialization context and pk range lookup context should be merged in that. And we can do this or some other implementation in a separate PR.", "author": "rakkuma", "createdAt": "2020-11-05T19:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNDE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518934190", "bodyText": "Sure, make sure these are tracked. Thankyou", "author": "mbhaskar", "createdAt": "2020-11-06T18:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NzAyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518387026", "bodyText": "I have two questions here:\n\n\nWhen these two exceptions happens, it will go back to the main sink and re-calculate the partitionKeyRangeId, but without refreshing the cache, we may get the same/old partitionKeyRangeId back. Where the cache is refreshed?\n\n\nCurrently we check for PARTITION_KEY_RANGE_GONE  and NAME_CACHE_IS_STALE exception, what about COMPLETING_SPLIT etc?", "author": "xinlian12", "createdAt": "2020-11-05T21:43:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.implementation.HttpConstants.StatusCodes;\n+import com.azure.cosmos.implementation.HttpConstants.SubStatusCodes;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import com.azure.cosmos.implementation.RetryPolicyWithDiagnostics;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * A container to keep retry policies and functions for bulk.\n+ */\n+final class BulkOperationRetryPolicy extends RetryPolicyWithDiagnostics {\n+\n+    private static final int MAX_RETRIES = 1;\n+\n+    private final ResourceThrottleRetryPolicy resourceThrottleRetryPolicy;\n+    private int attemptedRetries;\n+\n+    BulkOperationRetryPolicy(ResourceThrottleRetryPolicy resourceThrottleRetryPolicy) {\n+        this.resourceThrottleRetryPolicy = resourceThrottleRetryPolicy;\n+    }\n+\n+    final Mono<IRetryPolicy.ShouldRetryResult> shouldRetry(final TransactionalBatchOperationResult result) {\n+\n+        checkNotNull(result, \"expected non-null result\");\n+\n+        // Create CosmosException for the next retry policy to understand:\n+        CosmosException exception = BridgeInternal.createCosmosException(\n+            result.getStatusCode(),\n+            null,\n+            BulkExecutorUtil.getResponseHeadersFromBatchOperationResult(result));\n+\n+        if (this.resourceThrottleRetryPolicy == null) {\n+            return Mono.just(IRetryPolicy.ShouldRetryResult.noRetry());\n+        }\n+\n+        return this.resourceThrottleRetryPolicy.shouldRetry(exception);\n+    }\n+\n+    @Override\n+    public Mono<IRetryPolicy.ShouldRetryResult> shouldRetry(Exception exception) {\n+\n+        if (this.resourceThrottleRetryPolicy == null) {\n+            return Mono.just(IRetryPolicy.ShouldRetryResult.noRetry());\n+        }\n+\n+        return this.resourceThrottleRetryPolicy.shouldRetry(exception);\n+    }\n+\n+    boolean shouldRetryForGone(int statusCode, int subStatusCode) {\n+\n+        if (statusCode == StatusCodes.GONE\n+            && (subStatusCode == SubStatusCodes.PARTITION_KEY_RANGE_GONE || subStatusCode == SubStatusCodes.NAME_CACHE_IS_STALE)\n+            && this.attemptedRetries < MAX_RETRIES) {", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5MTUyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518491520", "bodyText": "I can see different refreshes for different substatus codes. For pk range, I don't see any thing to handle forceRefresh. Even in function  RxPartitionKeyRangeCache::getPartitionKeyRange function, forceRefresh variable is unused. Will make some changes to address collection cache refresh.\nWill add COMPLETING_SPLIT and COMPLETING_PARTITION_MIGRATION.\n\nThanks.", "author": "rakkuma", "createdAt": "2020-11-06T02:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NzAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5OTcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518999711", "bodyText": "Thanks Rakesh.\nI read the flow one more time, and I think I understand the general flow better now.\nSo ultimately it will be an RxDocumentServiceRequest, underlying with GoneAndRetryWithRetryPolicy, RenameCollectionAwareClientRetryPolicy will be applied. Since we do not retry for COMPLETING_SPLIT etc for write operations(but will refresh the range cache), so the exceptions will be throwned and eventually captured in BulkOperationRetryPolicy for each bulkItemOperation.\nBy the way, InvalidPartitionExceptionRetryPolicy is doing similar collection cache refresh~", "author": "xinlian12", "createdAt": "2020-11-06T20:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4ODY0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518388643", "bodyText": "nit: if (...) (space between)", "author": "xinlian12", "createdAt": "2020-11-05T21:46:30Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.BulkProcessingOptions;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosBridgeInternal;\n+import com.azure.cosmos.CosmosBulkItemResponse;\n+import com.azure.cosmos.CosmosBulkOperationResponse;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.ThrottlingRetryOptions;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.AsyncDocumentClient;\n+import com.azure.cosmos.implementation.apachecommons.lang.tuple.Pair;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.GroupedFlux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.UnicastProcessor;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+public final class BulkExecutor<TContext> {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BulkExecutor.class);\n+\n+    private final CosmosAsyncContainer container;\n+    private final AsyncDocumentClient docClientWrapper;\n+    private final ThrottlingRetryOptions throttlingRetryOptions;\n+    private final Flux<CosmosItemOperation> inputOperations;\n+\n+    // Options for bulk execution.\n+    private final int maxMicroBatchSize;\n+    private final int maxMicroBatchConcurrency;\n+    private final Duration maxMicroBatchInterval;\n+    private final TContext batchContext;\n+\n+    // Handle gone error:\n+    private final AtomicBoolean mainSourceCompleted;\n+    private final AtomicInteger totalCount;\n+    private final FluxProcessor<CosmosItemOperation, CosmosItemOperation> mainFluxProcessor;\n+    private final FluxSink<CosmosItemOperation> mainSink;\n+    private final List<FluxSink<CosmosItemOperation>> groupSinks;\n+\n+    public BulkExecutor(CosmosAsyncContainer container,\n+                        Flux<CosmosItemOperation> inputOperations,\n+                        BulkProcessingOptions<TContext> bulkOptions) {\n+\n+        checkNotNull(container, \"expected non-null container\");\n+        checkNotNull(inputOperations, \"expected non-null inputOperations\");\n+        checkNotNull(bulkOptions, \"expected non-null bulkOptions\");\n+\n+        this.container = container;\n+        this.inputOperations = inputOperations;\n+        this.docClientWrapper = CosmosBridgeInternal.getAsyncDocumentClient(container.getDatabase());\n+        this.throttlingRetryOptions = docClientWrapper.getConnectionPolicy().getThrottlingRetryOptions();\n+\n+        // Fill the option first, to make the BulkProcessingOptions immutable, as if accessed directly, we might get\n+        // different values when a new group is created.\n+        maxMicroBatchSize = bulkOptions.getMaxMicroBatchSize();\n+        maxMicroBatchConcurrency = bulkOptions.getMaxMicroBatchConcurrency();\n+        maxMicroBatchInterval = bulkOptions.getMaxMicroBatchInterval();\n+        batchContext = bulkOptions.getBatchContext();\n+\n+        // Initialize sink for handling gone error.\n+        mainSourceCompleted = new AtomicBoolean(false);\n+        totalCount = new AtomicInteger(0);\n+        mainFluxProcessor = UnicastProcessor.<CosmosItemOperation>create().serialize();\n+        mainSink = mainFluxProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+        groupSinks = new ArrayList<>();\n+    }\n+\n+    /**\n+     * The actual execution of the flux of operations. It is done in 5 steps:\n+\n+     * 1. Getting partition key range ID and grouping operations using that id.\n+     * 2. For the flux of operations in a group, adding buffering based on size and a duration.\n+     * 3. For the operation we get in after buffering, process it using a batch request and return\n+     *    a wrapper having request, response(if-any) and exception(if-any). Either response or exception will be there.\n+     *\n+     * 4. Any internal retry is done by adding in an intermediate sink for each grouped flux.\n+     * 5. Any operation which failed due to partition key range gone is retried by re calculating it's range id.\n+     */\n+    public Flux<CosmosBulkOperationResponse<TContext>> execute() {\n+\n+        Flux<CosmosBulkOperationResponse<TContext>> responseFlux = this.inputOperations\n+            .onErrorResume((error) -> {\n+                // eat up the error signals\n+                return Mono.empty();\n+            })\n+            .doOnNext((CosmosItemOperation cosmosItemOperation) -> {\n+\n+                // Set the retry policy before starting execution. Should only happens once.\n+                BulkExecutorUtil.setRetryPolicyForBulk(cosmosItemOperation, this.throttlingRetryOptions);\n+\n+                totalCount.incrementAndGet();\n+            })\n+            .doOnComplete(() -> {\n+                mainSourceCompleted.set(true);\n+\n+                if (totalCount.get() == 0) {\n+                    // This is needed as there can be case that onComplete was called after last element was processed\n+                    // So complete the sink here also if count is 0, if source has completed and count isn't zero,\n+                    // then the last element in the doOnNext will close it. Sink doesn't mind in case of a double close.\n+\n+                    completeAllSinks();\n+                }\n+            })\n+            .mergeWith(mainFluxProcessor)\n+            .flatMap(operation -> {\n+\n+                // resolve partition key range id again for operations which comes in main sink due to gone retry.\n+                return BulkExecutorUtil.resolvePartitionKeyRangeId(this.docClientWrapper, this.container, operation)\n+                    .map((String pkRangeId) -> Pair.of(pkRangeId, operation));\n+            })\n+            .groupBy(Pair::getKey, Pair::getValue)\n+            .flatMap(this::executePartitionedGroup)\n+            .doOnNext(requestAndResponse -> {\n+\n+                if (totalCount.decrementAndGet() == 0 && mainSourceCompleted.get()) {\n+                    // It is possible that count is zero but there are more elements in the source.\n+                    // Count 0 also signifies that there are no pending elements in any sink.\n+\n+                    completeAllSinks();\n+                }\n+            });\n+\n+        return responseFlux;\n+    }\n+\n+    private Flux<CosmosBulkOperationResponse<TContext>> executePartitionedGroup(\n+        GroupedFlux<String, CosmosItemOperation> partitionedGroupFluxOfInputOperations) {\n+\n+        final String pkRange = partitionedGroupFluxOfInputOperations.key();\n+\n+        final FluxProcessor<CosmosItemOperation, CosmosItemOperation> groupFluxProcessor =\n+            UnicastProcessor.<CosmosItemOperation>create().serialize();\n+        final FluxSink<CosmosItemOperation> groupSink = groupFluxProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+        groupSinks.add(groupSink);\n+\n+        return partitionedGroupFluxOfInputOperations\n+            .mergeWith(groupFluxProcessor)\n+            .bufferTimeout(this.maxMicroBatchSize, this.maxMicroBatchInterval)\n+            .onBackpressureBuffer()\n+            .flatMap((List<CosmosItemOperation> cosmosItemOperations) -> {\n+                return executeOperations(cosmosItemOperations, pkRange, groupSink);\n+            }, this.maxMicroBatchConcurrency);\n+    }\n+\n+    private Flux<CosmosBulkOperationResponse<TContext>> executeOperations(\n+        List<CosmosItemOperation> operations,\n+        String pkRange,\n+        FluxSink<CosmosItemOperation> groupSink) {\n+\n+        ServerOperationBatchRequest serverOperationBatchRequest = BulkExecutorUtil.createBatchRequest(operations, pkRange);\n+        if (serverOperationBatchRequest.getBatchPendingOperations().size() > 0) {\n+            serverOperationBatchRequest.getBatchPendingOperations().forEach(groupSink::next);\n+        }\n+\n+        return Flux.just(serverOperationBatchRequest.getBatchRequest())\n+            .publishOn(Schedulers.elastic())\n+            .flatMap((PartitionKeyRangeServerBatchRequest serverRequest) -> {\n+                return this.executePartitionKeyRangeServerBatchRequest(serverRequest, groupSink);\n+            });\n+    }\n+\n+    private Flux<CosmosBulkOperationResponse<TContext>> executePartitionKeyRangeServerBatchRequest(\n+        PartitionKeyRangeServerBatchRequest serverRequest,\n+        FluxSink<CosmosItemOperation> groupSink) {\n+\n+        return this.executeBatchRequest(serverRequest)\n+            .flatMapMany(response -> {\n+\n+                return Flux.fromIterable(response.getResults()).flatMap((TransactionalBatchOperationResult result) -> {\n+                    return handleTransactionalBatchOperationResult(response, result, groupSink);\n+                });\n+            })\n+            .onErrorResume((Throwable throwable) -> {\n+\n+                return Flux.fromIterable(serverRequest.getOperations()).flatMap((CosmosItemOperation itemOperation) -> {\n+                    return handleTransactionalBatchExecutionException(itemOperation, throwable, groupSink);\n+                });\n+            });\n+    }\n+\n+    // Helper functions\n+    private Mono<CosmosBulkOperationResponse<TContext>> handleTransactionalBatchOperationResult(\n+        TransactionalBatchResponse response,\n+        TransactionalBatchOperationResult operationResult,\n+        FluxSink<CosmosItemOperation> groupSink) {\n+\n+        CosmosBulkItemResponse cosmosBulkItemResponse = BridgeInternal.createCosmosBulkItemResponse(operationResult, response);\n+        CosmosItemOperation itemOperation = operationResult.getOperation();\n+\n+        if (!operationResult.isSuccessStatusCode()) {\n+\n+            if(itemOperation instanceof ItemBulkOperation<?>) {\n+\n+                return ((ItemBulkOperation<?>) itemOperation).getRetryPolicy().shouldRetry(operationResult).flatMap(\n+                    result -> {\n+                        if (result.shouldRetry) {\n+                            groupSink.next(itemOperation);\n+                            return Mono.empty();\n+                        } else {\n+                            return Mono.just(BridgeInternal.createCosmosBulkOperationResponse(\n+                                itemOperation, cosmosBulkItemResponse, this.batchContext));\n+                        }\n+                    });\n+\n+            } else {\n+                throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+            }\n+        }\n+\n+        return Mono.just(BridgeInternal.createCosmosBulkOperationResponse(\n+            itemOperation,\n+            cosmosBulkItemResponse,\n+            this.batchContext));\n+    }\n+\n+    private Mono<CosmosBulkOperationResponse<TContext>> handleTransactionalBatchExecutionException(\n+        CosmosItemOperation itemOperation,\n+        Throwable throwable,\n+        FluxSink<CosmosItemOperation> groupSink) {\n+\n+        if(throwable instanceof CosmosException && itemOperation instanceof ItemBulkOperation<?>) {\n+            CosmosException cosmosException = (CosmosException) throwable;", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5MDg2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518490865", "bodyText": "I can see both \"if( \" ~ without space and \"if (\" ~ with spaces in code. Not sure what we follow.", "author": "rakkuma", "createdAt": "2020-11-06T02:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4ODY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxODE5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518518195", "bodyText": "Will change it. The \"if (\" seems to be widely accepted elsewhere. Thanks.", "author": "rakkuma", "createdAt": "2020-11-06T04:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4ODY0Mw=="}], "type": "inlineReview"}, {"oid": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/77189fc3165e2f19006d3f329238e95b2e7e87f1", "message": "More test cases, handling collection refresh and few NITs\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-06T11:32:39Z", "type": "commit"}, {"oid": "dbe39418a26300f5613380c3a420ff043469ea93", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbe39418a26300f5613380c3a420ff043469ea93", "message": "Merge branch 'master' into users/rakkuma/bulk-executor", "committedDate": "2020-11-06T11:46:19Z", "type": "commit"}, {"oid": "ef9f92b276631cd9e042d1dff60b23c6f7943a43", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ef9f92b276631cd9e042d1dff60b23c6f7943a43", "message": "Version bump\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-06T11:50:43Z", "type": "commit"}, {"oid": "2382a652e626a6ca0890b0401bae068245648fd4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2382a652e626a6ca0890b0401bae068245648fd4", "message": "Bug\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-06T14:12:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520292110", "bodyText": "\"new\" prefix sounds very odd actually... are there any other options to consider here? \"insert\" or \"compose\" may be?", "author": "milismsft", "createdAt": "2020-11-10T05:18:30Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.ItemBulkOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Utility for creating bulk operations which can be executed by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} .\n+ *\n+ * Also while creating these operation, if some options which are only for individual operation can be provided by passing\n+ * a {@link BulkItemRequestOptions} while creating the bulk operation.\n+ *\n+ * See also {@link BulkProcessingOptions}.\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class BulkOperations {\n+\n+    /**\n+     * Instantiate an operation for Creating item in Bulk execution.\n+     *\n+     * @param <T> The type of item to be created.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param partitionKey the partition key for the operation\n+     *\n+     * @return the bulk operation.\n+     */\n+    public static <T> CosmosItemOperation newCreateItemOperation(T item, PartitionKey partitionKey) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMxNjUxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520316510", "bodyText": "Insert seems like we are putting in a container. But we are returning the operation right.", "author": "rakkuma", "createdAt": "2020-11-10T06:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyNjk4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520326981", "bodyText": "How about \"compose\" or a similar wording? \"newCreate...\" and \"newDelete..\" just does not sound right... Plus \"new\" has a whole different meaning in Java, and in that case it's better if using a constructor method and not a static one; though I will guess that will add an explosion of new classes, for each operation type...", "author": "milismsft", "createdAt": "2020-11-10T06:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNTQwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520935401", "bodyText": "to me as well \"new\" prefix seems odd. how about not having any prefix at all? (e.g., newCreateItemOperation() -> createItemOperation()", "author": "moderakh", "createdAt": "2020-11-10T23:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3Nzk0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525877946", "bodyText": "But this might seem like BulkOperation is executing the operation rather than returning the operation to be executed by another function. So that's why I was thinking to have a get/new or some similar verb.", "author": "rakkuma", "createdAt": "2020-11-18T07:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMxMDc1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r527310751", "bodyText": "I agree with @rakkuma here, without prefix, it might confuse the user. I am fine with both getCreateItemOperation() or composeCreateItemOperation().", "author": "kushagraThapar", "createdAt": "2020-11-20T00:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMzODg0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r527338844", "bodyText": "Is this something the central SDK team should decide?", "author": "j82w", "createdAt": "2020-11-20T01:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwMDQyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r529000422", "bodyText": "the SDK team decided on the \"get\" as the prefix: e.g.: getCreateItemOperation()", "author": "moderakh", "createdAt": "2020-11-23T21:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NDU2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520294564", "bodyText": "do we really need the TContext here? From the content of the rest of the class and its methods, it does not look like we have any particular logic to be considered based on this TContext.", "author": "milismsft", "createdAt": "2020-11-10T05:27:09Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingOptions.java", "diffHunk": "@@ -0,0 +1,61 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.BatchRequestResponseConstants;\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+\n+/**\n+ * Encapsulates options for executing a bulk. This is immutable once\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} is called, changing it will have no affect.\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class BulkProcessingOptions<TContext> {\n+    private int maxMicroBatchSize = BatchRequestResponseConstants.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST;\n+    private int maxMicroBatchConcurrency = BatchRequestResponseConstants.DEFAULT_MAX_MICRO_BATCH_CONCURRENCY;\n+    private Duration maxMicroBatchInterval = Duration.ofMillis(BatchRequestResponseConstants.DEFAULT_MAX_MICRO_BATCH_INTERVAL_IN_MILLISECONDS);\n+    private final TContext batchContext;\n+\n+    public BulkProcessingOptions(TContext batchContext) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwODU4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520908589", "bodyText": "we'll need it - that is the way how the caller can pass through state needed to update bookmarks etc. We discussed this when we iterated over it in the public surface area discussions. Please leave it for now - we can add samples and then iterate if really needed.", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NDU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTQ1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520295452", "bodyText": "See my previous comment on TContext... I don't think we need it, so we might just remove this and keep the BulkProcessingOptions simpler.", "author": "milismsft", "createdAt": "2020-11-10T05:28:37Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -585,6 +586,74 @@ public String getId() {\n             });\n     }\n \n+    /**\n+     * Executes flux of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     * @param operations Flux of operation which will be executed by this container.\n+     *\n+     * @return A Flux of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> Flux<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        Flux<CosmosItemOperation> operations) {\n+\n+        return this.processBulkOperations(operations, new BulkProcessingOptions<>());\n+    }\n+\n+    /**\n+     * Executes flux of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     *\n+     * @param operations Flux of operation which will be executed by this container.\n+     * @param bulkOptions Options that apply for this Bulk request which specifies options regarding execution like\n+     *                    concurrency, batching size, interval and context.\n+     *\n+     * @return A Flux of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> Flux<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        Flux<CosmosItemOperation> operations,\n+        BulkProcessingOptions<TContext> bulkOptions) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwODQ0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520908448", "bodyText": "we'll need it - that is the way how the caller can pass through state needed to update bookmarks etc. We discussed this when we iterated over it in the public surface area discussions. Please leave it for now - we can add samples and then iterate if really needed.", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5ODkwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520298905", "bodyText": "how will someone use an ETAG in the bulk operation context? I don't think it can be used...", "author": "milismsft", "createdAt": "2020-11-10T05:37:24Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTQ1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520299458", "bodyText": "Neve mind... the CosmosBulkItemResponse is per each operation in the bulk, right?", "author": "milismsft", "createdAt": "2020-11-10T05:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5ODkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMxMzIwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520313203", "bodyText": "Yes. And like normal operations, etag will yield NotModified or condition failed", "author": "rakkuma", "createdAt": "2020-11-10T06:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5ODkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTg5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520299892", "bodyText": "We should try to stay consistent.. in the above classes we use TContext rather than T", "author": "milismsft", "createdAt": "2020-11-10T05:40:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @param <T> the type parameter\n+     *\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public <T> T getItem(final Class<T> type) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMxMzk1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520313956", "bodyText": "Context is different, this is item type, the same is in TransactionalBatchItemResponse.", "author": "rakkuma", "createdAt": "2020-11-10T06:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyMjk5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520322995", "bodyText": "I'm not sure I understand... TContext is used to specify the POJO when creating a CosmosItemOperation, right? If so, should that be the same here?", "author": "milismsft", "createdAt": "2020-11-10T06:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyNTEwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520325108", "bodyText": "No no. We are not fixing the type for a bulk execution. TContext is passed in the options. Operations in a bulk can have different class type. This is something for the users to distinguish between bulk executions.", "author": "rakkuma", "createdAt": "2020-11-10T06:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzY1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520937657", "bodyText": "Throwable vs Exception vs CosmosException", "author": "moderakh", "createdAt": "2020-11-10T23:23:20Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Request, response and the exception(if any) for a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class CosmosBulkOperationResponse<TContext> {\n+\n+    private final CosmosItemOperation operation;\n+    private final CosmosBulkItemResponse response;\n+    private final Throwable throwable;\n+    private final TContext batchContext;\n+\n+    /**\n+     * Initialises a new instance of {@link CosmosBulkOperationResponse}.\n+     *\n+     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n+     * @param response the {@link CosmosBulkItemResponse} the bulk response.\n+     * @param batchContext the context of this bulk request.\n+     */\n+    CosmosBulkOperationResponse(CosmosItemOperation operation, CosmosBulkItemResponse response, TContext batchContext) {\n+        this.operation = operation;\n+        this.response = response;\n+        this.throwable = null;\n+        this.batchContext = batchContext;\n+    }\n+\n+    /**\n+     * Initialises a new instance of {@link CosmosBulkOperationResponse}.\n+     *\n+     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n+     * @param throwable the {@link Throwable} for this request.\n+     * @param batchContext the context of this bulk request.\n+     */\n+    CosmosBulkOperationResponse(CosmosItemOperation operation, Throwable throwable, TContext batchContext) {\n+        this.operation = operation;\n+        this.response = null;\n+        this.throwable = throwable;\n+        this.batchContext = batchContext;\n+    }\n+\n+    public CosmosItemOperation getOperation() {\n+        return operation;\n+    }\n+\n+    public CosmosBulkItemResponse getResponse() {\n+        return response;\n+    }\n+\n+    public Throwable getThrowable() {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3MzY2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525973668", "bodyText": "Have kept it exception.", "author": "rakkuma", "createdAt": "2020-11-18T10:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzODY2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520938663", "bodyText": "This should be Iterable instead of List.\nIterable is a better translation for Flux in sync world than a List.", "author": "moderakh", "createdAt": "2020-11-10T23:26:03Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -538,6 +554,64 @@ public TransactionalBatchResponse executeTransactionalBatch(\n         return this.blockBatchResponse(asyncContainer.executeTransactionalBatch(transactionalBatch, requestOptions));\n     }\n \n+    /**\n+     * Executes list of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     * @param operations list of operation which will be executed by this container.\n+     *\n+     * @return A list of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> List<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        List<CosmosItemOperation> operations) {\n+\n+        return this.blockBulkResponse(asyncContainer.processBulkOperations(Flux.fromIterable(operations)));\n+    }\n+\n+    /**\n+     * Executes list of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     *\n+     * @param operations list of operation which will be executed by this container.\n+     * @param bulkOptions Options that apply for this Bulk request which specifies options regarding execution like\n+     *                    concurrency, batching size, interval and context.\n+     *\n+     * @return A list of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> List<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        List<CosmosItemOperation> operations,", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3MjU2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525972562", "bodyText": "Fixed. Thanks mo.", "author": "rakkuma", "createdAt": "2020-11-18T10:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzODY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzODcwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520938709", "bodyText": "This should be Iterable instead of List.\nIterable is a better translation for Flux in sync world than a List.", "author": "moderakh", "createdAt": "2020-11-10T23:26:11Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -538,6 +554,64 @@ public TransactionalBatchResponse executeTransactionalBatch(\n         return this.blockBatchResponse(asyncContainer.executeTransactionalBatch(transactionalBatch, requestOptions));\n     }\n \n+    /**\n+     * Executes list of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     * @param operations list of operation which will be executed by this container.\n+     *\n+     * @return A list of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> List<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        List<CosmosItemOperation> operations) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg4MTExMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525881110", "bodyText": "@milismsft @kushagraThapar should we keep Beta tag on class or all it's functions? What's the best way?", "author": "rakkuma", "createdAt": "2020-11-18T08:03:40Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.ItemBulkOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Utility for creating bulk operations which can be executed by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} .\n+ *\n+ * Also while creating these operation, if some options which are only for individual operation can be provided by passing\n+ * a {@link BulkItemRequestOptions} while creating the bulk operation.\n+ *\n+ * See also {@link BulkProcessingOptions}.\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyODU5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r526528592", "bodyText": "Discussed with Milis. Beta tag on class makes more sense for newly added class. Also later, if a function is added to in class which is in beta, that function will have new beta.", "author": "rakkuma", "createdAt": "2020-11-19T01:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg4MTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0NDY4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r526544680", "bodyText": "absolutely :-)", "author": "milismsft", "createdAt": "2020-11-19T02:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg4MTExMA=="}], "type": "inlineReview"}, {"oid": "6a7be7cbb42113055b4f34602a9e92a91168ce8c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6a7be7cbb42113055b4f34602a9e92a91168ce8c", "message": "Code review - exception and todos\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T08:55:03Z", "type": "commit"}, {"oid": "a509dfb049c77ae1fe034b8f09866b3651f66013", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a509dfb049c77ae1fe034b8f09866b3651f66013", "message": "Merge branch 'master' into users/rakkuma/bulk-executor", "committedDate": "2020-11-18T09:09:08Z", "type": "commit"}, {"oid": "1db022fed55b382aad4a609c533e15cb6df305df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1db022fed55b382aad4a609c533e15cb6df305df", "message": "Exception init fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T09:26:09Z", "type": "commit"}, {"oid": "740a175938e2d0d68f19b4400d0c2fb8ebced560", "url": "https://github.com/Azure/azure-sdk-for-java/commit/740a175938e2d0d68f19b4400d0c2fb8ebced560", "message": "Minor fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T11:49:38Z", "type": "commit"}, {"oid": "07779e74c82fe2f7361da17e02251fc8a93aba97", "url": "https://github.com/Azure/azure-sdk-for-java/commit/07779e74c82fe2f7361da17e02251fc8a93aba97", "message": "Merging with master\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T14:54:49Z", "type": "commit"}, {"oid": "10777cdbd8aec0b7f8b2a37001553e9652db1e99", "url": "https://github.com/Azure/azure-sdk-for-java/commit/10777cdbd8aec0b7f8b2a37001553e9652db1e99", "message": "Fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T15:12:24Z", "type": "commit"}, {"oid": "b812c658c83abf5dcea1511db3e0d863cceeafc7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b812c658c83abf5dcea1511db3e0d863cceeafc7", "message": "Merging with master\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-23T09:40:42Z", "type": "commit"}, {"oid": "f0c652f2406da5f7d3c23f1ee61667defcbb6115", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f0c652f2406da5f7d3c23f1ee61667defcbb6115", "message": "Fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-23T11:33:40Z", "type": "commit"}, {"oid": "dbaa99302bea4927d33455328aadab4130000668", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbaa99302bea4927d33455328aadab4130000668", "message": "Adding beta tags on functions\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-23T17:21:02Z", "type": "commit"}, {"oid": "8541a07fdf2abca507e6099c03e9912c969a2b79", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8541a07fdf2abca507e6099c03e9912c969a2b79", "message": "Merge branch 'master' into users/rakkuma/bulk-executor", "committedDate": "2020-11-24T01:56:03Z", "type": "commit"}, {"oid": "96a54e24182e5e1d3e43b2129ea2faaf360c5659", "url": "https://github.com/Azure/azure-sdk-for-java/commit/96a54e24182e5e1d3e43b2129ea2faaf360c5659", "message": "new to get prefix + few test cases\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-24T02:44:31Z", "type": "commit"}]}