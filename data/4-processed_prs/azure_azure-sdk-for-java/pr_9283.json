{"pr_number": 9283, "pr_title": "[Storage] Blob versioning.", "pr_createdAt": "2020-03-20T00:31:27Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9283", "timeline": [{"oid": "ffdeffc31de621f5cfe7f60af1a6bab6d16a1bc2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ffdeffc31de621f5cfe7f60af1a6bab6d16a1bc2", "message": "create version and read version.", "committedDate": "2020-03-17T22:58:38Z", "type": "commit"}, {"oid": "f2ae5b127796ab75b498a1b7c4a7fc27b23726f2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f2ae5b127796ab75b498a1b7c4a7fc27b23726f2", "message": "Delete blob by version.", "committedDate": "2020-03-18T23:50:16Z", "type": "commit"}, {"oid": "5ef374d201b8d950a9a5107950bb50bbc112ce54", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ef374d201b8d950a9a5107950bb50bbc112ce54", "message": "Regenerate blob client.", "committedDate": "2020-03-19T20:13:06Z", "type": "commit"}, {"oid": "526098bcc948792244a6296e89c2e93fb092f56b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/526098bcc948792244a6296e89c2e93fb092f56b", "message": "Generate client one more time.", "committedDate": "2020-03-19T20:34:14Z", "type": "commit"}, {"oid": "dbf63e263098de95ee9d81c923822c144f9d97fe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbf63e263098de95ee9d81c923822c144f9d97fe", "message": "List blob and blob properties.", "committedDate": "2020-03-19T21:29:38Z", "type": "commit"}, {"oid": "1c16542496614b2b2d0a749305afe441084a5490", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1c16542496614b2b2d0a749305afe441084a5490", "message": "Copy and get properties.", "committedDate": "2020-03-19T23:28:42Z", "type": "commit"}, {"oid": "4a894d50270c92a80a9cdccfb1e3eec2229fed23", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4a894d50270c92a80a9cdccfb1e3eec2229fed23", "message": "Snapshot", "committedDate": "2020-03-20T00:18:51Z", "type": "commit"}, {"oid": "5ee6c4d78b8999b322cb3b1d730d65f4b956d9ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ee6c4d78b8999b322cb3b1d730d65f4b956d9ca", "message": "Recordings.", "committedDate": "2020-03-20T00:25:25Z", "type": "commit"}, {"oid": "3a2ebd2bcd3b70372f4678a42f5bd1c3a08e9d98", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a2ebd2bcd3b70372f4678a42f5bd1c3a08e9d98", "message": "Recordings.", "committedDate": "2020-03-20T00:30:27Z", "type": "commit"}, {"oid": "43ea3124d55ba3fd48e35e783303c2e666722f34", "url": "https://github.com/Azure/azure-sdk-for-java/commit/43ea3124d55ba3fd48e35e783303c2e666722f34", "message": "Fix checkstyle errors.", "committedDate": "2020-03-20T00:55:24Z", "type": "commit"}, {"oid": "3ca9c6984de25b9633388f274c8b33cdf1cb6bc4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ca9c6984de25b9633388f274c8b33cdf1cb6bc4", "message": "Recordings.", "committedDate": "2020-03-20T01:00:53Z", "type": "commit"}, {"oid": "bf8a98f29d6b0140d8369bc94d508eaab22be5ff", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf8a98f29d6b0140d8369bc94d508eaab22be5ff", "message": "undo readme.", "committedDate": "2020-03-20T01:02:31Z", "type": "commit"}, {"oid": "b5e27d190d1bc71e5770169aada677b0a0a4a81f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b5e27d190d1bc71e5770169aada677b0a0a4a81f", "message": "make test compatible with java 8", "committedDate": "2020-03-20T01:07:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3MDcwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395770701", "bodyText": "Is it legal for a url to have a snapshot and a versionId? I would guess not, and it may be worth validating that here.", "author": "rickle-msft", "createdAt": "2020-03-20T16:59:01Z", "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobClientBuilder.java", "diffHunk": "@@ -151,7 +152,7 @@ public EncryptedBlobAsyncClient buildEncryptedBlobAsyncClient() {\n \n         return new EncryptedBlobAsyncClient(getHttpPipeline(),\n             String.format(\"%s/%s/%s\", endpoint, containerName, blobName), serviceVersion, accountName, containerName,\n-            blobName, snapshot, customerProvidedKey, keyWrapper, keyWrapAlgorithm);\n+            blobName, snapshot, customerProvidedKey, keyWrapper, keyWrapAlgorithm, versionId);", "originalCommit": "b5e27d190d1bc71e5770169aada677b0a0a4a81f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MzA1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395793050", "bodyText": "Looks like you covered that below :)", "author": "rickle-msft", "createdAt": "2020-03-20T17:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3MDcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MjQ4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396592483", "bodyText": "Correct, that's covered.", "author": "kasobol-msft", "createdAt": "2020-03-23T16:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3MDcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4Njk4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395786984", "bodyText": "I think retrieve, properties, and delete are independent of blob type and should share the same code path regardless of blob type, so it may be better to only test that once.", "author": "rickle-msft", "createdAt": "2020-03-20T17:27:56Z", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/VersioningTest.groovy", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob\n+\n+import com.azure.core.util.Context\n+import com.azure.storage.blob.models.BlobListDetails\n+import com.azure.storage.blob.models.ListBlobsOptions\n+import com.azure.storage.blob.models.PageRange\n+import com.azure.storage.blob.models.PublicAccessType\n+import com.azure.storage.blob.specialized.PageBlobClient\n+import org.apache.commons.lang3.StringUtils\n+\n+import java.nio.charset.StandardCharsets\n+import java.time.Duration\n+\n+class VersioningTest extends APISpec {\n+\n+    BlobContainerClient blobContainerClient\n+    BlobClient blobClient\n+    String blobName\n+    String containerName\n+    String contentV1 = \"contentV1\"\n+    String contentV2 = \"contentV2\"\n+\n+    def setup() {\n+        blobName = generateBlobName()\n+        containerName = generateContainerName()\n+        blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        blobClient = blobContainerClient.getBlobClient(blobName)\n+    }\n+\n+    def cleanup() {\n+        blobContainerClient.delete();\n+    }\n+\n+    def \"Create Block Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Page Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(512, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Append Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getAppendBlobClient().create();\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true);\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Retrieve Block Blob by Version\"() {", "originalCommit": "b5e27d190d1bc71e5770169aada677b0a0a4a81f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5NDI0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396594248", "bodyText": "Fair point. I'll remove that.", "author": "kasobol-msft", "createdAt": "2020-03-23T16:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4Njk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4NzM4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395787384", "bodyText": "nit: we usually use download instead of retrieve and get properties instead of retrieve properties for test naming", "author": "rickle-msft", "createdAt": "2020-03-20T17:28:42Z", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/VersioningTest.groovy", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob\n+\n+import com.azure.core.util.Context\n+import com.azure.storage.blob.models.BlobListDetails\n+import com.azure.storage.blob.models.ListBlobsOptions\n+import com.azure.storage.blob.models.PageRange\n+import com.azure.storage.blob.models.PublicAccessType\n+import com.azure.storage.blob.specialized.PageBlobClient\n+import org.apache.commons.lang3.StringUtils\n+\n+import java.nio.charset.StandardCharsets\n+import java.time.Duration\n+\n+class VersioningTest extends APISpec {\n+\n+    BlobContainerClient blobContainerClient\n+    BlobClient blobClient\n+    String blobName\n+    String containerName\n+    String contentV1 = \"contentV1\"\n+    String contentV2 = \"contentV2\"\n+\n+    def setup() {\n+        blobName = generateBlobName()\n+        containerName = generateContainerName()\n+        blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        blobClient = blobContainerClient.getBlobClient(blobName)\n+    }\n+\n+    def cleanup() {\n+        blobContainerClient.delete();\n+    }\n+\n+    def \"Create Block Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Page Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(512, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Append Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getAppendBlobClient().create();\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true);\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Retrieve Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getBlockBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Retrieve Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getPageBlobClient().download(outputV2)\n+\n+        then:\n+        Arrays.equals(contentV1, outputV1.toByteArray())\n+        Arrays.equals(contentV2, outputV2.toByteArray())\n+    }\n+\n+    def \"Retrieve Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getAppendBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Delete Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Retrieve Block Blob Properties by Version\"() {", "originalCommit": "b5e27d190d1bc71e5770169aada677b0a0a4a81f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5NTEwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396595105", "bodyText": "Ok.", "author": "kasobol-msft", "createdAt": "2020-03-23T16:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4NzM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4ODA5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395788092", "bodyText": "We shouldn't have to index into the raw headers to get this value. Maybe swagger needs to be updated to add this field to the deserialized headers?", "author": "rickle-msft", "createdAt": "2020-03-20T17:29:54Z", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/VersioningTest.groovy", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob\n+\n+import com.azure.core.util.Context\n+import com.azure.storage.blob.models.BlobListDetails\n+import com.azure.storage.blob.models.ListBlobsOptions\n+import com.azure.storage.blob.models.PageRange\n+import com.azure.storage.blob.models.PublicAccessType\n+import com.azure.storage.blob.specialized.PageBlobClient\n+import org.apache.commons.lang3.StringUtils\n+\n+import java.nio.charset.StandardCharsets\n+import java.time.Duration\n+\n+class VersioningTest extends APISpec {\n+\n+    BlobContainerClient blobContainerClient\n+    BlobClient blobClient\n+    String blobName\n+    String containerName\n+    String contentV1 = \"contentV1\"\n+    String contentV2 = \"contentV2\"\n+\n+    def setup() {\n+        blobName = generateBlobName()\n+        containerName = generateContainerName()\n+        blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        blobClient = blobContainerClient.getBlobClient(blobName)\n+    }\n+\n+    def cleanup() {\n+        blobContainerClient.delete();\n+    }\n+\n+    def \"Create Block Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Page Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(512, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Append Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getAppendBlobClient().create();\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true);\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Retrieve Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getBlockBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Retrieve Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getPageBlobClient().download(outputV2)\n+\n+        then:\n+        Arrays.equals(contentV1, outputV1.toByteArray())\n+        Arrays.equals(contentV2, outputV2.toByteArray())\n+    }\n+\n+    def \"Retrieve Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getAppendBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Delete Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Retrieve Block Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def responseV2 = blobClient.getBlockBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getBlockBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getBlockBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getBlockBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getBlockBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"Retrieve Page Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def responseV2 = blobClient.getPageBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getPageBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getPageBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getPageBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getPageBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"Retrieve Append Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        def responseV2 = blobClient.getAppendBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getAppendBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getAppendBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getAppendBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getAppendBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"List Blobs with Version\"() {\n+        given:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+        def blobItemV3 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        when:\n+        def blobs = blobContainerClient.listBlobs(new ListBlobsOptions().setDetails(new BlobListDetails().setRetrieveVersions(true)), null)\n+\n+        then:\n+        blobs.size() == 3\n+        blobs[0].getVersionId() == blobItemV1.getVersionId()\n+        blobs[1].getVersionId() == blobItemV2.getVersionId()\n+        blobs[2].getVersionId() == blobItemV3.getVersionId()\n+        blobs[0].isCurrentVersion() == null\n+        blobs[1].isCurrentVersion() == null\n+        blobs[2].isCurrentVersion()\n+    }\n+\n+    def \"List Blobs without Version\"() {\n+        given:\n+        blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+        def blobItemV3 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        when:\n+        def blobs = blobContainerClient.listBlobs(new ListBlobsOptions().setDetails(new BlobListDetails().setRetrieveVersions(false)), null)\n+\n+        then:\n+        blobs.size() == 1\n+        blobs[0].getVersionId() == blobItemV3.getVersionId()\n+    }\n+\n+    def \"Begin Copy Blobs with Version\"() {\n+        given:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def sourceBlob = blobContainerClient.getBlobClient(generateBlobName())\n+        sourceBlob.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+\n+        when:\n+        def pooler = blobClient.beginCopy(sourceBlob.getBlobUrl(), Duration.ofSeconds(1))\n+        def copyInfo = pooler.waitForCompletion().getValue()\n+\n+        then:\n+        copyInfo.getVersionId() != null\n+        copyInfo.getVersionId() != blobItemV1.getVersionId()\n+    }\n+\n+    def \"Copy From Url Blobs with Version\"() {\n+        given:\n+        blobContainerClient.setAccessPolicy(PublicAccessType.CONTAINER, null)\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def sourceBlob = blobContainerClient.getBlobClient(generateBlobName())\n+        sourceBlob.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+\n+        when:\n+        def response = blobClient.copyFromUrlWithResponse(sourceBlob.getBlobUrl(), null, null, null, null, null, Context.NONE)\n+        def versionIdAfterCopy = response.getHeaders().getValue(\"x-ms-version-id\")", "originalCommit": "b5e27d190d1bc71e5770169aada677b0a0a4a81f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwNDcwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396604707", "bodyText": "The swagger document seems to be correct. We do have access to deserialized headers at some point. However, the cases where I am retrieving raw header cover APIs that doesn't seem to have a good place to expose this value - they return Response or Response, so deserialized headers get lost in the transformation from impl->blob client. I wonder if there's any other option to expose it.\nOther alternative I can see is to shoot get properties request after copy but that's not safe in concurrent access scenarios (what if there's other operation that bumps version executed in the middle?).", "author": "kasobol-msft", "createdAt": "2020-03-23T16:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4ODA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwMzQ2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396803463", "bodyText": "In that case this is fine. I didn't remember that some operations just return a raw Response object", "author": "rickle-msft", "createdAt": "2020-03-23T22:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4ODA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwODY2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396808661", "bodyText": "We cant call getDeserializedHeaders here?", "author": "gapra-msft", "createdAt": "2020-03-23T23:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4ODA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMDEyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396810123", "bodyText": "copyFromUrl just returns Response, and Response only has getHeaders, not getDeserializedHeaders", "author": "rickle-msft", "createdAt": "2020-03-23T23:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4ODA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MTg3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r395791871", "bodyText": "It may also be worth testing copying from a non-current version. Or at least testing getBlobUrl and ensuring that the version query parameter is present", "author": "rickle-msft", "createdAt": "2020-03-20T17:36:54Z", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/VersioningTest.groovy", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob\n+\n+import com.azure.core.util.Context\n+import com.azure.storage.blob.models.BlobListDetails\n+import com.azure.storage.blob.models.ListBlobsOptions\n+import com.azure.storage.blob.models.PageRange\n+import com.azure.storage.blob.models.PublicAccessType\n+import com.azure.storage.blob.specialized.PageBlobClient\n+import org.apache.commons.lang3.StringUtils\n+\n+import java.nio.charset.StandardCharsets\n+import java.time.Duration\n+\n+class VersioningTest extends APISpec {\n+\n+    BlobContainerClient blobContainerClient\n+    BlobClient blobClient\n+    String blobName\n+    String containerName\n+    String contentV1 = \"contentV1\"\n+    String contentV2 = \"contentV2\"\n+\n+    def setup() {\n+        blobName = generateBlobName()\n+        containerName = generateContainerName()\n+        blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        blobClient = blobContainerClient.getBlobClient(blobName)\n+    }\n+\n+    def cleanup() {\n+        blobContainerClient.delete();\n+    }\n+\n+    def \"Create Block Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Page Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(512, true)\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Create Append Blob with Version\"() {\n+        when:\n+        def blobItemV1 = blobClient.getAppendBlobClient().create();\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true);\n+\n+        then:\n+        blobItemV1.getVersionId() != null\n+        blobItemV2.getVersionId() != null\n+        !StringUtils.equals(blobItemV1.getVersionId(), blobItemV2.getVersionId())\n+    }\n+\n+    def \"Retrieve Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getBlockBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Retrieve Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getPageBlobClient().download(outputV2)\n+\n+        then:\n+        Arrays.equals(contentV1, outputV1.toByteArray())\n+        Arrays.equals(contentV2, outputV2.toByteArray())\n+    }\n+\n+    def \"Retrieve Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        def outputV1 = new ByteArrayOutputStream()\n+        def outputV2 = new ByteArrayOutputStream()\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().download(outputV1)\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).getAppendBlobClient().download(outputV2)\n+\n+        then:\n+        outputV1.toByteArray() == contentV1.getBytes(StandardCharsets.UTF_8)\n+        outputV2.toByteArray() == contentV2.getBytes(StandardCharsets.UTF_8)\n+    }\n+\n+    def \"Delete Block Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(inputV2, inputV2.available(), true)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getBlockBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Page Blob by Version\"() {\n+        given:\n+        def contentV1 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def contentV2 = getRandomByteArray(PageBlobClient.PAGE_BYTES)\n+        def inputV1 = new ByteArrayInputStream(contentV1)\n+        def inputV2 = new ByteArrayInputStream(contentV2)\n+        def blobItemV1 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV1)\n+        def blobItemV2 = blobClient.getPageBlobClient().create(PageBlobClient.PAGE_BYTES, true)\n+        blobClient.getPageBlobClient().uploadPages(new PageRange().setStart(0).setEnd(PageBlobClient.PAGE_BYTES-1), inputV2)\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getPageBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Delete Append Blob by Version\"() {\n+        given:\n+        def inputV1 = new ByteArrayInputStream(contentV1.getBytes(StandardCharsets.UTF_8))\n+        def inputV2 = new ByteArrayInputStream(contentV2.getBytes(StandardCharsets.UTF_8))\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        blobClient.getAppendBlobClient().appendBlock(inputV1, inputV1.available())\n+        def blobItemV2 = blobClient.getAppendBlobClient().create(true)\n+        blobClient.getAppendBlobClient().appendBlock(inputV2, inputV2.available())\n+\n+        when:\n+        blobClient.getVersionClient(blobItemV1.getVersionId()).getAppendBlobClient().delete()\n+\n+        then:\n+        !blobClient.getVersionClient(blobItemV1.getVersionId()).exists()\n+        blobClient.getVersionClient(blobItemV2.getVersionId()).exists()\n+    }\n+\n+    def \"Retrieve Block Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def responseV2 = blobClient.getBlockBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getBlockBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getBlockBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getBlockBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getBlockBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"Retrieve Page Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getPageBlobClient().create(512)\n+        def responseV2 = blobClient.getPageBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getPageBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getPageBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getPageBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getPageBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"Retrieve Append Blob Properties by Version\"() {\n+        given:\n+        def key = \"key\"\n+        def valV2 = \"val2\"\n+        def valV3 = \"val3\"\n+        def blobItemV1 = blobClient.getAppendBlobClient().create()\n+        def responseV2 = blobClient.getAppendBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV2), null, null, Context.NONE);\n+        def responseV3 = blobClient.getAppendBlobClient().setMetadataWithResponse(Collections.singletonMap(key, valV3), null, null, Context.NONE);\n+        def versionId1 = blobItemV1.getVersionId()\n+        def versionId2 = responseV2.getHeaders().getValue(\"x-ms-version-id\")\n+        def versionId3 = responseV3.getHeaders().getValue(\"x-ms-version-id\")\n+\n+        when:\n+        def receivedValV1 = blobClient.getVersionClient(versionId1).getAppendBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV2 = blobClient.getVersionClient(versionId2).getAppendBlobClient().getProperties().getMetadata().get(key)\n+        def receivedValV3 = blobClient.getVersionClient(versionId3).getAppendBlobClient().getProperties().getMetadata().get(key)\n+\n+        then:\n+        receivedValV1 == null\n+        valV2 == receivedValV2\n+        valV3 == receivedValV3\n+    }\n+\n+    def \"List Blobs with Version\"() {\n+        given:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def blobItemV2 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+        def blobItemV3 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        when:\n+        def blobs = blobContainerClient.listBlobs(new ListBlobsOptions().setDetails(new BlobListDetails().setRetrieveVersions(true)), null)\n+\n+        then:\n+        blobs.size() == 3\n+        blobs[0].getVersionId() == blobItemV1.getVersionId()\n+        blobs[1].getVersionId() == blobItemV2.getVersionId()\n+        blobs[2].getVersionId() == blobItemV3.getVersionId()\n+        blobs[0].isCurrentVersion() == null\n+        blobs[1].isCurrentVersion() == null\n+        blobs[2].isCurrentVersion()\n+    }\n+\n+    def \"List Blobs without Version\"() {\n+        given:\n+        blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+        def blobItemV3 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize, true)\n+\n+        when:\n+        def blobs = blobContainerClient.listBlobs(new ListBlobsOptions().setDetails(new BlobListDetails().setRetrieveVersions(false)), null)\n+\n+        then:\n+        blobs.size() == 1\n+        blobs[0].getVersionId() == blobItemV3.getVersionId()\n+    }\n+\n+    def \"Begin Copy Blobs with Version\"() {\n+        given:\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def sourceBlob = blobContainerClient.getBlobClient(generateBlobName())\n+        sourceBlob.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+\n+        when:\n+        def pooler = blobClient.beginCopy(sourceBlob.getBlobUrl(), Duration.ofSeconds(1))\n+        def copyInfo = pooler.waitForCompletion().getValue()\n+\n+        then:\n+        copyInfo.getVersionId() != null\n+        copyInfo.getVersionId() != blobItemV1.getVersionId()\n+    }\n+\n+    def \"Copy From Url Blobs with Version\"() {\n+        given:\n+        blobContainerClient.setAccessPolicy(PublicAccessType.CONTAINER, null)\n+        def blobItemV1 = blobClient.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+        def sourceBlob = blobContainerClient.getBlobClient(generateBlobName())\n+        sourceBlob.getBlockBlobClient().upload(defaultInputStream.get(), defaultDataSize)\n+\n+        when:\n+        def response = blobClient.copyFromUrlWithResponse(sourceBlob.getBlobUrl(), null, null, null, null, null, Context.NONE)", "originalCommit": "b5e27d190d1bc71e5770169aada677b0a0a4a81f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMDUyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396610528", "bodyText": "Sounds good. I'll add test case for getBlobUrl.", "author": "kasobol-msft", "createdAt": "2020-03-23T17:04:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MTg3MQ=="}], "type": "inlineReview"}, {"oid": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7a46fc3ac0fca612a36c4bfb03fbee445d68b041", "message": "pr feedback.", "committedDate": "2020-03-23T17:35:30Z", "type": "commit"}, {"oid": "c9e3a8c5f7b5a737cff85be906327911826ea72c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c9e3a8c5f7b5a737cff85be906327911826ea72c", "message": "version delete sas permission (x)", "committedDate": "2020-03-23T21:06:28Z", "type": "commit"}, {"oid": "0ee2af67f235671c81cfcf01436f775ba0117c8d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ee2af67f235671c81cfcf01436f775ba0117c8d", "message": "get client by version", "committedDate": "2020-03-23T21:19:43Z", "type": "commit"}, {"oid": "88342b91f19b0ebc9902a5544e460b4f12d42b40", "url": "https://github.com/Azure/azure-sdk-for-java/commit/88342b91f19b0ebc9902a5544e460b4f12d42b40", "message": "recordings.", "committedDate": "2020-03-23T21:38:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNDkxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396804915", "bodyText": "typo - \"the a\"", "author": "gapra-msft", "createdAt": "2020-03-23T22:53:13Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobProperties.java", "diffHunk": "@@ -355,4 +420,18 @@ public OffsetDateTime getAccessTierChangeTime() {\n     public Integer getCommittedBlockCount() {\n         return committedBlockCount;\n     }\n+\n+    /**\n+     * @return the version identifier the blob.\n+     */\n+    public String getVersionId() {\n+        return versionId;\n+    }\n+\n+    /**\n+     * @return the a flag indicating whether version identifier points to current version of the blob.", "originalCommit": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgzMzI3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396833275", "bodyText": "fixed", "author": "kasobol-msft", "createdAt": "2020-03-24T00:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNDkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNTI5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396805290", "bodyText": "\"Flag indicating\"", "author": "gapra-msft", "createdAt": "2020-03-23T22:53:41Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/BlobProperties.java", "diffHunk": "@@ -95,6 +97,67 @@ public BlobProperties(final OffsetDateTime creationTime, final OffsetDateTime la\n         final Boolean isAccessTierInferred, final ArchiveStatus archiveStatus, final String encryptionKeySha256,\n         final OffsetDateTime accessTierChangeTime, final Map<String, String> metadata,\n         final Integer committedBlockCount) {\n+        this(creationTime, lastModified, eTag, blobSize, contentType, contentMd5, contentEncoding, contentDisposition,\n+             contentLanguage, cacheControl, blobSequenceNumber, blobType, leaseStatus, leaseState, leaseDuration,\n+            copyId, copyStatus, copySource, copyProgress, copyCompletionTime, copyStatusDescription, isServerEncrypted,\n+            isIncrementalCopy, copyDestinationSnapshot, accessTier, isAccessTierInferred, archiveStatus,\n+            encryptionKeySha256, accessTierChangeTime, metadata, committedBlockCount, null, null);\n+    }\n+\n+    /**\n+     * Constructs a {@link BlobProperties}.\n+     *\n+     * @param creationTime Creation time of the blob.\n+     * @param lastModified Datetime when the blob was last modified.\n+     * @param eTag ETag of the blob.\n+     * @param blobSize Size of the blob.\n+     * @param contentType Content type specified for the blob.\n+     * @param contentMd5 Content MD5 specified for the blob.\n+     * @param contentEncoding Content encoding specified for the blob.\n+     * @param contentDisposition Content disposition specified for the blob.\n+     * @param contentLanguage Content language specified for the blob.\n+     * @param cacheControl Cache control specified for the blob.\n+     * @param blobSequenceNumber The current sequence number for a page blob, if the blob is an append or block blob\n+     * pass {@code null}.\n+     * @param blobType Type of the blob.\n+     * @param leaseStatus Status of the lease on the blob.\n+     * @param leaseState State of the lease on the blob.\n+     * @param leaseDuration Type of lease on the blob.\n+     * @param copyId Identifier of the last copy operation performed on the blob.\n+     * @param copyStatus Status of the last copy operation performed on the blob.\n+     * @param copySource Source of the last copy operation performed on the blob.\n+     * @param copyProgress Progress of the last copy operation performed on the blob.\n+     * @param copyCompletionTime Datetime when the last copy operation on the blob completed.\n+     * @param copyStatusDescription Description of the last copy operation on the blob.\n+     * @param isServerEncrypted Flag indicating if the blob's content is encrypted on the server.\n+     * @param isIncrementalCopy Flag indicating if the blob was incrementally copied.\n+     * @param copyDestinationSnapshot Snapshot identifier of the last incremental copy snapshot for the blob.\n+     * @param accessTier Access tier of the blob.\n+     * @param isAccessTierInferred Flag indicating if the access tier of the blob was inferred from properties of the\n+     * blob.\n+     * @param archiveStatus Archive status of the blob.\n+     * @param encryptionKeySha256 SHA256 of the customer provided encryption key used to encrypt the blob on the server.\n+     * @param accessTierChangeTime Datetime when the access tier of the blob last changed.\n+     * @param metadata Metadata associated with the blob.\n+     * @param committedBlockCount Number of blocks committed to an append blob, if the blob is a block or page blob\n+     * pass {@code null}.\n+     * @param versionId The version identifier of the blob.\n+     * @param isCurrentVersion Flag indication if version identifier points to current version of the blob.", "originalCommit": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNjE1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396806153", "bodyText": "Also not 100% sure about naming but I think it would read better to call the property \"versionCurrent\" and the getter would be like isVersionCurrent.", "author": "gapra-msft", "createdAt": "2020-03-23T22:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNTI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgzMjg5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396832894", "bodyText": "@gapra-msft Regarding naming. I'd rather leave it as is. We have same naming in BlobItem.IsCurrentVersion that we expose elsewhere - naming comes from swagger.", "author": "kasobol-msft", "createdAt": "2020-03-24T00:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNzIwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396807200", "bodyText": "did we create this new resource just cause versioning is still in stage? Would it eventually be available on any account?", "author": "gapra-msft", "createdAt": "2020-03-23T22:57:59Z", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/APISpec.groovy", "diffHunk": "@@ -121,12 +121,14 @@ class APISpec extends Specification {\n     /* Unignore any managed disk tests if a managed disk account is available to be tested. They are difficult to\n      acquire so we do not run them in the nightly live run tests. */\n     static def MANAGED_DISK_STORAGE = \"MANAGED_DISK_STORAGE_\"\n+    static def VERSIONED_STORAGE = \"VERSIONED_STORAGE_\"\n \n     protected static StorageSharedKeyCredential primaryCredential\n     static StorageSharedKeyCredential alternateCredential\n     static StorageSharedKeyCredential blobCredential\n     static StorageSharedKeyCredential premiumCredential\n     static StorageSharedKeyCredential managedDiskCredential\n+    static StorageSharedKeyCredential versionedCredential", "originalCommit": "7a46fc3ac0fca612a36c4bfb03fbee445d68b041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwODk5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r396808997", "bodyText": "This is because versioning isn't on by default and can't be enabled from our data plane apis. It's similar in that way to a premium account, so we decided it'd be best to have a separate credential for it (though, as with all our credentials, it could be the same as the primary if the primary has this feature turned on).", "author": "rickle-msft", "createdAt": "2020-03-23T23:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwNzIwMA=="}], "type": "inlineReview"}, {"oid": "ca532b7ef803b8d24800d115bf3b07f277e08762", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ca532b7ef803b8d24800d115bf3b07f277e08762", "message": "recordings", "committedDate": "2020-03-23T23:21:00Z", "type": "commit"}, {"oid": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "message": "fix typos", "committedDate": "2020-03-24T00:12:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwODM0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397508345", "bodyText": "I know this was a copy and paste, so the other locations will be wrong, but there is no WithPipeline method. Mind fixing the documentation here and either fixing the other locations or filing an issue to fix them, shouldn't reference something that doesn't exist \ud83d\ude03", "author": "alzimmermsft", "createdAt": "2020-03-24T22:49:21Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerAsyncClient.java", "diffHunk": "@@ -161,6 +161,22 @@ public BlobAsyncClient getBlobAsyncClient(String blobName, String snapshot) {\n             getBlobContainerName(), blobName, snapshot, getCustomerProvidedKey(), encryptionScope);\n     }\n \n+    /**\n+     * Creates a new BlobAsyncClient object by concatenating blobName to the end of ContainerAsyncClient's URL. The new\n+     * BlobAsyncClient uses the same request policy pipeline as the ContainerAsyncClient. To change the pipeline, create\n+     * the BlobAsyncClient and then call its WithPipeline method passing in the desired pipeline object. Or, call this", "originalCommit": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1Mjc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398152777", "bodyText": "This is outdated statement referring to something that existed in previous version. Removed here and places I copied from.", "author": "kasobol-msft", "createdAt": "2020-03-25T20:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwODM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwODUwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397508503", "bodyText": "Same as the other comment about WithPipeline.", "author": "alzimmermsft", "createdAt": "2020-03-24T22:49:47Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerClient.java", "diffHunk": "@@ -98,6 +98,20 @@ public BlobClient getBlobClient(String blobName, String snapshot) {\n         return new BlobClient(client.getBlobAsyncClient(blobName, snapshot));\n     }\n \n+    /**\n+     * Initializes a new BlobClient object by concatenating blobName to the end of ContainerAsyncClient's URL. The new\n+     * BlobClient uses the same request policy pipeline as the ContainerAsyncClient. To change the pipeline, create the\n+     * BlobClient and then call its WithPipeline method passing in the desired pipeline object. Or, call this package's", "originalCommit": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1MjgwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398152809", "bodyText": "This is outdated statement referring to something that existed in previous version. Removed here and places I copied from.", "author": "kasobol-msft", "createdAt": "2020-03-25T20:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwODUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwOTUxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397509510", "bodyText": "Should a comment be added to state that passing null will interact with the latest blob?", "author": "alzimmermsft", "createdAt": "2020-03-24T22:52:37Z", "path": "sdk/storage/azure-storage-blob-cryptography/src/main/java/com/azure/storage/blob/specialized/cryptography/EncryptedBlobClientBuilder.java", "diffHunk": "@@ -399,6 +401,17 @@ public EncryptedBlobClientBuilder snapshot(String snapshot) {\n         return this;\n     }\n \n+    /**\n+     * Sets the version identifier of the blob.", "originalCommit": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1Mjk2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398152962", "bodyText": "Added here and other places where we pass versionId", "author": "kasobol-msft", "createdAt": "2020-03-25T20:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwOTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMDcxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397510718", "bodyText": "Not this PR, but I don't fully understand what this Javadoc means by this package's getBlobAsyncClient, I'm not certain this is a thing. Unless it means BlobClientBuilder, which isn't very clear.", "author": "alzimmermsft", "createdAt": "2020-03-24T22:55:26Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerAsyncClient.java", "diffHunk": "@@ -161,6 +161,22 @@ public BlobAsyncClient getBlobAsyncClient(String blobName, String snapshot) {\n             getBlobContainerName(), blobName, snapshot, getCustomerProvidedKey(), encryptionScope);\n     }\n \n+    /**\n+     * Creates a new BlobAsyncClient object by concatenating blobName to the end of ContainerAsyncClient's URL. The new\n+     * BlobAsyncClient uses the same request policy pipeline as the ContainerAsyncClient. To change the pipeline, create\n+     * the BlobAsyncClient and then call its WithPipeline method passing in the desired pipeline object. Or, call this\n+     * package's getBlobAsyncClient instead of calling this object's getBlobAsyncClient method.", "originalCommit": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1MzIzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398153230", "bodyText": "This is outdated statement referring to something that existed in previous version. Removed.", "author": "kasobol-msft", "createdAt": "2020-03-25T20:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMDcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMTM1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397511356", "bodyText": "Please file an issue to cleanup the Javadocs where this was copied from, the mention incorrect things in some places.", "author": "alzimmermsft", "createdAt": "2020-03-24T22:57:02Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/BlobContainerClient.java", "diffHunk": "@@ -98,6 +98,20 @@ public BlobClient getBlobClient(String blobName, String snapshot) {\n         return new BlobClient(client.getBlobAsyncClient(blobName, snapshot));\n     }\n \n+    /**\n+     * Initializes a new BlobClient object by concatenating blobName to the end of ContainerAsyncClient's URL. The new\n+     * BlobClient uses the same request policy pipeline as the ContainerAsyncClient. To change the pipeline, create the\n+     * BlobClient and then call its WithPipeline method passing in the desired pipeline object. Or, call this package's\n+     * getBlobAsyncClient instead of calling this object's getBlobAsyncClient method.\n+     *\n+     * @param blobName A {@code String} representing the name of the blob.\n+     * @param versionId the version identifier for the blob.\n+     * @return A new {@link BlobClient} object which references the blob with the specified name in this container.\n+     */", "originalCommit": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1MzM5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398153399", "bodyText": "Fixed in this PR.", "author": "kasobol-msft", "createdAt": "2020-03-25T20:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMTM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMzkxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397513910", "bodyText": "This code is in implementation so feel free to update the old API as it is non-breaking change.", "author": "alzimmermsft", "createdAt": "2020-03-24T23:03:50Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/implementation/util/BlobSasImplUtil.java", "diffHunk": "@@ -97,7 +104,25 @@ public BlobSasImplUtil(BlobServiceSasSignatureValues sasValues, String container\n      */\n     public BlobSasImplUtil(BlobServiceSasSignatureValues sasValues, String containerName, String blobName,\n         String snapshotId) {\n+        this(sasValues, containerName, blobName, snapshotId, null);\n+    }\n+\n+    /**\n+     * Creates a new {@link BlobSasImplUtil} with the specified parameters\n+     *\n+     * @param sasValues {@link BlobServiceSasSignatureValues}\n+     * @param containerName The container name\n+     * @param blobName The blob name\n+     * @param snapshotId The snapshot id\n+     * @param versionId The version id\n+     */\n+    public BlobSasImplUtil(BlobServiceSasSignatureValues sasValues, String containerName, String blobName,", "originalCommit": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1MzQ3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398153477", "bodyText": "Great! Done.", "author": "kasobol-msft", "createdAt": "2020-03-25T20:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNTAyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397515024", "bodyText": "Mind filing an issue to investigate a way to make constructors which are capable of handling additional parameters that the service could add in the future. There are a few other classes that need a new constructor every time a new service return is added.", "author": "alzimmermsft", "createdAt": "2020-03-24T23:07:03Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/AppendBlobItem.java", "diffHunk": "@@ -55,6 +56,27 @@ public AppendBlobItem(final String eTag, final OffsetDateTime lastModified, fina\n     public AppendBlobItem(final String eTag, final OffsetDateTime lastModified, final byte[] contentMd5,\n         final boolean isServerEncrypted, final String encryptionKeySha256, final String encryptionScope,\n         final String blobAppendOffset, final Integer blobCommittedBlockCount) {\n+        this(eTag, lastModified, contentMd5, isServerEncrypted, encryptionKeySha256, encryptionScope, blobAppendOffset,\n+            blobCommittedBlockCount, null);\n+    }\n+\n+    /**\n+     * Constructs an {@link AppendBlobItem}.\n+     *\n+     * @param eTag ETag of the append blob.\n+     * @param lastModified Last modified time of the append blob.\n+     * @param contentMd5 Content MD5 of the append blob.\n+     * @param isServerEncrypted Flag indicating if the page blob is encrypted on the server.\n+     * @param encryptionKeySha256 The encryption key used to encrypt the append blob.\n+     * @param encryptionScope The encryption scope used to encrypt the append blob.\n+     * @param blobAppendOffset The offset at which the block was committed to the append blob.\n+     * @param blobCommittedBlockCount The number of committed blocks in the append blob.\n+     * @param versionId The version identifier of the append blob.\n+     */\n+    public AppendBlobItem(final String eTag, final OffsetDateTime lastModified, final byte[] contentMd5,", "originalCommit": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1NTczNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398155734", "bodyText": "#9530", "author": "kasobol-msft", "createdAt": "2020-03-25T20:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNTAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r397516396", "bodyText": "This is for another Storage Account resource correct? This will need an update to the ARM template which deploys resources before live test runs for these new tests to work in the nightly live test run.", "author": "alzimmermsft", "createdAt": "2020-03-24T23:10:56Z", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/APISpec.groovy", "diffHunk": "@@ -121,12 +121,14 @@ class APISpec extends Specification {\n     /* Unignore any managed disk tests if a managed disk account is available to be tested. They are difficult to\n      acquire so we do not run them in the nightly live run tests. */\n     static def MANAGED_DISK_STORAGE = \"MANAGED_DISK_STORAGE_\"\n+    static def VERSIONED_STORAGE = \"VERSIONED_STORAGE_\"", "originalCommit": "5e08058f4d2cd1a2c261d648eb7d90cb19f47e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1NzY1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398157651", "bodyText": "@alzimmermsft that's correct. Versioning is feature that can be enabled/disabled. Few questions here:\n\nis there any documentation about how new resource should be added ? I guess it's not only ARM template.\nI'm going to check if versioning can be enabled via ARM at this point. If not then is there any alternative to inject account and it's credentials somehow into the pipeline?", "author": "kasobol-msft", "createdAt": "2020-03-25T20:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE2NTQyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398165422", "bodyText": "If there isn't a way to add this as part of ARM we could resort to using a static testing resource given the limited number of tests that'll be using it. Given this is a new service feature I have a feeling there won't be ARM support for this.", "author": "alzimmermsft", "createdAt": "2020-03-25T20:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3OTk0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398179943", "bodyText": "Good news is that there is ARM support https://review.docs.microsoft.com/en-us/azure/storage/blobs/versioning-enable?branch=pr-en-us-104390&tabs=template .\nIs the azure-sdk-for-java\\sdk\\storage\\test-resources.json the only place that needs an update?", "author": "kasobol-msft", "createdAt": "2020-03-25T21:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNzQ5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r398717498", "bodyText": "On the other hand it might take some time before support through ARM is rolled out.\n@alzimmermsft what does it take to define static testing resource? Who does that?", "author": "kasobol-msft", "createdAt": "2020-03-26T16:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMTAxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r406511011", "bodyText": "@JimSuplizio could you chime in on how to define static resource (hardcoded storage account in this case ) ?", "author": "kasobol-msft", "createdAt": "2020-04-09T22:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc2MDgwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9283#discussion_r406760806", "bodyText": "@kasobol-msft unfortunately, I'm not the right person for this. @alzimmermsft and @hemanttanwar are the ones that setup the templates and test resources and @danieljurek may also have some input here.", "author": "JimSuplizio", "createdAt": "2020-04-10T13:37:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxNjM5Ng=="}], "type": "inlineReview"}, {"oid": "d951b669c7e4f7c584fcd7e220e1a781623b8234", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d951b669c7e4f7c584fcd7e220e1a781623b8234", "message": "Remove obsolete javadoc statements.", "committedDate": "2020-03-25T19:23:43Z", "type": "commit"}, {"oid": "eb466015e306d704ca6f464b9a52c43626029720", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb466015e306d704ca6f464b9a52c43626029720", "message": "javadoc null version", "committedDate": "2020-03-25T19:32:03Z", "type": "commit"}, {"oid": "ea06ee5a86803c3bf35dd3dd5e82a60c0a05d80a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea06ee5a86803c3bf35dd3dd5e82a60c0a05d80a", "message": "remove obsolete constructor in BlobSasImplUtil", "committedDate": "2020-03-25T20:09:06Z", "type": "commit"}, {"oid": "b54ed86c48e0dbf6420bce0d43636eb125945c56", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b54ed86c48e0dbf6420bce0d43636eb125945c56", "message": "Merge branch 'feature/storage/stg73' into feature/storage/blob-versioning", "committedDate": "2020-04-09T21:47:28Z", "type": "commit"}, {"oid": "bd7465abab34095128ba591076e58b91149dcbf2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bd7465abab34095128ba591076e58b91149dcbf2", "message": "define versioned storage account variables for static test resource injection until we figure out programmatic way.", "committedDate": "2020-04-10T20:44:36Z", "type": "commit"}]}