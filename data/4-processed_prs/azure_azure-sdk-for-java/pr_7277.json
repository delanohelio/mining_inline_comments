{"pr_number": 7277, "pr_title": "Adds support for Sync API read latency and read throughput benchmark", "pr_createdAt": "2020-01-08T19:59:44Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/7277", "timeline": [{"oid": "5efdc097cba5884932438f38bc10db6bf8510ff9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5efdc097cba5884932438f38bc10db6bf8510ff9", "message": "ported fix from v3", "committedDate": "2020-01-06T18:17:55Z", "type": "commit"}, {"oid": "2a311b2fc4b1b20c1dd5be65f7d237bdf94b48a0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a311b2fc4b1b20c1dd5be65f7d237bdf94b48a0", "message": "Merge branch 'feature/cosmos/v4' into users/moderakh/20200106-v4-perf", "committedDate": "2020-01-07T18:36:18Z", "type": "commit"}, {"oid": "c059bdce346591b240de9f6fbe1d5e4fbd4cb4b4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c059bdce346591b240de9f6fbe1d5e4fbd4cb4b4", "message": "adds support for doc field count in benchmark tool", "committedDate": "2020-01-07T23:04:25Z", "type": "commit"}, {"oid": "4801c918be02e695464cf5be5ebaed0d9a485aee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4801c918be02e695464cf5be5ebaed0d9a485aee", "message": "Merge branch 'feature/cosmos/v4' into users/moderakh/20200107-perf-tool-docFieldCnt", "committedDate": "2020-01-07T23:05:07Z", "type": "commit"}, {"oid": "957121faea5b4621d4011a8f0a96a2b169bb0ee9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/957121faea5b4621d4011a8f0a96a2b169bb0ee9", "message": "sync api benchmark app", "committedDate": "2020-01-08T19:56:05Z", "type": "commit"}, {"oid": "16839aeac5017a859231b01f2a79aecc1e5e406d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/16839aeac5017a859231b01f2a79aecc1e5e406d", "message": "Merge branch 'feature/cosmos/v4' into users/moderakh/v4-sync-api-benchmark-app", "committedDate": "2020-01-08T19:56:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3MDYwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364470605", "bodyText": "Nested classes should always be static unless they need enclosing class's object to be instantiated, or they are accessing or invoking any members or methods of enclosing class. In this case, I don't see any reason for this nested class to not be static.\nIn my opinion, we should change this to static nested class. This will save us memory when running these benchmarks.", "author": "kushagraThapar", "createdAt": "2020-01-08T22:16:31Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/SyncBenchmark.java", "diffHunk": "@@ -0,0 +1,359 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosClient;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosContainer;\n+import com.azure.cosmos.CosmosItemResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+abstract class SyncBenchmark<T> {\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final ScheduledReporter reporter;\n+    private final ExecutorService executorService;\n+\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+\n+    final Logger logger;\n+    final CosmosClient cosmosClient;\n+    final CosmosContainer cosmosContainer;\n+\n+    final String partitionKey;\n+    final Configuration configuration;\n+    final List<PojoizedJson> docsToRead;\n+    final Semaphore concurrencyControlSemaphore;\n+    Timer latency;\n+\n+    abstract class ResultHandler<T, Throwable> implements BiFunction<T, Throwable, T> {", "originalCommit": "16839aeac5017a859231b01f2a79aecc1e5e406d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4MjU0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364482546", "bodyText": "done", "author": "moderakh", "createdAt": "2020-01-08T22:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3MDYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3NDAzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364474039", "bodyText": "This is a good example of nested class (non-static) which uses enclosing class's members (latency here)", "author": "kushagraThapar", "createdAt": "2020-01-08T22:25:41Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/SyncBenchmark.java", "diffHunk": "@@ -0,0 +1,359 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosClient;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosContainer;\n+import com.azure.cosmos.CosmosItemResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+abstract class SyncBenchmark<T> {\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final ScheduledReporter reporter;\n+    private final ExecutorService executorService;\n+\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+\n+    final Logger logger;\n+    final CosmosClient cosmosClient;\n+    final CosmosContainer cosmosContainer;\n+\n+    final String partitionKey;\n+    final Configuration configuration;\n+    final List<PojoizedJson> docsToRead;\n+    final Semaphore concurrencyControlSemaphore;\n+    Timer latency;\n+\n+    abstract class ResultHandler<T, Throwable> implements BiFunction<T, Throwable, T> {\n+        ResultHandler() {\n+        }\n+\n+        protected void init() {\n+        }\n+\n+        @Override\n+        abstract public T apply(T o, Throwable throwable);\n+    }\n+\n+    class LatencyListener<T> extends ResultHandler<T, Throwable> {", "originalCommit": "16839aeac5017a859231b01f2a79aecc1e5e406d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3NDcyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364474720", "bodyText": "Please specify parameters in this declaration as this is a parametrized class.\nShould be -> CompletableFuture< PojoizedJson>", "author": "kushagraThapar", "createdAt": "2020-01-08T22:27:41Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/SyncBenchmark.java", "diffHunk": "@@ -0,0 +1,359 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosClient;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosContainer;\n+import com.azure.cosmos.CosmosItemResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+abstract class SyncBenchmark<T> {\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final ScheduledReporter reporter;\n+    private final ExecutorService executorService;\n+\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+\n+    final Logger logger;\n+    final CosmosClient cosmosClient;\n+    final CosmosContainer cosmosContainer;\n+\n+    final String partitionKey;\n+    final Configuration configuration;\n+    final List<PojoizedJson> docsToRead;\n+    final Semaphore concurrencyControlSemaphore;\n+    Timer latency;\n+\n+    abstract class ResultHandler<T, Throwable> implements BiFunction<T, Throwable, T> {\n+        ResultHandler() {\n+        }\n+\n+        protected void init() {\n+        }\n+\n+        @Override\n+        abstract public T apply(T o, Throwable throwable);\n+    }\n+\n+    class LatencyListener<T> extends ResultHandler<T, Throwable> {\n+        private final ResultHandler<T, Throwable> baseFunction;\n+        Timer.Context context;\n+        LatencyListener(ResultHandler<T, Throwable> baseFunction, Timer latency) {\n+            this.baseFunction = baseFunction;\n+        }\n+\n+        protected void init() {\n+            super.init();\n+            context = latency.time();\n+        }\n+\n+        @Override\n+        public T apply(T o, Throwable throwable) {\n+            context.stop();\n+            return baseFunction.apply(o, throwable);\n+        }\n+    }\n+\n+    SyncBenchmark(Configuration cfg) throws Exception {\n+        executorService = Executors.newFixedThreadPool(cfg.getConcurrency());\n+\n+        cosmosClient = new CosmosClientBuilder()\n+            .setEndpoint(cfg.getServiceEndpoint())\n+            .setKey(cfg.getMasterKey())\n+            .setConnectionPolicy(cfg.getConnectionPolicy())\n+            .setConsistencyLevel(cfg.getConsistencyLevel())\n+            .buildClient();\n+\n+        cosmosContainer = cosmosClient.getDatabase(cfg.getDatabaseId()).getContainer(cfg.getCollectionId()).read().getContainer();\n+\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        partitionKey = cosmosContainer.read().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+        configuration = cfg;\n+\n+        ArrayList<CompletableFuture<PojoizedJson>> createDocumentFutureList = new ArrayList<>();\n+\n+        if (configuration.getOperationType() != Configuration.Operation.WriteLatency\n+                && configuration.getOperationType() != Configuration.Operation.WriteThroughput\n+                && configuration.getOperationType() != Configuration.Operation.ReadMyWrites) {\n+            String dataFieldValue = RandomStringUtils.randomAlphabetic(cfg.getDocumentDataFieldSize());\n+            for (int i = 0; i < cfg.getNumberOfPreCreatedDocuments(); i++) {\n+                String uuid = UUID.randomUUID().toString();\n+                PojoizedJson newDoc = generateDocument(uuid, dataFieldValue);\n+                CompletableFuture futureResult = CompletableFuture.supplyAsync(() -> {", "originalCommit": "16839aeac5017a859231b01f2a79aecc1e5e406d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4MjU4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364482585", "bodyText": "addressed", "author": "moderakh", "createdAt": "2020-01-08T22:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3NDcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3NTM4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364475389", "bodyText": "Parameterized type, please change this to LatencyListener<T>... new LatencyListener<>(resultHandler, ...)", "author": "kushagraThapar", "createdAt": "2020-01-08T22:29:36Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/SyncBenchmark.java", "diffHunk": "@@ -0,0 +1,359 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosClient;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosContainer;\n+import com.azure.cosmos.CosmosItemResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+abstract class SyncBenchmark<T> {\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final ScheduledReporter reporter;\n+    private final ExecutorService executorService;\n+\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+\n+    final Logger logger;\n+    final CosmosClient cosmosClient;\n+    final CosmosContainer cosmosContainer;\n+\n+    final String partitionKey;\n+    final Configuration configuration;\n+    final List<PojoizedJson> docsToRead;\n+    final Semaphore concurrencyControlSemaphore;\n+    Timer latency;\n+\n+    abstract class ResultHandler<T, Throwable> implements BiFunction<T, Throwable, T> {\n+        ResultHandler() {\n+        }\n+\n+        protected void init() {\n+        }\n+\n+        @Override\n+        abstract public T apply(T o, Throwable throwable);\n+    }\n+\n+    class LatencyListener<T> extends ResultHandler<T, Throwable> {\n+        private final ResultHandler<T, Throwable> baseFunction;\n+        Timer.Context context;\n+        LatencyListener(ResultHandler<T, Throwable> baseFunction, Timer latency) {\n+            this.baseFunction = baseFunction;\n+        }\n+\n+        protected void init() {\n+            super.init();\n+            context = latency.time();\n+        }\n+\n+        @Override\n+        public T apply(T o, Throwable throwable) {\n+            context.stop();\n+            return baseFunction.apply(o, throwable);\n+        }\n+    }\n+\n+    SyncBenchmark(Configuration cfg) throws Exception {\n+        executorService = Executors.newFixedThreadPool(cfg.getConcurrency());\n+\n+        cosmosClient = new CosmosClientBuilder()\n+            .setEndpoint(cfg.getServiceEndpoint())\n+            .setKey(cfg.getMasterKey())\n+            .setConnectionPolicy(cfg.getConnectionPolicy())\n+            .setConsistencyLevel(cfg.getConsistencyLevel())\n+            .buildClient();\n+\n+        cosmosContainer = cosmosClient.getDatabase(cfg.getDatabaseId()).getContainer(cfg.getCollectionId()).read().getContainer();\n+\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        partitionKey = cosmosContainer.read().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+        configuration = cfg;\n+\n+        ArrayList<CompletableFuture<PojoizedJson>> createDocumentFutureList = new ArrayList<>();\n+\n+        if (configuration.getOperationType() != Configuration.Operation.WriteLatency\n+                && configuration.getOperationType() != Configuration.Operation.WriteThroughput\n+                && configuration.getOperationType() != Configuration.Operation.ReadMyWrites) {\n+            String dataFieldValue = RandomStringUtils.randomAlphabetic(cfg.getDocumentDataFieldSize());\n+            for (int i = 0; i < cfg.getNumberOfPreCreatedDocuments(); i++) {\n+                String uuid = UUID.randomUUID().toString();\n+                PojoizedJson newDoc = generateDocument(uuid, dataFieldValue);\n+                CompletableFuture futureResult = CompletableFuture.supplyAsync(() -> {\n+\n+                    try {\n+                        CosmosItemResponse itemResponse = cosmosContainer.createItem(newDoc);\n+                        return toPojoizedJson(itemResponse);\n+\n+                    } catch (Exception e) {\n+                        throw propagate(e);\n+                    }\n+\n+                }, executorService);\n+\n+                createDocumentFutureList.add(futureResult);\n+            }\n+        }\n+\n+        docsToRead = createDocumentFutureList.stream().map(future -> getOrThrow(future)).collect(Collectors.toList());\n+        init();\n+\n+        if (configuration.isEnableJvmStats()) {\n+            metricsRegistry.register(\"gc\", new GarbageCollectorMetricSet());\n+            metricsRegistry.register(\"threads\", new CachedThreadStatesGaugeSet(10, TimeUnit.SECONDS));\n+            metricsRegistry.register(\"memory\", new MemoryUsageGaugeSet());\n+        }\n+\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                                       .prefixedWith(configuration.getOperationType().name())\n+                                       .convertRatesTo(TimeUnit.SECONDS)\n+                                       .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                                       .filter(MetricFilter.ALL)\n+                                       .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                                      .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+\n+        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+\n+        registry = configuration.getGraphiteMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+    }\n+\n+    protected void init() {\n+    }\n+\n+    void shutdown() {\n+        cosmosClient.close();\n+        executorService.shutdown();\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    protected abstract T performWorkload(long i) throws Exception;\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    void run() throws Exception {\n+\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+\n+        switch (configuration.getOperationType()) {\n+            case ReadLatency:\n+                // TODO: support for other operationTypes will be added later\n+//            case WriteLatency:\n+//            case QueryInClauseParallel:\n+//            case QueryCross:\n+//            case QuerySingle:\n+//            case QuerySingleMany:\n+//            case QueryParallel:\n+//            case QueryOrderby:\n+//            case QueryAggregate:\n+//            case QueryAggregateTopOrderby:\n+//            case QueryTopOrderby:\n+            case Mixed:\n+                latency = metricsRegistry.timer(\"Latency\");\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        long startTime = System.currentTimeMillis();\n+\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+\n+        for ( i = 0; shouldContinue(startTime, i); i++) {\n+\n+            ResultHandler<T, Throwable> resultHandler = new ResultHandler<T, Throwable>() {\n+                @Override\n+                public T apply(T t, Throwable throwable) {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    if (t != null) {\n+                        assert(throwable == null);\n+                        SyncBenchmark.this.onSuccess();\n+                        synchronized (count) {\n+                            count.incrementAndGet();\n+                            count.notify();\n+                        }\n+                    } else {\n+                        assert(throwable != null);\n+\n+                        failureMeter.mark();\n+                        logger.error(\"Encountered failure {} on thread {}\" ,\n+                                     throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                        concurrencyControlSemaphore.release();\n+                        SyncBenchmark.this.onError(throwable);\n+\n+                        synchronized (count) {\n+                            count.incrementAndGet();\n+                            count.notify();\n+                        }\n+                    }\n+\n+                    return t;\n+                }\n+            };\n+\n+            concurrencyControlSemaphore.acquire();\n+            final long cnt = i;\n+\n+            switch (configuration.getOperationType()) {\n+                case ReadLatency:\n+                    // TODO: support for other operation types will be added later\n+//                case WriteLatency:\n+//                case QueryInClauseParallel:\n+//                case QueryCross:\n+//                case QuerySingle:\n+//                case QuerySingleMany:\n+//                case QueryParallel:\n+//                case QueryOrderby:\n+//                case QueryAggregate:\n+//                case QueryAggregateTopOrderby:\n+//                case QueryTopOrderby:\n+//                case Mixed:\n+                    LatencyListener latencyListener = new LatencyListener(resultHandler, latency);", "originalCommit": "16839aeac5017a859231b01f2a79aecc1e5e406d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4MjczNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364482735", "bodyText": "addressed", "author": "moderakh", "createdAt": "2020-01-08T22:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3NTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3NTcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364475711", "bodyText": "Parametrized type -> CompletableFuture<T>", "author": "kushagraThapar", "createdAt": "2020-01-08T22:30:29Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/SyncBenchmark.java", "diffHunk": "@@ -0,0 +1,359 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosClient;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosContainer;\n+import com.azure.cosmos.CosmosItemResponse;\n+import com.azure.cosmos.implementation.Utils;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+abstract class SyncBenchmark<T> {\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final ScheduledReporter reporter;\n+    private final ExecutorService executorService;\n+\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+\n+    final Logger logger;\n+    final CosmosClient cosmosClient;\n+    final CosmosContainer cosmosContainer;\n+\n+    final String partitionKey;\n+    final Configuration configuration;\n+    final List<PojoizedJson> docsToRead;\n+    final Semaphore concurrencyControlSemaphore;\n+    Timer latency;\n+\n+    abstract class ResultHandler<T, Throwable> implements BiFunction<T, Throwable, T> {\n+        ResultHandler() {\n+        }\n+\n+        protected void init() {\n+        }\n+\n+        @Override\n+        abstract public T apply(T o, Throwable throwable);\n+    }\n+\n+    class LatencyListener<T> extends ResultHandler<T, Throwable> {\n+        private final ResultHandler<T, Throwable> baseFunction;\n+        Timer.Context context;\n+        LatencyListener(ResultHandler<T, Throwable> baseFunction, Timer latency) {\n+            this.baseFunction = baseFunction;\n+        }\n+\n+        protected void init() {\n+            super.init();\n+            context = latency.time();\n+        }\n+\n+        @Override\n+        public T apply(T o, Throwable throwable) {\n+            context.stop();\n+            return baseFunction.apply(o, throwable);\n+        }\n+    }\n+\n+    SyncBenchmark(Configuration cfg) throws Exception {\n+        executorService = Executors.newFixedThreadPool(cfg.getConcurrency());\n+\n+        cosmosClient = new CosmosClientBuilder()\n+            .setEndpoint(cfg.getServiceEndpoint())\n+            .setKey(cfg.getMasterKey())\n+            .setConnectionPolicy(cfg.getConnectionPolicy())\n+            .setConsistencyLevel(cfg.getConsistencyLevel())\n+            .buildClient();\n+\n+        cosmosContainer = cosmosClient.getDatabase(cfg.getDatabaseId()).getContainer(cfg.getCollectionId()).read().getContainer();\n+\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        partitionKey = cosmosContainer.read().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+        configuration = cfg;\n+\n+        ArrayList<CompletableFuture<PojoizedJson>> createDocumentFutureList = new ArrayList<>();\n+\n+        if (configuration.getOperationType() != Configuration.Operation.WriteLatency\n+                && configuration.getOperationType() != Configuration.Operation.WriteThroughput\n+                && configuration.getOperationType() != Configuration.Operation.ReadMyWrites) {\n+            String dataFieldValue = RandomStringUtils.randomAlphabetic(cfg.getDocumentDataFieldSize());\n+            for (int i = 0; i < cfg.getNumberOfPreCreatedDocuments(); i++) {\n+                String uuid = UUID.randomUUID().toString();\n+                PojoizedJson newDoc = generateDocument(uuid, dataFieldValue);\n+                CompletableFuture futureResult = CompletableFuture.supplyAsync(() -> {\n+\n+                    try {\n+                        CosmosItemResponse itemResponse = cosmosContainer.createItem(newDoc);\n+                        return toPojoizedJson(itemResponse);\n+\n+                    } catch (Exception e) {\n+                        throw propagate(e);\n+                    }\n+\n+                }, executorService);\n+\n+                createDocumentFutureList.add(futureResult);\n+            }\n+        }\n+\n+        docsToRead = createDocumentFutureList.stream().map(future -> getOrThrow(future)).collect(Collectors.toList());\n+        init();\n+\n+        if (configuration.isEnableJvmStats()) {\n+            metricsRegistry.register(\"gc\", new GarbageCollectorMetricSet());\n+            metricsRegistry.register(\"threads\", new CachedThreadStatesGaugeSet(10, TimeUnit.SECONDS));\n+            metricsRegistry.register(\"memory\", new MemoryUsageGaugeSet());\n+        }\n+\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                                       .prefixedWith(configuration.getOperationType().name())\n+                                       .convertRatesTo(TimeUnit.SECONDS)\n+                                       .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                                       .filter(MetricFilter.ALL)\n+                                       .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                                      .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+\n+        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+\n+        registry = configuration.getGraphiteMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+    }\n+\n+    protected void init() {\n+    }\n+\n+    void shutdown() {\n+        cosmosClient.close();\n+        executorService.shutdown();\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    protected abstract T performWorkload(long i) throws Exception;\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    void run() throws Exception {\n+\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+\n+        switch (configuration.getOperationType()) {\n+            case ReadLatency:\n+                // TODO: support for other operationTypes will be added later\n+//            case WriteLatency:\n+//            case QueryInClauseParallel:\n+//            case QueryCross:\n+//            case QuerySingle:\n+//            case QuerySingleMany:\n+//            case QueryParallel:\n+//            case QueryOrderby:\n+//            case QueryAggregate:\n+//            case QueryAggregateTopOrderby:\n+//            case QueryTopOrderby:\n+            case Mixed:\n+                latency = metricsRegistry.timer(\"Latency\");\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        long startTime = System.currentTimeMillis();\n+\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+\n+        for ( i = 0; shouldContinue(startTime, i); i++) {\n+\n+            ResultHandler<T, Throwable> resultHandler = new ResultHandler<T, Throwable>() {\n+                @Override\n+                public T apply(T t, Throwable throwable) {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    if (t != null) {\n+                        assert(throwable == null);\n+                        SyncBenchmark.this.onSuccess();\n+                        synchronized (count) {\n+                            count.incrementAndGet();\n+                            count.notify();\n+                        }\n+                    } else {\n+                        assert(throwable != null);\n+\n+                        failureMeter.mark();\n+                        logger.error(\"Encountered failure {} on thread {}\" ,\n+                                     throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                        concurrencyControlSemaphore.release();\n+                        SyncBenchmark.this.onError(throwable);\n+\n+                        synchronized (count) {\n+                            count.incrementAndGet();\n+                            count.notify();\n+                        }\n+                    }\n+\n+                    return t;\n+                }\n+            };\n+\n+            concurrencyControlSemaphore.acquire();\n+            final long cnt = i;\n+\n+            switch (configuration.getOperationType()) {\n+                case ReadLatency:\n+                    // TODO: support for other operation types will be added later\n+//                case WriteLatency:\n+//                case QueryInClauseParallel:\n+//                case QueryCross:\n+//                case QuerySingle:\n+//                case QuerySingleMany:\n+//                case QueryParallel:\n+//                case QueryOrderby:\n+//                case QueryAggregate:\n+//                case QueryAggregateTopOrderby:\n+//                case QueryTopOrderby:\n+//                case Mixed:\n+                    LatencyListener latencyListener = new LatencyListener(resultHandler, latency);\n+                    latencyListener.context = latency.time();\n+                    resultHandler = latencyListener;\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            final ResultHandler<T, Throwable> finalResultHandler = resultHandler;\n+\n+            CompletableFuture futureResult = CompletableFuture.supplyAsync(() -> {", "originalCommit": "16839aeac5017a859231b01f2a79aecc1e5e406d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4MjY1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7277#discussion_r364482654", "bodyText": "addressed", "author": "moderakh", "createdAt": "2020-01-08T22:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ3NTcxMQ=="}], "type": "inlineReview"}, {"oid": "676c0c7abd53bd0dfdd89bb3d79c84047a5e3a71", "url": "https://github.com/Azure/azure-sdk-for-java/commit/676c0c7abd53bd0dfdd89bb3d79c84047a5e3a71", "message": "addressed review comments", "committedDate": "2020-01-08T22:49:40Z", "type": "commit"}]}