{"pr_number": 7298, "pr_title": "Implements a slf4j logger impl as default logger in azure core", "pr_createdAt": "2020-01-09T02:43:34Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/7298", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU0ODczMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364548732", "bodyText": "missing description for param level and format", "author": "mssfang", "createdAt": "2020-01-09T03:48:54Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public class DefaultLogger extends DefaultLoggerBase {\n+    private final String classPath;\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(String.format(\"We are not able to find the class %s in default logger.\",\n+                className));\n+        }\n+    }\n+\n+    /**\n+     * Perform double parameter substitution before logging the message of level\n+     * DEBUG according to the format outlined above.\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Perform double parameter substitution before logging the message of level\n+     * DEBUG according to the format outlined above.\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Perform double parameter substitution before logging the message of level\n+     * DEBUG according to the format outlined above.\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Perform double parameter substitution before logging the message of level\n+     * DEBUG according to the format outlined above.\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1MDY3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364550674", "bodyText": "At leastt do not use 'java.util.Date'.  https://programminghints.com/2017/05/still-using-java-util-date-dont/", "author": "mssfang", "createdAt": "2020-01-09T04:00:07Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU0OTY0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364549648", "bodyText": "I think we should implement this and remove the class name tracking from ClientLogger", "author": "alzimmermsft", "createdAt": "2020-01-09T03:54:06Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLoggerBase.java", "diffHunk": "@@ -0,0 +1,841 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+\n+public abstract class DefaultLoggerBase implements Logger {\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance.\n+     *\n+     * @return name of this logger instance\n+     */\n+    @Override\n+    public String getName() {\n+        return null;", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5OTg1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364899853", "bodyText": "ClientLogger passes the class name to DefaultLogger. Is it not that useful at DefaultLoggerBase layer, since we need to add private field and pass the class name to base class. I prefer to leave it alone.", "author": "sima-zhu", "createdAt": "2020-01-09T18:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU0OTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU0OTk4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364549986", "bodyText": "Given that we don't want to implement these we may want to throw an exception here to enforce that this shouldn't be used.", "author": "alzimmermsft", "createdAt": "2020-01-09T03:55:58Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLoggerBase.java", "diffHunk": "@@ -0,0 +1,841 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+\n+public abstract class DefaultLoggerBase implements Logger {\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance.\n+     *\n+     * @return name of this logger instance\n+     */\n+    @Override\n+    public String getName() {\n+        return null;\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the TRACE level?\n+     *\n+     * @return True if this Logger is enabled for the TRACE level,\n+     * false otherwise.\n+     * @since 1.4\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        return false;\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level.\n+     *\n+     * @param msg the message string to be logged\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final String msg) {", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1MDE5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364550199", "bodyText": "Let's implement this to validate against the environment variable, same goes for the other log levels we want to support", "author": "alzimmermsft", "createdAt": "2020-01-09T03:57:06Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLoggerBase.java", "diffHunk": "@@ -0,0 +1,841 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+\n+public abstract class DefaultLoggerBase implements Logger {\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance.\n+     *\n+     * @return name of this logger instance\n+     */\n+    @Override\n+    public String getName() {\n+        return null;\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the TRACE level?\n+     *\n+     * @return True if this Logger is enabled for the TRACE level,\n+     * false otherwise.\n+     * @since 1.4\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        return false;\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level.\n+     *\n+     * @param msg the message string to be logged\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final String msg) {\n+\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and argument.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg the argument\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg) {\n+\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg1 the first argument\n+     * @param arg2 the second argument\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1, final Object arg2) {\n+\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the TRACE level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for TRACE. The variants taking {@link #trace(String, Object) one} and\n+     * {@link #trace(String, Object, Object) two} arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param arguments a list of 3 or more arguments\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final String format, final Object... arguments) {\n+\n+    }\n+\n+    /**\n+     * Log an exception (throwable) at the TRACE level with an\n+     * accompanying message.\n+     *\n+     * @param msg the message accompanying the exception\n+     * @param t the exception (throwable) to log\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final String msg, final Throwable t) {\n+\n+    }\n+\n+    /**\n+     * Similar to {@link #isTraceEnabled()} method except that the\n+     * marker data is also taken into account.\n+     *\n+     * @param marker The marker data to take into consideration\n+     * @return True if this Logger is enabled for the TRACE level,\n+     * false otherwise.\n+     * @since 1.4\n+     */\n+    @Override\n+    public boolean isTraceEnabled(final Marker marker) {\n+        return false;\n+    }\n+\n+    /**\n+     * Log a message with the specific Marker at the TRACE level.\n+     *\n+     * @param marker the marker data specific to this log statement\n+     * @param msg the message string to be logged\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final Marker marker, final String msg) {\n+\n+    }\n+\n+    /**\n+     * This method is similar to {@link #trace(String, Object)} method except that the\n+     * marker data is also taken into consideration.\n+     *\n+     * @param marker the marker data specific to this log statement\n+     * @param format the format string\n+     * @param arg the argument\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final Marker marker, final String format, final Object arg) {\n+\n+    }\n+\n+    /**\n+     * This method is similar to {@link #trace(String, Object, Object)}\n+     * method except that the marker data is also taken into\n+     * consideration.\n+     *\n+     * @param marker the marker data specific to this log statement\n+     * @param format the format string\n+     * @param arg1 the first argument\n+     * @param arg2 the second argument\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final Marker marker, final String format, final Object arg1, final Object arg2) {\n+\n+    }\n+\n+    /**\n+     * This method is similar to {@link #trace(String, Object...)}\n+     * method except that the marker data is also taken into\n+     * consideration.\n+     *\n+     * @param marker the marker data specific to this log statement\n+     * @param format the format string\n+     * @param argArray an array of arguments\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final Marker marker, final String format, final Object... argArray) {\n+\n+    }\n+\n+    /**\n+     * This method is similar to {@link #trace(String, Throwable)} method except that the\n+     * marker data is also taken into consideration.\n+     *\n+     * @param marker the marker data specific to this log statement\n+     * @param msg the message accompanying the exception\n+     * @param t the exception (throwable) to log\n+     * @since 1.4\n+     */\n+    @Override\n+    public void trace(final Marker marker, final String msg, final Throwable t) {\n+\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the DEBUG level?\n+     *\n+     * @return True if this Logger is enabled for the DEBUG level,\n+     * false otherwise.\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        return false;", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkwOTA0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364909046", "bodyText": "Since default logger base is package private abstract class, we always need to have it in DefaultLogger. However API is not that useful for current structure.\nIt is not always the case to read env. We might need to introduce reading from file and etc in future. So it better to have it in subclass instead of base class.\nI think to leave it as it is. And we can easily implement this if there is a need in future.", "author": "sima-zhu", "createdAt": "2020-01-09T19:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1MDE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU2OTQ2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364569462", "bodyText": "Shouldn't assume this is always a class, I believe any arbitrary string could be used", "author": "alzimmermsft", "createdAt": "2020-01-09T05:55:44Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public class DefaultLogger extends DefaultLoggerBase {\n+    private final String classPath;\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg4MzQwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364883407", "bodyText": "Switch to\n        try {\n            this.classPath = Class.forName(className).getCanonicalName();\n        } catch (ClassNotFoundException e) {\n            this.classPath = className;\n        }", "author": "sima-zhu", "createdAt": "2020-01-09T18:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU2OTQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU2OTY5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364569694", "bodyText": "Do we actually want this to be a publicly extendible class?", "author": "alzimmermsft", "createdAt": "2020-01-09T05:56:57Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLoggerBase.java", "diffHunk": "@@ -0,0 +1,841 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+\n+public abstract class DefaultLoggerBase implements Logger {", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MDI3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364570277", "bodyText": "Should make the entire print statement a single operation to prevent race conditions interleaving messages", "author": "alzimmermsft", "createdAt": "2020-01-09T05:59:38Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public class DefaultLogger extends DefaultLoggerBase {\n+    private final String classPath;\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(String.format(\"We are not able to find the class %s in default logger.\",\n+                className));\n+        }\n+    }\n+\n+    /**\n+     * Perform double parameter substitution before logging the message of level\n+     * DEBUG according to the format outlined above.\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Perform double parameter substitution before logging the message of level\n+     * DEBUG according to the format outlined above.\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Perform double parameter substitution before logging the message of level\n+     * DEBUG according to the format outlined above.\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Perform double parameter substitution before logging the message of level\n+     * DEBUG according to the format outlined above.\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level\n+     * @param format\n+     * @param arguments\n+     *            a list of 3 ore more arguments\n+     */\n+    private void formatAndLog(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * This is our internal implementation for logging regular\n+     * (non-parameterized) log messages.\n+     *\n+     * @param level\n+     *            One of the LOG_LEVEL_XXX constants defining the log level\n+     * @param message\n+     *            The message itself\n+     * @param t\n+     *            The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        StringBuilder buf = new StringBuilder(32);\n+\n+        // Append date-time.\n+        buf.append(getFormattedDate());\n+        buf.append(' ');\n+\n+        // Append current thread name if so configured\n+        buf.append('[');\n+        buf.append(Thread.currentThread().getName());\n+        buf.append(\"] \");\n+\n+\n+        // Append a readable representation of the log level\n+        buf.append('[');\n+        buf.append(level.name());\n+        buf.append(']');\n+        buf.append(' ');\n+\n+        // Append the name of the log instance if so configured\n+        buf.append(classPath).append(\" - \");\n+\n+        // Append the message\n+        buf.append(message);\n+\n+        write(buf, t);\n+    }\n+\n+    private String getFormattedDate() {\n+        Date now = new Date();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    void write(StringBuilder buf, Throwable t) {\n+        PrintStream targetStream = System.out;\n+\n+        targetStream.println(buf.toString());", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5Njg4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364896889", "bodyText": "https://stackoverflow.com/questions/9459657/is-multi-thread-output-from-system-out-println-interleaved\nMake the print process atomic so the log message will not intervene by other message, or print throwable to other places.", "author": "sima-zhu", "createdAt": "2020-01-09T18:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MDI3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkxNzA3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364917071", "bodyText": "The individual print statement shouldn't interleave but right now we print the message and stack trace in two separate calls which could result in the following scenario.\nTwo exceptions are being logged, problemA and problemB, logging could have the following outcome\n\nproblemA message\nproblemB message\nproblemA stack trace\nproblemB stack trace\n\nInstead we should build the message + stack trace and log them in one print call.", "author": "alzimmermsft", "createdAt": "2020-01-09T19:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MDI3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0MjYwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364942606", "bodyText": "void write(StringBuilder buf, Throwable t) {\n        if (t != null) {\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            t.printStackTrace(pw);\n            String sStackTrace = sw.toString();\n            buf.append(sStackTrace);\n        }\n        System.out.println(buf.toString());\n    }", "author": "sima-zhu", "createdAt": "2020-01-09T20:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MDI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MDM3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364570379", "bodyText": "Should this be final?", "author": "alzimmermsft", "createdAt": "2020-01-09T06:00:17Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public class DefaultLogger extends DefaultLoggerBase {", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzE5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364897192", "bodyText": "Made it final", "author": "sima-zhu", "createdAt": "2020-01-09T18:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MDM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MDk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364570940", "bodyText": "Why is this no longer final? Instead load the SLF4J binded instance into a temp variable then set this based on that being a NOPLogger.", "author": "alzimmermsft", "createdAt": "2020-01-09T06:03:15Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -35,7 +36,8 @@\n  * @see Configuration\n  */\n public class ClientLogger {\n-    private final Logger logger;\n+    private Logger logger;", "originalCommit": "f2296c0e94b14d23043a29ec1d4215e184c63a0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzMzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364897333", "bodyText": "Revert back to final", "author": "sima-zhu", "createdAt": "2020-01-09T18:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkxNzc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364917777", "bodyText": "This can be removed now that the fields in ClientLogger are final", "author": "alzimmermsft", "createdAt": "2020-01-09T19:23:11Z", "path": "eng/code-quality-reports/src/main/resources/checkstyle/checkstyle-suppressions.xml", "diffHunk": "@@ -96,6 +96,9 @@\n   <!-- Custom checkstyle rules only check track 2 libraries -->\n   <suppress checks=\"com\\.azure\\.tools\\.checkstyle\\.checks\\..+\" files=\".*[/\\\\]com[/\\\\]microsoft[/\\\\].*\"/>\n \n+  <!-- There is a need to check whether assign logger to the slf4j binding one or default one. -->\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.EnforceFinalFieldsCheck\" files=\".*ClientLogger.java\"/>\n+", "originalCommit": "074bad8c798c274f1ac2fd24f41909ee7caea9ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkxOTg5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364919892", "bodyText": "Let's remove these Javadocs and just use\n/**\n * {@inheritDoc}\n */", "author": "alzimmermsft", "createdAt": "2020-01-09T19:28:03Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLoggerBase.java", "diffHunk": "@@ -0,0 +1,886 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+\n+abstract class DefaultLoggerBase implements Logger {\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance. It is currently not supported.\n+     *\n+     * @return name of this logger instance\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the TRACE level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the TRACE level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */", "originalCommit": "074bad8c798c274f1ac2fd24f41909ee7caea9ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkzMzA3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364933074", "bodyText": "javadoc", "author": "srnagar", "createdAt": "2020-01-09T19:58:09Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLoggerBase.java", "diffHunk": "@@ -0,0 +1,886 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.Marker;\n+\n+abstract class DefaultLoggerBase implements Logger {", "originalCommit": "07e4921ce72b6074a713346d563ea8b168b96583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAyODU4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365028586", "bodyText": "Removed.", "author": "sima-zhu", "createdAt": "2020-01-10T00:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkzMzA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2ODc5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364968791", "bodyText": "Both StringWriter and PrintWriter should be closed after use", "author": "srnagar", "createdAt": "2020-01-09T21:30:08Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,559 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the DEBUG level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for DEBUG. The variants taking\n+     * {@link #debug(String, Object) one} and {@link #debug(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the INFO level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the INFO level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for INFO. The variants taking\n+     * {@link #info(String, Object) one} and {@link #info(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the WARN level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the WARN level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for WARN. The variants taking\n+     * {@link #warn(String, Object) one} and {@link #warn(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the ERROR level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the ERROR level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for ERROR. The variants taking\n+     * {@link #error(String, Object) one} and {@link #error(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void formatAndLog(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * This is our internal implementation for logging regular\n+     * (non-parameterized) log messages.\n+     *\n+     * @param level\n+     *            One of the LOG_LEVEL_XXX constants defining the log level\n+     * @param message\n+     *            The message itself\n+     * @param t\n+     *            The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        StringBuilder buf = new StringBuilder(32);\n+\n+        // Append date-time.\n+        buf.append(getFormattedDate());\n+        buf.append(' ');\n+\n+        // Append current thread name if so configured\n+        buf.append('[');\n+        buf.append(Thread.currentThread().getName());\n+        buf.append(\"] \");\n+\n+\n+        // Append a readable representation of the log level\n+        buf.append('[');\n+        buf.append(level.name());\n+        buf.append(']');\n+        buf.append(' ');\n+\n+        // Append the name of the log instance if so configured\n+        buf.append(classPath).append(\" - \");\n+\n+        // Append the message\n+        buf.append(message);\n+\n+        write(buf, t);\n+    }\n+\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    void write(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);", "originalCommit": "7cc5822ffbb08042d165667437e5a72e01ad71c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAyODU0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365028544", "bodyText": "StringWriter does not need to close as it is a no op.\nhttps://stackoverflow.com/questions/14542535/will-not-closing-a-stringwriter-cause-a-leak\nClosed the PrintStream", "author": "sima-zhu", "createdAt": "2020-01-10T00:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2ODc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3Nzc1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364977754", "bodyText": "nit: fix formatting.", "author": "srnagar", "createdAt": "2020-01-09T21:52:30Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,559 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the DEBUG level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for DEBUG. The variants taking\n+     * {@link #debug(String, Object) one} and {@link #debug(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the INFO level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the INFO level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for INFO. The variants taking\n+     * {@link #info(String, Object) one} and {@link #info(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the WARN level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the WARN level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for WARN. The variants taking\n+     * {@link #warn(String, Object) one} and {@link #warn(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the ERROR level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the ERROR level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for ERROR. The variants taking\n+     * {@link #error(String, Object) one} and {@link #error(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void formatAndLog(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * This is our internal implementation for logging regular\n+     * (non-parameterized) log messages.\n+     *\n+     * @param level\n+     *            One of the LOG_LEVEL_XXX constants defining the log level", "originalCommit": "7cc5822ffbb08042d165667437e5a72e01ad71c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAyODY0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365028645", "bodyText": "Done.", "author": "sima-zhu", "createdAt": "2020-01-10T00:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3Nzc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3ODc1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364978753", "bodyText": "This should be supported since we have an implementation for debug(String format, Object.. argArray) on line 61.", "author": "srnagar", "createdAt": "2020-01-09T21:55:05Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,559 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the DEBUG level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for DEBUG. The variants taking\n+     * {@link #debug(String, Object) one} and {@link #debug(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the INFO level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the INFO level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for INFO. The variants taking\n+     * {@link #info(String, Object) one} and {@link #info(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the WARN level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the WARN level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for WARN. The variants taking\n+     * {@link #warn(String, Object) one} and {@link #warn(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the ERROR level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the ERROR level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for ERROR. The variants taking\n+     * {@link #error(String, Object) one} and {@link #error(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void formatAndLog(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * This is our internal implementation for logging regular\n+     * (non-parameterized) log messages.\n+     *\n+     * @param level\n+     *            One of the LOG_LEVEL_XXX constants defining the log level\n+     * @param message\n+     *            The message itself\n+     * @param t\n+     *            The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        StringBuilder buf = new StringBuilder(32);\n+\n+        // Append date-time.\n+        buf.append(getFormattedDate());\n+        buf.append(' ');\n+\n+        // Append current thread name if so configured\n+        buf.append('[');\n+        buf.append(Thread.currentThread().getName());\n+        buf.append(\"] \");\n+\n+\n+        // Append a readable representation of the log level\n+        buf.append('[');\n+        buf.append(level.name());\n+        buf.append(']');\n+        buf.append(' ');\n+\n+        // Append the name of the log instance if so configured\n+        buf.append(classPath).append(\" - \");\n+\n+        // Append the message\n+        buf.append(message);\n+\n+        write(buf, t);\n+    }\n+\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    void write(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            t.printStackTrace(pw);\n+            buf.append(sw.toString());\n+        }\n+        System.out.println(buf.toString());\n+    }\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance. It is currently not supported.\n+     *\n+     * @return name of this logger instance\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the TRACE level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the TRACE level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and argument. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg the argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg1 the first argument\n+     * @param arg2 the second argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the TRACE level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for TRACE. The variants taking {@link #trace(String, Object) one} and\n+     * {@link #trace(String, Object, Object) two} arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param arguments a list of 3 or more arguments\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object... arguments) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log an exception (throwable) at the TRACE level with an\n+     * accompanying message. It is currently not supported.\n+     *\n+     * @param msg the message accompanying the exception\n+     * @param t the exception (throwable) to log\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the DEBUG level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the DEBUG level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        throw new UnsupportedOperationException();", "originalCommit": "7cc5822ffbb08042d165667437e5a72e01ad71c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3OTA4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364979085", "bodyText": "This should be supported too as we have support for debug overload with formatted strings.", "author": "srnagar", "createdAt": "2020-01-09T21:55:58Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,559 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the DEBUG level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for DEBUG. The variants taking\n+     * {@link #debug(String, Object) one} and {@link #debug(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the INFO level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the INFO level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for INFO. The variants taking\n+     * {@link #info(String, Object) one} and {@link #info(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the WARN level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the WARN level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for WARN. The variants taking\n+     * {@link #warn(String, Object) one} and {@link #warn(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the ERROR level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the ERROR level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for ERROR. The variants taking\n+     * {@link #error(String, Object) one} and {@link #error(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void formatAndLog(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * This is our internal implementation for logging regular\n+     * (non-parameterized) log messages.\n+     *\n+     * @param level\n+     *            One of the LOG_LEVEL_XXX constants defining the log level\n+     * @param message\n+     *            The message itself\n+     * @param t\n+     *            The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        StringBuilder buf = new StringBuilder(32);\n+\n+        // Append date-time.\n+        buf.append(getFormattedDate());\n+        buf.append(' ');\n+\n+        // Append current thread name if so configured\n+        buf.append('[');\n+        buf.append(Thread.currentThread().getName());\n+        buf.append(\"] \");\n+\n+\n+        // Append a readable representation of the log level\n+        buf.append('[');\n+        buf.append(level.name());\n+        buf.append(']');\n+        buf.append(' ');\n+\n+        // Append the name of the log instance if so configured\n+        buf.append(classPath).append(\" - \");\n+\n+        // Append the message\n+        buf.append(message);\n+\n+        write(buf, t);\n+    }\n+\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    void write(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            t.printStackTrace(pw);\n+            buf.append(sw.toString());\n+        }\n+        System.out.println(buf.toString());\n+    }\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance. It is currently not supported.\n+     *\n+     * @return name of this logger instance\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the TRACE level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the TRACE level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and argument. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg the argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg1 the first argument\n+     * @param arg2 the second argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the TRACE level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for TRACE. The variants taking {@link #trace(String, Object) one} and\n+     * {@link #trace(String, Object, Object) two} arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param arguments a list of 3 or more arguments\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object... arguments) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log an exception (throwable) at the TRACE level with an\n+     * accompanying message. It is currently not supported.\n+     *\n+     * @param msg the message accompanying the exception\n+     * @param t the exception (throwable) to log\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the DEBUG level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the DEBUG level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String msg) {\n+        throw new UnsupportedOperationException();", "originalCommit": "7cc5822ffbb08042d165667437e5a72e01ad71c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ1OTI0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365459248", "bodyText": "I enabled the ones used by ClientLogger.", "author": "sima-zhu", "createdAt": "2020-01-10T22:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3OTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3OTI0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364979249", "bodyText": "This should be supported. We should return the name of this logger instance.", "author": "srnagar", "createdAt": "2020-01-09T21:56:23Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,559 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the DEBUG level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for DEBUG. The variants taking\n+     * {@link #debug(String, Object) one} and {@link #debug(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the INFO level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the INFO level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for INFO. The variants taking\n+     * {@link #info(String, Object) one} and {@link #info(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the WARN level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the WARN level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for WARN. The variants taking\n+     * {@link #warn(String, Object) one} and {@link #warn(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the ERROR level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the ERROR level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for ERROR. The variants taking\n+     * {@link #error(String, Object) one} and {@link #error(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void formatAndLog(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * This is our internal implementation for logging regular\n+     * (non-parameterized) log messages.\n+     *\n+     * @param level\n+     *            One of the LOG_LEVEL_XXX constants defining the log level\n+     * @param message\n+     *            The message itself\n+     * @param t\n+     *            The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        StringBuilder buf = new StringBuilder(32);\n+\n+        // Append date-time.\n+        buf.append(getFormattedDate());\n+        buf.append(' ');\n+\n+        // Append current thread name if so configured\n+        buf.append('[');\n+        buf.append(Thread.currentThread().getName());\n+        buf.append(\"] \");\n+\n+\n+        // Append a readable representation of the log level\n+        buf.append('[');\n+        buf.append(level.name());\n+        buf.append(']');\n+        buf.append(' ');\n+\n+        // Append the name of the log instance if so configured\n+        buf.append(classPath).append(\" - \");\n+\n+        // Append the message\n+        buf.append(message);\n+\n+        write(buf, t);\n+    }\n+\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    void write(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            t.printStackTrace(pw);\n+            buf.append(sw.toString());\n+        }\n+        System.out.println(buf.toString());\n+    }\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance. It is currently not supported.\n+     *\n+     * @return name of this logger instance\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();", "originalCommit": "7cc5822ffbb08042d165667437e5a72e01ad71c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0Nzg3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365347876", "bodyText": "Talked offline. Will create an issue and put Up-for-grabs label.", "author": "sima-zhu", "createdAt": "2020-01-10T17:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3OTI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1MDY5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365350698", "bodyText": "github.com//issues/7341", "author": "sima-zhu", "createdAt": "2020-01-10T17:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3OTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3OTcyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364979721", "bodyText": "All is*Enabled() methods should be supported.", "author": "srnagar", "createdAt": "2020-01-09T21:57:29Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,559 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the DEBUG level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for DEBUG. The variants taking\n+     * {@link #debug(String, Object) one} and {@link #debug(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the INFO level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the INFO level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for INFO. The variants taking\n+     * {@link #info(String, Object) one} and {@link #info(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the WARN level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the WARN level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for WARN. The variants taking\n+     * {@link #warn(String, Object) one} and {@link #warn(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the ERROR level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the ERROR level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for ERROR. The variants taking\n+     * {@link #error(String, Object) one} and {@link #error(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void formatAndLog(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * This is our internal implementation for logging regular\n+     * (non-parameterized) log messages.\n+     *\n+     * @param level\n+     *            One of the LOG_LEVEL_XXX constants defining the log level\n+     * @param message\n+     *            The message itself\n+     * @param t\n+     *            The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        StringBuilder buf = new StringBuilder(32);\n+\n+        // Append date-time.\n+        buf.append(getFormattedDate());\n+        buf.append(' ');\n+\n+        // Append current thread name if so configured\n+        buf.append('[');\n+        buf.append(Thread.currentThread().getName());\n+        buf.append(\"] \");\n+\n+\n+        // Append a readable representation of the log level\n+        buf.append('[');\n+        buf.append(level.name());\n+        buf.append(']');\n+        buf.append(' ');\n+\n+        // Append the name of the log instance if so configured\n+        buf.append(classPath).append(\" - \");\n+\n+        // Append the message\n+        buf.append(message);\n+\n+        write(buf, t);\n+    }\n+\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    void write(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            t.printStackTrace(pw);\n+            buf.append(sw.toString());\n+        }\n+        System.out.println(buf.toString());\n+    }\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance. It is currently not supported.\n+     *\n+     * @return name of this logger instance\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the TRACE level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the TRACE level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and argument. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg the argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg1 the first argument\n+     * @param arg2 the second argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the TRACE level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for TRACE. The variants taking {@link #trace(String, Object) one} and\n+     * {@link #trace(String, Object, Object) two} arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param arguments a list of 3 or more arguments\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object... arguments) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log an exception (throwable) at the TRACE level with an\n+     * accompanying message. It is currently not supported.\n+     *\n+     * @param msg the message accompanying the exception\n+     * @param t the exception (throwable) to log\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the DEBUG level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the DEBUG level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and argument. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the DEBUG level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg the argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the DEBUG level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg1 the first argument\n+     * @param arg2 the second argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log an exception (throwable) at the DEBUG level with an\n+     * accompanying message. It is currently not supported.\n+     *\n+     * @param msg the message accompanying the exception\n+     * @param t the exception (throwable) to log\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the INFO level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the INFO level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        throw new UnsupportedOperationException();", "originalCommit": "7cc5822ffbb08042d165667437e5a72e01ad71c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk4MjA5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r364982091", "bodyText": "These should be implemented too.", "author": "srnagar", "createdAt": "2020-01-09T22:03:40Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,559 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the DEBUG level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for DEBUG. The variants taking\n+     * {@link #debug(String, Object) one} and {@link #debug(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void debug(String format, Object... argArray) {\n+        formatAndLog(LogLevel.VERBOSE, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the INFO level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the INFO level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for INFO. The variants taking\n+     * {@link #info(String, Object) one} and {@link #info(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void info(String format, Object... argArray) {\n+        formatAndLog(LogLevel.INFORMATIONAL, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the WARN level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the WARN level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for WARN. The variants taking\n+     * {@link #warn(String, Object) one} and {@link #warn(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void warn(String format, Object... argArray) {\n+        formatAndLog(LogLevel.WARNING, format, argArray);\n+    }\n+\n+    /**\n+     * Log a message at the ERROR level according to the specified format\n+     * and arguments.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the ERROR level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for ERROR. The variants taking\n+     * {@link #error(String, Object) one} and {@link #error(String, Object, Object) two}\n+     * arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param argArray a list of arbitrary arguments\n+     */\n+    public void error(String format, Object... argArray) {\n+        formatAndLog(LogLevel.ERROR, format, argArray);\n+    }\n+\n+    /**\n+     * For formatted messages, first substitute arguments and then log.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void formatAndLog(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * This is our internal implementation for logging regular\n+     * (non-parameterized) log messages.\n+     *\n+     * @param level\n+     *            One of the LOG_LEVEL_XXX constants defining the log level\n+     * @param message\n+     *            The message itself\n+     * @param t\n+     *            The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        StringBuilder buf = new StringBuilder(32);\n+\n+        // Append date-time.\n+        buf.append(getFormattedDate());\n+        buf.append(' ');\n+\n+        // Append current thread name if so configured\n+        buf.append('[');\n+        buf.append(Thread.currentThread().getName());\n+        buf.append(\"] \");\n+\n+\n+        // Append a readable representation of the log level\n+        buf.append('[');\n+        buf.append(level.name());\n+        buf.append(']');\n+        buf.append(' ');\n+\n+        // Append the name of the log instance if so configured\n+        buf.append(classPath).append(\" - \");\n+\n+        // Append the message\n+        buf.append(message);\n+\n+        write(buf, t);\n+    }\n+\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    void write(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            t.printStackTrace(pw);\n+            buf.append(sw.toString());\n+        }\n+        System.out.println(buf.toString());\n+    }\n+\n+    /**\n+     * Return the name of this <code>Logger</code> instance. It is currently not supported.\n+     *\n+     * @return name of this logger instance\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the TRACE level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the TRACE level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and argument. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg the argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the TRACE level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg1 the first argument\n+     * @param arg2 the second argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the TRACE level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous string concatenation when the logger\n+     * is disabled for the TRACE level. However, this variant incurs the hidden\n+     * (and relatively small) cost of creating an <code>Object[]</code> before invoking the method,\n+     * even if this logger is disabled for TRACE. The variants taking {@link #trace(String, Object) one} and\n+     * {@link #trace(String, Object, Object) two} arguments exist solely in order to avoid this hidden cost.</p>\n+     *\n+     * @param format the format string\n+     * @param arguments a list of 3 or more arguments\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String format, final Object... arguments) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log an exception (throwable) at the TRACE level with an\n+     * accompanying message. It is currently not supported.\n+     *\n+     * @param msg the message accompanying the exception\n+     * @param t the exception (throwable) to log\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void trace(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the DEBUG level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the DEBUG level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and argument. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the DEBUG level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg the argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the DEBUG level according to the specified format\n+     * and arguments. It is currently not supported.\n+     * <p/>\n+     * <p>This form avoids superfluous object creation when the logger\n+     * is disabled for the DEBUG level. </p>\n+     *\n+     * @param format the format string\n+     * @param arg1 the first argument\n+     * @param arg2 the second argument\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log an exception (throwable) at the DEBUG level with an\n+     * accompanying message. It is currently not supported.\n+     *\n+     * @param msg the message accompanying the exception\n+     * @param t the exception (throwable) to log\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void debug(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Is the logger instance enabled for the INFO level? It is currently not supported.\n+     *\n+     * @return True if this Logger is enabled for the INFO level,\n+     * false otherwise.\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Log a message at the INFO level. It is currently not supported.\n+     *\n+     * @param msg the message string to be logged\n+     * @throws UnsupportedOperationException It is currently not supported.\n+     */\n+    @Override\n+    public void info(final String msg) {\n+        throw new UnsupportedOperationException();", "originalCommit": "7cc5822ffbb08042d165667437e5a72e01ad71c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1MDgwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365350806", "bodyText": "Same as above", "author": "sima-zhu", "createdAt": "2020-01-10T17:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk4MjA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA0MjkxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365042913", "bodyText": "Use try-with-resources to ensure the resource is always closed.", "author": "srnagar", "createdAt": "2020-01-10T01:55:48Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void warn(String format, Object... args) {\n+        logFromFormat(LogLevel.WARNING, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void error(String format, Object... args) {\n+        logFromFormat(LogLevel.ERROR, format, args);\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void logFromFormat(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level log level\n+     * @param message The message itself\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        String dateTime = getFormattedDate();\n+        String threadName = Thread.currentThread().getName();\n+        String levelName = level.name();\n+        StringBuilder buf = new StringBuilder(32);\n+        buf.append(String.format(MESSAGE_TEMPLATE, dateTime, threadName, levelName, classPath, message));\n+        writeWithThrowable(buf, t);\n+    }\n+\n+    /**\n+     * Get the current time in Local time zone.\n+     *\n+     * @return The current time in {@code DATE_FORMAT}\n+     */\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    /**\n+     * Write the log message with throwable stack trace if any.\n+     *\n+     * @param buf Take the log messages.\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    void writeWithThrowable(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            t.printStackTrace(pw);\n+            buf.append(sw.toString());\n+            pw.close();", "originalCommit": "3931f3629d26acc965e5903180dd57055645fa67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0NzQwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365347408", "bodyText": "Since StringWriter has no-op close(), I only move pw to try with resource. Thanks for pointing this out!", "author": "sima-zhu", "createdAt": "2020-01-10T17:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA0MjkxMw=="}], "type": "inlineReview"}, {"oid": "ae1e40a83adec2dd113fdb74c38db3d8fee8d43d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae1e40a83adec2dd113fdb74c38db3d8fee8d43d", "message": "Address comments", "committedDate": "2020-01-10T17:30:00Z", "type": "commit"}, {"oid": "ae1e40a83adec2dd113fdb74c38db3d8fee8d43d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae1e40a83adec2dd113fdb74c38db3d8fee8d43d", "message": "Address comments", "committedDate": "2020-01-10T17:30:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NTc5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365355797", "bodyText": "If we have the default logger implement the isDebugEnabled and other similar APIs there would be no need for isFromEnv nor would there need to be any different handling here.", "author": "alzimmermsft", "createdAt": "2020-01-10T17:53:22Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -235,39 +229,47 @@ private void performLogging(LogLevel logLevel, LogLevel environmentLogLevel, boo\n                 // Don't do anything, this state shouldn't be possible.\n                 break;\n         }\n+\n     }\n \n-    /*\n-     * Determines if the environment and logger support logging at the given log level.\n+    /**\n+     * Determines if the app or environment logger support logging at the given log level.\n      *\n      * @param logLevel Logging level for the log message.\n-     * @param environmentLoggingLevel Logging level the environment is set to support.\n      * @return Flag indicating if the environment and logger are configured to support logging at the given log level.\n      */\n-    private boolean canLogAtLevel(LogLevel logLevel, LogLevel environmentLoggingLevel) {\n-        // Do not log if logLevel is null is not set.\n-        if (logLevel == null) {\n-            return false;\n-        }\n+    public boolean canLogAtLevel(LogLevel logLevel) {\n+        LogLevel rootLogLevel = getConfiguredLogLevel();\n+        return canLogAtLevel(logLevel, rootLogLevel);\n+    }\n \n-        // Attempting to log at a level not supported by the environment.\n-        if (logLevel.getLogLevel() < environmentLoggingLevel.getLogLevel()) {\n-            return false;\n-        }\n+    private boolean canLogAtLevel(LogLevel logLevel, LogLevel allowedLogLevel) {\n+        // Attempting to log at a level not supported by the SLF4J configuration or env variable.\n+        return logLevel.getLogLevel() >= allowedLogLevel.getLogLevel();\n+    }\n \n-        // Determine if the logger configuration supports logging at the level.\n-        switch (logLevel) {\n-            case VERBOSE:\n-                return logger.isDebugEnabled();\n-            case INFORMATIONAL:\n-                return logger.isInfoEnabled();\n-            case WARNING:\n-                return logger.isWarnEnabled();\n-            case ERROR:\n-                return logger.isErrorEnabled();\n-            default:\n-                return false;\n+    /**\n+     * Checking the system log with the preference order of slf4j and environment variable.\n+     *\n+     * @return The log level.\n+     */\n+    private LogLevel getConfiguredLogLevel() {\n+        if (isFromEnv) {", "originalCommit": "ae1e40a83adec2dd113fdb74c38db3d8fee8d43d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NjMxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365356317", "bodyText": "The only reason the environment logging level was passed around was to handle the fact that there was a two tiered structure of SLF4J logging level and environment logging level, not that this is being merged a lot of the logic in this class and within HttpLoggingPolicy could be cleaned up.", "author": "alzimmermsft", "createdAt": "2020-01-10T17:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ1OTkzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365459937", "bodyText": "Done.", "author": "sima-zhu", "createdAt": "2020-01-10T22:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NTc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NjYzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365356634", "bodyText": "If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.", "author": "alzimmermsft", "createdAt": "2020-01-10T17:55:33Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,366 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private String classPath;\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void warn(String format, Object... args) {\n+        logFromFormat(LogLevel.WARNING, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void error(String format, Object... args) {\n+        logFromFormat(LogLevel.ERROR, format, args);\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void logFromFormat(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level log level\n+     * @param message The message itself\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        String dateTime = getFormattedDate();\n+        String threadName = Thread.currentThread().getName();\n+        String levelName = level.name();\n+        StringBuilder buf = new StringBuilder(32);\n+        buf.append(String.format(MESSAGE_TEMPLATE, dateTime, threadName, levelName, classPath, message));\n+        writeWithThrowable(buf, t);\n+    }\n+\n+    /**\n+     * Get the current time in Local time zone.\n+     *\n+     * @return The current time in {@code DATE_FORMAT}\n+     */\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    /**\n+     * Write the log message with throwable stack trace if any.\n+     *\n+     * @param buf Take the log messages.\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    void writeWithThrowable(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            try (PrintWriter pw = new PrintWriter(sw)) {\n+                t.printStackTrace(pw);\n+                buf.append(sw.toString());\n+            }\n+        }\n+        System.out.println(buf.toString());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object... arguments) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isWarnEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(final String format, final Object arg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isErrorEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(final String msg) {\n+        throw new UnsupportedOperationException();", "originalCommit": "ae1e40a83adec2dd113fdb74c38db3d8fee8d43d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ1OTU3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365459573", "bodyText": "logger.error(format, args);\n\nThis is the one we used.", "author": "sima-zhu", "createdAt": "2020-01-10T22:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NjYzNA=="}], "type": "inlineReview"}, {"oid": "cd8b2be2b191421c862369779b31bd14124940a6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cd8b2be2b191421c862369779b31bd14124940a6", "message": "Unified logger APIs", "committedDate": "2020-01-10T22:33:17Z", "type": "commit"}, {"oid": "e484e10cf3f19cdec69923af52d09d8770c8f749", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e484e10cf3f19cdec69923af52d09d8770c8f749", "message": "Fixed failed tests", "committedDate": "2020-01-10T23:12:49Z", "type": "commit"}, {"oid": "75bde915b1138ef615bc56ddd5a8307b224545af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/75bde915b1138ef615bc56ddd5a8307b224545af", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into addlogimpl", "committedDate": "2020-01-10T23:24:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzMzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365477338", "bodyText": "This code is common for all is*Enabled() methods. You can extract this out to a method to reduce duplication.", "author": "srnagar", "createdAt": "2020-01-11T00:08:56Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,376 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.VERBOSE.getLogLevel() >= currentLogLevel.getLogLevel();", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NDM4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365944389", "bodyText": "Done.", "author": "sima-zhu", "createdAt": "2020-01-13T17:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzUwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365477505", "bodyText": "Combination of inheritdoc and @param docs don't work correctly. Just use @inheritDoc and skip @param docs.", "author": "srnagar", "createdAt": "2020-01-11T00:10:05Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,376 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.VERBOSE.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object arg) {\n+        logFromFormat(LogLevel.VERBOSE, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.INFORMATIONAL.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object arg) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, arg);\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isWarnEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.WARNING.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object arg) {\n+        logFromFormat(LogLevel.WARNING, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MjQ5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365942498", "bodyText": "Done.", "author": "sima-zhu", "createdAt": "2020-01-13T17:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3Nzk0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365477943", "bodyText": "I don't think you need this anymore.", "author": "srnagar", "createdAt": "2020-01-11T00:12:53Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -36,6 +35,7 @@\n  */\n public class ClientLogger {\n     private final Logger logger;\n+    private final boolean isFromEnv;", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MjUyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365942529", "bodyText": "Done.", "author": "sima-zhu", "createdAt": "2020-01-13T17:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3Nzk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODEyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365478120", "bodyText": "This null check is still required otherwise it will cause a NPE.", "author": "srnagar", "createdAt": "2020-01-11T00:14:10Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -235,27 +236,16 @@ private void performLogging(LogLevel logLevel, LogLevel environmentLogLevel, boo\n                 // Don't do anything, this state shouldn't be possible.\n                 break;\n         }\n+\n     }\n \n-    /*\n-     * Determines if the environment and logger support logging at the given log level.\n+    /**\n+     * Determines if the app or environment logger support logging at the given log level.\n      *\n      * @param logLevel Logging level for the log message.\n-     * @param environmentLoggingLevel Logging level the environment is set to support.\n      * @return Flag indicating if the environment and logger are configured to support logging at the given log level.\n      */\n-    private boolean canLogAtLevel(LogLevel logLevel, LogLevel environmentLoggingLevel) {\n-        // Do not log if logLevel is null is not set.\n-        if (logLevel == null) {", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MjQ1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365942455", "bodyText": "Done.", "author": "sima-zhu", "createdAt": "2020-01-13T17:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMjAyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365932025", "bodyText": "Could this method be removed and all the higher level methods just call into performLogging? This previously existed to abstract a few pieces of logic away from the public API methods which no longer exists based on the changes made in this PR.", "author": "alzimmermsft", "createdAt": "2020-01-13T17:32:27Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -131,11 +143,7 @@ public void error(String format, Object... args) {\n      * @param args Arguments for the message, if an exception is being logged last argument is the throwable.\n      */\n     private void log(LogLevel logLevel, String format, Object... args) {\n-        LogLevel environmentLoggingLevel = getEnvironmentLoggingLevel();\n-\n-        if (canLogAtLevel(logLevel, environmentLoggingLevel)) {\n-            performLogging(logLevel, environmentLoggingLevel, false, format, args);\n-        }\n+        performLogging(logLevel, false, format, args);", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0OTQyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365949426", "bodyText": "Sure.", "author": "sima-zhu", "createdAt": "2020-01-13T18:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMjAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMjQ3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365932476", "bodyText": "Is this being used by anything other than the instantiation in the constructor? If not let's remove it.", "author": "alzimmermsft", "createdAt": "2020-01-13T17:33:25Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -36,6 +35,7 @@\n  */\n public class ClientLogger {\n     private final Logger logger;\n+    private final boolean isFromEnv;", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NDQ1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365944454", "bodyText": "Done.", "author": "sima-zhu", "createdAt": "2020-01-13T17:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMjQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMzE5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365933198", "bodyText": "Should this logic be abstracted into LoggingUtils or as a private static method on this class?", "author": "alzimmermsft", "createdAt": "2020-01-13T17:35:02Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,376 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTgxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365945816", "bodyText": "Have a private helper method in class. Env log level is only needed for default logger, so it is ok to leave it here for current use.", "author": "sima-zhu", "createdAt": "2020-01-13T18:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMzE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNDIxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365934211", "bodyText": "Any reason to instantiate the StringBuilder with an internal capacity of 32? Instead could it be instantiated with a capacity large enough to hold the initial string being written to it?", "author": "alzimmermsft", "createdAt": "2020-01-13T17:37:01Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,376 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.VERBOSE.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object arg) {\n+        logFromFormat(LogLevel.VERBOSE, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.INFORMATIONAL.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object arg) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, arg);\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isWarnEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.WARNING.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object arg) {\n+        logFromFormat(LogLevel.WARNING, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void warn(String format, Object... args) {\n+        logFromFormat(LogLevel.WARNING, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isErrorEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.ERROR.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(String format, Object arg) {\n+        logFromFormat(LogLevel.ERROR, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void error(String format, Object... args) {\n+        logFromFormat(LogLevel.ERROR, format, args);\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void logFromFormat(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level log level\n+     * @param message The message itself\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        String dateTime = getFormattedDate();\n+        String threadName = Thread.currentThread().getName();\n+        String levelName = level.name();\n+        StringBuilder buf = new StringBuilder(32);", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0ODYwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365948606", "bodyText": "It is inherited from simple logger.\nThe message we know definitely will be printed out is:\n2020-01-09 12:35 [main] [Informational]\nThis is 39 character long. I can put 64 instead of 32 characters to minimize capacity increase.", "author": "sima-zhu", "createdAt": "2020-01-13T18:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNDIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNTUxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365935513", "bodyText": "If there is a Throwable to write is there a newline after the message template? Looking at the message template there is no newline inserted between the general log message and the stack trace.", "author": "alzimmermsft", "createdAt": "2020-01-13T17:39:46Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,376 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.VERBOSE.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object arg) {\n+        logFromFormat(LogLevel.VERBOSE, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.INFORMATIONAL.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object arg) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, arg);\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isWarnEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.WARNING.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object arg) {\n+        logFromFormat(LogLevel.WARNING, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void warn(String format, Object... args) {\n+        logFromFormat(LogLevel.WARNING, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isErrorEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.ERROR.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(String format, Object arg) {\n+        logFromFormat(LogLevel.ERROR, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void error(String format, Object... args) {\n+        logFromFormat(LogLevel.ERROR, format, args);\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void logFromFormat(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level log level\n+     * @param message The message itself\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        String dateTime = getFormattedDate();\n+        String threadName = Thread.currentThread().getName();\n+        String levelName = level.name();\n+        StringBuilder buf = new StringBuilder(32);\n+        buf.append(String.format(MESSAGE_TEMPLATE, dateTime, threadName, levelName, classPath, message));\n+        writeWithThrowable(buf, t);", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MDI1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365960255", "bodyText": "Added %n in template.", "author": "sima-zhu", "createdAt": "2020-01-13T18:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNTUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNjA4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365936081", "bodyText": "Could this be made private? Additionally, could we change this method to simple add the stack trace to the log message. Adding the Throwable stack trace and writing the message to the console don't seem like ideas that should be merged eagerly.", "author": "alzimmermsft", "createdAt": "2020-01-13T17:41:00Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,376 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.VERBOSE.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object arg) {\n+        logFromFormat(LogLevel.VERBOSE, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.INFORMATIONAL.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object arg) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, arg);\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isWarnEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.WARNING.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object arg) {\n+        logFromFormat(LogLevel.WARNING, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void warn(String format, Object... args) {\n+        logFromFormat(LogLevel.WARNING, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isErrorEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.ERROR.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(String format, Object arg) {\n+        logFromFormat(LogLevel.ERROR, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void error(String format, Object... args) {\n+        logFromFormat(LogLevel.ERROR, format, args);\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void logFromFormat(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level log level\n+     * @param message The message itself\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        String dateTime = getFormattedDate();\n+        String threadName = Thread.currentThread().getName();\n+        String levelName = level.name();\n+        StringBuilder buf = new StringBuilder(32);\n+        buf.append(String.format(MESSAGE_TEMPLATE, dateTime, threadName, levelName, classPath, message));\n+        writeWithThrowable(buf, t);\n+    }\n+\n+    /**\n+     * Get the current time in Local time zone.\n+     *\n+     * @return The current time in {@code DATE_FORMAT}\n+     */\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    /**\n+     * Write the log message with throwable stack trace if any.\n+     *\n+     * @param buf Take the log messages.\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    void writeWithThrowable(StringBuilder buf, Throwable t) {", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MDEzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365960133", "bodyText": "Talked offline.", "author": "sima-zhu", "createdAt": "2020-01-13T18:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNjA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNjU3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365936570", "bodyText": "One of the SDK guidelines it to only print an exception's stack trace when logging is set to verbose. In ClientLogger it was set to only log the exception message at a different level.", "author": "alzimmermsft", "createdAt": "2020-01-13T17:41:57Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,376 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.VERBOSE.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object arg) {\n+        logFromFormat(LogLevel.VERBOSE, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.INFORMATIONAL.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object arg) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, arg);\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isWarnEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.WARNING.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object arg) {\n+        logFromFormat(LogLevel.WARNING, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void warn(String format, Object... args) {\n+        logFromFormat(LogLevel.WARNING, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isErrorEnabled() {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return LogLevel.ERROR.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(String format, Object arg) {\n+        logFromFormat(LogLevel.ERROR, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param format The formattable message to log.\n+     * @param args Arguments for the message. If an exception is being logged, the last argument should be the\n+     *     {@link Throwable}.\n+     */\n+    @Override\n+    public void error(String format, Object... args) {\n+        logFromFormat(LogLevel.ERROR, format, args);\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void logFromFormat(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level log level\n+     * @param message The message itself\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        String dateTime = getFormattedDate();\n+        String threadName = Thread.currentThread().getName();\n+        String levelName = level.name();\n+        StringBuilder buf = new StringBuilder(32);\n+        buf.append(String.format(MESSAGE_TEMPLATE, dateTime, threadName, levelName, classPath, message));\n+        writeWithThrowable(buf, t);\n+    }\n+\n+    /**\n+     * Get the current time in Local time zone.\n+     *\n+     * @return The current time in {@code DATE_FORMAT}\n+     */\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    /**\n+     * Write the log message with throwable stack trace if any.\n+     *\n+     * @param buf Take the log messages.\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    void writeWithThrowable(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            try (PrintWriter pw = new PrintWriter(sw)) {\n+                t.printStackTrace(pw);\n+                buf.append(sw.toString());\n+            }", "originalCommit": "e484e10cf3f19cdec69923af52d09d8770c8f749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MDM4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365960384", "bodyText": "Talked offline.", "author": "sima-zhu", "createdAt": "2020-01-13T18:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNjU3MA=="}], "type": "inlineReview"}, {"oid": "f3673e218b3716acf0b80bf3c1f4ac1d299c3392", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f3673e218b3716acf0b80bf3c1f4ac1d299c3392", "message": "Addressed comments", "committedDate": "2020-01-13T18:35:33Z", "type": "commit"}, {"oid": "5f0f82b979e0430582ee20c3a2c785e0817ba3ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5f0f82b979e0430582ee20c3a2c785e0817ba3ab", "message": "Some more changes", "committedDate": "2020-01-13T18:38:08Z", "type": "commit"}, {"oid": "f1a75a79fdc6d4885742bcc1c729f675a6b8f339", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f1a75a79fdc6d4885742bcc1c729f675a6b8f339", "message": "Remove some extra methods", "committedDate": "2020-01-13T18:40:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2NDUyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r365964523", "bodyText": "This line can now be removed as DefaultLoggerBase does not exist.", "author": "srnagar", "createdAt": "2020-01-13T18:43:18Z", "path": "eng/code-quality-reports/src/main/resources/checkstyle/checkstyle-suppressions.xml", "diffHunk": "@@ -184,8 +185,10 @@\n   <!-- CodeSnippet Suppression for now, which need code owner's attention -->\n   <suppress checks=\"com.azure.tools.checkstyle.checks.JavadocCodeSnippetCheck\" files=\"com.azure.data.appconfiguration.ConfigurationAsyncClient.java\"/>\n \n-  <!-- ClientLogger class suppression -->\n+  <!-- Logger class suppression -->\n   <suppress checks=\"com.azure.tools.checkstyle.checks.GoodLoggingCheck\" files=\"ClientLogger.java\"/>\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.GoodLoggingCheck\" files=\"DefaultLogger.java\"/>\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.GoodLoggingCheck\" files=\"DefaultLoggerBase.java\"/>", "originalCommit": "5f0f82b979e0430582ee20c3a2c785e0817ba3ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "343ab84379d86a2ee8715b763c46034a4e1dd8a4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/343ab84379d86a2ee8715b763c46034a4e1dd8a4", "message": "Remove redundant checkstyle suppression", "committedDate": "2020-01-13T18:52:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA3ODkwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r366078906", "bodyText": "nit: extra two lines", "author": "mssfang", "createdAt": "2020-01-13T23:13:35Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s%n\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        return isLogLevelEnabledFromEnv(LogLevel.VERBOSE);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object arg) {\n+        logFromFormat(LogLevel.VERBOSE, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        return isLogLevelEnabledFromEnv(LogLevel.INFORMATIONAL);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object arg) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, arg);\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isWarnEnabled() {\n+        return isLogLevelEnabledFromEnv(LogLevel.WARNING);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object arg) {\n+        logFromFormat(LogLevel.WARNING, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object... args) {\n+        logFromFormat(LogLevel.WARNING, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isErrorEnabled() {\n+        return isLogLevelEnabledFromEnv(LogLevel.ERROR);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(String format, Object arg) {\n+        logFromFormat(LogLevel.ERROR, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(String format, Object... args) {\n+        logFromFormat(LogLevel.ERROR, format, args);\n+    }\n+\n+    private boolean isLogLevelEnabledFromEnv(LogLevel logLevel) {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return logLevel.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void logFromFormat(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level log level\n+     * @param message The message itself\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        String dateTime = getFormattedDate();\n+        String threadName = Thread.currentThread().getName();\n+        String levelName = level.name();\n+        StringBuilder buf = new StringBuilder(64);\n+        buf.append(String.format(MESSAGE_TEMPLATE, dateTime, threadName, levelName, classPath, message));\n+        writeWithThrowable(buf, t);\n+    }\n+\n+    /**\n+     * Get the current time in Local time zone.\n+     *\n+     * @return The current time in {@code DATE_FORMAT}\n+     */\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    /**\n+     * Write the log message with throwable stack trace if any.\n+     *\n+     * @param buf Take the log messages.\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    void writeWithThrowable(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            try (PrintWriter pw = new PrintWriter(sw)) {\n+                t.printStackTrace(pw);\n+                buf.append(sw.toString());\n+            }\n+        }\n+        System.out.println(buf.toString());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object... arguments) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(final String msg, final Throwable t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+", "originalCommit": "343ab84379d86a2ee8715b763c46034a4e1dd8a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "49be4b3aa48f0b513ba8ab9e394b2c7718198d75", "url": "https://github.com/Azure/azure-sdk-for-java/commit/49be4b3aa48f0b513ba8ab9e394b2c7718198d75", "message": "Update DefaultLogger.java", "committedDate": "2020-01-14T00:19:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzOTk1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r366539954", "bodyText": "Why overload all of these methods to throw an exception when the base class has an actual useful implementation? Look at https://github.com/qos-ch/slf4j/blob/master/slf4j-api/src/main/java/org/slf4j/helpers/MarkerIgnoringBase.java", "author": "JonathanGiles", "createdAt": "2020-01-14T19:50:32Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,365 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s%n\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.\n+     */\n+    public DefaultLogger(String className) {\n+        try {\n+            this.classPath = Class.forName(className).getCanonicalName();\n+        } catch (ClassNotFoundException e) {\n+            this.classPath = className;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isDebugEnabled() {\n+        return isLogLevelEnabledFromEnv(LogLevel.VERBOSE);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object arg) {\n+        logFromFormat(LogLevel.VERBOSE, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void debug(String format, Object... args) {\n+        logFromFormat(LogLevel.VERBOSE, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isInfoEnabled() {\n+        return isLogLevelEnabledFromEnv(LogLevel.INFORMATIONAL);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object arg) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, arg);\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void info(String format, Object... args) {\n+        logFromFormat(LogLevel.INFORMATIONAL, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isWarnEnabled() {\n+        return isLogLevelEnabledFromEnv(LogLevel.WARNING);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object arg) {\n+        logFromFormat(LogLevel.WARNING, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void warn(String format, Object... args) {\n+        logFromFormat(LogLevel.WARNING, format, args);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isErrorEnabled() {\n+        return isLogLevelEnabledFromEnv(LogLevel.ERROR);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(String format, Object arg) {\n+        logFromFormat(LogLevel.ERROR, format, arg);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void error(String format, Object... args) {\n+        logFromFormat(LogLevel.ERROR, format, args);\n+    }\n+\n+    private boolean isLogLevelEnabledFromEnv(LogLevel logLevel) {\n+        String logLevelStr = Configuration.getGlobalConfiguration().get(AZURE_LOG_LEVEL);\n+        LogLevel currentLogLevel = LogLevel.fromString(logLevelStr);\n+        return logLevel.getLogLevel() >= currentLogLevel.getLogLevel();\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level The level to log.\n+     * @param format The log message format.\n+     * @param arguments a list of arbitrary arguments taken in by format.\n+     */\n+    private void logFromFormat(LogLevel level, String format, Object... arguments) {\n+        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n+        log(level, tp.getMessage(), tp.getThrowable());\n+    }\n+\n+    /**\n+     * Format and write the message according to the {@code MESSAGE_TEMPLATE}.\n+     *\n+     * @param level log level\n+     * @param message The message itself\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    private void log(LogLevel level, String message, Throwable t) {\n+        String dateTime = getFormattedDate();\n+        String threadName = Thread.currentThread().getName();\n+        String levelName = level.name();\n+        StringBuilder buf = new StringBuilder(64);\n+        buf.append(String.format(MESSAGE_TEMPLATE, dateTime, threadName, levelName, classPath, message));\n+        writeWithThrowable(buf, t);\n+    }\n+\n+    /**\n+     * Get the current time in Local time zone.\n+     *\n+     * @return The current time in {@code DATE_FORMAT}\n+     */\n+    private String getFormattedDate() {\n+        LocalDateTime now = LocalDateTime.now();\n+        return DATE_FORMAT.format(now);\n+    }\n+\n+    /**\n+     * Write the log message with throwable stack trace if any.\n+     *\n+     * @param buf Take the log messages.\n+     * @param t The exception whose stack trace should be logged\n+     */\n+    void writeWithThrowable(StringBuilder buf, Throwable t) {\n+        if (t != null) {\n+            StringWriter sw = new StringWriter();\n+            try (PrintWriter pw = new PrintWriter(sw)) {\n+                t.printStackTrace(pw);\n+                buf.append(sw.toString());\n+            }\n+        }\n+        System.out.println(buf.toString());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String getName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isTraceEnabled() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String msg) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object arg1, final Object arg2) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String format, final Object... arguments) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void trace(final String msg, final Throwable t) {", "originalCommit": "49be4b3aa48f0b513ba8ab9e394b2c7718198d75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNjA3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r366606077", "bodyText": "Done", "author": "sima-zhu", "createdAt": "2020-01-14T22:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzOTk1NA=="}], "type": "inlineReview"}, {"oid": "7258f7652051a46ce0fc893073ac0003b6c3c2b4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7258f7652051a46ce0fc893073ac0003b6c3c2b4", "message": "Implements all APIs", "committedDate": "2020-01-14T21:02:52Z", "type": "commit"}, {"oid": "7145d10be49bc8cedcb343e394aa6d7293c514d8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7145d10be49bc8cedcb343e394aa6d7293c514d8", "message": "Merge branch 'addlogimpl' of https://github.com/sima-zhu/azure-sdk-for-java into addlogimpl", "committedDate": "2020-01-14T21:03:12Z", "type": "commit"}, {"oid": "a0e582c142c33515dd575a264ff7a3716ddf842c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a0e582c142c33515dd575a264ff7a3716ddf842c", "message": "Fixed linting issue", "committedDate": "2020-01-14T21:17:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NzAzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r367077037", "bodyText": "Will this throw an exception now that you have a catch block?", "author": "srnagar", "createdAt": "2020-01-15T19:56:48Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/implementation/logging/DefaultLogger.java", "diffHunk": "@@ -0,0 +1,362 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.implementation.logging;\n+\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.LogLevel;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import org.slf4j.helpers.FormattingTuple;\n+import org.slf4j.helpers.MarkerIgnoringBase;\n+import org.slf4j.helpers.MessageFormatter;\n+\n+/**\n+ * This class is an internal implementation of slf4j logger.\n+ */\n+public final class DefaultLogger extends MarkerIgnoringBase {\n+    private static final long serialVersionUID = -144261058636441630L;\n+\n+    private static final String AZURE_LOG_LEVEL = \"AZURE_LOG_LEVEL\";\n+    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n+\n+    // The template forms the log message in a format:\n+    // YYYY-MM-DD HH:MM [thread] [level] classpath - message\n+    // E.g: 2020-01-09 12:35 [main] [WARNING] com.azure.core.DefaultLogger - This is my log message.\n+    private static final String MESSAGE_TEMPLATE = \"%s [%s] [%s] %s - %s%n\";\n+\n+    private String classPath;\n+\n+    /**\n+     * Construct DefaultLogger for the given class.\n+     *\n+     * @param clazz Class creating the logger.\n+     */\n+    public DefaultLogger(Class<?> clazz) {\n+        this(clazz.getName());\n+    }\n+\n+    /**\n+     * Construct DefaultLogger for the given class name.\n+     *\n+     * @param className Class name creating the logger.\n+     * @throws RuntimeException it is an error.", "originalCommit": "a0e582c142c33515dd575a264ff7a3716ddf842c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MTIwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r367091202", "bodyText": "Not logger throw an exception. Good catch. Will update the JavaDoc", "author": "sima-zhu", "createdAt": "2020-01-15T20:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NzAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NzQwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r367077408", "bodyText": "Now that all methods are implemented in DefaultLogger this exception is no longer required.", "author": "srnagar", "createdAt": "2020-01-15T19:57:39Z", "path": "eng/code-quality-reports/src/main/resources/checkstyle/checkstyle-suppressions.xml", "diffHunk": "@@ -153,6 +153,7 @@\n \n   <!-- Any code in any package, it should never be a 'throw' keyword in the client library codebase except for in the client logger -->\n   <suppress checks=\"com.azure.tools.checkstyle.checks.ThrowFromClientLoggerCheck\" files=\".*[/\\\\]com[/\\\\]azure[/\\\\]core[/\\\\]util[/\\\\]logging[/\\\\]*\"/>\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.ThrowFromClientLoggerCheck\" files=\".*[/\\\\]com[/\\\\]azure[/\\\\]core[/\\\\]implementation[/\\\\]logging[/\\\\]*\"/>", "originalCommit": "a0e582c142c33515dd575a264ff7a3716ddf842c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "68085b4993a16d8ff9a4f10212272b4db113b477", "url": "https://github.com/Azure/azure-sdk-for-java/commit/68085b4993a16d8ff9a4f10212272b4db113b477", "message": "Address feedback", "committedDate": "2020-01-15T20:43:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5ODQ4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7298#discussion_r367398481", "bodyText": "Is this an error message?", "author": "mssfang", "createdAt": "2020-01-16T12:47:56Z", "path": "sdk/core/azure-core/src/test/java/com/azure/core/util/logging/ClientLoggerTests.java", "diffHunk": "@@ -144,7 +133,7 @@ public void onlyLogExceptionMessage() {\n      */\n     @Test\n     public void logExceptionStackTrace() {\n-        String logMessage = \"This is an exception\";\n+        String logMessage = \"This is an exception fdsafdafdomcklamfd fdsafdafmlkdfmalsf fdsafdcacdalmd\";", "originalCommit": "68085b4993a16d8ff9a4f10212272b4db113b477", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}