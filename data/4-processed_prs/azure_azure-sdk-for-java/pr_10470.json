{"pr_number": 10470, "pr_title": "Add InputStream to Flux<ByteBuffer> Utility Method", "pr_createdAt": "2020-04-23T22:17:44Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10470", "timeline": [{"oid": "32ed4959a2b839e9f5d94e49d4e7045fb0021b93", "url": "https://github.com/Azure/azure-sdk-for-java/commit/32ed4959a2b839e9f5d94e49d4e7045fb0021b93", "message": "Add toFluxByteBuffer to FluxUtil that converts an InputStream to a Flux<ByteBuffer>", "committedDate": "2020-04-23T22:08:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5NzY1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414197658", "bodyText": "Should we document that the caller is responsible for closing the provided stream? (if the user provides the produced Flux to our async API then they should dispose it once async API completes)", "author": "anuchandy", "createdAt": "2020-04-23T23:47:42Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/FluxUtil.java", "diffHunk": "@@ -83,6 +84,74 @@ private static void accept(ByteArrayOutputStream byteOutputStream, ByteBuffer by\n         return byteArray;\n     }\n \n+    /**\n+     * Converts an {@link InputStream} into a {@link Flux} of {@link ByteBuffer} using a chunk size of 4096.\n+     * <p>\n+     * Given that {@link InputStream} is not guaranteed to be replayable the returned {@link Flux} should be considered\n+     * non-replayable as well.\n+     * <p>\n+     * If the passed {@link InputStream} is {@code null} {@link Flux#empty()} will be returned.\n+     *\n+     * @param inputStream The {@link InputStream} to convert into a {@link Flux}.\n+     * @return A {@link Flux} of {@link ByteBuffer ByteBuffers} that contains the contents of the stream.\n+     */\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {\n+        return toFluxByteBuffer(inputStream, 4096);\n+    }\n+\n+    /**\n+     * Converts an {@link InputStream} into a {@link Flux} of {@link ByteBuffer}.\n+     * <p>\n+     * Given that {@link InputStream} is not guaranteed to be replayable the returned {@link Flux} should be considered\n+     * non-replayable as well.\n+     * <p>", "originalCommit": "32ed4959a2b839e9f5d94e49d4e7045fb0021b93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIwMDI4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414200282", "bodyText": "Good question, I don't think in any other location where we are converting an InputStream into a Flux<ByteBuffer> we close the stream.", "author": "alzimmermsft", "createdAt": "2020-04-23T23:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIwNTUzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414205538", "bodyText": "yes, the Flux.generate is not closing stream and it shouldn't. I mean consumer of this API is in charge of dealing with it.\nInputStream is = // open-file\nFormRecognizer.someAsyncAPI(FluxUtils.toByteBufferFlux(is))\n    .doFinally(s -> {\n       is.close();\n    }).block();", "author": "anuchandy", "createdAt": "2020-04-24T00:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIwNzY5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414207691", "bodyText": "The lifecyle of the inputstream should be managed by the user. They might decide to reset and reuse the inputstream if they want to. So, we shouldn't be closing user provided stream.", "author": "srnagar", "createdAt": "2020-04-24T00:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxNDk1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414214953", "bodyText": "yes.\nAlso, any thoughts on the replayability of such Fluxes?  I see this https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#markSupported() API to check the stream can be marked and reset. Not sure how feasible it with File streams.\nIn FR APIs we do two subscriptions - one for contentType detection and another one when sending the content. The sync API takes InputStream from the user, convert that to Flux and call async API, so those APIs won't work as expected.", "author": "anuchandy", "createdAt": "2020-04-24T00:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MDM1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414770351", "bodyText": "@anuchandy I think it would be safer for the FormRecognizer API to not subscribe twice in case the Flux being sent isn't replayable, this goes back to the problem where we need to assume Flux isn't replayable since treating as non-replayable will work for replayable but not the other way around.", "author": "alzimmermsft", "createdAt": "2020-04-24T18:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3OTY4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414779689", "bodyText": "I thought, in general, our SDKs assume Flux is \"replayable\" :), otherwise, retry is not going to work (retry requires multi-subscription). Storage is a special case where they are committed to supporting \"non-replyable\" Flux, that makes sense because of server-side chunk support.\nWe had some discussion on the same topic, in this thread #9953 (comment)", "author": "anuchandy", "createdAt": "2020-04-24T18:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5NzY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIwODYzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414208638", "bodyText": "A method returning a reactive publisher shouldn't throw exceptions. It makes chaining of reactive operators difficult as the caller will have to handle errors in 2 ways. Return Flux.error() instead.", "author": "srnagar", "createdAt": "2020-04-24T00:18:36Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/FluxUtil.java", "diffHunk": "@@ -83,6 +84,74 @@ private static void accept(ByteArrayOutputStream byteOutputStream, ByteBuffer by\n         return byteArray;\n     }\n \n+    /**\n+     * Converts an {@link InputStream} into a {@link Flux} of {@link ByteBuffer} using a chunk size of 4096.\n+     * <p>\n+     * Given that {@link InputStream} is not guaranteed to be replayable the returned {@link Flux} should be considered\n+     * non-replayable as well.\n+     * <p>\n+     * If the passed {@link InputStream} is {@code null} {@link Flux#empty()} will be returned.\n+     *\n+     * @param inputStream The {@link InputStream} to convert into a {@link Flux}.\n+     * @return A {@link Flux} of {@link ByteBuffer ByteBuffers} that contains the contents of the stream.\n+     */\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {\n+        return toFluxByteBuffer(inputStream, 4096);\n+    }\n+\n+    /**\n+     * Converts an {@link InputStream} into a {@link Flux} of {@link ByteBuffer}.\n+     * <p>\n+     * Given that {@link InputStream} is not guaranteed to be replayable the returned {@link Flux} should be considered\n+     * non-replayable as well.\n+     * <p>\n+     * If the passed {@link InputStream} is {@code null} {@link Flux#empty()} will be returned.\n+     *\n+     * @param inputStream The {@link InputStream} to convert into a {@link Flux}.\n+     * @param chunkSize The requested size for each {@link ByteBuffer}.\n+     * @return A {@link Flux} of {@link ByteBuffer ByteBuffers} that contains the contents of the stream.\n+     * @throws IllegalArgumentException If {@code chunkSize} is less than or equal to {@code 0}.\n+     */\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream, int chunkSize) {\n+        if (chunkSize <= 0) {\n+            throw new IllegalArgumentException(\"'chunkSize' must be greater than 0.\");\n+        }", "originalCommit": "32ed4959a2b839e9f5d94e49d4e7045fb0021b93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MDU3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10470#discussion_r414770575", "bodyText": "Changed to Flux.error", "author": "alzimmermsft", "createdAt": "2020-04-24T18:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIwODYzOA=="}], "type": "inlineReview"}, {"oid": "90436f4ea141af32d4785bc91c33c12df021fbe9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/90436f4ea141af32d4785bc91c33c12df021fbe9", "message": "Merge branch 'master' into AzCore_AddInputStreamToFluxUtilityMethod", "committedDate": "2020-04-24T18:03:26Z", "type": "commit"}, {"oid": "d6fb2ebbf8bb15e8f829d2df82fc33cc60589567", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d6fb2ebbf8bb15e8f829d2df82fc33cc60589567", "message": "Fix linting issue and changed exception throw to return Flux.error", "committedDate": "2020-04-24T18:08:45Z", "type": "commit"}, {"oid": "d6139e96ad1a2b17588d4e234570eddf64021e3b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d6139e96ad1a2b17588d4e234570eddf64021e3b", "message": "Infinite for loop -> infite while loop", "committedDate": "2020-04-24T18:28:52Z", "type": "commit"}]}