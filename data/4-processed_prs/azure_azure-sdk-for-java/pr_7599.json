{"pr_number": 7599, "pr_title": "Adding PollerFlux::create to support ActivationOp variant that returns PollResponse", "pr_createdAt": "2020-01-22T02:46:49Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/7599", "timeline": [{"oid": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2", "message": "Adding PollerFlux::create to support ActivationOp variant that returns PollResponse", "committedDate": "2020-01-22T02:44:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NTMwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r370295305", "bodyText": "nit: rename this to activationOperationWithResponse to make it clear that this is different from activationOperation which doesn't have the PollResponse.", "author": "srnagar", "createdAt": "2020-01-23T18:54:25Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -89,17 +90,94 @@ public PollerFlux(Duration defaultPollInterval,\n         this.defaultPollInterval = defaultPollInterval;\n         this.activationOperation = Objects.requireNonNull(activationOperation,\n             \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        this.activationOperationEx = null;\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = oneTimeActivationMono();\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, response holds the result. The PollerFlux created from constructor uses\n+     * an activationOperation which returns a Mono that directly emits result. Since the first variant of\n+     * PollerFlux has access to the response, it can skip the polling loop if the response indicate that\n+     * LRO is completed. Whereas the second PollerFlux variant calls pollFunction at least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n+     *                      is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n+     *                        if service supports cancellation, this parameter is required and if service does not\n+     *                        support cancellation then the implementer should return Mono.error with an error message\n+     *                        indicating absence of cancellation support, the operation will be called with current\n+     *                        {@link PollingContext}.\n+     * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n+     *                             the long-running operation if service support it, this parameter is required and\n+     *                             operation will be called current {@link PollingContext}, if service does not have an\n+     *                             api to fetch final result and if final result is same as final poll response value\n+     *                             then implementer can choose to simply return value from provided final poll response.\n+     *\n+     * @param <T> The type of poll response value.\n+     * @param <U> The type of the final result of long-running operation.\n+     * @return PollerFlux\n+     */\n+    public static <T, U> PollerFlux<T, U>\n+        create(Duration defaultPollInterval,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+               BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+               Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n+        return new PollerFlux<>(defaultPollInterval,\n+            activationOperation,\n+            pollOperation,\n+            cancelOperation,\n+            fetchResultOperation,\n+            true);\n+    }\n+\n+    private PollerFlux(Duration defaultPollInterval,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+                       BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+                       Function<PollingContext<T>, Mono<U>> fetchResultOperation,\n+                       boolean ignored) {\n+        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n+        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\n+                \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n+        }\n+        this.defaultPollInterval = defaultPollInterval;\n+        this.activationOperation = null;\n+        this.activationOperationEx = Objects.requireNonNull(activationOperation,", "originalCommit": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg1NDExOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r370854118", "bodyText": "I'm trying to get rid of storing activationOperation in class level, just updated the code to move all activation logic to its own inner class.", "author": "anuchandy", "createdAt": "2020-01-24T21:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NTMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NjcwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r370296706", "bodyText": "Would be good to add a unit test case for this change.", "author": "srnagar", "createdAt": "2020-01-23T18:57:30Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -89,17 +90,94 @@ public PollerFlux(Duration defaultPollInterval,\n         this.defaultPollInterval = defaultPollInterval;\n         this.activationOperation = Objects.requireNonNull(activationOperation,\n             \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        this.activationOperationEx = null;\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = oneTimeActivationMono();\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, response holds the result. The PollerFlux created from constructor uses\n+     * an activationOperation which returns a Mono that directly emits result. Since the first variant of\n+     * PollerFlux has access to the response, it can skip the polling loop if the response indicate that\n+     * LRO is completed. Whereas the second PollerFlux variant calls pollFunction at least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n+     *                      is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n+     *                        if service supports cancellation, this parameter is required and if service does not\n+     *                        support cancellation then the implementer should return Mono.error with an error message\n+     *                        indicating absence of cancellation support, the operation will be called with current\n+     *                        {@link PollingContext}.\n+     * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n+     *                             the long-running operation if service support it, this parameter is required and\n+     *                             operation will be called current {@link PollingContext}, if service does not have an\n+     *                             api to fetch final result and if final result is same as final poll response value\n+     *                             then implementer can choose to simply return value from provided final poll response.\n+     *\n+     * @param <T> The type of poll response value.\n+     * @param <U> The type of the final result of long-running operation.\n+     * @return PollerFlux\n+     */\n+    public static <T, U> PollerFlux<T, U>\n+        create(Duration defaultPollInterval,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+               BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+               Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n+        return new PollerFlux<>(defaultPollInterval,\n+            activationOperation,\n+            pollOperation,\n+            cancelOperation,\n+            fetchResultOperation,\n+            true);\n+    }\n+\n+    private PollerFlux(Duration defaultPollInterval,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+                       BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+                       Function<PollingContext<T>, Mono<U>> fetchResultOperation,\n+                       boolean ignored) {\n+        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n+        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\n+                \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n+        }\n+        this.defaultPollInterval = defaultPollInterval;\n+        this.activationOperation = null;\n+        this.activationOperationEx = Objects.requireNonNull(activationOperation,\n+            \"'activationOperation' cannot be null.\");\n+        this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n+        this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n+        this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n+            \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = oneTimeActivationMono();\n     }\n \n     @Override\n     public void subscribe(CoreSubscriber<? super AsyncPollResponse<T, U>> actual) {\n         this.oneTimeActivationMono\n-            .flatMapMany(ignored -> pollingLoop())\n+            .flatMapMany(ignored -> {", "originalCommit": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NzkxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r370867917", "bodyText": "tests added", "author": "anuchandy", "createdAt": "2020-01-24T22:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NjcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NzI5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r370297297", "bodyText": "same here - maybe name this as isActivationWithResponse", "author": "srnagar", "createdAt": "2020-01-23T18:58:39Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -129,34 +207,43 @@ public void subscribe(CoreSubscriber<? super AsyncPollResponse<T, U>> actual) {\n      * The decorated Mono also handles concurrent calls to activation. Only one of them will be able to call\n      * activation and other subscriptions will keep resubscribing until it sees a activation happened or get a chance\n      * to call activation as the one previously entered the critical section got an error on activation.\n-     *\n-     * @param activationOperation a supplier that provide a Mono upon subscription execute activation operation.\n+\n      * @return a one time activation mono\n      */\n-    private Mono<Boolean> oneTimeActivationMono(final Function<PollingContext<T>, Mono<T>> activationOperation) {\n+    @SuppressWarnings(\"unchecked\")\n+    private Mono<Boolean> oneTimeActivationMono() {\n         return Mono.defer(() -> {\n             if (this.activated) {\n                 return Mono.just(true);\n             }\n             if (this.guardActivationCall.compareAndSet(this, 0, 1)) {\n-                final Mono<T> activationMono;\n+                final boolean isEx = this.activationOperationEx != null;", "originalCommit": "3bc39d4173f4baf9fc57a44552bc7c4b9bd8f0f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "276cc411e8327da3b8a2916e3193d12311e3655c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/276cc411e8327da3b8a2916e3193d12311e3655c", "message": "Merge branch 'master' of github.com:azure/azure-sdk-for-java into poller-lro-init", "committedDate": "2020-01-24T15:40:30Z", "type": "commit"}, {"oid": "d1db603ffb0e37a5115706307d829ea448f051ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d1db603ffb0e37a5115706307d829ea448f051ca", "message": "PollerFlux: Simplifying one-time-activation logic", "committedDate": "2020-01-24T21:15:33Z", "type": "commit"}, {"oid": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b73748b66cc8c5c62a78b1874f01347ef7a70a53", "message": "PollerTests: adding tests for PollerFlux::create factory method", "committedDate": "2020-01-24T22:19:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxNzYwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371517601", "bodyText": "Can you please improve this wording - I'm not entirely sure what it means.", "author": "JonathanGiles", "createdAt": "2020-01-27T22:26:02Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -38,10 +38,7 @@\n      * Creates DefaultSyncPoller.\n      *\n      * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param syncActivationOperation the activation function upon call synchronously execute the activation operation.", "originalCommit": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxODI5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371518292", "bodyText": "If you're meaning to contrast this method against the constructor, be more explicit. \"This create method differs from the PollerFlux constructor in that the constructor uses an ....\"", "author": "JonathanGiles", "createdAt": "2020-01-27T22:27:47Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.", "originalCommit": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxODQ5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371518498", "bodyText": "Avoid acronyms, e.g, \"that the long-running operation\"", "author": "JonathanGiles", "createdAt": "2020-01-27T22:28:20Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at", "originalCommit": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxODg4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371518882", "bodyText": "Similarly, I'm not entirely clear what you mean by 'first variant' and 'second variant'. Try to be more explicit to avoid any confusion.", "author": "JonathanGiles", "createdAt": "2020-01-27T22:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxODQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxOTE4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371519180", "bodyText": "Don't worry about this kind of indentation - checkstyle should be warning against this too - please check if checkstyle passes.", "author": "JonathanGiles", "createdAt": "2020-01-27T22:29:55Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at\n+     * least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.", "originalCommit": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxOTM3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371519377", "bodyText": "This is a very long, single sentence. Break it down into a few sentences.", "author": "JonathanGiles", "createdAt": "2020-01-27T22:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxOTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MDgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371560819", "bodyText": "Is it necessary to do this blocking operation in PollerFlux if the sync poller is not going to be used? It might be better to move this to SyncPoller.", "author": "srnagar", "createdAt": "2020-01-28T00:43:46Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());", "originalCommit": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3MjgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371572819", "bodyText": "We don't block in the PollerFlux constructor/factory. We are creating  function that get passed to SyncPoller and it's gets blocked when called from SyncPoller.", "author": "anuchandy", "createdAt": "2020-01-28T01:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MDgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTIwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371561201", "bodyText": "Change name to pollInterval instead as it's not a default and can be customized.", "author": "srnagar", "createdAt": "2020-01-28T00:45:18Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at\n+     * least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n+     *                      is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n+     *                        if service supports cancellation, this parameter is required and if service does not\n+     *                        support cancellation then the implementer should return Mono.error with an error message\n+     *                        indicating absence of cancellation support, the operation will be called with current\n+     *                        {@link PollingContext}.\n+     * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n+     *                             the long-running operation if service support it, this parameter is required and\n+     *                             operation will be called current {@link PollingContext}, if service does not have an\n+     *                             api to fetch final result and if final result is same as final poll response value\n+     *                             then implementer can choose to simply return value from provided final poll response.\n+     *\n+     * @param <T> The type of poll response value.\n+     * @param <U> The type of the final result of long-running operation.\n+     * @return PollerFlux\n+     */\n+    public static <T, U> PollerFlux<T, U>\n+        create(Duration defaultPollInterval,", "originalCommit": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3NDk3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371574974", "bodyText": "Will do", "author": "anuchandy", "createdAt": "2020-01-28T01:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDE0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371564144", "bodyText": "Same here - might be better to defer this blocking operation until it's needed (when getSyncPoller() is called).", "author": "srnagar", "createdAt": "2020-01-28T00:57:00Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -87,19 +82,103 @@ public PollerFlux(Duration defaultPollInterval,\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n         this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.\n+     *\n+     * PollerFlux obtained from this factory method uses an activationOperation which returns a Mono that\n+     * emits {@link PollResponse}, which holds the result.\n+     * The PollerFlux created from constructor uses an activationOperation which returns a Mono that directly\n+     * emits result.\n+     * Since the first variant of PollerFlux has access to the response, it can skip the polling loop if the\n+     * response indicate that LRO is completed. Whereas the second PollerFlux variant calls pollFunction at\n+     * least once.\n+     *\n+     * @param defaultPollInterval the default polling interval\n+     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n+     *                            this parameter is required, if there is no specific activation work to be\n+     *                            done then invocation should return Mono.empty(), this operation will be called\n+     *                            with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n+     *                      is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n+     *                        if service supports cancellation, this parameter is required and if service does not\n+     *                        support cancellation then the implementer should return Mono.error with an error message\n+     *                        indicating absence of cancellation support, the operation will be called with current\n+     *                        {@link PollingContext}.\n+     * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n+     *                             the long-running operation if service support it, this parameter is required and\n+     *                             operation will be called current {@link PollingContext}, if service does not have an\n+     *                             api to fetch final result and if final result is same as final poll response value\n+     *                             then implementer can choose to simply return value from provided final poll response.\n+     *\n+     * @param <T> The type of poll response value.\n+     * @param <U> The type of the final result of long-running operation.\n+     * @return PollerFlux\n+     */\n+    public static <T, U> PollerFlux<T, U>\n+        create(Duration defaultPollInterval,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+               Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+               BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+               Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n+        return new PollerFlux<>(defaultPollInterval,\n+            activationOperation,\n+            pollOperation,\n+            cancelOperation,\n+            fetchResultOperation,\n+            true);\n+    }\n+\n+    private PollerFlux(Duration defaultPollInterval,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> activationOperation,\n+                       Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n+                       BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n+                       Function<PollingContext<T>, Mono<U>> fetchResultOperation,\n+                       boolean ignored) {\n+        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n+        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\n+                \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n+        }\n+        this.defaultPollInterval = defaultPollInterval;\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n+        this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n+        this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n+        this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n+            \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            Function.identity()).getMono();\n+        this.syncActivationOperation = cxt -> activationOperation.apply(cxt).block();", "originalCommit": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3NDE2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371574161", "bodyText": "As mentioned in previous comment, it's function that blocked only when called from SyncPoller\nThe reason for wrapping activationOpertion in Func is, we have two types of activationOperation depending on how user want to create poller - factory vs ctr.", "author": "anuchandy", "createdAt": "2020-01-28T01:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371564862", "bodyText": "Here you can do ctx -> this.activationOperation.apply(ctx).block() instead of eagerly creating syncActivationOperation", "author": "srnagar", "createdAt": "2020-01-28T01:00:05Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -108,61 +187,12 @@ public void subscribe(CoreSubscriber<? super AsyncPollResponse<T, U>> actual) {\n      */\n     public SyncPoller<T, U> getSyncPoller() {\n         return new DefaultSyncPoller<>(this.defaultPollInterval,\n-                this.activationOperation,\n+                this.syncActivationOperation,", "originalCommit": "b73748b66cc8c5c62a78b1874f01347ef7a70a53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3NDc0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371574744", "bodyText": "We could do it in previous version but not anymore since we don't have two class members defined to store variations of activationOperations", "author": "anuchandy", "createdAt": "2020-01-28T01:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3NjUyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371576527", "bodyText": "@srnagar - or we could re-introduces those two member vars and use it for SyncPoller. What do you think?", "author": "anuchandy", "createdAt": "2020-01-28T01:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzOTI5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371639293", "bodyText": "@anuchandy I guess re-introducing two variables will make it less readable. We can leave it as-is for now.", "author": "srnagar", "createdAt": "2020-01-28T07:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk3MTg1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r371971850", "bodyText": "Ok, sounds good.", "author": "anuchandy", "createdAt": "2020-01-28T18:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NDg2Mg=="}], "type": "inlineReview"}, {"oid": "3e154db233567c22e241efbe2fcb241b4d09b21a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3e154db233567c22e241efbe2fcb241b4d09b21a", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into poller-lro-init", "committedDate": "2020-01-30T04:34:44Z", "type": "commit"}, {"oid": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "message": "Improving PollerFlux javadoc and renaming the parameter defaultPollInterval to pollInterval.", "committedDate": "2020-01-30T05:32:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMTkyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373911928", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param <U> The type of the final result of long running operation\n          \n          \n            \n             * @param <U> The type of the final result of the long running operation", "author": "JonathanGiles", "createdAt": "2020-02-03T03:44:31Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -22,7 +22,7 @@\n  * it is possible to be so, e.g. by using volatile and copying context.\n  *\n  * @param <T> The type of poll response value\n- * @param <U> The type of the final result of long-running operation\n+ * @param <U> The type of the final result of long running operation", "originalCommit": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMTk0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373911949", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param pollInterval the polling interval\n          \n          \n            \n                 * @param pollInterval the polling interval.", "author": "JonathanGiles", "createdAt": "2020-02-03T03:44:44Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -37,42 +37,38 @@\n     /**\n      * Creates DefaultSyncPoller.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param pollInterval the polling interval", "originalCommit": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjA2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912066", "bodyText": "This still lacks clarity to me. I don't know, as a user of this API, what exactly I should supply here. In other words, you're telling me how this is used, rather than how I use it.", "author": "JonathanGiles", "createdAt": "2020-02-03T03:45:46Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -37,42 +37,38 @@\n     /**\n      * Creates DefaultSyncPoller.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param pollInterval the polling interval\n+     * @param syncActivationOperation the operation to synchronously activate (start) the long running operation,\n+     *     this operation will be called with a new {@link PollingContext}.", "originalCommit": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjI3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912272", "bodyText": "Break some of these sentences up - in a few places you flow straight into \"this parameter is required\" when a full stop and a new sentence would improve readability.", "author": "JonathanGiles", "createdAt": "2020-02-03T03:47:29Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -37,42 +37,38 @@\n     /**\n      * Creates DefaultSyncPoller.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param pollInterval the polling interval\n+     * @param syncActivationOperation the operation to synchronously activate (start) the long running operation,\n+     *     this operation will be called with a new {@link PollingContext}.\n      * @param pollOperation the operation to poll the current state of long running operation, this parameter\n-     *                      is required and the operation will be called with current {@link PollingContext}.\n-     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n-     *                        if service supports cancellation, this parameter is required and if service does not\n-     *                        support cancellation then the implementer should return Mono.error with an error message\n-     *                        indicating absence of cancellation support, the operation will be called with current\n-     *                        {@link PollingContext}.\n+     *     is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long running operation\n+     *     if service supports cancellation, this parameter is required and if service does not support cancellation", "originalCommit": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjMwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912309", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Objects.requireNonNull(pollInterval, \"'defaultPollInterval' cannot be null.\");\n          \n          \n            \n                    Objects.requireNonNull(pollInterval, \"'pollInterval' cannot be null.\");", "author": "JonathanGiles", "createdAt": "2020-02-03T03:47:48Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java", "diffHunk": "@@ -37,42 +37,38 @@\n     /**\n      * Creates DefaultSyncPoller.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n+     * @param pollInterval the polling interval\n+     * @param syncActivationOperation the operation to synchronously activate (start) the long running operation,\n+     *     this operation will be called with a new {@link PollingContext}.\n      * @param pollOperation the operation to poll the current state of long running operation, this parameter\n-     *                      is required and the operation will be called with current {@link PollingContext}.\n-     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n-     *                        if service supports cancellation, this parameter is required and if service does not\n-     *                        support cancellation then the implementer should return Mono.error with an error message\n-     *                        indicating absence of cancellation support, the operation will be called with current\n-     *                        {@link PollingContext}.\n+     *     is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long running operation\n+     *     if service supports cancellation, this parameter is required and if service does not support cancellation\n+     *     then the implementer should return Mono.error with an error message indicating absence of cancellation\n+     *     support, the operation will be called with current {@link PollingContext}.\n      * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n-     *                             the long-running operation if service support it, this parameter is required and\n-     *                             operation will be called current {@link PollingContext}, if service does not have an\n-     *                             api to fetch final result and if final result is same as final poll response value\n-     *                             then implementer can choose to simply return value from provided final poll response.\n+     *     the long running operation if service support it, this parameter is required and operation will be called\n+     *     current {@link PollingContext}, if service does not have an api to fetch final result and if final result\n+     *     is same as final poll response value then implementer can choose to simply return value from provided\n+     *     final poll response.\n      */\n-    DefaultSyncPoller(Duration defaultPollInterval,\n-                             Function<PollingContext<T>, Mono<T>> activationOperation,\n+    DefaultSyncPoller(Duration pollInterval,\n+                             Function<PollingContext<T>, PollResponse<T>> syncActivationOperation,\n                              Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n                              BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n                              Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n-        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n-        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+        Objects.requireNonNull(pollInterval, \"'defaultPollInterval' cannot be null.\");", "originalCommit": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjQ3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912475", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A subscription to {@link PollerFlux} initiate a long running operation and polls the status\n          \n          \n            \n             * A subscription to {@link PollerFlux} initiates a long running operation and polls the status", "author": "JonathanGiles", "createdAt": "2020-02-03T03:49:00Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -11,13 +11,13 @@\n \n import java.time.Duration;\n import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.BiFunction;\n import java.util.function.Function;\n \n /**\n- * A Flux that simplifies the task of executing long-running operations against an Azure service.\n- * A subscription to {@link PollerFlux} initiate a long-running operation and polls the status\n+ * A Flux that simplifies the task of executing long running operations against an Azure service.\n+ * A subscription to {@link PollerFlux} initiate a long running operation and polls the status", "originalCommit": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMjYyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/7599#discussion_r373912628", "bodyText": "Provide a better first sentence, as this is the most visible text in the JavaDoc.", "author": "JonathanGiles", "createdAt": "2020-02-03T03:50:15Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java", "diffHunk": "@@ -38,68 +38,143 @@\n  * {@codesnippet com.azure.core.util.polling.poller.cancelOperation}\n  *\n  * @param <T> The type of poll response value.\n- * @param <U> The type of the final result of long-running operation.\n+ * @param <U> The type of the final result of long running operation.\n  */\n public final class PollerFlux<T, U> extends Flux<AsyncPollResponse<T, U>> {\n     private final ClientLogger logger = new ClientLogger(PollerFlux.class);\n     private final PollingContext<T> rootContext = new PollingContext<>();\n     private final Duration defaultPollInterval;\n-    private final Function<PollingContext<T>, Mono<T>> activationOperation;\n     private final Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation;\n     private final BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation;\n     private final Function<PollingContext<T>, Mono<U>> fetchResultOperation;\n     private final Mono<Boolean> oneTimeActivationMono;\n-    private volatile boolean activated = false;\n-    private volatile int activationGuardFlag = 0;\n-    @SuppressWarnings({\"rawtypes\"})\n-    private final AtomicIntegerFieldUpdater<PollerFlux> guardActivationCall =\n-        AtomicIntegerFieldUpdater.newUpdater(PollerFlux.class, \"activationGuardFlag\");\n+    private final Function<PollingContext<T>, PollResponse<T>> syncActivationOperation;\n \n     /**\n      * Creates PollerFlux.\n      *\n-     * @param defaultPollInterval the default polling interval\n-     * @param activationOperation the activation operation to be invoked at most once across all subscriptions,\n-     *                            this parameter is required, if there is no specific activation work to be\n-     *                            done then invocation should return Mono.empty(), this operation will be called\n-     *                            with a new {@link PollingContext}.\n-     * @param pollOperation the operation to poll the current state of long running operation, this parameter\n-     *                      is required and the operation will be called with current {@link PollingContext}.\n-     * @param cancelOperation a {@link Function} that represents the operation to cancel the long-running operation\n-     *                        if service supports cancellation, this parameter is required and if service does not\n-     *                        support cancellation then the implementer should return Mono.error with an error message\n-     *                        indicating absence of cancellation support, the operation will be called with current\n-     *                        {@link PollingContext}.\n+     * @param pollInterval the polling interval\n+     * @param activationOperation the activation operation to activate (start) the long running operation.\n+     *     This operation will be invoked at most once across all subscriptions. This parameter is required.\n+     *     If there is no specific activation work to be done then invocation should return Mono.empty(),\n+     *     this operation will be called with a new {@link PollingContext}.\n+     * @param pollOperation the operation to poll the current state of long running operation. This parameter\n+     *     is required and the operation will be called with current {@link PollingContext}.\n+     * @param cancelOperation a {@link Function} that represents the operation to cancel the long running operation\n+     *     if service supports cancellation. This parameter is required. If service does not support cancellation\n+     *     then the implementer should return Mono.error with an error message indicating absence of cancellation\n+     *     support. The operation will be called with current {@link PollingContext}.\n      * @param fetchResultOperation a {@link Function} that represents the  operation to retrieve final result of\n-     *                             the long-running operation if service support it, this parameter is required and\n-     *                             operation will be called current {@link PollingContext}, if service does not have an\n-     *                             api to fetch final result and if final result is same as final poll response value\n-     *                             then implementer can choose to simply return value from provided final poll response.\n+     *     the long running operation if service support it. This parameter is required and operation will be called\n+     *     current {@link PollingContext}. If service does not have an api to fetch final result and if final result\n+     *     is same as final poll response value then implementer can choose to simply return value from provided\n+     *     final poll response.\n      */\n-    public PollerFlux(Duration defaultPollInterval,\n+    public PollerFlux(Duration pollInterval,\n                       Function<PollingContext<T>, Mono<T>> activationOperation,\n                       Function<PollingContext<T>, Mono<PollResponse<T>>> pollOperation,\n                       BiFunction<PollingContext<T>, PollResponse<T>, Mono<T>> cancelOperation,\n                       Function<PollingContext<T>, Mono<U>> fetchResultOperation) {\n-        Objects.requireNonNull(defaultPollInterval, \"'defaultPollInterval' cannot be null.\");\n-        if (defaultPollInterval.compareTo(Duration.ZERO) <= 0) {\n+        Objects.requireNonNull(pollInterval, \"'pollInterval' cannot be null.\");\n+        if (pollInterval.compareTo(Duration.ZERO) <= 0) {\n             throw logger.logExceptionAsWarning(new IllegalArgumentException(\n                 \"Negative or zero value for 'defaultPollInterval' is not allowed.\"));\n         }\n-        this.defaultPollInterval = defaultPollInterval;\n-        this.activationOperation = Objects.requireNonNull(activationOperation,\n-            \"'activationOperation' cannot be null.\");\n-        this.oneTimeActivationMono = oneTimeActivationMono(activationOperation);\n+        this.defaultPollInterval = pollInterval;\n+        Objects.requireNonNull(activationOperation, \"'activationOperation' cannot be null.\");\n         this.pollOperation = Objects.requireNonNull(pollOperation, \"'pollOperation' cannot be null.\");\n         this.cancelOperation = Objects.requireNonNull(cancelOperation, \"'cancelOperation' cannot be null.\");\n         this.fetchResultOperation = Objects.requireNonNull(fetchResultOperation,\n             \"'fetchResultOperation' cannot be null.\");\n+        this.oneTimeActivationMono = new OneTimeActivation<>(this.rootContext,\n+            activationOperation,\n+            // mapper\n+            activationResult -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationResult)).getMono();\n+        this.syncActivationOperation =\n+            cxt -> new PollResponse<>(LongRunningOperationStatus.NOT_STARTED, activationOperation.apply(cxt).block());\n+    }\n+\n+    /**\n+     * Creates PollerFlux.", "originalCommit": "546ed5ebd15b74dd198bb487a1e06086ee5aacd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cf958c6f31a44317f4102978f5b70971ea488365", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cf958c6f31a44317f4102978f5b70971ea488365", "message": "Update sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java\n\nCo-Authored-By: Jonathan Giles <jonathan@jonathangiles.net>", "committedDate": "2020-02-03T04:44:20Z", "type": "commit"}, {"oid": "3846e276483222866322858e84534762d3502991", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3846e276483222866322858e84534762d3502991", "message": "Update sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java\n\nCo-Authored-By: Jonathan Giles <jonathan@jonathangiles.net>", "committedDate": "2020-02-03T04:44:38Z", "type": "commit"}, {"oid": "4377fcb463bb3c0f8a23fc2ca7b728d94cdb4468", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4377fcb463bb3c0f8a23fc2ca7b728d94cdb4468", "message": "Update sdk/core/azure-core/src/main/java/com/azure/core/util/polling/DefaultSyncPoller.java\n\nCo-Authored-By: Jonathan Giles <jonathan@jonathangiles.net>", "committedDate": "2020-02-03T04:44:51Z", "type": "commit"}, {"oid": "0e9e6658f21f02b0b19d9ac300cc99763e301844", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0e9e6658f21f02b0b19d9ac300cc99763e301844", "message": "Update sdk/core/azure-core/src/main/java/com/azure/core/util/polling/PollerFlux.java\n\nCo-Authored-By: Jonathan Giles <jonathan@jonathangiles.net>", "committedDate": "2020-02-03T04:45:03Z", "type": "commit"}]}