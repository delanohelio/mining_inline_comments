{"pr_number": 9988, "pr_title": "[FR] Update for preview 1 design changes", "pr_createdAt": "2020-04-08T23:58:19Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9988", "timeline": [{"oid": "3bda61c5b2a7d388433effb5f53f84c8839ab851", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3bda61c5b2a7d388433effb5f53f84c8839ab851", "message": "checkstyle", "committedDate": "2020-04-09T16:58:34Z", "type": "forcePushed"}, {"oid": "46aa7e0ec19425685d3e4de89d961f22da041dab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/46aa7e0ec19425685d3e4de89d961f22da041dab", "message": "Form Training async client test part 1", "committedDate": "2020-04-09T21:46:37Z", "type": "forcePushed"}, {"oid": "a2e54a36b87338de917245070a0e0bf59d5bca84", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a2e54a36b87338de917245070a0e0bf59d5bca84", "message": "Form Training async client test part 1", "committedDate": "2020-04-09T22:00:10Z", "type": "forcePushed"}, {"oid": "7e6a337594dac2e3e4c7757a9ab869a2fdc07efe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7e6a337594dac2e3e4c7757a9ab869a2fdc07efe", "message": "Form Training async client test part 1", "committedDate": "2020-04-09T22:01:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MDk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406980940", "bodyText": "Something looks off, there is no injected code here", "author": "alzimmermsft", "createdAt": "2020-04-10T23:22:56Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/README.md", "diffHunk": "@@ -119,27 +119,8 @@ FormRecognizerAsyncClient formRecognizerAsyncClient = new FormRecognizerClientBu\n ```\n \n ### Extract receipt information\n-<!-- embedme ./src/samples/java/com/azure/ai/formrecognizer/ReadmeSamples.java#L68-L86 -->\n+<!-- embedme ./src/samples/java/com/azure/ai/formrecognizer/ReadmeSamples.java#L70-86 -->", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MjE3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406982170", "bodyText": "Could setTrainingErrors null check the passed List so we don't need to maintain a new List outside of the scope of the if?", "author": "alzimmermsft", "createdAt": "2020-04-10T23:28:22Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,89 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        com.azure.ai.formrecognizer.implementation.models.ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(new IllegalArgumentException(\"Invalid status Model Id.\"));\n+        }\n+\n+        List<FormRecognizerError> trainResultErrors = new ArrayList<>();\n+        if (modelResponse.getTrainResult().getErrors() != null) {\n+            trainResultErrors = setTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MjM3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406982373", "bodyText": "Thoughts on using a stream to map the List?", "author": "alzimmermsft", "createdAt": "2020-04-10T23:29:11Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,89 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        com.azure.ai.formrecognizer.implementation.models.ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(new IllegalArgumentException(\"Invalid status Model Id.\"));\n+        }\n+\n+        List<FormRecognizerError> trainResultErrors = new ArrayList<>();\n+        if (modelResponse.getTrainResult().getErrors() != null) {\n+            trainResultErrors = setTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList = new ArrayList<>();\n+        modelResponse.getTrainResult().getTrainingDocuments().forEach(trainingDocumentItem -> {\n+            List<FormRecognizerError> documentErrors = new ArrayList<>();\n+            if (trainingDocumentItem.getErrors() != null) {\n+                documentErrors = setTrainingErrors(trainingDocumentItem.getErrors());\n+            }\n+            TrainingDocumentInfo trainingDocumentInfo = new TrainingDocumentInfo(trainingDocumentItem.getDocumentName(),\n+                TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()), trainingDocumentItem.getPages(),\n+                documentErrors);\n+            trainingDocumentInfoList.add(trainingDocumentInfo);\n+        });", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MjcxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406982714", "bodyText": "No need to add a coma before listing the allowed operations.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Operations allowed by the client are, to recognize receipt data from documents, extract layout information and\n          \n          \n            \n             * analyze custom forms for predefined data.\n          \n          \n            \n             * Operations allowed by the client are recognizing receipt data from documents, extracting layout information and\n          \n          \n            \n             * analyzing custom forms for predefined data.", "author": "alzimmermsft", "createdAt": "2020-04-10T23:31:10Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -31,11 +32,15 @@\n import java.util.function.Function;\n \n import static com.azure.ai.formrecognizer.Transforms.toReceipt;\n+import static com.azure.ai.formrecognizer.Transforms.toRecognizedFormSupervised;\n+import static com.azure.ai.formrecognizer.Transforms.toRecognizedLayout;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n import static com.azure.core.util.FluxUtil.monoError;\n \n /**\n  * This class provides an asynchronous client that contains all the operations that apply to Azure Form Recognizer.\n- * Operations allowed by the client are, to extract receipt data fields from receipt documents.\n+ * Operations allowed by the client are, to recognize receipt data from documents, extract layout information and\n+ * analyze custom forms for predefined data.", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MzYwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406983608", "bodyText": "Why is the default case to assume the operation is complete? Is this a case we should never hit?", "author": "alzimmermsft", "createdAt": "2020-04-10T23:35:33Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -57,6 +62,39 @@\n         this.serviceVersion = serviceVersion;\n     }\n \n+    private static Mono<PollResponse<OperationResult>> processAnalyzeModelResponse(\n+        SimpleResponse<AnalyzeOperationResult> analyzeOperationResultSimpleResponse,\n+        PollResponse<OperationResult> operationResultPollResponse) {\n+        LongRunningOperationStatus status;\n+        switch (analyzeOperationResultSimpleResponse.getValue().getStatus()) {\n+            case NOT_STARTED:\n+            case RUNNING:\n+                status = LongRunningOperationStatus.IN_PROGRESS;\n+                break;\n+            case SUCCEEDED:\n+                status = LongRunningOperationStatus.SUCCESSFULLY_COMPLETED;\n+                break;\n+            case FAILED:\n+                status = LongRunningOperationStatus.FAILED;\n+                break;\n+            default:\n+                status = LongRunningOperationStatus.fromString(\n+                    analyzeOperationResultSimpleResponse.getValue().getStatus().toString(), true);", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAwMTk2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407001962", "bodyText": "Yes, the above-defined cases should cover all of the OperationStatus statuses and this should never be hit. But if it does it should complete the LRO with the status it found.", "author": "samvaity", "createdAt": "2020-04-11T01:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MzYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MzgzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406983830", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Creates a new {@link FormTrainingAsyncClient} object.The new {@code FormTrainingAsyncClient}\n          \n          \n            \n                 * Creates a new {@link FormTrainingAsyncClient} object. The new {@code FormTrainingAsyncClient}", "author": "alzimmermsft", "createdAt": "2020-04-10T23:36:50Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -57,6 +62,39 @@\n         this.serviceVersion = serviceVersion;\n     }\n \n+    private static Mono<PollResponse<OperationResult>> processAnalyzeModelResponse(\n+        SimpleResponse<AnalyzeOperationResult> analyzeOperationResultSimpleResponse,\n+        PollResponse<OperationResult> operationResultPollResponse) {\n+        LongRunningOperationStatus status;\n+        switch (analyzeOperationResultSimpleResponse.getValue().getStatus()) {\n+            case NOT_STARTED:\n+            case RUNNING:\n+                status = LongRunningOperationStatus.IN_PROGRESS;\n+                break;\n+            case SUCCEEDED:\n+                status = LongRunningOperationStatus.SUCCESSFULLY_COMPLETED;\n+                break;\n+            case FAILED:\n+                status = LongRunningOperationStatus.FAILED;\n+                break;\n+            default:\n+                status = LongRunningOperationStatus.fromString(\n+                    analyzeOperationResultSimpleResponse.getValue().getStatus().toString(), true);\n+                break;\n+        }\n+        return Mono.just(new PollResponse<>(status, operationResultPollResponse.getValue()));\n+    }\n+\n+    /**\n+     * Creates a new {@link FormTrainingAsyncClient} object.The new {@code FormTrainingAsyncClient}", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NDIzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406984233", "bodyText": "Should this overload offer the option to set the polling interval?", "author": "alzimmermsft", "createdAt": "2020-04-10T23:38:48Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -67,40 +105,226 @@ public FormRecognizerServiceVersion getServiceVersion() {\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract custom form operation until it has completed, has failed,\n+     * or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>\n+        beginExtractCustomFormsFromUrl(String fileSourceUrl, String modelId) {\n+        return new PollerFlux<OperationResult, IterableStream<RecognizedForm>>(\n+            Duration.ofSeconds(5),\n+            analyzeFormActivationOperation(fileSourceUrl, modelId, false),\n+            createAnalyzeFormPollOperation(modelId),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchAnalyzeFormResultOperation(modelId, false));\n+    }\n+\n+    /**\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     * @param includeTextDetails Include text lines and element references in the result.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract custom form operation until it has completed, has failed,\n+     * or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>\n+        beginExtractCustomFormsFromUrl(String fileSourceUrl, String modelId, boolean includeTextDetails) {", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NDY3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406984674", "bodyText": "Should this have a parameter for poll interval?", "author": "alzimmermsft", "createdAt": "2020-04-10T23:40:46Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerClient.java", "diffHunk": "@@ -37,7 +40,171 @@\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Creates a new {@link FormTrainingClient} object.The new {@code FormRecognizerClient} uses the same request policy\n+     * pipeline as the {@code FormRecognizerClient}.\n+     *\n+     * @return A new {@link FormTrainingClient} object.\n+     */\n+    public FormTrainingClient getFormTrainingClient() {\n+        return new FormTrainingClient(client.getFormTrainingAsyncClient());\n+    }\n+\n+    /**\n+     * Recognizes and extracts receipt data from documents using optical character recognition (OCR)\n+     * and a custom trained model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     *\n+     * @return A {@link SyncPoller} to poll the progress of the extract custom form operation until it has completed,\n+     * has failed, or has been cancelled.\n+     */\n+    public SyncPoller<OperationResult, IterableStream<RecognizedForm>>\n+        beginExtractCustomFormsFromUrl(String fileSourceUrl, String modelId) {\n+        return beginExtractCustomFormsFromUrl(fileSourceUrl, modelId, false);\n+    }\n+\n+    /**\n+     * Recognizes and extracts receipt data from documents using optical character recognition (OCR)\n+     * and a custom trained model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     * @param includeTextDetails Include text lines and element references in the result.\n+     *\n+     * @return A {@link SyncPoller} to poll the progress of the extract custom form operation until it has completed,\n+     * has failed, or has been cancelled.\n+     */\n+    public SyncPoller<OperationResult, IterableStream<RecognizedForm>>\n+        beginExtractCustomFormsFromUrl(String fileSourceUrl, String modelId, boolean includeTextDetails) {", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NDg2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406984860", "bodyText": "Watch the spacing on each indented line, DevOps expected 2 spaces per indentation level.", "author": "alzimmermsft", "createdAt": "2020-04-10T23:41:44Z", "path": "sdk/formrecognizer/ci.yml", "diffHunk": "@@ -0,0 +1,42 @@\n+# DO NOT EDIT THIS FILE\n+# This file is generated automatically and any changes will be lost.\n+\n+resources:", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NTQyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406985423", "bodyText": "I feel the caller should check if the pipeline is null before calling into this.", "author": "alzimmermsft", "createdAt": "2020-04-10T23:44:49Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerClientBuilder.java", "diffHunk": "@@ -145,10 +146,19 @@ public FormRecognizerAsyncClient buildAsyncClient() {\n         final FormRecognizerServiceVersion serviceVersion =\n             version != null ? version : FormRecognizerServiceVersion.getLatest();\n \n-        // Endpoint cannot be null, which is required in request authentication\n-\n         HttpPipeline pipeline = httpPipeline;\n         // Create a default Pipeline if it is not given\n+        pipeline = getDefaultHttpPipeline(buildConfiguration, pipeline);\n+\n+        final FormRecognizerClientImpl formRecognizerAPI = new FormRecognizerClientImplBuilder()\n+            .endpoint(endpoint)\n+            .pipeline(pipeline)\n+            .build();\n+\n+        return new FormRecognizerAsyncClient(formRecognizerAPI, serviceVersion);\n+    }\n+\n+    private HttpPipeline getDefaultHttpPipeline(Configuration buildConfiguration, HttpPipeline pipeline) {", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NjA5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406986096", "bodyText": "No need to catch the exception here, it was already done in the overload.", "author": "alzimmermsft", "createdAt": "2020-04-10T23:48:48Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,304 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations \n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+public class FormTrainingAsyncClient {\n+\n+    private final ClientLogger logger = new ClientLogger(FormTrainingAsyncClient.class);\n+    private final FormRecognizerClientImpl service;\n+    private final FormRecognizerServiceVersion serviceVersion;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param service The proxy service used to perform REST calls.\n+     * @param serviceVersion The versions of Azure Form Recognizer supported by this client library.\n+     */\n+    FormTrainingAsyncClient(FormRecognizerClientImpl service, FormRecognizerServiceVersion serviceVersion) {\n+        this.service = service;\n+        this.serviceVersion = serviceVersion;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return serviceVersion;\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link PollerFlux} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl,\n+        boolean useLabelFile, boolean includeSubFolders, String filePrefix, Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' cannot be null.\");\n+        Objects.requireNonNull(useLabelFile, \"'useLabelFile' cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : Duration.ofSeconds(5);\n+\n+        return new PollerFlux<OperationResult, CustomFormModel>(\n+            interval,\n+            getTrainingActivationOperation(fileSourceUrl, includeSubFolders, filePrefix, useLabelFile),\n+            createTrainingPollOperation(),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchTrainingModelResultOperation());\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id.\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return The detailed information for the specified model.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<CustomFormModel> getCustomModel(String modelId) {\n+        try {\n+            return getCustomFormModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NjM3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406986372", "bodyText": "No need to catch the exception here, it was already done in the overload.", "author": "alzimmermsft", "createdAt": "2020-04-10T23:50:18Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,304 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations \n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+public class FormTrainingAsyncClient {\n+\n+    private final ClientLogger logger = new ClientLogger(FormTrainingAsyncClient.class);\n+    private final FormRecognizerClientImpl service;\n+    private final FormRecognizerServiceVersion serviceVersion;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param service The proxy service used to perform REST calls.\n+     * @param serviceVersion The versions of Azure Form Recognizer supported by this client library.\n+     */\n+    FormTrainingAsyncClient(FormRecognizerClientImpl service, FormRecognizerServiceVersion serviceVersion) {\n+        this.service = service;\n+        this.serviceVersion = serviceVersion;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return serviceVersion;\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link PollerFlux} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl,\n+        boolean useLabelFile, boolean includeSubFolders, String filePrefix, Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' cannot be null.\");\n+        Objects.requireNonNull(useLabelFile, \"'useLabelFile' cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : Duration.ofSeconds(5);\n+\n+        return new PollerFlux<OperationResult, CustomFormModel>(\n+            interval,\n+            getTrainingActivationOperation(fileSourceUrl, includeSubFolders, filePrefix, useLabelFile),\n+            createTrainingPollOperation(),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchTrainingModelResultOperation());\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id.\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return The detailed information for the specified model.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<CustomFormModel> getCustomModel(String modelId) {\n+        try {\n+            return getCustomFormModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id with Http response\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return A {@link Response} containing the requested {@link CustomFormModel model}.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<CustomFormModel>> getCustomFormModelWithResponse(String modelId) {\n+        try {\n+            return withContext(context -> getCustomFormModelWithResponse(modelId, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    Mono<Response<CustomFormModel>> getCustomFormModelWithResponse(String modelId, Context context) {\n+        Objects.requireNonNull(modelId, \"'modelId' cannot be null\");\n+        return service.getCustomModelWithResponseAsync(UUID.fromString(modelId), context, true)\n+            .map(response -> new SimpleResponse<>(response, toCustomFormModel(response.getValue())));\n+    }\n+\n+    /**\n+     * Get account information for all custom models.\n+     *\n+     * @return The account information.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<AccountProperties> getAccountProperties() {\n+        try {\n+            return getAccountPropertiesWithResponse().flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NjQ1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406986458", "bodyText": "No need to catch the exception here, it was already done in the overload.", "author": "alzimmermsft", "createdAt": "2020-04-10T23:50:47Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,304 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations \n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+public class FormTrainingAsyncClient {\n+\n+    private final ClientLogger logger = new ClientLogger(FormTrainingAsyncClient.class);\n+    private final FormRecognizerClientImpl service;\n+    private final FormRecognizerServiceVersion serviceVersion;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param service The proxy service used to perform REST calls.\n+     * @param serviceVersion The versions of Azure Form Recognizer supported by this client library.\n+     */\n+    FormTrainingAsyncClient(FormRecognizerClientImpl service, FormRecognizerServiceVersion serviceVersion) {\n+        this.service = service;\n+        this.serviceVersion = serviceVersion;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return serviceVersion;\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link PollerFlux} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl,\n+        boolean useLabelFile, boolean includeSubFolders, String filePrefix, Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' cannot be null.\");\n+        Objects.requireNonNull(useLabelFile, \"'useLabelFile' cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : Duration.ofSeconds(5);\n+\n+        return new PollerFlux<OperationResult, CustomFormModel>(\n+            interval,\n+            getTrainingActivationOperation(fileSourceUrl, includeSubFolders, filePrefix, useLabelFile),\n+            createTrainingPollOperation(),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchTrainingModelResultOperation());\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id.\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return The detailed information for the specified model.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<CustomFormModel> getCustomModel(String modelId) {\n+        try {\n+            return getCustomFormModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id with Http response\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return A {@link Response} containing the requested {@link CustomFormModel model}.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<CustomFormModel>> getCustomFormModelWithResponse(String modelId) {\n+        try {\n+            return withContext(context -> getCustomFormModelWithResponse(modelId, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    Mono<Response<CustomFormModel>> getCustomFormModelWithResponse(String modelId, Context context) {\n+        Objects.requireNonNull(modelId, \"'modelId' cannot be null\");\n+        return service.getCustomModelWithResponseAsync(UUID.fromString(modelId), context, true)\n+            .map(response -> new SimpleResponse<>(response, toCustomFormModel(response.getValue())));\n+    }\n+\n+    /**\n+     * Get account information for all custom models.\n+     *\n+     * @return The account information.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<AccountProperties> getAccountProperties() {\n+        try {\n+            return getAccountPropertiesWithResponse().flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Get account information.\n+     *\n+     * @return A {@link Response} containing the requested account information details.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<AccountProperties>> getAccountPropertiesWithResponse() {\n+        try {\n+            return withContext(context -> getAccountPropertiesWithResponse(context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    Mono<Response<AccountProperties>> getAccountPropertiesWithResponse(Context context) {\n+        return service.getCustomModelsWithResponseAsync(context)\n+            .map(response -> new SimpleResponse<>(response,\n+            new AccountProperties(response.getValue().getSummary().getCount(),\n+                response.getValue().getSummary().getLimit())));\n+    }\n+\n+    /**\n+     * Deletes the specified custom model.\n+     *\n+     * @param modelId The modelIdentifier.\n+     * @return An empty Mono.\n+     */\n+    public Mono<Void> deleteModel(String modelId) {\n+        try {\n+            return deleteModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NjU3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406986577", "bodyText": "If the model ID is a UUID should we accept that in the API instead?", "author": "alzimmermsft", "createdAt": "2020-04-10T23:51:37Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,304 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations \n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+public class FormTrainingAsyncClient {\n+\n+    private final ClientLogger logger = new ClientLogger(FormTrainingAsyncClient.class);\n+    private final FormRecognizerClientImpl service;\n+    private final FormRecognizerServiceVersion serviceVersion;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param service The proxy service used to perform REST calls.\n+     * @param serviceVersion The versions of Azure Form Recognizer supported by this client library.\n+     */\n+    FormTrainingAsyncClient(FormRecognizerClientImpl service, FormRecognizerServiceVersion serviceVersion) {\n+        this.service = service;\n+        this.serviceVersion = serviceVersion;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return serviceVersion;\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link PollerFlux} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl,\n+        boolean useLabelFile, boolean includeSubFolders, String filePrefix, Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' cannot be null.\");\n+        Objects.requireNonNull(useLabelFile, \"'useLabelFile' cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : Duration.ofSeconds(5);\n+\n+        return new PollerFlux<OperationResult, CustomFormModel>(\n+            interval,\n+            getTrainingActivationOperation(fileSourceUrl, includeSubFolders, filePrefix, useLabelFile),\n+            createTrainingPollOperation(),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchTrainingModelResultOperation());\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id.\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return The detailed information for the specified model.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<CustomFormModel> getCustomModel(String modelId) {\n+        try {\n+            return getCustomFormModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id with Http response\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return A {@link Response} containing the requested {@link CustomFormModel model}.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<CustomFormModel>> getCustomFormModelWithResponse(String modelId) {\n+        try {\n+            return withContext(context -> getCustomFormModelWithResponse(modelId, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    Mono<Response<CustomFormModel>> getCustomFormModelWithResponse(String modelId, Context context) {\n+        Objects.requireNonNull(modelId, \"'modelId' cannot be null\");\n+        return service.getCustomModelWithResponseAsync(UUID.fromString(modelId), context, true)", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMxNTg3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407315875", "bodyText": "Expecting a string modelID is more approachable for the user so decided to go with it.", "author": "samvaity", "createdAt": "2020-04-13T04:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NjU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NjgxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406986817", "bodyText": "Is this similar to the other poller helpers? Would there be any way to combine them into a generic helper?", "author": "alzimmermsft", "createdAt": "2020-04-10T23:52:54Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,304 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations \n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+public class FormTrainingAsyncClient {\n+\n+    private final ClientLogger logger = new ClientLogger(FormTrainingAsyncClient.class);\n+    private final FormRecognizerClientImpl service;\n+    private final FormRecognizerServiceVersion serviceVersion;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param service The proxy service used to perform REST calls.\n+     * @param serviceVersion The versions of Azure Form Recognizer supported by this client library.\n+     */\n+    FormTrainingAsyncClient(FormRecognizerClientImpl service, FormRecognizerServiceVersion serviceVersion) {\n+        this.service = service;\n+        this.serviceVersion = serviceVersion;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return serviceVersion;\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link PollerFlux} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl,\n+        boolean useLabelFile, boolean includeSubFolders, String filePrefix, Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' cannot be null.\");\n+        Objects.requireNonNull(useLabelFile, \"'useLabelFile' cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : Duration.ofSeconds(5);\n+\n+        return new PollerFlux<OperationResult, CustomFormModel>(\n+            interval,\n+            getTrainingActivationOperation(fileSourceUrl, includeSubFolders, filePrefix, useLabelFile),\n+            createTrainingPollOperation(),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchTrainingModelResultOperation());\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id.\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return The detailed information for the specified model.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<CustomFormModel> getCustomModel(String modelId) {\n+        try {\n+            return getCustomFormModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id with Http response\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return A {@link Response} containing the requested {@link CustomFormModel model}.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<CustomFormModel>> getCustomFormModelWithResponse(String modelId) {\n+        try {\n+            return withContext(context -> getCustomFormModelWithResponse(modelId, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    Mono<Response<CustomFormModel>> getCustomFormModelWithResponse(String modelId, Context context) {\n+        Objects.requireNonNull(modelId, \"'modelId' cannot be null\");\n+        return service.getCustomModelWithResponseAsync(UUID.fromString(modelId), context, true)\n+            .map(response -> new SimpleResponse<>(response, toCustomFormModel(response.getValue())));\n+    }\n+\n+    /**\n+     * Get account information for all custom models.\n+     *\n+     * @return The account information.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<AccountProperties> getAccountProperties() {\n+        try {\n+            return getAccountPropertiesWithResponse().flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Get account information.\n+     *\n+     * @return A {@link Response} containing the requested account information details.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<AccountProperties>> getAccountPropertiesWithResponse() {\n+        try {\n+            return withContext(context -> getAccountPropertiesWithResponse(context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    Mono<Response<AccountProperties>> getAccountPropertiesWithResponse(Context context) {\n+        return service.getCustomModelsWithResponseAsync(context)\n+            .map(response -> new SimpleResponse<>(response,\n+            new AccountProperties(response.getValue().getSummary().getCount(),\n+                response.getValue().getSummary().getLimit())));\n+    }\n+\n+    /**\n+     * Deletes the specified custom model.\n+     *\n+     * @param modelId The modelIdentifier.\n+     * @return An empty Mono.\n+     */\n+    public Mono<Void> deleteModel(String modelId) {\n+        try {\n+            return deleteModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Deletes the specified custom model.\n+     *\n+     * @param modelId The modelIdentifier\n+     *\n+     * @return A {@link Mono} containing containing status code and HTTP headers\n+     */\n+    public Mono<Response<Void>> deleteModelWithResponse(String modelId) {\n+        try {\n+            return withContext(context -> deleteModelWithResponse(modelId, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<Void>> deleteModelWithResponse(String modelId, Context context) {\n+        Objects.requireNonNull(modelId, \"'modelId' cannot be null\");\n+\n+        return service.deleteCustomModelWithResponseAsync(UUID.fromString(modelId), context)\n+            .map(response -> new SimpleResponse<>(response, null));\n+    }\n+\n+    // list models\n+    // TODO (shawn) : #9976\n+\n+    private Function<PollingContext<OperationResult>, Mono<CustomFormModel>> fetchTrainingModelResultOperation() {\n+        return (pollingContext) -> {\n+            final UUID modelUid = UUID.fromString(pollingContext.getLatestResponse().getValue().getResultId());\n+            return service.getCustomModelWithResponseAsync(modelUid, true)\n+                .map(modelSimpleResponse -> toCustomFormModel(modelSimpleResponse.getValue()));\n+        };\n+    }\n+\n+    private Function<PollingContext<OperationResult>, Mono<PollResponse<OperationResult>>>\n+        createTrainingPollOperation() {\n+        return (pollingContext) -> {\n+            PollResponse<OperationResult> operationResultPollResponse = pollingContext.getLatestResponse();\n+            try {\n+                UUID modelUid = UUID.fromString(operationResultPollResponse.getValue().getResultId());\n+                return service.getCustomModelWithResponseAsync(modelUid, true)\n+                    .flatMap(modelSimpleResponse ->\n+                        processTrainingModelResponse(modelSimpleResponse, operationResultPollResponse));\n+            } catch (HttpResponseException e) {\n+                logger.logExceptionAsError(e);\n+                return Mono.just(new PollResponse<>(LongRunningOperationStatus.FAILED, null));\n+            }\n+        };\n+    }\n+\n+    private Function<PollingContext<OperationResult>, Mono<OperationResult>> getTrainingActivationOperation(\n+        String sourcePath, boolean includeSubFolders, String filePrefix, boolean useLabelFile) {\n+\n+        TrainSourceFilter trainSourceFilter = new TrainSourceFilter().setIncludeSubFolders(includeSubFolders)\n+            .setPrefix(filePrefix);\n+        TrainRequest serviceTrainRequest = new TrainRequest().setSource(sourcePath).\n+            setSourceFilter(trainSourceFilter).setUseLabelFile(useLabelFile);\n+        return (pollingContext) -> {\n+            try {\n+                return service.trainCustomModelAsyncWithResponseAsync(serviceTrainRequest)\n+                    .map(response ->\n+                        new OperationResult(parseModelId(response.getDeserializedHeaders().getLocation())));\n+            } catch (RuntimeException ex) {\n+                return monoError(logger, ex);\n+            }\n+        };\n+    }\n+\n+    private static Mono<PollResponse<OperationResult>> processTrainingModelResponse(", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2NDk2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407864963", "bodyText": "There are total of 2 such methods both switch case and also return different return types. Don't see a cleanest way to combine these atm.", "author": "samvaity", "createdAt": "2020-04-14T04:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NzM0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r406987344", "bodyText": "What happens if there isn't a / in the String?", "author": "alzimmermsft", "createdAt": "2020-04-10T23:55:43Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -49,4 +50,19 @@ private static ByteBuffer toByteArray(InputStream in) {\n             throw LOGGER.logExceptionAsError(new RuntimeException(e));\n         }\n     }\n+\n+    /**\n+     * Extracts the result ID from the URL.\n+     *\n+     * @param operationLocation The URL specified in the 'Operation-Location' response header containing the\n+     * resultId used to track the progress and obtain the result of the analyze operation.\n+     *\n+     * @return The resultId used to track the progress.\n+     */\n+    public static String parseModelId(String operationLocation) {\n+        if (!CoreUtils.isNullOrEmpty(operationLocation)) {\n+            return operationLocation.substring(operationLocation.lastIndexOf('/') + 1);", "originalCommit": "eb18c628811e882a0c94919b0e4bb4f30709eba0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4OTE3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407589176", "bodyText": "Updated to throw an error if / is not found in the string.", "author": "samvaity", "createdAt": "2020-04-13T17:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NzM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Mjc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407082777", "bodyText": "just 'ModelInfo' should be good", "author": "mssfang", "createdAt": "2020-04-11T16:28:11Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        com.azure.ai.formrecognizer.implementation.models.ModelInfo modelInfo = modelResponse.getModelInfo();", "originalCommit": "2bec359a9f36e999021e1e4e4bd0a6e4b4b2a8ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4MzEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407083103", "bodyText": "@Immutable and final class?", "author": "mssfang", "createdAt": "2020-04-11T16:31:18Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/ArrayValue.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import java.util.List;\n+\n+/**\n+ * Class to represent the Array value for\n+ * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray()}\n+ */\n+public class ArrayValue extends FieldValue<List<FieldValue<?>>> {", "originalCommit": "2bec359a9f36e999021e1e4e4bd0a6e4b4b2a8ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4MzE3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407083170", "bodyText": "final class", "author": "mssfang", "createdAt": "2020-04-11T16:32:00Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/CustomFormModel.java", "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.util.IterableStream;\n+\n+import java.time.OffsetDateTime;\n+import java.util.List;\n+\n+/**\n+ * The CustomFormModel\n+ */\n+@Immutable\n+public class CustomFormModel {", "originalCommit": "2bec359a9f36e999021e1e4e4bd0a6e4b4b2a8ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4MzIzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407083236", "bodyText": "final class, there are other classes that are missing the final keyword.", "author": "mssfang", "createdAt": "2020-04-11T16:32:45Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/CustomFormSubModel.java", "diffHunk": "@@ -0,0 +1,71 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+import java.util.Map;\n+\n+/**\n+ * The CustomFormSubModel model.\n+ */\n+@Immutable\n+public class CustomFormSubModel {", "originalCommit": "2bec359a9f36e999021e1e4e4bd0a6e4b4b2a8ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "message": "update sync tests", "committedDate": "2020-04-13T04:56:44Z", "type": "forcePushed"}, {"oid": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "message": "update sync tests", "committedDate": "2020-04-13T17:26:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2NzExNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407567114", "bodyText": "Any reason this dependency is being listed explicitly? This should be transitively pulled through from Azure Core.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:21:25Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/pom.xml", "diffHunk": "@@ -63,5 +63,17 @@\n       <version>5.4.2</version> <!-- {x-version-update;org.junit.jupiter:junit-jupiter-engine;external_dependency} -->\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>com.fasterxml.jackson.datatype</groupId>\n+      <artifactId>jackson-datatype-jsr310</artifactId>\n+      <version>2.10.1</version> <!-- {x-version-update;com.fasterxml.jackson.datatype:jackson-datatype-jsr310;external_dependency} -->\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>com.fasterxml.jackson.dataformat</groupId>\n+      <artifactId>jackson-dataformat-xml</artifactId>\n+      <version>2.10.1</version> <!-- {x-version-update;com.fasterxml.jackson.dataformat:jackson-dataformat-xml;external_dependency} -->\n+      <scope>compile</scope>\n+    </dependency>", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2ODI0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407568241", "bodyText": "Would JacksonAdapter suffice in this scenario?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:23:35Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/test/java/com/azure/ai/formrecognizer/TestJsonUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult;\n+import com.azure.ai.formrecognizer.implementation.models.PageResult;\n+import com.azure.ai.formrecognizer.implementation.models.ReadResult;\n+import com.azure.ai.formrecognizer.models.FormLine;\n+import com.azure.ai.formrecognizer.models.FormTable;\n+import com.azure.ai.formrecognizer.models.RecognizedForm;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.core.util.IterableStream;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.SimpleDateFormat;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static com.azure.ai.formrecognizer.Transforms.toReceipt;\n+import static com.azure.ai.formrecognizer.Transforms.toRecognizedForm;\n+import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;\n+\n+/**\n+ * Contains helper methods for generating test data for test methods.\n+ */\n+final class TestJsonUtil {\n+\n+    public static ObjectMapper getObjectMapper() {\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        objectMapper.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n+        df.setTimeZone(TimeZone.getDefault());\n+        objectMapper.setDateFormat(df);\n+\n+        objectMapper.registerModule(new JavaTimeModule());\n+        return objectMapper;", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4NDg0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407784845", "bodyText": "Yup, thanks!", "author": "samvaity", "createdAt": "2020-04-13T23:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2ODI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MDc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407570793", "bodyText": "Is this supposed to be a valid URL?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:28:08Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/TrainCustomModel.java", "diffHunk": "@@ -0,0 +1,57 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollerFlux;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Sample for training a custom model using training data set source URL.\n+ */\n+public class TrainCustomModel {\n+\n+    /**\n+     * Main method to invoke this demo about how to train a custom model.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // Instantiate a client that will be used to call the service.\n+\n+        FormTrainingAsyncClient client = new FormRecognizerClientBuilder()\n+            .apiKey(new AzureKeyCredential(\"{api_Key}\"))\n+            .endpoint(\"https://{endpoint}.cognitiveservices.azure.com/\")\n+            .buildAsyncClient().getFormTrainingAsyncClient();\n+\n+        // Train custom model\n+        String trainingSetSource = \"https://training-SAS-URL\";", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNDk3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407614973", "bodyText": "This should be the user's choice of training data set url.", "author": "samvaity", "createdAt": "2020-04-13T17:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MDc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MTM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407571343", "bodyText": "Should a final, non-success response be returned through the error channel? Mono.error", "author": "alzimmermsft", "createdAt": "2020-04-13T16:29:03Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/TrainCustomModel.java", "diffHunk": "@@ -0,0 +1,57 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollerFlux;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Sample for training a custom model using training data set source URL.\n+ */\n+public class TrainCustomModel {\n+\n+    /**\n+     * Main method to invoke this demo about how to train a custom model.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // Instantiate a client that will be used to call the service.\n+\n+        FormTrainingAsyncClient client = new FormRecognizerClientBuilder()\n+            .apiKey(new AzureKeyCredential(\"{api_Key}\"))\n+            .endpoint(\"https://{endpoint}.cognitiveservices.azure.com/\")\n+            .buildAsyncClient().getFormTrainingAsyncClient();\n+\n+        // Train custom model\n+        String trainingSetSource = \"https://training-SAS-URL\";\n+        PollerFlux<OperationResult, CustomFormModel> trainingPoller = client.beginTraining(trainingSetSource, true);\n+\n+        CustomFormModel customFormModel = trainingPoller\n+            .last()\n+            .flatMap(trainingOperationResponse -> {\n+                if (trainingOperationResponse.getStatus().equals(LongRunningOperationStatus.SUCCESSFULLY_COMPLETED)) {\n+                    // training completed successfully, retrieving final result.\n+                    return trainingOperationResponse.getFinalResult();\n+                } else {\n+                    System.out.println(\"Polling completed unsuccessfully with status:\"\n+                        + trainingOperationResponse.getStatus());\n+                    return Mono.empty();", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNDYyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407614620", "bodyText": "Kept this as an empty Mono on purpose. Didn't want the samples to throw errors as we already print out that polling was unsuccessful.", "author": "samvaity", "createdAt": "2020-04-13T17:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MTM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjA3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407572079", "bodyText": "Should check for customFormModel being null since blocking Mono.empty for a value will return null.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:30:21Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/TrainCustomModel.java", "diffHunk": "@@ -0,0 +1,57 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollerFlux;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Sample for training a custom model using training data set source URL.\n+ */\n+public class TrainCustomModel {\n+\n+    /**\n+     * Main method to invoke this demo about how to train a custom model.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // Instantiate a client that will be used to call the service.\n+\n+        FormTrainingAsyncClient client = new FormRecognizerClientBuilder()\n+            .apiKey(new AzureKeyCredential(\"{api_Key}\"))\n+            .endpoint(\"https://{endpoint}.cognitiveservices.azure.com/\")\n+            .buildAsyncClient().getFormTrainingAsyncClient();\n+\n+        // Train custom model\n+        String trainingSetSource = \"https://training-SAS-URL\";\n+        PollerFlux<OperationResult, CustomFormModel> trainingPoller = client.beginTraining(trainingSetSource, true);\n+\n+        CustomFormModel customFormModel = trainingPoller\n+            .last()\n+            .flatMap(trainingOperationResponse -> {\n+                if (trainingOperationResponse.getStatus().equals(LongRunningOperationStatus.SUCCESSFULLY_COMPLETED)) {\n+                    // training completed successfully, retrieving final result.\n+                    return trainingOperationResponse.getFinalResult();\n+                } else {\n+                    System.out.println(\"Polling completed unsuccessfully with status:\"\n+                        + trainingOperationResponse.getStatus());\n+                    return Mono.empty();\n+                }\n+            }).block();\n+\n+        // Model Info\n+        System.out.printf(\"Model Id: %s%n\", customFormModel.getModelId());\n+        System.out.printf(\"Model Status: %s%n\", customFormModel.getModelStatus());\n+        customFormModel.getSubModels().forEach(customFormSubModel ->\n+            customFormSubModel.getFieldMap().forEach((key, customFormModelField) ->\n+                System.out.printf(\"Model Type Id: %s Field Text: %s Field Accuracy: %s%n\",\n+                    key, customFormModelField.getName(), customFormModelField.getAccuracy())));", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4NDcxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407784717", "bodyText": "Updated the sample to return a Mono.error if the training poller didn't go through.", "author": "samvaity", "createdAt": "2020-04-13T23:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjU4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407572584", "bodyText": "If the underlying polling results in an error state/invalid completion state what does this IterableStream end up being?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:31:15Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/ReadmeSamples.java", "diffHunk": "@@ -66,23 +67,21 @@ public void rotatingApiKey() {\n \n     public void extractReceipt() {\n         String receiptSourceUrl = \"https://docs.microsoft.com/en-us/azure/cognitive-services/form-recognizer/media/contoso-allinone.jpg\";\n-        SyncPoller<OperationResult, IterableStream<ExtractedReceipt>> syncPoller =\n-            formRecognizerClient.beginExtractReceiptsFromUrl(receiptSourceUrl);\n-        IterableStream<ExtractedReceipt> extractedReceipts = syncPoller.getFinalResult();\n+        SyncPoller<OperationResult, IterableStream<RecognizedReceipt>> syncPoller =\n+            formRecognizerClient.beginRecognizeReceiptsFromUrl(receiptSourceUrl);\n+        IterableStream<RecognizedReceipt> receiptPageResults = syncPoller.getFinalResult();", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4NDM4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407784383", "bodyText": "The respective fetch operation checks for the status on the returned model and raises exception on the model.errors.", "author": "samvaity", "createdAt": "2020-04-13T23:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MzY2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407573663", "bodyText": "Are these actually needed as transitive requires? That infers they are used in the public API.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:33:10Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/module-info.java", "diffHunk": "@@ -3,6 +3,12 @@\n \n module com.azure.ai.formrecognizer {\n     requires transitive com.azure.core;\n+    requires transitive com.fasterxml.jackson.annotation;\n+    requires transitive com.fasterxml.jackson.core;\n+    requires transitive com.fasterxml.jackson.databind;", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NDAxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407684016", "bodyText": "Yeah, these should not be transitive and core should require them transitively so, you don't need these at all.", "author": "srnagar", "createdAt": "2020-04-13T19:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MzY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NDUxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407574516", "bodyText": "So this ReceiptType is United States specific? Is there a plan to have additional ReceiptTypes in the future where an abstract base class should be added?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:34:44Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/USReceiptType.java", "diffHunk": "@@ -6,10 +6,10 @@\n import com.azure.core.annotation.Immutable;\n \n /**\n- * The ReceiptType model.\n+ * The USReceiptType model.\n  */\n @Immutable\n-public final class ReceiptType {\n+public final class USReceiptType {", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxODIzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407618230", "bodyText": "Currently, the service hasn't reported any potential additional ReceiptType. And this one specifically only applies to USReceipt.", "author": "samvaity", "createdAt": "2020-04-13T17:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NDUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NjI1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407576251", "bodyText": "Is it likely that this class would see additional fields added to it in the future? One thing we need to begin handling better in all of our SDKs is constructor proliferation as the services extend and change, Storage is running into this problem in a few classes where there are now three constructors where two are deprecated due to adding an additional parameter.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:38:00Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/USReceipt.java", "diffHunk": "@@ -0,0 +1,226 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+import java.time.LocalDate;\n+import java.util.List;\n+\n+/**\n+ * The USReceipt model.\n+ */\n+@Immutable\n+public final class USReceipt extends RecognizedReceipt {\n+\n+    /**\n+     * List of recognized field items.\n+     */\n+    private final List<USReceiptItem> receiptItems;\n+\n+    /**\n+     * Recognized receipt type information.\n+     */\n+    private final USReceiptType receiptType;\n+\n+    /**\n+     * Recognized field merchant name.\n+     */\n+    private final FormField<String> merchantName;\n+\n+    /**\n+     * Recognized field merchant address.\n+     */\n+    private final FormField<String> merchantAddress;\n+\n+    /**\n+     * Recognized field merchant phone number.\n+     */\n+    private final FormField<String> merchantPhoneNumber;\n+\n+    /**\n+     * Recognized field subtotal.\n+     */\n+    private final FormField<Float> subtotal;\n+\n+    /**\n+     * Recognized field tax.\n+     */\n+    private final FormField<Float> tax;\n+\n+    /**\n+     * Recognized field tip.\n+     */\n+    private final FormField<Float> tip;\n+\n+    /**\n+     * Recognized field total.\n+     */\n+    private final FormField<Float> total;\n+\n+    /**\n+     * Recognized field transaction date.\n+     */\n+    private final FormField<LocalDate> transactionDate;\n+\n+    /**\n+     * Recognized field transaction time.\n+     */\n+    private final FormField<String> transactionTime;\n+\n+    /**\n+     * Constructs a USReceipt object.\n+     *\n+     * @param receiptLocale The locale information for the recognized Receipt.\n+     * @param recognizedForm The recognized form.\n+     * @param receiptItems List of recognized field items.\n+     * @param receiptType Recognized receipt type information.\n+     * @param merchantName Recognized field merchant name.\n+     * @param merchantAddress Recognized field merchant address.\n+     * @param merchantPhoneNumber Recognized field merchant phone number.\n+     * @param subtotal Recognized field subtotal.\n+     * @param tax Recognized field tax.\n+     * @param tip Recognized field tip.\n+     * @param total Recognized field total.\n+     * @param transactionDate Recognized field transaction date.\n+     * @param transactionTime Recognized field transaction time.\n+     */\n+    public USReceipt(String receiptLocale, RecognizedForm recognizedForm, final List<USReceiptItem> receiptItems,\n+                     final USReceiptType receiptType, final FormField<String> merchantName,\n+                     final FormField<String> merchantAddress,\n+                     final FormField<String> merchantPhoneNumber, final FormField<Float> subtotal,\n+                     final FormField<Float> tax,\n+                     final FormField<Float> tip, final FormField<Float> total,\n+                     final FormField<LocalDate> transactionDate,\n+                     final FormField<String> transactionTime) {", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyMDMzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407620333", "bodyText": "There is definitely a chance for this model to grow based on the conversations we are having with the service team. But don't know how much more future-proofing can be done at the moment.\nOne way to get around the constructor problem would be to have constructors only for fields that are required for the model and cannot be null and have setters for the rest of the fields. But then this causes the model to have public setter which when exposed to users are not really helpful.", "author": "samvaity", "createdAt": "2020-04-13T17:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NjI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NjUxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407576510", "bodyText": "No real need to add Javadocs to private fields.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:38:30Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/USReceipt.java", "diffHunk": "@@ -0,0 +1,226 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+import java.time.LocalDate;\n+import java.util.List;\n+\n+/**\n+ * The USReceipt model.\n+ */\n+@Immutable\n+public final class USReceipt extends RecognizedReceipt {\n+\n+    /**\n+     * List of recognized field items.\n+     */", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3NzM3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407577375", "bodyText": "Is this copied from Swagger? Is this class meant to be generated? If not we should change these Javadocs a bit.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:40:07Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/TrainingDocumentInfo.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+import java.util.List;\n+\n+/**\n+ * The TrainingDocumentInfo model.\n+ */\n+@Immutable\n+public final class TrainingDocumentInfo {\n+\n+    /*\n+     * Training document name.\n+     */\n+    private final String name;\n+\n+    /*\n+     * Status of the training operation.\n+     */\n+    private final TrainingStatus trainingStatus;\n+\n+    /*\n+     * Total number of pages trained.\n+     */\n+    private final int pageCount;\n+\n+    /*\n+     * List of errors.\n+     */\n+    private final List<FormRecognizerError> documentError;\n+\n+    /**\n+     * Constructs a TrainingDocumentInfo object.\n+     *\n+     * @param name Training document name.\n+     * @param trainingStatus Status of the training operation.\n+     * @param pageCount Total number of pages trained.\n+     * @param documentError List of errors.\n+     */\n+    public TrainingDocumentInfo(final String name, final TrainingStatus trainingStatus, final int pageCount,\n+                                final List<FormRecognizerError> documentError) {\n+        this.name = name;\n+        this.trainingStatus = trainingStatus;\n+        this.pageCount = pageCount;\n+        this.documentError = documentError;\n+    }\n+\n+    /**\n+     * Get the documentName property: Training document name.", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3ODE1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407578158", "bodyText": "From these Javadocs I don't fully understand this property, my guess is this is the original document sent to the service to be analyzed.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:41:45Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/RecognizedReceipt.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+/**\n+ * The RecognizedReceipt model.\n+ */\n+@Immutable\n+public class RecognizedReceipt {\n+\n+    /**\n+     * The locale information for the recognized Receipt.\n+     */\n+    private final String receiptLocale;\n+\n+    /**\n+     * The recognized form.\n+     */\n+    private final RecognizedForm recognizedForm;\n+\n+    /**\n+     * Constructs a RecognizedReceipt object.\n+     *\n+     * @param receiptLocale The locale information for the recognized Receipt.\n+     * @param recognizedForm The recognized form.\n+     */\n+    public RecognizedReceipt(final String receiptLocale, final RecognizedForm recognizedForm) {\n+        this.receiptLocale = receiptLocale;\n+        this.recognizedForm = recognizedForm;\n+    }\n+\n+    /**\n+     * Get the receiptLocale property. The locale information for the recognized Receipt.\n+     *\n+     * @return The locale information for the recognized Receipt.\n+     */\n+    public String getReceiptLocale() {\n+        return this.receiptLocale;\n+    }\n+\n+    /**\n+     * Get the recognizedForm property. The recognized form for the recognized Receipt.", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3ODg3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407578876", "bodyText": "When one of these values is null should both be null?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:43:01Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/Point.java", "diffHunk": "@@ -14,20 +14,20 @@\n     /*\n      * The x-axis point coordinate.\n      */\n-    private final float xCoordinate;\n+    private final Float xCoordinate;\n \n     /*\n      * The y-axis point coordinate.\n      */\n-    private final float yCoordinate;\n+    private final Float yCoordinate;\n \n     /**\n      * Creates a Point object.\n      *\n      * @param xCoordinate The x-axis point coordinate.\n      * @param yCoordinate The y-axis point coordinate.\n      */\n-    public Point(final float xCoordinate, final float yCoordinate) {\n+    public Point(final Float xCoordinate, final Float yCoordinate) {\n         this.xCoordinate = xCoordinate;\n         this.yCoordinate = yCoordinate;", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MDE4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407580189", "bodyText": "Will code ever be mapped back to an enum?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:45:24Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/FormRecognizerError.java", "diffHunk": "@@ -0,0 +1,53 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+/**\n+ * The FormRecognizerError model.\n+ */\n+@Immutable\n+public final class FormRecognizerError {\n+    /*\n+     * The code property.\n+     */\n+    private final String code;", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyMjY3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407622678", "bodyText": "We still don't have a good set of code to expect so keeping it as String for now.\nFiled an issue to keep track of this in preview 2 - #10138", "author": "samvaity", "createdAt": "2020-04-13T18:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MDE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MDYzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407580632", "bodyText": "Would height, width, or textAngle ever be returned as null?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:46:14Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/FormPage.java", "diffHunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+import java.util.List;\n+\n+/**\n+ * The FormPage model.\n+ */\n+@Immutable\n+public final class FormPage {\n+\n+    /*\n+     * The height of the image/PDF in pixels/inches, respectively.\n+     */\n+    private final float height;\n+\n+    /*\n+     * When includeTextDetails is set to true, a list of recognized text lines.\n+     */\n+    private final List<FormLine> lines;\n+\n+    /*\n+     * List of data tables extracted from the page.\n+     */\n+    private final List<FormTable> tables;\n+\n+    /*\n+     * The general orientation of the text in clockwise direction, measured in\n+     * degrees between (-180, 180].\n+     */\n+    private final float textAngle;\n+\n+    /*\n+     * The unit used by the width, height and boundingBox properties. For\n+     * images, the unit is \"pixel\". For PDF, the unit is \"inch\".\n+     */\n+    private final DimensionUnit unit;\n+\n+    /*\n+     * The width of the image/PDF in pixels/inches, respectively.\n+     */\n+    private final float width;\n+\n+    /**\n+     * Constructs a FormPage object.\n+     *  @param height The height of the image/PDF in pixels/inches, respectively.\n+     * @param textAngle The general orientation of the text in clockwise direction.\n+     * @param unit The unit used by the width, height and boundingBox properties.\n+     * @param width The width of the image/PDF in pixels/inches, respectively.\n+     * @param lines When includeTextDetails is set to true, a list of recognized text lines.\n+     * @param tables List of data tables extracted from the page.\n+     */\n+    public FormPage(final float height, final float textAngle, final DimensionUnit unit,\n+        final float width, final List<FormLine> lines, final List<FormTable> tables) {", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzQwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407717400", "bodyText": "No, as they are mentioned as required in the swagger", "author": "samvaity", "createdAt": "2020-04-13T20:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MDYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MjQ2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407582469", "bodyText": "Was this change done manually? If so we should file an issue to port this into a Swagger transform.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:49:22Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/FormRecognizerClientImpl.java", "diffHunk": "@@ -121,86 +121,86 @@ public FormRecognizerClientImpl(HttpPipeline httpPipeline) {\n     private interface FormRecognizerClientService {\n         @Post(\"/custom/models\")\n         @ExpectedResponses({201})\n-        @UnexpectedResponseExceptionType(ErrorResponseException.class)\n+        @UnexpectedResponseExceptionType(HttpResponseException.class)", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyODU2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407828560", "bodyText": "Azure/autorest.java#577", "author": "samvaity", "createdAt": "2020-04-14T02:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MjQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1NjM2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409056364", "bodyText": "This is defined in Swagger. Also, ErrorResponseException extends from HttpResponseException. So, this shouldn't be changed manually.", "author": "srnagar", "createdAt": "2020-04-15T18:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MjQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MjkzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407582937", "bodyText": "Should this check for null, empty, and less than eight elements?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:50:14Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -52,326 +51,383 @@ private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap = null;\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n \n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult);\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (int i = 0; i < documentResults.size(); i++) {\n+\n+                DocumentResult documentResultItem = documentResults.get(i);\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getLabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n \n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+            extractedFormList.add(new RecognizedForm(extractedFieldMap, formType.get(), pageRange.get(),\n+                new IterableStream<FormPage>(formPages.subList(pageRange.get().getStartPageNumber(), pageRange.get().getEndPageNumber()))));\n+        }\n+\n+        // labeled\n+        if (pageResults != null) {\n+            for (int i = 0; i < pageResults.size(); i++) {\n+                PageResult pageResultItem = pageResults.get(i);\n+                Integer pageNumber = pageResultItem.getPage();\n+\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getUnlabeledFieldMap(includeTextDetails, readResults, pageResultItem, pageNumber);\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+                extractedFormList.add(\n+                    new RecognizedForm(extractedFieldMap, formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<FormPage>(Arrays.asList(formPages.get(pageNumber - 1)))));\n+            }\n         }\n+        return extractedFormList;\n+    }\n+\n+    /**\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n+     *\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n+     */\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<RecognizedReceipt> extractedReceiptList =\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm)).collect(Collectors.toList());\n+\n         return new IterableStream<>(extractedReceiptList);\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n+     * @param analyzeResult The service returned result for analyze layouts.\n+     *\n+     * @return The IterableStream of {@code FormPage}.\n+     */\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        for (int i = 0; i < readResults.size(); i++) {\n+            ReadResult readResultItem = readResults.get(i);\n+            PageResult pageResultItem;\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+                pageResultItem = pageResults.get(i);\n+                perPageTableList = getPageTables(pageResultItem, pageResultItem.getPage());\n+            }\n+\n+            // add form lines\n+            List<FormLine> perPageFormLineList = new ArrayList<>();\n+            if (!CoreUtils.isNullOrEmpty(readResultItem.getLines())) {\n+                perPageFormLineList = getReadResultFormLines(readResultItem);\n+            }\n+\n+            // get form tables\n+            formPages.add(getFormPage(readResultItem, perPageTableList, perPageFormLineList));\n+        }\n+        return formPages;\n+    }\n+\n+    /**\n+     * The field map returned on analyze with an unlabeled model id.\n+     *\n+     * @param documentResultItem The extracted document level information.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The {@code RecognizedForm#getFields}.\n+     */\n+    private static Map<String, FormField<?>> getLabeledFieldMap(DocumentResult documentResultItem,\n+        List<ReadResult> readResults, boolean includeTextDetails) {\n+        Map<String, FormField<?>> extractedFieldMap = new TreeMap<>();\n+        // add receipt fields\n+        documentResultItem.getFields().forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formContentList = null;\n+            Integer pageNumber = fieldValue.getPage();\n+            if (includeTextDetails && !(CoreUtils.isNullOrEmpty(fieldValue.getElements()))) {\n+                formContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n+            }\n+            FieldText labelText = new FieldText(key, null, fieldValue.getPage(), null);\n+            FieldText valueText = new FieldText(fieldValue.getText(), null, pageNumber, formContentList);\n+            extractedFieldMap.put(key, setFormField(labelText, key, fieldValue, valueText, pageNumber, readResults));\n+        });\n+        return extractedFieldMap;\n+    }\n+\n+    /**\n+     * Helper method that converts the incoming service field value to one of the strongly typed SDK level\n+     * {@link FormField} with reference elements set when {@code includeTextDetails} is set to true.\n+     *\n+     * @param labelText The label text of the field.\n+     * @param key The name of the field.\n      * @param fieldValue The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param valueText The value text of the field.\n+     * @param pageNumber The 1-based page number.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return The strongly typed {@link FieldValue} for the field input.\n+     * @return The strongly typed {@link FormField} for the field input.\n      */\n-    private static FieldValue<?> setFieldValue(com.azure.ai.formrecognizer.implementation.models.FieldValue fieldValue,\n-                                               List<ReadResult> readResults, boolean includeTextDetails) {\n-        FieldValue<?> value;\n+    private static FormField<?> setFormField(FieldText labelText, String key, FieldValue fieldValue, FieldText valueText, Integer pageNumber, List<ReadResult> readResults) {\n+        FormField<?> value;\n         switch (fieldValue.getType()) {\n             case PHONE_NUMBER:\n-                value = toFieldValuePhoneNumber(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValuePhoneNumber(), valueText, pageNumber);\n                 break;\n             case STRING:\n-                value = toFieldValueString(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueString(), valueText, pageNumber);\n                 break;\n             case TIME:\n-                value = toFieldValueTime(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueTime(), valueText, pageNumber);\n                 break;\n             case DATE:\n-                value = toFieldValueDate(fieldValue);\n+                value = new FormField<LocalDate>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueDate(), valueText, pageNumber);\n                 break;\n             case INTEGER:\n-                value = toFieldValueInteger(fieldValue);\n+                value = new FormField<Integer>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueInteger(), valueText, pageNumber);\n                 break;\n             case NUMBER:\n-                value = toFieldValueNumber(fieldValue);\n+                value = new FormField<Number>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueNumber(), valueText, pageNumber);\n                 break;\n             case ARRAY:\n+                value = new FormField<List<FormField<?>>>(null, null, key,\n+                    toFormFieldArray(fieldValue.getValueArray(), readResults), null, pageNumber);\n+                break;\n             case OBJECT:\n+                value = new FormField<Map<String, FormField<?>>>(fieldValue.getConfidence(), labelText,\n+                    key, toFormFieldObject(fieldValue.getValueObject(), pageNumber, readResults), valueText, pageNumber);\n+                break;\n             default:\n                 throw LOGGER.logExceptionAsError(new RuntimeException(\"FieldValue Type not supported\"));\n         }\n-        if (includeTextDetails) {\n-            value.setElements(setReferenceElements(readResults, fieldValue.getElements()));\n-        }\n         return value;\n     }\n \n     /**\n-     * Helper method that converts the service returned page information to SDK model {@link PageMetadata}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueObject()}\n+     * to a SDK level map of {@link FormField}.\n      *\n-     * @param readResultItem A read result item returned from the service containing the page information for provided\n-     * input.\n+     * @param valueObject The array of field values returned by the service in\n+     * {@link FieldValue#getValueObject()} .\n      *\n-     * @return The {@link PageMetadata} for the receipt page.\n+     * @return The Map of {@link FormField}.\n      */\n-    private static PageMetadata getPageInfo(ReadResult readResultItem) {\n-        return new PageMetadata(readResultItem.getHeight(), readResultItem.getPage(), readResultItem.getWidth(),\n-            readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n-    }\n-\n-    /**\n-     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n-     *\n-     * @param readResults The ReadResult containing the resolved references for text elements.\n-     * @param elements When includeTextDetails is set to true, a list of references to the text\n-     * elements constituting this field value.\n-     *\n-     * @return The updated {@link FieldValue} object with list if referenced elements.\n-     */\n-    private static List<Element> setReferenceElements(List<ReadResult> readResults, List<String> elements) {\n-        List<Element> elementList = new ArrayList<>();\n-        elements.forEach(elementString -> {\n-            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n-            int readResultIndex, lineIndex;\n-            if (indices.length >= 1) {\n-                readResultIndex = Integer.parseInt(indices[0]);\n-                lineIndex = Integer.parseInt(indices[1]);\n-            } else {\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n-            }\n-            if (indices.length == 3) {\n-                int wordIndex = Integer.parseInt(indices[2]);\n-                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n-                    .get(wordIndex);\n-                WordElement wordElement = new WordElement(textWord.getText(), toBoundingBox(textWord.getBoundingBox()));\n-                elementList.add(wordElement);\n-            } else {\n-                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n-                LineElement lineElement = new LineElement(textLine.getText(), toBoundingBox(textLine.getBoundingBox()));\n-                elementList.add(lineElement);\n+    private static Map<String, FormField<?>> toFormFieldObject(Map<String, FieldValue> valueObject, Integer pageNumber, List<ReadResult> readResults) {\n+        Map<String, FormField<?>> fieldValueObjectMap = new TreeMap<>();\n+        valueObject.forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (!CoreUtils.isNullOrEmpty(fieldValue.getElements())) {\n+                formValueContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n             }\n+            fieldValueObjectMap.put(key, setFormField(null, key, fieldValue, new FieldText(fieldValue.getText(),\n+                    toBoundingBox(fieldValue.getBoundingBox()), fieldValue.getPage(), formValueContentList),\n+                fieldValue.getPage(), readResults));\n         });\n-        return elementList;\n+        return fieldValueObjectMap;\n     }\n \n     /**\n-     * Helper method to convert the service level modeled eight numbers representing the four points to SDK level\n-     * {@link BoundingBox}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray()}\n+     * to a SDK level List of {@link FormField}.\n      *\n-     * @param boundingBox A list of eight numbers representing the four points of a box.\n+     * @param valueArray The array of field values returned by the service in\n+     * {@link FieldValue#getValueArray()}.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return A {@link BoundingBox}.\n+     * @return The List of {@link FormField}.\n      */\n-    private static BoundingBox toBoundingBox(List<Float> boundingBox) {\n-        BoundingBox boundingBox1;\n-        if (boundingBox.size() == 8) {\n-            Point topLeft = new Point(boundingBox.get(0), boundingBox.get(1));\n-            Point topRight = new Point(boundingBox.get(2), boundingBox.get(3));\n-            Point bottomLeft = new Point(boundingBox.get(4), boundingBox.get(5));\n-            Point bottomRight = new Point(boundingBox.get(6), boundingBox.get(7));\n-            boundingBox1 = new BoundingBox(topLeft, topRight, bottomLeft, bottomRight);\n-        } else {\n-            return null;\n-        }\n-        return boundingBox1;\n+    private static List<FormField<?>> toFormFieldArray(List<FieldValue> valueArray, List<ReadResult> readResults) {\n+        return valueArray.stream().map(fieldValue -> setFormField(null, null, fieldValue, null, fieldValue.getPage(), readResults)).collect(Collectors.toList());\n     }\n \n     /**\n-     * Helper method to convert the service level {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray() value items}\n-     * to SDK level {@link ReceiptItem receipt items}.\n+     * Helper method to convert the page results to {@code FormPage form pages}.\n      *\n-     * @param fieldValueItems The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n+     * @param perPageTableList The per page tables list.\n+     * @param perPageLineList The per page form lines.\n      *\n-     * @return A list of {@link ReceiptItem}.\n+     * @return The per page {@code FormPage}.\n      */\n-    private static List<ReceiptItem> toReceiptItems(\n-        List<com.azure.ai.formrecognizer.implementation.models.FieldValue> fieldValueItems, List<ReadResult> readResults, boolean includeTextDetails) {\n-        List<ReceiptItem> receiptItemList = new ArrayList<>();\n-        for (com.azure.ai.formrecognizer.implementation.models.FieldValue eachFieldValue : fieldValueItems) {\n-            ReceiptItem receiptItem = new ReceiptItem();\n-\n-            for (ReceiptItemType key : ReceiptItemType.values()) {\n-                com.azure.ai.formrecognizer.implementation.models.FieldValue item = eachFieldValue.getValueObject().get(key.toString());\n-                if (QUANTITY.equals(key) && item != null) {\n-                    receiptItem.setQuantity(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (NAME.equals(key) && item != null) {\n-                    receiptItem.setName(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (PRICE.equals(key) && item != null) {\n-                    receiptItem.setPrice(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (TOTAL_PRICE.equals(key) && item != null) {\n-                    receiptItem.setTotalPrice(setFieldValue(item, readResults, includeTextDetails));\n-                }\n-            }\n-            receiptItemList.add(receiptItem);\n-        }\n-        return receiptItemList;\n+    private static FormPage getFormPage(ReadResult readResultItem, List<FormTable> perPageTableList,\n+        List<FormLine> perPageLineList) {\n+        return new FormPage(readResultItem.getHeight(), readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()), readResultItem.getWidth(), perPageLineList,\n+            perPageTableList\n+        );\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}\n-     * to a SDK level {@link IntegerValue}\n+     * Helper method to get per-page table information.\n      *\n-     * @param serviceIntegerValue The integer value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link IntegerValue}.\n+     * @return The list of per page {@code FormTable}.\n      */\n-    private static IntegerValue toFieldValueInteger(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                        serviceIntegerValue) {\n-        if (serviceIntegerValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()),\n-                serviceIntegerValue.getValueInteger(), serviceIntegerValue.getPage());\n-        }\n-\n-        return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()), null, serviceIntegerValue.getPage());\n+    static List<FormTable> getPageTables(PageResult pageResultItem, Integer pageNumber) {\n+        List<FormTable> extractedTablesList = new ArrayList<>();\n+        pageResultItem.getTables().forEach(dataTable -> {\n+            List<FormTableCell> tableCellList = dataTable.getCells().stream()\n+                .map(dataTableCell -> new FormTableCell(dataTableCell.getRowIndex(), dataTableCell.getColumnIndex(),\n+                    dataTableCell.getRowSpan(), dataTableCell.getColumnSpan(),\n+                    dataTableCell.getText(), toBoundingBox(dataTableCell.getBoundingBox()),\n+                    dataTableCell.getConfidence(), null,\n+                    dataTableCell.isHeader() == null ? false : dataTableCell.isHeader(),\n+                    dataTableCell.isFooter() == null ? false : dataTableCell.isHeader(),\n+                    pageNumber))\n+                .collect(Collectors.toList());\n+            FormTable extractedTable = new FormTable(dataTable.getRows(), dataTable.getColumns(), tableCellList);\n+            extractedTablesList.add(extractedTable);\n+        });\n+        return extractedTablesList;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}\n-     * to a SDK level {@link StringValue}.\n+     * Helper method to convert the per page {@link ReadResult} item to {@link FormLine}.\n      *\n-     * @param serviceStringValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list of {@code FormLine}.\n      */\n-    private static StringValue toFieldValueString(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                      serviceStringValue) {\n-        return new StringValue(serviceStringValue.getText(), toBoundingBox(serviceStringValue.getBoundingBox()),\n-            serviceStringValue.getValueString(), serviceStringValue.getPage());\n+    static List<FormLine> getReadResultFormLines(ReadResult readResultItem) {\n+        List<FormLine> formLines = readResultItem.getLines().stream()\n+            .map(textLine -> new FormLine(textLine.getText(), toBoundingBox(textLine.getBoundingBox()),\n+                readResultItem.getPage(), new IterableStream<>(toWords(textLine.getWords(), readResultItem.getPage()))))\n+            .collect(Collectors.toList());\n+        return formLines;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()}\n-     * to a SDK level {@link FloatValue}.\n+     * Helper method to set the {@link RecognizedForm#getFields() fields} from unlabeled result returned from the service.\n      *\n-     * @param serviceFloatValue The float value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()} .\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link FloatValue}.\n+     * @return The fields populated on {@link RecognizedForm#getFields() fields}.\n      */\n-    private static FloatValue toFieldValueNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                     serviceFloatValue) {\n-        if (serviceFloatValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()),\n-                serviceFloatValue.getValueNumber(), serviceFloatValue.getPage());\n-        }\n+    static Map<String, FormField<?>> getUnlabeledFieldMap(boolean includeTextDetails, List<ReadResult> readResults,\n+        PageResult pageResultItem, Integer pageNumber) {\n+        Map<String, FormField<?>> formFieldMap = new TreeMap<>();\n+        List<KeyValuePair> keyValuePairs = pageResultItem.getKeyValuePairs();\n+        for (int i = 0; i < keyValuePairs.size(); i++) {\n+            KeyValuePair keyValuePair = keyValuePairs.get(i);\n+            IterableStream<FormContent> formKeyContentList = null;\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (includeTextDetails && !CoreUtils.isNullOrEmpty(keyValuePair.getValue().getElements())) {\n+                formKeyContentList = setReferenceElements(keyValuePair.getKey().getElements(), readResults, pageNumber);\n+                formValueContentList = setReferenceElements(keyValuePair.getValue().getElements(), readResults, pageNumber);\n \n-        return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()), null, serviceFloatValue.getPage());\n+            }\n+            String fieldName = \"field-\" + i;\n+            FieldText labelFieldText = new FieldText(keyValuePair.getKey().getText(), toBoundingBox(keyValuePair.getKey().getBoundingBox()), pageNumber, formKeyContentList);\n+            FieldText valueText = new FieldText(keyValuePair.getValue().getText(), toBoundingBox(keyValuePair.getValue().getBoundingBox()), pageNumber, formValueContentList);\n+            FormField<String> formField = new FormField<>(keyValuePair.getConfidence(), labelFieldText, fieldName, keyValuePair.getValue().getText(), valueText, pageNumber);\n+            formFieldMap.put(fieldName, formField);\n+        }\n+        return formFieldMap;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}\n-     * to a SDK level {@link StringValue}.\n-     *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}.\n+     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list if referenced elements.\n      */\n-    private static StringValue toFieldValuePhoneNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                  serviceDateValue) {\n-        return new StringValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValuePhoneNumber(), serviceDateValue.getPage());\n+    private static IterableStream<FormContent> setReferenceElements(List<String> elements, List<ReadResult> readResults, Integer pageNumber) {\n+        List<FormContent> formContentList = new ArrayList<>();\n+        elements.forEach(elementString -> {\n+            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n+            int readResultIndex, lineIndex;\n+            if (indices.length >= 1) {\n+                readResultIndex = Integer.parseInt(indices[0]);\n+                lineIndex = Integer.parseInt(indices[1]);\n+            } else {\n+                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n+            }\n+            if (indices.length == 3) {\n+                int wordIndex = Integer.parseInt(indices[2]);\n+                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n+                    .get(wordIndex);\n+                FormWord wordElement = new FormWord(textWord.getText(), toBoundingBox(textWord.getBoundingBox()), pageNumber, textWord.getConfidence());\n+                formContentList.add(wordElement);\n+            } else {\n+                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n+                FormLine lineElement = new FormLine(textLine.getText(), toBoundingBox(textLine.getBoundingBox()), pageNumber, toWords(textLine.getWords(), pageNumber));\n+                formContentList.add(lineElement);\n+            }\n+        });\n+        return new IterableStream<>(formContentList);\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueDate()}\n-     * to a SDK level {@link DateValue}.\n+     * Helper method to convert the service level {@link TextWord}  to list of SDK level model {@link FormWord}.\n      *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueDate()}.\n+     * @param words A list of word reference elements returned by the service.\n+     * @param pageNumber The 1 based page number on which this word element exists.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list of {@code FormWord words}.\n      */\n-    private static DateValue toFieldValueDate(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                      serviceDateValue) {\n-        return new DateValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValueDate(), serviceDateValue.getPage());\n+    static IterableStream<FormWord> toWords(List<TextWord> words, Integer pageNumber) {\n+        List<FormWord> extractedWordList = words.stream()\n+            .map(textWord -> new FormWord(textWord.getText(), toBoundingBox(textWord.getBoundingBox()), pageNumber,\n+                textWord.getConfidence())).collect(Collectors.toList());\n+        return new IterableStream<FormWord>(extractedWordList);\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueTime()}\n-     * to a SDK level {@link TimeValue}.\n-     *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueTime()} .\n+     * Helper method to convert the service level modeled eight numbers representing the four points to SDK level\n+     * {@link BoundingBox}.\n      *\n-     * @return The {@link TimeValue}.\n+     * @param serviceBoundingBox A list of eight numbers representing the four points of a box.\n      *\n+     * @return A {@link BoundingBox}.\n      */\n-    private static TimeValue toFieldValueTime(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                  serviceDateValue) {\n-        return new TimeValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValueTime(), serviceDateValue.getPage());\n-        // TODO: currently returning a string, waiting on swagger update.\n+    private static BoundingBox toBoundingBox(List<Float> serviceBoundingBox) {\n+        if (CoreUtils.isNullOrEmpty(serviceBoundingBox)) {", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MzgzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407583835", "bodyText": "Since BoundingBox infers a box shape, four corners, should it accept the specific points as parameters in the constructor? Unless BoundingBox is meant to be more generic and should be renamed BoundingArea. Magic parameter ordering in lists is generally a confusing API design.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:51:58Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -52,326 +51,383 @@ private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap = null;\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n \n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult);\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (int i = 0; i < documentResults.size(); i++) {\n+\n+                DocumentResult documentResultItem = documentResults.get(i);\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getLabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n \n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+            extractedFormList.add(new RecognizedForm(extractedFieldMap, formType.get(), pageRange.get(),\n+                new IterableStream<FormPage>(formPages.subList(pageRange.get().getStartPageNumber(), pageRange.get().getEndPageNumber()))));\n+        }\n+\n+        // labeled\n+        if (pageResults != null) {\n+            for (int i = 0; i < pageResults.size(); i++) {\n+                PageResult pageResultItem = pageResults.get(i);\n+                Integer pageNumber = pageResultItem.getPage();\n+\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getUnlabeledFieldMap(includeTextDetails, readResults, pageResultItem, pageNumber);\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+                extractedFormList.add(\n+                    new RecognizedForm(extractedFieldMap, formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<FormPage>(Arrays.asList(formPages.get(pageNumber - 1)))));\n+            }\n         }\n+        return extractedFormList;\n+    }\n+\n+    /**\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n+     *\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n+     */\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<RecognizedReceipt> extractedReceiptList =\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm)).collect(Collectors.toList());\n+\n         return new IterableStream<>(extractedReceiptList);\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n+     * @param analyzeResult The service returned result for analyze layouts.\n+     *\n+     * @return The IterableStream of {@code FormPage}.\n+     */\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        for (int i = 0; i < readResults.size(); i++) {\n+            ReadResult readResultItem = readResults.get(i);\n+            PageResult pageResultItem;\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+                pageResultItem = pageResults.get(i);\n+                perPageTableList = getPageTables(pageResultItem, pageResultItem.getPage());\n+            }\n+\n+            // add form lines\n+            List<FormLine> perPageFormLineList = new ArrayList<>();\n+            if (!CoreUtils.isNullOrEmpty(readResultItem.getLines())) {\n+                perPageFormLineList = getReadResultFormLines(readResultItem);\n+            }\n+\n+            // get form tables\n+            formPages.add(getFormPage(readResultItem, perPageTableList, perPageFormLineList));\n+        }\n+        return formPages;\n+    }\n+\n+    /**\n+     * The field map returned on analyze with an unlabeled model id.\n+     *\n+     * @param documentResultItem The extracted document level information.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The {@code RecognizedForm#getFields}.\n+     */\n+    private static Map<String, FormField<?>> getLabeledFieldMap(DocumentResult documentResultItem,\n+        List<ReadResult> readResults, boolean includeTextDetails) {\n+        Map<String, FormField<?>> extractedFieldMap = new TreeMap<>();\n+        // add receipt fields\n+        documentResultItem.getFields().forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formContentList = null;\n+            Integer pageNumber = fieldValue.getPage();\n+            if (includeTextDetails && !(CoreUtils.isNullOrEmpty(fieldValue.getElements()))) {\n+                formContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n+            }\n+            FieldText labelText = new FieldText(key, null, fieldValue.getPage(), null);\n+            FieldText valueText = new FieldText(fieldValue.getText(), null, pageNumber, formContentList);\n+            extractedFieldMap.put(key, setFormField(labelText, key, fieldValue, valueText, pageNumber, readResults));\n+        });\n+        return extractedFieldMap;\n+    }\n+\n+    /**\n+     * Helper method that converts the incoming service field value to one of the strongly typed SDK level\n+     * {@link FormField} with reference elements set when {@code includeTextDetails} is set to true.\n+     *\n+     * @param labelText The label text of the field.\n+     * @param key The name of the field.\n      * @param fieldValue The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param valueText The value text of the field.\n+     * @param pageNumber The 1-based page number.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return The strongly typed {@link FieldValue} for the field input.\n+     * @return The strongly typed {@link FormField} for the field input.\n      */\n-    private static FieldValue<?> setFieldValue(com.azure.ai.formrecognizer.implementation.models.FieldValue fieldValue,\n-                                               List<ReadResult> readResults, boolean includeTextDetails) {\n-        FieldValue<?> value;\n+    private static FormField<?> setFormField(FieldText labelText, String key, FieldValue fieldValue, FieldText valueText, Integer pageNumber, List<ReadResult> readResults) {\n+        FormField<?> value;\n         switch (fieldValue.getType()) {\n             case PHONE_NUMBER:\n-                value = toFieldValuePhoneNumber(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValuePhoneNumber(), valueText, pageNumber);\n                 break;\n             case STRING:\n-                value = toFieldValueString(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueString(), valueText, pageNumber);\n                 break;\n             case TIME:\n-                value = toFieldValueTime(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueTime(), valueText, pageNumber);\n                 break;\n             case DATE:\n-                value = toFieldValueDate(fieldValue);\n+                value = new FormField<LocalDate>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueDate(), valueText, pageNumber);\n                 break;\n             case INTEGER:\n-                value = toFieldValueInteger(fieldValue);\n+                value = new FormField<Integer>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueInteger(), valueText, pageNumber);\n                 break;\n             case NUMBER:\n-                value = toFieldValueNumber(fieldValue);\n+                value = new FormField<Number>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueNumber(), valueText, pageNumber);\n                 break;\n             case ARRAY:\n+                value = new FormField<List<FormField<?>>>(null, null, key,\n+                    toFormFieldArray(fieldValue.getValueArray(), readResults), null, pageNumber);\n+                break;\n             case OBJECT:\n+                value = new FormField<Map<String, FormField<?>>>(fieldValue.getConfidence(), labelText,\n+                    key, toFormFieldObject(fieldValue.getValueObject(), pageNumber, readResults), valueText, pageNumber);\n+                break;\n             default:\n                 throw LOGGER.logExceptionAsError(new RuntimeException(\"FieldValue Type not supported\"));\n         }\n-        if (includeTextDetails) {\n-            value.setElements(setReferenceElements(readResults, fieldValue.getElements()));\n-        }\n         return value;\n     }\n \n     /**\n-     * Helper method that converts the service returned page information to SDK model {@link PageMetadata}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueObject()}\n+     * to a SDK level map of {@link FormField}.\n      *\n-     * @param readResultItem A read result item returned from the service containing the page information for provided\n-     * input.\n+     * @param valueObject The array of field values returned by the service in\n+     * {@link FieldValue#getValueObject()} .\n      *\n-     * @return The {@link PageMetadata} for the receipt page.\n+     * @return The Map of {@link FormField}.\n      */\n-    private static PageMetadata getPageInfo(ReadResult readResultItem) {\n-        return new PageMetadata(readResultItem.getHeight(), readResultItem.getPage(), readResultItem.getWidth(),\n-            readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n-    }\n-\n-    /**\n-     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n-     *\n-     * @param readResults The ReadResult containing the resolved references for text elements.\n-     * @param elements When includeTextDetails is set to true, a list of references to the text\n-     * elements constituting this field value.\n-     *\n-     * @return The updated {@link FieldValue} object with list if referenced elements.\n-     */\n-    private static List<Element> setReferenceElements(List<ReadResult> readResults, List<String> elements) {\n-        List<Element> elementList = new ArrayList<>();\n-        elements.forEach(elementString -> {\n-            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n-            int readResultIndex, lineIndex;\n-            if (indices.length >= 1) {\n-                readResultIndex = Integer.parseInt(indices[0]);\n-                lineIndex = Integer.parseInt(indices[1]);\n-            } else {\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n-            }\n-            if (indices.length == 3) {\n-                int wordIndex = Integer.parseInt(indices[2]);\n-                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n-                    .get(wordIndex);\n-                WordElement wordElement = new WordElement(textWord.getText(), toBoundingBox(textWord.getBoundingBox()));\n-                elementList.add(wordElement);\n-            } else {\n-                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n-                LineElement lineElement = new LineElement(textLine.getText(), toBoundingBox(textLine.getBoundingBox()));\n-                elementList.add(lineElement);\n+    private static Map<String, FormField<?>> toFormFieldObject(Map<String, FieldValue> valueObject, Integer pageNumber, List<ReadResult> readResults) {\n+        Map<String, FormField<?>> fieldValueObjectMap = new TreeMap<>();\n+        valueObject.forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (!CoreUtils.isNullOrEmpty(fieldValue.getElements())) {\n+                formValueContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n             }\n+            fieldValueObjectMap.put(key, setFormField(null, key, fieldValue, new FieldText(fieldValue.getText(),\n+                    toBoundingBox(fieldValue.getBoundingBox()), fieldValue.getPage(), formValueContentList),\n+                fieldValue.getPage(), readResults));\n         });\n-        return elementList;\n+        return fieldValueObjectMap;\n     }\n \n     /**\n-     * Helper method to convert the service level modeled eight numbers representing the four points to SDK level\n-     * {@link BoundingBox}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray()}\n+     * to a SDK level List of {@link FormField}.\n      *\n-     * @param boundingBox A list of eight numbers representing the four points of a box.\n+     * @param valueArray The array of field values returned by the service in\n+     * {@link FieldValue#getValueArray()}.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return A {@link BoundingBox}.\n+     * @return The List of {@link FormField}.\n      */\n-    private static BoundingBox toBoundingBox(List<Float> boundingBox) {\n-        BoundingBox boundingBox1;\n-        if (boundingBox.size() == 8) {\n-            Point topLeft = new Point(boundingBox.get(0), boundingBox.get(1));\n-            Point topRight = new Point(boundingBox.get(2), boundingBox.get(3));\n-            Point bottomLeft = new Point(boundingBox.get(4), boundingBox.get(5));\n-            Point bottomRight = new Point(boundingBox.get(6), boundingBox.get(7));\n-            boundingBox1 = new BoundingBox(topLeft, topRight, bottomLeft, bottomRight);\n-        } else {\n-            return null;\n-        }\n-        return boundingBox1;\n+    private static List<FormField<?>> toFormFieldArray(List<FieldValue> valueArray, List<ReadResult> readResults) {\n+        return valueArray.stream().map(fieldValue -> setFormField(null, null, fieldValue, null, fieldValue.getPage(), readResults)).collect(Collectors.toList());\n     }\n \n     /**\n-     * Helper method to convert the service level {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray() value items}\n-     * to SDK level {@link ReceiptItem receipt items}.\n+     * Helper method to convert the page results to {@code FormPage form pages}.\n      *\n-     * @param fieldValueItems The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n+     * @param perPageTableList The per page tables list.\n+     * @param perPageLineList The per page form lines.\n      *\n-     * @return A list of {@link ReceiptItem}.\n+     * @return The per page {@code FormPage}.\n      */\n-    private static List<ReceiptItem> toReceiptItems(\n-        List<com.azure.ai.formrecognizer.implementation.models.FieldValue> fieldValueItems, List<ReadResult> readResults, boolean includeTextDetails) {\n-        List<ReceiptItem> receiptItemList = new ArrayList<>();\n-        for (com.azure.ai.formrecognizer.implementation.models.FieldValue eachFieldValue : fieldValueItems) {\n-            ReceiptItem receiptItem = new ReceiptItem();\n-\n-            for (ReceiptItemType key : ReceiptItemType.values()) {\n-                com.azure.ai.formrecognizer.implementation.models.FieldValue item = eachFieldValue.getValueObject().get(key.toString());\n-                if (QUANTITY.equals(key) && item != null) {\n-                    receiptItem.setQuantity(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (NAME.equals(key) && item != null) {\n-                    receiptItem.setName(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (PRICE.equals(key) && item != null) {\n-                    receiptItem.setPrice(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (TOTAL_PRICE.equals(key) && item != null) {\n-                    receiptItem.setTotalPrice(setFieldValue(item, readResults, includeTextDetails));\n-                }\n-            }\n-            receiptItemList.add(receiptItem);\n-        }\n-        return receiptItemList;\n+    private static FormPage getFormPage(ReadResult readResultItem, List<FormTable> perPageTableList,\n+        List<FormLine> perPageLineList) {\n+        return new FormPage(readResultItem.getHeight(), readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()), readResultItem.getWidth(), perPageLineList,\n+            perPageTableList\n+        );\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}\n-     * to a SDK level {@link IntegerValue}\n+     * Helper method to get per-page table information.\n      *\n-     * @param serviceIntegerValue The integer value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link IntegerValue}.\n+     * @return The list of per page {@code FormTable}.\n      */\n-    private static IntegerValue toFieldValueInteger(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                        serviceIntegerValue) {\n-        if (serviceIntegerValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()),\n-                serviceIntegerValue.getValueInteger(), serviceIntegerValue.getPage());\n-        }\n-\n-        return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()), null, serviceIntegerValue.getPage());\n+    static List<FormTable> getPageTables(PageResult pageResultItem, Integer pageNumber) {\n+        List<FormTable> extractedTablesList = new ArrayList<>();\n+        pageResultItem.getTables().forEach(dataTable -> {\n+            List<FormTableCell> tableCellList = dataTable.getCells().stream()\n+                .map(dataTableCell -> new FormTableCell(dataTableCell.getRowIndex(), dataTableCell.getColumnIndex(),\n+                    dataTableCell.getRowSpan(), dataTableCell.getColumnSpan(),\n+                    dataTableCell.getText(), toBoundingBox(dataTableCell.getBoundingBox()),\n+                    dataTableCell.getConfidence(), null,\n+                    dataTableCell.isHeader() == null ? false : dataTableCell.isHeader(),\n+                    dataTableCell.isFooter() == null ? false : dataTableCell.isHeader(),\n+                    pageNumber))\n+                .collect(Collectors.toList());\n+            FormTable extractedTable = new FormTable(dataTable.getRows(), dataTable.getColumns(), tableCellList);\n+            extractedTablesList.add(extractedTable);\n+        });\n+        return extractedTablesList;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}\n-     * to a SDK level {@link StringValue}.\n+     * Helper method to convert the per page {@link ReadResult} item to {@link FormLine}.\n      *\n-     * @param serviceStringValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list of {@code FormLine}.\n      */\n-    private static StringValue toFieldValueString(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                      serviceStringValue) {\n-        return new StringValue(serviceStringValue.getText(), toBoundingBox(serviceStringValue.getBoundingBox()),\n-            serviceStringValue.getValueString(), serviceStringValue.getPage());\n+    static List<FormLine> getReadResultFormLines(ReadResult readResultItem) {\n+        List<FormLine> formLines = readResultItem.getLines().stream()\n+            .map(textLine -> new FormLine(textLine.getText(), toBoundingBox(textLine.getBoundingBox()),\n+                readResultItem.getPage(), new IterableStream<>(toWords(textLine.getWords(), readResultItem.getPage()))))\n+            .collect(Collectors.toList());\n+        return formLines;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()}\n-     * to a SDK level {@link FloatValue}.\n+     * Helper method to set the {@link RecognizedForm#getFields() fields} from unlabeled result returned from the service.\n      *\n-     * @param serviceFloatValue The float value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()} .\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link FloatValue}.\n+     * @return The fields populated on {@link RecognizedForm#getFields() fields}.\n      */\n-    private static FloatValue toFieldValueNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                     serviceFloatValue) {\n-        if (serviceFloatValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()),\n-                serviceFloatValue.getValueNumber(), serviceFloatValue.getPage());\n-        }\n+    static Map<String, FormField<?>> getUnlabeledFieldMap(boolean includeTextDetails, List<ReadResult> readResults,\n+        PageResult pageResultItem, Integer pageNumber) {\n+        Map<String, FormField<?>> formFieldMap = new TreeMap<>();\n+        List<KeyValuePair> keyValuePairs = pageResultItem.getKeyValuePairs();\n+        for (int i = 0; i < keyValuePairs.size(); i++) {\n+            KeyValuePair keyValuePair = keyValuePairs.get(i);\n+            IterableStream<FormContent> formKeyContentList = null;\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (includeTextDetails && !CoreUtils.isNullOrEmpty(keyValuePair.getValue().getElements())) {\n+                formKeyContentList = setReferenceElements(keyValuePair.getKey().getElements(), readResults, pageNumber);\n+                formValueContentList = setReferenceElements(keyValuePair.getValue().getElements(), readResults, pageNumber);\n \n-        return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()), null, serviceFloatValue.getPage());\n+            }\n+            String fieldName = \"field-\" + i;\n+            FieldText labelFieldText = new FieldText(keyValuePair.getKey().getText(), toBoundingBox(keyValuePair.getKey().getBoundingBox()), pageNumber, formKeyContentList);\n+            FieldText valueText = new FieldText(keyValuePair.getValue().getText(), toBoundingBox(keyValuePair.getValue().getBoundingBox()), pageNumber, formValueContentList);\n+            FormField<String> formField = new FormField<>(keyValuePair.getConfidence(), labelFieldText, fieldName, keyValuePair.getValue().getText(), valueText, pageNumber);\n+            formFieldMap.put(fieldName, formField);\n+        }\n+        return formFieldMap;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}\n-     * to a SDK level {@link StringValue}.\n-     *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}.\n+     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list if referenced elements.\n      */\n-    private static StringValue toFieldValuePhoneNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                  serviceDateValue) {\n-        return new StringValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValuePhoneNumber(), serviceDateValue.getPage());\n+    private static IterableStream<FormContent> setReferenceElements(List<String> elements, List<ReadResult> readResults, Integer pageNumber) {\n+        List<FormContent> formContentList = new ArrayList<>();\n+        elements.forEach(elementString -> {\n+            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n+            int readResultIndex, lineIndex;\n+            if (indices.length >= 1) {\n+                readResultIndex = Integer.parseInt(indices[0]);\n+                lineIndex = Integer.parseInt(indices[1]);\n+            } else {\n+                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n+            }\n+            if (indices.length == 3) {\n+                int wordIndex = Integer.parseInt(indices[2]);\n+                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n+                    .get(wordIndex);\n+                FormWord wordElement = new FormWord(textWord.getText(), toBoundingBox(textWord.getBoundingBox()), pageNumber, textWord.getConfidence());\n+                formContentList.add(wordElement);\n+            } else {\n+                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n+                FormLine lineElement = new FormLine(textLine.getText(), toBoundingBox(textLine.getBoundingBox()), pageNumber, toWords(textLine.getWords(), pageNumber));\n+                formContentList.add(lineElement);\n+            }\n+        });\n+        return new IterableStream<>(formContentList);\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueDate()}\n-     * to a SDK level {@link DateValue}.\n+     * Helper method to convert the service level {@link TextWord}  to list of SDK level model {@link FormWord}.\n      *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueDate()}.\n+     * @param words A list of word reference elements returned by the service.\n+     * @param pageNumber The 1 based page number on which this word element exists.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list of {@code FormWord words}.\n      */\n-    private static DateValue toFieldValueDate(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                      serviceDateValue) {\n-        return new DateValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValueDate(), serviceDateValue.getPage());\n+    static IterableStream<FormWord> toWords(List<TextWord> words, Integer pageNumber) {\n+        List<FormWord> extractedWordList = words.stream()\n+            .map(textWord -> new FormWord(textWord.getText(), toBoundingBox(textWord.getBoundingBox()), pageNumber,\n+                textWord.getConfidence())).collect(Collectors.toList());\n+        return new IterableStream<FormWord>(extractedWordList);\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueTime()}\n-     * to a SDK level {@link TimeValue}.\n-     *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueTime()} .\n+     * Helper method to convert the service level modeled eight numbers representing the four points to SDK level\n+     * {@link BoundingBox}.\n      *\n-     * @return The {@link TimeValue}.\n+     * @param serviceBoundingBox A list of eight numbers representing the four points of a box.\n      *\n+     * @return A {@link BoundingBox}.\n      */\n-    private static TimeValue toFieldValueTime(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                  serviceDateValue) {\n-        return new TimeValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValueTime(), serviceDateValue.getPage());\n-        // TODO: currently returning a string, waiting on swagger update.\n+    private static BoundingBox toBoundingBox(List<Float> serviceBoundingBox) {\n+        if (CoreUtils.isNullOrEmpty(serviceBoundingBox)) {\n+            return null;\n+        }\n+        Point topLeft = new Point(serviceBoundingBox.get(0), serviceBoundingBox.get(1));\n+        Point topRight = new Point(serviceBoundingBox.get(2), serviceBoundingBox.get(3));\n+        Point bottomLeft = new Point(serviceBoundingBox.get(4), serviceBoundingBox.get(5));\n+        Point bottomRight = new Point(serviceBoundingBox.get(6), serviceBoundingBox.get(7));\n+        return new BoundingBox(Arrays.asList(topLeft, topRight, bottomLeft, bottomRight));", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MzY1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407783653", "bodyText": "It was originally designed to be accepting specific four parameters in the constructor but with service feedback that it could be in future grow to accept more than just 8 points extended, updated this to accept a list.", "author": "samvaity", "createdAt": "2020-04-13T23:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MzgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4NjQyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407586426", "bodyText": "Could we renamed the Pattern to something that reflects its purpose?", "author": "alzimmermsft", "createdAt": "2020-04-13T16:56:36Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -52,326 +51,383 @@ private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap = null;\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n \n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult);\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (int i = 0; i < documentResults.size(); i++) {\n+\n+                DocumentResult documentResultItem = documentResults.get(i);\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getLabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n \n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+            extractedFormList.add(new RecognizedForm(extractedFieldMap, formType.get(), pageRange.get(),\n+                new IterableStream<FormPage>(formPages.subList(pageRange.get().getStartPageNumber(), pageRange.get().getEndPageNumber()))));\n+        }\n+\n+        // labeled\n+        if (pageResults != null) {\n+            for (int i = 0; i < pageResults.size(); i++) {\n+                PageResult pageResultItem = pageResults.get(i);\n+                Integer pageNumber = pageResultItem.getPage();\n+\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getUnlabeledFieldMap(includeTextDetails, readResults, pageResultItem, pageNumber);\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+                extractedFormList.add(\n+                    new RecognizedForm(extractedFieldMap, formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<FormPage>(Arrays.asList(formPages.get(pageNumber - 1)))));\n+            }\n         }\n+        return extractedFormList;\n+    }\n+\n+    /**\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n+     *\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n+     */\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<RecognizedReceipt> extractedReceiptList =\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm)).collect(Collectors.toList());\n+\n         return new IterableStream<>(extractedReceiptList);\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n+     * @param analyzeResult The service returned result for analyze layouts.\n+     *\n+     * @return The IterableStream of {@code FormPage}.\n+     */\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        for (int i = 0; i < readResults.size(); i++) {\n+            ReadResult readResultItem = readResults.get(i);\n+            PageResult pageResultItem;\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+                pageResultItem = pageResults.get(i);\n+                perPageTableList = getPageTables(pageResultItem, pageResultItem.getPage());\n+            }\n+\n+            // add form lines\n+            List<FormLine> perPageFormLineList = new ArrayList<>();\n+            if (!CoreUtils.isNullOrEmpty(readResultItem.getLines())) {\n+                perPageFormLineList = getReadResultFormLines(readResultItem);\n+            }\n+\n+            // get form tables\n+            formPages.add(getFormPage(readResultItem, perPageTableList, perPageFormLineList));\n+        }\n+        return formPages;\n+    }\n+\n+    /**\n+     * The field map returned on analyze with an unlabeled model id.\n+     *\n+     * @param documentResultItem The extracted document level information.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The {@code RecognizedForm#getFields}.\n+     */\n+    private static Map<String, FormField<?>> getLabeledFieldMap(DocumentResult documentResultItem,\n+        List<ReadResult> readResults, boolean includeTextDetails) {\n+        Map<String, FormField<?>> extractedFieldMap = new TreeMap<>();\n+        // add receipt fields\n+        documentResultItem.getFields().forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formContentList = null;\n+            Integer pageNumber = fieldValue.getPage();\n+            if (includeTextDetails && !(CoreUtils.isNullOrEmpty(fieldValue.getElements()))) {\n+                formContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n+            }\n+            FieldText labelText = new FieldText(key, null, fieldValue.getPage(), null);\n+            FieldText valueText = new FieldText(fieldValue.getText(), null, pageNumber, formContentList);\n+            extractedFieldMap.put(key, setFormField(labelText, key, fieldValue, valueText, pageNumber, readResults));\n+        });\n+        return extractedFieldMap;\n+    }\n+\n+    /**\n+     * Helper method that converts the incoming service field value to one of the strongly typed SDK level\n+     * {@link FormField} with reference elements set when {@code includeTextDetails} is set to true.\n+     *\n+     * @param labelText The label text of the field.\n+     * @param key The name of the field.\n      * @param fieldValue The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param valueText The value text of the field.\n+     * @param pageNumber The 1-based page number.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return The strongly typed {@link FieldValue} for the field input.\n+     * @return The strongly typed {@link FormField} for the field input.\n      */\n-    private static FieldValue<?> setFieldValue(com.azure.ai.formrecognizer.implementation.models.FieldValue fieldValue,\n-                                               List<ReadResult> readResults, boolean includeTextDetails) {\n-        FieldValue<?> value;\n+    private static FormField<?> setFormField(FieldText labelText, String key, FieldValue fieldValue, FieldText valueText, Integer pageNumber, List<ReadResult> readResults) {\n+        FormField<?> value;\n         switch (fieldValue.getType()) {\n             case PHONE_NUMBER:\n-                value = toFieldValuePhoneNumber(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValuePhoneNumber(), valueText, pageNumber);\n                 break;\n             case STRING:\n-                value = toFieldValueString(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueString(), valueText, pageNumber);\n                 break;\n             case TIME:\n-                value = toFieldValueTime(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueTime(), valueText, pageNumber);\n                 break;\n             case DATE:\n-                value = toFieldValueDate(fieldValue);\n+                value = new FormField<LocalDate>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueDate(), valueText, pageNumber);\n                 break;\n             case INTEGER:\n-                value = toFieldValueInteger(fieldValue);\n+                value = new FormField<Integer>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueInteger(), valueText, pageNumber);\n                 break;\n             case NUMBER:\n-                value = toFieldValueNumber(fieldValue);\n+                value = new FormField<Number>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueNumber(), valueText, pageNumber);\n                 break;\n             case ARRAY:\n+                value = new FormField<List<FormField<?>>>(null, null, key,\n+                    toFormFieldArray(fieldValue.getValueArray(), readResults), null, pageNumber);\n+                break;\n             case OBJECT:\n+                value = new FormField<Map<String, FormField<?>>>(fieldValue.getConfidence(), labelText,\n+                    key, toFormFieldObject(fieldValue.getValueObject(), pageNumber, readResults), valueText, pageNumber);\n+                break;\n             default:\n                 throw LOGGER.logExceptionAsError(new RuntimeException(\"FieldValue Type not supported\"));\n         }\n-        if (includeTextDetails) {\n-            value.setElements(setReferenceElements(readResults, fieldValue.getElements()));\n-        }\n         return value;\n     }\n \n     /**\n-     * Helper method that converts the service returned page information to SDK model {@link PageMetadata}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueObject()}\n+     * to a SDK level map of {@link FormField}.\n      *\n-     * @param readResultItem A read result item returned from the service containing the page information for provided\n-     * input.\n+     * @param valueObject The array of field values returned by the service in\n+     * {@link FieldValue#getValueObject()} .\n      *\n-     * @return The {@link PageMetadata} for the receipt page.\n+     * @return The Map of {@link FormField}.\n      */\n-    private static PageMetadata getPageInfo(ReadResult readResultItem) {\n-        return new PageMetadata(readResultItem.getHeight(), readResultItem.getPage(), readResultItem.getWidth(),\n-            readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n-    }\n-\n-    /**\n-     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n-     *\n-     * @param readResults The ReadResult containing the resolved references for text elements.\n-     * @param elements When includeTextDetails is set to true, a list of references to the text\n-     * elements constituting this field value.\n-     *\n-     * @return The updated {@link FieldValue} object with list if referenced elements.\n-     */\n-    private static List<Element> setReferenceElements(List<ReadResult> readResults, List<String> elements) {\n-        List<Element> elementList = new ArrayList<>();\n-        elements.forEach(elementString -> {\n-            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n-            int readResultIndex, lineIndex;\n-            if (indices.length >= 1) {\n-                readResultIndex = Integer.parseInt(indices[0]);\n-                lineIndex = Integer.parseInt(indices[1]);\n-            } else {\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n-            }\n-            if (indices.length == 3) {\n-                int wordIndex = Integer.parseInt(indices[2]);\n-                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n-                    .get(wordIndex);\n-                WordElement wordElement = new WordElement(textWord.getText(), toBoundingBox(textWord.getBoundingBox()));\n-                elementList.add(wordElement);\n-            } else {\n-                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n-                LineElement lineElement = new LineElement(textLine.getText(), toBoundingBox(textLine.getBoundingBox()));\n-                elementList.add(lineElement);\n+    private static Map<String, FormField<?>> toFormFieldObject(Map<String, FieldValue> valueObject, Integer pageNumber, List<ReadResult> readResults) {\n+        Map<String, FormField<?>> fieldValueObjectMap = new TreeMap<>();\n+        valueObject.forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (!CoreUtils.isNullOrEmpty(fieldValue.getElements())) {\n+                formValueContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n             }\n+            fieldValueObjectMap.put(key, setFormField(null, key, fieldValue, new FieldText(fieldValue.getText(),\n+                    toBoundingBox(fieldValue.getBoundingBox()), fieldValue.getPage(), formValueContentList),\n+                fieldValue.getPage(), readResults));\n         });\n-        return elementList;\n+        return fieldValueObjectMap;\n     }\n \n     /**\n-     * Helper method to convert the service level modeled eight numbers representing the four points to SDK level\n-     * {@link BoundingBox}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray()}\n+     * to a SDK level List of {@link FormField}.\n      *\n-     * @param boundingBox A list of eight numbers representing the four points of a box.\n+     * @param valueArray The array of field values returned by the service in\n+     * {@link FieldValue#getValueArray()}.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return A {@link BoundingBox}.\n+     * @return The List of {@link FormField}.\n      */\n-    private static BoundingBox toBoundingBox(List<Float> boundingBox) {\n-        BoundingBox boundingBox1;\n-        if (boundingBox.size() == 8) {\n-            Point topLeft = new Point(boundingBox.get(0), boundingBox.get(1));\n-            Point topRight = new Point(boundingBox.get(2), boundingBox.get(3));\n-            Point bottomLeft = new Point(boundingBox.get(4), boundingBox.get(5));\n-            Point bottomRight = new Point(boundingBox.get(6), boundingBox.get(7));\n-            boundingBox1 = new BoundingBox(topLeft, topRight, bottomLeft, bottomRight);\n-        } else {\n-            return null;\n-        }\n-        return boundingBox1;\n+    private static List<FormField<?>> toFormFieldArray(List<FieldValue> valueArray, List<ReadResult> readResults) {\n+        return valueArray.stream().map(fieldValue -> setFormField(null, null, fieldValue, null, fieldValue.getPage(), readResults)).collect(Collectors.toList());\n     }\n \n     /**\n-     * Helper method to convert the service level {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray() value items}\n-     * to SDK level {@link ReceiptItem receipt items}.\n+     * Helper method to convert the page results to {@code FormPage form pages}.\n      *\n-     * @param fieldValueItems The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n+     * @param perPageTableList The per page tables list.\n+     * @param perPageLineList The per page form lines.\n      *\n-     * @return A list of {@link ReceiptItem}.\n+     * @return The per page {@code FormPage}.\n      */\n-    private static List<ReceiptItem> toReceiptItems(\n-        List<com.azure.ai.formrecognizer.implementation.models.FieldValue> fieldValueItems, List<ReadResult> readResults, boolean includeTextDetails) {\n-        List<ReceiptItem> receiptItemList = new ArrayList<>();\n-        for (com.azure.ai.formrecognizer.implementation.models.FieldValue eachFieldValue : fieldValueItems) {\n-            ReceiptItem receiptItem = new ReceiptItem();\n-\n-            for (ReceiptItemType key : ReceiptItemType.values()) {\n-                com.azure.ai.formrecognizer.implementation.models.FieldValue item = eachFieldValue.getValueObject().get(key.toString());\n-                if (QUANTITY.equals(key) && item != null) {\n-                    receiptItem.setQuantity(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (NAME.equals(key) && item != null) {\n-                    receiptItem.setName(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (PRICE.equals(key) && item != null) {\n-                    receiptItem.setPrice(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (TOTAL_PRICE.equals(key) && item != null) {\n-                    receiptItem.setTotalPrice(setFieldValue(item, readResults, includeTextDetails));\n-                }\n-            }\n-            receiptItemList.add(receiptItem);\n-        }\n-        return receiptItemList;\n+    private static FormPage getFormPage(ReadResult readResultItem, List<FormTable> perPageTableList,\n+        List<FormLine> perPageLineList) {\n+        return new FormPage(readResultItem.getHeight(), readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()), readResultItem.getWidth(), perPageLineList,\n+            perPageTableList\n+        );\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}\n-     * to a SDK level {@link IntegerValue}\n+     * Helper method to get per-page table information.\n      *\n-     * @param serviceIntegerValue The integer value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link IntegerValue}.\n+     * @return The list of per page {@code FormTable}.\n      */\n-    private static IntegerValue toFieldValueInteger(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                        serviceIntegerValue) {\n-        if (serviceIntegerValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()),\n-                serviceIntegerValue.getValueInteger(), serviceIntegerValue.getPage());\n-        }\n-\n-        return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()), null, serviceIntegerValue.getPage());\n+    static List<FormTable> getPageTables(PageResult pageResultItem, Integer pageNumber) {\n+        List<FormTable> extractedTablesList = new ArrayList<>();\n+        pageResultItem.getTables().forEach(dataTable -> {\n+            List<FormTableCell> tableCellList = dataTable.getCells().stream()\n+                .map(dataTableCell -> new FormTableCell(dataTableCell.getRowIndex(), dataTableCell.getColumnIndex(),\n+                    dataTableCell.getRowSpan(), dataTableCell.getColumnSpan(),\n+                    dataTableCell.getText(), toBoundingBox(dataTableCell.getBoundingBox()),\n+                    dataTableCell.getConfidence(), null,\n+                    dataTableCell.isHeader() == null ? false : dataTableCell.isHeader(),\n+                    dataTableCell.isFooter() == null ? false : dataTableCell.isHeader(),\n+                    pageNumber))\n+                .collect(Collectors.toList());\n+            FormTable extractedTable = new FormTable(dataTable.getRows(), dataTable.getColumns(), tableCellList);\n+            extractedTablesList.add(extractedTable);\n+        });\n+        return extractedTablesList;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}\n-     * to a SDK level {@link StringValue}.\n+     * Helper method to convert the per page {@link ReadResult} item to {@link FormLine}.\n      *\n-     * @param serviceStringValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list of {@code FormLine}.\n      */\n-    private static StringValue toFieldValueString(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                      serviceStringValue) {\n-        return new StringValue(serviceStringValue.getText(), toBoundingBox(serviceStringValue.getBoundingBox()),\n-            serviceStringValue.getValueString(), serviceStringValue.getPage());\n+    static List<FormLine> getReadResultFormLines(ReadResult readResultItem) {\n+        List<FormLine> formLines = readResultItem.getLines().stream()\n+            .map(textLine -> new FormLine(textLine.getText(), toBoundingBox(textLine.getBoundingBox()),\n+                readResultItem.getPage(), new IterableStream<>(toWords(textLine.getWords(), readResultItem.getPage()))))\n+            .collect(Collectors.toList());\n+        return formLines;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()}\n-     * to a SDK level {@link FloatValue}.\n+     * Helper method to set the {@link RecognizedForm#getFields() fields} from unlabeled result returned from the service.\n      *\n-     * @param serviceFloatValue The float value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()} .\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link FloatValue}.\n+     * @return The fields populated on {@link RecognizedForm#getFields() fields}.\n      */\n-    private static FloatValue toFieldValueNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                     serviceFloatValue) {\n-        if (serviceFloatValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()),\n-                serviceFloatValue.getValueNumber(), serviceFloatValue.getPage());\n-        }\n+    static Map<String, FormField<?>> getUnlabeledFieldMap(boolean includeTextDetails, List<ReadResult> readResults,\n+        PageResult pageResultItem, Integer pageNumber) {\n+        Map<String, FormField<?>> formFieldMap = new TreeMap<>();\n+        List<KeyValuePair> keyValuePairs = pageResultItem.getKeyValuePairs();\n+        for (int i = 0; i < keyValuePairs.size(); i++) {\n+            KeyValuePair keyValuePair = keyValuePairs.get(i);\n+            IterableStream<FormContent> formKeyContentList = null;\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (includeTextDetails && !CoreUtils.isNullOrEmpty(keyValuePair.getValue().getElements())) {\n+                formKeyContentList = setReferenceElements(keyValuePair.getKey().getElements(), readResults, pageNumber);\n+                formValueContentList = setReferenceElements(keyValuePair.getValue().getElements(), readResults, pageNumber);\n \n-        return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()), null, serviceFloatValue.getPage());\n+            }\n+            String fieldName = \"field-\" + i;\n+            FieldText labelFieldText = new FieldText(keyValuePair.getKey().getText(), toBoundingBox(keyValuePair.getKey().getBoundingBox()), pageNumber, formKeyContentList);\n+            FieldText valueText = new FieldText(keyValuePair.getValue().getText(), toBoundingBox(keyValuePair.getValue().getBoundingBox()), pageNumber, formValueContentList);\n+            FormField<String> formField = new FormField<>(keyValuePair.getConfidence(), labelFieldText, fieldName, keyValuePair.getValue().getText(), valueText, pageNumber);\n+            formFieldMap.put(fieldName, formField);\n+        }\n+        return formFieldMap;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}\n-     * to a SDK level {@link StringValue}.\n-     *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}.\n+     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list if referenced elements.\n      */\n-    private static StringValue toFieldValuePhoneNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                  serviceDateValue) {\n-        return new StringValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValuePhoneNumber(), serviceDateValue.getPage());\n+    private static IterableStream<FormContent> setReferenceElements(List<String> elements, List<ReadResult> readResults, Integer pageNumber) {\n+        List<FormContent> formContentList = new ArrayList<>();\n+        elements.forEach(elementString -> {\n+            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4Njk4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407586983", "bodyText": "Logic here is a bit off, indices length will need to be greater than or equal to two to ensure index 1 is existent.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:57:39Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -52,326 +51,383 @@ private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap = null;\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n \n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult);\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (int i = 0; i < documentResults.size(); i++) {\n+\n+                DocumentResult documentResultItem = documentResults.get(i);\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getLabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n \n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+            extractedFormList.add(new RecognizedForm(extractedFieldMap, formType.get(), pageRange.get(),\n+                new IterableStream<FormPage>(formPages.subList(pageRange.get().getStartPageNumber(), pageRange.get().getEndPageNumber()))));\n+        }\n+\n+        // labeled\n+        if (pageResults != null) {\n+            for (int i = 0; i < pageResults.size(); i++) {\n+                PageResult pageResultItem = pageResults.get(i);\n+                Integer pageNumber = pageResultItem.getPage();\n+\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getUnlabeledFieldMap(includeTextDetails, readResults, pageResultItem, pageNumber);\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+                extractedFormList.add(\n+                    new RecognizedForm(extractedFieldMap, formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<FormPage>(Arrays.asList(formPages.get(pageNumber - 1)))));\n+            }\n         }\n+        return extractedFormList;\n+    }\n+\n+    /**\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n+     *\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n+     */\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<RecognizedReceipt> extractedReceiptList =\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm)).collect(Collectors.toList());\n+\n         return new IterableStream<>(extractedReceiptList);\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n+     * @param analyzeResult The service returned result for analyze layouts.\n+     *\n+     * @return The IterableStream of {@code FormPage}.\n+     */\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        for (int i = 0; i < readResults.size(); i++) {\n+            ReadResult readResultItem = readResults.get(i);\n+            PageResult pageResultItem;\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+                pageResultItem = pageResults.get(i);\n+                perPageTableList = getPageTables(pageResultItem, pageResultItem.getPage());\n+            }\n+\n+            // add form lines\n+            List<FormLine> perPageFormLineList = new ArrayList<>();\n+            if (!CoreUtils.isNullOrEmpty(readResultItem.getLines())) {\n+                perPageFormLineList = getReadResultFormLines(readResultItem);\n+            }\n+\n+            // get form tables\n+            formPages.add(getFormPage(readResultItem, perPageTableList, perPageFormLineList));\n+        }\n+        return formPages;\n+    }\n+\n+    /**\n+     * The field map returned on analyze with an unlabeled model id.\n+     *\n+     * @param documentResultItem The extracted document level information.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The {@code RecognizedForm#getFields}.\n+     */\n+    private static Map<String, FormField<?>> getLabeledFieldMap(DocumentResult documentResultItem,\n+        List<ReadResult> readResults, boolean includeTextDetails) {\n+        Map<String, FormField<?>> extractedFieldMap = new TreeMap<>();\n+        // add receipt fields\n+        documentResultItem.getFields().forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formContentList = null;\n+            Integer pageNumber = fieldValue.getPage();\n+            if (includeTextDetails && !(CoreUtils.isNullOrEmpty(fieldValue.getElements()))) {\n+                formContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n+            }\n+            FieldText labelText = new FieldText(key, null, fieldValue.getPage(), null);\n+            FieldText valueText = new FieldText(fieldValue.getText(), null, pageNumber, formContentList);\n+            extractedFieldMap.put(key, setFormField(labelText, key, fieldValue, valueText, pageNumber, readResults));\n+        });\n+        return extractedFieldMap;\n+    }\n+\n+    /**\n+     * Helper method that converts the incoming service field value to one of the strongly typed SDK level\n+     * {@link FormField} with reference elements set when {@code includeTextDetails} is set to true.\n+     *\n+     * @param labelText The label text of the field.\n+     * @param key The name of the field.\n      * @param fieldValue The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param valueText The value text of the field.\n+     * @param pageNumber The 1-based page number.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return The strongly typed {@link FieldValue} for the field input.\n+     * @return The strongly typed {@link FormField} for the field input.\n      */\n-    private static FieldValue<?> setFieldValue(com.azure.ai.formrecognizer.implementation.models.FieldValue fieldValue,\n-                                               List<ReadResult> readResults, boolean includeTextDetails) {\n-        FieldValue<?> value;\n+    private static FormField<?> setFormField(FieldText labelText, String key, FieldValue fieldValue, FieldText valueText, Integer pageNumber, List<ReadResult> readResults) {\n+        FormField<?> value;\n         switch (fieldValue.getType()) {\n             case PHONE_NUMBER:\n-                value = toFieldValuePhoneNumber(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValuePhoneNumber(), valueText, pageNumber);\n                 break;\n             case STRING:\n-                value = toFieldValueString(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueString(), valueText, pageNumber);\n                 break;\n             case TIME:\n-                value = toFieldValueTime(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueTime(), valueText, pageNumber);\n                 break;\n             case DATE:\n-                value = toFieldValueDate(fieldValue);\n+                value = new FormField<LocalDate>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueDate(), valueText, pageNumber);\n                 break;\n             case INTEGER:\n-                value = toFieldValueInteger(fieldValue);\n+                value = new FormField<Integer>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueInteger(), valueText, pageNumber);\n                 break;\n             case NUMBER:\n-                value = toFieldValueNumber(fieldValue);\n+                value = new FormField<Number>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueNumber(), valueText, pageNumber);\n                 break;\n             case ARRAY:\n+                value = new FormField<List<FormField<?>>>(null, null, key,\n+                    toFormFieldArray(fieldValue.getValueArray(), readResults), null, pageNumber);\n+                break;\n             case OBJECT:\n+                value = new FormField<Map<String, FormField<?>>>(fieldValue.getConfidence(), labelText,\n+                    key, toFormFieldObject(fieldValue.getValueObject(), pageNumber, readResults), valueText, pageNumber);\n+                break;\n             default:\n                 throw LOGGER.logExceptionAsError(new RuntimeException(\"FieldValue Type not supported\"));\n         }\n-        if (includeTextDetails) {\n-            value.setElements(setReferenceElements(readResults, fieldValue.getElements()));\n-        }\n         return value;\n     }\n \n     /**\n-     * Helper method that converts the service returned page information to SDK model {@link PageMetadata}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueObject()}\n+     * to a SDK level map of {@link FormField}.\n      *\n-     * @param readResultItem A read result item returned from the service containing the page information for provided\n-     * input.\n+     * @param valueObject The array of field values returned by the service in\n+     * {@link FieldValue#getValueObject()} .\n      *\n-     * @return The {@link PageMetadata} for the receipt page.\n+     * @return The Map of {@link FormField}.\n      */\n-    private static PageMetadata getPageInfo(ReadResult readResultItem) {\n-        return new PageMetadata(readResultItem.getHeight(), readResultItem.getPage(), readResultItem.getWidth(),\n-            readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n-    }\n-\n-    /**\n-     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n-     *\n-     * @param readResults The ReadResult containing the resolved references for text elements.\n-     * @param elements When includeTextDetails is set to true, a list of references to the text\n-     * elements constituting this field value.\n-     *\n-     * @return The updated {@link FieldValue} object with list if referenced elements.\n-     */\n-    private static List<Element> setReferenceElements(List<ReadResult> readResults, List<String> elements) {\n-        List<Element> elementList = new ArrayList<>();\n-        elements.forEach(elementString -> {\n-            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n-            int readResultIndex, lineIndex;\n-            if (indices.length >= 1) {\n-                readResultIndex = Integer.parseInt(indices[0]);\n-                lineIndex = Integer.parseInt(indices[1]);\n-            } else {\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n-            }\n-            if (indices.length == 3) {\n-                int wordIndex = Integer.parseInt(indices[2]);\n-                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n-                    .get(wordIndex);\n-                WordElement wordElement = new WordElement(textWord.getText(), toBoundingBox(textWord.getBoundingBox()));\n-                elementList.add(wordElement);\n-            } else {\n-                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n-                LineElement lineElement = new LineElement(textLine.getText(), toBoundingBox(textLine.getBoundingBox()));\n-                elementList.add(lineElement);\n+    private static Map<String, FormField<?>> toFormFieldObject(Map<String, FieldValue> valueObject, Integer pageNumber, List<ReadResult> readResults) {\n+        Map<String, FormField<?>> fieldValueObjectMap = new TreeMap<>();\n+        valueObject.forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (!CoreUtils.isNullOrEmpty(fieldValue.getElements())) {\n+                formValueContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n             }\n+            fieldValueObjectMap.put(key, setFormField(null, key, fieldValue, new FieldText(fieldValue.getText(),\n+                    toBoundingBox(fieldValue.getBoundingBox()), fieldValue.getPage(), formValueContentList),\n+                fieldValue.getPage(), readResults));\n         });\n-        return elementList;\n+        return fieldValueObjectMap;\n     }\n \n     /**\n-     * Helper method to convert the service level modeled eight numbers representing the four points to SDK level\n-     * {@link BoundingBox}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray()}\n+     * to a SDK level List of {@link FormField}.\n      *\n-     * @param boundingBox A list of eight numbers representing the four points of a box.\n+     * @param valueArray The array of field values returned by the service in\n+     * {@link FieldValue#getValueArray()}.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return A {@link BoundingBox}.\n+     * @return The List of {@link FormField}.\n      */\n-    private static BoundingBox toBoundingBox(List<Float> boundingBox) {\n-        BoundingBox boundingBox1;\n-        if (boundingBox.size() == 8) {\n-            Point topLeft = new Point(boundingBox.get(0), boundingBox.get(1));\n-            Point topRight = new Point(boundingBox.get(2), boundingBox.get(3));\n-            Point bottomLeft = new Point(boundingBox.get(4), boundingBox.get(5));\n-            Point bottomRight = new Point(boundingBox.get(6), boundingBox.get(7));\n-            boundingBox1 = new BoundingBox(topLeft, topRight, bottomLeft, bottomRight);\n-        } else {\n-            return null;\n-        }\n-        return boundingBox1;\n+    private static List<FormField<?>> toFormFieldArray(List<FieldValue> valueArray, List<ReadResult> readResults) {\n+        return valueArray.stream().map(fieldValue -> setFormField(null, null, fieldValue, null, fieldValue.getPage(), readResults)).collect(Collectors.toList());\n     }\n \n     /**\n-     * Helper method to convert the service level {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray() value items}\n-     * to SDK level {@link ReceiptItem receipt items}.\n+     * Helper method to convert the page results to {@code FormPage form pages}.\n      *\n-     * @param fieldValueItems The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n+     * @param perPageTableList The per page tables list.\n+     * @param perPageLineList The per page form lines.\n      *\n-     * @return A list of {@link ReceiptItem}.\n+     * @return The per page {@code FormPage}.\n      */\n-    private static List<ReceiptItem> toReceiptItems(\n-        List<com.azure.ai.formrecognizer.implementation.models.FieldValue> fieldValueItems, List<ReadResult> readResults, boolean includeTextDetails) {\n-        List<ReceiptItem> receiptItemList = new ArrayList<>();\n-        for (com.azure.ai.formrecognizer.implementation.models.FieldValue eachFieldValue : fieldValueItems) {\n-            ReceiptItem receiptItem = new ReceiptItem();\n-\n-            for (ReceiptItemType key : ReceiptItemType.values()) {\n-                com.azure.ai.formrecognizer.implementation.models.FieldValue item = eachFieldValue.getValueObject().get(key.toString());\n-                if (QUANTITY.equals(key) && item != null) {\n-                    receiptItem.setQuantity(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (NAME.equals(key) && item != null) {\n-                    receiptItem.setName(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (PRICE.equals(key) && item != null) {\n-                    receiptItem.setPrice(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (TOTAL_PRICE.equals(key) && item != null) {\n-                    receiptItem.setTotalPrice(setFieldValue(item, readResults, includeTextDetails));\n-                }\n-            }\n-            receiptItemList.add(receiptItem);\n-        }\n-        return receiptItemList;\n+    private static FormPage getFormPage(ReadResult readResultItem, List<FormTable> perPageTableList,\n+        List<FormLine> perPageLineList) {\n+        return new FormPage(readResultItem.getHeight(), readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()), readResultItem.getWidth(), perPageLineList,\n+            perPageTableList\n+        );\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}\n-     * to a SDK level {@link IntegerValue}\n+     * Helper method to get per-page table information.\n      *\n-     * @param serviceIntegerValue The integer value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link IntegerValue}.\n+     * @return The list of per page {@code FormTable}.\n      */\n-    private static IntegerValue toFieldValueInteger(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                        serviceIntegerValue) {\n-        if (serviceIntegerValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()),\n-                serviceIntegerValue.getValueInteger(), serviceIntegerValue.getPage());\n-        }\n-\n-        return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()), null, serviceIntegerValue.getPage());\n+    static List<FormTable> getPageTables(PageResult pageResultItem, Integer pageNumber) {\n+        List<FormTable> extractedTablesList = new ArrayList<>();\n+        pageResultItem.getTables().forEach(dataTable -> {\n+            List<FormTableCell> tableCellList = dataTable.getCells().stream()\n+                .map(dataTableCell -> new FormTableCell(dataTableCell.getRowIndex(), dataTableCell.getColumnIndex(),\n+                    dataTableCell.getRowSpan(), dataTableCell.getColumnSpan(),\n+                    dataTableCell.getText(), toBoundingBox(dataTableCell.getBoundingBox()),\n+                    dataTableCell.getConfidence(), null,\n+                    dataTableCell.isHeader() == null ? false : dataTableCell.isHeader(),\n+                    dataTableCell.isFooter() == null ? false : dataTableCell.isHeader(),\n+                    pageNumber))\n+                .collect(Collectors.toList());\n+            FormTable extractedTable = new FormTable(dataTable.getRows(), dataTable.getColumns(), tableCellList);\n+            extractedTablesList.add(extractedTable);\n+        });\n+        return extractedTablesList;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}\n-     * to a SDK level {@link StringValue}.\n+     * Helper method to convert the per page {@link ReadResult} item to {@link FormLine}.\n      *\n-     * @param serviceStringValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list of {@code FormLine}.\n      */\n-    private static StringValue toFieldValueString(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                      serviceStringValue) {\n-        return new StringValue(serviceStringValue.getText(), toBoundingBox(serviceStringValue.getBoundingBox()),\n-            serviceStringValue.getValueString(), serviceStringValue.getPage());\n+    static List<FormLine> getReadResultFormLines(ReadResult readResultItem) {\n+        List<FormLine> formLines = readResultItem.getLines().stream()\n+            .map(textLine -> new FormLine(textLine.getText(), toBoundingBox(textLine.getBoundingBox()),\n+                readResultItem.getPage(), new IterableStream<>(toWords(textLine.getWords(), readResultItem.getPage()))))\n+            .collect(Collectors.toList());\n+        return formLines;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()}\n-     * to a SDK level {@link FloatValue}.\n+     * Helper method to set the {@link RecognizedForm#getFields() fields} from unlabeled result returned from the service.\n      *\n-     * @param serviceFloatValue The float value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()} .\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link FloatValue}.\n+     * @return The fields populated on {@link RecognizedForm#getFields() fields}.\n      */\n-    private static FloatValue toFieldValueNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                     serviceFloatValue) {\n-        if (serviceFloatValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()),\n-                serviceFloatValue.getValueNumber(), serviceFloatValue.getPage());\n-        }\n+    static Map<String, FormField<?>> getUnlabeledFieldMap(boolean includeTextDetails, List<ReadResult> readResults,\n+        PageResult pageResultItem, Integer pageNumber) {\n+        Map<String, FormField<?>> formFieldMap = new TreeMap<>();\n+        List<KeyValuePair> keyValuePairs = pageResultItem.getKeyValuePairs();\n+        for (int i = 0; i < keyValuePairs.size(); i++) {\n+            KeyValuePair keyValuePair = keyValuePairs.get(i);\n+            IterableStream<FormContent> formKeyContentList = null;\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (includeTextDetails && !CoreUtils.isNullOrEmpty(keyValuePair.getValue().getElements())) {\n+                formKeyContentList = setReferenceElements(keyValuePair.getKey().getElements(), readResults, pageNumber);\n+                formValueContentList = setReferenceElements(keyValuePair.getValue().getElements(), readResults, pageNumber);\n \n-        return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()), null, serviceFloatValue.getPage());\n+            }\n+            String fieldName = \"field-\" + i;\n+            FieldText labelFieldText = new FieldText(keyValuePair.getKey().getText(), toBoundingBox(keyValuePair.getKey().getBoundingBox()), pageNumber, formKeyContentList);\n+            FieldText valueText = new FieldText(keyValuePair.getValue().getText(), toBoundingBox(keyValuePair.getValue().getBoundingBox()), pageNumber, formValueContentList);\n+            FormField<String> formField = new FormField<>(keyValuePair.getConfidence(), labelFieldText, fieldName, keyValuePair.getValue().getText(), valueText, pageNumber);\n+            formFieldMap.put(fieldName, formField);\n+        }\n+        return formFieldMap;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}\n-     * to a SDK level {@link StringValue}.\n-     *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}.\n+     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list if referenced elements.\n      */\n-    private static StringValue toFieldValuePhoneNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                  serviceDateValue) {\n-        return new StringValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValuePhoneNumber(), serviceDateValue.getPage());\n+    private static IterableStream<FormContent> setReferenceElements(List<String> elements, List<ReadResult> readResults, Integer pageNumber) {\n+        List<FormContent> formContentList = new ArrayList<>();\n+        elements.forEach(elementString -> {\n+            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n+            int readResultIndex, lineIndex;\n+            if (indices.length >= 1) {\n+                readResultIndex = Integer.parseInt(indices[0]);\n+                lineIndex = Integer.parseInt(indices[1]);", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4NzE4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407587182", "bodyText": "Mind making this exception into a proper sentence.", "author": "alzimmermsft", "createdAt": "2020-04-13T16:58:01Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -52,326 +51,383 @@ private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap = null;\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n \n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult);\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (int i = 0; i < documentResults.size(); i++) {\n+\n+                DocumentResult documentResultItem = documentResults.get(i);\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getLabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n \n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+            extractedFormList.add(new RecognizedForm(extractedFieldMap, formType.get(), pageRange.get(),\n+                new IterableStream<FormPage>(formPages.subList(pageRange.get().getStartPageNumber(), pageRange.get().getEndPageNumber()))));\n+        }\n+\n+        // labeled\n+        if (pageResults != null) {\n+            for (int i = 0; i < pageResults.size(); i++) {\n+                PageResult pageResultItem = pageResults.get(i);\n+                Integer pageNumber = pageResultItem.getPage();\n+\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getUnlabeledFieldMap(includeTextDetails, readResults, pageResultItem, pageNumber);\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+                extractedFormList.add(\n+                    new RecognizedForm(extractedFieldMap, formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<FormPage>(Arrays.asList(formPages.get(pageNumber - 1)))));\n+            }\n         }\n+        return extractedFormList;\n+    }\n+\n+    /**\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n+     *\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n+     */\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<RecognizedReceipt> extractedReceiptList =\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm)).collect(Collectors.toList());\n+\n         return new IterableStream<>(extractedReceiptList);\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n+     * @param analyzeResult The service returned result for analyze layouts.\n+     *\n+     * @return The IterableStream of {@code FormPage}.\n+     */\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        for (int i = 0; i < readResults.size(); i++) {\n+            ReadResult readResultItem = readResults.get(i);\n+            PageResult pageResultItem;\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+                pageResultItem = pageResults.get(i);\n+                perPageTableList = getPageTables(pageResultItem, pageResultItem.getPage());\n+            }\n+\n+            // add form lines\n+            List<FormLine> perPageFormLineList = new ArrayList<>();\n+            if (!CoreUtils.isNullOrEmpty(readResultItem.getLines())) {\n+                perPageFormLineList = getReadResultFormLines(readResultItem);\n+            }\n+\n+            // get form tables\n+            formPages.add(getFormPage(readResultItem, perPageTableList, perPageFormLineList));\n+        }\n+        return formPages;\n+    }\n+\n+    /**\n+     * The field map returned on analyze with an unlabeled model id.\n+     *\n+     * @param documentResultItem The extracted document level information.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The {@code RecognizedForm#getFields}.\n+     */\n+    private static Map<String, FormField<?>> getLabeledFieldMap(DocumentResult documentResultItem,\n+        List<ReadResult> readResults, boolean includeTextDetails) {\n+        Map<String, FormField<?>> extractedFieldMap = new TreeMap<>();\n+        // add receipt fields\n+        documentResultItem.getFields().forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formContentList = null;\n+            Integer pageNumber = fieldValue.getPage();\n+            if (includeTextDetails && !(CoreUtils.isNullOrEmpty(fieldValue.getElements()))) {\n+                formContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n+            }\n+            FieldText labelText = new FieldText(key, null, fieldValue.getPage(), null);\n+            FieldText valueText = new FieldText(fieldValue.getText(), null, pageNumber, formContentList);\n+            extractedFieldMap.put(key, setFormField(labelText, key, fieldValue, valueText, pageNumber, readResults));\n+        });\n+        return extractedFieldMap;\n+    }\n+\n+    /**\n+     * Helper method that converts the incoming service field value to one of the strongly typed SDK level\n+     * {@link FormField} with reference elements set when {@code includeTextDetails} is set to true.\n+     *\n+     * @param labelText The label text of the field.\n+     * @param key The name of the field.\n      * @param fieldValue The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param valueText The value text of the field.\n+     * @param pageNumber The 1-based page number.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return The strongly typed {@link FieldValue} for the field input.\n+     * @return The strongly typed {@link FormField} for the field input.\n      */\n-    private static FieldValue<?> setFieldValue(com.azure.ai.formrecognizer.implementation.models.FieldValue fieldValue,\n-                                               List<ReadResult> readResults, boolean includeTextDetails) {\n-        FieldValue<?> value;\n+    private static FormField<?> setFormField(FieldText labelText, String key, FieldValue fieldValue, FieldText valueText, Integer pageNumber, List<ReadResult> readResults) {\n+        FormField<?> value;\n         switch (fieldValue.getType()) {\n             case PHONE_NUMBER:\n-                value = toFieldValuePhoneNumber(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValuePhoneNumber(), valueText, pageNumber);\n                 break;\n             case STRING:\n-                value = toFieldValueString(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueString(), valueText, pageNumber);\n                 break;\n             case TIME:\n-                value = toFieldValueTime(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueTime(), valueText, pageNumber);\n                 break;\n             case DATE:\n-                value = toFieldValueDate(fieldValue);\n+                value = new FormField<LocalDate>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueDate(), valueText, pageNumber);\n                 break;\n             case INTEGER:\n-                value = toFieldValueInteger(fieldValue);\n+                value = new FormField<Integer>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueInteger(), valueText, pageNumber);\n                 break;\n             case NUMBER:\n-                value = toFieldValueNumber(fieldValue);\n+                value = new FormField<Number>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueNumber(), valueText, pageNumber);\n                 break;\n             case ARRAY:\n+                value = new FormField<List<FormField<?>>>(null, null, key,\n+                    toFormFieldArray(fieldValue.getValueArray(), readResults), null, pageNumber);\n+                break;\n             case OBJECT:\n+                value = new FormField<Map<String, FormField<?>>>(fieldValue.getConfidence(), labelText,\n+                    key, toFormFieldObject(fieldValue.getValueObject(), pageNumber, readResults), valueText, pageNumber);\n+                break;\n             default:\n                 throw LOGGER.logExceptionAsError(new RuntimeException(\"FieldValue Type not supported\"));\n         }\n-        if (includeTextDetails) {\n-            value.setElements(setReferenceElements(readResults, fieldValue.getElements()));\n-        }\n         return value;\n     }\n \n     /**\n-     * Helper method that converts the service returned page information to SDK model {@link PageMetadata}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueObject()}\n+     * to a SDK level map of {@link FormField}.\n      *\n-     * @param readResultItem A read result item returned from the service containing the page information for provided\n-     * input.\n+     * @param valueObject The array of field values returned by the service in\n+     * {@link FieldValue#getValueObject()} .\n      *\n-     * @return The {@link PageMetadata} for the receipt page.\n+     * @return The Map of {@link FormField}.\n      */\n-    private static PageMetadata getPageInfo(ReadResult readResultItem) {\n-        return new PageMetadata(readResultItem.getHeight(), readResultItem.getPage(), readResultItem.getWidth(),\n-            readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n-    }\n-\n-    /**\n-     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n-     *\n-     * @param readResults The ReadResult containing the resolved references for text elements.\n-     * @param elements When includeTextDetails is set to true, a list of references to the text\n-     * elements constituting this field value.\n-     *\n-     * @return The updated {@link FieldValue} object with list if referenced elements.\n-     */\n-    private static List<Element> setReferenceElements(List<ReadResult> readResults, List<String> elements) {\n-        List<Element> elementList = new ArrayList<>();\n-        elements.forEach(elementString -> {\n-            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n-            int readResultIndex, lineIndex;\n-            if (indices.length >= 1) {\n-                readResultIndex = Integer.parseInt(indices[0]);\n-                lineIndex = Integer.parseInt(indices[1]);\n-            } else {\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n-            }\n-            if (indices.length == 3) {\n-                int wordIndex = Integer.parseInt(indices[2]);\n-                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n-                    .get(wordIndex);\n-                WordElement wordElement = new WordElement(textWord.getText(), toBoundingBox(textWord.getBoundingBox()));\n-                elementList.add(wordElement);\n-            } else {\n-                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n-                LineElement lineElement = new LineElement(textLine.getText(), toBoundingBox(textLine.getBoundingBox()));\n-                elementList.add(lineElement);\n+    private static Map<String, FormField<?>> toFormFieldObject(Map<String, FieldValue> valueObject, Integer pageNumber, List<ReadResult> readResults) {\n+        Map<String, FormField<?>> fieldValueObjectMap = new TreeMap<>();\n+        valueObject.forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (!CoreUtils.isNullOrEmpty(fieldValue.getElements())) {\n+                formValueContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n             }\n+            fieldValueObjectMap.put(key, setFormField(null, key, fieldValue, new FieldText(fieldValue.getText(),\n+                    toBoundingBox(fieldValue.getBoundingBox()), fieldValue.getPage(), formValueContentList),\n+                fieldValue.getPage(), readResults));\n         });\n-        return elementList;\n+        return fieldValueObjectMap;\n     }\n \n     /**\n-     * Helper method to convert the service level modeled eight numbers representing the four points to SDK level\n-     * {@link BoundingBox}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray()}\n+     * to a SDK level List of {@link FormField}.\n      *\n-     * @param boundingBox A list of eight numbers representing the four points of a box.\n+     * @param valueArray The array of field values returned by the service in\n+     * {@link FieldValue#getValueArray()}.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return A {@link BoundingBox}.\n+     * @return The List of {@link FormField}.\n      */\n-    private static BoundingBox toBoundingBox(List<Float> boundingBox) {\n-        BoundingBox boundingBox1;\n-        if (boundingBox.size() == 8) {\n-            Point topLeft = new Point(boundingBox.get(0), boundingBox.get(1));\n-            Point topRight = new Point(boundingBox.get(2), boundingBox.get(3));\n-            Point bottomLeft = new Point(boundingBox.get(4), boundingBox.get(5));\n-            Point bottomRight = new Point(boundingBox.get(6), boundingBox.get(7));\n-            boundingBox1 = new BoundingBox(topLeft, topRight, bottomLeft, bottomRight);\n-        } else {\n-            return null;\n-        }\n-        return boundingBox1;\n+    private static List<FormField<?>> toFormFieldArray(List<FieldValue> valueArray, List<ReadResult> readResults) {\n+        return valueArray.stream().map(fieldValue -> setFormField(null, null, fieldValue, null, fieldValue.getPage(), readResults)).collect(Collectors.toList());\n     }\n \n     /**\n-     * Helper method to convert the service level {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray() value items}\n-     * to SDK level {@link ReceiptItem receipt items}.\n+     * Helper method to convert the page results to {@code FormPage form pages}.\n      *\n-     * @param fieldValueItems The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n+     * @param perPageTableList The per page tables list.\n+     * @param perPageLineList The per page form lines.\n      *\n-     * @return A list of {@link ReceiptItem}.\n+     * @return The per page {@code FormPage}.\n      */\n-    private static List<ReceiptItem> toReceiptItems(\n-        List<com.azure.ai.formrecognizer.implementation.models.FieldValue> fieldValueItems, List<ReadResult> readResults, boolean includeTextDetails) {\n-        List<ReceiptItem> receiptItemList = new ArrayList<>();\n-        for (com.azure.ai.formrecognizer.implementation.models.FieldValue eachFieldValue : fieldValueItems) {\n-            ReceiptItem receiptItem = new ReceiptItem();\n-\n-            for (ReceiptItemType key : ReceiptItemType.values()) {\n-                com.azure.ai.formrecognizer.implementation.models.FieldValue item = eachFieldValue.getValueObject().get(key.toString());\n-                if (QUANTITY.equals(key) && item != null) {\n-                    receiptItem.setQuantity(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (NAME.equals(key) && item != null) {\n-                    receiptItem.setName(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (PRICE.equals(key) && item != null) {\n-                    receiptItem.setPrice(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (TOTAL_PRICE.equals(key) && item != null) {\n-                    receiptItem.setTotalPrice(setFieldValue(item, readResults, includeTextDetails));\n-                }\n-            }\n-            receiptItemList.add(receiptItem);\n-        }\n-        return receiptItemList;\n+    private static FormPage getFormPage(ReadResult readResultItem, List<FormTable> perPageTableList,\n+        List<FormLine> perPageLineList) {\n+        return new FormPage(readResultItem.getHeight(), readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()), readResultItem.getWidth(), perPageLineList,\n+            perPageTableList\n+        );\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}\n-     * to a SDK level {@link IntegerValue}\n+     * Helper method to get per-page table information.\n      *\n-     * @param serviceIntegerValue The integer value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link IntegerValue}.\n+     * @return The list of per page {@code FormTable}.\n      */\n-    private static IntegerValue toFieldValueInteger(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                        serviceIntegerValue) {\n-        if (serviceIntegerValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()),\n-                serviceIntegerValue.getValueInteger(), serviceIntegerValue.getPage());\n-        }\n-\n-        return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()), null, serviceIntegerValue.getPage());\n+    static List<FormTable> getPageTables(PageResult pageResultItem, Integer pageNumber) {\n+        List<FormTable> extractedTablesList = new ArrayList<>();\n+        pageResultItem.getTables().forEach(dataTable -> {\n+            List<FormTableCell> tableCellList = dataTable.getCells().stream()\n+                .map(dataTableCell -> new FormTableCell(dataTableCell.getRowIndex(), dataTableCell.getColumnIndex(),\n+                    dataTableCell.getRowSpan(), dataTableCell.getColumnSpan(),\n+                    dataTableCell.getText(), toBoundingBox(dataTableCell.getBoundingBox()),\n+                    dataTableCell.getConfidence(), null,\n+                    dataTableCell.isHeader() == null ? false : dataTableCell.isHeader(),\n+                    dataTableCell.isFooter() == null ? false : dataTableCell.isHeader(),\n+                    pageNumber))\n+                .collect(Collectors.toList());\n+            FormTable extractedTable = new FormTable(dataTable.getRows(), dataTable.getColumns(), tableCellList);\n+            extractedTablesList.add(extractedTable);\n+        });\n+        return extractedTablesList;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}\n-     * to a SDK level {@link StringValue}.\n+     * Helper method to convert the per page {@link ReadResult} item to {@link FormLine}.\n      *\n-     * @param serviceStringValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list of {@code FormLine}.\n      */\n-    private static StringValue toFieldValueString(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                      serviceStringValue) {\n-        return new StringValue(serviceStringValue.getText(), toBoundingBox(serviceStringValue.getBoundingBox()),\n-            serviceStringValue.getValueString(), serviceStringValue.getPage());\n+    static List<FormLine> getReadResultFormLines(ReadResult readResultItem) {\n+        List<FormLine> formLines = readResultItem.getLines().stream()\n+            .map(textLine -> new FormLine(textLine.getText(), toBoundingBox(textLine.getBoundingBox()),\n+                readResultItem.getPage(), new IterableStream<>(toWords(textLine.getWords(), readResultItem.getPage()))))\n+            .collect(Collectors.toList());\n+        return formLines;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()}\n-     * to a SDK level {@link FloatValue}.\n+     * Helper method to set the {@link RecognizedForm#getFields() fields} from unlabeled result returned from the service.\n      *\n-     * @param serviceFloatValue The float value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()} .\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link FloatValue}.\n+     * @return The fields populated on {@link RecognizedForm#getFields() fields}.\n      */\n-    private static FloatValue toFieldValueNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                     serviceFloatValue) {\n-        if (serviceFloatValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()),\n-                serviceFloatValue.getValueNumber(), serviceFloatValue.getPage());\n-        }\n+    static Map<String, FormField<?>> getUnlabeledFieldMap(boolean includeTextDetails, List<ReadResult> readResults,\n+        PageResult pageResultItem, Integer pageNumber) {\n+        Map<String, FormField<?>> formFieldMap = new TreeMap<>();\n+        List<KeyValuePair> keyValuePairs = pageResultItem.getKeyValuePairs();\n+        for (int i = 0; i < keyValuePairs.size(); i++) {\n+            KeyValuePair keyValuePair = keyValuePairs.get(i);\n+            IterableStream<FormContent> formKeyContentList = null;\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (includeTextDetails && !CoreUtils.isNullOrEmpty(keyValuePair.getValue().getElements())) {\n+                formKeyContentList = setReferenceElements(keyValuePair.getKey().getElements(), readResults, pageNumber);\n+                formValueContentList = setReferenceElements(keyValuePair.getValue().getElements(), readResults, pageNumber);\n \n-        return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()), null, serviceFloatValue.getPage());\n+            }\n+            String fieldName = \"field-\" + i;\n+            FieldText labelFieldText = new FieldText(keyValuePair.getKey().getText(), toBoundingBox(keyValuePair.getKey().getBoundingBox()), pageNumber, formKeyContentList);\n+            FieldText valueText = new FieldText(keyValuePair.getValue().getText(), toBoundingBox(keyValuePair.getValue().getBoundingBox()), pageNumber, formValueContentList);\n+            FormField<String> formField = new FormField<>(keyValuePair.getConfidence(), labelFieldText, fieldName, keyValuePair.getValue().getText(), valueText, pageNumber);\n+            formFieldMap.put(fieldName, formField);\n+        }\n+        return formFieldMap;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}\n-     * to a SDK level {@link StringValue}.\n-     *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}.\n+     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list if referenced elements.\n      */\n-    private static StringValue toFieldValuePhoneNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                  serviceDateValue) {\n-        return new StringValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValuePhoneNumber(), serviceDateValue.getPage());\n+    private static IterableStream<FormContent> setReferenceElements(List<String> elements, List<ReadResult> readResults, Integer pageNumber) {\n+        List<FormContent> formContentList = new ArrayList<>();\n+        elements.forEach(elementString -> {\n+            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n+            int readResultIndex, lineIndex;\n+            if (indices.length >= 1) {\n+                readResultIndex = Integer.parseInt(indices[0]);\n+                lineIndex = Integer.parseInt(indices[1]);\n+            } else {\n+                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4ODEzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407588130", "bodyText": "Could we invert this if/else block to check for the invalid case? That way we won't need to instantiate the int fields outside of the scope.\nif (invalidCase) {\n  throw exception;\n}\n\n// set int fields\n// continuation logic", "author": "alzimmermsft", "createdAt": "2020-04-13T16:59:33Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -52,326 +51,383 @@ private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap = null;\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n \n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult);\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (int i = 0; i < documentResults.size(); i++) {\n+\n+                DocumentResult documentResultItem = documentResults.get(i);\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getLabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n \n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+            extractedFormList.add(new RecognizedForm(extractedFieldMap, formType.get(), pageRange.get(),\n+                new IterableStream<FormPage>(formPages.subList(pageRange.get().getStartPageNumber(), pageRange.get().getEndPageNumber()))));\n+        }\n+\n+        // labeled\n+        if (pageResults != null) {\n+            for (int i = 0; i < pageResults.size(); i++) {\n+                PageResult pageResultItem = pageResults.get(i);\n+                Integer pageNumber = pageResultItem.getPage();\n+\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getUnlabeledFieldMap(includeTextDetails, readResults, pageResultItem, pageNumber);\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+                extractedFormList.add(\n+                    new RecognizedForm(extractedFieldMap, formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<FormPage>(Arrays.asList(formPages.get(pageNumber - 1)))));\n+            }\n         }\n+        return extractedFormList;\n+    }\n+\n+    /**\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n+     *\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n+     */\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<RecognizedReceipt> extractedReceiptList =\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm)).collect(Collectors.toList());\n+\n         return new IterableStream<>(extractedReceiptList);\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n+     * @param analyzeResult The service returned result for analyze layouts.\n+     *\n+     * @return The IterableStream of {@code FormPage}.\n+     */\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        for (int i = 0; i < readResults.size(); i++) {\n+            ReadResult readResultItem = readResults.get(i);\n+            PageResult pageResultItem;\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+                pageResultItem = pageResults.get(i);\n+                perPageTableList = getPageTables(pageResultItem, pageResultItem.getPage());\n+            }\n+\n+            // add form lines\n+            List<FormLine> perPageFormLineList = new ArrayList<>();\n+            if (!CoreUtils.isNullOrEmpty(readResultItem.getLines())) {\n+                perPageFormLineList = getReadResultFormLines(readResultItem);\n+            }\n+\n+            // get form tables\n+            formPages.add(getFormPage(readResultItem, perPageTableList, perPageFormLineList));\n+        }\n+        return formPages;\n+    }\n+\n+    /**\n+     * The field map returned on analyze with an unlabeled model id.\n+     *\n+     * @param documentResultItem The extracted document level information.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The {@code RecognizedForm#getFields}.\n+     */\n+    private static Map<String, FormField<?>> getLabeledFieldMap(DocumentResult documentResultItem,\n+        List<ReadResult> readResults, boolean includeTextDetails) {\n+        Map<String, FormField<?>> extractedFieldMap = new TreeMap<>();\n+        // add receipt fields\n+        documentResultItem.getFields().forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formContentList = null;\n+            Integer pageNumber = fieldValue.getPage();\n+            if (includeTextDetails && !(CoreUtils.isNullOrEmpty(fieldValue.getElements()))) {\n+                formContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n+            }\n+            FieldText labelText = new FieldText(key, null, fieldValue.getPage(), null);\n+            FieldText valueText = new FieldText(fieldValue.getText(), null, pageNumber, formContentList);\n+            extractedFieldMap.put(key, setFormField(labelText, key, fieldValue, valueText, pageNumber, readResults));\n+        });\n+        return extractedFieldMap;\n+    }\n+\n+    /**\n+     * Helper method that converts the incoming service field value to one of the strongly typed SDK level\n+     * {@link FormField} with reference elements set when {@code includeTextDetails} is set to true.\n+     *\n+     * @param labelText The label text of the field.\n+     * @param key The name of the field.\n      * @param fieldValue The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param valueText The value text of the field.\n+     * @param pageNumber The 1-based page number.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return The strongly typed {@link FieldValue} for the field input.\n+     * @return The strongly typed {@link FormField} for the field input.\n      */\n-    private static FieldValue<?> setFieldValue(com.azure.ai.formrecognizer.implementation.models.FieldValue fieldValue,\n-                                               List<ReadResult> readResults, boolean includeTextDetails) {\n-        FieldValue<?> value;\n+    private static FormField<?> setFormField(FieldText labelText, String key, FieldValue fieldValue, FieldText valueText, Integer pageNumber, List<ReadResult> readResults) {\n+        FormField<?> value;\n         switch (fieldValue.getType()) {\n             case PHONE_NUMBER:\n-                value = toFieldValuePhoneNumber(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValuePhoneNumber(), valueText, pageNumber);\n                 break;\n             case STRING:\n-                value = toFieldValueString(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueString(), valueText, pageNumber);\n                 break;\n             case TIME:\n-                value = toFieldValueTime(fieldValue);\n+                value = new FormField<String>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueTime(), valueText, pageNumber);\n                 break;\n             case DATE:\n-                value = toFieldValueDate(fieldValue);\n+                value = new FormField<LocalDate>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueDate(), valueText, pageNumber);\n                 break;\n             case INTEGER:\n-                value = toFieldValueInteger(fieldValue);\n+                value = new FormField<Integer>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueInteger(), valueText, pageNumber);\n                 break;\n             case NUMBER:\n-                value = toFieldValueNumber(fieldValue);\n+                value = new FormField<Number>(fieldValue.getConfidence(), labelText,\n+                    key, fieldValue.getValueNumber(), valueText, pageNumber);\n                 break;\n             case ARRAY:\n+                value = new FormField<List<FormField<?>>>(null, null, key,\n+                    toFormFieldArray(fieldValue.getValueArray(), readResults), null, pageNumber);\n+                break;\n             case OBJECT:\n+                value = new FormField<Map<String, FormField<?>>>(fieldValue.getConfidence(), labelText,\n+                    key, toFormFieldObject(fieldValue.getValueObject(), pageNumber, readResults), valueText, pageNumber);\n+                break;\n             default:\n                 throw LOGGER.logExceptionAsError(new RuntimeException(\"FieldValue Type not supported\"));\n         }\n-        if (includeTextDetails) {\n-            value.setElements(setReferenceElements(readResults, fieldValue.getElements()));\n-        }\n         return value;\n     }\n \n     /**\n-     * Helper method that converts the service returned page information to SDK model {@link PageMetadata}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueObject()}\n+     * to a SDK level map of {@link FormField}.\n      *\n-     * @param readResultItem A read result item returned from the service containing the page information for provided\n-     * input.\n+     * @param valueObject The array of field values returned by the service in\n+     * {@link FieldValue#getValueObject()} .\n      *\n-     * @return The {@link PageMetadata} for the receipt page.\n+     * @return The Map of {@link FormField}.\n      */\n-    private static PageMetadata getPageInfo(ReadResult readResultItem) {\n-        return new PageMetadata(readResultItem.getHeight(), readResultItem.getPage(), readResultItem.getWidth(),\n-            readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n-    }\n-\n-    /**\n-     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n-     *\n-     * @param readResults The ReadResult containing the resolved references for text elements.\n-     * @param elements When includeTextDetails is set to true, a list of references to the text\n-     * elements constituting this field value.\n-     *\n-     * @return The updated {@link FieldValue} object with list if referenced elements.\n-     */\n-    private static List<Element> setReferenceElements(List<ReadResult> readResults, List<String> elements) {\n-        List<Element> elementList = new ArrayList<>();\n-        elements.forEach(elementString -> {\n-            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n-            int readResultIndex, lineIndex;\n-            if (indices.length >= 1) {\n-                readResultIndex = Integer.parseInt(indices[0]);\n-                lineIndex = Integer.parseInt(indices[1]);\n-            } else {\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n-            }\n-            if (indices.length == 3) {\n-                int wordIndex = Integer.parseInt(indices[2]);\n-                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n-                    .get(wordIndex);\n-                WordElement wordElement = new WordElement(textWord.getText(), toBoundingBox(textWord.getBoundingBox()));\n-                elementList.add(wordElement);\n-            } else {\n-                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n-                LineElement lineElement = new LineElement(textLine.getText(), toBoundingBox(textLine.getBoundingBox()));\n-                elementList.add(lineElement);\n+    private static Map<String, FormField<?>> toFormFieldObject(Map<String, FieldValue> valueObject, Integer pageNumber, List<ReadResult> readResults) {\n+        Map<String, FormField<?>> fieldValueObjectMap = new TreeMap<>();\n+        valueObject.forEach((key, fieldValue) -> {\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (!CoreUtils.isNullOrEmpty(fieldValue.getElements())) {\n+                formValueContentList = setReferenceElements(fieldValue.getElements(), readResults, pageNumber);\n             }\n+            fieldValueObjectMap.put(key, setFormField(null, key, fieldValue, new FieldText(fieldValue.getText(),\n+                    toBoundingBox(fieldValue.getBoundingBox()), fieldValue.getPage(), formValueContentList),\n+                fieldValue.getPage(), readResults));\n         });\n-        return elementList;\n+        return fieldValueObjectMap;\n     }\n \n     /**\n-     * Helper method to convert the service level modeled eight numbers representing the four points to SDK level\n-     * {@link BoundingBox}.\n+     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray()}\n+     * to a SDK level List of {@link FormField}.\n      *\n-     * @param boundingBox A list of eight numbers representing the four points of a box.\n+     * @param valueArray The array of field values returned by the service in\n+     * {@link FieldValue#getValueArray()}.\n+     * @param readResults The text extraction result returned by the service.\n      *\n-     * @return A {@link BoundingBox}.\n+     * @return The List of {@link FormField}.\n      */\n-    private static BoundingBox toBoundingBox(List<Float> boundingBox) {\n-        BoundingBox boundingBox1;\n-        if (boundingBox.size() == 8) {\n-            Point topLeft = new Point(boundingBox.get(0), boundingBox.get(1));\n-            Point topRight = new Point(boundingBox.get(2), boundingBox.get(3));\n-            Point bottomLeft = new Point(boundingBox.get(4), boundingBox.get(5));\n-            Point bottomRight = new Point(boundingBox.get(6), boundingBox.get(7));\n-            boundingBox1 = new BoundingBox(topLeft, topRight, bottomLeft, bottomRight);\n-        } else {\n-            return null;\n-        }\n-        return boundingBox1;\n+    private static List<FormField<?>> toFormFieldArray(List<FieldValue> valueArray, List<ReadResult> readResults) {\n+        return valueArray.stream().map(fieldValue -> setFormField(null, null, fieldValue, null, fieldValue.getPage(), readResults)).collect(Collectors.toList());\n     }\n \n     /**\n-     * Helper method to convert the service level {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray() value items}\n-     * to SDK level {@link ReceiptItem receipt items}.\n+     * Helper method to convert the page results to {@code FormPage form pages}.\n      *\n-     * @param fieldValueItems The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n+     * @param perPageTableList The per page tables list.\n+     * @param perPageLineList The per page form lines.\n      *\n-     * @return A list of {@link ReceiptItem}.\n+     * @return The per page {@code FormPage}.\n      */\n-    private static List<ReceiptItem> toReceiptItems(\n-        List<com.azure.ai.formrecognizer.implementation.models.FieldValue> fieldValueItems, List<ReadResult> readResults, boolean includeTextDetails) {\n-        List<ReceiptItem> receiptItemList = new ArrayList<>();\n-        for (com.azure.ai.formrecognizer.implementation.models.FieldValue eachFieldValue : fieldValueItems) {\n-            ReceiptItem receiptItem = new ReceiptItem();\n-\n-            for (ReceiptItemType key : ReceiptItemType.values()) {\n-                com.azure.ai.formrecognizer.implementation.models.FieldValue item = eachFieldValue.getValueObject().get(key.toString());\n-                if (QUANTITY.equals(key) && item != null) {\n-                    receiptItem.setQuantity(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (NAME.equals(key) && item != null) {\n-                    receiptItem.setName(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (PRICE.equals(key) && item != null) {\n-                    receiptItem.setPrice(setFieldValue(item, readResults, includeTextDetails));\n-                } else if (TOTAL_PRICE.equals(key) && item != null) {\n-                    receiptItem.setTotalPrice(setFieldValue(item, readResults, includeTextDetails));\n-                }\n-            }\n-            receiptItemList.add(receiptItem);\n-        }\n-        return receiptItemList;\n+    private static FormPage getFormPage(ReadResult readResultItem, List<FormTable> perPageTableList,\n+        List<FormLine> perPageLineList) {\n+        return new FormPage(readResultItem.getHeight(), readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()), readResultItem.getWidth(), perPageLineList,\n+            perPageTableList\n+        );\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}\n-     * to a SDK level {@link IntegerValue}\n+     * Helper method to get per-page table information.\n      *\n-     * @param serviceIntegerValue The integer value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueInteger()}.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link IntegerValue}.\n+     * @return The list of per page {@code FormTable}.\n      */\n-    private static IntegerValue toFieldValueInteger(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                        serviceIntegerValue) {\n-        if (serviceIntegerValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()),\n-                serviceIntegerValue.getValueInteger(), serviceIntegerValue.getPage());\n-        }\n-\n-        return new IntegerValue(serviceIntegerValue.getText(), toBoundingBox(serviceIntegerValue.getBoundingBox()), null, serviceIntegerValue.getPage());\n+    static List<FormTable> getPageTables(PageResult pageResultItem, Integer pageNumber) {\n+        List<FormTable> extractedTablesList = new ArrayList<>();\n+        pageResultItem.getTables().forEach(dataTable -> {\n+            List<FormTableCell> tableCellList = dataTable.getCells().stream()\n+                .map(dataTableCell -> new FormTableCell(dataTableCell.getRowIndex(), dataTableCell.getColumnIndex(),\n+                    dataTableCell.getRowSpan(), dataTableCell.getColumnSpan(),\n+                    dataTableCell.getText(), toBoundingBox(dataTableCell.getBoundingBox()),\n+                    dataTableCell.getConfidence(), null,\n+                    dataTableCell.isHeader() == null ? false : dataTableCell.isHeader(),\n+                    dataTableCell.isFooter() == null ? false : dataTableCell.isHeader(),\n+                    pageNumber))\n+                .collect(Collectors.toList());\n+            FormTable extractedTable = new FormTable(dataTable.getRows(), dataTable.getColumns(), tableCellList);\n+            extractedTablesList.add(extractedTable);\n+        });\n+        return extractedTablesList;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}\n-     * to a SDK level {@link StringValue}.\n+     * Helper method to convert the per page {@link ReadResult} item to {@link FormLine}.\n      *\n-     * @param serviceStringValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueString()}.\n+     * @param readResultItem The per page text extraction item result returned by the service.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list of {@code FormLine}.\n      */\n-    private static StringValue toFieldValueString(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                      serviceStringValue) {\n-        return new StringValue(serviceStringValue.getText(), toBoundingBox(serviceStringValue.getBoundingBox()),\n-            serviceStringValue.getValueString(), serviceStringValue.getPage());\n+    static List<FormLine> getReadResultFormLines(ReadResult readResultItem) {\n+        List<FormLine> formLines = readResultItem.getLines().stream()\n+            .map(textLine -> new FormLine(textLine.getText(), toBoundingBox(textLine.getBoundingBox()),\n+                readResultItem.getPage(), new IterableStream<>(toWords(textLine.getWords(), readResultItem.getPage()))))\n+            .collect(Collectors.toList());\n+        return formLines;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()}\n-     * to a SDK level {@link FloatValue}.\n+     * Helper method to set the {@link RecognizedForm#getFields() fields} from unlabeled result returned from the service.\n      *\n-     * @param serviceFloatValue The float value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueNumber()} .\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n      *\n-     * @return The {@link FloatValue}.\n+     * @return The fields populated on {@link RecognizedForm#getFields() fields}.\n      */\n-    private static FloatValue toFieldValueNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                     serviceFloatValue) {\n-        if (serviceFloatValue.getValueNumber() != null) {\n-            // TODO: Do not need this check, service team bug\n-            return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()),\n-                serviceFloatValue.getValueNumber(), serviceFloatValue.getPage());\n-        }\n+    static Map<String, FormField<?>> getUnlabeledFieldMap(boolean includeTextDetails, List<ReadResult> readResults,\n+        PageResult pageResultItem, Integer pageNumber) {\n+        Map<String, FormField<?>> formFieldMap = new TreeMap<>();\n+        List<KeyValuePair> keyValuePairs = pageResultItem.getKeyValuePairs();\n+        for (int i = 0; i < keyValuePairs.size(); i++) {\n+            KeyValuePair keyValuePair = keyValuePairs.get(i);\n+            IterableStream<FormContent> formKeyContentList = null;\n+            IterableStream<FormContent> formValueContentList = null;\n+            if (includeTextDetails && !CoreUtils.isNullOrEmpty(keyValuePair.getValue().getElements())) {\n+                formKeyContentList = setReferenceElements(keyValuePair.getKey().getElements(), readResults, pageNumber);\n+                formValueContentList = setReferenceElements(keyValuePair.getValue().getElements(), readResults, pageNumber);\n \n-        return new FloatValue(serviceFloatValue.getText(), toBoundingBox(serviceFloatValue.getBoundingBox()), null, serviceFloatValue.getPage());\n+            }\n+            String fieldName = \"field-\" + i;\n+            FieldText labelFieldText = new FieldText(keyValuePair.getKey().getText(), toBoundingBox(keyValuePair.getKey().getBoundingBox()), pageNumber, formKeyContentList);\n+            FieldText valueText = new FieldText(keyValuePair.getValue().getText(), toBoundingBox(keyValuePair.getValue().getBoundingBox()), pageNumber, formValueContentList);\n+            FormField<String> formField = new FormField<>(keyValuePair.getConfidence(), labelFieldText, fieldName, keyValuePair.getValue().getText(), valueText, pageNumber);\n+            formFieldMap.put(fieldName, formField);\n+        }\n+        return formFieldMap;\n     }\n \n     /**\n-     * Helper method to convert the service returned {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}\n-     * to a SDK level {@link StringValue}.\n-     *\n-     * @param serviceDateValue The string value returned by the service in\n-     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValuePhoneNumber()}.\n+     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n      *\n-     * @return The {@link StringValue}.\n+     * @return The list if referenced elements.\n      */\n-    private static StringValue toFieldValuePhoneNumber(com.azure.ai.formrecognizer.implementation.models.FieldValue\n-                                                  serviceDateValue) {\n-        return new StringValue(serviceDateValue.getText(), toBoundingBox(serviceDateValue.getBoundingBox()),\n-            serviceDateValue.getValuePhoneNumber(), serviceDateValue.getPage());\n+    private static IterableStream<FormContent> setReferenceElements(List<String> elements, List<ReadResult> readResults, Integer pageNumber) {\n+        List<FormContent> formContentList = new ArrayList<>();\n+        elements.forEach(elementString -> {\n+            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n+            int readResultIndex, lineIndex;\n+            if (indices.length >= 1) {", "originalCommit": "13796f3dcad2d9ab709d1f9eb712681d98d1ed7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1MDA0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407650048", "bodyText": "Should move the instantiation of USReceiptItem outside of the inner for loop, this will construct it when the entire entrySet has been processed and will churn a lot of short lived objects.", "author": "alzimmermsft", "createdAt": "2020-04-13T18:51:44Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/ReceiptExtensions.java", "diffHunk": "@@ -0,0 +1,133 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.ai.formrecognizer.models.USReceipt;\n+import com.azure.ai.formrecognizer.models.USReceiptItem;\n+import com.azure.ai.formrecognizer.models.USReceiptType;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+\n+/**\n+ * The ReceiptExtensions class to allow users to convert a {@link RecognizedReceipt}\n+ * to a receiptLocale specific Receipt type.\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public final class ReceiptExtensions {\n+\n+    /**\n+     * Static method to convert an incoming receipt to a {@link USReceipt type}.\n+     *\n+     * @param receipt The {@link RecognizedReceipt recognized receipt}.\n+     *\n+     * @return The converted {@link USReceipt US locale receipt} type.\n+     */\n+    public static USReceipt asUSReceipt(RecognizedReceipt receipt) {\n+        // add receipt fields\n+        USReceiptType receiptType = null;\n+        FormField<String> merchantName = null;\n+        FormField<String> merchantAddress = null;\n+        FormField<String> merchantPhoneNumber = null;\n+        FormField<Float> subtotal = null;\n+        FormField<Float> tax = null;\n+        FormField<Float> tip = null;\n+        FormField<Float> total = null;\n+        FormField<LocalDate> transactionDate = null;\n+        FormField<String> transactionTime = null;\n+        List<USReceiptItem> receiptItems = null;\n+\n+        for (Map.Entry<String, FormField<?>> entry : receipt.getRecognizedForm().getFields().entrySet()) {\n+            String key = entry.getKey();\n+            FormField<?> fieldValue = entry.getValue();\n+            switch (key) {\n+                case \"ReceiptType\":\n+                    receiptType = new USReceiptType(key, fieldValue.getConfidence());\n+                    break;\n+                case \"MerchantName\":\n+                    merchantName = (FormField<String>) fieldValue;\n+                    break;\n+                case \"MerchantAddress\":\n+                    merchantAddress = (FormField<String>) fieldValue;\n+                    break;\n+                case \"MerchantPhoneNumber\":\n+                    merchantPhoneNumber = (FormField<String>) fieldValue;\n+                    break;\n+                case \"Subtotal\":\n+                    subtotal = (FormField<Float>) fieldValue;\n+                    break;\n+                case \"Tax\":\n+                    tax = (FormField<Float>) fieldValue;\n+                    break;\n+                case \"Tip\":\n+                    tip = (FormField<Float>) fieldValue;\n+                    break;\n+                case \"Total\":\n+                    total = (FormField<Float>) fieldValue;\n+                    break;\n+                case \"TransactionDate\":\n+                    transactionDate = (FormField<LocalDate>) fieldValue;\n+                    break;\n+                case \"TransactionTime\":\n+                    transactionTime = (FormField<String>) fieldValue;\n+                    break;\n+                case \"Items\":\n+                    receiptItems = toReceiptItems(fieldValue);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        return new USReceipt(receipt.getReceiptLocale(), receipt.getRecognizedForm(), receiptItems, receiptType,\n+            merchantName, merchantAddress, merchantPhoneNumber, subtotal, tax, tip, total, transactionDate,\n+            transactionTime);\n+    }\n+\n+    /**\n+     * Helper method to convert the service level\n+     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray() value items}\n+     * to SDK level {@link USReceiptItem receipt items}.\n+     *\n+     * @param fieldValueItems The strongly typed field values.\n+     *\n+     * @return A list of {@link USReceiptItem}.\n+     */\n+    private static List<USReceiptItem> toReceiptItems(FormField<?> fieldValueItems) {\n+        List<FormField<?>> fieldValueArray = (List<FormField<?>>) fieldValueItems.getFieldValue();\n+        List<USReceiptItem> receiptItemList = new ArrayList<>();\n+        FormField<String> name = null;\n+        FormField<Float> quantity = null;\n+        FormField<Float> price = null;\n+        FormField<Float> totalPrice = null;\n+        USReceiptItem receiptItem = null;\n+\n+        for (FormField<?> eachFieldValue : fieldValueArray) {\n+            Map<String, FormField<?>> objectValue = ((Map<String, FormField<?>>) (eachFieldValue.getFieldValue()));\n+            for (Map.Entry<String, FormField<?>> entry : objectValue.entrySet()) {\n+                String key = entry.getKey();\n+                if (QUANTITY.toString().equals(key)) {\n+                    quantity = (FormField<Float>) entry.getValue();\n+                } else if (NAME.toString().equals(key)) {\n+                    name = (FormField<String>) entry.getValue();\n+                } else if (PRICE.toString().equals(key)) {\n+                    price = (FormField<Float>) entry.getValue();\n+                } else if (TOTAL_PRICE.toString().equals(key)) {\n+                    totalPrice = (FormField<Float>) entry.getValue();\n+                }\n+                receiptItem = new USReceiptItem(name, quantity, price, totalPrice);", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MzA4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407783088", "bodyText": "updated.", "author": "samvaity", "createdAt": "2020-04-13T23:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1MDA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1MTk3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407651971", "bodyText": "I've been seeing a lot of locations where an empty list will be passed into a constructor, what happens if null is passed? Is this to be a convenience for consumers of the library? If not it appears there will be many object pointers to empty lists.", "author": "alzimmermsft", "createdAt": "2020-04-13T18:55:15Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -52,326 +51,383 @@ private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap = null;\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n \n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult);\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (int i = 0; i < documentResults.size(); i++) {\n+\n+                DocumentResult documentResultItem = documentResults.get(i);\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getLabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n \n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+            extractedFormList.add(new RecognizedForm(extractedFieldMap, formType.get(), pageRange.get(),\n+                new IterableStream<FormPage>(formPages.subList(pageRange.get().getStartPageNumber(), pageRange.get().getEndPageNumber()))));\n+        }\n+\n+        // labeled\n+        if (pageResults != null) {\n+            for (int i = 0; i < pageResults.size(); i++) {\n+                PageResult pageResultItem = pageResults.get(i);\n+                Integer pageNumber = pageResultItem.getPage();\n+\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getUnlabeledFieldMap(includeTextDetails, readResults, pageResultItem, pageNumber);\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+                extractedFormList.add(\n+                    new RecognizedForm(extractedFieldMap, formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<FormPage>(Arrays.asList(formPages.get(pageNumber - 1)))));\n+            }\n         }\n+        return extractedFormList;\n+    }\n+\n+    /**\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n+     *\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     *\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n+     */\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<RecognizedReceipt> extractedReceiptList =\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm)).collect(Collectors.toList());\n+\n         return new IterableStream<>(extractedReceiptList);\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n+     * @param analyzeResult The service returned result for analyze layouts.\n+     *\n+     * @return The IterableStream of {@code FormPage}.\n+     */\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        for (int i = 0; i < readResults.size(); i++) {\n+            ReadResult readResultItem = readResults.get(i);\n+            PageResult pageResultItem;\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+                pageResultItem = pageResults.get(i);\n+                perPageTableList = getPageTables(pageResultItem, pageResultItem.getPage());\n+            }\n+\n+            // add form lines\n+            List<FormLine> perPageFormLineList = new ArrayList<>();\n+            if (!CoreUtils.isNullOrEmpty(readResultItem.getLines())) {\n+                perPageFormLineList = getReadResultFormLines(readResultItem);\n+            }\n+\n+            // get form tables\n+            formPages.add(getFormPage(readResultItem, perPageTableList, perPageFormLineList));", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MzAyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407783020", "bodyText": "I have updated the places where an empty list was created beforehand and have initialized it to null. It is acceptable for user scenarios to get back null rather than empty lists.", "author": "samvaity", "createdAt": "2020-04-13T23:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1MTk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1MjY2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407652665", "bodyText": "It may be more performant to use Collections.singletonList here, note that this will create an unmodifiable list so if this will be added onto that will throw an exception.", "author": "alzimmermsft", "createdAt": "2020-04-13T18:56:35Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -52,326 +51,383 @@ private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap = null;\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n \n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult);\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (int i = 0; i < documentResults.size(); i++) {\n+\n+                DocumentResult documentResultItem = documentResults.get(i);\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getLabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n \n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+            extractedFormList.add(new RecognizedForm(extractedFieldMap, formType.get(), pageRange.get(),\n+                new IterableStream<FormPage>(formPages.subList(pageRange.get().getStartPageNumber(), pageRange.get().getEndPageNumber()))));\n+        }\n+\n+        // labeled\n+        if (pageResults != null) {\n+            for (int i = 0; i < pageResults.size(); i++) {\n+                PageResult pageResultItem = pageResults.get(i);\n+                Integer pageNumber = pageResultItem.getPage();\n+\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getUnlabeledFieldMap(includeTextDetails, readResults, pageResultItem, pageNumber);\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+                extractedFormList.add(\n+                    new RecognizedForm(extractedFieldMap, formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<FormPage>(Arrays.asList(formPages.get(pageNumber - 1)))));", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTUwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407625509", "bodyText": "Consider naming this as transformTrainingErrors().", "author": "srnagar", "createdAt": "2020-04-13T18:06:54Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        com.azure.ai.formrecognizer.implementation.models.ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(new IllegalArgumentException(\"Invalid status Model Id.\"));\n+        }\n+\n+        List<FormRecognizerError> trainResultErrors = new ArrayList<>();\n+        if (modelResponse.getTrainResult().getErrors() != null) {\n+            trainResultErrors = setTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream().map(trainingDocumentItem -> {\n+                List<FormRecognizerError> documentErrors = new ArrayList<>();\n+                if (trainingDocumentItem.getErrors() != null) {\n+                    documentErrors = setTrainingErrors(trainingDocumentItem.getErrors());\n+                }\n+                return new TrainingDocumentInfo(trainingDocumentItem.getDocumentName(),\n+                    TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                    trainingDocumentItem.getPages(),\n+                    documentErrors);\n+            }).collect(Collectors.toList());\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                for (int i = 0, clusterFieldsSize = clusterFields.size(); i < clusterFieldsSize; i++) {\n+                    String eachField = clusterFields.get(i);\n+                    String fieldLabel = \"field-\" + i;\n+                    fieldMap.put(fieldLabel, new CustomFormModelField(fieldLabel, eachField, null));\n+                }\n+                CustomFormSubModel customFormSubModel = new CustomFormSubModel(null, fieldMap,\n+                    formType + clusterKey);\n+                subModelList.add(customFormSubModel);\n+            });\n+        } else if (modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getTrainResult().getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+            subModelList.add(new CustomFormSubModel(modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap, formType + modelInfo.getModelId()));\n+        }\n+\n+        return new CustomFormModel(modelInfo.getModelId().toString(),\n+            ModelTrainingStatus.fromString(modelInfo.getStatus().toString()),\n+            modelInfo.getCreatedDateTime(), modelInfo.getLastUpdatedDateTime(),\n+            new IterableStream<>(subModelList),\n+            trainResultErrors, trainingDocumentInfoList);\n+    }\n+\n+    /**\n+     * Helper method to convert the list of {@link ErrorInformation} to list of {@link FormRecognizerError}.\n+     *\n+     * @param trainingErrorList The list of {@link ErrorInformation}.\n+     *\n+     * @return The list of {@link FormRecognizerError}\n+     */\n+    private static List<FormRecognizerError> setTrainingErrors(List<ErrorInformation> trainingErrorList) {", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNzgwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407627802", "bodyText": "Can we use a HashMap instead or do we expect the keys to be sorted?", "author": "srnagar", "createdAt": "2020-04-13T18:11:11Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        com.azure.ai.formrecognizer.implementation.models.ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(new IllegalArgumentException(\"Invalid status Model Id.\"));\n+        }\n+\n+        List<FormRecognizerError> trainResultErrors = new ArrayList<>();\n+        if (modelResponse.getTrainResult().getErrors() != null) {\n+            trainResultErrors = setTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream().map(trainingDocumentItem -> {\n+                List<FormRecognizerError> documentErrors = new ArrayList<>();\n+                if (trainingDocumentItem.getErrors() != null) {\n+                    documentErrors = setTrainingErrors(trainingDocumentItem.getErrors());\n+                }\n+                return new TrainingDocumentInfo(trainingDocumentItem.getDocumentName(),\n+                    TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                    trainingDocumentItem.getPages(),\n+                    documentErrors);\n+            }).collect(Collectors.toList());\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzOTE3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407639173", "bodyText": "Same here - can this be a hashmap?", "author": "srnagar", "createdAt": "2020-04-13T18:32:03Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        com.azure.ai.formrecognizer.implementation.models.ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(new IllegalArgumentException(\"Invalid status Model Id.\"));\n+        }\n+\n+        List<FormRecognizerError> trainResultErrors = new ArrayList<>();\n+        if (modelResponse.getTrainResult().getErrors() != null) {\n+            trainResultErrors = setTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream().map(trainingDocumentItem -> {\n+                List<FormRecognizerError> documentErrors = new ArrayList<>();\n+                if (trainingDocumentItem.getErrors() != null) {\n+                    documentErrors = setTrainingErrors(trainingDocumentItem.getErrors());\n+                }\n+                return new TrainingDocumentInfo(trainingDocumentItem.getDocumentName(),\n+                    TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                    trainingDocumentItem.getPages(),\n+                    documentErrors);\n+            }).collect(Collectors.toList());\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                for (int i = 0, clusterFieldsSize = clusterFields.size(); i < clusterFieldsSize; i++) {\n+                    String eachField = clusterFields.get(i);\n+                    String fieldLabel = \"field-\" + i;\n+                    fieldMap.put(fieldLabel, new CustomFormModelField(fieldLabel, eachField, null));\n+                }\n+                CustomFormSubModel customFormSubModel = new CustomFormSubModel(null, fieldMap,\n+                    formType + clusterKey);\n+                subModelList.add(customFormSubModel);\n+            });\n+        } else if (modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MjUwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407782506", "bodyText": "We need to maintain the order of the entries so using a TreeMap instead.", "author": "samvaity", "createdAt": "2020-04-13T23:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzOTE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MzExMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407643111", "bodyText": "All these APIs should have @ServiceMethod annotation", "author": "srnagar", "createdAt": "2020-04-13T18:39:13Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -67,22 +83,209 @@ public FormRecognizerServiceVersion getServiceVersion() {\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract custom form operation until it has completed, has failed,\n+     * or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MzY1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407643658", "bodyText": "Make the duration a constant. So, if we have to change it later, we can change it in one place instead of updating all APIs.", "author": "srnagar", "createdAt": "2020-04-13T18:40:14Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -67,22 +83,209 @@ public FormRecognizerServiceVersion getServiceVersion() {\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract custom form operation until it has completed, has failed,\n+     * or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>\n+        beginRecognizeCustomFormsFromUrl(String fileSourceUrl, String modelId) {\n+        return beginRecognizeCustomFormsFromUrl(fileSourceUrl, modelId, false, null);\n+    }\n+\n+    /**\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     * @param includeTextDetails Include text lines and element references in the result.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract custom form operation until it has completed, has failed,\n+     * or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>\n+        beginRecognizeCustomFormsFromUrl(String fileSourceUrl, String modelId, boolean includeTextDetails,\n+        Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' is required and cannot be null.\");\n+        Objects.requireNonNull(modelId, \"'modelId' is required and cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : Duration.ofSeconds(5);", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NzYxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407647611", "bodyText": "Why do we have this client creating another client? Can this be done from the builder? If it's in the builder, then users don't have to create FormRecognizerAsyncClient first to get FormTrainingAsyncClient.", "author": "srnagar", "createdAt": "2020-04-13T18:47:24Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -57,6 +63,16 @@\n         this.serviceVersion = serviceVersion;\n     }\n \n+    /**\n+     * Creates a new {@link FormTrainingAsyncClient} object. The new {@code FormTrainingAsyncClient}\n+     * uses the same request policy pipeline as the {@code FormRecognizerAsyncClient}.\n+     *\n+     * @return A new {@link FormTrainingAsyncClient} object.\n+     */\n+    public FormTrainingAsyncClient getFormTrainingAsyncClient() {", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MDEzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407790136", "bodyText": "For preview 1, we decided to go ahead and explore it with a getter and in general understand the discoverability of sub-clients this way. Further, we hope user studies would help us to converge to the ideal approach that can be followed here.", "author": "samvaity", "createdAt": "2020-04-14T00:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NzYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0ODA0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407648041", "bodyText": "Same here - this can be created from the builder instead.", "author": "srnagar", "createdAt": "2020-04-13T18:48:05Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerClient.java", "diffHunk": "@@ -37,7 +40,175 @@\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Creates a new {@link FormTrainingClient} object.The new {@code FormRecognizerClient} uses the same request policy\n+     * pipeline as the {@code FormRecognizerClient}.\n+     *\n+     * @return A new {@link FormTrainingClient} object.\n+     */\n+    public FormTrainingClient getFormTrainingClient() {", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MDMyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407790322", "bodyText": "same as #9988 (comment)", "author": "samvaity", "createdAt": "2020-04-14T00:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0ODA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0ODI1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407648256", "bodyText": "Add @ServiceMethod annotation to this client APIs as well.", "author": "srnagar", "createdAt": "2020-04-13T18:48:27Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerClient.java", "diffHunk": "@@ -37,7 +40,175 @@\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Creates a new {@link FormTrainingClient} object.The new {@code FormRecognizerClient} uses the same request policy\n+     * pipeline as the {@code FormRecognizerClient}.\n+     *\n+     * @return A new {@link FormTrainingClient} object.\n+     */\n+    public FormTrainingClient getFormTrainingClient() {\n+        return new FormTrainingClient(client.getFormTrainingAsyncClient());\n+    }\n+\n+    /**\n+     * Recognizes and extracts receipt data from documents using optical character recognition (OCR)\n+     * and a custom trained model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     *\n+     * @return A {@link SyncPoller} to poll the progress of the extract custom form operation until it has completed,\n+     * has failed, or has been cancelled.\n+     */\n+    public SyncPoller<OperationResult, IterableStream<RecognizedForm>>", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1MjYzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407652630", "bodyText": "Sync client should not use Flux.", "author": "srnagar", "createdAt": "2020-04-13T18:56:32Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerClient.java", "diffHunk": "@@ -37,7 +40,175 @@\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Creates a new {@link FormTrainingClient} object.The new {@code FormRecognizerClient} uses the same request policy\n+     * pipeline as the {@code FormRecognizerClient}.\n+     *\n+     * @return A new {@link FormTrainingClient} object.\n+     */\n+    public FormTrainingClient getFormTrainingClient() {\n+        return new FormTrainingClient(client.getFormTrainingAsyncClient());\n+    }\n+\n+    /**\n+     * Recognizes and extracts receipt data from documents using optical character recognition (OCR)\n+     * and a custom trained model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     *\n+     * @return A {@link SyncPoller} to poll the progress of the extract custom form operation until it has completed,\n+     * has failed, or has been cancelled.\n+     */\n+    public SyncPoller<OperationResult, IterableStream<RecognizedForm>>\n+        beginExtractCustomFormsFromUrl(String fileSourceUrl, String modelId) {\n+        return beginExtractCustomFormsFromUrl(fileSourceUrl, modelId, false, null);\n+    }\n+\n+    /**\n+     * Recognizes and extracts receipt data from documents using optical character recognition (OCR)\n+     * and a custom trained model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param modelId The custom trained model Id to be used.\n+     * @param includeTextDetails Include text lines and element references in the result.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link SyncPoller} to poll the progress of the extract custom form operation until it has completed,\n+     * has failed, or has been cancelled.\n+     */\n+    public SyncPoller<OperationResult, IterableStream<RecognizedForm>>\n+        beginExtractCustomFormsFromUrl(String fileSourceUrl, String modelId, boolean includeTextDetails,\n+        Duration pollInterval) {\n+        return client.beginRecognizeCustomFormsFromUrl(fileSourceUrl, modelId, includeTextDetails, pollInterval)\n+            .getSyncPoller();\n+    }\n+\n+    /**\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param data The data of the document to be extract receipt information from.\n+     * @param modelId The custom trained model Id to be used.\n+     * @param length The exact length of the data. Size of the file must be less than 20 MB.\n+     * @param formContentType Supported Media types including .pdf, .jpg, .png or .tiff type file stream.\n+     *\n+     * @return A {@link SyncPoller} that polls the extract custom form operation until it has completed,\n+     * has failed, or has been cancelled.\n+     */\n+    public SyncPoller<OperationResult, IterableStream<RecognizedForm>>\n+        beginRecognizeCustomForms(Flux<ByteBuffer> data, String modelId, long length, FormContentType formContentType) {\n+        return beginRecognizeCustomForms(data, modelId, length, formContentType, false, null);\n+    }\n+\n+    /**\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param data The data of the document to be extract receipt information from.\n+     * @param modelId The custom trained model Id to be used.\n+     * @param length The exact length of the data. Size of the file must be less than 20 MB.\n+     * @param includeTextDetails Include text lines and element references in the result.\n+     * @param formContentType Supported Media types including .pdf, .jpg, .png or .tiff type file stream.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link SyncPoller} that polls the extract custom form operation until it has completed,\n+     * has failed, or has been cancelled.\n+     */\n+    public SyncPoller<OperationResult, IterableStream<RecognizedForm>>\n+        beginRecognizeCustomForms(Flux<ByteBuffer> data, String modelId, long length, FormContentType formContentType,", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1NDk0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407654945", "bodyText": "Add annotations.", "author": "srnagar", "createdAt": "2020-04-13T19:00:31Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,292 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations\n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+public class FormTrainingAsyncClient {", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1ODUzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407658537", "bodyText": "Update javadoc to specify that the model identifier is expected to be in UUID format. I would lean towards taking UUID as the input directly as the user anyway has to generate one from UUID.randomUUID().", "author": "srnagar", "createdAt": "2020-04-13T19:07:08Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,292 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations\n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+public class FormTrainingAsyncClient {\n+\n+    private final ClientLogger logger = new ClientLogger(FormTrainingAsyncClient.class);\n+    private final FormRecognizerClientImpl service;\n+    private final FormRecognizerServiceVersion serviceVersion;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param service The proxy service used to perform REST calls.\n+     * @param serviceVersion The versions of Azure Form Recognizer supported by this client library.\n+     */\n+    FormTrainingAsyncClient(FormRecognizerClientImpl service, FormRecognizerServiceVersion serviceVersion) {\n+        this.service = service;\n+        this.serviceVersion = serviceVersion;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return serviceVersion;\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link PollerFlux} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl,\n+        boolean useLabelFile, boolean includeSubFolders, String filePrefix, Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' cannot be null.\");\n+        Objects.requireNonNull(useLabelFile, \"'useLabelFile' cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : Duration.ofSeconds(5);\n+\n+        return new PollerFlux<OperationResult, CustomFormModel>(\n+            interval,\n+            getTrainingActivationOperation(fileSourceUrl, includeSubFolders, filePrefix, useLabelFile),\n+            createTrainingPollOperation(),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchTrainingModelResultOperation());\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id.\n+     *\n+     * @param modelId Model identifier.\n+     *\n+     * @return The detailed information for the specified model.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<CustomFormModel> getCustomModel(String modelId) {\n+        return getCustomFormModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id with Http response\n+     *\n+     * @param modelId Model identifier.", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxNzU2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407817564", "bodyText": "It is expected as String for now as it allows the service team to evolve to other string formats in the future.\nI will update the javadoc.", "author": "samvaity", "createdAt": "2020-04-14T01:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1ODUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MjQ0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407662445", "bodyText": "Add annotations.", "author": "srnagar", "createdAt": "2020-04-13T19:14:30Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingClient.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.polling.SyncPoller;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+\n+/**\n+ * This class provides a synchronous client that contains model management the operations that apply\n+ * to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+public class FormTrainingClient {", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NDU0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407664548", "bodyText": "Add a private ctor.", "author": "srnagar", "createdAt": "2020-04-13T19:18:37Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/ReceiptExtensions.java", "diffHunk": "@@ -0,0 +1,133 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.ai.formrecognizer.models.USReceipt;\n+import com.azure.ai.formrecognizer.models.USReceiptItem;\n+import com.azure.ai.formrecognizer.models.USReceiptType;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+\n+/**\n+ * The ReceiptExtensions class to allow users to convert a {@link RecognizedReceipt}\n+ * to a receiptLocale specific Receipt type.\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public final class ReceiptExtensions {", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NDk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407664940", "bodyText": "Prefer to have this suppresswarnings at the method level instead of having it for the entire class.", "author": "srnagar", "createdAt": "2020-04-13T19:19:15Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/ReceiptExtensions.java", "diffHunk": "@@ -0,0 +1,133 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.ai.formrecognizer.models.USReceipt;\n+import com.azure.ai.formrecognizer.models.USReceiptItem;\n+import com.azure.ai.formrecognizer.models.USReceiptType;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+\n+/**\n+ * The ReceiptExtensions class to allow users to convert a {@link RecognizedReceipt}\n+ * to a receiptLocale specific Receipt type.\n+ */\n+@SuppressWarnings(\"unchecked\")", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NjAzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407666031", "bodyText": "As per naming conventions, acronyms should follow camel-case convention but in this case, I am not sure naming this as asUsReceipt is good.", "author": "srnagar", "createdAt": "2020-04-13T19:21:10Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/ReceiptExtensions.java", "diffHunk": "@@ -0,0 +1,133 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.ai.formrecognizer.models.USReceipt;\n+import com.azure.ai.formrecognizer.models.USReceiptItem;\n+import com.azure.ai.formrecognizer.models.USReceiptType;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+\n+/**\n+ * The ReceiptExtensions class to allow users to convert a {@link RecognizedReceipt}\n+ * to a receiptLocale specific Receipt type.\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public final class ReceiptExtensions {\n+\n+    /**\n+     * Static method to convert an incoming receipt to a {@link USReceipt type}.\n+     *\n+     * @param receipt The {@link RecognizedReceipt recognized receipt}.\n+     *\n+     * @return The converted {@link USReceipt US locale receipt} type.\n+     */\n+    public static USReceipt asUSReceipt(RecognizedReceipt receipt) {", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3MjUwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408372501", "bodyText": "I think that is what we had decided as a team. Do you have any suggestions we discuss it with the crew.", "author": "samvaity", "createdAt": "2020-04-14T19:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NjAzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MTYyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409051628", "bodyText": "Either leave US as-is or expand it. Don't really like changing this to Us. Check with @JonathanGiles  too.", "author": "srnagar", "createdAt": "2020-04-15T18:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NjAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MDExOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407670118", "bodyText": "Include the operationLocation in the error message for debuggability.", "author": "srnagar", "createdAt": "2020-04-13T19:29:03Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -49,4 +50,22 @@ private static ByteBuffer toByteArray(InputStream in) {\n             throw LOGGER.logExceptionAsError(new RuntimeException(e));\n         }\n     }\n+\n+    /**\n+     * Extracts the result ID from the URL.\n+     *\n+     * @param operationLocation The URL specified in the 'Operation-Location' response header containing the\n+     * resultId used to track the progress and obtain the result of the analyze operation.\n+     *\n+     * @return The resultId used to track the progress.\n+     */\n+    public static String parseModelId(String operationLocation) {\n+        if (!CoreUtils.isNullOrEmpty(operationLocation)) {\n+            int lastIndex = operationLocation.lastIndexOf('/');\n+            if (lastIndex != -1) {\n+                return operationLocation.substring(lastIndex + 1);\n+            }\n+        }\n+        throw LOGGER.logExceptionAsError(new RuntimeException(\"Failed to parse operation header for result Id.\"));", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MjM3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407672377", "bodyText": "Why do we have IterableStream in one and List in another as return type?", "author": "srnagar", "createdAt": "2020-04-13T19:33:22Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/CustomFormModel.java", "diffHunk": "@@ -0,0 +1,142 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.util.IterableStream;\n+\n+import java.time.OffsetDateTime;\n+import java.util.List;\n+\n+/**\n+ * The CustomFormModel\n+ */\n+@Immutable\n+public final class CustomFormModel {\n+\n+    /*\n+     * List of errors returned during the training operation.\n+     */\n+    private final List<FormRecognizerError> modelError;\n+\n+    /*\n+     * Model identifier.\n+     */\n+    private final String modelId;\n+\n+    /*\n+     * Status of the model.\n+     */\n+    private final ModelTrainingStatus modelStatus;\n+\n+    /*\n+     * Date and time (UTC) when the model was created.\n+     */\n+    private final OffsetDateTime createdOn;\n+\n+    /*\n+     * Date and time (UTC) when the status was last updated.\n+     */\n+    private final OffsetDateTime lastUpdatedOn;\n+\n+    /*\n+     * List of sub models.\n+     */\n+    private final IterableStream<CustomFormSubModel> subModels;\n+\n+    /*\n+     * List of the documents used to train the model.\n+     */\n+    private final List<TrainingDocumentInfo> trainingDocuments;\n+\n+    /**\n+     * Constructs a CustomFormModel object.\n+     *\n+     * @param modelId Model identifier.\n+     * @param modelStatus Status of the model.\n+     * @param createdOn Date and time (UTC) when the model was created.\n+     * @param lastUpdatedOn Date and time (UTC) when the status was last updated.\n+     * @param subModels List of sub models.\n+     * @param modelError List of errors returned during the training operation.\n+     * @param trainingDocuments List of the documents used to train the model.\n+     */\n+    public CustomFormModel(final String modelId, final ModelTrainingStatus modelStatus,\n+        final OffsetDateTime createdOn, final OffsetDateTime lastUpdatedOn,\n+        final IterableStream<CustomFormSubModel> subModels, final List<FormRecognizerError> modelError,\n+        final List<TrainingDocumentInfo> trainingDocuments) {\n+        this.modelId = modelId;\n+        this.modelStatus = modelStatus;\n+        this.createdOn = createdOn;\n+        this.lastUpdatedOn = lastUpdatedOn;\n+        this.subModels = subModels;\n+        this.modelError = modelError;\n+        this.trainingDocuments = trainingDocuments;\n+    }\n+\n+    /**\n+     * Get the modelId property: Model identifier.\n+     *\n+     * @return the modelId value.\n+     */\n+    public String getModelId() {\n+        return this.modelId;\n+    }\n+\n+    /**\n+     * Get the status property: Status of the model.\n+     *\n+     * @return the status value.\n+     */\n+    public ModelTrainingStatus getModelStatus() {\n+        return this.modelStatus;\n+    }\n+\n+    /**\n+     * Get the createdDateTime property: Date and time (UTC) when the model was\n+     * created.\n+     *\n+     * @return the createdDateTime value.\n+     */\n+    public OffsetDateTime getCreatedOn() {\n+        return this.createdOn;\n+    }\n+\n+    /**\n+     * Get the lastUpdatedDateTime property: Date and time (UTC) when the\n+     * status was last updated.\n+     *\n+     * @return the lastUpdatedDateTime value.\n+     */\n+    public OffsetDateTime getLastUpdatedOn() {\n+        return this.lastUpdatedOn;\n+    }\n+\n+    /**\n+     * Get the errors property: Errors returned during the training operation.\n+     *\n+     * @return the errors value.\n+     */\n+    public List<FormRecognizerError> getModelError() {\n+        return this.modelError;\n+    }\n+\n+    /**\n+     * Get the sub models property: The sub models returned during the training operation.\n+     *\n+     * @return the sub models value.\n+     */\n+    public IterableStream<CustomFormSubModel> getSubModels() {\n+        return this.subModels;\n+    }\n+\n+    /**\n+     * Get the trainingDocuments property: List of the documents used to train\n+     * the model and any errors reported in each document.\n+     *\n+     * @return the trainingDocuments value.\n+     */\n+    public List<TrainingDocumentInfo> getTrainingDocuments() {\n+        return this.trainingDocuments;\n+    }", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2NDE0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407864142", "bodyText": "updated both to be of type IterableStream", "author": "samvaity", "createdAt": "2020-04-14T04:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3MjM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NTA4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407685083", "bodyText": "Uncomment this.", "author": "srnagar", "createdAt": "2020-04-13T19:57:45Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/CustomModelOperations.java", "diffHunk": "@@ -0,0 +1,63 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.Context;\n+\n+/**\n+ * Sample for demonstrating common custom model management operations.\n+ */\n+public class CustomModelOperations {\n+\n+    /**\n+     * Main program to invoke the demo for performing operations of a custom model.\n+     *\n+     * @param args Unused. Arguments to the program.\n+     */\n+    public static void main(final String[] args) {\n+        // Instantiate a client that will be used to call the service.\n+        FormTrainingClient client = new FormRecognizerClientBuilder()\n+            .apiKey(new AzureKeyCredential(\"{api_key}\"))\n+            .endpoint(\"https://{endpoint}.cognitiveservices.azure.com/\")\n+            .buildClient().getFormTrainingClient();\n+\n+        String modelId = \"{model-Id}\";\n+        // Get Custom Model\n+        CustomFormModel customModel = client.getCustomModel(modelId);\n+        System.out.printf(\"Model Id: %s%n\", customModel.getModelId());\n+        System.out.printf(\"Model Status: %s%n\", customModel.getModelStatus());\n+        customModel.getSubModels().forEach(customFormSubModel -> {\n+            System.out.printf(\"Custom Model Form type: %s%n\", customFormSubModel.getFormType());\n+            System.out.printf(\"Custom Model Accuracy: %s%n\", customFormSubModel.getAccuracy());\n+            if (customFormSubModel.getFieldMap() != null) {\n+                customFormSubModel.getFieldMap().forEach((fieldText, customFormModelField) -> {\n+                    System.out.printf(\"Field Text: %s%n\", fieldText);\n+                    System.out.printf(\"Field Accuracy: %s%n\", customFormModelField.getAccuracy());\n+                });\n+            }\n+            // Model Training info\n+            System.out.println(\"Model Training Info:\");\n+            customModel.getTrainingDocuments().forEach(trainingDocumentInfo -> {\n+                System.out.printf(\"Training document Name: %s%n\", trainingDocumentInfo.getName());\n+                System.out.printf(\"Training document Status: %s%n\", trainingDocumentInfo.getTrainingStatus());\n+            });\n+        });\n+\n+        // Get model Info\n+        AccountProperties accountProperties = client.getAccountProperties();\n+        System.out.println(\"Account Properties\");\n+        System.out.printf(\"Model count in subscription : %s%n\", modelId, accountProperties.getCount());\n+        System.out.printf(\"Model limit in subsciption: %s%n\", accountProperties.getLimit());\n+\n+        // Delete Custom Model\n+        System.out.printf(\"Deleted model with model Id: %s operation completed with status: %s%n\", modelId,\n+            client.deleteModelWithResponse(modelId, Context.NONE).getStatusCode());\n+\n+        // List Custom Model\n+        // client.listModels()", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MjE3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407782171", "bodyText": "Dependent on this open PR - #9975.", "author": "samvaity", "createdAt": "2020-04-13T23:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NTA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NTQxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407685413", "bodyText": "empty class?", "author": "srnagar", "createdAt": "2020-04-13T19:58:21Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/test/java/com/azure/ai/formrecognizer/FormTrainingClientTest.java", "diffHunk": "@@ -0,0 +1,7 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+public class FormTrainingClientTest {", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MDkzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407760935", "bodyText": "Should the message be something changed to something like: Invalid status for Model Id: {modelInfo.getModelId().ToString()}?", "author": "maririos", "createdAt": "2020-04-13T22:40:12Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        com.azure.ai.formrecognizer.implementation.models.ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(new IllegalArgumentException(\"Invalid status Model Id.\"));", "originalCommit": "3d86e383c1a587c09bfe0dfbd23e91a98d0f514b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg4NzczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407887736", "bodyText": "Looks like label and name are mixed (?)\nname should contain the \"field-\" string, and label the value you have in eachField", "author": "maririos", "createdAt": "2020-04-14T06:07:19Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    public static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                    trainingDocumentItem.getDocumentName(),\n+                    TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                    trainingDocumentItem.getPages(),\n+                    new IterableStream<FormRecognizerError>(transformTrainingErrors(trainingDocumentItem.getErrors()))))\n+                .collect(Collectors.toList());\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                for (int i = 0, clusterFieldsSize = clusterFields.size(); i < clusterFieldsSize; i++) {\n+                    String eachField = clusterFields.get(i);\n+                    String fieldLabel = \"field-\" + i;", "originalCommit": "17cab82f69992bba788ea4f9d3b696982074c27d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Njk1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408366959", "bodyText": "Oh yes, thank you for finding that!", "author": "samvaity", "createdAt": "2020-04-14T19:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg4NzczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NTIwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407895203", "bodyText": "Will this apply even if this is accuracy and not confidence?", "author": "maririos", "createdAt": "2020-04-14T06:28:24Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    public static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                    trainingDocumentItem.getDocumentName(),\n+                    TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                    trainingDocumentItem.getPages(),\n+                    new IterableStream<FormRecognizerError>(transformTrainingErrors(trainingDocumentItem.getErrors()))))\n+                .collect(Collectors.toList());\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                for (int i = 0, clusterFieldsSize = clusterFields.size(); i < clusterFieldsSize; i++) {\n+                    String eachField = clusterFields.get(i);\n+                    String fieldLabel = \"field-\" + i;\n+                    fieldMap.put(fieldLabel, new CustomFormModelField(fieldLabel, eachField, null));\n+                }\n+                subModelList.add(new CustomFormSubModel(\n+                    DEFAULT_CONFIDENCE_VALUE,", "originalCommit": "17cab82f69992bba788ea4f9d3b696982074c27d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwNjE4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r407906182", "bodyText": "It shouldn't apply to accuracy, updated!", "author": "samvaity", "createdAt": "2020-04-14T06:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NTIwMw=="}], "type": "inlineReview"}, {"oid": "c90608f61f528d78c10bb7f12eb9fe8f17a93908", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c90608f61f528d78c10bb7f12eb9fe8f17a93908", "message": "additional tests for custom forms", "committedDate": "2020-04-14T06:55:17Z", "type": "forcePushed"}, {"oid": "8d5b01b07c8c31acdbf4e90d2f19818a279f4136", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8d5b01b07c8c31acdbf4e90d2f19818a279f4136", "message": "update to new design", "committedDate": "2020-04-14T16:57:28Z", "type": "commit"}, {"oid": "77d8b4487ba5d15a4b246ab6c11f007fa87e5fb5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/77d8b4487ba5d15a4b246ab6c11f007fa87e5fb5", "message": "checkstyle", "committedDate": "2020-04-14T16:57:34Z", "type": "commit"}, {"oid": "1db662e4cc0e27c43b6ba847855ce8e4a1b22e53", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1db662e4cc0e27c43b6ba847855ce8e4a1b22e53", "message": "Form Training async client test part 1", "committedDate": "2020-04-14T16:57:56Z", "type": "commit"}, {"oid": "aa9264e4caad13c487e19fe6612ceaeb8b70cc04", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aa9264e4caad13c487e19fe6612ceaeb8b70cc04", "message": "update form recognizer endpoint models", "committedDate": "2020-04-14T16:58:30Z", "type": "commit"}, {"oid": "8576463b55913dbeacabd9f2ff07d36b33f478b4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8576463b55913dbeacabd9f2ff07d36b33f478b4", "message": "update model transforms for fieldMap", "committedDate": "2020-04-14T16:58:34Z", "type": "commit"}, {"oid": "6db06c5bbf07f93122c97732e265fe1d6f6ae732", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6db06c5bbf07f93122c97732e265fe1d6f6ae732", "message": "Remove generic fieldvalue instead use generic FormField", "committedDate": "2020-04-14T17:00:02Z", "type": "commit"}, {"oid": "a1432425a544135a7edfd940dd496746d29e25d6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a1432425a544135a7edfd940dd496746d29e25d6", "message": "Add form recognizer async tests", "committedDate": "2020-04-14T17:00:11Z", "type": "commit"}, {"oid": "5f22d8e381300a333c4d815a6bd7a59c1afa6084", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5f22d8e381300a333c4d815a6bd7a59c1afa6084", "message": "update sync tests", "committedDate": "2020-04-14T17:00:35Z", "type": "commit"}, {"oid": "181b7885a4c0e13ec6748abbb65e4421f1360986", "url": "https://github.com/Azure/azure-sdk-for-java/commit/181b7885a4c0e13ec6748abbb65e4421f1360986", "message": "review comments", "committedDate": "2020-04-14T17:00:40Z", "type": "commit"}, {"oid": "434bdaf8655af0ec832374bbdffd92c2de0216e6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/434bdaf8655af0ec832374bbdffd92c2de0216e6", "message": "review comments", "committedDate": "2020-04-14T17:01:15Z", "type": "commit"}, {"oid": "5dee66b6bda4859850f98e71f4fe6762d15b7d23", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5dee66b6bda4859850f98e71f4fe6762d15b7d23", "message": "additional tests for custom forms", "committedDate": "2020-04-14T17:01:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI4NTY5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408285692", "bodyText": "Why do we instantiate clusterFieldSize in the for loop and use it nowhere else?", "author": "alzimmermsft", "createdAt": "2020-04-14T16:48:55Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,117 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                    trainingDocumentItem.getDocumentName(),\n+                    TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                    trainingDocumentItem.getPages(),\n+                    new IterableStream<FormRecognizerError>(transformTrainingErrors(trainingDocumentItem.getErrors()))))\n+                .collect(Collectors.toList());\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                for (int i = 0, clusterFieldsSize = clusterFields.size(); i < clusterFieldsSize; i++) {", "originalCommit": "c90608f61f528d78c10bb7f12eb9fe8f17a93908", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI4ODk2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408288969", "bodyText": "I'm seeing a lot of cases where we are looping over an iterable where we also need to know which index we are at, should we add a helper function which takes a BiConsumer<Integer, T> which will maintain the index count and pass the appropriate element?\nstatic void forEachWithIndex(Iterable<T> iterable, BiConsumer<Integer, T> biConsumer) {\n  int[] index = new int[] { 0 };\n  iterable.forEach(element -> biConsumer.accept(index[0]++, element));\n}", "author": "alzimmermsft", "createdAt": "2020-04-14T16:53:52Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,117 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                    trainingDocumentItem.getDocumentName(),\n+                    TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                    trainingDocumentItem.getPages(),\n+                    new IterableStream<FormRecognizerError>(transformTrainingErrors(trainingDocumentItem.getErrors()))))\n+                .collect(Collectors.toList());\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                for (int i = 0, clusterFieldsSize = clusterFields.size(); i < clusterFieldsSize; i++) {\n+                    String eachField = clusterFields.get(i);", "originalCommit": "c90608f61f528d78c10bb7f12eb9fe8f17a93908", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Njc1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408366758", "bodyText": "Updated!", "author": "samvaity", "createdAt": "2020-04-14T19:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI4ODk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5MjcxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408292716", "bodyText": "Do we need this class? It seems to be a copy of ModelStatus.", "author": "alzimmermsft", "createdAt": "2020-04-14T16:59:23Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/ModelTrainingStatus.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.util.ExpandableStringEnum;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Defines enum values for ModelTrainingStatus.\n+ */\n+public final class ModelTrainingStatus extends ExpandableStringEnum<ModelTrainingStatus> {", "originalCommit": "c90608f61f528d78c10bb7f12eb9fe8f17a93908", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408318736", "bodyText": "Isn't ModelStatus an implementation/model class and we don't want to be using those?", "author": "samvaity", "createdAt": "2020-04-14T17:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5MjcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2NzM4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408367380", "bodyText": "ModelStatus is a generated enum which are generally fine to have in the public API (generated models are too but they need more hand holding sometimes). I think it would be better to move ModelStatus into public API and use it instead of making a copy of it.", "author": "alzimmermsft", "createdAt": "2020-04-14T19:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5MjcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDQ4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408294487", "bodyText": "Lets have this return IterableStream instead, I don't see the List return being used for anything other than constructing an IterableStream. With this change we could optimize the null or empty case to return IterableStream.of(null) which optimizes to a static immutable instance.", "author": "alzimmermsft", "createdAt": "2020-04-14T17:02:07Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,117 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                    trainingDocumentItem.getDocumentName(),\n+                    TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                    trainingDocumentItem.getPages(),\n+                    new IterableStream<FormRecognizerError>(transformTrainingErrors(trainingDocumentItem.getErrors()))))\n+                .collect(Collectors.toList());\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                for (int i = 0, clusterFieldsSize = clusterFields.size(); i < clusterFieldsSize; i++) {\n+                    String eachField = clusterFields.get(i);\n+                    String fieldLabel = \"field-\" + i;\n+                    fieldMap.put(fieldLabel, new CustomFormModelField(fieldLabel, eachField, null));\n+                }\n+                subModelList.add(new CustomFormSubModel(\n+                    null,\n+                    fieldMap,\n+                    formType + clusterKey));\n+            });\n+        } else if (modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getTrainResult().getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+            subModelList.add(new CustomFormSubModel(\n+                modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap,\n+                formType + modelInfo.getModelId()));\n+        }\n+\n+        return new CustomFormModel(\n+            modelInfo.getModelId().toString(),\n+            ModelTrainingStatus.fromString(modelInfo.getStatus().toString()),\n+            modelInfo.getCreatedDateTime(),\n+            modelInfo.getLastUpdatedDateTime(),\n+            new IterableStream<>(subModelList),\n+            new IterableStream<FormRecognizerError>(\n+                transformTrainingErrors(modelResponse.getTrainResult().getErrors())),\n+            new IterableStream<TrainingDocumentInfo>(trainingDocumentInfoList));\n+    }\n+\n+    /**\n+     * Helper method to convert the list of {@link ErrorInformation} to list of {@link FormRecognizerError}.\n+     *\n+     * @param trainingErrorList The list of {@link ErrorInformation}.\n+     *\n+     * @return The list of {@link FormRecognizerError}\n+     */\n+    private static List<FormRecognizerError> transformTrainingErrors(List<ErrorInformation> trainingErrorList) {", "originalCommit": "c90608f61f528d78c10bb7f12eb9fe8f17a93908", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwMjAzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408302033", "bodyText": "Any reason this handles the exception case differently?", "author": "alzimmermsft", "createdAt": "2020-04-14T17:14:34Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -203,21 +422,160 @@ public FormRecognizerServiceVersion getServiceVersion() {\n         };\n     }\n \n-    private Function<PollingContext<OperationResult>, Mono<IterableStream<ExtractedReceipt>>>\n+    private Function<PollingContext<OperationResult>, Mono<IterableStream<RecognizedReceipt>>>\n         fetchExtractReceiptResult(boolean includeTextDetails) {\n         return (pollingContext) -> {\n             final UUID resultUid = UUID.fromString(pollingContext.getLatestResponse().getValue().getResultId());\n             return service.getAnalyzeReceiptResultWithResponseAsync(resultUid)\n-                .map(modelSimpleResponse -> toReceipt(modelSimpleResponse.getValue().getAnalyzeResult(),\n-                    includeTextDetails));\n+                .map(modelSimpleResponse -> {\n+                    throwIfAnalyzeStatusInvalid(modelSimpleResponse);\n+                    return toReceipt(modelSimpleResponse.getValue().getAnalyzeResult(),\n+                        includeTextDetails);\n+                });\n+        };\n+    }\n+\n+    private Function<PollingContext<OperationResult>, Mono<OperationResult>> contentAnalyzeActivationOperation(\n+        String sourceUrl) {\n+        return (pollingContext) -> {\n+            try {\n+                return service.analyzeLayoutAsyncWithResponseAsync(new SourcePath().setSource(sourceUrl))\n+                    .map(response ->\n+                        new OperationResult(parseModelId(response.getDeserializedHeaders().getOperationLocation())));\n+            } catch (RuntimeException ex) {\n+                return monoError(logger, ex);\n+            }\n+        };\n+    }\n+\n+    private Function<PollingContext<OperationResult>, Mono<OperationResult>> contentStreamActivationOperation(\n+        Flux<ByteBuffer> buffer, long length, FormContentType formContentType) {\n+        return (pollingContext) -> {\n+            try {\n+                return service.analyzeLayoutAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n+                    buffer, length)\n+                    .map(response -> new OperationResult(\n+                        parseModelId(response.getDeserializedHeaders().getOperationLocation())));\n+            } catch (RuntimeException ex) {\n+                return monoError(logger, ex);\n+            }\n+        };\n+    }\n+\n+    private Function<PollingContext<OperationResult>, Mono<PollResponse<OperationResult>>>\n+        extractContentPollOperation() {\n+        return (pollingContext) -> {\n+            PollResponse<OperationResult> operationResultPollResponse = pollingContext.getLatestResponse();\n+            String modelId = operationResultPollResponse.getValue().getResultId();\n+            try {\n+                UUID resultUid = UUID.fromString(modelId);\n+                return service.getAnalyzeLayoutResultWithResponseAsync(resultUid)\n+                    .flatMap(modelSimpleResponse -> processAnalyzeModelResponse(modelSimpleResponse,\n+                        operationResultPollResponse));\n+            } catch (HttpResponseException e) {\n+                logger.logExceptionAsError(e);\n+                return Mono.just(new PollResponse<>(LongRunningOperationStatus.FAILED, null));\n+            }", "originalCommit": "c90608f61f528d78c10bb7f12eb9fe8f17a93908", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyMjgxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408322814", "bodyText": "This is consistent all across. The other way of handling exceptions is when the service returns a 200 OK and creates a response with the model returning an invalid status.", "author": "samvaity", "createdAt": "2020-04-14T17:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwMjAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwMzM5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408303390", "bodyText": "Other than the activation method and the result are these poller helper methods different? Could it be combined into a single helper method?", "author": "alzimmermsft", "createdAt": "2020-04-14T17:16:49Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -203,21 +422,160 @@ public FormRecognizerServiceVersion getServiceVersion() {\n         };\n     }\n \n-    private Function<PollingContext<OperationResult>, Mono<IterableStream<ExtractedReceipt>>>\n+    private Function<PollingContext<OperationResult>, Mono<IterableStream<RecognizedReceipt>>>\n         fetchExtractReceiptResult(boolean includeTextDetails) {\n         return (pollingContext) -> {\n             final UUID resultUid = UUID.fromString(pollingContext.getLatestResponse().getValue().getResultId());\n             return service.getAnalyzeReceiptResultWithResponseAsync(resultUid)\n-                .map(modelSimpleResponse -> toReceipt(modelSimpleResponse.getValue().getAnalyzeResult(),\n-                    includeTextDetails));\n+                .map(modelSimpleResponse -> {\n+                    throwIfAnalyzeStatusInvalid(modelSimpleResponse);\n+                    return toReceipt(modelSimpleResponse.getValue().getAnalyzeResult(),\n+                        includeTextDetails);\n+                });\n+        };\n+    }\n+\n+    private Function<PollingContext<OperationResult>, Mono<OperationResult>> contentAnalyzeActivationOperation(", "originalCommit": "c90608f61f528d78c10bb7f12eb9fe8f17a93908", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2NjIxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408366213", "bodyText": "Would like to consider doing this post preview 1 - #10187", "author": "samvaity", "createdAt": "2020-04-14T19:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwMzM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzNzk2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408337967", "bodyText": "not sure how Java does it, but asking the same Krista pointed out in in .net,\nTrainResult can be null. So, will modelResponse.getTrainResult().getTrainingDocuments() and all other references work?", "author": "maririos", "createdAt": "2020-04-14T18:12:24Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,117 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList =\n+            modelResponse.getTrainResult().getTrainingDocuments().stream()", "originalCommit": "c90608f61f528d78c10bb7f12eb9fe8f17a93908", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2NDYxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408364612", "bodyText": "Updated to check for trainResult as it can be null before referencing the training documents.", "author": "samvaity", "createdAt": "2020-04-14T18:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzNzk2Nw=="}], "type": "inlineReview"}, {"oid": "31db43cfbbcde31e291f240be50b00a01490dc13", "url": "https://github.com/Azure/azure-sdk-for-java/commit/31db43cfbbcde31e291f240be50b00a01490dc13", "message": "rebase changes", "committedDate": "2020-04-14T18:56:26Z", "type": "commit"}, {"oid": "31db43cfbbcde31e291f240be50b00a01490dc13", "url": "https://github.com/Azure/azure-sdk-for-java/commit/31db43cfbbcde31e291f240be50b00a01490dc13", "message": "rebase changes", "committedDate": "2020-04-14T18:56:26Z", "type": "forcePushed"}, {"oid": "045af61fb937f554ea05fcfad70561bc72944faa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/045af61fb937f554ea05fcfad70561bc72944faa", "message": "ModelTrainingStatus rename, deleteModel tests", "committedDate": "2020-04-14T20:57:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU1ODU1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408558557", "bodyText": "Not sure if this is somewhere else in the code, but how are we handling that by default we want Prefix=\"\" and includeSubFolders=false?", "author": "maririos", "createdAt": "2020-04-15T03:24:18Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingClient.java", "diffHunk": "@@ -0,0 +1,190 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.polling.SyncPoller;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+\n+/**\n+ * This class provides a synchronous client that contains model management the operations that apply\n+ * to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+@ServiceClient(builder = FormRecognizerClientBuilder.class)\n+public class FormTrainingClient {\n+\n+    private final FormTrainingAsyncClient client;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param formTrainingAsyncClient The {@link FormRecognizerAsyncClient} that the client routes its request through.\n+     */\n+    FormTrainingClient(FormTrainingAsyncClient formTrainingAsyncClient) {\n+        this.client = formTrainingAsyncClient;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return client.getServiceVersion();\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content\n+     * type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible\n+     * Azure storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link SyncPoller} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public SyncPoller<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type - 'application/pdf',\n+     * 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure storage\n+     * blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link SyncPoller} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public SyncPoller<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile,\n+        boolean includeSubFolders, String filePrefix, Duration pollInterval) {\n+        return client.beginTraining(fileSourceUrl, useLabelFile, includeSubFolders,", "originalCommit": "045af61fb937f554ea05fcfad70561bc72944faa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU2NDgwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408564800", "bodyText": "The other overload of this sets the includeSubFolders=false for users. And for Prefix we accept it as String so it can be passed as null, don't set it to empty if not specified.", "author": "samvaity", "createdAt": "2020-04-15T03:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU1ODU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU2NTk3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408565976", "bodyText": "Great! thanks for the pointer", "author": "maririos", "createdAt": "2020-04-15T03:56:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU1ODU1Nw=="}], "type": "inlineReview"}, {"oid": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a845a82dea48e915ebdedfefbb740f39cf6ed28e", "message": "model updates, null checks", "committedDate": "2020-04-15T10:20:22Z", "type": "commit"}, {"oid": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a845a82dea48e915ebdedfefbb740f39cf6ed28e", "message": "model updates, null checks", "committedDate": "2020-04-15T10:20:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5NjUxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408996512", "bodyText": "Is this class really needed? This seems to be another representation of Stream.map.", "author": "alzimmermsft", "createdAt": "2020-04-15T17:02:49Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.CustomFormModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.ai.formrecognizer.Transforms.forEachWithIndex;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList = null;\n+        IterableStream<FormRecognizerError> modelErrors = null;\n+\n+        if (modelResponse.getTrainResult() != null) {\n+            trainingDocumentInfoList =\n+                modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                        trainingDocumentItem.getDocumentName(),\n+                        TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                        trainingDocumentItem.getPages(),\n+                        transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .collect(Collectors.toList());\n+            modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                forEachWithIndex(clusterFields, (index, eachField) -> {\n+                    String fieldName = \"field-\" + index;\n+                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n+                });\n+                subModelList.add(new CustomFormSubModel(\n+                    null,\n+                    fieldMap,\n+                    formType + clusterKey));\n+            });\n+        } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getTrainResult().getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+            subModelList.add(new CustomFormSubModel(\n+                modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap,\n+                formType + modelInfo.getModelId()));\n+        }\n+\n+        return new CustomFormModel(\n+            modelInfo.getModelId().toString(),\n+            CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n+            modelInfo.getCreatedDateTime(),\n+            modelInfo.getLastUpdatedDateTime(),\n+            new IterableStream<>(subModelList),\n+            modelErrors,\n+            new IterableStream<TrainingDocumentInfo>(trainingDocumentInfoList));\n+    }\n+\n+    /**\n+     * Helper method to convert the list of {@link ErrorInformation} to list of {@link FormRecognizerError}.\n+     *\n+     * @param trainingErrorList The list of {@link ErrorInformation}.\n+     *\n+     * @return The list of {@link FormRecognizerError}\n+     */\n+    private static IterableStream<FormRecognizerError> transformTrainingErrors(\n+        List<ErrorInformation> trainingErrorList) {\n+        if (CoreUtils.isNullOrEmpty(trainingErrorList)) {\n+            return new IterableStream<FormRecognizerError>(Collections.emptyList());\n+        } else {\n+            return new IterableStream<>(trainingErrorList.stream()\n+                .map(errorInformation -> new FormRecognizerError(errorInformation.getCode(),\n+                    errorInformation.getMessage()))\n+                .collect(Collectors.toList()));\n+        }\n+    }\n+\n+    /**\n+     * Transform a list of {@link ModelInfo} to a list of {@link CustomFormModelInfo}.\n+     *\n+     * @param list A list of {@link ModelInfo}.\n+     *\n+     * @return A list of {@link CustomFormModelInfo}.\n+     */\n+    static List<CustomFormModelInfo> toCustomFormModelInfo(List<ModelInfo> list) {\n+        CollectionTransformer<ModelInfo, CustomFormModelInfo> transformer =\n+            new CollectionTransformer<ModelInfo, CustomFormModelInfo>() {\n+                @Override\n+                CustomFormModelInfo transform(ModelInfo modelInfo) {\n+                    return new CustomFormModelInfo(modelInfo.getModelId().toString(),\n+                        CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n+                        modelInfo.getCreatedDateTime(), modelInfo.getLastUpdatedDateTime());\n+                }\n+            };\n+        return transformer.transform(list);\n+    }\n+\n+    /**\n+     * A generic transformation class for collection that transform from type {@code E} to type {@code F}.\n+     *\n+     * @param <E> Transform type E to another type.\n+     * @param <F> Transform to type F from another type.\n+     */\n+    abstract static class CollectionTransformer<E, F> {", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5NzQ2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408997461", "bodyText": "Could this be replaced with\nreturn list.stream()\n    .map(element -> new CustomFormModelInfo(...))\n    .collect(Collectors.toList());", "author": "alzimmermsft", "createdAt": "2020-04-15T17:04:25Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.CustomFormModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.ai.formrecognizer.Transforms.forEachWithIndex;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList = null;\n+        IterableStream<FormRecognizerError> modelErrors = null;\n+\n+        if (modelResponse.getTrainResult() != null) {\n+            trainingDocumentInfoList =\n+                modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                        trainingDocumentItem.getDocumentName(),\n+                        TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                        trainingDocumentItem.getPages(),\n+                        transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .collect(Collectors.toList());\n+            modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                forEachWithIndex(clusterFields, (index, eachField) -> {\n+                    String fieldName = \"field-\" + index;\n+                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n+                });\n+                subModelList.add(new CustomFormSubModel(\n+                    null,\n+                    fieldMap,\n+                    formType + clusterKey));\n+            });\n+        } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getTrainResult().getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+            subModelList.add(new CustomFormSubModel(\n+                modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap,\n+                formType + modelInfo.getModelId()));\n+        }\n+\n+        return new CustomFormModel(\n+            modelInfo.getModelId().toString(),\n+            CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n+            modelInfo.getCreatedDateTime(),\n+            modelInfo.getLastUpdatedDateTime(),\n+            new IterableStream<>(subModelList),\n+            modelErrors,\n+            new IterableStream<TrainingDocumentInfo>(trainingDocumentInfoList));\n+    }\n+\n+    /**\n+     * Helper method to convert the list of {@link ErrorInformation} to list of {@link FormRecognizerError}.\n+     *\n+     * @param trainingErrorList The list of {@link ErrorInformation}.\n+     *\n+     * @return The list of {@link FormRecognizerError}\n+     */\n+    private static IterableStream<FormRecognizerError> transformTrainingErrors(\n+        List<ErrorInformation> trainingErrorList) {\n+        if (CoreUtils.isNullOrEmpty(trainingErrorList)) {\n+            return new IterableStream<FormRecognizerError>(Collections.emptyList());\n+        } else {\n+            return new IterableStream<>(trainingErrorList.stream()\n+                .map(errorInformation -> new FormRecognizerError(errorInformation.getCode(),\n+                    errorInformation.getMessage()))\n+                .collect(Collectors.toList()));\n+        }\n+    }\n+\n+    /**\n+     * Transform a list of {@link ModelInfo} to a list of {@link CustomFormModelInfo}.\n+     *\n+     * @param list A list of {@link ModelInfo}.\n+     *\n+     * @return A list of {@link CustomFormModelInfo}.\n+     */\n+    static List<CustomFormModelInfo> toCustomFormModelInfo(List<ModelInfo> list) {\n+        CollectionTransformer<ModelInfo, CustomFormModelInfo> transformer =\n+            new CollectionTransformer<ModelInfo, CustomFormModelInfo>() {\n+                @Override\n+                CustomFormModelInfo transform(ModelInfo modelInfo) {\n+                    return new CustomFormModelInfo(modelInfo.getModelId().toString(),\n+                        CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n+                        modelInfo.getCreatedDateTime(), modelInfo.getLastUpdatedDateTime());\n+                }\n+            };\n+        return transformer.transform(list);", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0Mzc4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409043786", "bodyText": "@mssfang you ok, if I change this to using a stream and delete the other generic toList method?", "author": "samvaity", "createdAt": "2020-04-15T18:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5NzQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5ODc3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408998778", "bodyText": "This should use IterableStream.of, there is a possibility where trainingDocumentInfoList is null and the constructor will throw a NullPointerException but the factory method will return an empty instance.", "author": "alzimmermsft", "createdAt": "2020-04-15T17:06:40Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.CustomFormModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.ai.formrecognizer.Transforms.forEachWithIndex;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList = null;\n+        IterableStream<FormRecognizerError> modelErrors = null;\n+\n+        if (modelResponse.getTrainResult() != null) {\n+            trainingDocumentInfoList =\n+                modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                        trainingDocumentItem.getDocumentName(),\n+                        TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                        trainingDocumentItem.getPages(),\n+                        transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .collect(Collectors.toList());\n+            modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                forEachWithIndex(clusterFields, (index, eachField) -> {\n+                    String fieldName = \"field-\" + index;\n+                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n+                });\n+                subModelList.add(new CustomFormSubModel(\n+                    null,\n+                    fieldMap,\n+                    formType + clusterKey));\n+            });\n+        } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getTrainResult().getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+            subModelList.add(new CustomFormSubModel(\n+                modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap,\n+                formType + modelInfo.getModelId()));\n+        }\n+\n+        return new CustomFormModel(\n+            modelInfo.getModelId().toString(),\n+            CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n+            modelInfo.getCreatedDateTime(),\n+            modelInfo.getLastUpdatedDateTime(),\n+            new IterableStream<>(subModelList),\n+            modelErrors,\n+            new IterableStream<TrainingDocumentInfo>(trainingDocumentInfoList));", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5OTMwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r408999303", "bodyText": "Could subModelList ever end up empty if both the if and else if don't pass?", "author": "alzimmermsft", "createdAt": "2020-04-15T17:07:33Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.CustomFormModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.ai.formrecognizer.Transforms.forEachWithIndex;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList = null;\n+        IterableStream<FormRecognizerError> modelErrors = null;\n+\n+        if (modelResponse.getTrainResult() != null) {\n+            trainingDocumentInfoList =\n+                modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                        trainingDocumentItem.getDocumentName(),\n+                        TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                        trainingDocumentItem.getPages(),\n+                        transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .collect(Collectors.toList());\n+            modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0MzM1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409043351", "bodyText": "That is not a known case and should not occur.", "author": "samvaity", "createdAt": "2020-04-15T18:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5OTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwMDc1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409000753", "bodyText": "Could make this a little more performant by hard coding in ModelStatus.INVALID's toString value since that is the only time we will reach this code path.\nnew IllegalArgumentException(String.format(\"Model Id %s returned with invalid status\", modelInfo.getModelId())", "author": "alzimmermsft", "createdAt": "2020-04-15T17:09:46Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.CustomFormModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.ai.formrecognizer.Transforms.forEachWithIndex;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwMTU4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409001587", "bodyText": "Could use IterableStream.of(null) here to get a static instance that uses an immutable empty list.", "author": "alzimmermsft", "createdAt": "2020-04-15T17:11:04Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.CustomFormModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.ai.formrecognizer.Transforms.forEachWithIndex;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList = null;\n+        IterableStream<FormRecognizerError> modelErrors = null;\n+\n+        if (modelResponse.getTrainResult() != null) {\n+            trainingDocumentInfoList =\n+                modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                        trainingDocumentItem.getDocumentName(),\n+                        TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                        trainingDocumentItem.getPages(),\n+                        transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .collect(Collectors.toList());\n+            modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                forEachWithIndex(clusterFields, (index, eachField) -> {\n+                    String fieldName = \"field-\" + index;\n+                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n+                });\n+                subModelList.add(new CustomFormSubModel(\n+                    null,\n+                    fieldMap,\n+                    formType + clusterKey));\n+            });\n+        } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getTrainResult().getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+            subModelList.add(new CustomFormSubModel(\n+                modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap,\n+                formType + modelInfo.getModelId()));\n+        }\n+\n+        return new CustomFormModel(\n+            modelInfo.getModelId().toString(),\n+            CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n+            modelInfo.getCreatedDateTime(),\n+            modelInfo.getLastUpdatedDateTime(),\n+            new IterableStream<>(subModelList),\n+            modelErrors,\n+            new IterableStream<TrainingDocumentInfo>(trainingDocumentInfoList));\n+    }\n+\n+    /**\n+     * Helper method to convert the list of {@link ErrorInformation} to list of {@link FormRecognizerError}.\n+     *\n+     * @param trainingErrorList The list of {@link ErrorInformation}.\n+     *\n+     * @return The list of {@link FormRecognizerError}\n+     */\n+    private static IterableStream<FormRecognizerError> transformTrainingErrors(\n+        List<ErrorInformation> trainingErrorList) {\n+        if (CoreUtils.isNullOrEmpty(trainingErrorList)) {\n+            return new IterableStream<FormRecognizerError>(Collections.emptyList());", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwMjA1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409002053", "bodyText": "@anuchandy @srnagar @JonathanGiles\nShould IterableStream have a constructor that takes a Stream?", "author": "alzimmermsft", "createdAt": "2020-04-15T17:11:52Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.CustomFormModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.ai.formrecognizer.Transforms.forEachWithIndex;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList = null;\n+        IterableStream<FormRecognizerError> modelErrors = null;\n+\n+        if (modelResponse.getTrainResult() != null) {\n+            trainingDocumentInfoList =\n+                modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                        trainingDocumentItem.getDocumentName(),\n+                        TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                        trainingDocumentItem.getPages(),\n+                        transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .collect(Collectors.toList());\n+            modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                forEachWithIndex(clusterFields, (index, eachField) -> {\n+                    String fieldName = \"field-\" + index;\n+                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n+                });\n+                subModelList.add(new CustomFormSubModel(\n+                    null,\n+                    fieldMap,\n+                    formType + clusterKey));\n+            });\n+        } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getTrainResult().getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+            subModelList.add(new CustomFormSubModel(\n+                modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap,\n+                formType + modelInfo.getModelId()));\n+        }\n+\n+        return new CustomFormModel(\n+            modelInfo.getModelId().toString(),\n+            CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n+            modelInfo.getCreatedDateTime(),\n+            modelInfo.getLastUpdatedDateTime(),\n+            new IterableStream<>(subModelList),\n+            modelErrors,\n+            new IterableStream<TrainingDocumentInfo>(trainingDocumentInfoList));\n+    }\n+\n+    /**\n+     * Helper method to convert the list of {@link ErrorInformation} to list of {@link FormRecognizerError}.\n+     *\n+     * @param trainingErrorList The list of {@link ErrorInformation}.\n+     *\n+     * @return The list of {@link FormRecognizerError}\n+     */\n+    private static IterableStream<FormRecognizerError> transformTrainingErrors(\n+        List<ErrorInformation> trainingErrorList) {\n+        if (CoreUtils.isNullOrEmpty(trainingErrorList)) {\n+            return new IterableStream<FormRecognizerError>(Collections.emptyList());\n+        } else {\n+            return new IterableStream<>(trainingErrorList.stream()", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0MTMyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409041322", "bodyText": "Yeah, that's a good overload to have in IterableStream.", "author": "srnagar", "createdAt": "2020-04-15T18:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwMjA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwOTEwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409009104", "bodyText": "So default confidence is 100%? Aren't most the confidence fields Floats and should be nullable, would null be a better value? Might be better to say, we're not really sure of the confidence instead of we're 100% sure.", "author": "alzimmermsft", "createdAt": "2020-04-15T17:23:32Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -5,413 +5,483 @@\n \n import com.azure.ai.formrecognizer.implementation.models.AnalyzeResult;\n import com.azure.ai.formrecognizer.implementation.models.DocumentResult;\n-import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.FieldValue;\n+import com.azure.ai.formrecognizer.implementation.models.KeyValuePair;\n+import com.azure.ai.formrecognizer.implementation.models.PageResult;\n import com.azure.ai.formrecognizer.implementation.models.ReadResult;\n import com.azure.ai.formrecognizer.implementation.models.TextLine;\n import com.azure.ai.formrecognizer.implementation.models.TextWord;\n import com.azure.ai.formrecognizer.models.BoundingBox;\n-import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n-import com.azure.ai.formrecognizer.models.DateValue;\n import com.azure.ai.formrecognizer.models.DimensionUnit;\n-import com.azure.ai.formrecognizer.models.Element;\n-import com.azure.ai.formrecognizer.models.ExtractedReceipt;\n-import com.azure.ai.formrecognizer.models.FieldValue;\n-import com.azure.ai.formrecognizer.models.FloatValue;\n-import com.azure.ai.formrecognizer.models.IntegerValue;\n-import com.azure.ai.formrecognizer.models.LineElement;\n-import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n-import com.azure.ai.formrecognizer.models.PageMetadata;\n+import com.azure.ai.formrecognizer.models.FieldText;\n+import com.azure.ai.formrecognizer.models.FormContent;\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.FormLine;\n+import com.azure.ai.formrecognizer.models.FormPage;\n+import com.azure.ai.formrecognizer.models.FormTable;\n+import com.azure.ai.formrecognizer.models.FormTableCell;\n+import com.azure.ai.formrecognizer.models.FormWord;\n import com.azure.ai.formrecognizer.models.PageRange;\n import com.azure.ai.formrecognizer.models.Point;\n-import com.azure.ai.formrecognizer.models.ReceiptItem;\n-import com.azure.ai.formrecognizer.models.ReceiptItemType;\n-import com.azure.ai.formrecognizer.models.ReceiptType;\n-import com.azure.ai.formrecognizer.models.StringValue;\n-import com.azure.ai.formrecognizer.models.TimeValue;\n-import com.azure.ai.formrecognizer.models.WordElement;\n+import com.azure.ai.formrecognizer.models.RecognizedForm;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.core.util.CoreUtils;\n import com.azure.core.util.IterableStream;\n import com.azure.core.util.logging.ClientLogger;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n import java.util.regex.Pattern;\n-\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+import java.util.stream.Collectors;\n \n /**\n  * Helper class to convert service level models to SDK exposed models.\n  */\n final class Transforms {\n     private static final ClientLogger LOGGER = new ClientLogger(Transforms.class);\n     // Pattern match to find all non-digits in the provided string.\n-    private static final Pattern COMPILE = Pattern.compile(\"[^0-9]+\");\n+    private static final Pattern NON_DIGIT_PATTERN = Pattern.compile(\"[^0-9]+\");\n+    private static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE0OTk2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409149960", "bodyText": "Updated confidence value to be float. This is a known service bug it should always return it non-null and it is service guidance to have it as 1.0 when undefined.", "author": "samvaity", "createdAt": "2020-04-15T21:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwOTEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwOTQyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409009425", "bodyText": "Do these need to be atomic references?", "author": "alzimmermsft", "createdAt": "2020-04-15T17:23:59Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -5,413 +5,483 @@\n \n import com.azure.ai.formrecognizer.implementation.models.AnalyzeResult;\n import com.azure.ai.formrecognizer.implementation.models.DocumentResult;\n-import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.FieldValue;\n+import com.azure.ai.formrecognizer.implementation.models.KeyValuePair;\n+import com.azure.ai.formrecognizer.implementation.models.PageResult;\n import com.azure.ai.formrecognizer.implementation.models.ReadResult;\n import com.azure.ai.formrecognizer.implementation.models.TextLine;\n import com.azure.ai.formrecognizer.implementation.models.TextWord;\n import com.azure.ai.formrecognizer.models.BoundingBox;\n-import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n-import com.azure.ai.formrecognizer.models.DateValue;\n import com.azure.ai.formrecognizer.models.DimensionUnit;\n-import com.azure.ai.formrecognizer.models.Element;\n-import com.azure.ai.formrecognizer.models.ExtractedReceipt;\n-import com.azure.ai.formrecognizer.models.FieldValue;\n-import com.azure.ai.formrecognizer.models.FloatValue;\n-import com.azure.ai.formrecognizer.models.IntegerValue;\n-import com.azure.ai.formrecognizer.models.LineElement;\n-import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n-import com.azure.ai.formrecognizer.models.PageMetadata;\n+import com.azure.ai.formrecognizer.models.FieldText;\n+import com.azure.ai.formrecognizer.models.FormContent;\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.FormLine;\n+import com.azure.ai.formrecognizer.models.FormPage;\n+import com.azure.ai.formrecognizer.models.FormTable;\n+import com.azure.ai.formrecognizer.models.FormTableCell;\n+import com.azure.ai.formrecognizer.models.FormWord;\n import com.azure.ai.formrecognizer.models.PageRange;\n import com.azure.ai.formrecognizer.models.Point;\n-import com.azure.ai.formrecognizer.models.ReceiptItem;\n-import com.azure.ai.formrecognizer.models.ReceiptItemType;\n-import com.azure.ai.formrecognizer.models.ReceiptType;\n-import com.azure.ai.formrecognizer.models.StringValue;\n-import com.azure.ai.formrecognizer.models.TimeValue;\n-import com.azure.ai.formrecognizer.models.WordElement;\n+import com.azure.ai.formrecognizer.models.RecognizedForm;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.core.util.CoreUtils;\n import com.azure.core.util.IterableStream;\n import com.azure.core.util.logging.ClientLogger;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n import java.util.regex.Pattern;\n-\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+import java.util.stream.Collectors;\n \n /**\n  * Helper class to convert service level models to SDK exposed models.\n  */\n final class Transforms {\n     private static final ClientLogger LOGGER = new ClientLogger(Transforms.class);\n     // Pattern match to find all non-digits in the provided string.\n-    private static final Pattern COMPILE = Pattern.compile(\"[^0-9]+\");\n+    private static final Pattern NON_DIGIT_PATTERN = Pattern.compile(\"[^0-9]+\");\n+    private static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;\n \n     private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n-\n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n-\n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap;\n+\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0NDc4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409044781", "bodyText": "Since I am using these two variables in lambda expression below they need to be final in nature.", "author": "samvaity", "createdAt": "2020-04-15T18:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwOTQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE1MDE2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409150168", "bodyText": "edit: updated this.", "author": "samvaity", "createdAt": "2020-04-15T21:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAwOTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxMDcxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409010716", "bodyText": "Since PageRange is immutable could we create a static instance that is used here?", "author": "alzimmermsft", "createdAt": "2020-04-15T17:26:07Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -5,413 +5,483 @@\n \n import com.azure.ai.formrecognizer.implementation.models.AnalyzeResult;\n import com.azure.ai.formrecognizer.implementation.models.DocumentResult;\n-import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.FieldValue;\n+import com.azure.ai.formrecognizer.implementation.models.KeyValuePair;\n+import com.azure.ai.formrecognizer.implementation.models.PageResult;\n import com.azure.ai.formrecognizer.implementation.models.ReadResult;\n import com.azure.ai.formrecognizer.implementation.models.TextLine;\n import com.azure.ai.formrecognizer.implementation.models.TextWord;\n import com.azure.ai.formrecognizer.models.BoundingBox;\n-import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n-import com.azure.ai.formrecognizer.models.DateValue;\n import com.azure.ai.formrecognizer.models.DimensionUnit;\n-import com.azure.ai.formrecognizer.models.Element;\n-import com.azure.ai.formrecognizer.models.ExtractedReceipt;\n-import com.azure.ai.formrecognizer.models.FieldValue;\n-import com.azure.ai.formrecognizer.models.FloatValue;\n-import com.azure.ai.formrecognizer.models.IntegerValue;\n-import com.azure.ai.formrecognizer.models.LineElement;\n-import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n-import com.azure.ai.formrecognizer.models.PageMetadata;\n+import com.azure.ai.formrecognizer.models.FieldText;\n+import com.azure.ai.formrecognizer.models.FormContent;\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.FormLine;\n+import com.azure.ai.formrecognizer.models.FormPage;\n+import com.azure.ai.formrecognizer.models.FormTable;\n+import com.azure.ai.formrecognizer.models.FormTableCell;\n+import com.azure.ai.formrecognizer.models.FormWord;\n import com.azure.ai.formrecognizer.models.PageRange;\n import com.azure.ai.formrecognizer.models.Point;\n-import com.azure.ai.formrecognizer.models.ReceiptItem;\n-import com.azure.ai.formrecognizer.models.ReceiptItemType;\n-import com.azure.ai.formrecognizer.models.ReceiptType;\n-import com.azure.ai.formrecognizer.models.StringValue;\n-import com.azure.ai.formrecognizer.models.TimeValue;\n-import com.azure.ai.formrecognizer.models.WordElement;\n+import com.azure.ai.formrecognizer.models.RecognizedForm;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.core.util.CoreUtils;\n import com.azure.core.util.IterableStream;\n import com.azure.core.util.logging.ClientLogger;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n import java.util.regex.Pattern;\n-\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+import java.util.stream.Collectors;\n \n /**\n  * Helper class to convert service level models to SDK exposed models.\n  */\n final class Transforms {\n     private static final ClientLogger LOGGER = new ClientLogger(Transforms.class);\n     // Pattern match to find all non-digits in the provided string.\n-    private static final Pattern COMPILE = Pattern.compile(\"[^0-9]+\");\n+    private static final Pattern NON_DIGIT_PATTERN = Pattern.compile(\"[^0-9]+\");\n+    private static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;\n \n     private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n-\n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n-\n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap;\n+\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult, includeTextDetails);\n+        // unlabeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (DocumentResult documentResultItem : documentResults) {\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                } else {\n+                    pageRange.set(new PageRange(1, 1));", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxMjY5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409012699", "bodyText": "What are some example page ranges the service would return? Taking an example from most printing UIs where you can set an option of print page 3, would the service return a page range of { 3 } or would it be { 3, 3 }? If it is the former would it make defaults to range 1-1 incorrect?", "author": "alzimmermsft", "createdAt": "2020-04-15T17:29:20Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -5,413 +5,483 @@\n \n import com.azure.ai.formrecognizer.implementation.models.AnalyzeResult;\n import com.azure.ai.formrecognizer.implementation.models.DocumentResult;\n-import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.FieldValue;\n+import com.azure.ai.formrecognizer.implementation.models.KeyValuePair;\n+import com.azure.ai.formrecognizer.implementation.models.PageResult;\n import com.azure.ai.formrecognizer.implementation.models.ReadResult;\n import com.azure.ai.formrecognizer.implementation.models.TextLine;\n import com.azure.ai.formrecognizer.implementation.models.TextWord;\n import com.azure.ai.formrecognizer.models.BoundingBox;\n-import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n-import com.azure.ai.formrecognizer.models.DateValue;\n import com.azure.ai.formrecognizer.models.DimensionUnit;\n-import com.azure.ai.formrecognizer.models.Element;\n-import com.azure.ai.formrecognizer.models.ExtractedReceipt;\n-import com.azure.ai.formrecognizer.models.FieldValue;\n-import com.azure.ai.formrecognizer.models.FloatValue;\n-import com.azure.ai.formrecognizer.models.IntegerValue;\n-import com.azure.ai.formrecognizer.models.LineElement;\n-import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n-import com.azure.ai.formrecognizer.models.PageMetadata;\n+import com.azure.ai.formrecognizer.models.FieldText;\n+import com.azure.ai.formrecognizer.models.FormContent;\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.FormLine;\n+import com.azure.ai.formrecognizer.models.FormPage;\n+import com.azure.ai.formrecognizer.models.FormTable;\n+import com.azure.ai.formrecognizer.models.FormTableCell;\n+import com.azure.ai.formrecognizer.models.FormWord;\n import com.azure.ai.formrecognizer.models.PageRange;\n import com.azure.ai.formrecognizer.models.Point;\n-import com.azure.ai.formrecognizer.models.ReceiptItem;\n-import com.azure.ai.formrecognizer.models.ReceiptItemType;\n-import com.azure.ai.formrecognizer.models.ReceiptType;\n-import com.azure.ai.formrecognizer.models.StringValue;\n-import com.azure.ai.formrecognizer.models.TimeValue;\n-import com.azure.ai.formrecognizer.models.WordElement;\n+import com.azure.ai.formrecognizer.models.RecognizedForm;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.core.util.CoreUtils;\n import com.azure.core.util.IterableStream;\n import com.azure.core.util.logging.ClientLogger;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n import java.util.regex.Pattern;\n-\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+import java.util.stream.Collectors;\n \n /**\n  * Helper class to convert service level models to SDK exposed models.\n  */\n final class Transforms {\n     private static final ClientLogger LOGGER = new ClientLogger(Transforms.class);\n     // Pattern match to find all non-digits in the provided string.\n-    private static final Pattern COMPILE = Pattern.compile(\"[^0-9]+\");\n+    private static final Pattern NON_DIGIT_PATTERN = Pattern.compile(\"[^0-9]+\");\n+    private static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;\n \n     private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n-\n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n-\n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap;\n+\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult, includeTextDetails);\n+        // unlabeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (DocumentResult documentResultItem : documentResults) {\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0NTU2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409045562", "bodyText": "Yes, it would return {3, 3} according to the current implementation of the service.", "author": "samvaity", "createdAt": "2020-04-15T18:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxMjY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxNTY3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409015670", "bodyText": "The logic here shows that you can't have both labeled and unlabeled, can you change this into an if / else if. Once that is done you can remove the check below for CoreUtils.isNullOrEmpty(documentResults).", "author": "alzimmermsft", "createdAt": "2020-04-15T17:34:08Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -5,413 +5,483 @@\n \n import com.azure.ai.formrecognizer.implementation.models.AnalyzeResult;\n import com.azure.ai.formrecognizer.implementation.models.DocumentResult;\n-import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.FieldValue;\n+import com.azure.ai.formrecognizer.implementation.models.KeyValuePair;\n+import com.azure.ai.formrecognizer.implementation.models.PageResult;\n import com.azure.ai.formrecognizer.implementation.models.ReadResult;\n import com.azure.ai.formrecognizer.implementation.models.TextLine;\n import com.azure.ai.formrecognizer.implementation.models.TextWord;\n import com.azure.ai.formrecognizer.models.BoundingBox;\n-import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n-import com.azure.ai.formrecognizer.models.DateValue;\n import com.azure.ai.formrecognizer.models.DimensionUnit;\n-import com.azure.ai.formrecognizer.models.Element;\n-import com.azure.ai.formrecognizer.models.ExtractedReceipt;\n-import com.azure.ai.formrecognizer.models.FieldValue;\n-import com.azure.ai.formrecognizer.models.FloatValue;\n-import com.azure.ai.formrecognizer.models.IntegerValue;\n-import com.azure.ai.formrecognizer.models.LineElement;\n-import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n-import com.azure.ai.formrecognizer.models.PageMetadata;\n+import com.azure.ai.formrecognizer.models.FieldText;\n+import com.azure.ai.formrecognizer.models.FormContent;\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.FormLine;\n+import com.azure.ai.formrecognizer.models.FormPage;\n+import com.azure.ai.formrecognizer.models.FormTable;\n+import com.azure.ai.formrecognizer.models.FormTableCell;\n+import com.azure.ai.formrecognizer.models.FormWord;\n import com.azure.ai.formrecognizer.models.PageRange;\n import com.azure.ai.formrecognizer.models.Point;\n-import com.azure.ai.formrecognizer.models.ReceiptItem;\n-import com.azure.ai.formrecognizer.models.ReceiptItemType;\n-import com.azure.ai.formrecognizer.models.ReceiptType;\n-import com.azure.ai.formrecognizer.models.StringValue;\n-import com.azure.ai.formrecognizer.models.TimeValue;\n-import com.azure.ai.formrecognizer.models.WordElement;\n+import com.azure.ai.formrecognizer.models.RecognizedForm;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.core.util.CoreUtils;\n import com.azure.core.util.IterableStream;\n import com.azure.core.util.logging.ClientLogger;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n import java.util.regex.Pattern;\n-\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+import java.util.stream.Collectors;\n \n /**\n  * Helper class to convert service level models to SDK exposed models.\n  */\n final class Transforms {\n     private static final ClientLogger LOGGER = new ClientLogger(Transforms.class);\n     // Pattern match to find all non-digits in the provided string.\n-    private static final Pattern COMPILE = Pattern.compile(\"[^0-9]+\");\n+    private static final Pattern NON_DIGIT_PATTERN = Pattern.compile(\"[^0-9]+\");\n+    private static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;\n \n     private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n-\n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n-\n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap;\n+\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult, includeTextDetails);\n+        // unlabeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (DocumentResult documentResultItem : documentResults) {\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                } else {\n+                    pageRange.set(new PageRange(1, 1));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getUnlabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n+\n+                extractedFormList.add(new RecognizedForm(\n+                    extractedFieldMap,\n+                    formType.get(),\n+                    pageRange.get(),\n+                    new IterableStream<>(formPages.subList(pageRange.get().getStartPageNumber() - 1,\n+                        pageRange.get().getEndPageNumber()))));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+        }\n+\n+        // labeled", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxNzk3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409017972", "bodyText": "Could we make this into a variable outside of the scope of the for loop? Should only need to check this once.", "author": "alzimmermsft", "createdAt": "2020-04-15T17:38:02Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -5,413 +5,483 @@\n \n import com.azure.ai.formrecognizer.implementation.models.AnalyzeResult;\n import com.azure.ai.formrecognizer.implementation.models.DocumentResult;\n-import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.FieldValue;\n+import com.azure.ai.formrecognizer.implementation.models.KeyValuePair;\n+import com.azure.ai.formrecognizer.implementation.models.PageResult;\n import com.azure.ai.formrecognizer.implementation.models.ReadResult;\n import com.azure.ai.formrecognizer.implementation.models.TextLine;\n import com.azure.ai.formrecognizer.implementation.models.TextWord;\n import com.azure.ai.formrecognizer.models.BoundingBox;\n-import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n-import com.azure.ai.formrecognizer.models.DateValue;\n import com.azure.ai.formrecognizer.models.DimensionUnit;\n-import com.azure.ai.formrecognizer.models.Element;\n-import com.azure.ai.formrecognizer.models.ExtractedReceipt;\n-import com.azure.ai.formrecognizer.models.FieldValue;\n-import com.azure.ai.formrecognizer.models.FloatValue;\n-import com.azure.ai.formrecognizer.models.IntegerValue;\n-import com.azure.ai.formrecognizer.models.LineElement;\n-import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n-import com.azure.ai.formrecognizer.models.PageMetadata;\n+import com.azure.ai.formrecognizer.models.FieldText;\n+import com.azure.ai.formrecognizer.models.FormContent;\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.FormLine;\n+import com.azure.ai.formrecognizer.models.FormPage;\n+import com.azure.ai.formrecognizer.models.FormTable;\n+import com.azure.ai.formrecognizer.models.FormTableCell;\n+import com.azure.ai.formrecognizer.models.FormWord;\n import com.azure.ai.formrecognizer.models.PageRange;\n import com.azure.ai.formrecognizer.models.Point;\n-import com.azure.ai.formrecognizer.models.ReceiptItem;\n-import com.azure.ai.formrecognizer.models.ReceiptItemType;\n-import com.azure.ai.formrecognizer.models.ReceiptType;\n-import com.azure.ai.formrecognizer.models.StringValue;\n-import com.azure.ai.formrecognizer.models.TimeValue;\n-import com.azure.ai.formrecognizer.models.WordElement;\n+import com.azure.ai.formrecognizer.models.RecognizedForm;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.core.util.CoreUtils;\n import com.azure.core.util.IterableStream;\n import com.azure.core.util.logging.ClientLogger;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n import java.util.regex.Pattern;\n-\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+import java.util.stream.Collectors;\n \n /**\n  * Helper class to convert service level models to SDK exposed models.\n  */\n final class Transforms {\n     private static final ClientLogger LOGGER = new ClientLogger(Transforms.class);\n     // Pattern match to find all non-digits in the provided string.\n-    private static final Pattern COMPILE = Pattern.compile(\"[^0-9]+\");\n+    private static final Pattern NON_DIGIT_PATTERN = Pattern.compile(\"[^0-9]+\");\n+    private static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;\n \n     private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n-\n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n-\n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap;\n+\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult, includeTextDetails);\n+        // unlabeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (DocumentResult documentResultItem : documentResults) {\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                } else {\n+                    pageRange.set(new PageRange(1, 1));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getUnlabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n+\n+                extractedFormList.add(new RecognizedForm(\n+                    extractedFieldMap,\n+                    formType.get(),\n+                    pageRange.get(),\n+                    new IterableStream<>(formPages.subList(pageRange.get().getStartPageNumber() - 1,\n+                        pageRange.get().getEndPageNumber()))));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+        }\n+\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+            for (PageResult pageResultItem : pageResults) {\n+                int pageNumber = pageResultItem.getPage();\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getLabeledFieldMap(includeTextDetails, readResults, pageResultItem,\n+                        pageNumber);\n+\n+                    extractedFormList.add(new RecognizedForm(\n+                        extractedFieldMap,\n+                        formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<>(Collections.singletonList(formPages.get(pageNumber - 1)))));\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+            }\n         }\n-        return new IterableStream<>(extractedReceiptList);\n+        return extractedFormList;\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n      *\n-     * @param fieldValue The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return The strongly typed {@link FieldValue} for the field input.\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n      */\n-    private static FieldValue<?> setFieldValue(com.azure.ai.formrecognizer.implementation.models.FieldValue fieldValue,\n-                                               List<ReadResult> readResults, boolean includeTextDetails) {\n-        FieldValue<?> value;\n-        switch (fieldValue.getType()) {\n-            case PHONE_NUMBER:\n-                value = toFieldValuePhoneNumber(fieldValue);\n-                break;\n-            case STRING:\n-                value = toFieldValueString(fieldValue);\n-                break;\n-            case TIME:\n-                value = toFieldValueTime(fieldValue);\n-                break;\n-            case DATE:\n-                value = toFieldValueDate(fieldValue);\n-                break;\n-            case INTEGER:\n-                value = toFieldValueInteger(fieldValue);\n-                break;\n-            case NUMBER:\n-                value = toFieldValueNumber(fieldValue);\n-                break;\n-            case ARRAY:\n-            case OBJECT:\n-            default:\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"FieldValue Type not supported\"));\n-        }\n-        if (includeTextDetails) {\n-            value.setElements(setReferenceElements(readResults, fieldValue.getElements()));\n-        }\n-        return value;\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        return new IterableStream<>(\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm))\n+                .collect(Collectors.toList()));\n     }\n \n     /**\n-     * Helper method that converts the service returned page information to SDK model {@link PageMetadata}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n-     * @param readResultItem A read result item returned from the service containing the page information for provided\n-     * input.\n+     * @param analyzeResult The service returned result for analyze layouts.\n      *\n-     * @return The {@link PageMetadata} for the receipt page.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     * @return The IterableStream of {@code FormPage}.\n      */\n-    private static PageMetadata getPageInfo(ReadResult readResultItem) {\n-        return new PageMetadata(readResultItem.getHeight(), readResultItem.getPage(), readResultItem.getWidth(),\n-            readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        forEachWithIndex(readResults, ((index, readResultItem) -> {\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxOTk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409019940", "bodyText": "This could be simplified a bit by using a stream, the logic inside of the lambda would be the same except adding it to the list.\nreturn pageResultItem.getTables().stream()\n    .map(/* convert to FormTable */)\n    .collect(Collectors.toList());", "author": "alzimmermsft", "createdAt": "2020-04-15T17:41:33Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -5,413 +5,483 @@\n \n import com.azure.ai.formrecognizer.implementation.models.AnalyzeResult;\n import com.azure.ai.formrecognizer.implementation.models.DocumentResult;\n-import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.FieldValue;\n+import com.azure.ai.formrecognizer.implementation.models.KeyValuePair;\n+import com.azure.ai.formrecognizer.implementation.models.PageResult;\n import com.azure.ai.formrecognizer.implementation.models.ReadResult;\n import com.azure.ai.formrecognizer.implementation.models.TextLine;\n import com.azure.ai.formrecognizer.implementation.models.TextWord;\n import com.azure.ai.formrecognizer.models.BoundingBox;\n-import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n-import com.azure.ai.formrecognizer.models.DateValue;\n import com.azure.ai.formrecognizer.models.DimensionUnit;\n-import com.azure.ai.formrecognizer.models.Element;\n-import com.azure.ai.formrecognizer.models.ExtractedReceipt;\n-import com.azure.ai.formrecognizer.models.FieldValue;\n-import com.azure.ai.formrecognizer.models.FloatValue;\n-import com.azure.ai.formrecognizer.models.IntegerValue;\n-import com.azure.ai.formrecognizer.models.LineElement;\n-import com.azure.ai.formrecognizer.models.ModelTrainingStatus;\n-import com.azure.ai.formrecognizer.models.PageMetadata;\n+import com.azure.ai.formrecognizer.models.FieldText;\n+import com.azure.ai.formrecognizer.models.FormContent;\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.FormLine;\n+import com.azure.ai.formrecognizer.models.FormPage;\n+import com.azure.ai.formrecognizer.models.FormTable;\n+import com.azure.ai.formrecognizer.models.FormTableCell;\n+import com.azure.ai.formrecognizer.models.FormWord;\n import com.azure.ai.formrecognizer.models.PageRange;\n import com.azure.ai.formrecognizer.models.Point;\n-import com.azure.ai.formrecognizer.models.ReceiptItem;\n-import com.azure.ai.formrecognizer.models.ReceiptItemType;\n-import com.azure.ai.formrecognizer.models.ReceiptType;\n-import com.azure.ai.formrecognizer.models.StringValue;\n-import com.azure.ai.formrecognizer.models.TimeValue;\n-import com.azure.ai.formrecognizer.models.WordElement;\n+import com.azure.ai.formrecognizer.models.RecognizedForm;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.core.util.CoreUtils;\n import com.azure.core.util.IterableStream;\n import com.azure.core.util.logging.ClientLogger;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n import java.util.regex.Pattern;\n-\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n-import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+import java.util.stream.Collectors;\n \n /**\n  * Helper class to convert service level models to SDK exposed models.\n  */\n final class Transforms {\n     private static final ClientLogger LOGGER = new ClientLogger(Transforms.class);\n     // Pattern match to find all non-digits in the provided string.\n-    private static final Pattern COMPILE = Pattern.compile(\"[^0-9]+\");\n+    private static final Pattern NON_DIGIT_PATTERN = Pattern.compile(\"[^0-9]+\");\n+    private static final float DEFAULT_CONFIDENCE_VALUE = 1.0f;\n \n     private Transforms() {\n     }\n \n     /**\n-     * Helper method to convert the {@link com.azure.ai.formrecognizer.implementation.models.AnalyzeOperationResult}\n-     * service level receipt model to list of {@link ExtractedReceipt}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedForm}.\n      *\n-     * @param analyzeResult The result of the analyze receipt operation returned by the service.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze custom forms.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return A list of {@link ExtractedReceipt} to represent the list of extracted receipt information.\n+     * @return The IterableStream of {@code RecognizedForm}.\n      */\n-    static IterableStream<ExtractedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+    static List<RecognizedForm> toRecognizedForm(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n         List<ReadResult> readResults = analyzeResult.getReadResults();\n-        List<DocumentResult> documentResult = analyzeResult.getDocumentResults();\n-        List<ExtractedReceipt> extractedReceiptList = new ArrayList<>();\n-\n-        for (int i = 0; i < readResults.size(); i++) {\n-            ReadResult readResultItem = readResults.get(i);\n-\n-            // add page Info\n-            PageMetadata pageMetadata = getPageInfo(readResultItem);\n-            PageRange pageRange = null;\n-            DocumentResult documentResultItem = documentResult.get(i);\n-            List<Integer> receiptPageRange = documentResultItem.getPageRange();\n-            if (receiptPageRange.size() == 2) {\n-                pageRange = new PageRange(receiptPageRange.get(0), receiptPageRange.get(1));\n+        List<DocumentResult> documentResults = analyzeResult.getDocumentResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<RecognizedForm> extractedFormList = new ArrayList<>();\n+        Map<String, FormField<?>> extractedFieldMap;\n+\n+        AtomicReference<PageRange> pageRange = new AtomicReference<>();\n+        AtomicReference<String> formType = new AtomicReference<>(\"form-\");\n+\n+        List<FormPage> formPages = toRecognizedLayout(analyzeResult, includeTextDetails);\n+        // unlabeled\n+        if (!CoreUtils.isNullOrEmpty(documentResults)) {\n+            for (DocumentResult documentResultItem : documentResults) {\n+                List<Integer> documentPageRange = documentResultItem.getPageRange();\n+                if (documentPageRange.size() == 2) {\n+                    pageRange.set(new PageRange(documentPageRange.get(0), documentPageRange.get(1)));\n+                } else {\n+                    pageRange.set(new PageRange(1, 1));\n+                }\n+\n+                formType.set(documentResultItem.getDocType());\n+                extractedFieldMap = getUnlabeledFieldMap(documentResultItem, readResults, includeTextDetails);\n+\n+                extractedFormList.add(new RecognizedForm(\n+                    extractedFieldMap,\n+                    formType.get(),\n+                    pageRange.get(),\n+                    new IterableStream<>(formPages.subList(pageRange.get().getStartPageNumber() - 1,\n+                        pageRange.get().getEndPageNumber()))));\n             }\n-            ExtractedReceipt extractedReceiptItem = new ExtractedReceipt(pageMetadata, pageRange);\n-            Map<String, FieldValue<?>> extractedFieldMap = new HashMap<>();\n-            // add receipt fields\n-            documentResultItem.getFields().forEach((key, fieldValue) -> {\n-                switch (key) {\n-                    case \"ReceiptType\":\n-                        extractedReceiptItem.setReceiptType(new ReceiptType(fieldValue.getValueString(),\n-                            fieldValue.getConfidence()));\n-                        break;\n-                    case \"MerchantName\":\n-                        extractedReceiptItem.setMerchantName(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantAddress\":\n-                        extractedReceiptItem.setMerchantAddress(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"MerchantPhoneNumber\":\n-                        extractedReceiptItem.setMerchantPhoneNumber(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Subtotal\":\n-                        extractedReceiptItem.setSubtotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tax\":\n-                        extractedReceiptItem.setTax(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Tip\":\n-                        extractedReceiptItem.setTip(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Total\":\n-                        extractedReceiptItem.setTotal(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionDate\":\n-                        extractedReceiptItem.setTransactionDate(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"TransactionTime\":\n-                        extractedReceiptItem.setTransactionTime(setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n-                    case \"Items\":\n-                        extractedReceiptItem.setReceiptItems(toReceiptItems(fieldValue.getValueArray(), readResults, includeTextDetails));\n-                        break;\n-                    default:\n-                        extractedFieldMap.putIfAbsent(key, setFieldValue(fieldValue, readResults, includeTextDetails));\n-                        break;\n+        }\n+\n+        // labeled\n+        if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+            for (PageResult pageResultItem : pageResults) {\n+                int pageNumber = pageResultItem.getPage();\n+                if (CoreUtils.isNullOrEmpty(documentResults)) {\n+                    Integer clusterId = pageResultItem.getClusterId();\n+                    if (clusterId != null) {\n+                        formType.set(formType.get() + clusterId);\n+                    }\n+                    extractedFieldMap = getLabeledFieldMap(includeTextDetails, readResults, pageResultItem,\n+                        pageNumber);\n+\n+                    extractedFormList.add(new RecognizedForm(\n+                        extractedFieldMap,\n+                        formType.get(),\n+                        new PageRange(pageNumber, pageNumber),\n+                        new IterableStream<>(Collections.singletonList(formPages.get(pageNumber - 1)))));\n                 }\n-            });\n-            // adding other detected extra fields\n-            extractedReceiptItem.setExtractedFields(extractedFieldMap);\n-            extractedReceiptList.add(extractedReceiptItem);\n+            }\n         }\n-        return new IterableStream<>(extractedReceiptList);\n+        return extractedFormList;\n     }\n \n     /**\n-     * Helper method that converts the incoming service field value to one of the strongly typed SDK level {@link FieldValue} with\n-     * reference elements set when {@code includeTextDetails} is set to true.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link RecognizedReceipt}.\n      *\n-     * @param fieldValue The named field values returned by the service.\n-     * @param readResults The result containing the list of element references when includeTextDetails is set to true.\n-     * @param includeTextDetails When set to true, a list of references to the text elements is returned in the read result.\n+     * @param analyzeResult The service returned result for analyze receipts.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n      *\n-     * @return The strongly typed {@link FieldValue} for the field input.\n+     * @return The IterableStream of {@code RecognizedReceipt}.\n      */\n-    private static FieldValue<?> setFieldValue(com.azure.ai.formrecognizer.implementation.models.FieldValue fieldValue,\n-                                               List<ReadResult> readResults, boolean includeTextDetails) {\n-        FieldValue<?> value;\n-        switch (fieldValue.getType()) {\n-            case PHONE_NUMBER:\n-                value = toFieldValuePhoneNumber(fieldValue);\n-                break;\n-            case STRING:\n-                value = toFieldValueString(fieldValue);\n-                break;\n-            case TIME:\n-                value = toFieldValueTime(fieldValue);\n-                break;\n-            case DATE:\n-                value = toFieldValueDate(fieldValue);\n-                break;\n-            case INTEGER:\n-                value = toFieldValueInteger(fieldValue);\n-                break;\n-            case NUMBER:\n-                value = toFieldValueNumber(fieldValue);\n-                break;\n-            case ARRAY:\n-            case OBJECT:\n-            default:\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"FieldValue Type not supported\"));\n-        }\n-        if (includeTextDetails) {\n-            value.setElements(setReferenceElements(readResults, fieldValue.getElements()));\n-        }\n-        return value;\n+    static IterableStream<RecognizedReceipt> toReceipt(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        return new IterableStream<>(\n+            toRecognizedForm(analyzeResult, includeTextDetails).stream()\n+                .map(recognizedForm ->\n+                    new RecognizedReceipt(\"en-US\", recognizedForm))\n+                .collect(Collectors.toList()));\n     }\n \n     /**\n-     * Helper method that converts the service returned page information to SDK model {@link PageMetadata}.\n+     * Helper method to transform the service returned {@link AnalyzeResult} to SDK model {@link FormPage}.\n      *\n-     * @param readResultItem A read result item returned from the service containing the page information for provided\n-     * input.\n+     * @param analyzeResult The service returned result for analyze layouts.\n      *\n-     * @return The {@link PageMetadata} for the receipt page.\n+     * @param includeTextDetails Boolean to indicate if to set reference elements data on fields.\n+     * @return The IterableStream of {@code FormPage}.\n      */\n-    private static PageMetadata getPageInfo(ReadResult readResultItem) {\n-        return new PageMetadata(readResultItem.getHeight(), readResultItem.getPage(), readResultItem.getWidth(),\n-            readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n+    static List<FormPage> toRecognizedLayout(AnalyzeResult analyzeResult, boolean includeTextDetails) {\n+        List<ReadResult> readResults = analyzeResult.getReadResults();\n+        List<PageResult> pageResults = analyzeResult.getPageResults();\n+        List<FormPage> formPages = new ArrayList<>();\n+\n+        forEachWithIndex(readResults, ((index, readResultItem) -> {\n+            List<FormTable> perPageTableList = new ArrayList<>();\n+\n+            if (!CoreUtils.isNullOrEmpty(pageResults)) {\n+                PageResult pageResultItem = pageResults.get(index);\n+                perPageTableList = getPageTables(pageResultItem, readResults, pageResultItem.getPage());\n+            }\n+\n+            // add form lines\n+            List<FormLine> perPageFormLineList = new ArrayList<>();\n+            if (includeTextDetails && !CoreUtils.isNullOrEmpty(readResultItem.getLines())) {\n+                perPageFormLineList = getReadResultFormLines(readResultItem);\n+            }\n+\n+            // get form tables\n+            formPages.add(getFormPage(readResultItem, perPageTableList, perPageFormLineList));\n+        }));\n+\n+        return formPages;\n     }\n \n     /**\n-     * Helper method to set the text reference elements on FieldValue/fields when {@code includeTextDetails} set to true.\n+     * Given an iterable will apply the indexing function to it and return the index and each item of the iterable.\n      *\n-     * @param readResults The ReadResult containing the resolved references for text elements.\n-     * @param elements When includeTextDetails is set to true, a list of references to the text\n-     * elements constituting this field value.\n+     * @param iterable the list to apply the mapping function to.\n+     * @param biConsumer the function which accepts the index and the each value of the iterable.\n+     * @param <T> the type of items being returned.\n      *\n-     * @return The updated {@link FieldValue} object with list if referenced elements.\n      */\n-    private static List<Element> setReferenceElements(List<ReadResult> readResults, List<String> elements) {\n-        List<Element> elementList = new ArrayList<>();\n-        elements.forEach(elementString -> {\n-            String[] indices = COMPILE.matcher(elementString).replaceAll(\" \").trim().split(\" \");\n-            int readResultIndex, lineIndex;\n-            if (indices.length >= 1) {\n-                readResultIndex = Integer.parseInt(indices[0]);\n-                lineIndex = Integer.parseInt(indices[1]);\n-            } else {\n-                throw LOGGER.logExceptionAsError(new RuntimeException(\"Reference Elements not found\"));\n-            }\n-            if (indices.length == 3) {\n-                int wordIndex = Integer.parseInt(indices[2]);\n-                TextWord textWord = readResults.get(readResultIndex).getLines().get(lineIndex).getWords()\n-                    .get(wordIndex);\n-                WordElement wordElement = new WordElement(textWord.getText(), toBoundingBox(textWord.getBoundingBox()));\n-                elementList.add(wordElement);\n-            } else {\n-                TextLine textLine = readResults.get(readResultIndex).getLines().get(lineIndex);\n-                LineElement lineElement = new LineElement(textLine.getText(), toBoundingBox(textLine.getBoundingBox()));\n-                elementList.add(lineElement);\n-            }\n+    static <T> void forEachWithIndex(Iterable<T> iterable, BiConsumer<Integer, T> biConsumer) {\n+        int[] index = new int[]{0};\n+        iterable.forEach(element -> biConsumer.accept(index[0]++, element));\n+    }\n+\n+    /**\n+     * Helper method to get per-page table information.\n+     *\n+     * @param pageResultItem The extracted page level information returned by the service.\n+     * @param readResults The text extraction result returned by the service.\n+     * @param pageNumber The 1 based page number on which these fields exist.\n+     *\n+     * @return The list of per page {@code FormTable}.\n+     */\n+    static List<FormTable> getPageTables(PageResult pageResultItem, List<ReadResult> readResults, Integer pageNumber) {\n+        List<FormTable> extractedTablesList = new ArrayList<>();\n+        pageResultItem.getTables().forEach(dataTable -> {", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzMjUzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409032538", "bodyText": "Would this API be easier to use if it was a List instead of IterableStream?", "author": "alzimmermsft", "createdAt": "2020-04-15T18:02:42Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/BoundingBox.java", "diffHunk": "@@ -12,73 +13,25 @@\n public final class BoundingBox {\n \n     /**\n-     * The top-left coordinate of the Bounding box.\n+     * The list of coordinates of the Bounding box.\n      */\n-    private final Point topLeft;\n-\n-    /**\n-     * The top-right coordinate of the Bounding box.\n-     */\n-    private final Point topRight;\n-\n-    /**\n-     * The bottom-right coordinate of the Bounding box.\n-     */\n-    private final Point bottomRight;\n-\n-    /**\n-     * The bottom-left coordinate of the Bounding box.\n-     */\n-    private final Point bottomLeft;\n+    private final IterableStream<Point> points;\n \n     /**\n      * Constructs a Bounding box object.\n      *\n-     * @param topLeft The top-left coordinate of the Bounding box.\n-     * @param topRight The top-right coordinate of the Bounding box.\n-     * @param bottomRight The bottom right coordinate of the Bounding box.\n-     * @param bottomLeft The bottom-left coordinate of the Bounding box.\n-     */\n-    public BoundingBox(final Point topLeft, final Point topRight, final Point bottomRight, final Point bottomLeft) {\n-        this.topLeft = topLeft;\n-        this.topRight = topRight;\n-        this.bottomRight = bottomRight;\n-        this.bottomLeft = bottomLeft;\n-    }\n-\n-    /**\n-     * Gets the top left coordinate of the Bounding box.\n-     *\n-     * @return The top left coordinate of the Bounding box.\n-     */\n-    public Point getTopLeft() {\n-        return this.topLeft;\n-    }\n-\n-    /**\n-     * Gets the top right coordinate of the Bounding box.\n-     *\n-     * @return The top tight coordinate of the Bounding box.\n-     */\n-    public Point getTopRight() {\n-        return this.topRight;\n-    }\n-\n-    /**\n-     * Gets the bottom right coordinate of the Bounding box.\n-     *\n-     * @return The bottom right coordinate of the Bounding box.\n+     * @param points The list of coordinates of the Bounding box.\n      */\n-    public Point getBottomRight() {\n-        return this.bottomRight;\n+    public BoundingBox(final IterableStream<Point> points) {", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzMzQyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409033429", "bodyText": "Could use the factory instead of the constructor as it is null safe.\nthis.lines = IterableStream.of(lines);\nthis.tables = IterbaleStream.of(tables);", "author": "alzimmermsft", "createdAt": "2020-04-15T18:04:08Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/FormPage.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.util.IterableStream;\n+\n+import java.util.Collections;\n+\n+/**\n+ * The FormPage model.\n+ */\n+@Immutable\n+public final class FormPage {\n+\n+    /*\n+     * The height of the image/PDF in pixels/inches, respectively.\n+     */\n+    private final float height;\n+\n+    /*\n+     * When includeTextDetails is set to true, a list of recognized text lines.\n+     */\n+    private final IterableStream<FormLine> lines;\n+\n+    /*\n+     * List of data tables extracted from the page.\n+     */\n+    private final IterableStream<FormTable> tables;\n+\n+    /*\n+     * The general orientation of the text in clockwise direction, measured in\n+     * degrees between (-180, 180].\n+     */\n+    private final float textAngle;\n+\n+    /*\n+     * The unit used by the width, height and boundingBox properties. For\n+     * images, the unit is \"pixel\". For PDF, the unit is \"inch\".\n+     */\n+    private final DimensionUnit unit;\n+\n+    /*\n+     * The width of the image/PDF in pixels/inches, respectively.\n+     */\n+    private final float width;\n+\n+    /**\n+     * Constructs a FormPage object.\n+     *\n+     * @param height The height of the image/PDF in pixels/inches, respectively.\n+     * @param textAngle The general orientation of the text in clockwise direction.\n+     * @param unit The unit used by the width, height and boundingBox properties.\n+     * @param width The width of the image/PDF in pixels/inches, respectively.\n+     * @param lines When includeTextDetails is set to true, a list of recognized text lines.\n+     * @param tables List of data tables extracted from the page.\n+     */\n+    public FormPage(final float height, final float textAngle, final DimensionUnit unit,\n+        final float width, final IterableStream<FormLine> lines, final IterableStream<FormTable> tables) {\n+        this.height = height;\n+        this.textAngle = textAngle;\n+        this.unit = unit;\n+        this.width = width;\n+        this.lines = lines == null\n+            ? new IterableStream<FormLine>(Collections.emptyList())\n+            : lines;\n+        this.tables = tables == null\n+            ? new IterableStream<FormTable>(Collections.emptyList())\n+            : tables;", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzNDgyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409034829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.documentError = documentError == null\n          \n          \n            \n                        ? new IterableStream<FormRecognizerError>(Collections.emptyList())\n          \n          \n            \n                        : documentError;\n          \n          \n            \n                    this.documentError = IterableStream.of(documentError);", "author": "alzimmermsft", "createdAt": "2020-04-15T18:06:39Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/TrainingDocumentInfo.java", "diffHunk": "@@ -0,0 +1,90 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.util.IterableStream;\n+\n+import java.util.Collections;\n+\n+/**\n+ * The TrainingDocumentInfo model.\n+ */\n+@Immutable\n+public final class TrainingDocumentInfo {\n+\n+    /*\n+     * Training document name.\n+     */\n+    private final String name;\n+\n+    /*\n+     * Status of the training operation.\n+     */\n+    private final TrainingStatus trainingStatus;\n+\n+    /*\n+     * Total number of pages trained.\n+     */\n+    private final int pageCount;\n+\n+    /*\n+     * List of errors.\n+     */\n+    private final IterableStream<FormRecognizerError> documentError;\n+\n+    /**\n+     * Constructs a TrainingDocumentInfo object.\n+     *\n+     * @param name Training document name.\n+     * @param trainingStatus Status of the training operation.\n+     * @param pageCount Total number of pages trained.\n+     * @param documentError List of errors.\n+     */\n+    public TrainingDocumentInfo(final String name, final TrainingStatus trainingStatus, final int pageCount,\n+                                final IterableStream<FormRecognizerError> documentError) {\n+        this.name = name;\n+        this.trainingStatus = trainingStatus;\n+        this.pageCount = pageCount;\n+        this.documentError = documentError == null\n+            ? new IterableStream<FormRecognizerError>(Collections.emptyList())\n+            : documentError;", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzNTAxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409035015", "bodyText": "nit: documentErrors?", "author": "alzimmermsft", "createdAt": "2020-04-15T18:06:56Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/TrainingDocumentInfo.java", "diffHunk": "@@ -0,0 +1,90 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.util.IterableStream;\n+\n+import java.util.Collections;\n+\n+/**\n+ * The TrainingDocumentInfo model.\n+ */\n+@Immutable\n+public final class TrainingDocumentInfo {\n+\n+    /*\n+     * Training document name.\n+     */\n+    private final String name;\n+\n+    /*\n+     * Status of the training operation.\n+     */\n+    private final TrainingStatus trainingStatus;\n+\n+    /*\n+     * Total number of pages trained.\n+     */\n+    private final int pageCount;\n+\n+    /*\n+     * List of errors.\n+     */\n+    private final IterableStream<FormRecognizerError> documentError;\n+\n+    /**\n+     * Constructs a TrainingDocumentInfo object.\n+     *\n+     * @param name Training document name.\n+     * @param trainingStatus Status of the training operation.\n+     * @param pageCount Total number of pages trained.\n+     * @param documentError List of errors.\n+     */\n+    public TrainingDocumentInfo(final String name, final TrainingStatus trainingStatus, final int pageCount,\n+                                final IterableStream<FormRecognizerError> documentError) {", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzNjUwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409036501", "bodyText": "Suppressing ServiceClientCheck for clients will mask real issues. Instead, ServiceClientCheck should be updated to address issues caused by LRO methods starting with begin*", "author": "srnagar", "createdAt": "2020-04-15T18:09:29Z", "path": "eng/code-quality-reports/src/main/resources/checkstyle/checkstyle-suppressions.xml", "diffHunk": "@@ -257,8 +257,15 @@\n \n   <!-- Use the logger in a Utility static method. -->\n   <suppress checks=\"com.azure.tools.checkstyle.checks.GoodLoggingCheck\" files=\"com.azure.ai.formrecognizer.Transforms.java\" />\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.GoodLoggingCheck\" files=\"com.azure.ai.formrecognizer.CustomModelTransforms.java\" />\n   <suppress checks=\"com.azure.tools.checkstyle.checks.GoodLoggingCheck\" files=\"com.azure.ai.formrecognizer.implementation.Utility.java\" />\n \n+  <!-- Common vocabulary error for LRO methods starting with begin* -->\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.ServiceClientCheck\" files=\"com.azure.ai.formrecognizer.FormRecognizerAsyncClient.java\" />\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.ServiceClientCheck\" files=\"com.azure.ai.formrecognizer.FormRecognizerClient.java\" />\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.ServiceClientCheck\" files=\"com.azure.ai.formrecognizer.FormTrainingClient.java\" />\n+  <suppress checks=\"com.azure.tools.checkstyle.checks.ServiceClientCheck\" files=\"com.azure.ai.formrecognizer.FormTrainingAsyncClient.java\" />", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0MjQ4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409042485", "bodyText": "I have an open issue to track this will add it in a comment the file too.\n#10147", "author": "samvaity", "createdAt": "2020-04-15T18:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzNjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzOTQ3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409039472", "bodyText": "Prefer to use a List<> instead of IterableStream<>. List provides more convenient APIs to work with. Since the original trainingErrorList is already a list, streaming is not necessary.\nIt will also match your javadoc :)", "author": "srnagar", "createdAt": "2020-04-15T18:14:38Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/CustomModelTransforms.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.models.ErrorInformation;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.ModelInfo;\n+import com.azure.ai.formrecognizer.implementation.models.ModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelField;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.CustomFormModelStatus;\n+import com.azure.ai.formrecognizer.models.CustomFormSubModel;\n+import com.azure.ai.formrecognizer.models.FormRecognizerError;\n+import com.azure.ai.formrecognizer.models.TrainingDocumentInfo;\n+import com.azure.ai.formrecognizer.models.TrainingStatus;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.IterableStream;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import static com.azure.ai.formrecognizer.Transforms.forEachWithIndex;\n+\n+/**\n+ * Helper class to convert service level custom form related models to SDK exposed models.\n+ */\n+final class CustomModelTransforms {\n+    private static final ClientLogger LOGGER = new ClientLogger(CustomModelTransforms.class);\n+\n+    private CustomModelTransforms() {\n+    }\n+\n+    /**\n+     * Helper method to convert the {@link Model model Response} from service to {@link CustomFormModel}.\n+     *\n+     * @param modelResponse The {@code Model model response} returned from the service.\n+     *\n+     * @return The {@link CustomFormModel}.\n+     */\n+    static CustomFormModel toCustomFormModel(Model modelResponse) {\n+        ModelInfo modelInfo = modelResponse.getModelInfo();\n+        if (modelInfo.getStatus() == ModelStatus.INVALID) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(String.format(\"Model Id %s returned with status: %s\",\n+                    modelInfo.getModelId(), modelInfo.getStatus())));\n+        }\n+\n+        List<TrainingDocumentInfo> trainingDocumentInfoList = null;\n+        IterableStream<FormRecognizerError> modelErrors = null;\n+\n+        if (modelResponse.getTrainResult() != null) {\n+            trainingDocumentInfoList =\n+                modelResponse.getTrainResult().getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem -> new TrainingDocumentInfo(\n+                        trainingDocumentItem.getDocumentName(),\n+                        TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                        trainingDocumentItem.getPages(),\n+                        transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .collect(Collectors.toList());\n+            modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n+        }\n+\n+        List<CustomFormSubModel> subModelList = new ArrayList<>();\n+        String formType = \"form-\";\n+        // unlabeled model\n+        if (modelResponse.getKeys() != null) {\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n+                forEachWithIndex(clusterFields, (index, eachField) -> {\n+                    String fieldName = \"field-\" + index;\n+                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n+                });\n+                subModelList.add(new CustomFormSubModel(\n+                    null,\n+                    fieldMap,\n+                    formType + clusterKey));\n+            });\n+        } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n+            // labeled model\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            modelResponse.getTrainResult().getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+            subModelList.add(new CustomFormSubModel(\n+                modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap,\n+                formType + modelInfo.getModelId()));\n+        }\n+\n+        return new CustomFormModel(\n+            modelInfo.getModelId().toString(),\n+            CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n+            modelInfo.getCreatedDateTime(),\n+            modelInfo.getLastUpdatedDateTime(),\n+            new IterableStream<>(subModelList),\n+            modelErrors,\n+            new IterableStream<TrainingDocumentInfo>(trainingDocumentInfoList));\n+    }\n+\n+    /**\n+     * Helper method to convert the list of {@link ErrorInformation} to list of {@link FormRecognizerError}.\n+     *\n+     * @param trainingErrorList The list of {@link ErrorInformation}.\n+     *\n+     * @return The list of {@link FormRecognizerError}\n+     */\n+    private static IterableStream<FormRecognizerError> transformTrainingErrors(", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE1MjY1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409152650", "bodyText": "updated this to be a list.", "author": "samvaity", "createdAt": "2020-04-15T21:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzOTQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0MzA3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409043074", "bodyText": "Throwing exception in a method returning a reactor publisher will cause issues downstream. Instead all these exceptions have to be wrapped and returned in error channel.", "author": "srnagar", "createdAt": "2020-04-15T18:20:57Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -76,164 +89,303 @@ public FormRecognizerServiceVersion getServiceVersion() {\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 50 MB.\n+     * @param modelId The UUID string format custom trained model Id to be used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract custom form operation until it has completed, has failed,\n+     * or has been cancelled.\n+     */\n+    @ServiceMethod(returns = ReturnType.COLLECTION)\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>\n+        beginRecognizeCustomFormsFromUrl(String fileSourceUrl, String modelId) {\n+        return beginRecognizeCustomFormsFromUrl(fileSourceUrl, modelId, false, null);\n+    }\n+\n+    /**\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n      * model.\n      * <p>The service does not support cancellation of the long running operation and returns with an\n      * error message indicating absence of cancellation support.</p>\n      *\n-     * @param sourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param fileSourceUrl The source URL to the input document. Size of the file must be less than 50 MB.\n+     * @param modelId The UUID string format custom trained model Id to be used.\n+     * @param includeTextDetails Include text lines and element references in the result.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract custom form operation until it has completed, has failed,\n+     * or has been cancelled.\n+     */\n+    @ServiceMethod(returns = ReturnType.COLLECTION)\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>\n+        beginRecognizeCustomFormsFromUrl(String fileSourceUrl, String modelId, boolean includeTextDetails,\n+        Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' is required and cannot be null.\");\n+        Objects.requireNonNull(modelId, \"'modelId' is required and cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : DEFAULT_DURATION;\n+        return new PollerFlux<OperationResult, IterableStream<RecognizedForm>>(\n+            interval,\n+            analyzeFormActivationOperation(fileSourceUrl, modelId, includeTextDetails),\n+            createAnalyzeFormPollOperation(modelId),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchAnalyzeFormResultOperation(modelId, includeTextDetails));\n+    }\n+\n+    /**\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n+     * model.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param data The data of the document to be extract receipt information from.\n+     * @param modelId The UUID string format custom trained model Id to be used.\n+     * @param length The exact length of the data. Size of the file must be less than 50 MB.\n+     * @param formContentType Supported Media types including .pdf, .jpg, .png or .tiff type file stream.\n      *\n      * @return A {@link PollerFlux} that polls the extract receipt operation until it has completed, has failed, or has\n      * been cancelled.\n      */\n-    public PollerFlux<OperationResult, IterableStream<ExtractedReceipt>> beginExtractReceiptsFromUrl(String sourceUrl) {\n-        return beginExtractReceiptsFromUrl(sourceUrl, false, null);\n+    @ServiceMethod(returns = ReturnType.COLLECTION)\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>\n+        beginRecognizeCustomForms(Flux<ByteBuffer> data, String modelId, long length, FormContentType formContentType) {\n+        return beginRecognizeCustomForms(data, modelId, length, formContentType, false, null);\n     }\n \n     /**\n-     * Detects and extracts data from receipts using optical character recognition (OCR) and a prebuilt receipt trained\n+     * Recognizes and extracts form data from documents using optical character recognition (OCR) and a custom trained\n      * model.\n      * <p>The service does not support cancellation of the long running operation and returns with an\n      * error message indicating absence of cancellation support.</p>\n      *\n-     * @param sourceUrl The source URL to the input document. Size of the file must be less than 20 MB.\n+     * @param data The data of the document to be extract receipt information from.\n+     * @param modelId The UUID string format custom trained model Id to be used.\n+     * @param length The exact length of the data. Size of the file must be less than 50 MB.\n      * @param includeTextDetails Include text lines and element references in the result.\n+     * @param formContentType Supported Media types including .pdf, .jpg, .png or .tiff type file stream.\n      * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n      * 5 seconds is used.\n      *\n      * @return A {@link PollerFlux} that polls the extract receipt operation until it has completed, has failed, or has\n      * been cancelled.\n      */\n-    public PollerFlux<OperationResult, IterableStream<ExtractedReceipt>>\n-        beginExtractReceiptsFromUrl(String sourceUrl, boolean includeTextDetails,\n-                                Duration pollInterval) {\n+    @ServiceMethod(returns = ReturnType.COLLECTION)\n+    public PollerFlux<OperationResult, IterableStream<RecognizedForm>>\n+        beginRecognizeCustomForms(Flux<ByteBuffer> data, String modelId, long length, FormContentType formContentType,\n+        boolean includeTextDetails, Duration pollInterval) {\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+        Objects.requireNonNull(modelId, \"'modelId' is required and cannot be null.\");\n+        Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0NzM0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409047345", "bodyText": "Why is the annotation commented out?", "author": "srnagar", "createdAt": "2020-04-15T18:28:27Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedResponse;\n+import com.azure.core.http.rest.PagedResponseBase;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModelInfo;\n+import static com.azure.ai.formrecognizer.FormRecognizerClientBuilder.DEFAULT_DURATION;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations\n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to creating, training of custom models, delete models, list models and get\n+ * subscription account information.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+@ServiceClient(builder = FormRecognizerClientBuilder.class, isAsync = true)\n+public class FormTrainingAsyncClient {\n+\n+    private final ClientLogger logger = new ClientLogger(FormTrainingAsyncClient.class);\n+    private final FormRecognizerClientImpl service;\n+    private final FormRecognizerServiceVersion serviceVersion;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param service The proxy service used to perform REST calls.\n+     * @param serviceVersion The versions of Azure Form Recognizer supported by this client library.\n+     */\n+    FormTrainingAsyncClient(FormRecognizerClientImpl service, FormRecognizerServiceVersion serviceVersion) {\n+        this.service = service;\n+        this.serviceVersion = serviceVersion;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return serviceVersion;\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link PollerFlux} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    // @ServiceMethod(returns = ReturnType.SINGLE)", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0Nzc5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409047799", "bodyText": "missing annotations.", "author": "srnagar", "createdAt": "2020-04-15T18:29:10Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingAsyncClient.java", "diffHunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.FormRecognizerClientImpl;\n+import com.azure.ai.formrecognizer.implementation.models.Model;\n+import com.azure.ai.formrecognizer.implementation.models.TrainRequest;\n+import com.azure.ai.formrecognizer.implementation.models.TrainSourceFilter;\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedResponse;\n+import com.azure.core.http.rest.PagedResponseBase;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.polling.LongRunningOperationStatus;\n+import com.azure.core.util.polling.PollResponse;\n+import com.azure.core.util.polling.PollerFlux;\n+import com.azure.core.util.polling.PollingContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModel;\n+import static com.azure.ai.formrecognizer.CustomModelTransforms.toCustomFormModelInfo;\n+import static com.azure.ai.formrecognizer.FormRecognizerClientBuilder.DEFAULT_DURATION;\n+import static com.azure.ai.formrecognizer.implementation.Utility.parseModelId;\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * This class provides an asynchronous client that contains model management operations\n+ * that apply to Azure Form Recognizer.\n+ * Operations allowed by the client are, to creating, training of custom models, delete models, list models and get\n+ * subscription account information.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+@ServiceClient(builder = FormRecognizerClientBuilder.class, isAsync = true)\n+public class FormTrainingAsyncClient {\n+\n+    private final ClientLogger logger = new ClientLogger(FormTrainingAsyncClient.class);\n+    private final FormRecognizerClientImpl service;\n+    private final FormRecognizerServiceVersion serviceVersion;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param service The proxy service used to perform REST calls.\n+     * @param serviceVersion The versions of Azure Form Recognizer supported by this client library.\n+     */\n+    FormTrainingAsyncClient(FormRecognizerClientImpl service, FormRecognizerServiceVersion serviceVersion) {\n+        this.service = service;\n+        this.serviceVersion = serviceVersion;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return serviceVersion;\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link PollerFlux} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    // @ServiceMethod(returns = ReturnType.SINGLE)\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content type -\n+     * 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure\n+     * storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link PollerFlux} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public PollerFlux<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl,\n+        boolean useLabelFile, boolean includeSubFolders, String filePrefix, Duration pollInterval) {\n+        Objects.requireNonNull(fileSourceUrl, \"'fileSourceUrl' cannot be null.\");\n+        final Duration interval = pollInterval != null ? pollInterval : DEFAULT_DURATION;\n+\n+        return new PollerFlux<OperationResult, CustomFormModel>(\n+            interval,\n+            getTrainingActivationOperation(fileSourceUrl, includeSubFolders, filePrefix, useLabelFile),\n+            createTrainingPollOperation(),\n+            (activationResponse, context) -> Mono.error(new RuntimeException(\"Cancellation is not supported\")),\n+            fetchTrainingModelResultOperation());\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id.\n+     *\n+     * @param modelId The UUID string format model identifier.\n+     *\n+     * @return The detailed information for the specified model.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<CustomFormModel> getCustomModel(String modelId) {\n+        return getCustomModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Get detailed information for a specified custom model id with Http response\n+     *\n+     * @param modelId The UUID string format model identifier.\n+     *\n+     * @return A {@link Response} containing the requested {@link CustomFormModel model}.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<CustomFormModel>> getCustomModelWithResponse(String modelId) {\n+        try {\n+            return withContext(context -> getCustomModelWithResponse(modelId, context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<CustomFormModel>> getCustomModelWithResponse(String modelId, Context context) {\n+        Objects.requireNonNull(modelId, \"'modelId' cannot be null\");\n+        return service.getCustomModelWithResponseAsync(UUID.fromString(modelId), context, true)\n+            .map(response -> new SimpleResponse<>(response, toCustomFormModel(response.getValue())));\n+    }\n+\n+    /**\n+     * Get account information for all custom models.\n+     *\n+     * @return The account information.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<AccountProperties> getAccountProperties() {\n+        return getAccountPropertiesWithResponse().flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Get account information.\n+     *\n+     * @return A {@link Response} containing the requested account information details.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<AccountProperties>> getAccountPropertiesWithResponse() {\n+        try {\n+            return withContext(context -> getAccountPropertiesWithResponse(context));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    Mono<Response<AccountProperties>> getAccountPropertiesWithResponse(Context context) {\n+        return service.getCustomModelsWithResponseAsync(context)\n+            .map(response -> new SimpleResponse<>(response,\n+                new AccountProperties(response.getValue().getSummary().getCount(),\n+                    response.getValue().getSummary().getLimit())));\n+    }\n+\n+    /**\n+     * Deletes the specified custom model.\n+     *\n+     * @param modelId The UUID string format model identifier.\n+     *\n+     * @return An empty Mono.\n+     */\n+    public Mono<Void> deleteModel(String modelId) {\n+        return deleteModelWithResponse(modelId).flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Deletes the specified custom model.\n+     *\n+     * @param modelId The UUID string format model identifier.\n+     *\n+     * @return A {@link Mono} containing containing status code and HTTP headers\n+     */\n+    public Mono<Response<Void>> deleteModelWithResponse(String modelId) {", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MDI0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409050246", "bodyText": "Should these methods support passing in a Context?", "author": "srnagar", "createdAt": "2020-04-15T18:33:19Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormTrainingClient.java", "diffHunk": "@@ -0,0 +1,190 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.AccountProperties;\n+import com.azure.ai.formrecognizer.models.CustomFormModel;\n+import com.azure.ai.formrecognizer.models.CustomFormModelInfo;\n+import com.azure.ai.formrecognizer.models.OperationResult;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.polling.SyncPoller;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+\n+/**\n+ * This class provides a synchronous client that contains model management the operations that apply\n+ * to Azure Form Recognizer.\n+ * Operations allowed by the client are, to create/tracin custom models. delete models, list models.\n+ *\n+ * @see FormRecognizerClientBuilder\n+ */\n+@ServiceClient(builder = FormRecognizerClientBuilder.class)\n+public class FormTrainingClient {\n+\n+    private final FormTrainingAsyncClient client;\n+\n+    /**\n+     * Create a {@link FormTrainingClient} that sends requests to the Form Recognizer service's endpoint.\n+     * Each service call goes through the {@link FormRecognizerClientBuilder#pipeline http pipeline}.\n+     *\n+     * @param formTrainingAsyncClient The {@link FormRecognizerAsyncClient} that the client routes its request through.\n+     */\n+    FormTrainingClient(FormTrainingAsyncClient formTrainingAsyncClient) {\n+        this.client = formTrainingAsyncClient;\n+    }\n+\n+    /**\n+     * Gets the service version the client is using.\n+     *\n+     * @return the service version the client is using.\n+     */\n+    public FormRecognizerServiceVersion getServiceVersion() {\n+        return client.getServiceVersion();\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * <p>Models are trained using documents that are of the following content\n+     * type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * </p>\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible\n+     * Azure storage blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     *\n+     * @return A {@link SyncPoller} that polls the training model operation until it has completed, has failed, or has\n+     * been cancelled.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public SyncPoller<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile) {\n+        return beginTraining(fileSourceUrl, useLabelFile, false, null, null);\n+    }\n+\n+    /**\n+     * Create and train a custom model.\n+     * Models are trained using documents that are of the following content type - 'application/pdf',\n+     * 'image/jpeg', 'image/png', 'image/tiff'.\n+     * Other type of content is ignored.\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * @param fileSourceUrl source URL parameter that is either an externally accessible Azure storage\n+     * blob container Uri (preferably a Shared Access Signature Uri).\n+     * @param useLabelFile Boolean to specify the use of labeled files for training the model.\n+     * @param includeSubFolders to indicate if sub folders within the set of prefix folders will\n+     * also need to be included when searching for content to be preprocessed.\n+     * @param filePrefix A case-sensitive prefix string to filter documents in the source path\n+     * for training. For example, when using a Azure storage blob Uri, use the prefix to restrict\n+     * sub folders for training.\n+     * @param pollInterval Duration between each poll for the operation status. If none is specified, a default of\n+     * 5 seconds is used.\n+     *\n+     * @return A {@link SyncPoller} that polls the extract receipt operation until it\n+     * has completed, has failed, or has been cancelled.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public SyncPoller<OperationResult, CustomFormModel> beginTraining(String fileSourceUrl, boolean useLabelFile,", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA2ODIxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409068211", "bodyText": "Context overloads for Form recognizer will be added once we get the support for context passing in pollers.", "author": "samvaity", "createdAt": "2020-04-15T19:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MDI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MzA4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409053086", "bodyText": "For some of these model types, consider using List as there's no additional benefit from using IterableStream while List provides options to check the size, provide random access with index etc and can easily be converted to stream or iterator.", "author": "srnagar", "createdAt": "2020-04-15T18:37:57Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/ReceiptExtensions.java", "diffHunk": "@@ -0,0 +1,137 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.FormField;\n+import com.azure.ai.formrecognizer.models.RecognizedReceipt;\n+import com.azure.ai.formrecognizer.models.USReceipt;\n+import com.azure.ai.formrecognizer.models.USReceiptItem;\n+import com.azure.ai.formrecognizer.models.USReceiptType;\n+import com.azure.core.util.IterableStream;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.NAME;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.PRICE;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.QUANTITY;\n+import static com.azure.ai.formrecognizer.models.ReceiptItemType.TOTAL_PRICE;\n+\n+/**\n+ * The ReceiptExtensions class to allow users to convert a {@link RecognizedReceipt}\n+ * to a receiptLocale specific Receipt type.\n+ */\n+public final class ReceiptExtensions {\n+\n+    private ReceiptExtensions() {\n+    }\n+\n+    /**\n+     * Static method to convert an incoming receipt to a {@link USReceipt type}.\n+     *\n+     * @param receipt The {@link RecognizedReceipt recognized receipt}.\n+     *\n+     * @return The converted {@link USReceipt US locale receipt} type.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static USReceipt asUSReceipt(RecognizedReceipt receipt) {\n+        // add receipt fields\n+        USReceiptType receiptType = null;\n+        FormField<String> merchantName = null;\n+        FormField<String> merchantAddress = null;\n+        FormField<String> merchantPhoneNumber = null;\n+        FormField<Float> subtotal = null;\n+        FormField<Float> tax = null;\n+        FormField<Float> tip = null;\n+        FormField<Float> total = null;\n+        FormField<LocalDate> transactionDate = null;\n+        FormField<String> transactionTime = null;\n+        IterableStream<USReceiptItem> receiptItems = null;\n+\n+        for (Map.Entry<String, FormField<?>> entry : receipt.getRecognizedForm().getFields().entrySet()) {\n+            String key = entry.getKey();\n+            FormField<?> fieldValue = entry.getValue();\n+            switch (key) {\n+                case \"ReceiptType\":\n+                    receiptType = new USReceiptType(key, fieldValue.getConfidence());\n+                    break;\n+                case \"MerchantName\":\n+                    merchantName = (FormField<String>) fieldValue;\n+                    break;\n+                case \"MerchantAddress\":\n+                    merchantAddress = (FormField<String>) fieldValue;\n+                    break;\n+                case \"MerchantPhoneNumber\":\n+                    merchantPhoneNumber = (FormField<String>) fieldValue;\n+                    break;\n+                case \"Subtotal\":\n+                    subtotal = (FormField<Float>) fieldValue;\n+                    break;\n+                case \"Tax\":\n+                    tax = (FormField<Float>) fieldValue;\n+                    break;\n+                case \"Tip\":\n+                    tip = (FormField<Float>) fieldValue;\n+                    break;\n+                case \"Total\":\n+                    total = (FormField<Float>) fieldValue;\n+                    break;\n+                case \"TransactionDate\":\n+                    transactionDate = (FormField<LocalDate>) fieldValue;\n+                    break;\n+                case \"TransactionTime\":\n+                    transactionTime = (FormField<String>) fieldValue;\n+                    break;\n+                case \"Items\":\n+                    receiptItems = toReceiptItems(fieldValue);\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        return new USReceipt(receipt.getReceiptLocale(), receipt.getRecognizedForm(), receiptItems, receiptType,\n+            merchantName, merchantAddress, merchantPhoneNumber, subtotal, tax, tip, total, transactionDate,\n+            transactionTime);\n+    }\n+\n+    /**\n+     * Helper method to convert the service level\n+     * {@link com.azure.ai.formrecognizer.implementation.models.FieldValue#getValueArray() value items}\n+     * to SDK level {@link USReceiptItem receipt items}.\n+     *\n+     * @param fieldValueItems The strongly typed field values.\n+     *\n+     * @return A list of {@link USReceiptItem}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private static IterableStream<USReceiptItem> toReceiptItems(FormField<?> fieldValueItems) {", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA2OTg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409069862", "bodyText": "Is it then ok, for some model variables to be returned as List and some as IterableStream gauging somewhat the way it will be used?", "author": "samvaity", "createdAt": "2020-04-15T19:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MzA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE1MzA3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409153076", "bodyText": "Updated some to be a List and kept a few as IterableStream depending on their expected usage.", "author": "samvaity", "createdAt": "2020-04-15T21:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1MzA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1ODE4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409058188", "bodyText": "fix javadoc.", "author": "srnagar", "createdAt": "2020-04-15T18:46:37Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/AccountProperties.java", "diffHunk": "@@ -0,0 +1,53 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+/**\n+ * The AccountProperties model.\n+ */\n+@Immutable\n+public final class AccountProperties {\n+\n+    /*\n+     * Max number of models that can be trained for this account.\n+     */\n+    private final int count;\n+\n+    /*\n+     * Max number of models that can be trained for this account.\n+     */\n+    private final int limit;\n+\n+    /**\n+     * Constructs an AccountProperties object.\n+     *\n+     * @param count Max number of models that can be trained for this account.\n+     * @param limit Max number of models that can be trained for this account.", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE1MzI3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409153277", "bodyText": "updated!", "author": "samvaity", "createdAt": "2020-04-15T21:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1ODE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1OTM3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409059372", "bodyText": "This javadoc doesn't look right for INVALID CustomFormModelStatus . Same for READY too.", "author": "srnagar", "createdAt": "2020-04-15T18:48:38Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/CustomFormModelStatus.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.util.ExpandableStringEnum;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Defines enum values for CustomFormModelStatus.\n+ */\n+public final class CustomFormModelStatus extends ExpandableStringEnum<CustomFormModelStatus> {\n+\n+    /**\n+     * Static value Creating for CustomFormModelStatus.\n+     */\n+    public static final CustomFormModelStatus CREATING = fromString(\"creating\");\n+\n+    /**\n+     * Static value Creating for CustomFormModelStatus.\n+     */\n+    public static final CustomFormModelStatus READY = fromString(\"ready\");\n+\n+    /**\n+     * Static value Creating for CustomFormModelStatus.", "originalCommit": "a845a82dea48e915ebdedfefbb740f39cf6ed28e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE1MzM1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9988#discussion_r409153357", "bodyText": "Updated.", "author": "samvaity", "createdAt": "2020-04-15T21:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1OTM3Mg=="}], "type": "inlineReview"}, {"oid": "9805caf64c053991fc25a0a83c197924931c9108", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9805caf64c053991fc25a0a83c197924931c9108", "message": "review comments, IterableStream->List updates, monoError, ErrorResponseException", "committedDate": "2020-04-15T21:25:03Z", "type": "commit"}]}