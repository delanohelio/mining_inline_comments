{"pr_number": 16452, "pr_title": "End to end TLS SSL", "pr_createdAt": "2020-10-16T13:34:14Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16452", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODIyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508818226", "bodyText": "This section can be placed under Contributing Section.", "author": "g2vinay", "createdAt": "2020-10-20T20:28:22Z", "path": "sdk/keyvault/azure-security-keyvault-jca/README.md", "diffHunk": "@@ -0,0 +1,127 @@\n+# JCA Provider for Azure Key Vault\n+\n+The JCA Provider for Azure Key Vault is a JCA provider for certificates in \n+Azure Key Vault. It is built on four principles:\n+ \n+1. Must be extremely thin to run within a JVM\n+1. Must not introduce any library version conflicts with Java app code dependencies\n+1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies\n+1. Must be ready for \"never trust, always verify and credential-free\" Zero Trust environments.\n+\n+## Testing the version under development", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzMzM3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510433374", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T20:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNDM1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508824350", "bodyText": "Why are we locking the config to 1.8 ?", "author": "g2vinay", "createdAt": "2020-10-20T20:39:21Z", "path": "sdk/keyvault/azure-security-keyvault-jca/pom.xml", "diffHunk": "@@ -0,0 +1,232 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>azure-client-sdk-parent</artifactId>\n+        <groupId>com.azure</groupId>\n+        <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+        <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+    </parent>\n+\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-security-keyvault-jca</artifactId>\n+    <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-security-keyvault-jca;current} -->\n+    <name>JCA Provider for Azure Key Vault</name>\n+    <description>The Java Crypto Architecture (JCA) Provider for Azure KeyVault</description>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <version>3.8.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-compiler-plugin;external_dependency} -->\n+                <configuration>\n+                    <source>1.8</source>\n+                    <target>1.8</target>", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2NDIzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508964231", "bodyText": "Because we want this library to work on Java 8.", "author": "JonathanGiles", "createdAt": "2020-10-21T03:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNDM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2NzQ4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508967489", "bodyText": "okay,\nbut we don't lock the target version here in our client sdk parent pom.\nThis can be cleaned up using profiles.", "author": "g2vinay", "createdAt": "2020-10-21T03:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNDM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2ODUzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508968539", "bodyText": "Yes we do", "author": "JonathanGiles", "createdAt": "2020-10-21T03:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNTU4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508825581", "bodyText": "This will work on IMDS supported Azure Platforms only.\nFor e.g This won't work in App Service.", "author": "g2vinay", "createdAt": "2020-10-20T20:41:33Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzQzNzE5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r607437192", "bodyText": "Hi, the case of App Service has been handled separately. And according to this doc, requesting access tokens via Azure resources VM Extension Endpoint is also not encouraged. Thus are there any other cases that are not covered? Thanks", "author": "yiliuTo", "createdAt": "2021-04-06T02:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNTU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNjQ2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508826465", "bodyText": "Why do we need to build the custom Auth Client ?\nMSAL offers this support, can we directly use MSAL here ?", "author": "g2vinay", "createdAt": "2020-10-20T20:43:11Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3MTIxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510171210", "bodyText": "MSAL would only be usable in this particular case if a) it is self-contained as a JAR and b) it can be properly shaded and relocated so customers are not impacted by versioning. As far as I can tell that is not the case hence it using its own client.", "author": "mnriem", "createdAt": "2020-10-22T13:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNjQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyODI1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508828254", "bodyText": "There's a newer 2019 API version available, which uses IDENTITY_ENDPOINT and IDENTITY_HEADER env vars.", "author": "g2vinay", "createdAt": "2020-10-20T20:46:18Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQ2NjgxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r597466816", "bodyText": "Hi @g2vinay , I found the following information that when using Linux Consumption, 2017 API version is required. Thus is it a better choice that we remain use of 2017 API version to support more cases?", "author": "yiliuTo", "createdAt": "2021-03-19T07:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyODI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyODg3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508828872", "bodyText": "with 2017 API version, I believe the expiry time comes in different formats on Windows and Linux based App Services,\nis that being handled here ?", "author": "g2vinay", "createdAt": "2020-10-20T20:47:27Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")\n+           .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Metadata\", \"true\");\n+        headers.put(\"Secret\", System.getenv(\"MSI_SECRET\"));\n+        String body = get(url.toString(), headers);\n+\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzMDcyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508830726", "bodyText": "This URL won't work on all of the other Azure Platforms, for e.g. Azure Service Fabric", "author": "g2vinay", "createdAt": "2020-10-20T20:50:47Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")\n+           .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Metadata\", \"true\");\n+        headers.put(\"Secret\", System.getenv(\"MSI_SECRET\"));\n+        String body = get(url.toString(), headers);\n+\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.exiting(\"AuthClient\", \"getAccessTokenOnAppService\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the authorization token on everything else but Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnOthers(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnOthers\", resource);\n+        LOGGER.info(\"Getting access token using managed identity\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(OAUTH2_MANAGED_IDENTITY_TOKEN_URL)", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjAxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508952015", "bodyText": "Don't need to have public methods on a package private class", "author": "g2vinay", "createdAt": "2020-10-21T02:31:39Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;\n+\n+    /**\n+     * Stores the tenant ID.\n+     */\n+    private String tenantId;\n+\n+    /**\n+     * Stores the client ID.\n+     */\n+    private String clientId;\n+\n+    /**\n+     * Stores the client secret.\n+     */\n+    private String clientSecret;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     */\n+    KeyVaultClient(String keyVaultUri) {\n+        super(RestClientFactory.createClient());\n+        LOGGER.log(INFO, \"Using KeyVault: {0}\", keyVaultUri);\n+        if (!keyVaultUri.endsWith(\"/\")) {\n+            keyVaultUri = keyVaultUri + \"/\";\n+        }\n+        this.keyVaultUri = keyVaultUri;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     */\n+    KeyVaultClient(final String keyVaultUri, final String tenantId, final String clientId, final String clientSecret) {\n+        this(keyVaultUri);\n+        this.tenantId = tenantId;\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    private String getAccessToken() {\n+        LOGGER.entering(\"KeyVaultClient\", \"getAccessToken\");\n+        String accessToken = null;\n+        try {\n+            AuthClient authClient = new AuthClient();\n+            String resource = URLEncoder.encode(\"https://vault.azure.net\", \"UTF-8\");\n+            if (tenantId != null && clientId != null && clientSecret != null) {\n+                accessToken = authClient.getAccessToken(resource, tenantId, clientId, clientSecret);\n+            } else {\n+                accessToken = authClient.getAccessToken(resource);\n+            }\n+        } catch (UnsupportedEncodingException uee) {\n+            LOGGER.log(WARNING, \"Unsupported encoding\", uee);\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getAccessToken\", accessToken);\n+        return accessToken;\n+    }\n+\n+    /**\n+     * Get the list of aliases.\n+     *\n+     * @return the list of aliases.\n+     */\n+    public List<String> getAliases() {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1NDcxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511154714", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2MzgzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511163839", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508952343", "bodyText": "why protected and not public ?", "author": "g2vinay", "createdAt": "2020-10-21T02:32:53Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyManagerFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactorySpi;\n+import javax.net.ssl.ManagerFactoryParameters;\n+import java.security.KeyStore;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+/**\n+ * The KeyVault variant of the KeyManagerFactory.\n+ */\n+public class KeyVaultKeyManagerFactory extends KeyManagerFactorySpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyManagerFactory.class.getName());\n+\n+    /**\n+     * Stores the key managers.\n+     */\n+    private final List<KeyManager> keyManagers = new ArrayList<>();\n+\n+    @Override\n+    protected void engineInit(KeyStore keystore, char[] password) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIwMDk2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510200967", "bodyText": "Not my choice this is part of the KeyManagerFactory delivered as part of JCA", "author": "mnriem", "createdAt": "2020-10-22T14:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjYyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508952621", "bodyText": "is this method meant to not do anything ?\nBetter to throw an UnsupportedOperationException, to let user know,", "author": "g2vinay", "createdAt": "2020-10-21T02:34:09Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyManagerFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactorySpi;\n+import javax.net.ssl.ManagerFactoryParameters;\n+import java.security.KeyStore;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+/**\n+ * The KeyVault variant of the KeyManagerFactory.\n+ */\n+public class KeyVaultKeyManagerFactory extends KeyManagerFactorySpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyManagerFactory.class.getName());\n+\n+    /**\n+     * Stores the key managers.\n+     */\n+    private final List<KeyManager> keyManagers = new ArrayList<>();\n+\n+    @Override\n+    protected void engineInit(KeyStore keystore, char[] password) {\n+        LOGGER.entering(\n+            \"KeyVaultKeyManagerFactory\",\n+            \"engineInit\",\n+            new Object[] { keystore, new String(password) }\n+        );\n+        KeyVaultKeyManager manager = new KeyVaultKeyManager(keystore, password);\n+        keyManagers.add(manager);\n+    }\n+\n+    @Override\n+    protected void engineInit(ManagerFactoryParameters spec) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2MTczOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510461739", "bodyText": "Yes it is meant to do nothing. And the API is defined and it does not state UnsupportedOperationException can be thrown.", "author": "mnriem", "createdAt": "2020-10-22T21:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzAzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508953035", "bodyText": "Consider adding code snippets in Javadocs for public API.", "author": "g2vinay", "createdAt": "2020-10-21T02:35:44Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2Nzk3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510467973", "bodyText": "This is an API that has been part of Java for a long time and as such has its own documentation so no need to add code snippets here.", "author": "mnriem", "createdAt": "2020-10-22T21:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzMxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508953314", "bodyText": "Consider throwing UnsupportedOperationException to offer a better User experience, in all the methods that do not have any logic in them.\nCurrently, user will just wonder if the operation executed successfully or not.", "author": "g2vinay", "createdAt": "2020-10-21T02:36:55Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2MDQ1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511160452", "bodyText": "The API contract is defined by the JCA specification / JavaDoc and it does not state UnsupportedOperationException can be thrown.", "author": "mnriem", "createdAt": "2020-10-23T21:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzMxNA=="}], "type": "inlineReview"}, {"oid": "9011247ff09367559d9d560811805d4c59e3a735", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9011247ff09367559d9d560811805d4c59e3a735", "message": "Add JCA provider for Azure KeyVault", "committedDate": "2020-09-22T23:04:36Z", "type": "commit"}, {"oid": "366021aeb4f0e0ec7b464172128d93e487de0c57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/366021aeb4f0e0ec7b464172128d93e487de0c57", "message": "Added the starter", "committedDate": "2020-09-29T21:16:18Z", "type": "commit"}, {"oid": "4229ad580682118919f8e647e9cd5b9b326850c8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4229ad580682118919f8e647e9cd5b9b326850c8", "message": "Added sample", "committedDate": "2020-09-30T14:43:58Z", "type": "commit"}, {"oid": "7720e9c3a85af9ebbef866874c536482b2edadaa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7720e9c3a85af9ebbef866874c536482b2edadaa", "message": "Cleaned up sample", "committedDate": "2020-09-30T15:00:18Z", "type": "commit"}, {"oid": "f4294f9fe29522ffdd548d0e892591a2ac4e3840", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f4294f9fe29522ffdd548d0e892591a2ac4e3840", "message": "Remove unncessary deployment.yml", "committedDate": "2020-09-30T15:36:28Z", "type": "commit"}, {"oid": "49239ee2e3cb96a8d9a22e89872317abd911f1b8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/49239ee2e3cb96a8d9a22e89872317abd911f1b8", "message": "Add system assigned identity support step #1", "committedDate": "2020-10-01T22:20:00Z", "type": "commit"}, {"oid": "502bd8724d382e35bf731213433c651b3f41774d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/502bd8724d382e35bf731213433c651b3f41774d", "message": "Added system managed identity support for App Service", "committedDate": "2020-10-02T18:28:28Z", "type": "commit"}, {"oid": "599b7ed42da34deeee1ffa2bf86bac3a327b5f07", "url": "https://github.com/Azure/azure-sdk-for-java/commit/599b7ed42da34deeee1ffa2bf86bac3a327b5f07", "message": "Added README for JCA provider", "committedDate": "2020-10-06T17:28:35Z", "type": "commit"}, {"oid": "d8d0bc0e7fc1d3eedaadab0429ddc40a28c303aa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d8d0bc0e7fc1d3eedaadab0429ddc40a28c303aa", "message": "Added README for JCA provider", "committedDate": "2020-10-06T17:48:49Z", "type": "commit"}, {"oid": "316bd9507b53434d22e0d7b5ca3eccdb0e87baa3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/316bd9507b53434d22e0d7b5ca3eccdb0e87baa3", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:13:56Z", "type": "commit"}, {"oid": "0c0c67a5debd73cbdbda1f1e2756d35120b54536", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0c0c67a5debd73cbdbda1f1e2756d35120b54536", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:17:13Z", "type": "commit"}, {"oid": "d4a5a1fb5161da287dc2fc12b9ec927ffd05b6bc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d4a5a1fb5161da287dc2fc12b9ec927ffd05b6bc", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:20:40Z", "type": "commit"}, {"oid": "95aea0e56c3859922d4ed467093a67fb2ce55a58", "url": "https://github.com/Azure/azure-sdk-for-java/commit/95aea0e56c3859922d4ed467093a67fb2ce55a58", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:22:19Z", "type": "commit"}, {"oid": "7fc29460aedef752bbb58f6fb04363b7460e272d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fc29460aedef752bbb58f6fb04363b7460e272d", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:25:52Z", "type": "commit"}, {"oid": "b7dcb077e3fd6a02d9525c23f7f7396bcf7dc089", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7dcb077e3fd6a02d9525c23f7f7396bcf7dc089", "message": "Minor fixes", "committedDate": "2020-10-06T19:42:48Z", "type": "commit"}, {"oid": "8da02d29665be3376b4991f8fce8afaf5012fcc8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8da02d29665be3376b4991f8fce8afaf5012fcc8", "message": "Added setDelegate", "committedDate": "2020-10-06T19:54:27Z", "type": "commit"}, {"oid": "8bece1fc97b81c3926dddee0b6d702857f92f195", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bece1fc97b81c3926dddee0b6d702857f92f195", "message": "Added logging", "committedDate": "2020-10-07T15:19:08Z", "type": "commit"}, {"oid": "0c3e63f9b7aed69b0715c82fc92bfc11adbe9731", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0c3e63f9b7aed69b0715c82fc92bfc11adbe9731", "message": "Added more logging", "committedDate": "2020-10-08T14:49:14Z", "type": "commit"}, {"oid": "f0624cfffca6fc3dc78f8e6c301c55abceb1796d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f0624cfffca6fc3dc78f8e6c301c55abceb1796d", "message": "Added more logging", "committedDate": "2020-10-08T14:49:53Z", "type": "commit"}, {"oid": "8ec0bc7df4035f2a2e71a094d89e96d4e9e966b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ec0bc7df4035f2a2e71a094d89e96d4e9e966b9", "message": "Added configuration for Spring Cloud gateway", "committedDate": "2020-10-08T18:02:51Z", "type": "commit"}, {"oid": "8dbd7ace724ac5d5caec744d09f27d092cb33432", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8dbd7ace724ac5d5caec744d09f27d092cb33432", "message": "Added creating an Azure KeyVault section", "committedDate": "2020-10-08T18:58:48Z", "type": "commit"}, {"oid": "132ec369267fe682dd8e1e93801be79d60a74624", "url": "https://github.com/Azure/azure-sdk-for-java/commit/132ec369267fe682dd8e1e93801be79d60a74624", "message": "Add instructions to create a self-signed certificate", "committedDate": "2020-10-08T19:07:39Z", "type": "commit"}, {"oid": "bec1cf67b63b8220a3bfd9d652348f8b312e3e80", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bec1cf67b63b8220a3bfd9d652348f8b312e3e80", "message": "Add 'assign a managed identity'", "committedDate": "2020-10-08T19:18:26Z", "type": "commit"}, {"oid": "da1774b8199f067e025548b80e3fd2276886cde0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/da1774b8199f067e025548b80e3fd2276886cde0", "message": "Add instructions to grant a managed identity access to keyvault", "committedDate": "2020-10-08T19:29:33Z", "type": "commit"}, {"oid": "c89d604786124ea2879e8a3aa0b9acb4a5958fbc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c89d604786124ea2879e8a3aa0b9acb4a5958fbc", "message": "Add link to JCA provider", "committedDate": "2020-10-08T22:16:54Z", "type": "commit"}, {"oid": "f9d0dd5bf2640a87ba483452b4e36b5abbe86cf7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9d0dd5bf2640a87ba483452b4e36b5abbe86cf7", "message": "Added link to JCA reference guide", "committedDate": "2020-10-09T13:40:15Z", "type": "commit"}, {"oid": "61c8a1980e0257f294161bee33bd2e7a8473cc12", "url": "https://github.com/Azure/azure-sdk-for-java/commit/61c8a1980e0257f294161bee33bd2e7a8473cc12", "message": "Add link to our Spring Boot starter", "committedDate": "2020-10-09T14:28:48Z", "type": "commit"}, {"oid": "53316f374235c924674dfc94fd35f7a6ae31abf7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/53316f374235c924674dfc94fd35f7a6ae31abf7", "message": "Make sure server.ssl.key-store and server.ssl.trust-store are set automatically when applicable", "committedDate": "2020-10-09T14:50:22Z", "type": "commit"}, {"oid": "ea2eb042c90284240b08ef87e0103faf5df6d23f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea2eb042c90284240b08ef87e0103faf5df6d23f", "message": "Fix Spring Boot starter link", "committedDate": "2020-10-09T18:02:13Z", "type": "commit"}, {"oid": "fa393b1e2525b27252d978e1dbf31dea7cfd893e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fa393b1e2525b27252d978e1dbf31dea7cfd893e", "message": "Merge branch 'end-to-end-tls-ssl' of https://github.com/selvasingh/azure-sdk-for-java into end-to-end-tls-ssl", "committedDate": "2020-10-09T22:47:15Z", "type": "commit"}, {"oid": "716acd7f264d3e2e425a241ddaebeae7bc4a27cc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/716acd7f264d3e2e425a241ddaebeae7bc4a27cc", "message": "Reworked logging", "committedDate": "2020-10-13T15:54:06Z", "type": "commit"}, {"oid": "10e00108e663c0d552fca49e59671f72aa8271f8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/10e00108e663c0d552fca49e59671f72aa8271f8", "message": "Reworked logging", "committedDate": "2020-10-13T17:31:00Z", "type": "commit"}, {"oid": "736723184f7e4decd1fc25b913388ef6264fa42c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/736723184f7e4decd1fc25b913388ef6264fa42c", "message": "Added certificate side-loading", "committedDate": "2020-10-13T21:10:23Z", "type": "commit"}, {"oid": "809cc3466531692f6955d3d89f2bc3fb1892d2bf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/809cc3466531692f6955d3d89f2bc3fb1892d2bf", "message": "Add logging for side-loading", "committedDate": "2020-10-13T22:11:51Z", "type": "commit"}, {"oid": "8078ad456ec578264bbf81a1a6d3f4e80925fb0d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8078ad456ec578264bbf81a1a6d3f4e80925fb0d", "message": "Add logging for side-loading", "committedDate": "2020-10-13T22:12:27Z", "type": "commit"}, {"oid": "99b94da5cf85ffd29bf5d5cb4d94c976fc9758b0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/99b94da5cf85ffd29bf5d5cb4d94c976fc9758b0", "message": "Add README content for side-loading", "committedDate": "2020-10-14T14:54:23Z", "type": "commit"}, {"oid": "653933b8e01ef4265ce57a0939249668d3d17b22", "url": "https://github.com/Azure/azure-sdk-for-java/commit/653933b8e01ef4265ce57a0939249668d3d17b22", "message": "Add README content for side-loading", "committedDate": "2020-10-14T14:55:00Z", "type": "commit"}, {"oid": "d7f1606d509ea93217fd9251f1d8eaf06fef5991", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d7f1606d509ea93217fd9251f1d8eaf06fef5991", "message": "Add statement what to do when Spring Cloud Config server is in the mix", "committedDate": "2020-10-14T15:02:17Z", "type": "commit"}, {"oid": "fff173c1817341086e9296f32984cc1e4e339340", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fff173c1817341086e9296f32984cc1e4e339340", "message": "Add logging of KeyVault URI", "committedDate": "2020-10-14T15:47:22Z", "type": "commit"}, {"oid": "bbfdc10a9665cee9814efa222504ad4c4ccadf38", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bbfdc10a9665cee9814efa222504ad4c4ccadf38", "message": "Programmatically determine whether or not using Tomcat", "committedDate": "2020-10-14T17:04:20Z", "type": "commit"}, {"oid": "f8ee1b0c5e015e3267d162f199dfbb8ba8c8d7ef", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f8ee1b0c5e015e3267d162f199dfbb8ba8c8d7ef", "message": "Added KeyVault TrustManagerFactory", "committedDate": "2020-10-15T16:29:24Z", "type": "commit"}, {"oid": "ebccc65463839ce622cb27b6b88692469c1d6ccc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ebccc65463839ce622cb27b6b88692469c1d6ccc", "message": "Added KeyVault TrustManagerFactory", "committedDate": "2020-10-15T16:30:08Z", "type": "commit"}, {"oid": "4391b3ec64410ccddd74779dfc81d05d38b4fac5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4391b3ec64410ccddd74779dfc81d05d38b4fac5", "message": "Updated groupId", "committedDate": "2020-10-16T14:04:29Z", "type": "commit"}, {"oid": "afb7883fc4361dacd9645e215e73f6307c38af99", "url": "https://github.com/Azure/azure-sdk-for-java/commit/afb7883fc4361dacd9645e215e73f6307c38af99", "message": "Updated artificatId", "committedDate": "2020-10-16T14:12:05Z", "type": "commit"}, {"oid": "a96ae4dbbbc3066d8c96ea8f2e3fd403f684db55", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a96ae4dbbbc3066d8c96ea8f2e3fd403f684db55", "message": "Updated package names", "committedDate": "2020-10-16T14:59:16Z", "type": "commit"}, {"oid": "abbf13d267850b92ec9ac55b5deb780c86bc8ccf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/abbf13d267850b92ec9ac55b5deb780c86bc8ccf", "message": "Add KeyVault URI to Spring Cloud Gateway snippet", "committedDate": "2020-10-16T15:01:58Z", "type": "commit"}, {"oid": "73f25b2f5a45cc00b6173540e153fa6489c5e524", "url": "https://github.com/Azure/azure-sdk-for-java/commit/73f25b2f5a45cc00b6173540e153fa6489c5e524", "message": "Allow for disabling hostname verification", "committedDate": "2020-10-16T15:36:14Z", "type": "commit"}, {"oid": "4d9d1eeab3406126bafbcc78506968a4690b2b94", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4d9d1eeab3406126bafbcc78506968a4690b2b94", "message": "Change properties to include JCA 'namespace' in it", "committedDate": "2020-10-16T18:36:00Z", "type": "commit"}, {"oid": "0da1ecc9862afa4706d2549d6976d3a27a916827", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0da1ecc9862afa4706d2549d6976d3a27a916827", "message": "Add core principles", "committedDate": "2020-10-16T22:13:52Z", "type": "commit"}, {"oid": "414a7fbd0939e0efadbf2a12814784c10f1b44b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/414a7fbd0939e0efadbf2a12814784c10f1b44b3", "message": "Add core principles", "committedDate": "2020-10-16T22:17:39Z", "type": "commit"}, {"oid": "221f65589ca731572e20d82b8a28bbace277dfb4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/221f65589ca731572e20d82b8a28bbace277dfb4", "message": "Add core principles", "committedDate": "2020-10-16T22:19:49Z", "type": "commit"}, {"oid": "70bab18e1cb98e7b7fba897738c66b7b8d876316", "url": "https://github.com/Azure/azure-sdk-for-java/commit/70bab18e1cb98e7b7fba897738c66b7b8d876316", "message": "Minor renaming of project to reflect it is a JCA provider for Azure Key Vault", "committedDate": "2020-10-16T22:22:35Z", "type": "commit"}, {"oid": "026d3860ae20ddd1e11008994958f9eee1c4ca67", "url": "https://github.com/Azure/azure-sdk-for-java/commit/026d3860ae20ddd1e11008994958f9eee1c4ca67", "message": "No logic change, just format xml file.", "committedDate": "2020-10-19T02:42:41Z", "type": "commit"}, {"oid": "92fec34e2939b7cc91535926abaafde1cd007678", "url": "https://github.com/Azure/azure-sdk-for-java/commit/92fec34e2939b7cc91535926abaafde1cd007678", "message": "Fix error reported by pom_file_version_scanner.ps1.", "committedDate": "2020-10-19T02:49:20Z", "type": "commit"}, {"oid": "309bb8e0c16bae9f5af710dd1b61ee36fc817216", "url": "https://github.com/Azure/azure-sdk-for-java/commit/309bb8e0c16bae9f5af710dd1b61ee36fc817216", "message": "Format file in sdk/spring/azure-spring-boot-starter-keyvault-certificates.", "committedDate": "2020-10-19T02:54:51Z", "type": "commit"}, {"oid": "309af4f8590c4af6b226b7ec3f106f9f209e6815", "url": "https://github.com/Azure/azure-sdk-for-java/commit/309af4f8590c4af6b226b7ec3f106f9f209e6815", "message": "Format files in sdk/keyvault/azure-security-keyvault-jca.", "committedDate": "2020-10-19T02:58:21Z", "type": "commit"}, {"oid": "ecfe01d1a1da565478a23c2b26791c40b59395e1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ecfe01d1a1da565478a23c2b26791c40b59395e1", "message": "Format files in sdk/spring/azure-spring-boot-samples/azure-spring-boot-sample-keyvault-certificates.", "committedDate": "2020-10-19T03:00:01Z", "type": "commit"}, {"oid": "8653364c9cad4f6aa791aad7e35be049e2a30d48", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8653364c9cad4f6aa791aad7e35be049e2a30d48", "message": "Change groupId from com.azure.spring to com.azure.", "committedDate": "2020-10-19T03:08:06Z", "type": "commit"}, {"oid": "851ae2009ac021db319c479e7e83c7b53fdadef1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/851ae2009ac021db319c479e7e83c7b53fdadef1", "message": "Add new projects in to root pom modules.", "committedDate": "2020-10-19T05:10:51Z", "type": "commit"}, {"oid": "d52fe29e958e33ce2caba2bbbc9d6f94bf0d6d34", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d52fe29e958e33ce2caba2bbbc9d6f94bf0d6d34", "message": "Merge branch 'master' into end-to-end-tls-ssl", "committedDate": "2020-10-19T05:15:24Z", "type": "commit"}, {"oid": "5870ffebe39af980da2c5a838fb400c1c6283807", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5870ffebe39af980da2c5a838fb400c1c6283807", "message": "Update CHANGELOG.md and README.md.", "committedDate": "2020-10-19T05:24:36Z", "type": "commit"}, {"oid": "539e5df91c0003b48979ade0b328a987a438cfd4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/539e5df91c0003b48979ade0b328a987a438cfd4", "message": "Add version tag in azure-security-keyvault-jca\\pom.xml.", "committedDate": "2020-10-19T05:36:33Z", "type": "commit"}, {"oid": "dc057a08e09f65a821606d45673eb53ddea88a14", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dc057a08e09f65a821606d45673eb53ddea88a14", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T06:04:41Z", "type": "commit"}, {"oid": "274b2ed08b5ad881c1316b2c2893a5798b0b3d9d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/274b2ed08b5ad881c1316b2c2893a5798b0b3d9d", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T06:51:13Z", "type": "commit"}, {"oid": "4d6a973b6bdcc9c6030068ed47245ef37f53aaa4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4d6a973b6bdcc9c6030068ed47245ef37f53aaa4", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T07:05:22Z", "type": "commit"}, {"oid": "4f0dbadd0ac19c90191332f04154357deb48445a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4f0dbadd0ac19c90191332f04154357deb48445a", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T07:11:19Z", "type": "commit"}, {"oid": "67bdb82b6e1c35ebb0d6f8359444e552310913d4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/67bdb82b6e1c35ebb0d6f8359444e552310913d4", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T07:32:58Z", "type": "commit"}, {"oid": "bdd4047ed6747eb8bfb09cc20fe4fd416a7e3d90", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bdd4047ed6747eb8bfb09cc20fe4fd416a7e3d90", "message": "Delete unused files.", "committedDate": "2020-10-19T07:38:13Z", "type": "commit"}, {"oid": "6867d33121ae8521811d5e081af1ce892e10f98b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6867d33121ae8521811d5e081af1ce892e10f98b", "message": "No logic change.", "committedDate": "2020-10-19T07:42:19Z", "type": "commit"}, {"oid": "8a2ab04a2ae4432597ed21e459610498456b0078", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8a2ab04a2ae4432597ed21e459610498456b0078", "message": "Update release version and current version of 'azure-spring-boot-starter-keyvault-certificates'.", "committedDate": "2020-10-19T07:46:06Z", "type": "commit"}, {"oid": "3f8c15216655c55fa1f62f70fb7d1765c93e4d9a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3f8c15216655c55fa1f62f70fb7d1765c93e4d9a", "message": "Update README.md.", "committedDate": "2020-10-19T07:52:43Z", "type": "commit"}, {"oid": "74306ece6b01047ec828e3d51307a5751e7d2085", "url": "https://github.com/Azure/azure-sdk-for-java/commit/74306ece6b01047ec828e3d51307a5751e7d2085", "message": "1. Set azure-security-keyvault-jca's version to 1.0.0-beta.1.\n2. Set parent for azure-spring-boot-starter-keyvault-certificates.", "committedDate": "2020-10-19T08:04:58Z", "type": "commit"}, {"oid": "039d92ca5049fb1bd017bd49c05a8500febac1ae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/039d92ca5049fb1bd017bd49c05a8500febac1ae", "message": "No logic change.", "committedDate": "2020-10-19T08:19:20Z", "type": "commit"}, {"oid": "4c3a3a758fef1e3ed30aeb8ef03c4c30f5caf775", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4c3a3a758fef1e3ed30aeb8ef03c4c30f5caf775", "message": "Change azure-spring-boot-sample-keyvault-certificates's groupId to com.azure.spring.", "committedDate": "2020-10-19T08:27:59Z", "type": "commit"}, {"oid": "eee1baf9fa320e0be8a446f34b243bc04a07b959", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eee1baf9fa320e0be8a446f34b243bc04a07b959", "message": "Skip maven-surefire-plugin by default.", "committedDate": "2020-10-19T09:10:57Z", "type": "commit"}, {"oid": "f1568c2d0d1f1daf05d335f08386247045fef5c0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f1568c2d0d1f1daf05d335f08386247045fef5c0", "message": "Change azure-spring-boot-starter-keyvault-certificates's version to 3.0.0-beta.1.", "committedDate": "2020-10-19T09:20:59Z", "type": "commit"}, {"oid": "625c50f879815abbdfca356acd5201ec9f1816df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/625c50f879815abbdfca356acd5201ec9f1816df", "message": "Fix groupId error about httpclient5.", "committedDate": "2020-10-19T09:23:05Z", "type": "commit"}, {"oid": "5c90b80bd17690bf00c0e525497bdb47ad3d3914", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5c90b80bd17690bf00c0e525497bdb47ad3d3914", "message": "Changes to accomodate X509ExtendedTrustManager", "committedDate": "2020-10-19T15:35:09Z", "type": "commit"}, {"oid": "767c6624aaae2225c21c14e1eae3ef80174a9e4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/767c6624aaae2225c21c14e1eae3ef80174a9e4b", "message": "Restore Dockerfile", "committedDate": "2020-10-19T18:24:50Z", "type": "commit"}, {"oid": "ee6952d0682aab298dc39603928769585cc12f8f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ee6952d0682aab298dc39603928769585cc12f8f", "message": "Comment out links for now", "committedDate": "2020-10-19T18:37:14Z", "type": "commit"}, {"oid": "30df750f99d01ac9f452da23d91c052f25ce5973", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30df750f99d01ac9f452da23d91c052f25ce5973", "message": "Add package-info for the starter", "committedDate": "2020-10-19T19:07:43Z", "type": "commit"}, {"oid": "41ada7f7d7262c81206d610096e4099dc3e41f6f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/41ada7f7d7262c81206d610096e4099dc3e41f6f", "message": "Add parent POMs back to see what else fails", "committedDate": "2020-10-19T19:37:06Z", "type": "commit"}, {"oid": "5198b86c28c4cbc2c64bdef453a93cc5f56b4816", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5198b86c28c4cbc2c64bdef453a93cc5f56b4816", "message": "Updates for pipeline", "committedDate": "2020-10-19T20:11:54Z", "type": "commit"}, {"oid": "2438787c2456ffc5906e4b9378aa75bd55a64bbb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2438787c2456ffc5906e4b9378aa75bd55a64bbb", "message": "Updates for pipeline", "committedDate": "2020-10-19T20:23:08Z", "type": "commit"}, {"oid": "5dc3b16b885c130e6b098e492116f9b9d6674484", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5dc3b16b885c130e6b098e492116f9b9d6674484", "message": "Allow for given dependencies", "committedDate": "2020-10-19T20:39:12Z", "type": "commit"}, {"oid": "da408a1c2c78fb9667a814e30a9885c2e51648ce", "url": "https://github.com/Azure/azure-sdk-for-java/commit/da408a1c2c78fb9667a814e30a9885c2e51648ce", "message": "Make build pass", "committedDate": "2020-10-19T20:56:33Z", "type": "commit"}, {"oid": "df48b766baea0d99551b1d5e5ff4c5e06a028239", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df48b766baea0d99551b1d5e5ff4c5e06a028239", "message": "Make build pass", "committedDate": "2020-10-19T21:00:05Z", "type": "commit"}, {"oid": "51e9ada11f3d681fcab735668287190d97f9f6ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51e9ada11f3d681fcab735668287190d97f9f6ab", "message": "Make build pass", "committedDate": "2020-10-19T21:11:20Z", "type": "commit"}, {"oid": "966ba73d5e3e451611fc8a349295115855a93789", "url": "https://github.com/Azure/azure-sdk-for-java/commit/966ba73d5e3e451611fc8a349295115855a93789", "message": "Make build pass", "committedDate": "2020-10-19T21:31:04Z", "type": "commit"}, {"oid": "75e41868e86a84b401914d778e6c54e8c6d19c29", "url": "https://github.com/Azure/azure-sdk-for-java/commit/75e41868e86a84b401914d778e6c54e8c6d19c29", "message": "Make build pass", "committedDate": "2020-10-19T21:39:41Z", "type": "commit"}, {"oid": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/22916a83b3adf58ca85e43fac5dabb01b489e1d2", "message": "Make build pass", "committedDate": "2020-10-19T21:48:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0Nzk3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508147974", "bodyText": "It appears as if this dependency is being used in a shaded fashion, alongside other libraries. I would be happier if we didn't need these dependencies at all though. From a quick look through the code it doesn't appear to be baked in deeply, mainly showing up it seems in the LegacyRestClient.", "author": "JonathanGiles", "createdAt": "2020-10-20T01:04:48Z", "path": "eng/versioning/external_dependencies.txt", "diffHunk": "@@ -63,6 +63,7 @@ org.apache.avro:avro-maven-plugin;1.9.2\n org.apache.commons:commons-compress;1.20\n org.apache.commons:commons-lang3;3.10\n org.apache.httpcomponents:httpclient;4.5.12\n+org.apache.httpcomponents.client5:httpclient5;5.0.1", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2Mzc2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508163766", "bodyText": "The dependencies of the JCA provider are shaded to make sure the provider is self-contained and can be used in any Java application", "author": "mnriem", "createdAt": "2020-10-20T02:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0Nzk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE3NjM2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508176365", "bodyText": "Yep, understood. My comment was mainly focused on whether the httpclient is necessary in the first place? It doesn't appear to be from a cursory glance.", "author": "JonathanGiles", "createdAt": "2020-10-20T02:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0Nzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0ODMxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508148313", "bodyText": "Does this link need to be set to go somewhere?", "author": "JonathanGiles", "createdAt": "2020-10-20T01:05:55Z", "path": "sdk/keyvault/azure-security-keyvault-jca/README.md", "diffHunk": "@@ -0,0 +1,127 @@\n+# JCA Provider for Azure Key Vault\n+\n+The JCA Provider for Azure Key Vault is a JCA provider for certificates in \n+Azure Key Vault. It is built on four principles:\n+ \n+1. Must be extremely thin to run within a JVM\n+1. Must not introduce any library version conflicts with Java app code dependencies\n+1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies\n+1. Must be ready for \"never trust, always verify and credential-free\" Zero Trust environments.\n+\n+## Testing the version under development\n+\n+If you want to test the current version under development you will have to\n+build and install it into your local Maven repository. To do so use the \n+following command line:\n+\n+```\n+  mvn clean install -DskipTests=true\n+```\n+\n+## Server side SSL\n+\n+If you are looking to integrate the JCA provider to create a SSLServerSocket\n+see the example below.\n+\n+```java\n+    KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+    Security.addProvider(provider);\n+\n+    KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+    KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+        System.getProperty(\"azure.keyvault.uri\"), \n+        System.getProperty(\"azure.tenant.id\"), \n+        System.getProperty(\"azure.client.id\"),\n+        System.getProperty(\"azure.client.secret\"));\n+    ks.load(parameter);\n+\n+    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+    kmf.init(ks, \"\".toCharArray());\n+\n+    SSLContext context = SSLContext.getInstance(\"TLS\");\n+    context.init(kmf.getKeyManagers(), null, null);\n+\n+    SSLServerSocketFactory factory = (SSLServerSocketFactory) context.getServerSocketFactory();\n+    SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(8765);\n+```\n+\n+Note if you want to use Azure managed identity, you should set the value\n+of `azure.keyvault.uri`, and the rest of the parameters would be `null`.\n+\n+## Client side SSL\n+\n+If you are looking to integrate the JCA provider for client side socket \n+connections, see the Apache HTTP client example below.\n+\n+```java\n+    KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+    Security.addProvider(provider);\n+\n+    KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+    KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"), \n+            System.getProperty(\"azure.tenant.id\"), \n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+    ks.load(parameter);\n+\n+    SSLContext sslContext = SSLContexts\n+            .custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+    SSLConnectionSocketFactory sslSocketFactory = SSLConnectionSocketFactoryBuilder\n+            .create()\n+            .setSslContext(sslContext)\n+            .setHostnameVerifier((hostname, session) -> {\n+                return true;\n+            })\n+            .build();\n+\n+    PoolingHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder\n+            .create()\n+            .setSSLSocketFactory(sslSocketFactory)\n+            .build();\n+\n+    String result = null;\n+\n+    try ( CloseableHttpClient client = HttpClients.custom().setConnectionManager(cm).build()) {\n+        HttpGet httpGet = new HttpGet(\"https://localhost:8766\");\n+        HttpClientResponseHandler<String> responseHandler = (ClassicHttpResponse response) -> {\n+            int status = response.getCode();\n+            String result1 = \"Not success\";\n+            if (status == 204) {\n+                result1 = \"Success\";\n+            }\n+            return result1;\n+        };\n+        result = client.execute(httpGet, responseHandler);\n+    } catch (IOException ioe) {\n+        ioe.printStackTrace();\n+    }\n+```\n+\n+Note if you want to use Azure managed identity, you should set the value\n+of `azure.keyvault.uri`, and the rest of the parameters would be `null`.\n+\n+## Spring Boot\n+\n+For Spring Boot applications see our [Spring Boot starter]<!--(../../spring/azure-spring-boot-starter-keyvault-certificates/README.md)-->.", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2MzkwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508163901", "bodyText": "This will be fixed in a subsequent PR as it is referring to a location that is currently not published", "author": "mnriem", "createdAt": "2020-10-20T02:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0ODMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0Njg0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510346841", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T17:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0ODMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTE0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508149140", "bodyText": "I'm not sure what this is - can you please clarify?", "author": "JonathanGiles", "createdAt": "2020-10-20T01:09:00Z", "path": "sdk/keyvault/azure-security-keyvault-jca/pom.xml", "diffHunk": "@@ -0,0 +1,232 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>azure-client-sdk-parent</artifactId>\n+        <groupId>com.azure</groupId>\n+        <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+        <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+    </parent>\n+\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-security-keyvault-jca</artifactId>\n+    <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-security-keyvault-jca;current} -->\n+    <name>JCA Provider for Azure Key Vault</name>\n+    <description>The Java Crypto Architecture (JCA) Provider for Azure KeyVault</description>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <version>3.8.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-compiler-plugin;external_dependency} -->\n+                <configuration>\n+                    <source>1.8</source>\n+                    <target>1.8</target>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-resources-plugin</artifactId>\n+                <version>2.4.3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-resources-plugin;external_dependency} -->\n+                <configuration>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-shade-plugin</artifactId>\n+                <version>3.2.4</version> <!-- {x-version-update;org.apache.maven.plugins:maven-shade-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>shade</goal>\n+                        </goals>\n+                        <configuration>\n+                            <relocations>\n+                                <relocation>\n+                                    <pattern>com.fasterxml.jackson</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.com.fasterxml.jackson</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.commons</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.commons</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.hc</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.hc</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>mozilla</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.mozilla</shadedPattern>\n+                                </relocation>", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2NDA2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508164067", "bodyText": "This package is part of one of the dependencies of the JCA provider and is shaded and relocated", "author": "mnriem", "createdAt": "2020-10-20T02:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTM3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508149377", "bodyText": "Not a huge fan of allowing this dependency - would love to see this removed if at all possible.", "author": "JonathanGiles", "createdAt": "2020-10-20T01:09:52Z", "path": "sdk/keyvault/azure-security-keyvault-jca/pom.xml", "diffHunk": "@@ -0,0 +1,232 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>azure-client-sdk-parent</artifactId>\n+        <groupId>com.azure</groupId>\n+        <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+        <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+    </parent>\n+\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-security-keyvault-jca</artifactId>\n+    <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-security-keyvault-jca;current} -->\n+    <name>JCA Provider for Azure Key Vault</name>\n+    <description>The Java Crypto Architecture (JCA) Provider for Azure KeyVault</description>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <version>3.8.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-compiler-plugin;external_dependency} -->\n+                <configuration>\n+                    <source>1.8</source>\n+                    <target>1.8</target>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-resources-plugin</artifactId>\n+                <version>2.4.3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-resources-plugin;external_dependency} -->\n+                <configuration>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-shade-plugin</artifactId>\n+                <version>3.2.4</version> <!-- {x-version-update;org.apache.maven.plugins:maven-shade-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>shade</goal>\n+                        </goals>\n+                        <configuration>\n+                            <relocations>\n+                                <relocation>\n+                                    <pattern>com.fasterxml.jackson</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.com.fasterxml.jackson</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.commons</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.commons</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.hc</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.hc</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>mozilla</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.mozilla</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.slf4j</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.slf4j</shadedPattern>\n+                                </relocation>\n+                            </relocations>\n+                            <transformers>\n+                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"/>\n+                            </transformers>\n+                            <createSourcesJar>true</createSourcesJar>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-surefire-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.jacoco</groupId>\n+                <artifactId>jacoco-maven-plugin</artifactId>\n+                <version>0.8.5</version> <!-- {x-version-update;org.jacoco:jacoco-maven-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <id>default-prepare-agent</id>\n+                        <goals>\n+                            <goal>prepare-agent</goal>\n+                        </goals>\n+                    </execution>\n+                    <execution>\n+                        <id>default-report</id>\n+                        <phase>prepare-package</phase>\n+                        <goals>\n+                            <goal>report</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-enforcer-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-enforcer-plugin;external_dependency} -->\n+                <configuration>\n+                    <rules>\n+                        <bannedDependencies>\n+                            <includes>\n+                                <include>org.apache.httpcomponents.client5:httpclient5:[5.0.1]</include> <!-- {x-include-update;org.apache.httpcomponents.client5:httpclient5;external_dependency} -->", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTQ4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508149489", "bodyText": "Don't skip this check.", "author": "JonathanGiles", "createdAt": "2020-10-20T01:10:16Z", "path": "sdk/keyvault/azure-security-keyvault-jca/pom.xml", "diffHunk": "@@ -0,0 +1,232 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>azure-client-sdk-parent</artifactId>\n+        <groupId>com.azure</groupId>\n+        <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+        <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+    </parent>\n+\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-security-keyvault-jca</artifactId>\n+    <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-security-keyvault-jca;current} -->\n+    <name>JCA Provider for Azure Key Vault</name>\n+    <description>The Java Crypto Architecture (JCA) Provider for Azure KeyVault</description>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <version>3.8.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-compiler-plugin;external_dependency} -->\n+                <configuration>\n+                    <source>1.8</source>\n+                    <target>1.8</target>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-resources-plugin</artifactId>\n+                <version>2.4.3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-resources-plugin;external_dependency} -->\n+                <configuration>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-shade-plugin</artifactId>\n+                <version>3.2.4</version> <!-- {x-version-update;org.apache.maven.plugins:maven-shade-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>shade</goal>\n+                        </goals>\n+                        <configuration>\n+                            <relocations>\n+                                <relocation>\n+                                    <pattern>com.fasterxml.jackson</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.com.fasterxml.jackson</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.commons</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.commons</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.hc</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.hc</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>mozilla</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.mozilla</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.slf4j</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.slf4j</shadedPattern>\n+                                </relocation>\n+                            </relocations>\n+                            <transformers>\n+                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"/>\n+                            </transformers>\n+                            <createSourcesJar>true</createSourcesJar>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-surefire-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.jacoco</groupId>\n+                <artifactId>jacoco-maven-plugin</artifactId>\n+                <version>0.8.5</version> <!-- {x-version-update;org.jacoco:jacoco-maven-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <id>default-prepare-agent</id>\n+                        <goals>\n+                            <goal>prepare-agent</goal>\n+                        </goals>\n+                    </execution>\n+                    <execution>\n+                        <id>default-report</id>\n+                        <phase>prepare-package</phase>\n+                        <goals>\n+                            <goal>report</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-enforcer-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-enforcer-plugin;external_dependency} -->\n+                <configuration>\n+                    <rules>\n+                        <bannedDependencies>\n+                            <includes>\n+                                <include>org.apache.httpcomponents.client5:httpclient5:[5.0.1]</include> <!-- {x-include-update;org.apache.httpcomponents.client5:httpclient5;external_dependency} -->\n+                                <include>com.fasterxml.jackson.core:jackson-databind:[2.11.2]</include> <!-- {x-include-update;com.fasterxml.jackson.core:jackson-databind;external_dependency} -->\n+                                <include>org.slf4j:slf4j-nop:[1.7.30]</include> <!-- {x-include-update;org.slf4j:slf4j-nop;external_dependency} -->\n+                            </includes>\n+                        </bannedDependencies>\n+                    </rules>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-checkstyle-plugin</artifactId>\n+                <version>3.1.0</version> <!-- {x-version-update;org.apache.maven.plugins:maven-checkstyle-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTUwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508149509", "bodyText": "Don't skip this check.", "author": "JonathanGiles", "createdAt": "2020-10-20T01:10:21Z", "path": "sdk/keyvault/azure-security-keyvault-jca/pom.xml", "diffHunk": "@@ -0,0 +1,232 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>azure-client-sdk-parent</artifactId>\n+        <groupId>com.azure</groupId>\n+        <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+        <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+    </parent>\n+\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-security-keyvault-jca</artifactId>\n+    <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-security-keyvault-jca;current} -->\n+    <name>JCA Provider for Azure Key Vault</name>\n+    <description>The Java Crypto Architecture (JCA) Provider for Azure KeyVault</description>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <version>3.8.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-compiler-plugin;external_dependency} -->\n+                <configuration>\n+                    <source>1.8</source>\n+                    <target>1.8</target>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-resources-plugin</artifactId>\n+                <version>2.4.3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-resources-plugin;external_dependency} -->\n+                <configuration>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-shade-plugin</artifactId>\n+                <version>3.2.4</version> <!-- {x-version-update;org.apache.maven.plugins:maven-shade-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>shade</goal>\n+                        </goals>\n+                        <configuration>\n+                            <relocations>\n+                                <relocation>\n+                                    <pattern>com.fasterxml.jackson</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.com.fasterxml.jackson</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.commons</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.commons</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.hc</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.hc</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>mozilla</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.mozilla</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.slf4j</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.slf4j</shadedPattern>\n+                                </relocation>\n+                            </relocations>\n+                            <transformers>\n+                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"/>\n+                            </transformers>\n+                            <createSourcesJar>true</createSourcesJar>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-surefire-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.jacoco</groupId>\n+                <artifactId>jacoco-maven-plugin</artifactId>\n+                <version>0.8.5</version> <!-- {x-version-update;org.jacoco:jacoco-maven-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <id>default-prepare-agent</id>\n+                        <goals>\n+                            <goal>prepare-agent</goal>\n+                        </goals>\n+                    </execution>\n+                    <execution>\n+                        <id>default-report</id>\n+                        <phase>prepare-package</phase>\n+                        <goals>\n+                            <goal>report</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-enforcer-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-enforcer-plugin;external_dependency} -->\n+                <configuration>\n+                    <rules>\n+                        <bannedDependencies>\n+                            <includes>\n+                                <include>org.apache.httpcomponents.client5:httpclient5:[5.0.1]</include> <!-- {x-include-update;org.apache.httpcomponents.client5:httpclient5;external_dependency} -->\n+                                <include>com.fasterxml.jackson.core:jackson-databind:[2.11.2]</include> <!-- {x-include-update;com.fasterxml.jackson.core:jackson-databind;external_dependency} -->\n+                                <include>org.slf4j:slf4j-nop:[1.7.30]</include> <!-- {x-include-update;org.slf4j:slf4j-nop;external_dependency} -->\n+                            </includes>\n+                        </bannedDependencies>\n+                    </rules>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-checkstyle-plugin</artifactId>\n+                <version>3.1.0</version> <!-- {x-version-update;org.apache.maven.plugins:maven-checkstyle-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>com.github.spotbugs</groupId>\n+                <artifactId>spotbugs-maven-plugin</artifactId>\n+                <version>3.1.12.2</version> <!-- {x-version-update;com.github.spotbugs:spotbugs-maven-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTU0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508149541", "bodyText": "Don't skip this check.", "author": "JonathanGiles", "createdAt": "2020-10-20T01:10:26Z", "path": "sdk/keyvault/azure-security-keyvault-jca/pom.xml", "diffHunk": "@@ -0,0 +1,232 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>azure-client-sdk-parent</artifactId>\n+        <groupId>com.azure</groupId>\n+        <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+        <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+    </parent>\n+\n+    <groupId>com.azure</groupId>\n+    <artifactId>azure-security-keyvault-jca</artifactId>\n+    <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-security-keyvault-jca;current} -->\n+    <name>JCA Provider for Azure Key Vault</name>\n+    <description>The Java Crypto Architecture (JCA) Provider for Azure KeyVault</description>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <version>3.8.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-compiler-plugin;external_dependency} -->\n+                <configuration>\n+                    <source>1.8</source>\n+                    <target>1.8</target>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-resources-plugin</artifactId>\n+                <version>2.4.3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-resources-plugin;external_dependency} -->\n+                <configuration>\n+                    <encoding>${project.build.sourceEncoding}</encoding>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-shade-plugin</artifactId>\n+                <version>3.2.4</version> <!-- {x-version-update;org.apache.maven.plugins:maven-shade-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>shade</goal>\n+                        </goals>\n+                        <configuration>\n+                            <relocations>\n+                                <relocation>\n+                                    <pattern>com.fasterxml.jackson</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.com.fasterxml.jackson</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.commons</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.commons</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.hc</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.apache.hc</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>mozilla</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.mozilla</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.slf4j</pattern>\n+                                    <shadedPattern>com.azure.keyvault.jca.org.slf4j</shadedPattern>\n+                                </relocation>\n+                            </relocations>\n+                            <transformers>\n+                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"/>\n+                            </transformers>\n+                            <createSourcesJar>true</createSourcesJar>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-surefire-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.jacoco</groupId>\n+                <artifactId>jacoco-maven-plugin</artifactId>\n+                <version>0.8.5</version> <!-- {x-version-update;org.jacoco:jacoco-maven-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <id>default-prepare-agent</id>\n+                        <goals>\n+                            <goal>prepare-agent</goal>\n+                        </goals>\n+                    </execution>\n+                    <execution>\n+                        <id>default-report</id>\n+                        <phase>prepare-package</phase>\n+                        <goals>\n+                            <goal>report</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-enforcer-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-enforcer-plugin;external_dependency} -->\n+                <configuration>\n+                    <rules>\n+                        <bannedDependencies>\n+                            <includes>\n+                                <include>org.apache.httpcomponents.client5:httpclient5:[5.0.1]</include> <!-- {x-include-update;org.apache.httpcomponents.client5:httpclient5;external_dependency} -->\n+                                <include>com.fasterxml.jackson.core:jackson-databind:[2.11.2]</include> <!-- {x-include-update;com.fasterxml.jackson.core:jackson-databind;external_dependency} -->\n+                                <include>org.slf4j:slf4j-nop:[1.7.30]</include> <!-- {x-include-update;org.slf4j:slf4j-nop;external_dependency} -->\n+                            </includes>\n+                        </bannedDependencies>\n+                    </rules>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-checkstyle-plugin</artifactId>\n+                <version>3.1.0</version> <!-- {x-version-update;org.apache.maven.plugins:maven-checkstyle-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>com.github.spotbugs</groupId>\n+                <artifactId>spotbugs-maven-plugin</artifactId>\n+                <version>3.1.12.2</version> <!-- {x-version-update;com.github.spotbugs:spotbugs-maven-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.revapi</groupId>\n+                <artifactId>revapi-maven-plugin</artifactId>\n+                <version>0.11.2</version> <!-- {x-version-update;org.revapi:revapi-maven-plugin;external_dependency} -->\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTgxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508149816", "bodyText": "We don't include author tags in our JavaDoc.", "author": "JonathanGiles", "createdAt": "2020-10-20T01:11:24Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,184 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2NDIyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508164223", "bodyText": "I will address this", "author": "mnriem", "createdAt": "2020-10-20T02:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MDQwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508150401", "bodyText": "It looks like elsewhere you have a dependency on slf4j - it would be good to standardise on that (which is also what the azure SDKs have standardised on).", "author": "JonathanGiles", "createdAt": "2020-10-20T01:13:36Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,184 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2NDg2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508164869", "bodyText": "As the JAR is self-contained it is not relying on SLF4J for its logging. Even though Jackson is pulling it in as a dependency it is not used for logging by the JCA provider itself.", "author": "mnriem", "createdAt": "2020-10-20T02:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MDQwMQ=="}], "type": "inlineReview"}, {"oid": "ea0d71be65833cabbe6aabb96f5a4988d30c3ada", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea0d71be65833cabbe6aabb96f5a4988d30c3ada", "message": "Add 2 new artifact into ci.yml.", "committedDate": "2020-10-20T02:32:41Z", "type": "commit"}, {"oid": "01a56131b1edde280cd7ec6ea9aa6ee8ab4db60f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/01a56131b1edde280cd7ec6ea9aa6ee8ab4db60f", "message": "Fix error in pipeline.", "committedDate": "2020-10-20T02:42:26Z", "type": "commit"}, {"oid": "59b9585bd9ca4de1246d417961916376e3bf226f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/59b9585bd9ca4de1246d417961916376e3bf226f", "message": "Removed @author", "committedDate": "2020-10-20T12:26:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgwNzI4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508807286", "bodyText": "Is this intended to work against clouds other than Azure Public Cloud? If so this would need to be configurable.", "author": "schaabs", "createdAt": "2020-10-20T20:09:39Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMzAxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508813017", "bodyText": "Certificates downloaded from Key Vault through the get secret API might be in PKCS12 or PEM format. These can be differentiated by the by the contentType of the secret bundle.", "author": "schaabs", "createdAt": "2020-10-20T20:20:29Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;\n+\n+    /**\n+     * Stores the tenant ID.\n+     */\n+    private String tenantId;\n+\n+    /**\n+     * Stores the client ID.\n+     */\n+    private String clientId;\n+\n+    /**\n+     * Stores the client secret.\n+     */\n+    private String clientSecret;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     */\n+    KeyVaultClient(String keyVaultUri) {\n+        super(RestClientFactory.createClient());\n+        LOGGER.log(INFO, \"Using KeyVault: {0}\", keyVaultUri);\n+        if (!keyVaultUri.endsWith(\"/\")) {\n+            keyVaultUri = keyVaultUri + \"/\";\n+        }\n+        this.keyVaultUri = keyVaultUri;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     */\n+    KeyVaultClient(final String keyVaultUri, final String tenantId, final String clientId, final String clientSecret) {\n+        this(keyVaultUri);\n+        this.tenantId = tenantId;\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    private String getAccessToken() {\n+        LOGGER.entering(\"KeyVaultClient\", \"getAccessToken\");\n+        String accessToken = null;\n+        try {\n+            AuthClient authClient = new AuthClient();\n+            String resource = URLEncoder.encode(\"https://vault.azure.net\", \"UTF-8\");\n+            if (tenantId != null && clientId != null && clientSecret != null) {\n+                accessToken = authClient.getAccessToken(resource, tenantId, clientId, clientSecret);\n+            } else {\n+                accessToken = authClient.getAccessToken(resource);\n+            }\n+        } catch (UnsupportedEncodingException uee) {\n+            LOGGER.log(WARNING, \"Unsupported encoding\", uee);\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getAccessToken\", accessToken);\n+        return accessToken;\n+    }\n+\n+    /**\n+     * Get the list of aliases.\n+     *\n+     * @return the list of aliases.\n+     */\n+    public List<String> getAliases() {\n+        ArrayList<String> result = new ArrayList<>();\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates%s\", keyVaultUri, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        CertificateListResult certificateListResult = null;\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            certificateListResult = (CertificateListResult) converter.fromJson(response, CertificateListResult.class);\n+        }\n+        if (certificateListResult != null && certificateListResult.getValue().size() > 0) {\n+            for (CertificateItem certificateItem : certificateListResult.getValue()) {\n+                String id = certificateItem.getId();\n+                String alias = id.substring(id.indexOf(\"certificates\") + \"certificates\".length() + 1);\n+                result.add(alias);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate bundle.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate bundle.\n+     */\n+    private CertificateBundle getCertificateBundle(String alias) {\n+        CertificateBundle result = null;\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates/%s%s\", keyVaultUri, alias, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            result = (CertificateBundle) converter.fromJson(response, CertificateBundle.class);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate, or null if not found.\n+     */\n+    public Certificate getCertificate(String alias) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getCertificate\", alias);\n+        LOGGER.log(INFO, \"Getting certificate for alias: {0}\", alias);\n+        X509Certificate certificate = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        if (certificateBundle != null) {\n+            String certificateString = certificateBundle.getCer();\n+            if (certificateString != null) {\n+                try {\n+                    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                    certificate = (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(Base64.getDecoder().decode(certificateBundle.getCer()))\n+                    );\n+                } catch (CertificateException ce) {\n+                    LOGGER.log(WARNING, \"Certificate error\", ce);\n+                }\n+            }\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getCertificate\", certificate);\n+        return certificate;\n+    }\n+\n+    /**\n+     * Get the key.\n+     *\n+     * @param alias the alias.\n+     * @param password the password.\n+     * @return the key.\n+     */\n+    public Key getKey(String alias, char[] password) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getKey\", new Object[] { alias, password });\n+        LOGGER.log(INFO, \"Getting key for alias: {0}\", alias);\n+        Key key = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        boolean isExportable = Optional.ofNullable(certificateBundle)\n+                                       .map(CertificateBundle::getPolicy)\n+                                       .map(CertificatePolicy::getKey_props)\n+                                       .map(KeyProperties::isExportable)\n+                                       .orElse(false);\n+        if (isExportable) {\n+            // Because the certificate is exportable the private key is\n+            // available. So we'll use the KeyVault Secrets API to get the \n+            // private key.\n+            String certificateSecretUri = certificateBundle.getSid();\n+            HashMap<String, String> headers = new HashMap<>();\n+            headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+            String body = get(certificateSecretUri + API_VERSION_POSTFIX, headers);\n+            if (body != null) {\n+                JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+                SecretBundle secretBundle = (SecretBundle) converter.fromJson(body, SecretBundle.class);\n+                try {\n+                    KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508818162", "bodyText": "I believe the resource string will need to be url encoded no?", "author": "schaabs", "createdAt": "2020-10-20T20:28:13Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")\n+           .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Metadata\", \"true\");\n+        headers.put(\"Secret\", System.getenv(\"MSI_SECRET\"));\n+        String body = get(url.toString(), headers);\n+\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.exiting(\"AuthClient\", \"getAccessTokenOnAppService\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the authorization token on everything else but Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnOthers(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnOthers\", resource);\n+        LOGGER.info(\"Getting access token using managed identity\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(OAUTH2_MANAGED_IDENTITY_TOKEN_URL)\n+           .append(RESOURCE_FRAGMENT).append(resource);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NDM2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510384363", "bodyText": "The KeyVaultClient code passes in a url encoded version so nothing further needs to be done", "author": "mnriem", "createdAt": "2020-10-22T18:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODQ4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508818484", "bodyText": "I believe the resource string will need to be url encoded no?", "author": "schaabs", "createdAt": "2020-10-20T20:28:52Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")\n+           .append(RESOURCE_FRAGMENT).append(resource);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MjQwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510392406", "bodyText": "The KeyVaultClient code passes in a url encoded version so nothing further needs to be done", "author": "mnriem", "createdAt": "2020-10-22T19:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyNjA2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508726065", "bodyText": "Just remember to add the changelog notes here before releasing :)", "author": "vcolin7", "createdAt": "2020-10-20T17:54:15Z", "path": "sdk/keyvault/azure-security-keyvault-jca/CHANGELOG.md", "diffHunk": "@@ -0,0 +1,4 @@\n+# Release History\n+\n+## 1.0.0-beta.1 (Unreleased)", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMzgxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510403814", "bodyText": "It is there ;)", "author": "mnriem", "createdAt": "2020-10-22T19:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyNjA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyNjYwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508726606", "bodyText": "nit;\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. Must be extremely thin to run within a JVM\n          \n          \n            \n            1. Must not introduce any library version conflicts with Java app code dependencies\n          \n          \n            \n            1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies\n          \n          \n            \n            1. Must be extremely thin to run within a JVM.\n          \n          \n            \n            1. Must not introduce any library version conflicts with Java app code dependencies.\n          \n          \n            \n            1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies.", "author": "vcolin7", "createdAt": "2020-10-20T17:54:58Z", "path": "sdk/keyvault/azure-security-keyvault-jca/README.md", "diffHunk": "@@ -0,0 +1,127 @@\n+# JCA Provider for Azure Key Vault\n+\n+The JCA Provider for Azure Key Vault is a JCA provider for certificates in \n+Azure Key Vault. It is built on four principles:\n+ \n+1. Must be extremely thin to run within a JVM\n+1. Must not introduce any library version conflicts with Java app code dependencies\n+1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0MzMzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510143333", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyNjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyNzExNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508727115", "bodyText": "nit;\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you are looking to integrate the JCA provider to create a SSLServerSocket\n          \n          \n            \n            If you are looking to integrate the JCA provider to create an SSLServerSocket", "author": "vcolin7", "createdAt": "2020-10-20T17:55:41Z", "path": "sdk/keyvault/azure-security-keyvault-jca/README.md", "diffHunk": "@@ -0,0 +1,127 @@\n+# JCA Provider for Azure Key Vault\n+\n+The JCA Provider for Azure Key Vault is a JCA provider for certificates in \n+Azure Key Vault. It is built on four principles:\n+ \n+1. Must be extremely thin to run within a JVM\n+1. Must not introduce any library version conflicts with Java app code dependencies\n+1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies\n+1. Must be ready for \"never trust, always verify and credential-free\" Zero Trust environments.\n+\n+## Testing the version under development\n+\n+If you want to test the current version under development you will have to\n+build and install it into your local Maven repository. To do so use the \n+following command line:\n+\n+```\n+  mvn clean install -DskipTests=true\n+```\n+\n+## Server side SSL\n+\n+If you are looking to integrate the JCA provider to create a SSLServerSocket", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0MjQ2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510142463", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyNzExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyOTc0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508729741", "bodyText": "nit; Small details.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n          \n          \n            \n                Security.addProvider(provider);\n          \n          \n            \n            \n          \n          \n            \n                KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n          \n          \n            \n                KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n          \n          \n            \n                        System.getProperty(\"azure.keyvault.uri\"), \n          \n          \n            \n                        System.getProperty(\"azure.tenant.id\"), \n          \n          \n            \n                        System.getProperty(\"azure.client.id\"),\n          \n          \n            \n                        System.getProperty(\"azure.client.secret\"));\n          \n          \n            \n                ks.load(parameter);\n          \n          \n            \n            \n          \n          \n            \n                SSLContext sslContext = SSLContexts\n          \n          \n            \n                        .custom()\n          \n          \n            \n                        .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n          \n          \n            \n                        .build();\n          \n          \n            \n            \n          \n          \n            \n                SSLConnectionSocketFactory sslSocketFactory = SSLConnectionSocketFactoryBuilder\n          \n          \n            \n                        .create()\n          \n          \n            \n                        .setSslContext(sslContext)\n          \n          \n            \n                        .setHostnameVerifier((hostname, session) -> {\n          \n          \n            \n                            return true;\n          \n          \n            \n                        })\n          \n          \n            \n                        .build();\n          \n          \n            \n            \n          \n          \n            \n                PoolingHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder\n          \n          \n            \n                        .create()\n          \n          \n            \n                        .setSSLSocketFactory(sslSocketFactory)\n          \n          \n            \n                        .build();\n          \n          \n            \n            \n          \n          \n            \n                String result = null;\n          \n          \n            \n            \n          \n          \n            \n                try ( CloseableHttpClient client = HttpClients.custom().setConnectionManager(cm).build()) {\n          \n          \n            \n                    HttpGet httpGet = new HttpGet(\"https://localhost:8766\");\n          \n          \n            \n                    HttpClientResponseHandler<String> responseHandler = (ClassicHttpResponse response) -> {\n          \n          \n            \n                        int status = response.getCode();\n          \n          \n            \n                        String result1 = \"Not success\";\n          \n          \n            \n                        if (status == 204) {\n          \n          \n            \n                            result1 = \"Success\";\n          \n          \n            \n                        }\n          \n          \n            \n                        return result1;\n          \n          \n            \n                    };\n          \n          \n            \n                    result = client.execute(httpGet, responseHandler);\n          \n          \n            \n                } catch (IOException ioe) {\n          \n          \n            \n                    ioe.printStackTrace();\n          \n          \n            \n                }\n          \n          \n            \n                KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n          \n          \n            \n                Security.addProvider(provider);\n          \n          \n            \n            \n          \n          \n            \n                KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n          \n          \n            \n                KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n          \n          \n            \n                    System.getProperty(\"azure.keyvault.uri\"), \n          \n          \n            \n                    System.getProperty(\"azure.tenant.id\"), \n          \n          \n            \n                    System.getProperty(\"azure.client.id\"),\n          \n          \n            \n                    System.getProperty(\"azure.client.secret\"));\n          \n          \n            \n                ks.load(parameter);\n          \n          \n            \n            \n          \n          \n            \n                SSLContext sslContext = SSLContexts\n          \n          \n            \n                    .custom()\n          \n          \n            \n                    .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n          \n          \n            \n                    .build();\n          \n          \n            \n            \n          \n          \n            \n                SSLConnectionSocketFactory sslSocketFactory = SSLConnectionSocketFactoryBuilder\n          \n          \n            \n                    .create()\n          \n          \n            \n                    .setSslContext(sslContext)\n          \n          \n            \n                    .setHostnameVerifier((hostname, session) -> {\n          \n          \n            \n                        return true;\n          \n          \n            \n                    })\n          \n          \n            \n                    .build();\n          \n          \n            \n            \n          \n          \n            \n                PoolingHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder\n          \n          \n            \n                    .create()\n          \n          \n            \n                    .setSSLSocketFactory(sslSocketFactory)\n          \n          \n            \n                    .build();\n          \n          \n            \n            \n          \n          \n            \n                String result = null;\n          \n          \n            \n            \n          \n          \n            \n                try (CloseableHttpClient client = HttpClients.custom().setConnectionManager(cm).build()) {\n          \n          \n            \n                    HttpGet httpGet = new HttpGet(\"https://localhost:8766\");\n          \n          \n            \n                    HttpClientResponseHandler<String> responseHandler = (ClassicHttpResponse response) -> {\n          \n          \n            \n                        int status = response.getCode();\n          \n          \n            \n                        String result1 = \"Not success\";\n          \n          \n            \n                        if (status == 204) {\n          \n          \n            \n                            result1 = \"Success\";\n          \n          \n            \n                        }\n          \n          \n            \n                        return result1;\n          \n          \n            \n                    };\n          \n          \n            \n                    result = client.execute(httpGet, responseHandler);\n          \n          \n            \n                } catch (IOException ioe) {\n          \n          \n            \n                    ioe.printStackTrace();\n          \n          \n            \n                }", "author": "vcolin7", "createdAt": "2020-10-20T17:59:42Z", "path": "sdk/keyvault/azure-security-keyvault-jca/README.md", "diffHunk": "@@ -0,0 +1,127 @@\n+# JCA Provider for Azure Key Vault\n+\n+The JCA Provider for Azure Key Vault is a JCA provider for certificates in \n+Azure Key Vault. It is built on four principles:\n+ \n+1. Must be extremely thin to run within a JVM\n+1. Must not introduce any library version conflicts with Java app code dependencies\n+1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies\n+1. Must be ready for \"never trust, always verify and credential-free\" Zero Trust environments.\n+\n+## Testing the version under development\n+\n+If you want to test the current version under development you will have to\n+build and install it into your local Maven repository. To do so use the \n+following command line:\n+\n+```\n+  mvn clean install -DskipTests=true\n+```\n+\n+## Server side SSL\n+\n+If you are looking to integrate the JCA provider to create a SSLServerSocket\n+see the example below.\n+\n+```java\n+    KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+    Security.addProvider(provider);\n+\n+    KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+    KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+        System.getProperty(\"azure.keyvault.uri\"), \n+        System.getProperty(\"azure.tenant.id\"), \n+        System.getProperty(\"azure.client.id\"),\n+        System.getProperty(\"azure.client.secret\"));\n+    ks.load(parameter);\n+\n+    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+    kmf.init(ks, \"\".toCharArray());\n+\n+    SSLContext context = SSLContext.getInstance(\"TLS\");\n+    context.init(kmf.getKeyManagers(), null, null);\n+\n+    SSLServerSocketFactory factory = (SSLServerSocketFactory) context.getServerSocketFactory();\n+    SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(8765);\n+```\n+\n+Note if you want to use Azure managed identity, you should set the value\n+of `azure.keyvault.uri`, and the rest of the parameters would be `null`.\n+\n+## Client side SSL\n+\n+If you are looking to integrate the JCA provider for client side socket \n+connections, see the Apache HTTP client example below.\n+\n+```java\n+    KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+    Security.addProvider(provider);\n+\n+    KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+    KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"), \n+            System.getProperty(\"azure.tenant.id\"), \n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+    ks.load(parameter);\n+\n+    SSLContext sslContext = SSLContexts\n+            .custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+    SSLConnectionSocketFactory sslSocketFactory = SSLConnectionSocketFactoryBuilder\n+            .create()\n+            .setSslContext(sslContext)\n+            .setHostnameVerifier((hostname, session) -> {\n+                return true;\n+            })\n+            .build();\n+\n+    PoolingHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder\n+            .create()\n+            .setSSLSocketFactory(sslSocketFactory)\n+            .build();\n+\n+    String result = null;\n+\n+    try ( CloseableHttpClient client = HttpClients.custom().setConnectionManager(cm).build()) {\n+        HttpGet httpGet = new HttpGet(\"https://localhost:8766\");\n+        HttpClientResponseHandler<String> responseHandler = (ClassicHttpResponse response) -> {\n+            int status = response.getCode();\n+            String result1 = \"Not success\";\n+            if (status == 204) {\n+                result1 = \"Success\";\n+            }\n+            return result1;\n+        };\n+        result = client.execute(httpGet, responseHandler);\n+    } catch (IOException ioe) {\n+        ioe.printStackTrace();\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMDIwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508730202", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note if you want to use Azure managed identity, you should set the value\n          \n          \n            \n            Note if you want to use Azure Managed Identity, you should set the value", "author": "vcolin7", "createdAt": "2020-10-20T18:00:22Z", "path": "sdk/keyvault/azure-security-keyvault-jca/README.md", "diffHunk": "@@ -0,0 +1,127 @@\n+# JCA Provider for Azure Key Vault\n+\n+The JCA Provider for Azure Key Vault is a JCA provider for certificates in \n+Azure Key Vault. It is built on four principles:\n+ \n+1. Must be extremely thin to run within a JVM\n+1. Must not introduce any library version conflicts with Java app code dependencies\n+1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies\n+1. Must be ready for \"never trust, always verify and credential-free\" Zero Trust environments.\n+\n+## Testing the version under development\n+\n+If you want to test the current version under development you will have to\n+build and install it into your local Maven repository. To do so use the \n+following command line:\n+\n+```\n+  mvn clean install -DskipTests=true\n+```\n+\n+## Server side SSL\n+\n+If you are looking to integrate the JCA provider to create a SSLServerSocket\n+see the example below.\n+\n+```java\n+    KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+    Security.addProvider(provider);\n+\n+    KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+    KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+        System.getProperty(\"azure.keyvault.uri\"), \n+        System.getProperty(\"azure.tenant.id\"), \n+        System.getProperty(\"azure.client.id\"),\n+        System.getProperty(\"azure.client.secret\"));\n+    ks.load(parameter);\n+\n+    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+    kmf.init(ks, \"\".toCharArray());\n+\n+    SSLContext context = SSLContext.getInstance(\"TLS\");\n+    context.init(kmf.getKeyManagers(), null, null);\n+\n+    SSLServerSocketFactory factory = (SSLServerSocketFactory) context.getServerSocketFactory();\n+    SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(8765);\n+```\n+\n+Note if you want to use Azure managed identity, you should set the value\n+of `azure.keyvault.uri`, and the rest of the parameters would be `null`.\n+\n+## Client side SSL\n+\n+If you are looking to integrate the JCA provider for client side socket \n+connections, see the Apache HTTP client example below.\n+\n+```java\n+    KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+    Security.addProvider(provider);\n+\n+    KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+    KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"), \n+            System.getProperty(\"azure.tenant.id\"), \n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+    ks.load(parameter);\n+\n+    SSLContext sslContext = SSLContexts\n+            .custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+    SSLConnectionSocketFactory sslSocketFactory = SSLConnectionSocketFactoryBuilder\n+            .create()\n+            .setSslContext(sslContext)\n+            .setHostnameVerifier((hostname, session) -> {\n+                return true;\n+            })\n+            .build();\n+\n+    PoolingHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder\n+            .create()\n+            .setSSLSocketFactory(sslSocketFactory)\n+            .build();\n+\n+    String result = null;\n+\n+    try ( CloseableHttpClient client = HttpClients.custom().setConnectionManager(cm).build()) {\n+        HttpGet httpGet = new HttpGet(\"https://localhost:8766\");\n+        HttpClientResponseHandler<String> responseHandler = (ClassicHttpResponse response) -> {\n+            int status = response.getCode();\n+            String result1 = \"Not success\";\n+            if (status == 204) {\n+                result1 = \"Success\";\n+            }\n+            return result1;\n+        };\n+        result = client.execute(httpGet, responseHandler);\n+    } catch (IOException ioe) {\n+        ioe.printStackTrace();\n+    }\n+```\n+\n+Note if you want to use Azure managed identity, you should set the value", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0NDE5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510144199", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMDIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMTU5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508731592", "bodyText": "When are we looking to fill these sections?", "author": "vcolin7", "createdAt": "2020-10-20T18:02:39Z", "path": "sdk/keyvault/azure-security-keyvault-jca/README.md", "diffHunk": "@@ -0,0 +1,127 @@\n+# JCA Provider for Azure Key Vault\n+\n+The JCA Provider for Azure Key Vault is a JCA provider for certificates in \n+Azure Key Vault. It is built on four principles:\n+ \n+1. Must be extremely thin to run within a JVM\n+1. Must not introduce any library version conflicts with Java app code dependencies\n+1. Must not introduce any class loader hierarchy conflicts with Java app code dependencies\n+1. Must be ready for \"never trust, always verify and credential-free\" Zero Trust environments.\n+\n+## Testing the version under development\n+\n+If you want to test the current version under development you will have to\n+build and install it into your local Maven repository. To do so use the \n+following command line:\n+\n+```\n+  mvn clean install -DskipTests=true\n+```\n+\n+## Server side SSL\n+\n+If you are looking to integrate the JCA provider to create a SSLServerSocket\n+see the example below.\n+\n+```java\n+    KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+    Security.addProvider(provider);\n+\n+    KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+    KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+        System.getProperty(\"azure.keyvault.uri\"), \n+        System.getProperty(\"azure.tenant.id\"), \n+        System.getProperty(\"azure.client.id\"),\n+        System.getProperty(\"azure.client.secret\"));\n+    ks.load(parameter);\n+\n+    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+    kmf.init(ks, \"\".toCharArray());\n+\n+    SSLContext context = SSLContext.getInstance(\"TLS\");\n+    context.init(kmf.getKeyManagers(), null, null);\n+\n+    SSLServerSocketFactory factory = (SSLServerSocketFactory) context.getServerSocketFactory();\n+    SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(8765);\n+```\n+\n+Note if you want to use Azure managed identity, you should set the value\n+of `azure.keyvault.uri`, and the rest of the parameters would be `null`.\n+\n+## Client side SSL\n+\n+If you are looking to integrate the JCA provider for client side socket \n+connections, see the Apache HTTP client example below.\n+\n+```java\n+    KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+    Security.addProvider(provider);\n+\n+    KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+    KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"), \n+            System.getProperty(\"azure.tenant.id\"), \n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+    ks.load(parameter);\n+\n+    SSLContext sslContext = SSLContexts\n+            .custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+    SSLConnectionSocketFactory sslSocketFactory = SSLConnectionSocketFactoryBuilder\n+            .create()\n+            .setSslContext(sslContext)\n+            .setHostnameVerifier((hostname, session) -> {\n+                return true;\n+            })\n+            .build();\n+\n+    PoolingHttpClientConnectionManager cm = PoolingHttpClientConnectionManagerBuilder\n+            .create()\n+            .setSSLSocketFactory(sslSocketFactory)\n+            .build();\n+\n+    String result = null;\n+\n+    try ( CloseableHttpClient client = HttpClients.custom().setConnectionManager(cm).build()) {\n+        HttpGet httpGet = new HttpGet(\"https://localhost:8766\");\n+        HttpClientResponseHandler<String> responseHandler = (ClassicHttpResponse response) -> {\n+            int status = response.getCode();\n+            String result1 = \"Not success\";\n+            if (status == 204) {\n+                result1 = \"Success\";\n+            }\n+            return result1;\n+        };\n+        result = client.execute(httpGet, responseHandler);\n+    } catch (IOException ioe) {\n+        ioe.printStackTrace();\n+    }\n+```\n+\n+Note if you want to use Azure managed identity, you should set the value\n+of `azure.keyvault.uri`, and the rest of the parameters would be `null`.\n+\n+## Spring Boot\n+\n+For Spring Boot applications see our [Spring Boot starter]<!--(../../spring/azure-spring-boot-starter-keyvault-certificates/README.md)-->.\n+\n+## Reference\n+\n+1. [Java Cryptography Architecture (JCA) Reference Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html)\n+\n+# Azure KeyVault JCA client library for Java\n+\n+# Getting started\n+\n+# Key concepts\n+\n+# Examples\n+\n+# Troubleshooting\n+\n+# Next steps\n+\n+# Contributing", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MjEyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510442121", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T20:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzMzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508753339", "bodyText": "Are we making a simple REST call for getting credentials instead of using our Azure Identity library to avoid pulling more dependencies into this JAR?", "author": "vcolin7", "createdAt": "2020-10-20T18:37:20Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIyNzczMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510227730", "bodyText": "That is correct.", "author": "mnriem", "createdAt": "2020-10-22T14:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2Nzc3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508767772", "bodyText": "Is this the only version that will be used for getting a token? If there are more versions available for this I would prefer us to use an expandable enum in future releases.", "author": "vcolin7", "createdAt": "2020-10-20T18:58:20Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTUwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511169508", "bodyText": "This will be indeed the only version as this code is not user configurable. This is by design so we eliminate user error.", "author": "mnriem", "createdAt": "2020-10-23T21:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2Nzc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MjkzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508772931", "bodyText": "We should use a ServiceVersion enum like other SDKs do in future releases to support multiple versions.", "author": "vcolin7", "createdAt": "2020-10-20T19:07:14Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511168736", "bodyText": "As this is completely hidden from the user and they can't configure it we do not need to support multiple versions. The project does need to be updated if the 7.1 would no longer be supported.", "author": "mnriem", "createdAt": "2020-10-23T21:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MjkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MzczOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508773739", "bodyText": "Even though it is technically a URI, in our Key Vault Java libraries we refer to this as a keyVaultUrl or vaultUrl, so I think we should be consistent to avoid confusing users.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /**\n          \n          \n            \n                 * Stores the KeyVault URI.\n          \n          \n            \n                 */\n          \n          \n            \n                private final String keyVaultUri;\n          \n          \n            \n                /**\n          \n          \n            \n                 * Stores the KeyVault URL.\n          \n          \n            \n                 */\n          \n          \n            \n                private final String keyVaultUrl;", "author": "vcolin7", "createdAt": "2020-10-20T19:08:41Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkzMDcxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510930715", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T14:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5MzI1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508793254", "bodyText": "nit; If we already have the value of certificateBundle.getCer() in certificateString we can use the variable here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    new ByteArrayInputStream(Base64.getDecoder().decode(certificateBundle.getCer()))\n          \n          \n            \n                                    new ByteArrayInputStream(Base64.getDecoder().decode(certificateString))", "author": "vcolin7", "createdAt": "2020-10-20T19:44:35Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;\n+\n+    /**\n+     * Stores the tenant ID.\n+     */\n+    private String tenantId;\n+\n+    /**\n+     * Stores the client ID.\n+     */\n+    private String clientId;\n+\n+    /**\n+     * Stores the client secret.\n+     */\n+    private String clientSecret;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     */\n+    KeyVaultClient(String keyVaultUri) {\n+        super(RestClientFactory.createClient());\n+        LOGGER.log(INFO, \"Using KeyVault: {0}\", keyVaultUri);\n+        if (!keyVaultUri.endsWith(\"/\")) {\n+            keyVaultUri = keyVaultUri + \"/\";\n+        }\n+        this.keyVaultUri = keyVaultUri;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     */\n+    KeyVaultClient(final String keyVaultUri, final String tenantId, final String clientId, final String clientSecret) {\n+        this(keyVaultUri);\n+        this.tenantId = tenantId;\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    private String getAccessToken() {\n+        LOGGER.entering(\"KeyVaultClient\", \"getAccessToken\");\n+        String accessToken = null;\n+        try {\n+            AuthClient authClient = new AuthClient();\n+            String resource = URLEncoder.encode(\"https://vault.azure.net\", \"UTF-8\");\n+            if (tenantId != null && clientId != null && clientSecret != null) {\n+                accessToken = authClient.getAccessToken(resource, tenantId, clientId, clientSecret);\n+            } else {\n+                accessToken = authClient.getAccessToken(resource);\n+            }\n+        } catch (UnsupportedEncodingException uee) {\n+            LOGGER.log(WARNING, \"Unsupported encoding\", uee);\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getAccessToken\", accessToken);\n+        return accessToken;\n+    }\n+\n+    /**\n+     * Get the list of aliases.\n+     *\n+     * @return the list of aliases.\n+     */\n+    public List<String> getAliases() {\n+        ArrayList<String> result = new ArrayList<>();\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates%s\", keyVaultUri, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        CertificateListResult certificateListResult = null;\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            certificateListResult = (CertificateListResult) converter.fromJson(response, CertificateListResult.class);\n+        }\n+        if (certificateListResult != null && certificateListResult.getValue().size() > 0) {\n+            for (CertificateItem certificateItem : certificateListResult.getValue()) {\n+                String id = certificateItem.getId();\n+                String alias = id.substring(id.indexOf(\"certificates\") + \"certificates\".length() + 1);\n+                result.add(alias);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate bundle.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate bundle.\n+     */\n+    private CertificateBundle getCertificateBundle(String alias) {\n+        CertificateBundle result = null;\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates/%s%s\", keyVaultUri, alias, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            result = (CertificateBundle) converter.fromJson(response, CertificateBundle.class);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate, or null if not found.\n+     */\n+    public Certificate getCertificate(String alias) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getCertificate\", alias);\n+        LOGGER.log(INFO, \"Getting certificate for alias: {0}\", alias);\n+        X509Certificate certificate = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        if (certificateBundle != null) {\n+            String certificateString = certificateBundle.getCer();\n+            if (certificateString != null) {\n+                try {\n+                    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                    certificate = (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(Base64.getDecoder().decode(certificateBundle.getCer()))", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkzOTczNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510939734", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T14:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5MzI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5NTMyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508795326", "bodyText": "I'm not entirely familiar with the KeyStore class, is it possible this can throw a NoSuchElementException in this case?", "author": "vcolin7", "createdAt": "2020-10-20T19:48:14Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;\n+\n+    /**\n+     * Stores the tenant ID.\n+     */\n+    private String tenantId;\n+\n+    /**\n+     * Stores the client ID.\n+     */\n+    private String clientId;\n+\n+    /**\n+     * Stores the client secret.\n+     */\n+    private String clientSecret;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     */\n+    KeyVaultClient(String keyVaultUri) {\n+        super(RestClientFactory.createClient());\n+        LOGGER.log(INFO, \"Using KeyVault: {0}\", keyVaultUri);\n+        if (!keyVaultUri.endsWith(\"/\")) {\n+            keyVaultUri = keyVaultUri + \"/\";\n+        }\n+        this.keyVaultUri = keyVaultUri;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     */\n+    KeyVaultClient(final String keyVaultUri, final String tenantId, final String clientId, final String clientSecret) {\n+        this(keyVaultUri);\n+        this.tenantId = tenantId;\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    private String getAccessToken() {\n+        LOGGER.entering(\"KeyVaultClient\", \"getAccessToken\");\n+        String accessToken = null;\n+        try {\n+            AuthClient authClient = new AuthClient();\n+            String resource = URLEncoder.encode(\"https://vault.azure.net\", \"UTF-8\");\n+            if (tenantId != null && clientId != null && clientSecret != null) {\n+                accessToken = authClient.getAccessToken(resource, tenantId, clientId, clientSecret);\n+            } else {\n+                accessToken = authClient.getAccessToken(resource);\n+            }\n+        } catch (UnsupportedEncodingException uee) {\n+            LOGGER.log(WARNING, \"Unsupported encoding\", uee);\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getAccessToken\", accessToken);\n+        return accessToken;\n+    }\n+\n+    /**\n+     * Get the list of aliases.\n+     *\n+     * @return the list of aliases.\n+     */\n+    public List<String> getAliases() {\n+        ArrayList<String> result = new ArrayList<>();\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates%s\", keyVaultUri, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        CertificateListResult certificateListResult = null;\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            certificateListResult = (CertificateListResult) converter.fromJson(response, CertificateListResult.class);\n+        }\n+        if (certificateListResult != null && certificateListResult.getValue().size() > 0) {\n+            for (CertificateItem certificateItem : certificateListResult.getValue()) {\n+                String id = certificateItem.getId();\n+                String alias = id.substring(id.indexOf(\"certificates\") + \"certificates\".length() + 1);\n+                result.add(alias);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate bundle.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate bundle.\n+     */\n+    private CertificateBundle getCertificateBundle(String alias) {\n+        CertificateBundle result = null;\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates/%s%s\", keyVaultUri, alias, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            result = (CertificateBundle) converter.fromJson(response, CertificateBundle.class);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate, or null if not found.\n+     */\n+    public Certificate getCertificate(String alias) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getCertificate\", alias);\n+        LOGGER.log(INFO, \"Getting certificate for alias: {0}\", alias);\n+        X509Certificate certificate = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        if (certificateBundle != null) {\n+            String certificateString = certificateBundle.getCer();\n+            if (certificateString != null) {\n+                try {\n+                    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                    certificate = (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(Base64.getDecoder().decode(certificateBundle.getCer()))\n+                    );\n+                } catch (CertificateException ce) {\n+                    LOGGER.log(WARNING, \"Certificate error\", ce);\n+                }\n+            }\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getCertificate\", certificate);\n+        return certificate;\n+    }\n+\n+    /**\n+     * Get the key.\n+     *\n+     * @param alias the alias.\n+     * @param password the password.\n+     * @return the key.\n+     */\n+    public Key getKey(String alias, char[] password) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getKey\", new Object[] { alias, password });\n+        LOGGER.log(INFO, \"Getting key for alias: {0}\", alias);\n+        Key key = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        boolean isExportable = Optional.ofNullable(certificateBundle)\n+                                       .map(CertificateBundle::getPolicy)\n+                                       .map(CertificatePolicy::getKey_props)\n+                                       .map(KeyProperties::isExportable)\n+                                       .orElse(false);\n+        if (isExportable) {\n+            // Because the certificate is exportable the private key is\n+            // available. So we'll use the KeyVault Secrets API to get the \n+            // private key.\n+            String certificateSecretUri = certificateBundle.getSid();\n+            HashMap<String, String> headers = new HashMap<>();\n+            headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+            String body = get(certificateSecretUri + API_VERSION_POSTFIX, headers);\n+            if (body != null) {\n+                JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+                SecretBundle secretBundle = (SecretBundle) converter.fromJson(body, SecretBundle.class);\n+                try {\n+                    KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n+                    keyStore.load(\n+                        new ByteArrayInputStream(Base64.getDecoder().decode(secretBundle.getValue())),\n+                        \"\".toCharArray()\n+                    );\n+                    alias = keyStore.aliases().nextElement();", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0NzgyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510447824", "bodyText": "In this particular case because we create a new Keystore and we load a specifically with just one certificate `NoSuchElementException' would not be thrown, because if loading failed it would have triggered the catch block.", "author": "mnriem", "createdAt": "2020-10-22T20:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5NTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTE5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508821196", "bodyText": "Should we also log a warning if the alias turns out to be null in the end?", "author": "vcolin7", "createdAt": "2020-10-20T20:33:46Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The KeyVault variant of the X509ExtendedKeyManager.\n+ */\n+public class KeyVaultKeyManager extends X509ExtendedKeyManager {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyManager.class.getName());\n+\n+    /**\n+     * Stores the keystore.\n+     */\n+    private final KeyStore keystore;\n+\n+    /**\n+     * Stores the password.\n+     */\n+    private final char[] password;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keystore the keystore.\n+     * @param password the password.\n+     */\n+    public KeyVaultKeyManager(KeyStore keystore, char[] password) {\n+        LOGGER.entering(\"KeyVaultKeyManager\", \"<init>\", new Object[] { keystore, password });\n+        this.keystore = keystore;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {\n+        LOGGER.entering(\n+            \"KeyVaultKeyManager\",\n+            \"chooseClientAlias\",\n+            new Object[] { keyType, issuers, socket }\n+        );\n+        String alias = null;\n+        try {\n+            /*\n+             * If we only have one alias and the keystore type is not 'AzureKeyVault'\n+             * return that alias as a match.\n+             */\n+            if (!keystore.getProvider().getName().equals(\"AzureKeyVault\")\n+                && keystore.size() == 1) {\n+                alias = keystore.aliases().nextElement();\n+            }\n+        } catch (KeyStoreException kse) {\n+            LOGGER.log(WARNING, \"Unable to choose client alias\", kse);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxODkwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511018901", "bodyText": "No as that would cause the application potentially to be very chatty. If the customer would need to know if it is indeed returning null they can change the logging level.", "author": "mnriem", "createdAt": "2020-10-23T17:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMzQxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508823417", "bodyText": "We don't need to check if keystoreChain is not empty if we are using a foreach loop.", "author": "vcolin7", "createdAt": "2020-10-20T20:37:41Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The KeyVault variant of the X509ExtendedKeyManager.\n+ */\n+public class KeyVaultKeyManager extends X509ExtendedKeyManager {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyManager.class.getName());\n+\n+    /**\n+     * Stores the keystore.\n+     */\n+    private final KeyStore keystore;\n+\n+    /**\n+     * Stores the password.\n+     */\n+    private final char[] password;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keystore the keystore.\n+     * @param password the password.\n+     */\n+    public KeyVaultKeyManager(KeyStore keystore, char[] password) {\n+        LOGGER.entering(\"KeyVaultKeyManager\", \"<init>\", new Object[] { keystore, password });\n+        this.keystore = keystore;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {\n+        LOGGER.entering(\n+            \"KeyVaultKeyManager\",\n+            \"chooseClientAlias\",\n+            new Object[] { keyType, issuers, socket }\n+        );\n+        String alias = null;\n+        try {\n+            /*\n+             * If we only have one alias and the keystore type is not 'AzureKeyVault'\n+             * return that alias as a match.\n+             */\n+            if (!keystore.getProvider().getName().equals(\"AzureKeyVault\")\n+                && keystore.size() == 1) {\n+                alias = keystore.aliases().nextElement();\n+            }\n+        } catch (KeyStoreException kse) {\n+            LOGGER.log(WARNING, \"Unable to choose client alias\", kse);\n+        }\n+        LOGGER.exiting(\"KeyVaultKeyManager\", \"chooseClientAlias\", alias);\n+        return alias;\n+    }\n+\n+    @Override\n+    public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {\n+        LOGGER.entering(\n+            \"KeyVaultKeyManager\",\n+            \"chooseServerAlias\",\n+            new Object[] { keyType, issuers, socket }\n+        );\n+        String alias = null;\n+        try {\n+            /*\n+             * If we only have one alias and the keystore type is not 'AzureKeyVault'\n+             * return that alias as a match.\n+             */\n+            if (!keystore.getProvider().getName().equals(\"AzureKeyVault\")\n+                && keystore.size() == 1) {\n+                alias = keystore.aliases().nextElement();\n+            }\n+        } catch (KeyStoreException kse) {\n+            LOGGER.log(WARNING, \"Unable to choose server alias\", kse);\n+        }\n+        LOGGER.exiting(\"KeyVaultKeyManager\", \"chooseServerAlias\", alias);\n+        return alias;\n+    }\n+\n+    @Override\n+    public String[] getClientAliases(String keyType, Principal[] issuers) {\n+        LOGGER.log(INFO, \"KeyVaultKeyManager.getClientAliases: {0}, {1}\",\n+            new Object[] { keyType, issuers });\n+        String[] aliases = null;\n+        try {\n+            aliases = Collections.list(keystore.aliases()).toArray(new String[0]);\n+        } catch (KeyStoreException kse) {\n+            LOGGER.log(WARNING, \"Unable to get client aliases\", kse);\n+        }\n+        LOGGER.log(INFO, \"KeyVaultKeyManager.getClientAliases: {0}\", aliases);\n+        return aliases;\n+    }\n+\n+    @Override\n+    public X509Certificate[] getCertificateChain(String alias) {\n+        LOGGER.entering(\"KeyVaultKeyManager\", \"getCertificateChain\", alias);\n+        List<X509Certificate> chain = new ArrayList<>();\n+        try {\n+            Certificate[] keystoreChain = keystore.getCertificateChain(alias);\n+            if (keystoreChain.length > 0) {\n+                for (Certificate certificate : keystoreChain) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0NzIyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510947221", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T15:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMzQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNjAzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508826034", "bodyText": "We might want to rename this to keyVaultClient.", "author": "vcolin7", "createdAt": "2020-10-20T20:42:24Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1NzAxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510957010", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T15:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNjAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyOTE1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508829152", "bodyText": "Is there a scenario where a certificate could have different contents to what's already cached and it needs to be set? If that's the case, it wouldn't be possible with this logic.", "author": "vcolin7", "createdAt": "2020-10-20T20:47:58Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MjU3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510972571", "bodyText": "Correct. The Azure Key Vault is a read-only KeyStore from the perspective of the user with the one exception that it does side-loading for certificates from the classpath. Which is why this method is implemented the way it is.", "author": "mnriem", "createdAt": "2020-10-23T15:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyOTE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzMDk5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508830999", "bodyText": "I'm not familiar with JCA but I wonder why these methods for keys are empty but we have things like engineIsKeyEntry where we call engineIsCertificateEntry inside. How is engineIsKeyEntry different that it needs an implementation, is it 100% expected to be used and the other methods are not? Are there scenarios where things like engineSetKeyEntry might need an implementation?", "author": "vcolin7", "createdAt": "2020-10-20T20:51:10Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNTk5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511005992", "bodyText": "Set engineSet methods do not get an implementation here because the Azure Key Vault KeyStore is a read-only KeyStore", "author": "mnriem", "createdAt": "2020-10-23T16:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzMDk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNDAyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508834026", "bodyText": "InputStream and BufferedReader must be closed after use in a finally block to avoid leaks. It is even more convenient to use try-with-resources statements.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    InputStream in = getClass().getResourceAsStream(path);\n          \n          \n            \n                    if (in != null) {\n          \n          \n            \n                        BufferedReader br = new BufferedReader(new InputStreamReader(in));\n          \n          \n            \n                        String resource;\n          \n          \n            \n                        while ((resource = br.readLine()) != null) {\n          \n          \n            \n                            filenames.add(resource);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return filenames.toArray(new String[0]);\n          \n          \n            \n                    try (InputStream in = getClass().getResourceAsStream(path)) {\n          \n          \n            \n                        if (in != null) {\n          \n          \n            \n                            try (BufferedReader br = new BufferedReader(new InputStreamReader(in))) {\n          \n          \n            \n                                String resource;\n          \n          \n            \n                                while ((resource = br.readLine()) != null) {\n          \n          \n            \n                                    filenames.add(resource);\n          \n          \n            \n                                }\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return filenames.toArray(new String[0]);", "author": "vcolin7", "createdAt": "2020-10-20T20:56:34Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public int engineSize() {\n+        return aliases != null ? aliases.size() : 0;\n+    }\n+\n+    @Override\n+    public void engineStore(OutputStream stream, char[] password) {\n+    }\n+\n+    @Override\n+    public void engineStore(KeyStore.LoadStoreParameter param) {\n+    }\n+\n+    /**\n+     * Get the filenames.\n+     *\n+     * @param path the path.\n+     * @return the filenames.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private String[] getFilenames(String path) throws IOException {\n+        List<String> filenames = new ArrayList<>();\n+        InputStream in = getClass().getResourceAsStream(path);\n+        if (in != null) {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n+            String resource;\n+            while ((resource = br.readLine()) != null) {\n+                filenames.add(resource);\n+            }\n+        }\n+        return filenames.toArray(new String[0]);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0MjM0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511042344", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T17:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNDAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNTM1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508835359", "bodyText": "Use a try-with-resources block to ensure this is closed after use.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();\n          \n          \n            \n                    byte[] buffer = new byte[1024];\n          \n          \n            \n                    while (true) {\n          \n          \n            \n                        int r = inputStream.read(buffer);\n          \n          \n            \n                        if (r == -1) {\n          \n          \n            \n                            break;\n          \n          \n            \n                        }\n          \n          \n            \n                        byteOutput.write(buffer, 0, r);\n          \n          \n            \n                    }\n          \n          \n            \n                    return byteOutput.toByteArray();\n          \n          \n            \n                    byte[] bytes;\n          \n          \n            \n                    try (ByteArrayOutputStream byteOutput = new ByteArrayOutputStream()) {\n          \n          \n            \n                        byte[] buffer = new byte[1024];\n          \n          \n            \n                        while (true) {\n          \n          \n            \n                            int r = inputStream.read(buffer);\n          \n          \n            \n                            if (r == -1) {\n          \n          \n            \n                                break;\n          \n          \n            \n                            }\n          \n          \n            \n                            byteOutput.write(buffer, 0, r);\n          \n          \n            \n                        }\n          \n          \n            \n                        bytes = byteOutput.toByteArray();\n          \n          \n            \n                    }\n          \n          \n            \n                    return bytes;", "author": "vcolin7", "createdAt": "2020-10-20T20:59:03Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public int engineSize() {\n+        return aliases != null ? aliases.size() : 0;\n+    }\n+\n+    @Override\n+    public void engineStore(OutputStream stream, char[] password) {\n+    }\n+\n+    @Override\n+    public void engineStore(KeyStore.LoadStoreParameter param) {\n+    }\n+\n+    /**\n+     * Get the filenames.\n+     *\n+     * @param path the path.\n+     * @return the filenames.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private String[] getFilenames(String path) throws IOException {\n+        List<String> filenames = new ArrayList<>();\n+        InputStream in = getClass().getResourceAsStream(path);\n+        if (in != null) {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n+            String resource;\n+            while ((resource = br.readLine()) != null) {\n+                filenames.add(resource);\n+            }\n+        }\n+        return filenames.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Read all the bytes for a given input stream.\n+     *\n+     * @param inputStream the input stream.\n+     * @return the byte-array.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private byte[] readAllBytes(InputStream inputStream) throws IOException {\n+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();\n+        byte[] buffer = new byte[1024];\n+        while (true) {\n+            int r = inputStream.read(buffer);\n+            if (r == -1) {\n+                break;\n+            }\n+            byteOutput.write(buffer, 0, r);\n+        }\n+        return byteOutput.toByteArray();", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTExMDE4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511110189", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T19:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNjkxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508836918", "bodyText": "Adding null check in case bytes could not be read considering my previous comment.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        byte[] bytes = readAllBytes(inputStream);\n          \n          \n            \n                                        try {\n          \n          \n            \n                                            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n          \n          \n            \n                                            X509Certificate certificate = (X509Certificate) cf.generateCertificate(\n          \n          \n            \n                                                new ByteArrayInputStream(bytes));\n          \n          \n            \n                                            engineSetCertificateEntry(alias, certificate);\n          \n          \n            \n                                            LOGGER.log(INFO, \"Side loaded certificate: {0} from: {1}\",\n          \n          \n            \n                                                new Object[] { alias, filename });\n          \n          \n            \n                                        } catch (CertificateException e) {\n          \n          \n            \n                                            LOGGER.log(WARNING, \"Unable to side-load certificate\", e);\n          \n          \n            \n                                        }\n          \n          \n            \n                                        byte[] bytes = readAllBytes(inputStream);\n          \n          \n            \n                                        if (bytes != null) {\n          \n          \n            \n                                            try {\n          \n          \n            \n                                                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n          \n          \n            \n                                                X509Certificate certificate = (X509Certificate) cf.generateCertificate(\n          \n          \n            \n                                                    new ByteArrayInputStream(bytes));\n          \n          \n            \n                                                engineSetCertificateEntry(alias, certificate);\n          \n          \n            \n                                                LOGGER.log(INFO, \"Side loaded certificate: {0} from: {1}\",\n          \n          \n            \n                                                    new Object[]{alias, filename});\n          \n          \n            \n                                            } catch (CertificateException e) {\n          \n          \n            \n                                                LOGGER.log(WARNING, \"Unable to side-load certificate\", e);\n          \n          \n            \n                                            }\n          \n          \n            \n                                        } else {\n          \n          \n            \n                                            LOGGER.log(WARNING, \"Unable to side-load certificate\");\n          \n          \n            \n                                        }", "author": "vcolin7", "createdAt": "2020-10-20T21:01:44Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public int engineSize() {\n+        return aliases != null ? aliases.size() : 0;\n+    }\n+\n+    @Override\n+    public void engineStore(OutputStream stream, char[] password) {\n+    }\n+\n+    @Override\n+    public void engineStore(KeyStore.LoadStoreParameter param) {\n+    }\n+\n+    /**\n+     * Get the filenames.\n+     *\n+     * @param path the path.\n+     * @return the filenames.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private String[] getFilenames(String path) throws IOException {\n+        List<String> filenames = new ArrayList<>();\n+        InputStream in = getClass().getResourceAsStream(path);\n+        if (in != null) {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n+            String resource;\n+            while ((resource = br.readLine()) != null) {\n+                filenames.add(resource);\n+            }\n+        }\n+        return filenames.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Read all the bytes for a given input stream.\n+     *\n+     * @param inputStream the input stream.\n+     * @return the byte-array.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private byte[] readAllBytes(InputStream inputStream) throws IOException {\n+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();\n+        byte[] buffer = new byte[1024];\n+        while (true) {\n+            int r = inputStream.read(buffer);\n+            if (r == -1) {\n+                break;\n+            }\n+            byteOutput.write(buffer, 0, r);\n+        }\n+        return byteOutput.toByteArray();\n+    }\n+\n+    /**\n+     * Side-load certificate from classpath.\n+     */\n+    private void sideLoad() {\n+        try {\n+            String[] filenames = getFilenames(\"/keyvault\");\n+            if (filenames.length > 0) {\n+                for (String filename : filenames) {\n+                    try (InputStream inputStream = getClass().getResourceAsStream(\"/keyvault/\" + filename)) {\n+                        String alias = filename;\n+                        if (alias != null) {\n+                            if (alias.lastIndexOf('.') != -1) {\n+                                alias = alias.substring(0, alias.lastIndexOf('.'));\n+                            }\n+                            byte[] bytes = readAllBytes(inputStream);\n+                            try {\n+                                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                                X509Certificate certificate = (X509Certificate) cf.generateCertificate(\n+                                    new ByteArrayInputStream(bytes));\n+                                engineSetCertificateEntry(alias, certificate);\n+                                LOGGER.log(INFO, \"Side loaded certificate: {0} from: {1}\",\n+                                    new Object[] { alias, filename });\n+                            } catch (CertificateException e) {\n+                                LOGGER.log(WARNING, \"Unable to side-load certificate\", e);\n+                            }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyMjE3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511122179", "bodyText": "Not needed as it will either return a byte-array (potentially empty) or throw an IOException", "author": "mnriem", "createdAt": "2020-10-23T19:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzODU1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508838550", "bodyText": "X509ExtendedTrustManager already implements X509TrustManager.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class KeyVaultTrustManager extends X509ExtendedTrustManager implements X509TrustManager {\n          \n          \n            \n            public class KeyVaultTrustManager extends X509ExtendedTrustManager {", "author": "vcolin7", "createdAt": "2020-10-20T21:04:47Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultTrustManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+\n+/**\n+ * The KeyVault variant of the X509TrustManager.\n+ */\n+public class KeyVaultTrustManager extends X509ExtendedTrustManager implements X509TrustManager {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEzMjQ0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511132442", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T20:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzODU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzOTQ0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508839445", "bodyText": "Can we use a logger in instances like these like in the rest of the classes in this package?", "author": "vcolin7", "createdAt": "2020-10-20T21:06:27Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultTrustManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+\n+/**\n+ * The KeyVault variant of the X509TrustManager.\n+ */\n+public class KeyVaultTrustManager extends X509ExtendedTrustManager implements X509TrustManager {\n+\n+    /**\n+     * Stores the default trust manager.\n+     */\n+    private X509TrustManager defaultTrustManager;\n+\n+    /**\n+     * Stores the keystore.\n+     */\n+    private KeyStore keyStore;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyStore the keystore.\n+     */\n+    public KeyVaultTrustManager(KeyStore keyStore) {\n+        this.keyStore = keyStore;\n+        if (this.keyStore == null) {\n+            try {\n+                this.keyStore = KeyStore.getInstance(\"AzureKeyVault\");\n+                this.keyStore.load(null, null);\n+            } catch (KeyStoreException | IOException | NoSuchAlgorithmException | CertificateException ex) {\n+                ex.printStackTrace();", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MDc5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508840790", "bodyText": "Would returning an empty array cause any bugs down the line?", "author": "vcolin7", "createdAt": "2020-10-20T21:08:47Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultTrustManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+\n+/**\n+ * The KeyVault variant of the X509TrustManager.\n+ */\n+public class KeyVaultTrustManager extends X509ExtendedTrustManager implements X509TrustManager {\n+\n+    /**\n+     * Stores the default trust manager.\n+     */\n+    private X509TrustManager defaultTrustManager;\n+\n+    /**\n+     * Stores the keystore.\n+     */\n+    private KeyStore keyStore;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyStore the keystore.\n+     */\n+    public KeyVaultTrustManager(KeyStore keyStore) {\n+        this.keyStore = keyStore;\n+        if (this.keyStore == null) {\n+            try {\n+                this.keyStore = KeyStore.getInstance(\"AzureKeyVault\");\n+                this.keyStore.load(null, null);\n+            } catch (KeyStoreException | IOException | NoSuchAlgorithmException | CertificateException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+        try {\n+            TrustManagerFactory factory = TrustManagerFactory.getInstance(\"PKIX\", \"SunJSSE\");\n+            factory.init(keyStore);\n+            defaultTrustManager = (X509TrustManager) factory.getTrustManagers()[0];\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException | KeyStoreException ex) {\n+            ex.printStackTrace();\n+        }\n+        if (defaultTrustManager == null) {\n+            try {\n+                TrustManagerFactory factory = TrustManagerFactory.getInstance(\"PKIX\", \"IbmJSSE\");\n+                factory.init(keyStore);\n+                defaultTrustManager = (X509TrustManager) factory.getTrustManagers()[0];\n+            } catch (NoSuchAlgorithmException | NoSuchProviderException | KeyStoreException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void checkClientTrusted(X509Certificate[] chain, String authType)\n+        throws CertificateException {\n+\n+        boolean pass = true;\n+\n+        /*\n+         * Step 1 - see if the default trust manager passes.\n+         */\n+        try {\n+            defaultTrustManager.checkClientTrusted(chain, authType);\n+        } catch (CertificateException ce) {\n+            pass = false;\n+        }\n+\n+        /*\n+         * Step 2 - see if the certificate exists in the keystore.\n+         */\n+        if (!pass) {\n+            String alias = null;\n+            try {\n+                alias = keyStore.getCertificateAlias(chain[0]);\n+            } catch (KeyStoreException kse) {\n+                kse.printStackTrace();\n+            }\n+            if (alias == null) {\n+                throw new CertificateException(\"Unable to verify in keystore\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void checkServerTrusted(X509Certificate[] chain, String authType)\n+        throws CertificateException {\n+\n+        boolean pass = true;\n+\n+        /*\n+         * Step 1 - see if the default trust manager passes.\n+         */\n+        try {\n+            defaultTrustManager.checkServerTrusted(chain, authType);\n+        } catch (CertificateException ce) {\n+            pass = false;\n+        }\n+\n+        /*\n+         * Step 2 - see if the certificate exists in the keystore.\n+         */\n+        if (!pass) {\n+            String alias = null;\n+            try {\n+                alias = keyStore.getCertificateAlias(chain[0]);\n+            } catch (KeyStoreException kse) {\n+                kse.printStackTrace();\n+            }\n+            if (alias == null) {\n+                throw new CertificateException(\"Unable to verify in keystore\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public X509Certificate[] getAcceptedIssuers() {\n+        return new X509Certificate[0];\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEzOTMwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511139304", "bodyText": "For the current use cases this is enough. This might change when we implement support for mTLS.", "author": "mnriem", "createdAt": "2020-10-23T20:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MDc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MTkwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508841902", "bodyText": "Can we name these getKeyProperties and setKeyProperties?", "author": "vcolin7", "createdAt": "2020-10-20T21:10:55Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/rest/CertificatePolicy.java", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca.rest;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * The CertificatePolicy REST model.\n+ */\n+public class CertificatePolicy implements Serializable {\n+\n+    /**\n+     * Stores the key properties.\n+     */\n+    private KeyProperties keyProperties;\n+\n+    /**\n+     * Get the key properties.\n+     *\n+     * @return the key properties.\n+     */\n+    public KeyProperties getKey_props() {\n+        return keyProperties;\n+    }\n+\n+    /**\n+     * Set the key properties.\n+     *\n+     * @param keyProperties the key properties.\n+     */\n+    public void setKey_props(KeyProperties keyProperties) {\n+        this.keyProperties = keyProperties;\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0NDA1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511144057", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T20:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MjIwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508842200", "bodyText": "Can we name these getAccessToken and setAccessToken?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getAccess_token() {\n          \n          \n            \n                    return access_token;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Set the access token.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param accessToken the access token.\n          \n          \n            \n                 */\n          \n          \n            \n                public void setAccess_token(String accessToken) {\n          \n          \n            \n                    this.access_token = accessToken;\n          \n          \n            \n                }\n          \n          \n            \n                public String getAccessToken() {\n          \n          \n            \n                    return accessToken;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Set the access token.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param accessToken the access token.\n          \n          \n            \n                 */\n          \n          \n            \n                public void setAccessToken(String accessToken) {\n          \n          \n            \n                    this.accessToken = accessToken;\n          \n          \n            \n                }", "author": "vcolin7", "createdAt": "2020-10-20T21:11:30Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/rest/OAuthToken.java", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.security.keyvault.jca.rest;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * An OAuth2 token.\n+ */\n+public class OAuthToken implements Serializable {\n+\n+    /**\n+     * Stores the access token.\n+     */\n+    private String access_token;\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    public String getAccess_token() {\n+        return access_token;\n+    }\n+\n+    /**\n+     * Set the access token.\n+     *\n+     * @param accessToken the access token.\n+     */\n+    public void setAccess_token(String accessToken) {\n+        this.access_token = accessToken;\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTM1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511171350", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MjYwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508842602", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String access_token;\n          \n          \n            \n                private String accessToken;", "author": "vcolin7", "createdAt": "2020-10-20T21:12:18Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/rest/OAuthToken.java", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.security.keyvault.jca.rest;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * An OAuth2 token.\n+ */\n+public class OAuthToken implements Serializable {\n+\n+    /**\n+     * Stores the access token.\n+     */\n+    private String access_token;", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTQzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511171438", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MjYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MzMxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508843312", "bodyText": "Let's remove the author tag from our Javadoc :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the DelegateRestClient class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the DelegateRestClient class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:13:46Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/DelegateRestClientTest.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * The JUnit tests for the DelegateRestClient class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MjI1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510272250", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MzMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MzU1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508843554", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the JsonbJsonConverter class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the JsonbJsonConverter class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:14:14Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/JacksonJsonConverterTest.java", "diffHunk": "@@ -0,0 +1,46 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The JUnit tests for the JsonbJsonConverter class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MjA3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510272079", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MzU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzc1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508843754", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultCertificate class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultCertificate class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:14:36Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultCertificateTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SignatureException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * The JUnit tests for the KeyVaultCertificate class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MTk3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510271978", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NTYzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508845631", "bodyText": "JUnit 5 allows to expect exceptions to be thrown via the following. Let's keep this in mind for future iterations.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try {\n          \n          \n            \n                        KeyVaultCertificate certificate = new KeyVaultCertificate(x509Certificate);\n          \n          \n            \n                        certificate.checkValidity(new Date(100, Calendar.FEBRUARY, 1));\n          \n          \n            \n                        fail();\n          \n          \n            \n                    } catch (CertificateExpiredException ex) {\n          \n          \n            \n                        fail();\n          \n          \n            \n                    } catch (CertificateNotYetValidException exception) {\n          \n          \n            \n                        // expecting this as the TEST_CERTIFICATE is not valid against given date.\n          \n          \n            \n                    }\n          \n          \n            \n                    Assertions.assertThrows(CertificateNotYetValidException.class, () -> {\n          \n          \n            \n                        KeyVaultCertificate certificate = new KeyVaultCertificate(x509Certificate);\n          \n          \n            \n                        certificate.checkValidity(new Date(100, Calendar.FEBRUARY, 1));\n          \n          \n            \n                    });", "author": "vcolin7", "createdAt": "2020-10-20T21:18:07Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultCertificateTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SignatureException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * The JUnit tests for the KeyVaultCertificate class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */\n+public class KeyVaultCertificateTest {\n+\n+    /**\n+     * Stores the CER test certificate (which is valid til 2120).\n+     */\n+    private static final String TEST_CERTIFICATE\n+        = \"MIIDeDCCAmCgAwIBAgIQGghBu97rQJKNnUHPWU7xjDANBgkqhkiG9w0BAQsFADAk\"\n+        + \"MSIwIAYDVQQDExlodW5kcmVkLXllYXJzLmV4YW1wbGUuY29tMCAXDTIwMDkwMjE3\"\n+        + \"NDUyNFoYDzIxMjAwOTAyMTc1NTI0WjAkMSIwIAYDVQQDExlodW5kcmVkLXllYXJz\"\n+        + \"LmV4YW1wbGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuU14\"\n+        + \"btkN5wmcO2WKXqm1NUKXzi79EtqiFFkrLgPAwj5NNwMw2Akm3GpdEpwkJ8/q3l7d\"\n+        + \"frDEVOO9gwZbz7xppyqutjxjllw8CCgjFdfK02btz56CGgh3X25ZZtzPbuMZJM0j\"\n+        + \"o4mVEdaFNJ0eUeMppS0DcbbuTWCF7Jf1gvr8GVqx+E0IJUFkE+D4kdTbnJSaeK0A\"\n+        + \"KEt94z88MPX18h8ud14uRVmUCYVZrZeswdE2tO1BpazrXELHuXCtrjGxsDDjDzeP\"\n+        + \"98aFI9kblkqoJS4TsmloLEjwZLm80cyJDEmpXXMtR7C0FFXFI1BAtIa4mxSgBLsT\"\n+        + \"L4GVPEGNANR8COYkHQIDAQABo4GjMIGgMA4GA1UdDwEB/wQEAwIFoDAJBgNVHRME\"\n+        + \"AjAAMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAkBgNVHREEHTAbghlo\"\n+        + \"dW5kcmVkLXllYXJzLmV4YW1wbGUuY29tMB8GA1UdIwQYMBaAFOGTt4H3ho30O4e+\"\n+        + \"hebwJjm2VMvIMB0GA1UdDgQWBBThk7eB94aN9DuHvoXm8CY5tlTLyDANBgkqhkiG\"\n+        + \"9w0BAQsFAAOCAQEAGp8mCioVCmM+kZv6r+K2j2uog1k4HBwN1NfRoSsibDB8+QXF\"\n+        + \"bmNf3M0imiuR/KJgODyuROwaa/AalxNFMOP8XTL2YmP7XsddBs9ONHHQXKjY/Ojl\"\n+        + \"PsIPR7vZjwYPfEB+XEKl2fOIxDQQ921POBV7M6DdTC49T5X+FsLR1AIIfinVetT9\"\n+        + \"QmNuvzulBX0T0rea/qpcPK4HTj7ToyImOaf8sXRv2s2ODLUrKWu5hhTNH2l6RIkQ\"\n+        + \"U/aIAdQRfDaSE9jhtcVu5d5kCgBs7nz5AzeCisDPo5zIt4Mxej3iVaAJ79oEbHOE\"\n+        + \"p192KLXLV/pscA4Wgb+PJ8AAEa5B6xq8p9JO+Q==\";\n+\n+    /**\n+     * Stores the X.509 certificate.\n+     */\n+    private X509Certificate x509Certificate;\n+\n+    /**\n+     * Setup before each test.\n+     *\n+     */\n+    @BeforeEach\n+    public void setUp() {\n+        try {\n+            byte[] certificateBytes = Base64.getDecoder().decode(TEST_CERTIFICATE);\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            x509Certificate = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(certificateBytes));\n+        } catch (CertificateException e) {\n+            throw new ProviderException(e);\n+        }\n+    }\n+\n+    /**\n+     * Test checkValidity method.\n+     */\n+    @Test\n+    public void testCheckValidity() {\n+        try {\n+            KeyVaultCertificate certificate = new KeyVaultCertificate(x509Certificate);\n+            certificate.checkValidity();\n+        } catch (CertificateExpiredException | CertificateNotYetValidException cnyve) {\n+            fail();\n+        }\n+    }\n+\n+    /**\n+     * Test checkValidity method.\n+     */\n+    @Test\n+    public void testCheckValidity2() {\n+        try {\n+            KeyVaultCertificate certificate = new KeyVaultCertificate(x509Certificate);\n+            certificate.checkValidity(new Date(100, Calendar.FEBRUARY, 1));\n+            fail();\n+        } catch (CertificateExpiredException ex) {\n+            fail();\n+        } catch (CertificateNotYetValidException exception) {\n+            // expecting this as the TEST_CERTIFICATE is not valid against given date.\n+        }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NjM2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508846362", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultProvider class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultProvider class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:19:27Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultJcaProviderTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.security.KeyStore;\n+import java.security.Security;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+/**\n+ * The JUnit tests for the KeyVaultProvider class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MTczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510271736", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NjM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NjU1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508846551", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultKeyStore class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultKeyStore class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:19:51Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultKeyStoreTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.ProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The JUnit tests for the KeyVaultKeyStore class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MTYwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510271606", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NjU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Njk4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508846982", "bodyText": "Why do we catch exceptions and use fail() in most places and we throw an exception here? I don't think it's a bad idea to just let things throw if they don't follow the happy path. Is there a specific reason you decided to use fail() in some catch blocks?", "author": "vcolin7", "createdAt": "2020-10-20T21:20:39Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultKeyStoreTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.ProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The JUnit tests for the KeyVaultKeyStore class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */\n+public class KeyVaultKeyStoreTest {\n+\n+    /**\n+     * Stores the CER test certificate (which is valid til 2120).\n+     */\n+    private static final String TEST_CERTIFICATE\n+        = \"MIIDeDCCAmCgAwIBAgIQGghBu97rQJKNnUHPWU7xjDANBgkqhkiG9w0BAQsFADAk\"\n+        + \"MSIwIAYDVQQDExlodW5kcmVkLXllYXJzLmV4YW1wbGUuY29tMCAXDTIwMDkwMjE3\"\n+        + \"NDUyNFoYDzIxMjAwOTAyMTc1NTI0WjAkMSIwIAYDVQQDExlodW5kcmVkLXllYXJz\"\n+        + \"LmV4YW1wbGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuU14\"\n+        + \"btkN5wmcO2WKXqm1NUKXzi79EtqiFFkrLgPAwj5NNwMw2Akm3GpdEpwkJ8/q3l7d\"\n+        + \"frDEVOO9gwZbz7xppyqutjxjllw8CCgjFdfK02btz56CGgh3X25ZZtzPbuMZJM0j\"\n+        + \"o4mVEdaFNJ0eUeMppS0DcbbuTWCF7Jf1gvr8GVqx+E0IJUFkE+D4kdTbnJSaeK0A\"\n+        + \"KEt94z88MPX18h8ud14uRVmUCYVZrZeswdE2tO1BpazrXELHuXCtrjGxsDDjDzeP\"\n+        + \"98aFI9kblkqoJS4TsmloLEjwZLm80cyJDEmpXXMtR7C0FFXFI1BAtIa4mxSgBLsT\"\n+        + \"L4GVPEGNANR8COYkHQIDAQABo4GjMIGgMA4GA1UdDwEB/wQEAwIFoDAJBgNVHRME\"\n+        + \"AjAAMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAkBgNVHREEHTAbghlo\"\n+        + \"dW5kcmVkLXllYXJzLmV4YW1wbGUuY29tMB8GA1UdIwQYMBaAFOGTt4H3ho30O4e+\"\n+        + \"hebwJjm2VMvIMB0GA1UdDgQWBBThk7eB94aN9DuHvoXm8CY5tlTLyDANBgkqhkiG\"\n+        + \"9w0BAQsFAAOCAQEAGp8mCioVCmM+kZv6r+K2j2uog1k4HBwN1NfRoSsibDB8+QXF\"\n+        + \"bmNf3M0imiuR/KJgODyuROwaa/AalxNFMOP8XTL2YmP7XsddBs9ONHHQXKjY/Ojl\"\n+        + \"PsIPR7vZjwYPfEB+XEKl2fOIxDQQ921POBV7M6DdTC49T5X+FsLR1AIIfinVetT9\"\n+        + \"QmNuvzulBX0T0rea/qpcPK4HTj7ToyImOaf8sXRv2s2ODLUrKWu5hhTNH2l6RIkQ\"\n+        + \"U/aIAdQRfDaSE9jhtcVu5d5kCgBs7nz5AzeCisDPo5zIt4Mxej3iVaAJ79oEbHOE\"\n+        + \"p192KLXLV/pscA4Wgb+PJ8AAEa5B6xq8p9JO+Q==\";\n+\n+    @Test\n+    public void testEngineGetCertificate() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+        assertNull(keystore.engineGetCertificate(\"myalias\"));\n+    }\n+\n+    @Test\n+    public void testEngineGetCertificateAlias() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+        assertNull(keystore.engineGetCertificateAlias(null));\n+    }\n+\n+    @Test\n+    public void testEngineGetCertificateChain() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+        assertNull(keystore.engineGetCertificateChain(\"myalias\"));\n+    }\n+\n+    @Test\n+    public void testEngineIsCertificateEntry() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+        assertFalse(keystore.engineIsCertificateEntry(\"myalias\"));\n+    }\n+\n+    @Test\n+    public void testEngineSetCertificateEntry() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+\n+        X509Certificate certificate;\n+\n+        try {\n+            byte[] certificateBytes = Base64.getDecoder().decode(TEST_CERTIFICATE);\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            certificate = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(certificateBytes));\n+        } catch (CertificateException e) {\n+            throw new ProviderException(e);\n+        }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzE3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508847172", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultLoadStoreParameter class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultLoadStoreParameter class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:21:03Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultLoadStoreParameterTest.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+/**\n+ * The JUnit tests for the KeyVaultLoadStoreParameter class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDU3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510270575", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzMxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508847313", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the LegacyRestClient class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the LegacyRestClient class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:21:20Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/LegacyRestClientTest.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * The JUnit tests for the LegacyRestClient class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDQyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510270420", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzQyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508847429", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the RestClientFactory class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the RestClientFactory class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:21:35Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/RestClientFactoryTest.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * The JUnit tests for the RestClientFactory class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDI5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510270292", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzU4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508847588", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The unit test validating the ServerSocket is created using a certificate from Azure KeyVault.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The unit test validating the ServerSocket is created using a certificate from Azure KeyVault.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:21:53Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/ServerSocketTest.java", "diffHunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.apache.hc.client5.http.classic.methods.HttpGet;\n+import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\n+import org.apache.hc.client5.http.impl.classic.HttpClients;\n+import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager;\n+import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder;\n+import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;\n+import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactoryBuilder;\n+import org.apache.hc.client5.http.ssl.TrustSelfSignedStrategy;\n+import org.apache.hc.core5.http.ClassicHttpResponse;\n+import org.apache.hc.core5.http.io.HttpClientResponseHandler;\n+import org.apache.hc.core5.ssl.SSLContexts;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.Security;\n+import java.security.cert.X509Certificate;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+/**\n+ * The unit test validating the ServerSocket is created using a certificate from Azure KeyVault.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NDU1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510154552", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MTA1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508851056", "bodyText": "Just remember to add the changelog notes here before releasing :)", "author": "vcolin7", "createdAt": "2020-10-20T21:28:37Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/CHANGELOG.md", "diffHunk": "@@ -0,0 +1,3 @@\n+# Release History\n+\n+## 3.0.0-beta.1 (Unreleased)", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwOTU4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510409585", "bodyText": "That was taken care of", "author": "mnriem", "createdAt": "2020-10-22T19:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MTA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MTkwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508851904", "bodyText": "We use Key Vault all accross our documentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n          \n          \n            \n            server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n          \n          \n            \n            server.ssl.key-store-type=AzureKeyVault\n          \n          \n            \n            ```\n          \n          \n            \n            azure.keyvault.uri=<the URI of the Azure Key Vault to use>\n          \n          \n            \n            server.ssl.key-alias=<the name of the certificate in Azure Key Vault to use>\n          \n          \n            \n            server.ssl.key-store-type=AzureKeyVault", "author": "vcolin7", "createdAt": "2020-10-20T21:30:15Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NDc0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510154744", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MTkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MjI4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508852286", "bodyText": "nit; Adding some visual help for readers.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To use the starter for server side SSL, you will need to add the following to\n          \n          \n            \n            your application.properties (if the application is using Spring Cloud Config \n          \n          \n            \n            Server for its configuration add it to the bootstrap.yml of the application)\n          \n          \n            \n            To use the starter for server side SSL, you will need to add the following to\n          \n          \n            \n            your `application.properties` (if the application is using Spring Cloud Config \n          \n          \n            \n            Server for its configuration add it to the `bootstrap.yml` of the application)", "author": "vcolin7", "createdAt": "2020-10-20T21:31:02Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDExMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510270112", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MjI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MjQxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508852412", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note: make sure the managed identity has access to the Azure KeyVault to access\n          \n          \n            \n            Note: make sure the managed identity has access to the Azure Key Vault to access", "author": "vcolin7", "createdAt": "2020-10-20T21:31:16Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NDg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510154898", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MjU0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508852540", "bodyText": "nit; Adding some visual help for readers.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To use the starter for server side SSL, you will need to add the following to\n          \n          \n            \n            your application.properties (if the application is using Spring Cloud Config \n          \n          \n            \n            Server for its configuration add it to the bootstrap.yml of the application)\n          \n          \n            \n            To use the starter for server side SSL, you will need to add the following to\n          \n          \n            \n            your `application.properties` (if the application is using Spring Cloud Config \n          \n          \n            \n            Server for its configuration add it to the `bootstrap.yml` of the application)", "author": "vcolin7", "createdAt": "2020-10-20T21:31:33Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2OTYxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510269616", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MjU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MjY4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508852687", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n          \n          \n            \n            azure.keyvault.tenantId=<the ID of your Azure tenant>\n          \n          \n            \n            azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n          \n          \n            \n            azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n          \n          \n            \n            server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n          \n          \n            \n            server.ssl.key-store-type=AzureKeyVault\n          \n          \n            \n            azure.keyvault.uri=<the URI of the Azure Key Vault to use>\n          \n          \n            \n            azure.keyvault.tenantId=<the ID of your Azure tenant>\n          \n          \n            \n            azure.keyvault.clientId=<the client ID with access to Azure Key Vault>\n          \n          \n            \n            azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n          \n          \n            \n            server.ssl.key-alias=<the name of the certificate in Azure Key Vault to use>\n          \n          \n            \n            server.ssl.key-store-type=AzureKeyVault", "author": "vcolin7", "createdAt": "2020-10-20T21:31:51Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NTEzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510155137", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MjY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Mjc3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508852775", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note: make sure the client ID has access to the Azure KeyVault to access\n          \n          \n            \n            Note: make sure the client ID has access to the Azure Key Vault to access", "author": "vcolin7", "createdAt": "2020-10-20T21:32:01Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NjczOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510156738", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Mjc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Mjk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508852941", "bodyText": "nit; Adding some visual help for readers.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To use the starter for client side SSL, you will need to add the following to\n          \n          \n            \n            your application.properties (if the application is using Spring Cloud Config \n          \n          \n            \n            Server for its configuration add it to the bootstrap.yml of the application)\n          \n          \n            \n            To use the starter for client side SSL, you will need to add the following to\n          \n          \n            \n            your `application.properties` (if the application is using Spring Cloud Config \n          \n          \n            \n            Server for its configuration add it to the `bootstrap.yml` of the application)", "author": "vcolin7", "createdAt": "2020-10-20T21:32:21Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2OTQ0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510269445", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Mjk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Mjk5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508852996", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n          \n          \n            \n            azure.keyvault.uri=<the URI of the Azure Key Vault to use>", "author": "vcolin7", "createdAt": "2020-10-20T21:32:29Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NTI4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510155288", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Mjk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzA4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508853084", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note: make sure the managed identity has access to the Azure KeyVault to access\n          \n          \n            \n            Note: make sure the managed identity has access to the Azure Key Vault to access", "author": "vcolin7", "createdAt": "2020-10-20T21:32:38Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NTQzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510155437", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzIxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508853216", "bodyText": "nit; Adding some visual help for readers.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you are using RestTemplate use code similar to the example below.\n          \n          \n            \n            If you are using `RestTemplate` use code similar to the example below.", "author": "vcolin7", "createdAt": "2020-10-20T21:32:53Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2Mjc2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510262766", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508853609", "bodyText": "nit; Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HttpComponentsClientHttpRequestFactory requestFactory =\n          \n          \n            \n                                    new HttpComponentsClientHttpRequestFactory();\n          \n          \n            \n                    HttpComponentsClientHttpRequestFactory requestFactory =\n          \n          \n            \n                        new HttpComponentsClientHttpRequestFactory();", "author": "vcolin7", "createdAt": "2020-10-20T21:33:40Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Mzg2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508853868", "bodyText": "nit; Adding some visual help for readers.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To use the starter for client side SSL, you will need to add the following to\n          \n          \n            \n            your application.properties (if the application is using Spring Cloud Config \n          \n          \n            \n            Server for its configuration add it to the bootstrap.yml of the application)\n          \n          \n            \n            To use the starter for client side SSL, you will need to add the following to\n          \n          \n            \n            your `application.properties` (if the application is using Spring Cloud Config \n          \n          \n            \n            Server for its configuration add it to the `bootstrap.yml` of the application)", "author": "vcolin7", "createdAt": "2020-10-20T21:34:09Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyNDAzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510424031", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T20:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Mzg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDEyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508854125", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n          \n          \n            \n            azure.keyvault.tenantId=<the ID of your Azure tenant>\n          \n          \n            \n            azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n          \n          \n            \n            azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n          \n          \n            \n            ```\n          \n          \n            \n            \n          \n          \n            \n            Note: make sure the client ID has access to the Azure KeyVault to access\n          \n          \n            \n            keys, secrets and certificates.\n          \n          \n            \n            azure.keyvault.uri=<the URI of the Azure Key Vault to use>\n          \n          \n            \n            azure.keyvault.tenantId=<the ID of your Azure tenant>\n          \n          \n            \n            azure.keyvault.clientId=<the client ID with access to Azure Key Vault>\n          \n          \n            \n            azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n          \n      \n    \n    \n  \n\nNote: make sure the client ID has access to the Azure Key Vault to access\nkeys, secrets and certificates.", "author": "vcolin7", "createdAt": "2020-10-20T21:34:45Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NTY0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510155645", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDIxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508854214", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then if you are using RestTemplate use the code below as a starting\n          \n          \n            \n            Then if you are using `RestTemplate` use the code below as a starting", "author": "vcolin7", "createdAt": "2020-10-20T21:34:56Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+Then if you are using RestTemplate use the code below as a starting", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI2MjU4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510262581", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDU5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508854598", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HttpComponentsClientHttpRequestFactory requestFactory =\n          \n          \n            \n                                    new HttpComponentsClientHttpRequestFactory();\n          \n          \n            \n                    HttpComponentsClientHttpRequestFactory requestFactory =\n          \n          \n            \n                        new HttpComponentsClientHttpRequestFactory();", "author": "vcolin7", "createdAt": "2020-10-20T21:35:38Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+Then if you are using RestTemplate use the code below as a starting\n+point:\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        HostnameVerifier allowAll = (String hostName, SSLSession session) -> true;\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext, allowAll);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508854911", "bodyText": "We could avoid repeating some sections in this README like the Maven dependency part and the one for RestTemplate.", "author": "vcolin7", "createdAt": "2020-10-20T21:36:18Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTA4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510235085", "bodyText": "I wrote it this way so the customer does not have to figure out what is relevant for them. They just look for the section applicable to their use case and all the information is there.", "author": "mnriem", "createdAt": "2020-10-22T15:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDk5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508854991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                uri: <the URI of the Azure KeyVault to use>\n          \n          \n            \n                uri: <the URI of the Azure Key Vault to use>", "author": "vcolin7", "createdAt": "2020-10-20T21:36:33Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+Then if you are using RestTemplate use the code below as a starting\n+point:\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        HostnameVerifier allowAll = (String hostName, SSLSession session) -> true;\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext, allowAll);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+## Configuring Spring Cloud Gateway\n+\n+To configure Spring Cloud Gateway for outbound SSL you will need\n+to add the following configuration:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    uri: <the URI of the Azure KeyVault to use>", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NjA2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510156068", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NTMzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508855331", "bodyText": "nit; Adding some visual help for readers.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you are developing you can completely disable the certificate and hostname\n          \n          \n            \n            validation altogether by using the configuration below. Note this is NOT \n          \n          \n            \n            recommended for production!\n          \n          \n            \n            If you are developing you can completely disable the certificate and hostname\n          \n          \n            \n            validation altogether by using the configuration below. **Note this is NOT \n          \n          \n            \n            recommended for production!**", "author": "vcolin7", "createdAt": "2020-10-20T21:37:04Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+Then if you are using RestTemplate use the code below as a starting\n+point:\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        HostnameVerifier allowAll = (String hostName, SSLSession session) -> true;\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext, allowAll);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+## Configuring Spring Cloud Gateway\n+\n+To configure Spring Cloud Gateway for outbound SSL you will need\n+to add the following configuration:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    uri: <the URI of the Azure KeyVault to use>\n+    jca: \n+      overrideTrustManagerFactory: true\n+```\n+\n+Note: if any of your routes point to a service where the FQDN does not match the\n+issued certificate you will need to disable hostname verification. This will\n+be the case if your service is dynamically assigned a hostname by the hosting\n+platform you use. In this particular case add the configuration below to disable\n+hostname verification:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    jca:\n+      disableHostnameVerification: true\n+```\n+\n+If you are developing you can completely disable the certificate and hostname\n+validation altogether by using the configuration below. Note this is NOT \n+recommended for production!", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MjIwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510252205", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NTMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NTUzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508855533", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To create an Azure KeyVault use the command line below:\n          \n          \n            \n            To create an Azure Key Vault use the command line below:", "author": "vcolin7", "createdAt": "2020-10-20T21:37:30Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+Then if you are using RestTemplate use the code below as a starting\n+point:\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        HostnameVerifier allowAll = (String hostName, SSLSession session) -> true;\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext, allowAll);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+## Configuring Spring Cloud Gateway\n+\n+To configure Spring Cloud Gateway for outbound SSL you will need\n+to add the following configuration:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    uri: <the URI of the Azure KeyVault to use>\n+    jca: \n+      overrideTrustManagerFactory: true\n+```\n+\n+Note: if any of your routes point to a service where the FQDN does not match the\n+issued certificate you will need to disable hostname verification. This will\n+be the case if your service is dynamically assigned a hostname by the hosting\n+platform you use. In this particular case add the configuration below to disable\n+hostname verification:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    jca:\n+      disableHostnameVerification: true\n+```\n+\n+If you are developing you can completely disable the certificate and hostname\n+validation altogether by using the configuration below. Note this is NOT \n+recommended for production!\n+\n+```yaml\n+spring:\n+  cloud:\n+    gateway:\n+      httpclient:\n+        ssl:\n+          useInsecureTrustManager: true\n+```\n+\n+## Creating an Azure Key Vault\n+\n+To create an Azure KeyVault use the command line below:", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NjIwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510156206", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NTc0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508855744", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Certificates coming from Azure KeyVault take precedence over \n          \n          \n            \n            2. Certificates coming from Azure Key Vault take precedence over", "author": "vcolin7", "createdAt": "2020-10-20T21:37:57Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+Then if you are using RestTemplate use the code below as a starting\n+point:\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        HostnameVerifier allowAll = (String hostName, SSLSession session) -> true;\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext, allowAll);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+## Configuring Spring Cloud Gateway\n+\n+To configure Spring Cloud Gateway for outbound SSL you will need\n+to add the following configuration:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    uri: <the URI of the Azure KeyVault to use>\n+    jca: \n+      overrideTrustManagerFactory: true\n+```\n+\n+Note: if any of your routes point to a service where the FQDN does not match the\n+issued certificate you will need to disable hostname verification. This will\n+be the case if your service is dynamically assigned a hostname by the hosting\n+platform you use. In this particular case add the configuration below to disable\n+hostname verification:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    jca:\n+      disableHostnameVerification: true\n+```\n+\n+If you are developing you can completely disable the certificate and hostname\n+validation altogether by using the configuration below. Note this is NOT \n+recommended for production!\n+\n+```yaml\n+spring:\n+  cloud:\n+    gateway:\n+      httpclient:\n+        ssl:\n+          useInsecureTrustManager: true\n+```\n+\n+## Creating an Azure Key Vault\n+\n+To create an Azure KeyVault use the command line below:\n+\n+```shell\n+  export KEY_VAULT=mykeyvault\n+  export RESOURCE_GROUP=myresourcegroup\n+  az keyvault create --name ${KEY_VAULT} -g ${RESOURCE_GROUP}\n+```\n+\n+## Create a self-signed certificate\n+\n+To create a self-signed certificate use the command line below:\n+\n+```shell\n+  export CERTIFICATE_ALIAS=self-signed\n+  az keyvault certificate create --vault-name ${KEY_VAULT} \\\n+    -n ${CERTIFICATE_ALIAS} -p \"$(az keyvault certificate get-default-policy)\"\n+```\n+\n+## Assign a managed identity (to an Azure Spring Cloud application)\n+\n+To assign a managed identity use the command line below:\n+\n+```shell\n+  export SPRING_CLOUD_APP=myspringcloudapp\n+  az spring-cloud app identity assign --name ${SPRING_CLOUD_APP}\n+  export MANAGED_IDENTITY=$(az spring-cloud app show \\\n+    --name ${SPRING_CLOUD_APP} --query identity.principalId --output tsv)\n+```\n+\n+## Grant a managed identity with access to Azure Key Vault\n+\n+To grant access use the command line below:\n+\n+```shell\n+  az keyvault set-policy --name ${KEY_VAULT} \\\n+        --object-id ${MANAGED_IDENTITY} \\\n+        --key-permisssions get list \\\n+        --secret-permissions get list \\\n+        --certificate-permissions get list\n+```\n+\n+## Side-loading certificates\n+\n+This starter allows you to side-load certificates by supplying them as part of\n+the application. \n+\n+To side-load add your certificates to the `src/main/resources/keyvault` folder.\n+\n+Notes: \n+1. The alias (certificate name) is constructed from the filename of the \n+certificate (minus the extension). So if your filename is `mycert.x509` the\n+certificate will be added with the alias of `mycert`. \n+2. Certificates coming from Azure KeyVault take precedence over ", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NjMzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510156338", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NTc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NTk2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508855969", "bodyText": "Let's try to fill these sections out for the next release.", "author": "vcolin7", "createdAt": "2020-10-20T21:38:28Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/README.md", "diffHunk": "@@ -0,0 +1,278 @@\n+# Azure Key Vault Certificates Spring Boot starter \n+\n+## Server side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for server side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+server.ssl.key-alias=<the name of the certificate in Azure KeyVault to use>\n+server.ssl.key-store-type=AzureKeyVault\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+## Client side SSL\n+\n+### Using a managed identity\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+```\n+Note: make sure the managed identity has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+If you are using RestTemplate use code similar to the example below.\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+### Using a client ID and client secret\n+\n+To use the starter for client side SSL, you will need to add the following to\n+your application.properties (if the application is using Spring Cloud Config \n+Server for its configuration add it to the bootstrap.yml of the application)\n+\n+```\n+azure.keyvault.uri=<the URI of the Azure KeyVault to use>\n+azure.keyvault.tenantId=<the ID of your Azure tenant>\n+azure.keyvault.clientId=<the client ID with access to Azure KeyVault>\n+azure.keyvault.clientSecret=<the client secret associated wit the client ID>\n+```\n+\n+Note: make sure the client ID has access to the Azure KeyVault to access\n+keys, secrets and certificates.\n+\n+Add then add the following Maven dependency to your POM file.\n+\n+```xml\n+    <dependency>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    </dependency>\n+```\n+\n+Then if you are using RestTemplate use the code below as a starting\n+point:\n+\n+```java\n+    @Bean\n+    public RestTemplate restTemplate() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"AzureKeyVault\");\n+        SSLContext sslContext = SSLContexts.custom()\n+            .loadTrustMaterial(ks, new TrustSelfSignedStrategy())\n+            .build();\n+\n+        HostnameVerifier allowAll = (String hostName, SSLSession session) -> true;\n+        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext, allowAll);\n+\n+        CloseableHttpClient httpClient = HttpClients.custom()\n+            .setSSLSocketFactory(csf)\n+            .build();\n+\n+        HttpComponentsClientHttpRequestFactory requestFactory =\n+                        new HttpComponentsClientHttpRequestFactory();\n+\n+        requestFactory.setHttpClient(httpClient);\n+        RestTemplate restTemplate = new RestTemplate(requestFactory);\n+        return restTemplate;\n+    }\n+```\n+\n+## Configuring Spring Cloud Gateway\n+\n+To configure Spring Cloud Gateway for outbound SSL you will need\n+to add the following configuration:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    uri: <the URI of the Azure KeyVault to use>\n+    jca: \n+      overrideTrustManagerFactory: true\n+```\n+\n+Note: if any of your routes point to a service where the FQDN does not match the\n+issued certificate you will need to disable hostname verification. This will\n+be the case if your service is dynamically assigned a hostname by the hosting\n+platform you use. In this particular case add the configuration below to disable\n+hostname verification:\n+\n+```yaml\n+azure:\n+  keyvault:\n+    jca:\n+      disableHostnameVerification: true\n+```\n+\n+If you are developing you can completely disable the certificate and hostname\n+validation altogether by using the configuration below. Note this is NOT \n+recommended for production!\n+\n+```yaml\n+spring:\n+  cloud:\n+    gateway:\n+      httpclient:\n+        ssl:\n+          useInsecureTrustManager: true\n+```\n+\n+## Creating an Azure Key Vault\n+\n+To create an Azure KeyVault use the command line below:\n+\n+```shell\n+  export KEY_VAULT=mykeyvault\n+  export RESOURCE_GROUP=myresourcegroup\n+  az keyvault create --name ${KEY_VAULT} -g ${RESOURCE_GROUP}\n+```\n+\n+## Create a self-signed certificate\n+\n+To create a self-signed certificate use the command line below:\n+\n+```shell\n+  export CERTIFICATE_ALIAS=self-signed\n+  az keyvault certificate create --vault-name ${KEY_VAULT} \\\n+    -n ${CERTIFICATE_ALIAS} -p \"$(az keyvault certificate get-default-policy)\"\n+```\n+\n+## Assign a managed identity (to an Azure Spring Cloud application)\n+\n+To assign a managed identity use the command line below:\n+\n+```shell\n+  export SPRING_CLOUD_APP=myspringcloudapp\n+  az spring-cloud app identity assign --name ${SPRING_CLOUD_APP}\n+  export MANAGED_IDENTITY=$(az spring-cloud app show \\\n+    --name ${SPRING_CLOUD_APP} --query identity.principalId --output tsv)\n+```\n+\n+## Grant a managed identity with access to Azure Key Vault\n+\n+To grant access use the command line below:\n+\n+```shell\n+  az keyvault set-policy --name ${KEY_VAULT} \\\n+        --object-id ${MANAGED_IDENTITY} \\\n+        --key-permisssions get list \\\n+        --secret-permissions get list \\\n+        --certificate-permissions get list\n+```\n+\n+## Side-loading certificates\n+\n+This starter allows you to side-load certificates by supplying them as part of\n+the application. \n+\n+To side-load add your certificates to the `src/main/resources/keyvault` folder.\n+\n+Notes: \n+1. The alias (certificate name) is constructed from the filename of the \n+certificate (minus the extension). So if your filename is `mycert.x509` the\n+certificate will be added with the alias of `mycert`. \n+2. Certificates coming from Azure KeyVault take precedence over \n+side-loaded certificates.\n+\n+## Testing the current version under development \n+\n+If you want to test the current version under development you will have to\n+\n+1. Build and install the [Microsoft Azure JCA Provider]<!--(../../keyvault/azure-security-keyvault-jca/README.md)--> for KeyVault\n+1. Build and install this starter.\n+\n+To build and install the starter use the following command line:\n+\n+```\n+  mvn clean install -DskipTests=true\n+```\n+\n+\n+# Azure KeyVault Certificates client library for Java\n+\n+# Getting started\n+\n+# Key concepts\n+\n+# Examples\n+\n+# Troubleshooting\n+\n+# Next steps\n+\n+# Contributing", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NzM2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508857368", "bodyText": "I noticed the Key Vault Secrets Spring Boot Starter does not make use of the Revapi plugin. Should we consider adding it there?", "author": "vcolin7", "createdAt": "2020-10-20T21:41:23Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/pom.xml", "diffHunk": "@@ -0,0 +1,185 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+  \n+    <parent>\n+        <groupId>com.azure</groupId>\n+        <artifactId>azure-client-sdk-parent</artifactId>\n+        <version>1.7.0</version> <!-- {x-version-update;com.azure:azure-client-sdk-parent;current} -->\n+        <relativePath>../../parents/azure-client-sdk-parent</relativePath>\n+    </parent>\n+    \n+    <groupId>com.azure.spring</groupId>\n+    <artifactId>azure-spring-boot-starter-keyvault-certificates</artifactId>\n+    <version>3.0.0-beta.1</version> <!-- {x-version-update;com.azure.spring:azure-spring-boot-starter-keyvault-certificates;current} -->\n+\n+    <name>Azure Key Vault Certificates Spring Boot Starter</name>\n+    <description>Spring Boot Starter supporting Azure Key Vault Certificates</description>\n+    <url>https://github.com/Azure/azure-sdk-for-java</url>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter</artifactId>\n+            <version>2.3.3.RELEASE</version> <!-- {x-version-update;org.springframework.boot:spring-boot-starter;external_dependency} -->\n+        </dependency>\n+        <dependency>\n+            <groupId>org.springframework.boot</groupId>\n+            <artifactId>spring-boot-starter-validation</artifactId>\n+            <version>2.3.3.RELEASE</version> <!-- {x-version-update;org.springframework.boot:spring-boot-starter-validation;external_dependency} -->\n+        </dependency>\n+        <dependency>\n+            <groupId>com.azure</groupId>\n+            <artifactId>azure-security-keyvault-jca</artifactId>\n+            <version>1.0.0-beta.1</version> <!-- {x-version-update;com.azure:azure-security-keyvault-jca;current} -->\n+        </dependency>\n+    </dependencies>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-enforcer-plugin</artifactId>\n+                <version>3.0.0-M3</version> <!-- {x-version-update;org.apache.maven.plugins:maven-enforcer-plugin;external_dependency} -->\n+                <configuration>\n+                    <rules>\n+                        <bannedDependencies>\n+                            <includes>\n+                                <include>org.springframework.boot:spring-boot-starter:[2.3.3.RELEASE]</include> <!-- {x-include-update;org.springframework.boot:spring-boot-starter;external_dependency} -->\n+                                <include>org.springframework.boot:spring-boot-starter-validation:[2.3.3.RELEASE]</include> <!-- {x-include-update;org.springframework.boot:spring-boot-starter-validation;external_dependency} -->\n+                            </includes>\n+                        </bannedDependencies>\n+                    </rules>\n+                </configuration>\n+            </plugin>\n+            <!-- BEGIN: Empty Java Doc & Sources -->\n+            <!-- The following code will generate an empty javadoc with just a README.md. This is necessary\n+                 to pass the required checks on Maven. The way this works is by setting the classesDirectory\n+                 to a directory that only contains the README.md, which we need to copy. If the classesDirectory\n+                 is set to the root, where the README.md lives, it still won't have javadocs but the jar file\n+                 will contain a bunch of files that shouldn't be there. The faux sources directory is deleted\n+                 and recreated with the README.md being copied every time to guarantee that, when building locally,\n+                 it'll have the latest copy of the README.md file.\n+            -->\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-javadoc-plugin</artifactId>\n+                <version>3.1.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-javadoc-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <id>attach-javadocs</id>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                        <configuration>\n+                            <skip>true</skip>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-jar-plugin</artifactId>\n+                <version>3.1.2</version> <!-- {x-version-update;org.apache.maven.plugins:maven-jar-plugin;external_dependency} -->\n+                <executions>\n+                    <!-- BEGIN: Empty Java Doc -->\n+                    <execution>\n+                        <id>empty-javadoc-jar-with-readme</id>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                        <configuration>\n+                            <classifier>javadoc</classifier>\n+                            <classesDirectory>${project.basedir}/javadocTemp</classesDirectory>\n+                        </configuration>\n+                    </execution>\n+                    <!-- END: Empty Java Doc -->\n+                    <!-- BEGIN: Empty Sources -->\n+                    <execution>\n+                        <id>empty-sources-jar-with-readme</id>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>jar</goal>\n+                        </goals>\n+                        <configuration>\n+                            <classifier>sources</classifier>\n+                            <classesDirectory>${project.basedir}/sourceTemp</classesDirectory>\n+                        </configuration>\n+                    </execution>\n+                    <!-- END: Empty Sources -->\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-antrun-plugin</artifactId>\n+                <version>1.8</version> <!-- {x-version-update;org.apache.maven.plugins:maven-antrun-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <id>copy-readme-to-javadocTemp</id>\n+                        <phase>prepare-package</phase>\n+                        <configuration>\n+                            <target>\n+                                <echo>Deleting existing ${project.basedir}/javadocTemp</echo>\n+                                <delete includeEmptyDirs=\"true\" quiet=\"true\">\n+                                    <fileset dir=\"${project.basedir}/javadocTemp\"/>\n+                                </delete>\n+                                <echo>Copying ${project.basedir}/README.md to\n+                                    ${project.basedir}/javadocTemp/README.md\n+                                </echo>\n+                                <copy file=\"${project.basedir}/README.md\" tofile=\"${project.basedir}/javadocTemp/README.md\"/>\n+                            </target>\n+                        </configuration>\n+                        <goals>\n+                            <goal>run</goal>\n+                        </goals>\n+                    </execution>\n+                    <execution>\n+                        <id>copy-readme-to-sourceTemp</id>\n+                        <phase>prepare-package</phase>\n+                        <configuration>\n+                            <target>\n+                                <echo>Deleting existing ${project.basedir}/sourceTemp</echo>\n+                                <delete includeEmptyDirs=\"true\" quiet=\"true\">\n+                                    <fileset dir=\"${project.basedir}/sourceTemp\"/>\n+                                </delete>\n+                                <echo>Copying ${project.basedir}/README.md to\n+                                    ${project.basedir}/sourceTemp/README.md\n+                                </echo>\n+                                <copy file=\"${project.basedir}/README.md\" tofile=\"${project.basedir}/sourceTemp/README.md\"/>\n+                            </target>\n+                        </configuration>\n+                        <goals>\n+                            <goal>run</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-source-plugin</artifactId>\n+                <version>3.0.1</version> <!-- {x-version-update;org.apache.maven.plugins:maven-source-plugin;external_dependency} -->\n+                <executions>\n+                    <execution>\n+                        <id>attach-sources</id>\n+                        <phase>none</phase> <!-- The way to skip the sources attach is to set the phase to none, the skip config doesn't work for sources -->\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <!-- END: Empty Java Doc & Sources -->\n+            <plugin>\n+                <groupId>org.revapi</groupId>\n+                <artifactId>revapi-maven-plugin</artifactId>", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Nzc2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508857763", "bodyText": "This logger is not used in the class at all.", "author": "vcolin7", "createdAt": "2020-10-20T21:42:12Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/src/main/java/com/azure/spring/security/keyvault/certificates/starter/KeyVaultCertificatesEnvironmentPostProcessor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.spring.security.keyvault.certificates.starter;\n+\n+import com.azure.security.keyvault.jca.KeyVaultJcaProvider;\n+import com.azure.security.keyvault.jca.KeyVaultTrustManagerFactoryProvider;\n+\n+import java.security.Security;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.env.EnvironmentPostProcessor;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.core.env.ConfigurableEnvironment;\n+import org.springframework.core.env.MutablePropertySources;\n+import org.springframework.core.env.PropertiesPropertySource;\n+\n+import static org.springframework.core.Ordered.LOWEST_PRECEDENCE;\n+\n+@Order(LOWEST_PRECEDENCE)\n+public class KeyVaultCertificatesEnvironmentPostProcessor implements EnvironmentPostProcessor {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultCertificatesEnvironmentPostProcessor.class.getName());", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2MzI2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511163264", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Nzc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTE0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508859140", "bodyText": "nit; Making things prettier.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> {\n          \n          \n            \n                                return true;\n          \n          \n            \n                            });\n          \n          \n            \n                            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);", "author": "vcolin7", "createdAt": "2020-10-20T21:45:12Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/src/main/java/com/azure/spring/security/keyvault/certificates/starter/KeyVaultCertificatesEnvironmentPostProcessor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.spring.security.keyvault.certificates.starter;\n+\n+import com.azure.security.keyvault.jca.KeyVaultJcaProvider;\n+import com.azure.security.keyvault.jca.KeyVaultTrustManagerFactoryProvider;\n+\n+import java.security.Security;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.env.EnvironmentPostProcessor;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.core.env.ConfigurableEnvironment;\n+import org.springframework.core.env.MutablePropertySources;\n+import org.springframework.core.env.PropertiesPropertySource;\n+\n+import static org.springframework.core.Ordered.LOWEST_PRECEDENCE;\n+\n+@Order(LOWEST_PRECEDENCE)\n+public class KeyVaultCertificatesEnvironmentPostProcessor implements EnvironmentPostProcessor {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultCertificatesEnvironmentPostProcessor.class.getName());\n+\n+    @Override\n+    public void postProcessEnvironment(ConfigurableEnvironment environment,\n+                                       SpringApplication application) {\n+\n+        Properties systemProperties = System.getProperties();\n+\n+        String uri = environment.getProperty(\"azure.keyvault.uri\");\n+        if (uri != null) {\n+            systemProperties.put(\"azure.keyvault.uri\", uri);\n+\n+            String tenantId = environment.getProperty(\"azure.keyvault.tenantId\");\n+            if (tenantId != null) {\n+                systemProperties.put(\"azure.keyvault.tenantId\", tenantId);\n+            }\n+\n+            String clientId = environment.getProperty(\"azure.keyvault.clientId\");\n+            if (clientId != null) {\n+                systemProperties.put(\"azure.keyvault.clientId\", clientId);\n+            }\n+\n+            String clientSecret = environment.getProperty(\"azure.keyvault.clientSecret\");\n+            if (clientSecret != null) {\n+                systemProperties.put(\"azure.keyvault.clientSecret\", clientSecret);\n+            }\n+\n+            String keyStoreType = environment.getProperty(\"server.ssl.key-store-type\");\n+\n+            if (keyStoreType != null && keyStoreType.equals(\"AzureKeyVault\")) {\n+                MutablePropertySources sources = environment.getPropertySources();\n+                Properties properties = new Properties();\n+                properties.put(\"server.ssl.key-store\", \"classpath:keyvault.dummy\");\n+\n+                try {\n+                    Class.forName(\"org.apache.tomcat.InstanceManager\");\n+                    properties.put(\"server.ssl.key-store-type\", \"DKS\");\n+                } catch (ClassNotFoundException ex) {\n+                }\n+\n+                PropertiesPropertySource propertySource =\n+                        new PropertiesPropertySource(\"KeyStorePropertySource\", properties);\n+                sources.addFirst(propertySource);\n+            }\n+\n+            String trustStoreType = environment.getProperty(\"server.ssl.trust-store-type\");\n+\n+            if (trustStoreType != null && trustStoreType.equals(\"AzureKeyVault\")) {\n+                MutablePropertySources sources = environment.getPropertySources();\n+                Properties properties = new Properties();\n+                properties.put(\"server.ssl.trust-store\", \"classpath:keyvault.dummy\");\n+\n+                try {\n+                    Class.forName(\"org.apache.tomcat.InstanceManager\");\n+                    properties.put(\"server.ssl.trust-store-type\", \"DKS\");\n+                } catch (ClassNotFoundException ex) {\n+                }\n+\n+                PropertiesPropertySource propertySource = \n+                        new PropertiesPropertySource(\"TrustStorePropertySource\", properties);\n+                sources.addFirst(propertySource);\n+            }\n+\n+            KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+            Security.insertProviderAt(provider, 1);\n+\n+            String enabled = environment.getProperty(\"azure.keyvault.jca.overrideTrustManagerFactory\");\n+            if (Boolean.parseBoolean(enabled)) {\n+                KeyVaultTrustManagerFactoryProvider factoryProvider =\n+                    new KeyVaultTrustManagerFactoryProvider();\n+                Security.insertProviderAt(factoryProvider, 1);\n+            }\n+\n+            enabled = environment.getProperty(\"azure.keyvault.jca.disableHostnameVerification\");\n+            if (Boolean.parseBoolean(enabled)) {\n+                HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> {\n+                    return true;\n+                });", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDM1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511150359", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T20:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MTM2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508861360", "bodyText": "I noticed that the all classes that are part of the Key Vault Secrets Spring Boot Starter live in the azure-spring-boot folder under the package com.azure.spring.keyvault, should this be there as well?", "author": "vcolin7", "createdAt": "2020-10-20T21:49:44Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/src/main/java/com/azure/spring/security/keyvault/certificates/starter/KeyVaultCertificatesEnvironmentPostProcessor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.spring.security.keyvault.certificates.starter;\n+\n+import com.azure.security.keyvault.jca.KeyVaultJcaProvider;\n+import com.azure.security.keyvault.jca.KeyVaultTrustManagerFactoryProvider;\n+\n+import java.security.Security;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.env.EnvironmentPostProcessor;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.core.env.ConfigurableEnvironment;\n+import org.springframework.core.env.MutablePropertySources;\n+import org.springframework.core.env.PropertiesPropertySource;\n+\n+import static org.springframework.core.Ordered.LOWEST_PRECEDENCE;\n+\n+@Order(LOWEST_PRECEDENCE)\n+public class KeyVaultCertificatesEnvironmentPostProcessor implements EnvironmentPostProcessor {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MTc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511151793", "bodyText": "@chenrujun @saragluna Can you answer this question?", "author": "mnriem", "createdAt": "2020-10-23T20:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjkxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508862913", "bodyText": "Maybe we can use dummy-value or something else instead (I don't have a better suggestion at the moment). As it stands right now, it is a little ambiguous if what does not matter is the value or the property at all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            server.ssl.key-store-password=doesnotmatter\n          \n          \n            \n            server.ssl.key-password=doesnotmatter\n          \n          \n            \n            server.ssl.trust-store-password=doesnotmatter\n          \n          \n            \n            server.ssl.key-store-password=dummy-value\n          \n          \n            \n            server.ssl.key-password=dummy-value\n          \n          \n            \n            server.ssl.trust-store-password=dummy-value", "author": "vcolin7", "createdAt": "2020-10-20T21:52:58Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/src/main/resources/config/application.properties", "diffHunk": "@@ -0,0 +1,3 @@\n+server.ssl.key-store-password=doesnotmatter\n+server.ssl.key-password=doesnotmatter\n+server.ssl.trust-store-password=doesnotmatter", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}