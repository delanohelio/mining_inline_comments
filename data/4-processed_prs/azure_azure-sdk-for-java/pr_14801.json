{"pr_number": 14801, "pr_title": "Enhance Playback Record Naming", "pr_createdAt": "2020-09-04T00:39:23Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14801", "timeline": [{"oid": "b484605db7da76cf630252978a2f9d707dc4932b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b484605db7da76cf630252978a2f9d707dc4932b", "message": "Add enhanced playback record names", "committedDate": "2020-09-04T00:22:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyNTgyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r483325826", "bodyText": "If playbackRecordName is null, should this fallback to testName?", "author": "srnagar", "createdAt": "2020-09-04T00:46:18Z", "path": "sdk/core/azure-core-test/src/main/java/com/azure/core/test/InterceptorManager.java", "diffHunk": "@@ -96,13 +98,15 @@ public InterceptorManager(String testName, TestMode testMode) {\n      * @throws NullPointerException If {@code testName} is {@code null}.\n      */\n     public InterceptorManager(TestContextManager testContextManager) {\n-        this(testContextManager.getTestName(), testContextManager.getTestMode(), testContextManager.doNotRecordTest());\n+        this(testContextManager.getTestName(), testContextManager.getTestPlaybackRecordingName(),\n+            testContextManager.getTestMode(), testContextManager.doNotRecordTest());\n     }\n \n-    private InterceptorManager(String testName, TestMode testMode, boolean doNotRecord) {\n+    private InterceptorManager(String testName, String playbackRecordName, TestMode testMode, boolean doNotRecord) {\n         Objects.requireNonNull(testName, \"'testName' cannot be null.\");\n \n         this.testName = testName;\n+        this.playbackRecordName = playbackRecordName;", "originalCommit": "b484605db7da76cf630252978a2f9d707dc4932b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMzMjg2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r483332860", "bodyText": "Yes, everything calling into this should be passing testName for playbackRecordName though.", "author": "alzimmermsft", "createdAt": "2020-09-04T01:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyNTgyNg=="}], "type": "inlineReview"}, {"oid": "cba01f7098003e46446faea9cc898d217d8f1674", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cba01f7098003e46446faea9cc898d217d8f1674", "message": "Fixed incorrect conditional and added missing Javadoc", "committedDate": "2020-09-04T01:20:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4Mjg3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r483682873", "bodyText": "I'm used to adding new parameters at the end rather than inserting them in between because this is an \"optional\" parameter.", "author": "conniey", "createdAt": "2020-09-04T15:16:05Z", "path": "sdk/core/azure-core-test/src/main/java/com/azure/core/test/InterceptorManager.java", "diffHunk": "@@ -152,12 +156,36 @@ public InterceptorManager(String testName, Map<String, String> textReplacementRu\n      * @throws UncheckedIOException An existing test session record could not be located or the data could not be\n      * deserialized into an instance of {@link RecordedData}.\n      * @throws NullPointerException If {@code testName} or {@code textReplacementRules} is {@code null}.\n+     * @deprecated Use {@link #InterceptorManager(String, String, Map, boolean)} instead.\n      */\n+    @Deprecated\n     public InterceptorManager(String testName, Map<String, String> textReplacementRules, boolean doNotRecord) {\n+        this(testName, testName, textReplacementRules, doNotRecord);\n+    }\n+\n+    /**\n+     * Creates a new InterceptorManager that replays test session records. It takes a set of {@code\n+     * textReplacementRules}, that can be used by {@link PlaybackClient} to replace values in a {@link\n+     * NetworkCallRecord#getResponse()}.\n+     *\n+     * The test session records are read from: \"<i>session-records/{@code testName}.json</i>\"\n+     *\n+     * @param testName Name of the test.\n+     * @param playbackRecordName Full name of the test including its iteration, used as the playback record name.\n+     * @param textReplacementRules A set of rules to replace text in {@link NetworkCallRecord#getResponse()} when\n+     * playing back network calls.\n+     * @param doNotRecord Flag indicating whether network calls should be record or played back.\n+     * @throws UncheckedIOException An existing test session record could not be located or the data could not be\n+     * deserialized into an instance of {@link RecordedData}.\n+     * @throws NullPointerException If {@code testName} or {@code textReplacementRules} is {@code null}.\n+     */\n+    public InterceptorManager(String testName, String playbackRecordName, Map<String, String> textReplacementRules,", "originalCommit": "cba01f7098003e46446faea9cc898d217d8f1674", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzODMyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r485038322", "bodyText": "Will move the new parameter to the end.", "author": "alzimmermsft", "createdAt": "2020-09-08T16:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4Mjg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MzY5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r483683695", "bodyText": "Do we need this as a method? It's only invoked once.", "author": "conniey", "createdAt": "2020-09-04T15:17:26Z", "path": "sdk/core/azure-core-test/src/main/java/com/azure/core/test/InterceptorManager.java", "diffHunk": "@@ -252,23 +275,32 @@ private File getRecordFolder() {\n     /*\n      * Attempts to retrieve the playback file, if it is not found an exception is thrown as playback can't continue.\n      */\n-    private File getRecordFile(String testName) {\n-        File playbackFile = new File(getRecordFolder(), testName + \".json\");\n+    private File getRecordFile() {\n+        File playbackFile = new File(getRecordFolder(), playbackRecordName + \".json\");\n+        File oldPlaybackFile = new File(getRecordFolder(), testName + \".json\");\n \n-        if (!playbackFile.exists()) {\n+        if (!playbackFile.exists() && !oldPlaybackFile.exists()) {\n             throw logger.logExceptionAsError(new RuntimeException(String.format(\n-                \"Missing playback file. File path: %s. \", playbackFile.getPath())));\n+                \"Missing both new and old playback files. Files are %s and %s.\", playbackFile.getPath(),\n+                oldPlaybackFile.getPath())));\n         }\n \n-        logger.info(\"==> Playback file path: \" + playbackFile.getPath());\n-        return playbackFile;\n+        if (playbackFile.exists()) {\n+            logger.info(\"==> Playback file path: {}\", playbackFile.getPath());\n+            return playbackFile;\n+        } else {\n+            logger.info(\"==> Playback file path: {}\", oldPlaybackFile.getPath());\n+            return oldPlaybackFile;\n+        }\n     }\n \n-    private void writeDataToFile() throws IOException {\n-        ObjectMapper mapper = new ObjectMapper();\n-        mapper.enable(SerializationFeature.INDENT_OUTPUT);\n-        File recordFile = createRecordFile(testName);\n-        mapper.writeValue(recordFile, recordedData);\n+    private void writeDataToFile() {", "originalCommit": "cba01f7098003e46446faea9cc898d217d8f1674", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzODQ2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r485038463", "bodyText": "This can be inlined.", "author": "alzimmermsft", "createdAt": "2020-09-08T16:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MzY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4Mzc3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r483683771", "bodyText": "nit: empty line", "author": "conniey", "createdAt": "2020-09-04T15:17:35Z", "path": "sdk/core/azure-core-test/src/main/java/com/azure/core/test/InterceptorManager.java", "diffHunk": "@@ -252,23 +275,32 @@ private File getRecordFolder() {\n     /*\n      * Attempts to retrieve the playback file, if it is not found an exception is thrown as playback can't continue.\n      */\n-    private File getRecordFile(String testName) {\n-        File playbackFile = new File(getRecordFolder(), testName + \".json\");\n+    private File getRecordFile() {\n+        File playbackFile = new File(getRecordFolder(), playbackRecordName + \".json\");\n+        File oldPlaybackFile = new File(getRecordFolder(), testName + \".json\");\n \n-        if (!playbackFile.exists()) {\n+        if (!playbackFile.exists() && !oldPlaybackFile.exists()) {\n             throw logger.logExceptionAsError(new RuntimeException(String.format(\n-                \"Missing playback file. File path: %s. \", playbackFile.getPath())));\n+                \"Missing both new and old playback files. Files are %s and %s.\", playbackFile.getPath(),\n+                oldPlaybackFile.getPath())));\n         }\n \n-        logger.info(\"==> Playback file path: \" + playbackFile.getPath());\n-        return playbackFile;\n+        if (playbackFile.exists()) {\n+            logger.info(\"==> Playback file path: {}\", playbackFile.getPath());\n+            return playbackFile;\n+        } else {\n+            logger.info(\"==> Playback file path: {}\", oldPlaybackFile.getPath());\n+            return oldPlaybackFile;\n+        }\n     }\n \n-    private void writeDataToFile() throws IOException {\n-        ObjectMapper mapper = new ObjectMapper();\n-        mapper.enable(SerializationFeature.INDENT_OUTPUT);\n-        File recordFile = createRecordFile(testName);\n-        mapper.writeValue(recordFile, recordedData);\n+    private void writeDataToFile() {\n+        try {\n+            RECORD_MAPPER.writeValue(createRecordFile(playbackRecordName), recordedData);\n+        } catch (IOException ex) {\n+            throw logger.logExceptionAsError(new UncheckedIOException(\"Unable to write data to playback file.\", ex));\n+        }\n+", "originalCommit": "cba01f7098003e46446faea9cc898d217d8f1674", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzODU0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r485038546", "bodyText": "Will remove", "author": "alzimmermsft", "createdAt": "2020-09-08T16:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4Mzc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4NzU1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r483687556", "bodyText": "Do we need this TEST_ITERATION_CACHE? It is a static variable that never gets cleared. I can imagine if we have a test suite like storage this growing.\nAnother concern is that we use this test iteration to name our files. It assumes that the resolution of the test matrix for paramterised tests will be the same. If the parameters get resolved in a different order, our tests will break and it'll be hard to debug. \"What set of parameters did foo[1].json represent?\"", "author": "conniey", "createdAt": "2020-09-04T15:24:32Z", "path": "sdk/core/azure-core-test/src/main/java/com/azure/core/test/TestContextManager.java", "diffHunk": "@@ -4,21 +4,38 @@\n \n import com.azure.core.test.annotation.DoNotRecord;\n \n+import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import static org.junit.jupiter.api.Assumptions.assumeTrue;\n \n /**\n  * This class handles managing context about a test, such as custom testing annotations and verifying whether the test\n  * is capable of running.\n  */\n+@SuppressWarnings(\"unchecked\")\n public class TestContextManager {\n+    private static final Map<String, AtomicInteger> TEST_ITERATION_CACHE = new ConcurrentHashMap<>();", "originalCommit": "cba01f7098003e46446faea9cc898d217d8f1674", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0MDg2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14801#discussion_r485040866", "bodyText": "Agreed that this is a bit of an issue for parameterized tests. JUnit 5 offers a variable that can be passed into BeforeEach method to get the parameterized iteration but it will throw an exception when used with a test that isn't parameterized. This lead me to choosing this option as the next best available route. Thinking on it more due to this comment I can look to see if the test parameters are accessible in BeforeEach and use them to create a hash that gets appended to the test name instead. I wouldn't go down the route of toStringing the test parameters and appending them as that may lead to long path issues with git on Windows.", "author": "alzimmermsft", "createdAt": "2020-09-08T16:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4NzU1Ng=="}], "type": "inlineReview"}, {"oid": "752cde7d8800d77eecca135843ab7edc5d7bd480", "url": "https://github.com/Azure/azure-sdk-for-java/commit/752cde7d8800d77eecca135843ab7edc5d7bd480", "message": "Merge branch 'master' into AzTest_EnhanceTestingRecording", "committedDate": "2020-09-08T16:35:09Z", "type": "commit"}, {"oid": "376e17b6fb46f1bb4982082e74ad6b979fd1ca14", "url": "https://github.com/Azure/azure-sdk-for-java/commit/376e17b6fb46f1bb4982082e74ad6b979fd1ca14", "message": "Changes based an feedback, updating loading of all HttpClients on the class path", "committedDate": "2020-09-08T18:12:59Z", "type": "commit"}, {"oid": "2aa16a93e56091f44a36e907495a3e7527f1390a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2aa16a93e56091f44a36e907495a3e7527f1390a", "message": "Merged in master", "committedDate": "2020-09-09T16:20:58Z", "type": "commit"}, {"oid": "1e333878244e2042ab1ea32e2b30e6873514e9e3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1e333878244e2042ab1ea32e2b30e6873514e9e3", "message": "Updated to get iteration number from ExtensionContext which includes it as part of its unique ID", "committedDate": "2020-09-09T22:39:33Z", "type": "commit"}]}