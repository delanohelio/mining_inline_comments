{"pr_number": 10940, "pr_title": "Servicebus track2 sync queue up multiple receive calls ", "pr_createdAt": "2020-05-08T02:48:16Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10940", "timeline": [{"oid": "be7f82b19b7381cf34b92bbfd6388ce6db699537", "url": "https://github.com/Azure/azure-sdk-for-java/commit/be7f82b19b7381cf34b92bbfd6388ce6db699537", "message": "First draft implementation", "committedDate": "2020-05-07T22:30:23Z", "type": "commit"}, {"oid": "fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "message": "Queue up the receive request queuest", "committedDate": "2020-05-08T02:47:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNjc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r421906793", "bodyText": "Why is this an atomic reference? If I remember correctly you are synchronizing on a lock. Only one thread can be in the method.", "author": "conniey", "createdAt": "2020-05-08T02:50:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -41,8 +42,11 @@\n         .setIsAutoCompleteEnabled(false)\n         .setMaxAutoLockRenewalDuration(Duration.ZERO);\n \n-    private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageProcessor =\n+    private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageSource =", "originalCommit": "fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzMTIzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422531237", "bodyText": "It is because checkstyle complain, I really do not need atomic reference because I synchronizing.", "author": "hemanttanwar", "createdAt": "2020-05-09T18:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNjc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MzYyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423083622", "bodyText": "What does checkstyle complain about?", "author": "conniey", "createdAt": "2020-05-11T14:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNjc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2NDIzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423264231", "bodyText": "This is the error we get: The variable field 'messageSource ' of class 'implements' should be final. Classes annotated with @ServiceClient are supposed to be immutable. [ServiceClient]\nAnd we can not define it as final, since we need to init it outside of constructor .", "author": "hemanttanwar", "createdAt": "2020-05-11T19:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNjc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwODE4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r421908183", "bodyText": "Why do you need another emitter processor? Processors are useful when it listens upstream and publishes downstream. In this case, you are using it as a sink.", "author": "conniey", "createdAt": "2020-05-08T02:56:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -41,8 +42,11 @@\n         .setIsAutoCompleteEnabled(false)\n         .setMaxAutoLockRenewalDuration(Duration.ZERO);\n \n-    private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageProcessor =\n+    private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageSource =\n         new AtomicReference<>();\n+    private final AtomicReference<EmitterProcessor<SynchronousMessageSubscriber>> workQueueProcessor =", "originalCommit": "fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "41cec1e23d6719dd855e917ee664ff0fb524fe57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/41cec1e23d6719dd855e917ee664ff0fb524fe57", "message": "Improved logging", "committedDate": "2020-05-08T03:00:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxMjMzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r421912334", "bodyText": "These should be done through a sink.", "author": "conniey", "createdAt": "2020-05-08T03:12:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -627,20 +631,40 @@ private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n-            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n \n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n             final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n \n-            if (emitterProcessor == null) {\n-                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+            EmitterProcessor<SynchronousMessageSubscriber> workProcessor = workQueueProcessor.get();\n+            workProcessor.onNext(syncSubscriber);", "originalCommit": "fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9ed2f312f8b421b6165b71871590befd1f30fdae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9ed2f312f8b421b6165b71871590befd1f30fdae", "message": "spot bugs check resolution", "committedDate": "2020-05-08T03:13:58Z", "type": "commit"}, {"oid": "1a3ff03996ebb782302f99b4cb5e73e29d4208db", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1a3ff03996ebb782302f99b4cb5e73e29d4208db", "message": "work in progress", "committedDate": "2020-05-08T18:27:45Z", "type": "commit"}, {"oid": "5c3cf988ac1c65cb1c4d14e6105d1d05fcc47648", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5c3cf988ac1c65cb1c4d14e6105d1d05fcc47648", "message": "Increment package version after release of com.azure azure-messaging-servicebus", "committedDate": "2020-05-08T21:29:37Z", "type": "commit"}, {"oid": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d83193508a88cb3165b18a6df0f9339500c3cd9", "message": "another implementation for multiple receive using BaseSubscriber", "committedDate": "2020-05-09T05:56:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NzY3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422467679", "bodyText": "This can be private static.", "author": "conniey", "createdAt": "2020-05-09T08:10:44Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NzcyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422467720", "bodyText": "Organise variables by final and not.", "author": "conniey", "createdAt": "2020-05-09T08:10:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODIzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422468233", "bodyText": "final", "author": "conniey", "createdAt": "2020-05-09T08:16:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private Disposable timeoutOperation;\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private volatile Subscription subscription;\n+    private long prefetch;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzMDgxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422530818", "bodyText": "I am planning to remove prefetch altogether. We are discussing this on teams.", "author": "hemanttanwar", "createdAt": "2020-05-09T18:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NjI2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423086260", "bodyText": "Why are you planning on removing prefetch? This would be your initial request in hookOnSubscribe", "author": "conniey", "createdAt": "2020-05-11T14:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODMxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422468314", "bodyText": "On subscribing you need to request something or it'll throw a debug message.", "author": "conniey", "createdAt": "2020-05-09T08:17:53Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private Disposable timeoutOperation;\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private volatile Subscription subscription;\n+    private long prefetch;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NzMyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423087326", "bodyText": "I mistook this for the rule about request has to be > 0. However, the documentation suggests hookOnSubscribe is overridden when you want to alter the request.\nhttps://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/BaseSubscriber.java#L80-L82", "author": "conniey", "createdAt": "2020-05-11T14:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MDI4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422470286", "bodyText": "Why just Mono.just(true) and not drainQueue?", "author": "conniey", "createdAt": "2020-05-09T08:39:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private Disposable timeoutOperation;\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private volatile Subscription subscription;\n+    private long prefetch;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;\n+        }\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     *\n+     * @param value Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n+        if (!currentWork.isTerminal()) {\n+            currentWork.next(value);\n+        } else {\n+            logger.error(\"[{}] received message but no subscriber Sequence number [{}].\", currentWork.getId(), value.getMessage().getSequenceNumber());\n+            // throw error since we can not send this to current receive.\n+        }\n+\n+        logger.info(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), value.getMessage().getSequenceNumber());\n+\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n+        }\n+    }\n+\n+\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0 ) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        Disposable drainQueueDisposable = Mono.just(true)", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MTI3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422471276", "bodyText": "or even Mono.empty()", "author": "conniey", "createdAt": "2020-05-09T08:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MDI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUyMTAwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422521005", "bodyText": "I want to trigger dainQueue() asynchronously , specially for multithreaded env.  Mono.empty() would not trigger subscribe", "author": "hemanttanwar", "createdAt": "2020-05-09T17:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MDI4Ng=="}], "type": "inlineReview"}, {"oid": "d9b69e82601a1c39deceef83af4b0c0ca353018d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d9b69e82601a1c39deceef83af4b0c0ca353018d", "message": "continue fix some issues", "committedDate": "2020-05-09T15:57:26Z", "type": "commit"}, {"oid": "5a8a9ece13d1bd205387ad4989715a26d4d957f3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5a8a9ece13d1bd205387ad4989715a26d4d957f3", "message": "added test", "committedDate": "2020-05-09T18:36:07Z", "type": "commit"}, {"oid": "01466200aab7f17b08884c3d2589a1dbcbdca391", "url": "https://github.com/Azure/azure-sdk-for-java/commit/01466200aab7f17b08884c3d2589a1dbcbdca391", "message": "fixing unwanted check", "committedDate": "2020-05-09T18:43:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NDE3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423084174", "bodyText": "The default ctor sets the boolean to false.", "author": "conniey", "createdAt": "2020-05-11T14:33:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NTU5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423085590", "bodyText": "nit: format your document", "author": "conniey", "createdAt": "2020-05-11T14:35:13Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4OTc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423089762", "bodyText": "This is only subscribed to once. The null check is unnecessary.\nhttps://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/BaseSubscriber.java#L146", "author": "conniey", "createdAt": "2020-05-11T14:40:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MDg2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423090861", "bodyText": "We don't need to override dispose. This is done in the basesubscriber. We can hook into hookOnCancel().", "author": "conniey", "createdAt": "2020-05-11T14:42:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;\n+        }\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     *\n+     * @param message Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+\n+        currentWork.next(message);\n+\n+        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n+\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n+        }\n+    }\n+\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0 ) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        drainQueueDisposable = Mono.just(true)\n+            .subscribe(l -> {\n+                drainQueue();\n+            });\n+    }\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        subscription.request(currentWork.getNumberOfEvents());\n+\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (!currentWork.isTerminal()) {\n+                    completeCurrentWork(currentWork);\n+                }\n+            });\n+    }\n+\n+\n+    @Override\n+    protected void hookOnComplete() {\n+        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n+        dispose();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n+        currentWork.error(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        dispose();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void dispose() {\n+        if (isDisposed.getAndSet(true)) {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MTMwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423091309", "bodyText": "nit: format document", "author": "conniey", "createdAt": "2020-05-11T14:43:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;\n+        }\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     *\n+     * @param message Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+\n+        currentWork.next(message);\n+\n+        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n+\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n+        }\n+    }\n+\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0 ) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        drainQueueDisposable = Mono.just(true)\n+            .subscribe(l -> {\n+                drainQueue();\n+            });\n+    }\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        subscription.request(currentWork.getNumberOfEvents());\n+\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (!currentWork.isTerminal()) {\n+                    completeCurrentWork(currentWork);\n+                }\n+            });\n+    }\n+\n+\n+    @Override\n+    protected void hookOnComplete() {\n+        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n+        dispose();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n+        currentWork.error(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        dispose();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void dispose() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        subscription.cancel();\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MTY3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423091677", "bodyText": "The BaseSubscriber takes care of disposing for you. This isn't necessary.", "author": "conniey", "createdAt": "2020-05-11T14:43:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;\n+        }\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     *\n+     * @param message Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+\n+        currentWork.next(message);\n+\n+        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n+\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n+        }\n+    }\n+\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0 ) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        drainQueueDisposable = Mono.just(true)\n+            .subscribe(l -> {\n+                drainQueue();\n+            });\n+    }\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        subscription.request(currentWork.getNumberOfEvents());\n+\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (!currentWork.isTerminal()) {\n+                    completeCurrentWork(currentWork);\n+                }\n+            });\n+    }\n+\n+\n+    @Override\n+    protected void hookOnComplete() {\n+        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n+        dispose();", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MjAwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423092001", "bodyText": "remove indentation.", "author": "conniey", "createdAt": "2020-05-11T14:44:03Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -624,23 +627,23 @@ public void close() {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+                                   FluxSink<ServiceBusReceivedMessageContext> emitter) {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MzcyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423093729", "bodyText": "", "author": "conniey", "createdAt": "2020-05-11T14:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5NDM2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423094365", "bodyText": "SynchronousMessageSubscriber is a better name.", "author": "conniey", "createdAt": "2020-05-11T14:47:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "71cd8d1fce131d9e378b43846e961b794c729e04", "url": "https://github.com/Azure/azure-sdk-for-java/commit/71cd8d1fce131d9e378b43846e961b794c729e04", "message": "REview comments", "committedDate": "2020-05-11T19:02:15Z", "type": "commit"}, {"oid": "452d557230b6e07e2efe64a368002ef933312f54", "url": "https://github.com/Azure/azure-sdk-for-java/commit/452d557230b6e07e2efe64a368002ef933312f54", "message": "Incorporating review comments", "committedDate": "2020-05-11T19:18:25Z", "type": "commit"}, {"oid": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "message": "Removing unused import.", "committedDate": "2020-05-11T19:23:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNTQ3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423325476", "bodyText": "This isn't thread-safe.\nIt's possible two different threads see messageSubscriber == null, and create the same instance of Subscriber. Then the last one wins and the first one is lost.", "author": "conniey", "createdAt": "2020-05-11T21:17:45Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -627,20 +627,20 @@ private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n-            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n-\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n-            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n \n-            if (emitterProcessor == null) {\n-                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n-                messageProcessor.set(emitterProcessor);\n+            SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n+            if (messageSubscriber == null) {\n+                messageSubscriber = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                    .subscribeWith(new SynchronousMessageSubscriber(asyncClient.getReceiverOptions()\n+                        .getPrefetchCount(), work));\n+                synchronousMessageSubscriber.set(messageSubscriber);", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNTgzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423325834", "bodyText": "rename: initWork -> initialWork. It makes it more readable.", "author": "conniey", "createdAt": "2020-05-11T21:18:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNjg1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423326855", "bodyText": "There shouldn't be a need for WIP. onNext occurs serially.", "author": "conniey", "createdAt": "2020-05-11T21:20:27Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        currentWork.next(message);\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMDEzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423330131", "bodyText": "https://github.com/reactive-streams/reactive-streams-jvm#1.3", "author": "conniey", "createdAt": "2020-05-11T21:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODc4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424098786", "bodyText": "Thanks for link, It is helpful. But It is not just onNext(),  also various timeout situation  ( we need to drain work queue after timeout ) and if there another  queueWork(work) request during timeout when where is no more work request in queue.  This is a safeguard against many such condition.", "author": "hemanttanwar", "createdAt": "2020-05-12T23:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNjg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNzQyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423327420", "bodyText": "This can be inside the hookOnNext method. And return if the currentWork is not terminal to save the nested if.", "author": "conniey", "createdAt": "2020-05-11T21:21:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        currentWork.next(message);\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423328162", "bodyText": "Why do we need to drain? We can see if there is a next one and push it.", "author": "conniey", "createdAt": "2020-05-11T21:23:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        currentWork.next(message);\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0) {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODM3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423328374", "bodyText": "Why do we need getError? the sink can complete with the error.", "author": "conniey", "createdAt": "2020-05-11T21:23:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousReceiveWork.java", "diffHunk": "@@ -108,4 +108,12 @@ void error(Throwable error) {\n         this.error = error;\n         emitter.error(error);\n     }\n+\n+    /**\n+     * Indicate is an this work encountered an error.\n+     * @return true if an error occured.\n+     */\n+    Throwable getError() {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423328936", "bodyText": "What if we requested 100 events, only 30 showed up in the timeout period, and the next work item wants 10? This logic will add another 10 credits (making it 80 credits) even though we don't need to add more credits to the link.", "author": "conniey", "createdAt": "2020-05-11T21:24:54Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        currentWork.next(message);\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        drainQueueDisposable = Mono.just(true)\n+            .subscribe(l -> {\n+                drainQueue();\n+            });\n+    }\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+\n+        subscription.request(currentWork.getNumberOfEvents());", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "message": "continue work ...", "committedDate": "2020-05-12T19:14:53Z", "type": "commit"}, {"oid": "d8dd7b6190f0d9a02c3de5bcdcdeaec5a55df0d4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d8dd7b6190f0d9a02c3de5bcdcdeaec5a55df0d4", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into servicebus-track2-sync-queueup-multiple-receive-calls", "committedDate": "2020-05-12T19:18:49Z", "type": "commit"}, {"oid": "39b9a1a6d1bfd9adf54c91fea1a90144cb02f288", "url": "https://github.com/Azure/azure-sdk-for-java/commit/39b9a1a6d1bfd9adf54c91fea1a90144cb02f288", "message": "resolve merge conflict", "committedDate": "2020-05-12T19:40:58Z", "type": "commit"}, {"oid": "f9cc7d2d82c36e62ea253071a1ec5ae29b4f1848", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9cc7d2d82c36e62ea253071a1ec5ae29b4f1848", "message": "Merge branch 'azure-sdk-increment-package-version-servicebus-386162'", "committedDate": "2020-05-12T19:50:47Z", "type": "commit"}, {"oid": "098504141281aae7856365937aa5cd2fa9d0bae8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/098504141281aae7856365937aa5cd2fa9d0bae8", "message": "Added loginc for timeout", "committedDate": "2020-05-12T23:50:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTc5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424099791", "bodyText": "Example: When there is only one receive(2) request and it time out. But we got two messages after that. During this time we also got request for another   receive(2) . In this case we can use this buffer to send the messages and do not need to ask upstream.", "author": "hemanttanwar", "createdAt": "2020-05-12T23:58:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        if (currentWork == null) {\n+            //Boundary condition(timeout cases), buffer the received message for future requests.\n+            bufferMessages.add(message);", "originalCommit": "098504141281aae7856365937aa5cd2fa9d0bae8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d1589a03e33f478d99057de124234c847c25fe37", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d1589a03e33f478d99057de124234c847c25fe37", "message": "timeout and remaining messages to request logic", "committedDate": "2020-05-13T00:22:14Z", "type": "commit"}, {"oid": "3a4b16fd9cc42f7dbc5d746e81ffc8de94e55b6b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a4b16fd9cc42f7dbc5d746e81ffc8de94e55b6b", "message": "merge master", "committedDate": "2020-05-13T00:26:33Z", "type": "commit"}, {"oid": "b67ac9b65651a41709584818e2c3417b6aed44ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b67ac9b65651a41709584818e2c3417b6aed44ca", "message": "Merge branch 'master' of github.com:hemanttanwar/azure-sdk-for-java", "committedDate": "2020-05-13T04:02:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwMzcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424203711", "bodyText": "In the case that two threads are in this, there will be two subscribers in asyncClient and it'll throw. This is what I was hoping to see:\nvar subscriber = synchronousMessageSubscriber.get();\nif (subscriber == null) {\n  var prefetch = asyncClient.getReceiverOptions().getPrefetchCount();\n  var newSubscriber = new SynchronousMessageSubscriber(prefetch, work);\n\n  if (!synchronousMessageSubscriber.compareAndSet(null, newSubscriber)) {\n    newSubscriber.dispose();\n    var existing = synchronousMessageSubscriber.get();\n    existing.queueWork(work);\n  } else {\n    asyncClient.subscribeWith(newSubscriber);\n    newSubscriber.queueWork(work);\n  }\n}", "author": "conniey", "createdAt": "2020-05-13T06:37:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -627,20 +627,22 @@ private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n-            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n-\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n-            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n \n-            if (emitterProcessor == null) {\n-                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n-                messageProcessor.set(emitterProcessor);\n+            SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n+            if (messageSubscriber == null) {\n+                SynchronousMessageSubscriber newMessageSubscriber = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwODIwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424208203", "bodyText": "This can be verbose. It'll get noisy.", "author": "conniey", "createdAt": "2020-05-13T06:48:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwOTIxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424209215", "bodyText": "Space after //: // Boundary....", "author": "conniey", "createdAt": "2020-05-13T06:51:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        if (currentWork == null) {\n+            //Boundary condition(timeout cases), buffer the received message for future requests.", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNjYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424216609", "bodyText": "In the case that this timeout occurs, the completeWork is completed, but it never occurs. So an onNext can happen after this completion. The completeWork will not be null; and it'll try to submit another message to that timed out work.", "author": "conniey", "createdAt": "2020-05-13T07:07:07Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        if (currentWork == null) {\n+            //Boundary condition(timeout cases), buffer the received message for future requests.\n+            bufferMessages.add(message);\n+            return;\n+        }\n+        currentWork.next(message);\n+        remaining.decrementAndGet();\n+\n+        if (currentWork.isTerminal()) {\n+            currentWork.complete();\n+            if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                timeoutOperation.dispose();\n+            }\n+\n+            // Now see if there is more queued up work\n+            currentWork = workQueue.poll();\n+            if (currentWork != null) {\n+\n+                logger.verbose(\"[{}] Picking up next receive request.\", currentWork.getId());\n+\n+                // timer to complete the current in case of timeout trigger\n+                timeoutOperation = getTimeoutOperation();\n+\n+                requestCredits(currentWork.getNumberOfEvents());\n+            } else {\n+                if (wip.decrementAndGet() != 0) {\n+                    logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+                }\n+            }\n+        }\n+    }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        } else {\n+            logger.verbose(\"[{}] No need to request credit. \", currentWork.getId());\n         }\n+\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..\n+        drainQueue();\n+\n+    }\n+\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        long sentFromBuffer = 0;\n+        if (bufferMessages.size() > 0) {\n+            // If  we already have messages in buffer, we should send it first\n+\n+            while (!bufferMessages.isEmpty() || sentFromBuffer < currentWork.getNumberOfEvents()) {\n+                currentWork.next(bufferMessages.poll());\n+                remaining.decrementAndGet();\n+                ++sentFromBuffer;\n+            }\n+            if (sentFromBuffer == currentWork.getNumberOfEvents()) {\n+                currentWork.complete();\n+                logger.verbose(\"[{}] Sent [{}] messages from buffer.\", currentWork.getId(), sentFromBuffer);\n+                drainQueue();\n+            }\n+        }\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = getTimeoutOperation();\n+\n+        requestCredits(currentWork.getNumberOfEvents() - sentFromBuffer);\n+    }\n+\n+    private Disposable getTimeoutOperation() {\n+        return Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (currentWork != null && !currentWork.isTerminal()) {\n+                    logger.verbose(\"[{}] Timeout triggered.\", currentWork.getId());\n+                    currentWork.complete();", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNzExMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424217111", "bodyText": "This isn't how WIP is usually used. WIP is to prevent reentrant onNext/requests which may end up creating a stack overflow.", "author": "conniey", "createdAt": "2020-05-13T07:08:11Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        if (currentWork == null) {\n+            //Boundary condition(timeout cases), buffer the received message for future requests.\n+            bufferMessages.add(message);\n+            return;\n+        }\n+        currentWork.next(message);\n+        remaining.decrementAndGet();\n+\n+        if (currentWork.isTerminal()) {\n+            currentWork.complete();\n+            if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                timeoutOperation.dispose();\n+            }\n+\n+            // Now see if there is more queued up work\n+            currentWork = workQueue.poll();\n+            if (currentWork != null) {\n+\n+                logger.verbose(\"[{}] Picking up next receive request.\", currentWork.getId());\n+\n+                // timer to complete the current in case of timeout trigger\n+                timeoutOperation = getTimeoutOperation();\n+\n+                requestCredits(currentWork.getNumberOfEvents());\n+            } else {\n+                if (wip.decrementAndGet() != 0) {\n+                    logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+                }\n+            }\n+        }\n+    }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        } else {\n+            logger.verbose(\"[{}] No need to request credit. \", currentWork.getId());\n         }\n+\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..\n+        drainQueue();\n+\n+    }\n+\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        long sentFromBuffer = 0;\n+        if (bufferMessages.size() > 0) {\n+            // If  we already have messages in buffer, we should send it first\n+\n+            while (!bufferMessages.isEmpty() || sentFromBuffer < currentWork.getNumberOfEvents()) {\n+                currentWork.next(bufferMessages.poll());\n+                remaining.decrementAndGet();\n+                ++sentFromBuffer;\n+            }\n+            if (sentFromBuffer == currentWork.getNumberOfEvents()) {\n+                currentWork.complete();\n+                logger.verbose(\"[{}] Sent [{}] messages from buffer.\", currentWork.getId(), sentFromBuffer);\n+                drainQueue();\n+            }\n+        }\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = getTimeoutOperation();\n+\n+        requestCredits(currentWork.getNumberOfEvents() - sentFromBuffer);\n+    }\n+\n+    private Disposable getTimeoutOperation() {\n+        return Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (currentWork != null && !currentWork.isTerminal()) {\n+                    logger.verbose(\"[{}] Timeout triggered.\", currentWork.getId());\n+                    currentWork.complete();\n+                }\n+                if (wip.decrementAndGet() != 0) {", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "08c3c870e0ee717089ed409ee11804e7cd891022", "url": "https://github.com/Azure/azure-sdk-for-java/commit/08c3c870e0ee717089ed409ee11804e7cd891022", "message": "Chaging WIP logic", "committedDate": "2020-05-14T08:03:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4ODk3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425488972", "bodyText": "We don't need a lock object anymore:\nprivate void queueWork(int maximumMessageCount, Duration maxWaitTime, FluxSink<ServiceBusReceivedMessageContext> emitter) {\n    final long id = idGenerator.getAndIncrement();\n    final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime, emitter);\n\n    final SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n    if (messageSubscriber == null) {\n        final long prefetch = asyncClient.getReceiverOptions().getPrefetchCount();\n        final SynchronousMessageSubscriber newSubscriber = new SynchronousMessageSubscriber(prefetch, work);\n\n        if (!synchronousMessageSubscriber.compareAndSet(null, newSubscriber)) {\n            newSubscriber.dispose();\n\n            final SynchronousMessageSubscriber existing = synchronousMessageSubscriber.get();\n            existing.queueWork(work);\n        } else {\n            asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(newSubscriber);\n            newSubscriber.queueWork(work);\n        }\n    } else {\n        messageSubscriber.queueWork(work);\n    }\n\n    logger.verbose(\"[{}] Receive request queued up.\", work.getId());\n}", "author": "conniey", "createdAt": "2020-05-14T23:43:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -624,23 +624,28 @@ public void close() {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+                           FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4OTY4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425489681", "bodyText": "Keep indentation.", "author": "conniey", "createdAt": "2020-05-14T23:45:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -624,23 +624,28 @@ public void close() {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+                           FluxSink<ServiceBusReceivedMessageContext> emitter) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MDIxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425490213", "bodyText": "you never use the prefetch:\nsubscription.request(prefetch);", "author": "conniey", "createdAt": "2020-05-14T23:47:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MDM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425490391", "bodyText": "Missing documentation.", "author": "conniey", "createdAt": "2020-05-14T23:48:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwMjI4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425802282", "bodyText": "Why not queue the initial request? You won't need the initialWork as a member variable. And you can use the prefetch.\n    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n        this.prefetch = prefetch;\n        this.workQueue.add(initialWork);\n        // using inititalWork.count + prefetch to figure out how much you should request on a subscription.\n    }\n\n    @Override\n    protected void hookOnSubscribe(Subscription subscription) {\n        this.subscription = subscription;\n        subscription.request(requested);\n    }", "author": "conniey", "createdAt": "2020-05-15T13:29:13Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwNDQ5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425804492", "bodyText": "In general, keep the methods with the same visibility together. I organise visibility of methods in descending visibility (ie. public, package-private, private) because consumers will interact with the public/package-private ones first.\nAs-is, I need to jump around code to reason about what you are trying to do.", "author": "conniey", "createdAt": "2020-05-15T13:32:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        boolean delivered = false;\n+\n+        // Boundary condition(timeout case): if timeout has happened, get next available work.\n+        if (currentWork == null) {\n+            // Now see if there is more queued up work\n+            currentWork = getNextWorkAndRequest();\n+            logger.verbose(\"No current work, Picked up next receive request.\");\n+        }\n+\n+        if (currentWork != null) {\n+            currentWork.next(message);\n+            delivered = true;\n+            remaining.decrementAndGet();\n+            // Check if we have delivered all the messages to current work.\n+            if (currentWork.isTerminal()) {\n+                currentWork.complete();\n+                if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                    timeoutOperation.dispose();\n+                }\n+\n+                // Now see if there is more queued up work\n+                currentWork = getNextWorkAndRequest();\n+                logger.verbose(\"Current work is terminal, Picked up next receive request.\");\n+            }\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork == null) {\n+            if (wip.decrementAndGet() != 0) {\n+                logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+            }\n+            // If message is not delivered to downstream, we will buffer it.\n+            if (!delivered) {\n+                bufferMessages.add(message);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwNjMzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425806336", "bodyText": "The comment I was trying to make about WIP is to use it only for if someone is clearing the queue and to control access to the drainQueue method. You also modify this value in hookOnNext, but never decrement it when we exit the drainQueue method.\n    private void drain() {\n        // If someone is already in this loop, then we are already clearing the queue.\n        if (!wip.compareAndSet(0, 1)) {\n            return;\n        }\n\n        try {\n            drainQueue();\n        } finally {\n            final int decremented = wip.decrementAndGet();\n            if (decremented != 0) {\n                logger.warning(\"There should be 0, but was: {}\", decremented);\n            }\n        }\n    }", "author": "conniey", "createdAt": "2020-05-15T13:36:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        boolean delivered = false;\n+\n+        // Boundary condition(timeout case): if timeout has happened, get next available work.\n+        if (currentWork == null) {\n+            // Now see if there is more queued up work\n+            currentWork = getNextWorkAndRequest();\n+            logger.verbose(\"No current work, Picked up next receive request.\");\n+        }\n+\n+        if (currentWork != null) {\n+            currentWork.next(message);\n+            delivered = true;\n+            remaining.decrementAndGet();\n+            // Check if we have delivered all the messages to current work.\n+            if (currentWork.isTerminal()) {\n+                currentWork.complete();\n+                if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                    timeoutOperation.dispose();\n+                }\n+\n+                // Now see if there is more queued up work\n+                currentWork = getNextWorkAndRequest();\n+                logger.verbose(\"Current work is terminal, Picked up next receive request.\");\n+            }\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork == null) {\n+            if (wip.decrementAndGet() != 0) {\n+                logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+            }\n+            // If message is not delivered to downstream, we will buffer it.\n+            if (!delivered) {\n+                bufferMessages.add(message);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwNzU1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425807554", "bodyText": "There's a lot of logic in this method which will make it hard to debug in the future... why wouldn't the following below work? And have any management of currentWork, or emitting the next work in a single place, inside the drainQueue method.\n    @Override\n    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n        bufferMessages.add(message);\n        drain();\n    }", "author": "conniey", "createdAt": "2020-05-15T13:38:01Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwODE5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425808199", "bodyText": "This timeout operation is not tied to a work item, it's possible that between the currentWork and when this times out, the item has changed.\n    private Disposable getTimeoutOperation(SynchronousReceiveWork work, Duration timeout) {\n        return Mono.delay(timeout).thenReturn(work)\n            .subscribe(l -> {\n                synchronized (currentWorkLock) {\n                    if (currentWork == work) {\n                        work.complete();\n                    }\n                }\n            });\n    }", "author": "conniey", "createdAt": "2020-05-15T13:39:08Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        boolean delivered = false;\n+\n+        // Boundary condition(timeout case): if timeout has happened, get next available work.\n+        if (currentWork == null) {\n+            // Now see if there is more queued up work\n+            currentWork = getNextWorkAndRequest();\n+            logger.verbose(\"No current work, Picked up next receive request.\");\n+        }\n+\n+        if (currentWork != null) {\n+            currentWork.next(message);\n+            delivered = true;\n+            remaining.decrementAndGet();\n+            // Check if we have delivered all the messages to current work.\n+            if (currentWork.isTerminal()) {\n+                currentWork.complete();\n+                if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                    timeoutOperation.dispose();\n+                }\n+\n+                // Now see if there is more queued up work\n+                currentWork = getNextWorkAndRequest();\n+                logger.verbose(\"Current work is terminal, Picked up next receive request.\");\n+            }\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork == null) {\n+            if (wip.decrementAndGet() != 0) {\n+                logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+            }\n+            // If message is not delivered to downstream, we will buffer it.\n+            if (!delivered) {\n+                bufferMessages.add(message);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..\n+        drainQueue();\n+\n+    }\n+\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        long sentFromBuffer = 0;\n+        if (bufferMessages.size() > 0) {\n+            // If  we already have messages in buffer, we should send it first\n+\n+            while (!bufferMessages.isEmpty() || sentFromBuffer < currentWork.getNumberOfEvents()) {\n+                currentWork.next(bufferMessages.poll());\n+                remaining.decrementAndGet();\n+                ++sentFromBuffer;\n+            }\n+            if (sentFromBuffer == currentWork.getNumberOfEvents()) {\n+                currentWork.complete();\n+                logger.verbose(\"[{}] Sent [{}] messages from buffer.\", currentWork.getId(), sentFromBuffer);\n+                drainQueue();\n+            }\n+        }\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = getTimeoutOperation(currentWork.getTimeout());\n+\n+        requestCredits(currentWork.getNumberOfEvents() - sentFromBuffer);\n+    }\n+\n+    private Disposable getTimeoutOperation(Duration timeout) {\n+        return Mono.delay(timeout)", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgxMDc0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425810744", "bodyText": "There are 4 places in which you set currentWork and these can happen asynchronously. It's possible that the work you're referencing here is one that has been cancelled or timed out. Consider a currentWorkLock that synchronises read-write to this variable and the associated timeout operation.\nLooking at other implementations of subscribers and your current implementation, I would put most of the heavy lifting in this method. (ie. checking to see if we have current work, updating it if need be, setting/requesting more work). As it currently is, there are several ways to emit next items and the currentWork is controlled in many places which will be a pain to debug when this fails.", "author": "conniey", "createdAt": "2020-05-15T13:43:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        boolean delivered = false;\n+\n+        // Boundary condition(timeout case): if timeout has happened, get next available work.\n+        if (currentWork == null) {\n+            // Now see if there is more queued up work\n+            currentWork = getNextWorkAndRequest();\n+            logger.verbose(\"No current work, Picked up next receive request.\");\n+        }\n+\n+        if (currentWork != null) {\n+            currentWork.next(message);\n+            delivered = true;\n+            remaining.decrementAndGet();\n+            // Check if we have delivered all the messages to current work.\n+            if (currentWork.isTerminal()) {\n+                currentWork.complete();\n+                if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                    timeoutOperation.dispose();\n+                }\n+\n+                // Now see if there is more queued up work\n+                currentWork = getNextWorkAndRequest();\n+                logger.verbose(\"Current work is terminal, Picked up next receive request.\");\n+            }\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork == null) {\n+            if (wip.decrementAndGet() != 0) {\n+                logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+            }\n+            // If message is not delivered to downstream, we will buffer it.\n+            if (!delivered) {\n+                bufferMessages.add(message);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..\n+        drainQueue();\n+\n+    }\n+\n+\n+    private void drainQueue() {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgxNTg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425815898", "bodyText": "You can look at any of the operators for inspiration.\nhttps://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java#L716", "author": "conniey", "createdAt": "2020-05-15T13:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgxMDc0NA=="}], "type": "inlineReview"}, {"oid": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0361bc1e109b1eb64493ebb2f5186ccc22961891", "message": "Changed logic for draining queue", "committedDate": "2020-05-16T01:00:56Z", "type": "commit"}, {"oid": "77b4001a43b53a4c8e1fb905c95b8f74376bd8cb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/77b4001a43b53a4c8e1fb905c95b8f74376bd8cb", "message": "Changed logic for draining queue", "committedDate": "2020-05-16T01:05:34Z", "type": "commit"}, {"oid": "d473eb5ff8298ca33b7d2c04c6910488c4f5723b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d473eb5ff8298ca33b7d2c04c6910488c4f5723b", "message": " formatting changes", "committedDate": "2020-05-16T01:11:44Z", "type": "commit"}, {"oid": "13ef032c0cad9094bc0fc87d695bb869a69b5277", "url": "https://github.com/Azure/azure-sdk-for-java/commit/13ef032c0cad9094bc0fc87d695bb869a69b5277", "message": " formatting changes", "committedDate": "2020-05-16T01:15:46Z", "type": "commit"}, {"oid": "2e1f98b15f6bef89b9fde4c6e665624ece5beff2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e1f98b15f6bef89b9fde4c6e665624ece5beff2", "message": "removing unwanted flags.git statuys", "committedDate": "2020-05-16T17:33:00Z", "type": "commit"}, {"oid": "7a333f93cf52e3d791e05a0cbede376e48e0870e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7a333f93cf52e3d791e05a0cbede376e48e0870e", "message": "Added lock in ServiceBusReceiverClient", "committedDate": "2020-05-16T17:33:54Z", "type": "commit"}, {"oid": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/64e6b30e6aa48cef93c9a207e002c63c170c04df", "message": "some more optimization", "committedDate": "2020-05-16T17:51:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwOTEwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427409109", "bodyText": "This doesn't need to be synchronised, does it?", "author": "conniey", "createdAt": "2020-05-19T15:49:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -479,7 +477,8 @@ public ServiceBusReceivedMessage peekAt(long sequenceNumber, String sessionId) {\n      *\n      * @throws IllegalArgumentException if {@code maxMessages} or {@code maxWaitTime} is zero or a negative value.\n      */\n-    public IterableStream<ServiceBusReceivedMessageContext> receive(int maxMessages, Duration maxWaitTime) {\n+    public synchronized IterableStream<ServiceBusReceivedMessageContext> receive(int maxMessages,", "originalCommit": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTA4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427411083", "bodyText": "In this case, work is never queued.", "author": "conniey", "createdAt": "2020-05-19T15:52:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -624,23 +623,26 @@ public void close() {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        synchronized (lock) {\n+            FluxSink<ServiceBusReceivedMessageContext> emitter) {\n             final long id = idGenerator.getAndIncrement();\n-            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n-\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n-            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n \n-            if (emitterProcessor == null) {\n-                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n-                messageProcessor.set(emitterProcessor);\n+            SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n+            if (messageSubscriber == null) {\n+                long prefetch = asyncClient.getReceiverOptions().getPrefetchCount();\n+                SynchronousMessageSubscriber newSubscriber = new SynchronousMessageSubscriber(prefetch, work);\n+\n+                if (!synchronousMessageSubscriber.compareAndSet(null, newSubscriber)) {\n+                    newSubscriber.dispose();\n+                    SynchronousMessageSubscriber existing = synchronousMessageSubscriber.get();\n+                    existing.queueWork(work);\n+                } else {\n+                    asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(newSubscriber);", "originalCommit": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3MDQ1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427570453", "bodyText": "When a newSubscriber instance is created , we queue the work.. We can not do after subscribeWith is called because you may receive a message before you have anything in the queue.", "author": "hemanttanwar", "createdAt": "2020-05-19T20:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMzI0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427413246", "bodyText": "Do you need this variable? if the subscription != null, I'll assume there is an upstream.\nAlso, if we call hookonSubscribe twice, it'll stomp over the previous subscription. We should guard against this by only setting it when it is null and erroring when someone wants to set it again.\nYou'll see a setOnce in some of the reactor operations.", "author": "conniey", "createdAt": "2020-05-19T15:55:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,226 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final AtomicLong remaining = new AtomicLong();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n+\n+    private Disposable currentTimeoutOperation;\n+    private SynchronousReceiveWork currentWork;\n+    private boolean subscriberInitialized;\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;", "originalCommit": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MTk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427461940", "bodyText": "Is there any benefit to setting this to null again (and in a few places)? Once a subscription is disposed calling dispose again is a no-op.", "author": "conniey", "createdAt": "2020-05-19T17:07:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,226 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final AtomicLong remaining = new AtomicLong();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n+\n+    private Disposable currentTimeoutOperation;\n+    private SynchronousReceiveWork currentWork;\n+    private boolean subscriberInitialized;\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n+        remaining.addAndGet(requested);\n+        subscription.request(requested);\n+        subscriberInitialized = true;\n+        drain();\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     * @param message Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        bufferMessages.add(message);\n+        drain();\n+    }\n+\n+    /**\n+     * Queue the work to be picked up by drain loop.\n+     * @param work to be queued.\n+     */\n+    void queueWork(SynchronousReceiveWork work) {\n \n         logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n             work.getTimeout());\n+        workQueue.add(work);\n \n-        subscription.request(work.getNumberOfEvents());\n-\n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // Do not drain if another thread want to queue the work before we have subscriber\n+        if (subscriberInitialized) {\n+            drain();\n+        }\n     }\n \n     /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * Drain the work, only one thread can be in this loop at a time.\n      */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        try {\n+            drainQueue();\n+        } finally {\n+            final int decremented = wip.decrementAndGet();\n+            if (decremented != 0) {\n+                logger.warning(\"There should be 0, but was: {}\", decremented);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /***\n+     * Drain the queue using a lock on current work in progress.\n+     */\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        // Acquiring the lock\n+        synchronized (currentWorkLock) {\n+\n+            // Making sure current work not become terminal since last drain queue cycle\n+            if (currentWork != null && currentWork.isTerminal()) {\n+                workQueue.remove(currentWork);\n+                if (currentTimeoutOperation != null & !currentTimeoutOperation.isDisposed()) {\n+                    currentTimeoutOperation.dispose();\n+                }\n+                currentTimeoutOperation = null;", "originalCommit": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MzQxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427463411", "bodyText": "Having a current work is always tied to a timeout operation. Checking currentWork != null should be enough.", "author": "conniey", "createdAt": "2020-05-19T17:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MTk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODAzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427578038", "bodyText": "We might pick currentWork more than one time from workQueue. currentTimeoutOperation ==  null will indicate that are we picking up first time.\nWe do not need to process  currentWork if is picked up second time and no bufferMessages to send to it.\nwhile ((currentWork = workQueue.peek()) != null && (currentTimeoutOperation == null || bufferMessages.size() > 0 )) {\nThe timeout Operation is not removing currentWork from he queue, thus currentWork needs be picked up again, thus we need to threat this different and go in the loop and remove this timeout work. setting currentTimeoutOperation = null indicate this case also.", "author": "hemanttanwar", "createdAt": "2020-05-19T20:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MTk0MA=="}], "type": "inlineReview"}, {"oid": "c9dcdd013c84793cca5626ea95b2254fc57dfbdb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c9dcdd013c84793cca5626ea95b2254fc57dfbdb", "message": "incorporated review comments", "committedDate": "2020-05-20T05:13:00Z", "type": "commit"}, {"oid": "a1c24b38134aef41b034c6a7b99e83e4730bde44", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a1c24b38134aef41b034c6a7b99e83e4730bde44", "message": "removed unwanted files", "committedDate": "2020-05-20T05:14:57Z", "type": "commit"}, {"oid": "510e76c7ffb58e006a09779558d7b01246f054a9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/510e76c7ffb58e006a09779558d7b01246f054a9", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java", "committedDate": "2020-05-20T05:17:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExMDMyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r428110320", "bodyText": "Only thing you need are unit tests. The logic in this subscriber is complex and I can see it being hard to debug.", "author": "conniey", "createdAt": "2020-05-20T15:35:38Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,239 @@\n ", "originalCommit": "a1c24b38134aef41b034c6a7b99e83e4730bde44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b9be8f55b9a372b26d0792a45a199850e8569e3d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9be8f55b9a372b26d0792a45a199850e8569e3d", "message": "Merge master into branch", "committedDate": "2020-05-20T17:42:06Z", "type": "commit"}, {"oid": "fe0486c832e96d3f87e00f7616a95e2a5aa6e9c7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe0486c832e96d3f87e00f7616a95e2a5aa6e9c7", "message": "unit test", "committedDate": "2020-05-22T05:30:28Z", "type": "commit"}, {"oid": "8bea4db595d3cbab0c9409ffa40ce5f4bd098ee9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bea4db595d3cbab0c9409ffa40ce5f4bd098ee9", "message": "adding unit test", "committedDate": "2020-05-22T08:39:33Z", "type": "commit"}]}