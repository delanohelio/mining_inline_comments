{"pr_number": 325, "pr_title": "feat: inline begin transaction", "pr_createdAt": "2020-07-08T14:15:50Z", "pr_url": "https://github.com/googleapis/java-spanner/pull/325", "timeline": [{"oid": "ec5b49e705bd40daed9953ded11d5a470da6fd16", "url": "https://github.com/googleapis/java-spanner/commit/ec5b49e705bd40daed9953ded11d5a470da6fd16", "message": "bench: add benchmarks for inline begin", "committedDate": "2020-07-16T15:17:49Z", "type": "forcePushed"}, {"oid": "9fb15fee2dcf09f672c94b3d353924d64c6b42e9", "url": "https://github.com/googleapis/java-spanner/commit/9fb15fee2dcf09f672c94b3d353924d64c6b42e9", "message": "feat: inline begin tx with first statement", "committedDate": "2020-07-30T13:30:27Z", "type": "commit"}, {"oid": "6b8d9dc0e855f64ef4e145a4d469f70ada2917c4", "url": "https://github.com/googleapis/java-spanner/commit/6b8d9dc0e855f64ef4e145a4d469f70ada2917c4", "message": "feat: support inlining BeginTransaction", "committedDate": "2020-07-30T13:30:27Z", "type": "commit"}, {"oid": "59ff2aa93a4ffebbfed78bc65fa6447220ff0b28", "url": "https://github.com/googleapis/java-spanner/commit/59ff2aa93a4ffebbfed78bc65fa6447220ff0b28", "message": "fix: invalid dml statement can still return tx id", "committedDate": "2020-07-30T13:30:27Z", "type": "commit"}, {"oid": "4d4446f51dede347634b08d20a78ef9b790f0e05", "url": "https://github.com/googleapis/java-spanner/commit/4d4446f51dede347634b08d20a78ef9b790f0e05", "message": "bench: add benchmarks for inline begin", "committedDate": "2020-07-30T13:30:27Z", "type": "commit"}, {"oid": "48a5db577dab88594dd7a823e86bdcfcf40ea75f", "url": "https://github.com/googleapis/java-spanner/commit/48a5db577dab88594dd7a823e86bdcfcf40ea75f", "message": "feat: add inline begin for async runner", "committedDate": "2020-07-30T13:30:27Z", "type": "commit"}, {"oid": "261c9113f3408a627f5899fa808e619400bd41dc", "url": "https://github.com/googleapis/java-spanner/commit/261c9113f3408a627f5899fa808e619400bd41dc", "message": "test: add additional tests and ITs", "committedDate": "2020-07-30T13:30:27Z", "type": "commit"}, {"oid": "af5066978406e106c72a113d2547f6b9309d12ad", "url": "https://github.com/googleapis/java-spanner/commit/af5066978406e106c72a113d2547f6b9309d12ad", "message": "test: add tests for error during tx", "committedDate": "2020-07-30T14:27:38Z", "type": "commit"}, {"oid": "af5066978406e106c72a113d2547f6b9309d12ad", "url": "https://github.com/googleapis/java-spanner/commit/af5066978406e106c72a113d2547f6b9309d12ad", "message": "test: add tests for error during tx", "committedDate": "2020-07-30T14:27:38Z", "type": "forcePushed"}, {"oid": "f30334e839baaf556279e948bb632562627a6461", "url": "https://github.com/googleapis/java-spanner/commit/f30334e839baaf556279e948bb632562627a6461", "message": "test: use statement with same error code on emulator", "committedDate": "2020-07-30T14:43:58Z", "type": "commit"}, {"oid": "a4d2e767239e563af25be5f42a4922b5ef43d410", "url": "https://github.com/googleapis/java-spanner/commit/a4d2e767239e563af25be5f42a4922b5ef43d410", "message": "test: skip test on emulator", "committedDate": "2020-07-30T14:54:49Z", "type": "commit"}, {"oid": "1817afade2005d3a3dbf61e25d096767b2ebfcb3", "url": "https://github.com/googleapis/java-spanner/commit/1817afade2005d3a3dbf61e25d096767b2ebfcb3", "message": "test: constraint error causes transaction to be invalidated", "committedDate": "2020-07-30T18:57:02Z", "type": "commit"}, {"oid": "61cc2072724f908d9eb21bc3cd9ea378d02e9d51", "url": "https://github.com/googleapis/java-spanner/commit/61cc2072724f908d9eb21bc3cd9ea378d02e9d51", "message": "fix: retry transaction if first statements fails and had BeginTransaction option", "committedDate": "2020-07-31T13:50:40Z", "type": "commit"}, {"oid": "3bdff48168636bb1160416e8a635980320a338a6", "url": "https://github.com/googleapis/java-spanner/commit/3bdff48168636bb1160416e8a635980320a338a6", "message": "fix: handle aborted exceptions", "committedDate": "2020-07-31T14:34:47Z", "type": "commit"}, {"oid": "057839f0e173580e9b2542308f71d58a0b19a513", "url": "https://github.com/googleapis/java-spanner/commit/057839f0e173580e9b2542308f71d58a0b19a513", "message": "Merge branch 'master' into inline-begin-tx", "committedDate": "2020-09-16T08:24:57Z", "type": "commit"}, {"oid": "b3148a080e32e9b27c35c056638df865fa13497f", "url": "https://github.com/googleapis/java-spanner/commit/b3148a080e32e9b27c35c056638df865fa13497f", "message": "test: add additional tests for corner cases", "committedDate": "2020-09-16T09:19:13Z", "type": "commit"}, {"oid": "f508bdb182d0694021864ccd0107c9572039e36f", "url": "https://github.com/googleapis/java-spanner/commit/f508bdb182d0694021864ccd0107c9572039e36f", "message": "feat: use single-use tx for idem-potent mutations", "committedDate": "2020-09-16T15:34:26Z", "type": "commit"}, {"oid": "d9e938fb9fc73a44e22e423e90b3ded6ba66148a", "url": "https://github.com/googleapis/java-spanner/commit/d9e938fb9fc73a44e22e423e90b3ded6ba66148a", "message": "fix: remove check for idempotent mutations", "committedDate": "2020-09-17T14:54:38Z", "type": "commit"}, {"oid": "8a28f6122f3576b09da87f4731cb198c250b7106", "url": "https://github.com/googleapis/java-spanner/commit/8a28f6122f3576b09da87f4731cb198c250b7106", "message": "Merge branch 'master' into inline-begin-tx", "committedDate": "2020-09-28T08:24:20Z", "type": "commit"}, {"oid": "bec71d71961701fc1304f9121e9d9b7cae2393d9", "url": "https://github.com/googleapis/java-spanner/commit/bec71d71961701fc1304f9121e9d9b7cae2393d9", "message": "Merge branch 'master' into inline-begin-tx", "committedDate": "2020-10-05T08:09:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNTYwMg==", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r500405602", "bodyText": "This is moved to the createTxnAsync method to be re-usable.", "author": "olavloite", "createdAt": "2020-10-06T15:45:37Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -190,36 +198,7 @@ void ensureTxn() {\n     ApiFuture<Void> ensureTxnAsync() {\n       final SettableApiFuture<Void> res = SettableApiFuture.create();\n       if (transactionId == null || isAborted()) {\n-        span.addAnnotation(\"Creating Transaction\");", "originalCommit": "bec71d71961701fc1304f9121e9d9b7cae2393d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNjc2Nw==", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r500406767", "bodyText": "This block of code is moved to CommitRunnable", "author": "olavloite", "createdAt": "2020-10-06T15:47:12Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -246,87 +258,103 @@ void commit() {\n \n     ApiFuture<Timestamp> commitAsync() {\n       final SettableApiFuture<Timestamp> res = SettableApiFuture.create();\n-      final SettableApiFuture<Void> latch;\n+      final SettableApiFuture<Void> finishOps;\n+      CommitRequest.Builder builder = CommitRequest.newBuilder().setSession(session.getName());\n       synchronized (lock) {\n-        latch = finishedAsyncOperations;\n+        if (transactionIdFuture == null && transactionId == null) {\n+          finishOps = SettableApiFuture.create();\n+          createTxnAsync(finishOps);\n+        } else {\n+          finishOps = finishedAsyncOperations;\n+        }\n+        if (!mutations.isEmpty()) {\n+          List<com.google.spanner.v1.Mutation> mutationsProto = new ArrayList<>();\n+          Mutation.toProto(mutations, mutationsProto);\n+          builder.addAllMutations(mutationsProto);\n+        }\n+        // Ensure that no call to buffer mutations that would be lost can succeed.\n+        mutations = null;\n       }\n-      latch.addListener(", "originalCommit": "bec71d71961701fc1304f9121e9d9b7cae2393d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "07346f02e1974a6800144c7ec03b24a61ed429bd", "url": "https://github.com/googleapis/java-spanner/commit/07346f02e1974a6800144c7ec03b24a61ed429bd", "message": "chore: remove commented code", "committedDate": "2020-10-06T15:55:53Z", "type": "commit"}, {"oid": "2768f69db13c155bbe3ee24b3440c0f3d2b67b67", "url": "https://github.com/googleapis/java-spanner/commit/2768f69db13c155bbe3ee24b3440c0f3d2b67b67", "message": "feat!: remove session pool preparing (#515)\n\n* feat: remove session pool preparing\r\n\r\n* fix: fix integration tests\r\n\r\n* test: fix malformed retry loop in test case\r\n\r\n* fix: review comments", "committedDate": "2020-10-21T06:03:39Z", "type": "commit"}, {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740", "url": "https://github.com/googleapis/java-spanner/commit/b816a6647106da2e346e3efaae4ab6dcc8d84740", "message": "Merge branch 'master' into inline-begin-tx", "committedDate": "2020-10-21T07:36:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTQ5Ng==", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055496", "bodyText": "Suggested change", "author": "yoshi-code-bot", "createdAt": "2020-10-21T07:39:17Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -150,7 +151,15 @@ public void removeListener(Runnable listener) {\n     @GuardedBy(\"lock\")\n     private long retryDelayInMillis = -1L;\n \n-    private volatile ByteString transactionId;\n+    /**\n+     * transactionIdFuture will return the transaction id returned by the first statement in the\n+     * transaction if the BeginTransaction option is included with the first statement of the\n+     * transaction.\n+     */\n+    private volatile SettableApiFuture<ByteString> transactionIdFuture = null;\n+\n+    volatile ByteString transactionId;\n+    ", "originalCommit": "b816a6647106da2e346e3efaae4ab6dcc8d84740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTQ5OQ==", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will be returned.\n          \n          \n            \n                mockSpanner.setExecuteStreamingSqlExecutionTime(\n          \n          \n            \n                    SimulatedExecutionTime.ofStreamException(\n          \n          \n            \n                // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will\n          \n          \n            \n                // be returned.\n          \n          \n            \n                    SimulatedExecutionTime.ofStreamException(Status.DATA_LOSS.asRuntimeException(), 1));", "author": "yoshi-code-bot", "createdAt": "2020-10-21T07:39:17Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/InlineBeginTransactionTest.java", "diffHunk": "@@ -0,0 +1,1155 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+import com.google.api.core.ApiAsyncFunction;\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ApiFutures;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.grpc.testing.LocalChannelProvider;\n+import com.google.cloud.NoCredentials;\n+import com.google.cloud.spanner.AsyncResultSet.CallbackResponse;\n+import com.google.cloud.spanner.AsyncResultSet.ReadyCallback;\n+import com.google.cloud.spanner.AsyncRunner.AsyncWork;\n+import com.google.cloud.spanner.AsyncTransactionManager.AsyncTransactionFunction;\n+import com.google.cloud.spanner.AsyncTransactionManager.AsyncTransactionStep;\n+import com.google.cloud.spanner.AsyncTransactionManager.CommitTimestampFuture;\n+import com.google.cloud.spanner.AsyncTransactionManager.TransactionContextFuture;\n+import com.google.cloud.spanner.MockSpannerServiceImpl.SimulatedExecutionTime;\n+import com.google.cloud.spanner.MockSpannerServiceImpl.StatementResult;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.AbstractMessage;\n+import com.google.protobuf.ListValue;\n+import com.google.spanner.v1.BeginTransactionRequest;\n+import com.google.spanner.v1.CommitRequest;\n+import com.google.spanner.v1.ExecuteBatchDmlRequest;\n+import com.google.spanner.v1.ExecuteSqlRequest;\n+import com.google.spanner.v1.ReadRequest;\n+import com.google.spanner.v1.ResultSetMetadata;\n+import com.google.spanner.v1.RollbackRequest;\n+import com.google.spanner.v1.StructType;\n+import com.google.spanner.v1.StructType.Field;\n+import com.google.spanner.v1.TypeCode;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class InlineBeginTransactionTest {\n+  @Parameter public Executor executor;\n+\n+  @Parameters(name = \"executor = {0}\")\n+  public static Collection<Object[]> data() {\n+    return Arrays.asList(\n+        new Object[][] {\n+          {MoreExecutors.directExecutor()},\n+          {Executors.newSingleThreadExecutor()},\n+          {Executors.newFixedThreadPool(4)}\n+        });\n+  }\n+\n+  private static MockSpannerServiceImpl mockSpanner;\n+  private static Server server;\n+  private static LocalChannelProvider channelProvider;\n+  private static final Statement UPDATE_STATEMENT =\n+      Statement.of(\"UPDATE FOO SET BAR=1 WHERE BAZ=2\");\n+  private static final Statement INVALID_UPDATE_STATEMENT =\n+      Statement.of(\"UPDATE NON_EXISTENT_TABLE SET BAR=1 WHERE BAZ=2\");\n+  private static final long UPDATE_COUNT = 1L;\n+  private static final Statement SELECT1 = Statement.of(\"SELECT 1 AS COL1\");\n+  private static final ResultSetMetadata SELECT1_METADATA =\n+      ResultSetMetadata.newBuilder()\n+          .setRowType(\n+              StructType.newBuilder()\n+                  .addFields(\n+                      Field.newBuilder()\n+                          .setName(\"COL1\")\n+                          .setType(\n+                              com.google.spanner.v1.Type.newBuilder()\n+                                  .setCode(TypeCode.INT64)\n+                                  .build())\n+                          .build())\n+                  .build())\n+          .build();\n+  private static final com.google.spanner.v1.ResultSet SELECT1_RESULTSET =\n+      com.google.spanner.v1.ResultSet.newBuilder()\n+          .addRows(\n+              ListValue.newBuilder()\n+                  .addValues(com.google.protobuf.Value.newBuilder().setStringValue(\"1\").build())\n+                  .build())\n+          .setMetadata(SELECT1_METADATA)\n+          .build();\n+  private static final Statement INVALID_SELECT = Statement.of(\"SELECT * FROM NON_EXISTING_TABLE\");\n+  private static final Statement READ_STATEMENT = Statement.of(\"SELECT ID FROM FOO WHERE 1=1\");\n+\n+  private Spanner spanner;\n+\n+  @BeforeClass\n+  public static void startStaticServer() throws IOException {\n+    mockSpanner = new MockSpannerServiceImpl();\n+    mockSpanner.setAbortProbability(0.0D); // We don't want any unpredictable aborted transactions.\n+    mockSpanner.putStatementResult(StatementResult.update(UPDATE_STATEMENT, UPDATE_COUNT));\n+    mockSpanner.putStatementResult(StatementResult.query(SELECT1, SELECT1_RESULTSET));\n+    mockSpanner.putStatementResult(StatementResult.query(READ_STATEMENT, SELECT1_RESULTSET));\n+    mockSpanner.putStatementResult(\n+        StatementResult.exception(\n+            INVALID_UPDATE_STATEMENT,\n+            Status.INVALID_ARGUMENT\n+                .withDescription(\"invalid update statement\")\n+                .asRuntimeException()));\n+    mockSpanner.putStatementResult(\n+        StatementResult.exception(\n+            INVALID_SELECT,\n+            Status.INVALID_ARGUMENT\n+                .withDescription(\"invalid select statement\")\n+                .asRuntimeException()));\n+\n+    String uniqueName = InProcessServerBuilder.generateName();\n+    server =\n+        InProcessServerBuilder.forName(uniqueName)\n+            // We need to use a real executor for timeouts to occur.\n+            .scheduledExecutorService(new ScheduledThreadPoolExecutor(1))\n+            .addService(mockSpanner)\n+            .build()\n+            .start();\n+    channelProvider = LocalChannelProvider.create(uniqueName);\n+  }\n+\n+  @AfterClass\n+  public static void stopServer() throws InterruptedException {\n+    server.shutdown();\n+    server.awaitTermination();\n+  }\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    mockSpanner.reset();\n+    mockSpanner.removeAllExecutionTimes();\n+    // Create a Spanner instance that will inline BeginTransaction calls. It also has no prepared\n+    // sessions in the pool to prevent session preparing from interfering with test cases.\n+    spanner =\n+        SpannerOptions.newBuilder()\n+            .setProjectId(\"[PROJECT]\")\n+            .setChannelProvider(channelProvider)\n+            .setCredentials(NoCredentials.getInstance())\n+            .build()\n+            .getService();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    spanner.close();\n+    mockSpanner.reset();\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTx() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    return transaction.executeUpdate(UPDATE_STATEMENT);\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxAborted() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    final AtomicBoolean firstAttempt = new AtomicBoolean(true);\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    long res = transaction.executeUpdate(UPDATE_STATEMENT);\n+                    if (firstAttempt.getAndSet(false)) {\n+                      mockSpanner.abortTransaction(transaction);\n+                    }\n+                    return res;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    // We have started 2 transactions, because the first transaction aborted during the commit.\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(2);\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithQuery() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs = transaction.executeQuery(SELECT1)) {\n+                      while (rs.next()) {\n+                        return rs.getLong(0);\n+                      }\n+                    }\n+                    return 0L;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(1L);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithRead() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs =\n+                        transaction.read(\"FOO\", KeySet.all(), Arrays.asList(\"ID\"))) {\n+                      while (rs.next()) {\n+                        return rs.getLong(0);\n+                      }\n+                    }\n+                    return 0L;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(1L);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ReadRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithBatchDml() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long[] updateCounts =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<long[]>() {\n+                  @Override\n+                  public long[] run(TransactionContext transaction) throws Exception {\n+                    return transaction.batchUpdate(\n+                        Arrays.asList(UPDATE_STATEMENT, UPDATE_STATEMENT));\n+                  }\n+                });\n+    assertThat(updateCounts).asList().containsExactly(UPDATE_COUNT, UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithError() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                    }\n+                    return transaction.executeUpdate(UPDATE_STATEMENT);\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    // The update statement will be executed 3 times:\n+    // 1. The invalid update statement will be executed during the first attempt and fail. The\n+    // second update statement will not be executed, as the transaction runner sees that the initial\n+    // statement failed and did not return a valid transaction id.\n+    // 2. The invalid update statement is executed again during the retry.\n+    // 3. The valid update statement is only executed after the first statement succeeded.\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(3);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnFirstStatement_andThenErrorOnBeginTransaction() {\n+    mockSpanner.setBeginTransactionExecutionTime(\n+        SimulatedExecutionTime.ofException(\n+            Status.INTERNAL\n+                .withDescription(\"Begin transaction failed due to an internal error\")\n+                .asRuntimeException()));\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Void>() {\n+                @Override\n+                public Void run(TransactionContext transaction) throws Exception {\n+                  try {\n+                    transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                    fail(\"missing expected exception\");\n+                  } catch (SpannerException e) {\n+                    assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                  }\n+                  return null;\n+                }\n+              });\n+      fail(\"Missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INTERNAL);\n+      assertThat(e.getMessage()).contains(\"Begin transaction failed due to an internal error\");\n+    }\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    // The explicit BeginTransaction RPC failed, so only one transaction was started.\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithUncaughtError() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Long>() {\n+                @Override\n+                public Long run(TransactionContext transaction) throws Exception {\n+                  return transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                }\n+              });\n+      fail(\"missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+    }\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    // No rollback request will be initiated because the client does not receive any transaction id.\n+    assertThat(countRequests(RollbackRequest.class)).isEqualTo(0);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithUncaughtErrorAfterSuccessfulBegin() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Long>() {\n+                @Override\n+                public Long run(TransactionContext transaction) throws Exception {\n+                  // This statement will start a transaction.\n+                  transaction.executeUpdate(UPDATE_STATEMENT);\n+                  // This statement will fail and cause a rollback as the exception is not caught.\n+                  return transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                }\n+              });\n+      fail(\"missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+    }\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(RollbackRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxBatchDmlWithErrorOnFirstStatement() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    Void res =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Void>() {\n+                  @Override\n+                  public Void run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.batchUpdate(\n+                          ImmutableList.of(INVALID_UPDATE_STATEMENT, UPDATE_STATEMENT));\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerBatchUpdateException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                      assertThat(e.getUpdateCounts()).hasLength(0);\n+                    }\n+                    return null;\n+                  }\n+                });\n+    assertThat(res).isNull();\n+    // The first statement failed and could not return a transaction. The entire transaction is\n+    // therefore retried with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxBatchDmlWithErrorOnSecondStatement() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.batchUpdate(\n+                          ImmutableList.of(UPDATE_STATEMENT, INVALID_UPDATE_STATEMENT));\n+                      fail(\"missing expected exception\");\n+                      // The following line is needed as the compiler does not know that this is\n+                      // unreachable.\n+                      return -1L;\n+                    } catch (SpannerBatchUpdateException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                      assertThat(e.getUpdateCounts()).hasLength(1);\n+                      return e.getUpdateCounts()[0];\n+                    }\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    // Although the batch DML returned an error, that error was for the second statement. That means\n+    // that the transaction was started by the first statement.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnStreamingSql() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    Void res =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Void>() {\n+                  @Override\n+                  public Void run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs = transaction.executeQuery(INVALID_SELECT)) {\n+                      while (rs.next()) {}\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                    }\n+                    return null;\n+                  }\n+                });\n+    assertThat(res).isNull();\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnSecondPartialResultSet() {\n+    final Statement statement = Statement.of(\"SELECT * FROM BROKEN_TABLE\");\n+    RandomResultSetGenerator generator = new RandomResultSetGenerator(2);\n+    mockSpanner.putStatementResult(StatementResult.query(statement, generator.generate()));\n+    // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will be returned.\n+    mockSpanner.setExecuteStreamingSqlExecutionTime(\n+        SimulatedExecutionTime.ofStreamException(", "originalCommit": "b816a6647106da2e346e3efaae4ab6dcc8d84740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTUwMg==", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055502", "bodyText": "Suggested change", "author": "yoshi-code-bot", "createdAt": "2020-10-21T07:39:17Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/MockSpannerServiceImpl.java", "diffHunk": "@@ -1917,6 +1917,10 @@ public void waitForLastRequestToBe(Class<? extends AbstractMessage> type, long t\n     }\n   }\n \n+  public List<ByteString> getTransactionsStarted() {\n+    return new ArrayList<>(transactionsStarted);\n+  }\n+  ", "originalCommit": "b816a6647106da2e346e3efaae4ab6dcc8d84740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24ea415052e4af5d258bfdac4eed50a541818cc9", "url": "https://github.com/googleapis/java-spanner/commit/24ea415052e4af5d258bfdac4eed50a541818cc9", "message": "chore: run formatter", "committedDate": "2020-10-21T07:43:41Z", "type": "commit"}, {"oid": "28277ff85aae454614eb14733db99fab8db1dcbc", "url": "https://github.com/googleapis/java-spanner/commit/28277ff85aae454614eb14733db99fab8db1dcbc", "message": "test: fix integration test that relied on data from other test case", "committedDate": "2020-10-21T08:40:31Z", "type": "commit"}]}