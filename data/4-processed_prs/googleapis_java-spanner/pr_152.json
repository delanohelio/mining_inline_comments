{"pr_number": 152, "pr_title": "perf: prepare sessions with r/w tx in-process", "pr_createdAt": "2020-04-14T20:36:55Z", "pr_url": "https://github.com/googleapis/java-spanner/pull/152", "timeline": [{"oid": "9e08ee3d8bc8e53a40f127cc96828759627f0c5a", "url": "https://github.com/googleapis/java-spanner/commit/9e08ee3d8bc8e53a40f127cc96828759627f0c5a", "message": "perf: prepare sessions with r/w tx in-process\n\nPreparing sessions with a read/write transaction using a background\nexecutor works well as long as that executor is not being overloaded.\nWhen the executor has reached its limit, it is more efficient to allow\nthe read/write transaction to be created in-process, as that scales\nwith the number of user threads available, instead of being limited to\nthe fixed thread pool of the background executor.\n\nFixes #151", "committedDate": "2020-04-16T12:24:32Z", "type": "commit"}, {"oid": "9e08ee3d8bc8e53a40f127cc96828759627f0c5a", "url": "https://github.com/googleapis/java-spanner/commit/9e08ee3d8bc8e53a40f127cc96828759627f0c5a", "message": "perf: prepare sessions with r/w tx in-process\n\nPreparing sessions with a read/write transaction using a background\nexecutor works well as long as that executor is not being overloaded.\nWhen the executor has reached its limit, it is more efficient to allow\nthe read/write transaction to be created in-process, as that scales\nwith the number of user threads available, instead of being limited to\nthe fixed thread pool of the background executor.\n\nFixes #151", "committedDate": "2020-04-16T12:24:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyMDI5OQ==", "url": "https://github.com/googleapis/java-spanner/pull/152#discussion_r412620299", "bodyText": "I don't quite understand this. Why is the waiter being added to readWaiters if inProcessPrepare? Aren't we trying to create a read/write session here?\nI suppose I don't understand why it makes a difference if this is done in-process.", "author": "skuruppu", "createdAt": "2020-04-22T02:21:22Z", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -1416,46 +1436,93 @@ PooledSession getReadSession() throws SpannerException {\n   PooledSession getReadWriteSession() {\n     Span span = Tracing.getTracer().getCurrentSpan();\n     span.addAnnotation(\"Acquiring read write session\");\n-    Waiter waiter = null;\n     PooledSession sess = null;\n-    synchronized (lock) {\n-      if (closureFuture != null) {\n-        span.addAnnotation(\"Pool has been closed\");\n-        throw new IllegalStateException(\"Pool has been closed\");\n+    // Loop to retry SessionNotFoundExceptions that might occur during in-process prepare of a\n+    // session.\n+    while (true) {\n+      Waiter waiter = null;\n+      boolean inProcessPrepare = false;\n+      synchronized (lock) {\n+        if (closureFuture != null) {\n+          span.addAnnotation(\"Pool has been closed\");\n+          throw new IllegalStateException(\"Pool has been closed\");\n+        }\n+        if (resourceNotFoundException != null) {\n+          span.addAnnotation(\"Database has been deleted\");\n+          throw SpannerExceptionFactory.newSpannerException(\n+              ErrorCode.NOT_FOUND,\n+              String.format(\n+                  \"The session pool has been invalidated because a previous RPC returned 'Database not found': %s\",\n+                  resourceNotFoundException.getMessage()),\n+              resourceNotFoundException);\n+        }\n+        sess = writePreparedSessions.poll();\n+        if (sess == null) {\n+          if (numSessionsBeingPrepared <= prepareThreadPoolSize) {\n+            if (numSessionsBeingPrepared <= readWriteWaiters.size()) {\n+              PooledSession readSession = readSessions.poll();\n+              if (readSession != null) {\n+                span.addAnnotation(\n+                    \"Acquired read only session. Preparing for read write transaction\");\n+                prepareSession(readSession);\n+              } else {\n+                span.addAnnotation(\"No session available\");\n+                maybeCreateSession();\n+              }\n+            }\n+          } else {\n+            inProcessPrepare = true;\n+            numSessionsInProcessPrepared++;\n+            PooledSession readSession = readSessions.poll();\n+            if (readSession != null) {\n+              // Create a read/write transaction in-process if there is already a queue for prepared\n+              // sessions. This is more efficient than doing it asynchronously, as it scales with\n+              // the number of user threads. The thread pool for asynchronously preparing sessions\n+              // is fixed.\n+              span.addAnnotation(\n+                  \"Acquired read only session. Preparing in-process for read write transaction\");\n+              sess = readSession;\n+            } else {\n+              span.addAnnotation(\"No session available\");\n+              maybeCreateSession();\n+            }\n+          }\n+          if (sess == null) {\n+            waiter = new Waiter();\n+            if (inProcessPrepare) {\n+              readWaiters.add(waiter);\n+            } else {\n+              readWriteWaiters.add(waiter);\n+            }", "originalCommit": "9e08ee3d8bc8e53a40f127cc96828759627f0c5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4NzYyNQ==", "url": "https://github.com/googleapis/java-spanner/pull/152#discussion_r412687625", "bodyText": "I've added a comment on why we add it to readWaiters here.\nThe reasons are:\n\nThe normal prepare process is executed using a background executor with a fixed thread pool. When the work queue for this executor has exceeded the number of threads available in the thread pool, any requester for a read/write session will have to wait for a thread to come available, and then for the prepare to actually be executed. In the meantime, the user thread is just waiting. In those cases, it's more efficient to use the user thread to execute the BeginTransaction RPC, instead of letting it wait for a thread to come available in the thread pool.\nIn this specific case, in addition to the work queue for preparing sessions being longer than the number of threads in the thread pool, there is also no session at all available in the session pool. In that case, it's more efficient to wait for any (read) session to come available, and then execute the BeginTransaction RPC using the user thread, than to wait for both a session to come available, and then for a thread in the thread pool to come available for preparing the session.", "author": "olavloite", "createdAt": "2020-04-22T05:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyMDI5OQ=="}], "type": "inlineReview"}, {"oid": "fcb403db3e798c4f6d8e6aaa7e1bccda89b5ef3e", "url": "https://github.com/googleapis/java-spanner/commit/fcb403db3e798c4f6d8e6aaa7e1bccda89b5ef3e", "message": "merge: merge latest from master", "committedDate": "2020-04-22T05:40:12Z", "type": "commit"}, {"oid": "9baf197f441bde69e6778bd569495703cffd2fd9", "url": "https://github.com/googleapis/java-spanner/commit/9baf197f441bde69e6778bd569495703cffd2fd9", "message": "docs: add comment on why we create a read waiter", "committedDate": "2020-04-22T05:42:43Z", "type": "commit"}]}