{"pr_number": 149, "pr_title": "tests: add test for session distribution", "pr_createdAt": "2020-04-14T13:45:38Z", "pr_url": "https://github.com/googleapis/java-spanner/pull/149", "timeline": [{"oid": "3331cc45ed57ed0e8bf11eb7d92ecdda5d1d1910", "url": "https://github.com/googleapis/java-spanner/commit/3331cc45ed57ed0e8bf11eb7d92ecdda5d1d1910", "message": "tests: add test for session distribution", "committedDate": "2020-04-14T13:40:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNzM2Nw==", "url": "https://github.com/googleapis/java-spanner/pull/149#discussion_r409337367", "bodyText": "Assume that spannerOptions.getNumChannels() returns 4. Does this means that we only have 4 available channels?\nBut why expectedChannels/usedChannelHintss can be [0,1,2,3,...,7]?\nI am just curious about the mocking here:\n                Long channelHint = (Long) options.get(SpannerRpc.Option.CHANNEL_HINT);\n                usedChannelHintss.add(channelHint);\nSpannerRpc.Option.CHANNEL_HINT is just a string. How do we construct the map options and channelHint will be become 0,1,2,3...7?", "author": "hengfengli", "createdAt": "2020-04-16T07:25:33Z", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/SessionClientTest.java", "diffHunk": "@@ -193,6 +195,73 @@ public void onSessionCreateFailure(Throwable t, int createFailureForSessionCount\n     assertThat(usedChannels).containsExactlyElementsIn(expectedChannels);\n   }\n \n+  /**\n+   * Tests that multiple consequtive calls to {@link SessionClient#asyncBatchCreateSessions(int,\n+   * boolean, SessionConsumer)} with distributeOverChannels=false does not distribute one batch over\n+   * multiple channels, but it does assign each new call to a new channel. This means that multiple\n+   * calls to this method will still distribute the total set of sessions over all available\n+   * channels.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  @Test\n+  public void batchCreateSessionsDistributesMultipleRequestsOverChannels() {\n+    DatabaseId db = DatabaseId.of(dbName);\n+    final String sessionName = dbName + \"/sessions/s%d\";\n+    final Map<String, String> labels = Collections.<String, String>emptyMap();\n+    when(spannerOptions.getSessionLabels()).thenReturn(labels);\n+    final Set<Long> usedChannelHintss = Collections.synchronizedSet(new HashSet<Long>());\n+    when(rpc.batchCreateSessions(\n+            Mockito.eq(dbName), Mockito.anyInt(), Mockito.eq(labels), Mockito.anyMap()))\n+        .then(\n+            new Answer<List<com.google.spanner.v1.Session>>() {\n+              @Override\n+              public List<com.google.spanner.v1.Session> answer(InvocationOnMock invocation)\n+                  throws Throwable {\n+                Map<SpannerRpc.Option, Object> options = invocation.getArgumentAt(3, Map.class);\n+                Long channelHint = (Long) options.get(SpannerRpc.Option.CHANNEL_HINT);\n+                usedChannelHintss.add(channelHint);\n+                int sessionCount = invocation.getArgumentAt(1, Integer.class);\n+                List<com.google.spanner.v1.Session> res = new ArrayList<>();\n+                for (int i = 1; i <= sessionCount; i++) {\n+                  res.add(\n+                      com.google.spanner.v1.Session.newBuilder()\n+                          .setName(String.format(sessionName, i))\n+                          .putAllLabels(labels)\n+                          .build());\n+                }\n+                return res;\n+              }\n+            });\n+\n+    final AtomicInteger returnedSessionCount = new AtomicInteger();\n+    SessionConsumer consumer =\n+        new SessionConsumer() {\n+          @Override\n+          public void onSessionReady(SessionImpl session) {\n+            assertThat(session.getName()).startsWith(dbName + \"/sessions/s\");\n+            returnedSessionCount.incrementAndGet();\n+            session.close();\n+          }\n+\n+          @Override\n+          public void onSessionCreateFailure(Throwable t, int createFailureForSessionCount) {}\n+        };\n+    final int numSessions = 10;\n+    final int numBatches = spannerOptions.getNumChannels() * 2;\n+    try (SessionClient client = new SessionClient(spanner, db, new TestExecutorFactory())) {\n+      for (int batch = 0; batch < numBatches; batch++) {\n+        client.asyncBatchCreateSessions(numSessions, false, consumer);\n+      }\n+    }\n+    assertThat(returnedSessionCount.get()).isEqualTo(numSessions * numBatches);\n+    assertThat(usedChannelHintss.size()).isEqualTo(spannerOptions.getNumChannels() * 2);\n+    List<Long> expectedChannels = new ArrayList<>();\n+    for (long l = 0; l < spannerOptions.getNumChannels() * 2; l++) {\n+      expectedChannels.add(l);\n+    }\n+    assertThat(usedChannelHintss).containsExactlyElementsIn(expectedChannels);", "originalCommit": "3331cc45ed57ed0e8bf11eb7d92ecdda5d1d1910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMTE3MQ==", "url": "https://github.com/googleapis/java-spanner/pull/149#discussion_r409431171", "bodyText": "I see.\n\n  \n    \n      java-spanner/google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionClient.java\n    \n    \n         Line 175\n      in\n      9e5a1cd\n    \n    \n    \n    \n\n        \n          \n           private volatile long sessionChannelCounter; \n        \n    \n  \n\n\nThere is an increasing counter in SessionClient. Every time when we call createSession, BatchCreateSessionsRunnable, and sessionWithId, sessionChannelCounter increases to make sure they use different channels.", "author": "hengfengli", "createdAt": "2020-04-16T09:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUxMjgwNg==", "url": "https://github.com/googleapis/java-spanner/pull/149#discussion_r409512806", "bodyText": "Java gRPC uses a channel hint to indicate that a call should be linked to a certain channel. That channel hint can be any long value, and gRPC will automatically bring that back to a certain channel number. The current implementation is channelHint % numChannels, but the SessionClient should not really depend on that (or care about that). The API specifies that any long value is OK, so the SessionClient just assigns a continuously increasing long.", "author": "olavloite", "createdAt": "2020-04-16T12:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNzM2Nw=="}], "type": "inlineReview"}]}