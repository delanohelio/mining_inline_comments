{"pr_number": 4842, "pr_title": "Issue 4808: (SegmentStore) Using BufferViews for Table Segment APIs", "pr_createdAt": "2020-06-02T15:52:29Z", "pr_url": "https://github.com/pravega/pravega/pull/4842", "timeline": [{"oid": "67fb2b5a5cd7069155a31dcc1e0e679c75923239", "url": "https://github.com/pravega/pravega/commit/67fb2b5a5cd7069155a31dcc1e0e679c75923239", "message": "Changed TableStore APIs to accept BufferView instead of ArrayView. This helps reduce the number of times we copy key/values both inbound (from 3 to 1) and outbound (from 2 to 1).\nUnified all implementations of BufferView to have a common equals and hashCode.\nRemoved HashArray - it was made redundant by the change above.\nExtended BufferView.Reader with new method to help reduce number of copies.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-02T15:51:55Z", "type": "commit"}, {"oid": "961cf2badf95fee49ccda26b0e3f6e146c1adb6a", "url": "https://github.com/pravega/pravega/commit/961cf2badf95fee49ccda26b0e3f6e146c1adb6a", "message": "More unit tests for BufferView.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-02T20:19:25Z", "type": "commit"}, {"oid": "88c79715a8004c91233ccdc68ccd191e7b1350d3", "url": "https://github.com/pravega/pravega/commit/88c79715a8004c91233ccdc68ccd191e7b1350d3", "message": "Unit tests for Wire Commands.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-02T21:30:48Z", "type": "commit"}, {"oid": "784f45abf8bbf9838e381d75b7e87c36c531f608", "url": "https://github.com/pravega/pravega/commit/784f45abf8bbf9838e381d75b7e87c36c531f608", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-04T15:47:03Z", "type": "commit"}, {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36", "url": "https://github.com/pravega/pravega/commit/91e7ec130f098b2e2feef28916807da74b54ab36", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-04T15:58:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MzIzMw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435753233", "bodyText": "Nit: extra dot at the end of this line.", "author": "RaulGracia", "createdAt": "2020-06-05T07:58:41Z", "path": "common/src/main/java/io/pravega/common/util/BufferViewBuilder.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * Builder for {@link BufferView} instances..", "originalCommit": "91e7ec130f098b2e2feef28916807da74b54ab36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4MzkzNg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435983936", "bodyText": "fixed", "author": "andreipaduroiu", "createdAt": "2020-06-05T15:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MzIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1NTkwMQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435755901", "bodyText": "From the abstract methods in this class in which this applies, would it make sense to clearly state in the javadoc what of them are expected to be zero-copy and which of them are not? I assume that you have an idea in mind for this, so perhaps this can be written as a guideline for future implementations of this interface. The thing is that, when working with ByteBuffer and ByteBuf, we sometimes have to go to the implementation to see whether an actual copy of the buffer is made or not, which is confusing. It would be great to use in this family of classes (this one and the ones implementing it) an annotation like @ZeroCopy or similar to make users rapidly aware of the costs of the different operations involved in this class.", "author": "RaulGracia", "createdAt": "2020-06-05T08:03:50Z", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -142,14 +154,43 @@ default void release() {\n      */\n     static BufferView wrap(List<BufferView> components) {\n         if (components.size() == 0) {\n-            return new ByteArraySegment(new byte[0]);\n+            return empty();\n         } else if (components.size() == 1) {\n             return components.get(0).slice();\n         } else {\n             return new CompositeBufferView(components);\n         }\n     }\n \n+    /**\n+     * Creates a new {@link BufferViewBuilder} that can be used to construct composite {@link BufferView} instances.\n+     *\n+     * @return A new {@link BufferViewBuilder} with default initial component count.\n+     */\n+    static BufferViewBuilder builder() {", "originalCommit": "91e7ec130f098b2e2feef28916807da74b54ab36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4NTUxMg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435985512", "bodyText": "Some of them are self-explanatory (the ones containing copy in their name). I updated the Javadoc for some of the others to make it clear. I would prefer not to go down the annotation path as it would be something very specific which only applies to this class.", "author": "andreipaduroiu", "createdAt": "2020-06-05T15:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1NTkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MTA1OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435761059", "bodyText": "In our experiments, we normally observe that using stream() heavily is more costly than a plain loop. We need to evaluate whether this change is making any performance difference in this case.", "author": "RaulGracia", "createdAt": "2020-06-05T08:14:21Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -314,15 +313,17 @@ private ReadResultEntry collectCachedEntries(long initialOffset, ReadResult read\n     /**\n      * Collect all the data from the given contents into a {@link ByteBuf}.\n      */\n-    private ByteBuf getData(List<BufferView> contents) {\n-        val compositeView = BufferView.wrap(contents);\n-        val rawBuffers = compositeView.getContents();\n-        val result = Unpooled.compositeBuffer(rawBuffers.size());\n-        for (ByteBuffer b : rawBuffers) {\n-            result.addComponent(Unpooled.wrappedBuffer(b));\n-        }\n+    private ByteBuf toByteBuf(List<BufferView> contents) {\n+        val buffers = contents.stream()", "originalCommit": "91e7ec130f098b2e2feef28916807da74b54ab36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4NjYxMg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435986612", "bodyText": "Sure. But in this case I need to output a byte array from a list of lists, so using Stream.flatMap helps a lot. There isn't any more efficient way of doing this and I would just be writing a lot more code to get it done.", "author": "andreipaduroiu", "createdAt": "2020-06-05T15:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNjUyMA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441216520", "bodyText": "This is expected to be a smallish number of items so it should be OK.", "author": "tkaitchuck", "createdAt": "2020-06-17T00:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MjY0MQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435762641", "bodyText": "Why the synchronization block is not needed anymore here?", "author": "RaulGracia", "createdAt": "2020-06-05T08:17:32Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -717,57 +727,49 @@ public void readTableKeys(WireCommands.ReadTableKeys readTableKeys) {\n             return;\n         }\n \n-        log.info(readTableKeys.getRequestId(), \"Fetching keys from {}.\", readTableKeys);\n+        log.debug(readTableKeys.getRequestId(), \"Iterate Table Segment Keys: Segment={}, Count={}.\",\n+                readTableKeys.getSegment(), readTableKeys.getSuggestedKeyCount());\n \n         int suggestedKeyCount = readTableKeys.getSuggestedKeyCount();\n         ByteBuf token = readTableKeys.getContinuationToken();\n \n-        byte[] state = null;\n+        BufferView state = null;\n         if (!token.equals(EMPTY_BUFFER)) {\n-            state = token.array();\n+            state = new ByteBufWrapper(token);\n         }\n \n-        final AtomicInteger msgSize = new AtomicInteger(0);\n-        final AtomicReference<ByteBuf> continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n-        final List<TableKey> keys = new ArrayList<>();\n-\n+        val msgSize = new AtomicInteger(segment.getBytes().length + WireCommands.TableKeysRead.HEADER_BYTES);\n+        val continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n+        val keys = new ArrayList<WireCommands.TableKey>();\n         val timer = new Timer();\n         tableStore.keyIterator(segment, state, TIMEOUT)\n-                  .thenCompose(itr -> itr.collectRemaining(\n-                          e -> {\n-                              synchronized (keys) {\n-                                  if (keys.size() < suggestedKeyCount && msgSize.get() < MAX_READ_SIZE) {\n-                                      Collection<TableKey> tableKeys = e.getEntries();\n-                                      ArrayView lastState = e.getState();\n-\n-                                      // Store all tableKeys.\n-                                      keys.addAll(tableKeys);\n-                                      // update the continuation token.\n-                                      continuationToken.set(wrappedBuffer(lastState.array(), lastState.arrayOffset(), lastState.getLength()));\n-                                      // Update msgSize.\n-                                      msgSize.addAndGet(getTableKeyBytes(segment, tableKeys, lastState.getLength()));\n-                                      return true;\n-                                  } else {\n-                                      return false;\n-                                  }\n-                              }\n-                          }))\n-                  .thenAccept(v -> {\n-                      final List<WireCommands.TableKey> wireCommandKeys;\n-                      synchronized (keys) {\n-                          log.debug(readTableKeys.getRequestId(), \"{} keys obtained for ReadTableKeys request.\", keys.size());\n-                          wireCommandKeys = keys.stream()\n-                                                .map(k -> {\n-                                                    ArrayView keyArray = k.getKey();\n-                                                    return new WireCommands.TableKey(wrappedBuffer(keyArray.array(),\n-                                                                                                   keyArray.arrayOffset(),\n-                                                                                                   keyArray.getLength()), k.getVersion());\n-                                                })\n-                                                .collect(toList());\n-                      }\n-                      connection.send(new WireCommands.TableKeysRead(readTableKeys.getRequestId(), segment, wireCommandKeys, continuationToken.get()));\n-                      this.tableStatsRecorder.iterateKeys(readTableKeys.getSegment(), keys.size(), timer.getElapsed());\n-                  }).exceptionally(e -> handleException(readTableKeys.getRequestId(), segment, operation, e));\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {", "originalCommit": "91e7ec130f098b2e2feef28916807da74b54ab36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4ODUxNA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435988514", "bodyText": "There was nothing to synchronize, since these callbacks would be invoked in order. But thanks for pointing this out as I had to make keys a synchronized list to make it safe for passing between threads.", "author": "andreipaduroiu", "createdAt": "2020-06-05T15:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxOTc5Mw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441219793", "bodyText": "Notice below that if connection.send calls iterator or stream on keys in can trigger a race. See how Collections.synchronizedList is defined. (I know it's really a bad impl)\nI think there is a neater solution though. Let's modify collectRemaining to have the collector return a generic value. Which can be passed below. This will eliminate the need for the sync and avoid a race with iterator. The collectRemaining method is also currently implemented recursively, which can cause problems on JDK-8. I suggest we turn it into a loop while we are at it.", "author": "tkaitchuck", "createdAt": "2020-06-17T00:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNDMxMQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441824311", "bodyText": "There is no race here. itr.collectRemaining(...) will fully execute before thenAccept (count the number of open and close parens). So the iterator will be fully consumed (collected) before we invoke connection.send.\nIn this case, Collection.synchronizedList is the appropriate solution as all I need to worry about is passing data between threads, but at no given time will I both iterate and update that collection.", "author": "andreipaduroiu", "createdAt": "2020-06-17T20:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNTc0OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r443715749", "bodyText": "After talking offline, I understand what the issue is. The Collections.synchronizedList returns a wrapper that synchronizes every access except the one to the iterator() which is delegated to the wrapped List, so that one is not thread safe.\nI am bringing back the synchronized block.", "author": "andreipaduroiu", "createdAt": "2020-06-22T17:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MjY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzMwNA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435763304", "bodyText": "Same question here about the sync block.", "author": "RaulGracia", "createdAt": "2020-06-05T08:18:45Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -779,115 +781,67 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n             return;\n         }\n \n-        log.info(readTableEntries.getRequestId(), \"Fetching keys from {}.\", readTableEntries);\n+        log.debug(readTableEntries.getRequestId(), \"Iterate Table Segment Entries: Segment={}, Count={}.\",\n+                readTableEntries.getSegment(), readTableEntries.getSuggestedEntryCount());\n \n         int suggestedEntryCount = readTableEntries.getSuggestedEntryCount();\n         ByteBuf token = readTableEntries.getContinuationToken();\n \n-        byte[] state = null;\n+        BufferView state = null;\n         if (!token.equals(EMPTY_BUFFER)) {\n-            state = token.array();\n+            state = new ByteBufWrapper(token);\n         }\n \n-        final AtomicInteger msgSize = new AtomicInteger(0);\n-        final AtomicReference<ByteBuf> continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n-        final List<TableEntry> entries = new ArrayList<>();\n+        val msgSize = new AtomicInteger(segment.getBytes().length + WireCommands.TableEntriesRead.HEADER_BYTES);\n+        val continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n+        val entries = new ArrayList<Map.Entry<WireCommands.TableKey, WireCommands.TableValue>>();\n         val timer = new Timer();\n         tableStore.entryIterator(segment, state, TIMEOUT)\n-                  .thenCompose(itr -> itr.collectRemaining(\n-                          e -> {\n-                              synchronized (entries) {\n-                                  if (entries.size() < suggestedEntryCount && msgSize.get() < MAX_READ_SIZE) {\n-                                      final Collection<TableEntry> tableEntries = e.getEntries();\n-                                      final ArrayView lastState = e.getState();\n-\n-                                      // Store all TableEntrys.\n-                                      entries.addAll(tableEntries);\n-                                      // Update the continuation token.\n-                                      continuationToken.set(wrappedBuffer(lastState.array(), lastState.arrayOffset(), lastState.getLength()));\n-                                      // Update message size.\n-                                      msgSize.addAndGet(getTableEntryBytes(segment, tableEntries, lastState.getLength()));\n-                                      return true;\n-                                  } else {\n-                                      return false;\n-                                  }\n-                              }\n-                          }))\n-                  .thenAccept(v -> {\n-                      final List<Map.Entry<WireCommands.TableKey, WireCommands.TableValue>> wireCommandEntries;\n-                      synchronized (entries) {\n-                          log.debug(readTableEntries.getRequestId(), \"{} entries obtained for ReadTableEntries request.\", entries.size());\n-                          wireCommandEntries = entries.stream()\n-                                                      .map(e -> {\n-                                                          TableKey k = e.getKey();\n-                                                          val keyWireCommand = new WireCommands.TableKey(wrappedBuffer(k.getKey().array(), k.getKey().arrayOffset(),\n-                                                                                                                       k.getKey().getLength()),\n-                                                                                                         k.getVersion());\n-                                                          ArrayView value = e.getValue();\n-                                                          val valueWireCommand = new WireCommands.TableValue(wrappedBuffer(value.array(), value.arrayOffset(),\n-                                                                                                                           value.getLength()));\n-                                                          return new AbstractMap.SimpleImmutableEntry<>(keyWireCommand, valueWireCommand);\n-                                                      })\n-                                                      .collect(toList());\n-                      }\n-\n-                      connection.send(new WireCommands.TableEntriesRead(readTableEntries.getRequestId(), segment,\n-                                                                        new WireCommands.TableEntries(wireCommandEntries),\n-                                                                        continuationToken.get()));\n-                      this.tableStatsRecorder.iterateEntries(readTableEntries.getSegment(), entries.size(), timer.getElapsed());\n-                  }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n-    }\n-\n-    private int getTableKeyBytes(String segment, Collection<TableKey> keys, int continuationTokenLength) {\n-        int headerLength = WireCommands.TableKeysRead.GET_HEADER_BYTES.apply(keys.size());\n-        int segmentLength = segment.getBytes().length;\n-        int dataLength = keys.stream().mapToInt(value -> value.getKey().getLength() + Long.BYTES).sum();\n-        return continuationTokenLength + headerLength + segmentLength + dataLength;\n-    }\n-\n-    private int getTableEntryBytes(String segment, Collection<TableEntry> items, int continuationTokenLength) {\n-        int headerLength = WireCommands.TableEntriesRead.GET_HEADER_BYTES.apply(items.size());\n-        int segmentLength = segment.getBytes().length;\n-        int dataLength = items.stream().mapToInt(value -> {\n-            return value.getKey().getKey().getLength() // key\n-                    + Long.BYTES // key version\n-                    + value.getValue().getLength(); // value\n-        }).sum();\n-        return headerLength + segmentLength + dataLength + continuationTokenLength;\n-    }\n-\n-    private ArrayView getArrayView(ByteBuf buf) {\n-        final int length = buf.readableBytes();\n-        if (buf.hasArray()) {\n-            return new ByteArraySegment(buf.array(), buf.readerIndex(), length);\n-        } else {\n-            byte[] bytes;\n-            bytes = new byte[length];\n-            buf.getBytes(buf.readerIndex(), bytes);\n-            return new ByteArraySegment(bytes, 0, length);\n-        }\n-    }\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {\n+                            if (entries.size() >= suggestedEntryCount || msgSize.get() >= MAX_READ_SIZE) {", "originalCommit": "91e7ec130f098b2e2feef28916807da74b54ab36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4ODU1OA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435988558", "bodyText": "see above", "author": "andreipaduroiu", "createdAt": "2020-06-05T15:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxOTk2Mw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441219963", "bodyText": "See above", "author": "tkaitchuck", "createdAt": "2020-06-17T00:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNDU1Nw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441824557", "bodyText": "I will give the same answer since it's the same pattern used.", "author": "andreipaduroiu", "createdAt": "2020-06-17T20:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzMwNA=="}], "type": "inlineReview"}, {"oid": "e82c83d07ecca77a42dc087519db9f161e357a74", "url": "https://github.com/pravega/pravega/commit/e82c83d07ecca77a42dc087519db9f161e357a74", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-4808-buffer-views", "committedDate": "2020-06-05T15:01:04Z", "type": "commit"}, {"oid": "75393f93b7ca4731214dd48856dec9fb1c86ef3f", "url": "https://github.com/pravega/pravega/commit/75393f93b7ca4731214dd48856dec9fb1c86ef3f", "message": "Javadoc for BufferView and BufferViewBuilder.\nSynchronization bugfix for PravegaRequestProcessor.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-05T15:15:55Z", "type": "commit"}, {"oid": "0fefefb24add30dd3920b2f39b65dd823b6aa9b4", "url": "https://github.com/pravega/pravega/commit/0fefefb24add30dd3920b2f39b65dd823b6aa9b4", "message": "Merge remote-tracking branch 'ap/issue-4808-buffer-views' into issue-4808-buffer-views", "committedDate": "2020-06-05T15:16:06Z", "type": "commit"}, {"oid": "deb6aec43150f98452ad65c33a1a3f2c2b61cfc5", "url": "https://github.com/pravega/pravega/commit/deb6aec43150f98452ad65c33a1a3f2c2b61cfc5", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-05T23:18:10Z", "type": "commit"}, {"oid": "42e653d7e7be1f14a47f403cbc83ee7212ee33c9", "url": "https://github.com/pravega/pravega/commit/42e653d7e7be1f14a47f403cbc83ee7212ee33c9", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-08T14:42:09Z", "type": "commit"}, {"oid": "b74cf9e11ebd27d5c59f80adf26a16ff44813ceb", "url": "https://github.com/pravega/pravega/commit/b74cf9e11ebd27d5c59f80adf26a16ff44813ceb", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-08T14:46:52Z", "type": "commit"}, {"oid": "aadda814743123a6ea18dff92495e66dd0623fc0", "url": "https://github.com/pravega/pravega/commit/aadda814743123a6ea18dff92495e66dd0623fc0", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-09T15:04:57Z", "type": "commit"}, {"oid": "42c6fbdf1290eeaabcfe13eab14885e82cfd6f6e", "url": "https://github.com/pravega/pravega/commit/42c6fbdf1290eeaabcfe13eab14885e82cfd6f6e", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-12T14:52:12Z", "type": "commit"}, {"oid": "a93c87781bcac941ad40dea06380b08d6177c0ea", "url": "https://github.com/pravega/pravega/commit/a93c87781bcac941ad40dea06380b08d6177c0ea", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-15T16:26:26Z", "type": "commit"}, {"oid": "89844088fe9693657a50ef71fed88155f029375e", "url": "https://github.com/pravega/pravega/commit/89844088fe9693657a50ef71fed88155f029375e", "message": "Merge branch 'master' into issue-4808-buffer-views", "committedDate": "2020-06-16T14:47:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MDMyNA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441180324", "bodyText": "final", "author": "tkaitchuck", "createdAt": "2020-06-16T22:36:20Z", "path": "common/src/main/java/io/pravega/common/hash/HashHelper.java", "diffHunk": "@@ -103,4 +114,21 @@ static double longToDoubleFraction(long value) {\n         long shifted = (value >> 12) & MASK;\n         return Double.longBitsToDouble(LEADING_BITS + shifted) - 1;\n     }\n+\n+    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+    public class HashBuilder {", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MTE5Mw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441181193", "bodyText": "collectBuffer isn't the best name, as it implies it is itself a buffer. Perhaps bufferCollector would be better.", "author": "tkaitchuck", "createdAt": "2020-06-16T22:39:00Z", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -127,29 +129,74 @@ default void release() {\n     }\n \n     /**\n-     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}. These buffer point\n+     * directly to the data contained within this buffer (i.e., they are not copies of the data).\n      *\n      * @return A List of {@link ByteBuffer}.\n      */\n     List<ByteBuffer> getContents();\n \n+    /**\n+     * Iterates through each of the buffers that make up this {@link BufferView}, in order, and invokes the given\n+     * {@link Collector} on each.\n+     *\n+     * @param collectBuffer A {@link Collector} function that will be invoked for each component. Each {@link ByteBuffer}", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNTEwNg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441825106", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-06-17T20:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MjA1OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441182059", "bodyText": "10 seems somewhat high on average...", "author": "tkaitchuck", "createdAt": "2020-06-16T22:41:24Z", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -127,29 +129,74 @@ default void release() {\n     }\n \n     /**\n-     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}. These buffer point\n+     * directly to the data contained within this buffer (i.e., they are not copies of the data).\n      *\n      * @return A List of {@link ByteBuffer}.\n      */\n     List<ByteBuffer> getContents();\n \n+    /**\n+     * Iterates through each of the buffers that make up this {@link BufferView}, in order, and invokes the given\n+     * {@link Collector} on each.\n+     *\n+     * @param collectBuffer A {@link Collector} function that will be invoked for each component. Each {@link ByteBuffer}\n+     *                      passed as an argument to this function is a direct pointer to the data contained within the\n+     *                      {@link BufferView} (i.e., they are not copies of the data).\n+     * @param <ExceptionT>  Type of exception that the {@link Collector} function throws, if any.\n+     * @throws ExceptionT If the {@link Collector} function throws an exception of this type, the iteration will end\n+     *                    and the exception will be bubbled up.\n+     */\n+    <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectBuffer) throws ExceptionT;\n+\n     /**\n      * Wraps the given {@link BufferView} into a single instance.\n      *\n-     * @param components The components to wrap.\n+     * @param components The components to wrap. These components will be added by reference, without making any data\n+     *                   copies. Any modifications made to these components will be reflected in the returned\n+     *                   {@link BufferView} and vice-versa.\n      * @return An empty {@link BufferView} (if the component list is empty), the first item in the list (if the component\n      * list has 1 element) or a {@link CompositeBufferView} wrapping all the given instances otherwise.\n      */\n     static BufferView wrap(List<BufferView> components) {\n         if (components.size() == 0) {\n-            return new ByteArraySegment(new byte[0]);\n+            return empty();\n         } else if (components.size() == 1) {\n             return components.get(0).slice();\n         } else {\n             return new CompositeBufferView(components);\n         }\n     }\n \n+    /**\n+     * Creates a new {@link BufferViewBuilder} that can be used to construct composite {@link BufferView} instances.\n+     *\n+     * @return A new {@link BufferViewBuilder} with default initial component count.\n+     */\n+    static BufferViewBuilder builder() {\n+        return builder(10);", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNTc0Mw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441825743", "bodyText": "I chose 10 because that's also the default in ArrayList, and down underneath this boils down to creating an ArrayList.", "author": "andreipaduroiu", "createdAt": "2020-06-17T20:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MjQ1OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441182459", "bodyText": "Why return an int?", "author": "tkaitchuck", "createdAt": "2020-06-16T22:42:33Z", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -173,23 +220,65 @@ static BufferView wrap(List<BufferView> components) {\n         int readBytes(ByteArraySegment segment);\n \n         /**\n-         * Reads all the remaining bytes from this {@link BufferView.Reader} into a new {@link ByteArraySegment}.\n+         * Reads one byte and advances the reader position by 1.\n+         *\n+         * @return The read byte.\n+         * @throws EOFException If {@link #available()} is 0.\n+         */\n+        int readByte() throws EOFException;", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzMzk3MA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441833970", "bodyText": "Good one. I originally had this return -1 instead of throwing EOFException, so an int` was required. Fixed.", "author": "andreipaduroiu", "createdAt": "2020-06-17T21:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MjQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4Mjc1Nw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441182757", "bodyText": "It should be clear that this is a copy.", "author": "tkaitchuck", "createdAt": "2020-06-16T22:43:29Z", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -173,23 +220,65 @@ static BufferView wrap(List<BufferView> components) {\n         int readBytes(ByteArraySegment segment);\n \n         /**\n-         * Reads all the remaining bytes from this {@link BufferView.Reader} into a new {@link ByteArraySegment}.\n+         * Reads one byte and advances the reader position by 1.\n+         *\n+         * @return The read byte.\n+         * @throws EOFException If {@link #available()} is 0.\n+         */\n+        int readByte() throws EOFException;\n+\n+        /**\n+         * Reads 4 bytes (and advances the reader position by 4) and composes a 32-bit Integer (Big-Endian).\n+         *\n+         * @return The read int.\n+         * @throws EOFException If {@link #available()} is less than {@link Integer#BYTES}.\n+         */\n+        int readInt() throws EOFException;\n+\n+        /**\n+         * Reads 8 bytes (and advances the reader position by 4) and composes a 64-bit Long (Big-Endian).\n+         *\n+         * @return The read long.\n+         * @throws EOFException If {@link #available()} is less than {@link Long#BYTES}.\n+         */\n+        long readLong() throws EOFException;\n+\n+        /**\n+         * Returns a {@link BufferView} that is a representation of the next bytes starting at the given position. The\n+         * reader position will be advanced by the requested number of bytes.\n+         *\n+         * @param length The number of bytes to slice out.\n+         * @return A {@link BufferView} that represents the given bytes. This {@link BufferView} represents a view into\n+         * the underlying {@link BufferView} and is not a copy of the given range.\n+         * @throws EOFException If {@link #available()} is less than length.\n+         */\n+        BufferView readSlice(int length) throws EOFException;\n+\n+        /**\n+         * Reads all the remaining bytes from this {@link BufferView.Reader} into a new {@link ArrayView}. The reader", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzMzMw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441183333", "bodyText": "Do you have specific plans for this? It may be possible to optimize significantly.", "author": "tkaitchuck", "createdAt": "2020-06-16T22:45:14Z", "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNjEwOQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441836109", "bodyText": "The goal of this is that any BufferView implementation would have the same hashcode and have equals(...) return true if their payload is the same. So I had to come up with a common hash code algorithm that works for all.\nIf there are more optimized solutions that would keep this working, I'd be up to fix them. However I compared this with ByteBuffer, ByteBuf and the old HashedArray implementations and they all so something equally \"slow\". That's because they need to account for the fact that the buffer payload may change between invocations, so the hash code must change accordingly.\nFYI we could do this later as these hashcodes are just used in memory and they're not persisted; there's no backwards compatibility we need to worry about this.", "author": "andreipaduroiu", "createdAt": "2020-06-17T21:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MDkyNw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442540927", "bodyText": "If it really is only used for maps, then I could probably port aHash's fallback algorithm to Java. If this is a performance concern, we can open an issue on it.", "author": "tkaitchuck", "createdAt": "2020-06-18T22:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg4ODg0NA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442888844", "bodyText": "Yes this is only for in-memory equality and hashes. So any improvement would be welcome and we wouldn't have to worry about backwards compatibility.", "author": "andreipaduroiu", "createdAt": "2020-06-19T14:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxODQ4Ng==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r443718486", "bodyText": "Created: #4887", "author": "tkaitchuck", "createdAt": "2020-06-22T17:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDkzNQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441184935", "bodyText": "I don't think this method should be defined here. Both ByteBuffer.equals and Arrays.equals are ~10-100x faster than doing it this way. If we make equals abstract then the child classes are forced to implement it for themselves.", "author": "tkaitchuck", "createdAt": "2020-06-16T22:49:55Z", "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        int l = getLength();\n+        if (l != other.getLength()) {\n+            return false;\n+        }\n+\n+        if (l > 0) {\n+            BufferView.Reader thisReader = getBufferViewReader();\n+            BufferView.Reader otherReader = other.getBufferViewReader();\n+            for (int i = 0; i < l; i++) {\n+                if (thisReader.readByte() != otherReader.readByte()) {", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNzQyNQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441837425", "bodyText": "There are multiple implementations of ByteBuffer:\n\nArrayView based (ByteArraySegment)\nCompositeArrayView (sparse array allocation)\nCompositeBufferView\nByteBufWrapper.\n\nI need a general solution that works for all of them. Then each class can have specialized implementations for this. For example, ByteArraySegment (by far the most commonly used class) has a special path for comparing against arrays.\nPS: Arrays.equals only compares whole arrays; I cannot compare array subsegments. In addition, it does nothing special; it just iterates through the two arrays and compares offset-by-offset.", "author": "andreipaduroiu", "createdAt": "2020-06-17T21:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzODY5Mg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442538692", "bodyText": "Arrays.equals is indeed special. It is calling ArraysSupport.vectorizedMismatch which in the base implementation is comparing 8 bytes at once but is annotated @HotSpotIntrinsicCandidate and so may be optimized further at runtime. It is OK to have a fallback, but if at all possible we should be calling into these accelerated methods in ByteBuffer or Arrays.", "author": "tkaitchuck", "createdAt": "2020-06-18T22:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1NTQyNQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442555425", "bodyText": "Perhaps there is another way to make this more efficient: Rather than having the impls try to specialize this we could have a protected abstract method for this class that returned: List<ByteBuffer which has the same bytes as what is inside the buffer view. Then that can be used to implement: (equals, hashcode, readInt, etc) in the generic logic here. I am not aware of anything which can't return that sort of view, but it's OK if we want to create an impl that can't, it just has to not extend the abstract class and implement the interface itself.", "author": "tkaitchuck", "createdAt": "2020-06-18T23:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5MzM1Mw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442893353", "bodyText": "According to both my IDE's decompilation and the JDK code here, there is nothing special done by Arrays.equals(...). What Java version are you looking at?\nBufferView returns both List<ByteBuffer> and collect(Consumer<ByteBuffer>) (the latter is more efficient as no lists are allocated. In order to make this work, though, I'd have to make this method handle the fact that component buffers may not be of the same length (even though their composition is equal). That would mean a lot of slicing and invoking of ByteBuffer.equals.\nHowever if I look at the ByteBuffer.equals() method it does nothing special. It simply loops through all the bytes in the buffers and compares byte-by-byte. There is no optimization employed and neither DirectByteBuffer nor HeapByteBuffer override that. I do not think we'd be gaining much from using that.", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxODk3NQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r443718975", "bodyText": "Resolving for now. We can take advantage of these faster methods once we upgrade to java 11.", "author": "tkaitchuck", "createdAt": "2020-06-22T17:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTE4MA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441195180", "bodyText": "Here and in the similar methods copy the structure of:\nUnsafe.getLongUnaligned et alt exactly. (obviously adapting the call to fetch the individual byte)\nthen annotate the method with @HotSpotIntrinsicCandidate\nthis should get the JIT to turn it into a CPU instruction directly.", "author": "tkaitchuck", "createdAt": "2020-06-16T23:21:49Z", "path": "common/src/main/java/io/pravega/common/util/BitConverter.java", "diffHunk": "@@ -176,6 +176,22 @@ public static int readInt(InputStream source) throws IOException {\n         }\n     }\n \n+    /**\n+     * Composes a 32-bit integer from the given byte components (Big-Endian order).\n+     *\n+     * @param b1 Byte #1.\n+     * @param b2 Byte #2.\n+     * @param b3 Byte #3.\n+     * @param b4 Byte #4.\n+     * @return The composed number.\n+     */\n+    public static int makeInt(int b1, int b2, int b3, int b4) {", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1NjM3MA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441856370", "bodyText": "I can't find this method anywhere in Unsafe or related classes. Nor is HotSpotIntrinsicCandidate a publicly-available annotation (it's internal).\nI got this implementation out of Java's DataInputStream.\nWhere are you looking at?", "author": "andreipaduroiu", "createdAt": "2020-06-17T21:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzOTAwMg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442539002", "bodyText": "This method is used internally inside of ByteBuffer.getInt. We should find a way to call it if possible.", "author": "tkaitchuck", "createdAt": "2020-06-18T22:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5NzU0MQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442897541", "bodyText": "I made all the readInt and readLong methods use makeInt/makeLong", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzU2NA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441207564", "bodyText": "See my comment above.", "author": "tkaitchuck", "createdAt": "2020-06-17T00:05:01Z", "path": "common/src/main/java/io/pravega/common/util/BitConverter.java", "diffHunk": "@@ -303,17 +319,34 @@ public static long readLong(InputStream source) throws IOException {\n         if ((b1 | b2 | b3 | b4 | b5 | b6 | b7 | b8) < 0) {\n             throw new EOFException();\n         } else {\n-            return ((long) b1 << 56) +\n-                    ((long) (b2 & 255) << 48) +\n-                    ((long) (b3 & 255) << 40) +\n-                    ((long) (b4 & 255) << 32) +\n-                    ((long) (b5 & 255) << 24) +\n-                    (long) ((b6 & 255) << 16) +\n-                    (long) ((b7 & 255) << 8) +\n-                    (long) ((b8 & 255));\n+            return BitConverter.makeLong(b1, b2, b3, b4, b5, b6, b7, b8);\n         }\n     }\n \n+    /**\n+     * Composes 64-bit long from the given byte components (in Big Endian order).\n+     *\n+     * @param b1 Byte #1.\n+     * @param b2 Byte #2.\n+     * @param b3 Byte #3.\n+     * @param b4 Byte #4.\n+     * @param b5 Byte #5.\n+     * @param b6 Byte #6.\n+     * @param b7 Byte #7.\n+     * @param b8 Byte #8.\n+     * @return The composed number.\n+     */\n+    public static long makeLong(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8) {", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzg2NQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441207865", "bodyText": "These really need to be passed as bytes not ints.\nAdditionally I think there may be performance gain in moving the BitConverter metrics here and leaving readByte abstract. See my comments on BItConverter.", "author": "tkaitchuck", "createdAt": "2020-06-17T00:06:02Z", "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        int l = getLength();\n+        if (l != other.getLength()) {\n+            return false;\n+        }\n+\n+        if (l > 0) {\n+            BufferView.Reader thisReader = getBufferViewReader();\n+            BufferView.Reader otherReader = other.getBufferViewReader();\n+            for (int i = 0; i < l; i++) {\n+                if (thisReader.readByte() != otherReader.readByte()) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    //region AbstractReader\n+\n+    /**\n+     * Base implementation of {@link BufferView.Reader}. Subclasses of {@link AbstractBufferView} should implement their\n+     * own {@link BufferView.Reader} instances based on this class.\n+     */\n+    protected static abstract class AbstractReader implements BufferView.Reader {\n+        @Override\n+        public int readInt() throws EOFException {\n+            return BitConverter.makeInt(readByte(), readByte(), readByte(), readByte());", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5ODQ0NA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442898444", "bodyText": "I changed readByte to return a byte.\nI cannot change makeInt/makeLong to accept bytes since those are inputs from InputStream and I also need to account for byte signage.", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzkxMg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441207912", "bodyText": "same here", "author": "tkaitchuck", "createdAt": "2020-06-17T00:06:13Z", "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        int l = getLength();\n+        if (l != other.getLength()) {\n+            return false;\n+        }\n+\n+        if (l > 0) {\n+            BufferView.Reader thisReader = getBufferViewReader();\n+            BufferView.Reader otherReader = other.getBufferViewReader();\n+            for (int i = 0; i < l; i++) {\n+                if (thisReader.readByte() != otherReader.readByte()) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    //region AbstractReader\n+\n+    /**\n+     * Base implementation of {@link BufferView.Reader}. Subclasses of {@link AbstractBufferView} should implement their\n+     * own {@link BufferView.Reader} instances based on this class.\n+     */\n+    protected static abstract class AbstractReader implements BufferView.Reader {\n+        @Override\n+        public int readInt() throws EOFException {\n+            return BitConverter.makeInt(readByte(), readByte(), readByte(), readByte());\n+        }\n+\n+        @Override\n+        public long readLong() throws EOFException {\n+            return BitConverter.makeLong(readByte(), readByte(), readByte(), readByte(), readByte(), readByte(), readByte(), readByte());", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTQyNQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441209425", "bodyText": "This is an unusual semantic by Java standards. Most of the standard library read methods will return a partial 'read' if there is less data. I don't have a strong opinion as to which way is better, but I wanted to call it out.", "author": "tkaitchuck", "createdAt": "2020-06-17T00:11:44Z", "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,45 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public int readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            int result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public BufferView readSlice(final int length) throws EOFException {\n+            if (length > available()) {", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MDk0Nw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441860947", "bodyText": "In this case I know exactly that I need to read this many bytes (this is most prevalent in deserializations). BufferViews are different than InputStreams in that all data is already available, so there is nothing more \"to add\" to it.\nBufferViews are immutable objects that will always refer to a (slice) of a data. As such, they have explicit bounds. These readers will need to respect that bounds and available is used to indicate how many more bytes are available for reading.", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjA0Nw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442546047", "bodyText": "Ok.", "author": "tkaitchuck", "createdAt": "2020-06-18T23:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDMyNA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441210324", "bodyText": "This used to cache the hash value, it does not appear to now. Is this intended?", "author": "tkaitchuck", "createdAt": "2020-06-17T00:14:54Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableKey.java", "diffHunk": "@@ -96,15 +95,14 @@ public String toString() {\n \n     @Override\n     public int hashCode() {\n-        return HashedArray.hashCode(this.key);\n+        return this.key.hashCode();", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MTU5OA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441861598", "bodyText": "HashedArray.hashCode is a static method so it never did cache the value. I don't think this class ever cached it.\nWhat you probably remember was that the HashedArray object itself was caching the hash value - which was incorrect since the array it wraps may mutate so the hash would change.", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTMwNA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441211304", "bodyText": "If it's idempotent perhaps it can be a try/with resource or just in a finally block.", "author": "tkaitchuck", "createdAt": "2020-06-17T00:18:43Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/ServerConnectionInboundHandler.java", "diffHunk": "@@ -53,7 +53,15 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) {\n         if (requestProcessor == null) {\n             throw new IllegalStateException(\"No command processor set for connection\");\n         }\n-        cmd.process(requestProcessor);\n+        try {\n+            cmd.process(requestProcessor);\n+        } catch (Throwable ex) {\n+            // Release buffers in case of an unhandled exception.\n+            if (cmd instanceof WireCommands.ReleasableCommand) {\n+                ((WireCommands.ReleasableCommand) cmd).release(); // Idempotent. Invoking multiple times has no side effects.", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MjEyMA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441862120", "bodyText": "PravegaRequestProcessor and AppendProcessor properly release these buffers for both successful and failed operations. However in case the call failed before anything could be released (i.e., a dumb NullPtr), I want to add this here to clean things up.\nI cannot blindly add it in a finally block as that would cause this to be released prematurely. PravegaRequestProcessor initiates an async call with these buffers which will complete way after this call returns synchronously. Making this a finally block will only complicate the management of these buffers as I would have to keep track each individual one for each call.", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTgyNQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441211825", "bodyText": "Hashed array used to cache hashcodes. Is this significant?", "author": "tkaitchuck", "createdAt": "2020-06-17T00:20:32Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableBucketReader.java", "diffHunk": "@@ -90,15 +89,14 @@\n      * will exclude all {@link ResultT} items that are marked as deleted.\n      */\n     CompletableFuture<List<ResultT>> findAllExisting(long bucketOffset, TimeoutTimer timer) {\n-        val result = new HashMap<HashedArray, ResultT>();\n+        val result = new HashMap<BufferView, ResultT>();", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MjQ4OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441862489", "bodyText": "HashMap only invokes hashCode once and then remembers that value for as long as the (key) object is inside it. So whether it's cached or not, it makes little difference as it will only be used once.", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzOTY0OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442539649", "bodyText": "It is recomputed if the hashmap is resized. (Which should be infrequent, but it's worth noting.)", "author": "tkaitchuck", "createdAt": "2020-06-18T22:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5ODcyNA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442898724", "bodyText": "OK.", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjk0OA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441212948", "bodyText": "Should this be reverted?", "author": "tkaitchuck", "createdAt": "2020-06-17T00:24:51Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImplTests.java", "diffHunk": "@@ -90,7 +88,7 @@\n     private static final double REMOVE_FRACTION = 0.3; // 30% of generated operations are removes.\n     private static final int SHORT_TIMEOUT_MILLIS = 20; // To verify a get() is blocked.\n     private static final int DEFAULT_COMPACTION_SIZE = -1; // Inherits from parent.\n-    private static final Duration TIMEOUT = Duration.ofSeconds(30000);\n+    private static final Duration TIMEOUT = Duration.ofSeconds(3000000);", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MzQ2MA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441863460", "bodyText": "Yes. It should be reverted to the value from April 2019 :)\n30000 seconds ~= 8h", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTIzMA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441215230", "bodyText": "This code is unreachable. The readFully above will throw if it can't read dataLength. This was the intention of the if conditional before.", "author": "tkaitchuck", "createdAt": "2020-06-17T00:33:25Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -1906,25 +1930,31 @@ public void writeFields(DataOutput out) throws IOException {\n             continuationToken.getBytes(continuationToken.readerIndex(), (OutputStream) out, continuationToken.readableBytes());\n         }\n \n-        public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOException {\n+        public static WireCommand readFrom(EnhancedByteBufInputStream in, int length) throws IOException {\n+            final int initialAvailable = in.available();\n             long requestId = in.readLong();\n             String segment = in.readUTF();\n             int numberOfKeys = in.readInt();\n             List<TableKey> keys = new ArrayList<>(numberOfKeys);\n-            int keyByteCount = 0;\n             for (int i = 0; i < numberOfKeys; i++) {\n                 TableKey k = TableKey.readFrom(in, in.available());\n                 keys.add(k);\n-                keyByteCount += TableKey.HEADER_BYTES + Long.BYTES + k.getData().readableBytes();\n             }\n+\n             int dataLength = in.readInt();\n-            if (length < dataLength + Long.BYTES + segment.getBytes(UTF_8).length + Integer.BYTES + keyByteCount) {\n-                throw new InvalidMessageException(\"Was expecting length: \" + length + \" but found: \" + dataLength);\n-            }\n             byte[] continuationToken = new byte[dataLength];\n             in.readFully(continuationToken);\n \n-            return new TableKeysRead(requestId, segment, keys, wrappedBuffer(continuationToken));\n+            if (initialAvailable - in.available() < length) {\n+                throw new InvalidMessageException(\"Was expecting length \" + length + \" but read \" + (initialAvailable - in.available()));", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2ODQ0NA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441868444", "bodyText": "I tried hard to figure out the point of this check and I couldn't find a good answer. But you are right; the readFully does throw if insufficient data is available. I removed this check.", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTQ0MQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441215441", "bodyText": "same here", "author": "tkaitchuck", "createdAt": "2020-06-17T00:34:17Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -2000,27 +2030,30 @@ public void writeFields(DataOutput out) throws IOException {\n             continuationToken.getBytes(continuationToken.readerIndex(), (OutputStream) out, continuationToken.readableBytes());\n         }\n \n-        public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOException {\n+        public static WireCommand readFrom(EnhancedByteBufInputStream in, int length) throws IOException {\n+            final int initialAvailable = in.available();\n             long requestId = in.readLong();\n             String segment = in.readUTF();\n             TableEntries entries = TableEntries.readFrom(in, in.available());\n             int dataLength = in.readInt();\n-\n-            if (length < dataLength + Long.BYTES + segment.getBytes(UTF_8).length + entries.size() + Integer.BYTES ) {\n-                throw new InvalidMessageException(\"Was expecting length: \" + length + \" but found: \" + dataLength);\n-            }\n-\n             byte[] continuationToken = new byte[dataLength];\n             in.readFully(continuationToken);\n \n-            return new TableEntriesRead(requestId, segment, entries, wrappedBuffer(continuationToken));\n+            if (initialAvailable - in.available() < length) {\n+                throw new InvalidMessageException(\"Was expecting length \" + length + \" but read \" + (initialAvailable - in.available()));", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2ODU2MQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441868561", "bodyText": "I removed this too.", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTkzNw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441215937", "bodyText": "HashedArray used to cache the hashCode. Please verify this is not a problem.", "author": "tkaitchuck", "createdAt": "2020-06-17T00:36:08Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/BucketUpdate.java", "diffHunk": "@@ -92,8 +92,8 @@ boolean hasUpdates() {\n         @NonNull\n         @Getter\n         private final TableBucket bucket;\n-        private final Map<HashedArray, KeyInfo> existingKeys = new HashMap<>();\n-        private final Map<HashedArray, KeyUpdate> updatedKeys = new HashMap<>();\n+        private final Map<BufferView, KeyInfo> existingKeys = new HashMap<>();", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2OTI5OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441869299", "bodyText": "I have answered this with other comments:\n\nCaching the hashcode is a bad idea as the underlying array may change. So we must recompute the hashcode every time. ByteBuffer and ByteBuf both do this.\nHashmap only calculates the hashcode once, so there is no advantage in caching it internally anyway.", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNjg0Mg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441216842", "bodyText": "Can you confirm we have test coverage validating there are no leaks on any of these paths?", "author": "tkaitchuck", "createdAt": "2020-06-17T00:39:48Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -691,21 +698,24 @@ public void readTable(final WireCommands.ReadTable readTable) {\n         final String operation = \"readTable\";\n \n         if (!verifyToken(segment, readTable.getRequestId(), readTable.getDelegationToken(), operation)) {\n+            readTable.release();\n             return;\n         }\n \n-        log.info(readTable.getRequestId(), \"Reading from table {}.\", readTable);\n+        log.debug(readTable.getRequestId(), \"Get Table Segment Keys: Segment={}, Count={}.\",\n+                readTable.getSegment(), readTable.getKeys());\n \n-        final List<ArrayView> keys = readTable.getKeys().stream()\n-                                              .map(k -> getArrayView(k.getData()))\n-                                              .collect(Collectors.toList());\n+        final List<BufferView> keys = readTable.getKeys().stream()\n+                .map(k -> new ByteBufWrapper(k.getData()))\n+                .collect(Collectors.toList());\n         val timer = new Timer();\n         tableStore.get(segment, keys, TIMEOUT)\n                 .thenAccept(values -> {\n                     connection.send(new WireCommands.TableRead(readTable.getRequestId(), segment, getTableEntriesCommand(keys, values)));\n                     this.tableStatsRecorder.getKeys(readTable.getSegment(), keys.size(), timer.getElapsed());\n                 })\n-                .exceptionally(e -> handleException(readTable.getRequestId(), segment, operation, e));\n+                .exceptionally(e -> handleException(readTable.getRequestId(), segment, operation, e))\n+                .whenComplete((r, ex) -> readTable.release());", "originalCommit": "89844088fe9693657a50ef71fed88155f029375e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3MDAwMg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441870002", "bodyText": "There are various tests extending from LeakDetectorTestSuite that will throw errors if Netty reports these.\nOnce I merge this in (or when KVTs are merged in - whichever comes first), this path will be exercised a lot more during tests and we'll get a good indication as to whether anything is leaking or not.", "author": "andreipaduroiu", "createdAt": "2020-06-17T22:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNjg0Mg=="}], "type": "inlineReview"}, {"oid": "9e38f92bd42fc28fa3f55f8ee95ed807a553c14c", "url": "https://github.com/pravega/pravega/commit/9e38f92bd42fc28fa3f55f8ee95ed807a553c14c", "message": "final class HashBuilder\nBufferView.collect -> bufferCollector.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-17T20:52:26Z", "type": "commit"}, {"oid": "b469bf8486a46ea82bd2036d38b11d6dfa3162bd", "url": "https://github.com/pravega/pravega/commit/b469bf8486a46ea82bd2036d38b11d6dfa3162bd", "message": "BufferView.Reader.readByte returns byte.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-17T21:05:51Z", "type": "commit"}, {"oid": "b110b6ea39335efaadffdc123d03583523425403", "url": "https://github.com/pravega/pravega/commit/b110b6ea39335efaadffdc123d03583523425403", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-17T22:34:20Z", "type": "commit"}, {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "url": "https://github.com/pravega/pravega/commit/ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "message": "Pushing down the implementation of readInt() and readLong() to actual classes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-18T19:58:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Mjc1NQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442542755", "bodyText": "Here and on these other methods, it may be better the EOFException to be an Runtime, because as near as I can tell, the caller is expected to call available() and use conditions to avoid the exception. Perhaps IndexOutOfBoundsException ?", "author": "tkaitchuck", "createdAt": "2020-06-18T22:51:11Z", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -173,23 +220,65 @@ static BufferView wrap(List<BufferView> components) {\n         int readBytes(ByteArraySegment segment);\n \n         /**\n-         * Reads all the remaining bytes from this {@link BufferView.Reader} into a new {@link ByteArraySegment}.\n+         * Reads one byte and advances the reader position by 1.\n+         *\n+         * @return The read byte.\n+         * @throws EOFException If {@link #available()} is 0.\n+         */\n+        byte readByte() throws EOFException;\n+\n+        /**\n+         * Reads 4 bytes (and advances the reader position by 4) and composes a 32-bit Integer (Big-Endian).\n+         *\n+         * @return The read int.\n+         * @throws EOFException If {@link #available()} is less than {@link Integer#BYTES}.\n+         */\n+        int readInt() throws EOFException;", "originalCommit": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxMjgyMQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442912821", "bodyText": "I need a special exception to indicate when I've read outside of the bounds (it's used in some cases upstream). However I like not having to deal with IOException. I created BufferView.Reader.OutOfBoundsException which extends IndexOutOfBoundsException. This should be both runtime and allow me to catch it when I need it ( while not confusing it with some other IndexOutOfBoundsException that may be thrown)", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Mjc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzA4OA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442543088", "bodyText": "I don't actually see anything throwing IOException below.", "author": "tkaitchuck", "createdAt": "2020-06-18T22:52:21Z", "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)", "originalCommit": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNzk4NA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442907984", "bodyText": "I removed this. It was the Reader.readByte which has since been changed.", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTYwNQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442545605", "bodyText": "um, this assert it really obvious... (like just based on the if condition above)", "author": "tkaitchuck", "createdAt": "2020-06-18T23:00:52Z", "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,69 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public byte readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            byte result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public int readInt() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current != null && current.available() >= Integer.BYTES) {\n+                this.available -= Integer.BYTES;\n+                assert this.available >= 0;", "originalCommit": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwODg0Nw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442908847", "bodyText": "ok, removed.", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTc4Ng==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442545786", "bodyText": "Should the readInt call go before the update to available?", "author": "tkaitchuck", "createdAt": "2020-06-18T23:01:32Z", "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,69 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public byte readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            byte result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public int readInt() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current != null && current.available() >= Integer.BYTES) {\n+                this.available -= Integer.BYTES;\n+                assert this.available >= 0;\n+                return current.readInt();", "originalCommit": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MDA5MQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r443640091", "bodyText": "I removed the assertion as it was superfluous.", "author": "andreipaduroiu", "createdAt": "2020-06-22T15:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTk0OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442545949", "bodyText": "Again: Order?", "author": "tkaitchuck", "createdAt": "2020-06-18T23:02:04Z", "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,69 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public byte readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            byte result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public int readInt() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current != null && current.available() >= Integer.BYTES) {\n+                this.available -= Integer.BYTES;\n+                assert this.available >= 0;\n+                return current.readInt();\n+            }\n+\n+            return super.readInt();\n+        }\n+\n+        @Override\n+        public long readLong() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current != null && current.available() >= Long.BYTES) {\n+                this.available -= Long.BYTES;\n+                assert this.available >= 0;\n+                return current.readLong();", "originalCommit": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxNDEzNA==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442914134", "bodyText": "See above.", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MDI3OQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r443640279", "bodyText": "Removed the assertion.", "author": "andreipaduroiu", "createdAt": "2020-06-22T15:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1MjMyNQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442552325", "bodyText": "Arrays.equals does this (and takes offsets)", "author": "tkaitchuck", "createdAt": "2020-06-18T23:24:27Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -169,6 +171,45 @@ public void copyTo(OutputStream stream) throws IOException {\n         stream.write(this.array, this.startOffset, this.length);\n     }\n \n+    @Override\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        if (this.length != other.getLength()) {\n+            return false;\n+        } else if (other instanceof ArrayView) {\n+            return equals((ArrayView) other);\n+        }\n+\n+        InputStream otherReader = other.getReader();\n+        for (int i = 0; i < this.length; i++) {\n+            if ((byte) otherReader.read() != this.array[this.startOffset + i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean equals(ArrayView other) {\n+        if (this.length != other.getLength()) {\n+            return false;\n+        }\n+\n+        byte[] otherArray = other.array();\n+        int otherOffset = other.arrayOffset();\n+        for (int i = 0; i < this.length; i++) {", "originalCommit": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwOTI0Mg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442909242", "bodyText": "There is no overload for Arrays.equals(byte[], byte[]) that takes offsets. At least not in Java 8 which is what we are targeting.", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1MjMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYzOTU4NQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r443639585", "bodyText": "See #4884. We'll tackle that once we target Java 11.", "author": "andreipaduroiu", "createdAt": "2020-06-22T15:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1MjMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1MzUxNQ==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442553515", "bodyText": "Here and below, if at construction time we create a ByteBuffer view of the array this can be faster.", "author": "tkaitchuck", "createdAt": "2020-06-18T23:28:26Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -291,6 +332,51 @@ public int readBytes(ByteArraySegment segment) {\n             this.position += len;\n             return len;\n         }\n+\n+        @Override\n+        public byte readByte() throws EOFException {\n+            if (position >= ByteArraySegment.this.length) {\n+                throw new EOFException();\n+            }\n+\n+            byte result = ByteArraySegment.this.array[ByteArraySegment.this.startOffset + this.position];\n+            this.position++;\n+            return result;\n+        }\n+\n+        @Override\n+        public int readInt() throws EOFException {\n+            int nextPos = this.position + Integer.BYTES;\n+            if (nextPos > ByteArraySegment.this.length) {\n+                throw new EOFException();\n+            }\n+            int r = BitConverter.readInt(ByteArraySegment.this.array, ByteArraySegment.this.startOffset + this.position);", "originalCommit": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxNjE2Nw==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442916167", "bodyText": "I have filed #4884 so that we may improve these core classes. This is getting a bit out of scope for this PR, which was to improve data allocation for Table APIs.", "author": "andreipaduroiu", "createdAt": "2020-06-19T15:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1MzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1NTgyMg==", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442555822", "bodyText": "See my comment on AbstractBufferView, (I think we can eliminate the need for this)", "author": "tkaitchuck", "createdAt": "2020-06-18T23:36:15Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -169,6 +171,45 @@ public void copyTo(OutputStream stream) throws IOException {\n         stream.write(this.array, this.startOffset, this.length);\n     }\n \n+    @Override\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {", "originalCommit": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "86b977cba9cea85691a8c81bcf0760bd094a5e0d", "url": "https://github.com/pravega/pravega/commit/86b977cba9cea85691a8c81bcf0760bd094a5e0d", "message": "BitConverter methods make use of makeInt/makeLong internally.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-19T15:22:52Z", "type": "commit"}, {"oid": "71cf2854ddc86f7d398a9a5a7b39c9cb63696af8", "url": "https://github.com/pravega/pravega/commit/71cf2854ddc86f7d398a9a5a7b39c9cb63696af8", "message": "BufferView.reader throws OutOfBoundsException.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-19T15:53:07Z", "type": "commit"}, {"oid": "0493807b8404bfb20d5ba1ba1073ba9c5250843c", "url": "https://github.com/pravega/pravega/commit/0493807b8404bfb20d5ba1ba1073ba9c5250843c", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-4808-buffer-views", "committedDate": "2020-06-22T15:21:46Z", "type": "commit"}, {"oid": "bc063e92749e64d51a76ab427077dbe55442ab66", "url": "https://github.com/pravega/pravega/commit/bc063e92749e64d51a76ab427077dbe55442ab66", "message": "Bringing back the synchronized block.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-22T17:25:13Z", "type": "commit"}, {"oid": "cd1901a8f4e7c370567d08717d39a66043a33ef1", "url": "https://github.com/pravega/pravega/commit/cd1901a8f4e7c370567d08717d39a66043a33ef1", "message": "Sending over the wire outside of the lock.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-22T19:15:09Z", "type": "commit"}, {"oid": "cde2adb8b786edffe162dc3ce068662c0ec107cd", "url": "https://github.com/pravega/pravega/commit/cde2adb8b786edffe162dc3ce068662c0ec107cd", "message": "Unified iterator collection into a single class.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-06-22T20:26:48Z", "type": "commit"}]}