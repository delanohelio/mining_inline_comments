{"pr_number": 4698, "pr_title": "Issue 4694: (SegmentStore) Use BufferViews instead of InputStreams on read path", "pr_createdAt": "2020-04-16T00:16:35Z", "pr_url": "https://github.com/pravega/pravega/pull/4698", "timeline": [{"oid": "4bdb48fe623a609e079ea29cd3fa680140aa8a40", "url": "https://github.com/pravega/pravega/commit/4bdb48fe623a609e079ea29cd3fa680140aa8a40", "message": "Replaced InputStream with BufferView on ReadResultEntry, which provides greater flexibility and better performance in copying data out of the wrapped buffer.\nRetired ReadResultEntryContents.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-15T22:11:35Z", "type": "commit"}, {"oid": "f8ea466f8927bf207b89ca1ea08529709855d6d1", "url": "https://github.com/pravega/pravega/commit/f8ea466f8927bf207b89ca1ea08529709855d6d1", "message": "Fixed bugs.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-16T00:13:40Z", "type": "commit"}, {"oid": "d0a8444520d62129c1e3e6543aa9804571ef08c7", "url": "https://github.com/pravega/pravega/commit/d0a8444520d62129c1e3e6543aa9804571ef08c7", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-16T07:45:24Z", "type": "commit"}, {"oid": "e6844f267ce32b7f472d132b1ec41fe0a65e810d", "url": "https://github.com/pravega/pravega/commit/e6844f267ce32b7f472d132b1ec41fe0a65e810d", "message": "SegmentRead uses ByteBuf instead of ByteBuffer.\nAdded BufferView.getContents.\nPravegaRequestProcessor copies data directly to the wire for segment reads.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-17T00:54:17Z", "type": "commit"}, {"oid": "f005dc705f8eb8b1cc1f27949ca7f1985b94a504", "url": "https://github.com/pravega/pravega/commit/f005dc705f8eb8b1cc1f27949ca7f1985b94a504", "message": "Merge remote-tracking branch 'ap/issue-4694-bufferviews-on-reads' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-17T00:54:25Z", "type": "commit"}, {"oid": "be571996f5e1f399485267f4ef759329f32e43a1", "url": "https://github.com/pravega/pravega/commit/be571996f5e1f399485267f4ef759329f32e43a1", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-17T00:55:43Z", "type": "commit"}, {"oid": "2e52b331a0604f599101957d50e7bd07d8145503", "url": "https://github.com/pravega/pravega/commit/2e52b331a0604f599101957d50e7bd07d8145503", "message": "Fixed serialization.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-17T03:11:31Z", "type": "commit"}, {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471", "url": "https://github.com/pravega/pravega/commit/c24747107387e6cbaeaf630ea83ac2929c901471", "message": "Added EnhancedByteBufInputStream.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-17T18:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MzUxMw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410383513", "bodyText": "Per the javadocs nioBuffer() may make a copy. I would like to avoid making two copies here.", "author": "tkaitchuck", "createdAt": "2020-04-17T17:59:55Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -150,20 +150,21 @@ private void handleRequest() throws SegmentTruncatedException {\n             throw e;\n         }\n         verifyIsAtCorrectOffset(segmentRead);\n-        if (segmentRead.getData().hasRemaining()) {\n-            buffer.fill(segmentRead.getData());\n+        if (segmentRead.getData().readableBytes() > 0) {\n+            int copied = buffer.fill(segmentRead.getData().nioBuffer());", "originalCommit": "2e52b331a0604f599101957d50e7bd07d8145503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDEzNg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410450136", "bodyText": "Added a method to CircularBuffer to handle this.", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MzUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NTU2Ng==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410385566", "bodyText": "Given that the array() method already exists on this interface, I think the return type can just be a single ByteBuffer. If there were multiple components array() wouldn't be implementable in which case it would make sense to just use a different interface.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:03:54Z", "path": "common/src/main/java/io/pravega/common/util/ArrayView.java", "diffHunk": "@@ -48,4 +52,9 @@\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n     void copyTo(byte[] target, int targetOffset, int length);\n+\n+    @Override\n+    default List<ByteBuffer> getContents() {\n+        return Collections.singletonList(ByteBuffer.wrap(array(), arrayOffset(), getLength()));", "originalCommit": "2e52b331a0604f599101957d50e7bd07d8145503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTUyNA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410431524", "bodyText": "This method is inherited from BufferView which may wrap multiple buffers. I can't change the return type.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410388208", "bodyText": "This may have unintended consequences if there is a subclass of bufferView which has internal state such as a modifiable position.\nI think instead there should be be a 'getView' method on bufferView the default version of which returns this. But which can be overridden by some impls to perform a slice.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:08:55Z", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -104,4 +105,28 @@ default void retain() {\n     default void release() {\n         // Default implementation intentionally left blank. Any derived class may implement if needed.\n     }\n+\n+    /**\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     *\n+     * @return A List of {@link ByteBuffer}.\n+     */\n+    List<ByteBuffer> getContents();\n+\n+    /**\n+     * Wraps the given {@link BufferView} into a single instance.\n+     *\n+     * @param components The components to wrap.\n+     * @return An empty {@link BufferView} (if the component list is empty), the first item in the list (if the component\n+     * list has 1 element) or a {@link CompositeBufferView} wrapping all the given instances otherwise.\n+     */\n+    static BufferView wrap(List<BufferView> components) {\n+        if (components.size() == 0) {\n+            return new ByteArraySegment(new byte[0]);\n+        } else if (components.size() == 1) {\n+            return components.get(0);", "originalCommit": "2e52b331a0604f599101957d50e7bd07d8145503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTk3Nw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410449977", "bodyText": "Can I just name it BufferView.slice() which will invoke BufferView.slice(0, BufferView.getLength())?", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3Mzk0Mw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410473943", "bodyText": "sure", "author": "tkaitchuck", "createdAt": "2020-04-17T21:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNzA1OA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r411727058", "bodyText": "done", "author": "andreipaduroiu", "createdAt": "2020-04-20T22:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5MDc0MA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410390740", "bodyText": "I really don't like these methods. Because they aren't used in most code paths they won't be well tested and the code handling these classes may assume it's working with an impl that doesn't use them, and will break with one that does.\nIf it is at all possible to remove them, I suggest we do so.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:13:54Z", "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * Provides a unified view of multiple wrapped {@link BufferView} instances.\n+ */\n+class CompositeBufferView implements BufferView {\n+    //region Members\n+\n+    private final List<BufferView> components;\n+    @Getter\n+    private final int length;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeBufferView} class. It is recommended to use {@link BufferView#wrap}\n+     * instead.\n+     *\n+     * @param components The components to wrap.\n+     */\n+    CompositeBufferView(@NonNull List<BufferView> components) {\n+        this.components = new ArrayList<>();\n+        int length = 0;\n+        for (BufferView c : components) {\n+            if (c instanceof CompositeBufferView) {\n+                this.components.addAll(((CompositeBufferView) c).components);\n+            } else {\n+                this.components.add(c);\n+            }\n+            length += c.getLength();\n+        }\n+        this.length = length;\n+    }\n+\n+    //endregion\n+\n+    //region BufferView implementation\n+\n+    @Override\n+    public InputStream getReader() {\n+        this.components.stream().map(BufferView::getReader).iterator();\n+        return new SequenceInputStream(Iterators.asEnumeration(this.components.stream().map(BufferView::getReader).iterator()));\n+    }\n+\n+    @Override\n+    public InputStream getReader(int offset, int length) {\n+        return slice(offset, length).getReader();\n+    }\n+\n+    @Override\n+    public BufferView slice(int offset, int length) {\n+        Preconditions.checkArgument(offset >= 0 && offset < length && length <= this.length,\n+                \"offset and length must be non-negative and less than %s.\", this.length);\n+        if (offset == 0 && length == this.length) {\n+            return this;\n+        }\n+        ArrayList<BufferView> components = new ArrayList<>(this.components.size());\n+        int index = 0;\n+        int currentOffset = 0;\n+        while (length > 0) {\n+            BufferView c = this.components.get(index);\n+            int lastComponentOffset = currentOffset + c.getLength();\n+            if (offset < lastComponentOffset) {\n+                int sliceStart = Math.max(0, offset - currentOffset);\n+                int sliceLength = Math.min(length, c.getLength() - sliceStart);\n+                components.add(c.slice(sliceStart, sliceLength));\n+                length -= sliceLength;\n+            }\n+\n+            index++;\n+            currentOffset += c.getLength();\n+        }\n+\n+        return BufferView.wrap(components);\n+    }\n+\n+    @Override\n+    public byte[] getCopy() {\n+        byte[] result = new byte[getLength()];\n+        int offset = 0;\n+        for (BufferView c : this.components) {\n+            int copiedBytes = c.copyTo(ByteBuffer.wrap(result, offset, c.getLength()));\n+            assert copiedBytes == c.getLength();\n+            offset += copiedBytes;\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public void copyTo(OutputStream target) throws IOException {\n+        for (BufferView c : this.components) {\n+            c.copyTo(target);\n+        }\n+    }\n+\n+    @Override\n+    public int copyTo(ByteBuffer target) {\n+        int bytesCopied = 0;\n+        for (BufferView c : this.components) {\n+            bytesCopied += c.copyTo(target);\n+        }\n+\n+        return bytesCopied;\n+    }\n+\n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>(this.components.size());\n+        for (BufferView c : this.components) {\n+            result.addAll(c.getContents());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public void retain() {", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjYyNQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410432625", "bodyText": "There is an implementation of BufferView that wraps ByteBufs. I need these methods for that specific case. The default implementation in BufferView does nothing, so they are only overridden if they have to.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5MDc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NDA4Nw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410394087", "bodyText": "Why is arrays an Object[] rather than a byte[][]?", "author": "tkaitchuck", "createdAt": "2020-04-17T18:20:22Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -217,6 +218,21 @@ public int copyTo(ByteBuffer target) {\n         return length;\n     }\n \n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>();\n+        for (int i = 0; i < this.arrays.length; i++) {\n+            byte[] a = getArray(i, false);", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNDY0Mg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410434642", "bodyText": "because byte[][] arrays = new byte[x][y] will create y arrays of x elements. This defeats the purpose of this class, which is a view of a sparse array (only allocates sub-arrays as they are needed).", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NDA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjI2OQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410396269", "bodyText": "It is not obvious from the method signature/javadoc that it is going to allocate.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:24:31Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -217,6 +218,21 @@ public int copyTo(ByteBuffer target) {\n         return length;\n     }\n \n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>();\n+        for (int i = 0; i < this.arrays.length; i++) {\n+            byte[] a = getArray(i, false);\n+            if (a == null) {\n+                int size = i == this.arrays.length - 1 ? this.length % this.arraySize : this.arraySize;\n+                result.add(ByteBuffer.allocate(size));", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTk2Nw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410435967", "bodyText": "Fixed the javadoc on CompositeArrayView to explain this.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410397345", "bodyText": "The streamHelpers method should be updated, as there are probably other callers.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:26:36Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/ReadResult.java", "diffHunk": "@@ -104,25 +101,25 @@ default int readRemaining(byte[] target, Duration fetchTimeout) {\n                 entry.requestContent(fetchTimeout);\n             }\n \n-            ReadResultEntryContents contents = entry.getContent().join();\n-            StreamHelpers.readAll(contents.getData(), target, bytesRead, Math.min(contents.getLength(), target.length - bytesRead));", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTQzMQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410449431", "bodyText": "I opened this a while back, with no clear solution in mind (at the time):  #2924.", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwMTQzNA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410501434", "bodyText": "Ok, let's link to that issue in the Javadoc for the method so that it doesn't get used when it doesn't have to be.", "author": "tkaitchuck", "createdAt": "2020-04-17T22:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyODQwMA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r411728400", "bodyText": "done", "author": "andreipaduroiu", "createdAt": "2020-04-20T22:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMDc5Mg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410420792", "bodyText": "It should be noted this can return null.", "author": "tkaitchuck", "createdAt": "2020-04-17T19:15:00Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java", "diffHunk": "@@ -757,34 +758,34 @@ private boolean canContinueFlushingExcess() {\n     }\n \n     /**\n-     * Returns a FlushArgs which contains the data needing to be flushed to Storage.\n+     * Returns a {@link BufferView} which contains the data needing to be flushed to Storage.\n      *\n-     * @return The aggregated object that can be used for flushing.\n+     * @return A {@link BufferView} to flush.", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNjY0OA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410436648", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMDc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMzQ5OA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410423498", "bodyText": "This code is fine, but I don't see how it's any different than the code before. It's not saving any copies.", "author": "tkaitchuck", "createdAt": "2020-04-17T19:20:52Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ByteBufWrapper.java", "diffHunk": "@@ -113,14 +120,17 @@ public void copyTo(OutputStream target) throws IOException {\n     @Override\n     public int copyTo(ByteBuffer byteBuffer) {\n         Exceptions.checkNotClosed(this.buf.refCnt() == 0, this);\n-        ByteBuf buf = this.buf.duplicate();\n+        ByteBuf source = this.buf.duplicate();", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNzIzMg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410437232", "bodyText": "The previous code had a bug in it where it would not update the target buffer's position after the write, thus ending up overwriting the same data over and over again.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMzQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410425875", "bodyText": "This is adding a call to retain(). Where is the corresponding release() call?", "author": "tkaitchuck", "createdAt": "2020-04-17T19:26:04Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -828,10 +827,9 @@ public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOE\n             if (dataLength > length) {\n                 throw new BufferOverflowException();\n             }\n-            byte[] data = new byte[dataLength];\n-            in.readFully(data);\n-            long requestId =  in.available() >= Long.BYTES ? in.readLong() : -1L;\n-            return new SegmentRead(segment, offset, atTail, endOfSegment, ByteBuffer.wrap(data), requestId);\n+            ByteBuf data = in.readFully(dataLength).retain();", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODA5NA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410448094", "bodyText": "Good point. Due to the fact that this class is instantiated in 2 ways (with an external ByteBuf via the constructor, and by deserializing), I only need to retain for the serialization, so the solution is a bit less elegant than I wished. I added some unit tests to verify it works as I intend to.\nThe corresponding release has been added to SegmentInputStreamImpl.handleRequest", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODkyOA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410448928", "bodyText": "I am not 100% sure this is correct. But I do not know of any way to prevent memory leaks without making a copy in the deserialization. I am concerned about cancelled requests or other unexpected situations.", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwMjg2MQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410502861", "bodyText": "SegmentInputStreamImpl:89 is missing the logic to call release. In case setoffset is called before reading the data is complete.", "author": "tkaitchuck", "createdAt": "2020-04-17T22:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}], "type": "inlineReview"}, {"oid": "afb2abc20e7d03ff7ffd9e6c28981c19a0e16598", "url": "https://github.com/pravega/pravega/commit/afb2abc20e7d03ff7ffd9e6c28981c19a0e16598", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-17T20:39:28Z", "type": "commit"}, {"oid": "ed825a0384ef22458bd2063d66f7a0897228c765", "url": "https://github.com/pravega/pravega/commit/ed825a0384ef22458bd2063d66f7a0897228c765", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-20T22:08:55Z", "type": "commit"}, {"oid": "65704b6f9a548c32a248dc9c8a61f5acdc40e001", "url": "https://github.com/pravega/pravega/commit/65704b6f9a548c32a248dc9c8a61f5acdc40e001", "message": "Code review coverage:\n- BufferView.slice()\n- Futures.cancellableFuture()\n- SegmentInputStreamImpl: releasing SegmentRead if cancelled.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-20T23:04:59Z", "type": "commit"}, {"oid": "6d4e1884da79c9e105fcebfb22950461565fcced", "url": "https://github.com/pravega/pravega/commit/6d4e1884da79c9e105fcebfb22950461565fcced", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-21T15:34:20Z", "type": "commit"}, {"oid": "38849f65ce27284cd7841f0f7e708770440d4a0e", "url": "https://github.com/pravega/pravega/commit/38849f65ce27284cd7841f0f7e708770440d4a0e", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-21T21:33:37Z", "type": "commit"}, {"oid": "cb55b9b4ec7d31af14bdd9fe0f5696a73c758cf0", "url": "https://github.com/pravega/pravega/commit/cb55b9b4ec7d31af14bdd9fe0f5696a73c758cf0", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-27T16:22:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNzgzMA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416127830", "bodyText": "This is a complicated case:\nIf the buffer has completed but has not had any slices pulled out of it we need to call releaese() if it does, then those could become invalid. So we need to make sure they don't like longer than the scope of $lock", "author": "tkaitchuck", "createdAt": "2020-04-27T20:32:07Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -197,14 +198,20 @@ private int computeReadLength(long currentFetchOffset) {\n         return Math.toIntExact(Math.min(currentReadLength, numberOfBytesRemaining));\n     }\n \n+    @GuardedBy(\"$lock\")\n+    private void cancelOutstandingRequest() {\n+        outstandingRequest.cancel(true);", "originalCommit": "cb55b9b4ec7d31af14bdd9fe0f5696a73c758cf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c85fadbc581113beea43a61c6c9316c8d5d9ef3", "url": "https://github.com/pravega/pravega/commit/1c85fadbc581113beea43a61c6c9316c8d5d9ef3", "message": "Fixing some cases.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T15:45:51Z", "type": "commit"}, {"oid": "c92cf38d5e33d9ecdc9cd2ceb72ff11a0ef2b51d", "url": "https://github.com/pravega/pravega/commit/c92cf38d5e33d9ecdc9cd2ceb72ff11a0ef2b51d", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-28T16:36:36Z", "type": "commit"}, {"oid": "bd96e442b2643aff9647e99180f1ad79d1dcf8ab", "url": "https://github.com/pravega/pravega/commit/bd96e442b2643aff9647e99180f1ad79d1dcf8ab", "message": "Fixed precondition check.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T17:26:45Z", "type": "commit"}, {"oid": "262117d6eba756acdf46de2e0e89654549ca5a86", "url": "https://github.com/pravega/pravega/commit/262117d6eba756acdf46de2e0e89654549ca5a86", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-28T17:57:22Z", "type": "commit"}, {"oid": "a3d0eed56a17a98edb29e8063937cfc82839dbd7", "url": "https://github.com/pravega/pravega/commit/a3d0eed56a17a98edb29e8063937cfc82839dbd7", "message": "Enabling resource leak detection on test classes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T18:00:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416890770", "bodyText": "These two exception listeners could be combined so as to avoid an extra link in the future chain.", "author": "tkaitchuck", "createdAt": "2020-04-28T20:10:14Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -228,6 +229,40 @@\n         return result;\n     }\n \n+    /**\n+     * Returns a CompletableFuture that will complete with the same outcome or result as the given source, but when\n+     * cancelled, will apply a consumer to the eventual result of the original future.\n+     * <p>\n+     * If the returned CompletableFuture is NOT cancelled ({@link CompletableFuture#cancel}):\n+     * - If source completes normally, the result CompletableFuture will complete with the same result.\n+     * - If source completes exceptionally, the result CompletableFuture will complete with the same result.\n+     * <p>\n+     * If the returned CompletableFuture is cancelled ({@link CompletableFuture#cancel}):\n+     * - If the source has already completed, the result CompletableFuture will also be completed with the same outcome.\n+     * - If the source has not already been completed, if it completes normally, then `onCancel` will be applied to\n+     * the result when it eventually completes. The source completes exceptionally, nothing will happen.\n+     *\n+     * @param source   The CompletableFuture to wrap.\n+     * @param onCancel A Consumer to invoke on source's eventual completion result if the result of this method is cancelled.\n+     * @param <T>      Result type.\n+     * @return A CompletableFuture that will complete with the same outcome or result as the given source.\n+     */\n+    public static <T> CompletableFuture<T> cancellableFuture(CompletableFuture<T> source, Consumer<T> onCancel) {\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        val result = new CompletableFuture<T>();\n+        source.thenAccept(result::complete);\n+        Futures.exceptionListener(source, result::completeExceptionally);", "originalCommit": "a3d0eed56a17a98edb29e8063937cfc82839dbd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjA4Mg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416976082", "bodyText": "These listeners are on different futures. The first one is on the source (which we're passed in) and propagates the failure to the result. The second one is on the result and invokes the onCancel callback if someone cancelled the result. I cannot combine them into one.\nAlso, these are not affecting the future chain. We are returning result directly, yet we are attaching these listeners to the result but not chain them anywhere. They will only be executed in case of some exception; they will not affect the normal path.", "author": "andreipaduroiu", "createdAt": "2020-04-28T23:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTU1NA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416979554", "bodyText": "I see my phrasing was confusing. I intended to refer to this and the above line.", "author": "tkaitchuck", "createdAt": "2020-04-28T23:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MTU1Nw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416981557", "bodyText": "Got it now. Fixed it.", "author": "andreipaduroiu", "createdAt": "2020-04-28T23:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzI2Ng==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416927266", "bodyText": "NotThreadSafe unless you want to make released an atomic boolean", "author": "tkaitchuck", "createdAt": "2020-04-28T21:14:57Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -792,15 +795,24 @@ public long getRequestId() {\n         }\n     }\n \n-    @Data\n+    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+    @Getter\n+    @ToString\n+    @EqualsAndHashCode(exclude = {\"mustRelease\", \"released\"})", "originalCommit": "a3d0eed56a17a98edb29e8063937cfc82839dbd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjEyMA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416976120", "bodyText": "Done.", "author": "andreipaduroiu", "createdAt": "2020-04-28T23:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzI2Ng=="}], "type": "inlineReview"}, {"oid": "6195766f8a29c435c2a75b716b5e288dcacb364b", "url": "https://github.com/pravega/pravega/commit/6195766f8a29c435c2a75b716b5e288dcacb364b", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-28T23:05:54Z", "type": "commit"}, {"oid": "96abc80d6ad752c551f45cbb910fa8daa5a1dd97", "url": "https://github.com/pravega/pravega/commit/96abc80d6ad752c551f45cbb910fa8daa5a1dd97", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T23:06:11Z", "type": "commit"}, {"oid": "607728d67382279dabc79e154f8e04b45b2da00f", "url": "https://github.com/pravega/pravega/commit/607728d67382279dabc79e154f8e04b45b2da00f", "message": "Combined futures callbacks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T23:20:21Z", "type": "commit"}]}