{"pr_number": 5378, "pr_title": "Issue 5377: Support TLS-enabled clusters for integration testing", "pr_createdAt": "2020-11-26T03:25:05Z", "pr_url": "https://github.com/pravega/pravega/pull/5378", "timeline": [{"oid": "30bd6b2f6661191f3980e10d17017325d90213c3", "url": "https://github.com/pravega/pravega/commit/30bd6b2f6661191f3980e10d17017325d90213c3", "message": "Convert construction to builder\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-11-25T09:15:53Z", "type": "commit"}, {"oid": "3c70e16dc7d8549e216436e235f27db7f71befc8", "url": "https://github.com/pravega/pravega/commit/3c70e16dc7d8549e216436e235f27db7f71befc8", "message": "Implement TLS support\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-11-25T17:13:47Z", "type": "commit"}, {"oid": "3a4ccf9af218cd0d753cbb028fd24534491ca6bd", "url": "https://github.com/pravega/pravega/commit/3a4ccf9af218cd0d753cbb028fd24534491ca6bd", "message": "Merge branch 'master' into integration-tls-support", "committedDate": "2020-11-26T03:25:13Z", "type": "commit"}, {"oid": "4965e430dde91cd397ec7c596d73aca3de77f801", "url": "https://github.com/pravega/pravega/commit/4965e430dde91cd397ec7c596d73aca3de77f801", "message": "Refine the implementation and the test\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-11-26T03:50:50Z", "type": "commit"}, {"oid": "0de92c1903dbcdf704659e60fef7cca95e65007d", "url": "https://github.com/pravega/pravega/commit/0de92c1903dbcdf704659e60fef7cca95e65007d", "message": "Merge remote-tracking branch 'origin/integration-tls-support' into integration-tls-support", "committedDate": "2020-11-26T03:51:01Z", "type": "commit"}, {"oid": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "url": "https://github.com/pravega/pravega/commit/a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "message": "Merge branch 'master' into integration-tls-support", "committedDate": "2020-11-26T11:19:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5NzY0NQ==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531097645", "bodyText": "It would be nice to add a single-sentence Javadoc to each of these explaining what they do. Others might find them useful in the future;", "author": "andreipaduroiu", "createdAt": "2020-11-26T15:21:23Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {", "originalCommit": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgxNTUwNw==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531815507", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-11-28T00:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5NzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5ODg5Ng==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531098896", "bodyText": "This is very inefficient. If you call this in a tight loop, then this will take a long time (due to constant reinitialization). Can you have this method take another argument that indicates how many events to write? Even if you don't use it now, someone in the future might find that useful.\nPS: if you do that, no need to call .get() upon each .writeEvent. Collect the futures in a list, and use Futures.allOf(...).get().\nPS2: A timeout for that .get might be useful too to pass to this method. But your call.", "author": "andreipaduroiu", "createdAt": "2020-11-26T15:23:38Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scopeName);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streamNames.forEach(s -> {\n+            boolean isStreamCreated =\n+                    streamManager.createStream(scopeName, s, StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope1, String stream1, String message1, ClientConfig writerClientConfig) {\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope1,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream1,", "originalCommit": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgxNTU2Nw==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531815567", "bodyText": "Sure, I've made the change in the latest commit I just pushed.", "author": "ravisharda", "createdAt": "2020-11-28T00:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5ODg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5OTQ1Mg==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531099452", "bodyText": "Same here. If you read just 1 message, this is OK. But as soon as you want to read more, then this method will be very slow.\nConsider taking a count argument and returning an (ordered) list of Strings representing the events.", "author": "andreipaduroiu", "createdAt": "2020-11-26T15:24:30Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scopeName);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streamNames.forEach(s -> {\n+            boolean isStreamCreated =\n+                    streamManager.createStream(scopeName, s, StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope1, String stream1, String message1, ClientConfig writerClientConfig) {\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope1,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream1,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        writer.writeEvent(message1).get();\n+        log.info(\"Wrote a message to the stream {}/{}\", scope1, stream1);\n+    }\n+\n+    public static String readAMessageFromStream(String scopeName, String streamName, ClientConfig readerClientConfig,", "originalCommit": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgxNTU5Ng==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531815596", "bodyText": "Have made this change as suggested.", "author": "ravisharda", "createdAt": "2020-11-28T00:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA5OTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwMDA4OA==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531100088", "bodyText": "It may surprise you but on Travis, this timeout may not be sufficient. Expect this to be a root cause for random failures.\nIf the timeout expires, you won't get a TimeoutException; rather the getEvent() will return null, which will likely manifest as a NullPtrEx upstream.", "author": "andreipaduroiu", "createdAt": "2020-11-26T15:25:34Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scopeName);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streamNames.forEach(s -> {\n+            boolean isStreamCreated =\n+                    streamManager.createStream(scopeName, s, StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope1, String stream1, String message1, ClientConfig writerClientConfig) {\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope1,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream1,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        writer.writeEvent(message1).get();\n+        log.info(\"Wrote a message to the stream {}/{}\", scope1, stream1);\n+    }\n+\n+    public static String readAMessageFromStream(String scopeName, String streamName, ClientConfig readerClientConfig,\n+                                                 String readerGroupName) {\n+        @Cleanup\n+        EventStreamClientFactory readerClientFactory = EventStreamClientFactory.withScope(scopeName, readerClientConfig);\n+        log.debug(\"Created the readerClientFactory\");\n+\n+        ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder()\n+                .stream(Stream.of(scopeName, streamName))\n+                .disableAutomaticCheckpoints()\n+                .build();\n+        @Cleanup\n+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scopeName, readerClientConfig);\n+        readerGroupManager.createReaderGroup(readerGroupName, readerGroupConfig);\n+        log.debug(\"Created reader group with name {}\", readerGroupName);\n+\n+        @Cleanup\n+        EventStreamReader<String> reader = readerClientFactory.createReader(\n+                \"readerId\", readerGroupName,\n+                new JavaSerializer<String>(), ReaderConfig.builder().initialAllocationDelay(0).build());\n+        log.debug(\"Created an event reader\");\n+\n+        // Keeping the read timeout large so that there is ample time for reading the event even in\n+        // case of abnormal delays in test environments.\n+        String readMessage = reader.readNextEvent(10000).getEvent();", "originalCommit": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgxNTY0NA==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531815644", "bodyText": "I've increased the timeout to account for that.", "author": "ravisharda", "createdAt": "2020-11-28T00:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwMDA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwMDQwNQ==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531100405", "bodyText": "You already used SneakyThrows in this class. You might as well use it here too.", "author": "andreipaduroiu", "createdAt": "2020-11-26T15:26:05Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    public static void createStreams(ClientConfig clientConfig, String scopeName, List<String> streamNames) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scopeName);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streamNames.forEach(s -> {\n+            boolean isStreamCreated =\n+                    streamManager.createStream(scopeName, s, StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope1, String stream1, String message1, ClientConfig writerClientConfig) {\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope1,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream1,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        writer.writeEvent(message1).get();\n+        log.info(\"Wrote a message to the stream {}/{}\", scope1, stream1);\n+    }\n+\n+    public static String readAMessageFromStream(String scopeName, String streamName, ClientConfig readerClientConfig,\n+                                                 String readerGroupName) {\n+        @Cleanup\n+        EventStreamClientFactory readerClientFactory = EventStreamClientFactory.withScope(scopeName, readerClientConfig);\n+        log.debug(\"Created the readerClientFactory\");\n+\n+        ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder()\n+                .stream(Stream.of(scopeName, streamName))\n+                .disableAutomaticCheckpoints()\n+                .build();\n+        @Cleanup\n+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scopeName, readerClientConfig);\n+        readerGroupManager.createReaderGroup(readerGroupName, readerGroupConfig);\n+        log.debug(\"Created reader group with name {}\", readerGroupName);\n+\n+        @Cleanup\n+        EventStreamReader<String> reader = readerClientFactory.createReader(\n+                \"readerId\", readerGroupName,\n+                new JavaSerializer<String>(), ReaderConfig.builder().initialAllocationDelay(0).build());\n+        log.debug(\"Created an event reader\");\n+\n+        // Keeping the read timeout large so that there is ample time for reading the event even in\n+        // case of abnormal delays in test environments.\n+        String readMessage = reader.readNextEvent(10000).getEvent();\n+        log.info(\"Done reading event [{}]\", readMessage);\n+        return readMessage;\n+    }\n+\n+    public static List<PasswordAuthHandlerInput.Entry> preparePasswordInputFileEntries(\n+            Map<String, String> entries, String password) {\n+        StrongPasswordProcessor passwordProcessor = StrongPasswordProcessor.builder().build();\n+        try {\n+            String encryptedPassword = passwordProcessor.encryptPassword(password);\n+            List<PasswordAuthHandlerInput.Entry> result = new ArrayList<>();\n+            entries.forEach((k, v) -> result.add(PasswordAuthHandlerInput.Entry.of(k, encryptedPassword, v)));\n+            return result;\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {", "originalCommit": "a93bf4c3f5b09c5733d5a6d091d6b4fddd6d81bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgxNTY3Ng==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531815676", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-11-28T00:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwMDQwNQ=="}], "type": "inlineReview"}, {"oid": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e", "url": "https://github.com/pravega/pravega/commit/ded72b53028bd37f3e5ae4cbf4fa69787e1a897e", "message": "Address review comments and minor refactorings for reusability\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-11-28T00:54:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg0MzM1MA==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531843350", "bodyText": "false is returned when the stream already exists.\nso in the idempotent case, do you want to throw the exception from here or return the boolean from this method signature to let the caller know so that they can deal with it.", "author": "shiveshr", "createdAt": "2020-11-28T04:18:23Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     */\n+    public static void createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scope);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streams.forEach(s -> {\n+            boolean isStreamCreated = streamManager.createStream(scope, s,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {", "originalCommit": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg4NjcyMg==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531886722", "bodyText": "Sure, I've modified the implementation to return a boolean that indicates whether all the objects were newly created or not.", "author": "ravisharda", "createdAt": "2020-11-28T05:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg0MzM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg0NTAyNQ==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531845025", "bodyText": "in case of a checkpoint event, you could get a null event.\ni think you should add event only when it is not a checkpoint event.\nor disable checkpoint in the readergroup config.\notherwise that can lead to some tests to fail.", "author": "shiveshr", "createdAt": "2020-11-28T04:20:40Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     */\n+    public static void createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean isScopeCreated = streamManager.createScope(scope);\n+        assertTrue(\"Failed to create scope\", isScopeCreated);\n+\n+        streams.forEach(s -> {\n+            boolean isStreamCreated = streamManager.createStream(scope, s,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            if (!isStreamCreated) {\n+                throw new RuntimeException(\"Failed to create stream: \" + s);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Write the {@code message} to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the message to write. If it is null, a default message will be used.\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope, String stream, String message, ClientConfig writerClientConfig) {\n+        writeDataToStream(scope, stream, message, 1, writerClientConfig);\n+    }\n+\n+    /**\n+     * Write the specified number of messages to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the event message to write. If it is null, a default message will be used.\n+     * @param numMessages the number of event messages to write\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static void writeDataToStream(@NonNull String scope, @NonNull String stream, String message, int numMessages,\n+                                         @NonNull ClientConfig writerClientConfig) {\n+        Preconditions.checkArgument(numMessages > 0);\n+        if (message == null) {\n+            message = \"Test message\";\n+        }\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        List<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (int i = 0; i < numMessages; i++) {\n+            futures.add(writer.writeEvent(message));\n+        }\n+        Futures.allOf(futures).join();\n+        log.info(\"Wrote {} message(s) to the stream {}/{}\", numMessages, scope, stream);\n+    }\n+\n+    /**\n+     * Returns the first message from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event message\n+     */\n+    public static String readAMessageFromStream(String scope, String stream, ClientConfig readerClientConfig,\n+                                                 String readerGroup) {\n+        List<String> messages = readDataFromStream(scope, stream, 1, readerClientConfig, readerGroup);\n+        if (messages == null || messages.size() == 0) {\n+            return null;\n+        } else {\n+            return messages.get(0);\n+        }\n+    }\n+\n+    /**\n+     * Returns the specified number of messages from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param numMessages the number of event messages to write\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event messages\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static List<String> readDataFromStream(@NonNull String scope, @NonNull String stream, int numMessages,\n+                                            @NonNull ClientConfig readerClientConfig, @NonNull String readerGroup) {\n+        Preconditions.checkArgument(numMessages > 0);\n+\n+        @Cleanup\n+        EventStreamClientFactory readerClientFactory = EventStreamClientFactory.withScope(scope, readerClientConfig);\n+        log.debug(\"Created the readerClientFactory\");\n+\n+        ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder()\n+                .stream(Stream.of(scope, stream))\n+                .disableAutomaticCheckpoints()\n+                .build();\n+        @Cleanup\n+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scope, readerClientConfig);\n+        readerGroupManager.createReaderGroup(readerGroup, readerGroupConfig);\n+        log.debug(\"Created reader group with name {}\", readerGroup);\n+\n+        @Cleanup\n+        EventStreamReader<String> reader = readerClientFactory.createReader(\n+                \"readerId\", readerGroup,\n+                new JavaSerializer<String>(), ReaderConfig.builder().initialAllocationDelay(0).build());\n+        log.debug(\"Created an event reader\");\n+\n+        // Keeping the read timeout large so that there is ample time for reading the event even in\n+        // case of abnormal delays in test environments.\n+        List<String> result = new ArrayList<>();\n+        for (int i = 0; i < numMessages; i++) {\n+            result.add(reader.readNextEvent(20000).getEvent());", "originalCommit": "ded72b53028bd37f3e5ae4cbf4fa69787e1a897e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg4NzgyNA==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r531887824", "bodyText": "We are assuming that the checkpoint is disabled in the reader group:\n\n  \n    \n      pravega/test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java\n    \n    \n        Lines 161 to 164\n      in\n      4788434\n    \n    \n    \n    \n\n        \n          \n           ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder() \n        \n\n        \n          \n                   .stream(Stream.of(scope, stream)) \n        \n\n        \n          \n                   .disableAutomaticCheckpoints() \n        \n\n        \n          \n                   .build();", "author": "ravisharda", "createdAt": "2020-11-28T05:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTg0NTAyNQ=="}], "type": "inlineReview"}, {"oid": "4788434e05b3cafc4dfc7e2bb2c56112ab6ac2ef", "url": "https://github.com/pravega/pravega/commit/4788434e05b3cafc4dfc7e2bb2c56112ab6ac2ef", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-11-28T05:16:22Z", "type": "commit"}, {"oid": "b910615c306dd84dece6c79537819b9d2931a064", "url": "https://github.com/pravega/pravega/commit/b910615c306dd84dece6c79537819b9d2931a064", "message": "Merge branch 'master' into integration-tls-support", "committedDate": "2020-11-29T09:34:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzMTg5OA==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532331898", "bodyText": "we can simply use a writer.flush() here.", "author": "shrids", "createdAt": "2020-11-30T03:40:09Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     * @return whether all the objects (scope and each of the streams) were newly created. Returns {@code false}, if\n+     *         any of those objects were already present.\n+     */\n+    public static boolean createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean result = streamManager.createScope(scope);\n+        for (String stream: streams) {\n+            boolean isStreamCreated = streamManager.createStream(scope, stream,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            result = result && !isStreamCreated ? false : true;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Write the {@code message} to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the message to write. If it is null, a default message will be used.\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope, String stream, String message, ClientConfig writerClientConfig) {\n+        writeDataToStream(scope, stream, message, 1, writerClientConfig);\n+    }\n+\n+    /**\n+     * Write the specified number of messages to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the event message to write. If it is null, a default message will be used.\n+     * @param numMessages the number of event messages to write\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static void writeDataToStream(@NonNull String scope, @NonNull String stream, String message, int numMessages,\n+                                         @NonNull ClientConfig writerClientConfig) {\n+        Preconditions.checkArgument(numMessages > 0);\n+        if (message == null) {\n+            message = \"Test message\";\n+        }\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        List<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (int i = 0; i < numMessages; i++) {\n+            futures.add(writer.writeEvent(message));\n+        }\n+        Futures.allOf(futures).join();", "originalCommit": "b910615c306dd84dece6c79537819b9d2931a064", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2NDgyOQ==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532364829", "bodyText": "Thanks. That change makes the code much simpler. I've made the change as suggested.", "author": "ravisharda", "createdAt": "2020-11-30T06:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzMTg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzMzgzNw==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532333837", "bodyText": "Since the reader group is not deleted invoking readDataFromStream(..) again would cause the method to read the next events from the stream. So we should document this behaviour or perhaps invoke delete reader group or change the name of the method to convey this behaviour perhaps as readNextEvents(..)", "author": "shrids", "createdAt": "2020-11-30T03:49:32Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     * @return whether all the objects (scope and each of the streams) were newly created. Returns {@code false}, if\n+     *         any of those objects were already present.\n+     */\n+    public static boolean createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean result = streamManager.createScope(scope);\n+        for (String stream: streams) {\n+            boolean isStreamCreated = streamManager.createStream(scope, stream,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            result = result && !isStreamCreated ? false : true;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Write the {@code message} to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the message to write. If it is null, a default message will be used.\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope, String stream, String message, ClientConfig writerClientConfig) {\n+        writeDataToStream(scope, stream, message, 1, writerClientConfig);\n+    }\n+\n+    /**\n+     * Write the specified number of messages to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the event message to write. If it is null, a default message will be used.\n+     * @param numMessages the number of event messages to write\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static void writeDataToStream(@NonNull String scope, @NonNull String stream, String message, int numMessages,\n+                                         @NonNull ClientConfig writerClientConfig) {\n+        Preconditions.checkArgument(numMessages > 0);\n+        if (message == null) {\n+            message = \"Test message\";\n+        }\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        List<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (int i = 0; i < numMessages; i++) {\n+            futures.add(writer.writeEvent(message));\n+        }\n+        Futures.allOf(futures).join();\n+        log.info(\"Wrote {} message(s) to the stream {}/{}\", numMessages, scope, stream);\n+    }\n+\n+    /**\n+     * Returns the first message from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event message\n+     */\n+    public static String readAMessageFromStream(String scope, String stream, ClientConfig readerClientConfig,\n+                                                String readerGroup) {\n+        List<String> messages = readDataFromStream(scope, stream, 1, readerClientConfig, readerGroup);\n+        if (messages == null || messages.size() == 0) {\n+            return null;\n+        } else {\n+            return messages.get(0);\n+        }\n+    }\n+\n+    /**\n+     * Returns the specified number of messages from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param numMessages the number of event messages to write\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event messages\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static List<String> readDataFromStream(@NonNull String scope, @NonNull String stream, int numMessages,\n+                                                  @NonNull ClientConfig readerClientConfig, @NonNull String readerGroup) {\n+        Preconditions.checkArgument(numMessages > 0);\n+\n+        @Cleanup\n+        EventStreamClientFactory readerClientFactory = EventStreamClientFactory.withScope(scope, readerClientConfig);\n+        log.debug(\"Created the readerClientFactory\");\n+\n+        ReaderGroupConfig readerGroupConfig = ReaderGroupConfig.builder()\n+                .stream(Stream.of(scope, stream))\n+                .disableAutomaticCheckpoints()\n+                .build();\n+        @Cleanup\n+        ReaderGroupManager readerGroupManager = ReaderGroupManager.withScope(scope, readerClientConfig);\n+        readerGroupManager.createReaderGroup(readerGroup, readerGroupConfig);\n+        log.debug(\"Created reader group with name {}\", readerGroup);\n+\n+        @Cleanup\n+        EventStreamReader<String> reader = readerClientFactory.createReader(", "originalCommit": "b910615c306dd84dece6c79537819b9d2931a064", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2NTAzMw==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532365033", "bodyText": "Sure, I've renamed the methods, so that they better represent the behavior that these methods exhibit.", "author": "ravisharda", "createdAt": "2020-11-30T06:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjMzMzgzNw=="}], "type": "inlineReview"}, {"oid": "cd977c0ae127210e0300a10772f2bb9c9fbac082", "url": "https://github.com/pravega/pravega/commit/cd977c0ae127210e0300a10772f2bb9c9fbac082", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-11-30T06:04:40Z", "type": "commit"}, {"oid": "795d86d56d92d74c407e6c7efe857383ddd49606", "url": "https://github.com/pravega/pravega/commit/795d86d56d92d74c407e6c7efe857383ddd49606", "message": "Merge remote-tracking branch 'origin/integration-tls-support' into integration-tls-support", "committedDate": "2020-11-30T06:04:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2NjQyNA==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532366424", "bodyText": "typo.", "author": "shrids", "createdAt": "2020-11-30T06:11:17Z", "path": "test/integration/src/main/java/io/pravega/test/integration/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.integration.utils;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.admin.ReaderGroupManager;\n+import io.pravega.client.admin.StreamManager;\n+import io.pravega.client.stream.EventStreamReader;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.stream.ReaderConfig;\n+import io.pravega.client.stream.ReaderGroupConfig;\n+import io.pravega.client.stream.ScalingPolicy;\n+import io.pravega.client.stream.Stream;\n+import io.pravega.client.stream.StreamConfiguration;\n+import io.pravega.client.stream.impl.JavaSerializer;\n+import io.pravega.shared.security.auth.PasswordAuthHandlerInput;\n+import io.pravega.shared.security.crypto.StrongPasswordProcessor;\n+import lombok.Cleanup;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ * A helper class with general-purpose utility methods for integration tests.\n+ */\n+@Slf4j\n+public class TestUtils {\n+\n+    /**\n+     * Creates the specified {@code scope} and {@code streams}, using the specified {@code clientConfig}.\n+     *\n+     * Note: This method creates the streams using a scaling policy with a fixed number of segments (one each).\n+     *\n+     * @param clientConfig the {@link ClientConfig} to use for connecting to the server\n+     * @param scope the scope\n+     * @param streams the streams\n+     * @return whether all the objects (scope and each of the streams) were newly created. Returns {@code false}, if\n+     *         any of those objects were already present.\n+     */\n+    public static boolean createScopeAndStreams(ClientConfig clientConfig, String scope, List<String> streams) {\n+        @Cleanup\n+        StreamManager streamManager = StreamManager.create(clientConfig);\n+        assertNotNull(streamManager);\n+\n+        boolean result = streamManager.createScope(scope);\n+        for (String stream: streams) {\n+            boolean isStreamCreated = streamManager.createStream(scope, stream,\n+                    StreamConfiguration.builder().scalingPolicy(ScalingPolicy.fixed(1)).build());\n+            result = result && !isStreamCreated ? false : true;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Write the {@code message} to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the message to write. If it is null, a default message will be used.\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    @SneakyThrows\n+    public static void writeDataToStream(String scope, String stream, String message, ClientConfig writerClientConfig) {\n+        writeDataToStream(scope, stream, message, 1, writerClientConfig);\n+    }\n+\n+    /**\n+     * Write the specified number of messages to the specified {@code scope}/{@code stream}, using the\n+     * provided {@writerClientConfig}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param message the event message to write. If it is null, a default message will be used.\n+     * @param numMessages the number of event messages to write\n+     * @param writerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @throws NullPointerException if {@code scope} or {@code stream} or {@writerClientConfig} is null\n+     * @throws IllegalArgumentException if {@code numMessages} < 1\n+     * @throws RuntimeException if any exception is thrown by the client\n+     */\n+    public static void writeDataToStream(@NonNull String scope, @NonNull String stream, String message, int numMessages,\n+                                         @NonNull ClientConfig writerClientConfig) {\n+        Preconditions.checkArgument(numMessages > 0);\n+        if (message == null) {\n+            message = \"Test message\";\n+        }\n+        @Cleanup final EventStreamClientFactory writerClientFactory = EventStreamClientFactory.withScope(scope,\n+                writerClientConfig);\n+\n+        @Cleanup final EventStreamWriter<String> writer = writerClientFactory.createEventWriter(stream,\n+                new JavaSerializer<String>(),\n+                EventWriterConfig.builder().build());\n+        for (int i = 0; i < numMessages; i++) {\n+            writer.writeEvent(message);\n+        }\n+        writer.flush();\n+        log.info(\"Wrote {} message(s) to the stream {}/{}\", numMessages, scope, stream);\n+    }\n+\n+    /**\n+     * Returns the next unread message from the specified {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param readerClientConfig the {@link ClientConfig} object to use to connect to the server\n+     * @param readerGroup the name of the reader group application\n+     * @return the event message\n+     */\n+    public static String readNextEventMessage(String scope, String stream, ClientConfig readerClientConfig,\n+                                              String readerGroup) {\n+        List<String> messages = readNextEventMessages(scope, stream, 1, readerClientConfig, readerGroup);\n+        if (messages == null || messages.size() == 0) {\n+            return null;\n+        } else {\n+            return messages.get(0);\n+        }\n+    }\n+\n+    /**\n+     * Returns the specified number of unread messages from the given {@code scope}/{@code stream}.\n+     *\n+     * @param scope the scope\n+     * @param stream the stream\n+     * @param numMessages the number of event messages to write", "originalCommit": "795d86d56d92d74c407e6c7efe857383ddd49606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NjA5NQ==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532396095", "bodyText": "Great catch - truly a hard to find one! I've fixed it now.", "author": "ravisharda", "createdAt": "2020-11-30T07:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2NjQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2ODA4NQ==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532368085", "bodyText": "new ClustuerWrapper() will ensure the defaults are not used. Should we make the default constructor private to enforce the builder pattern?", "author": "shrids", "createdAt": "2020-11-30T06:17:18Z", "path": "test/integration/src/main/java/io/pravega/test/integration/demo/ClusterWrapper.java", "diffHunk": "@@ -65,52 +72,58 @@\n \n     private ServiceBuilder serviceBuilder;\n \n-    private ScheduledExecutorService executor;\n+    @Builder.Default\n+    private ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n \n-    // Configuration\n-    private boolean isAuthEnabled;\n-    private String tokenSigningKeyBasis;\n-    private boolean isRGWritesWithReadPermEnabled;\n-    private int tokenTtlInSeconds;\n+    @Getter\n+    @Builder.Default\n+    private boolean authEnabled = false;\n+\n+    @Getter\n+    @Builder.Default", "originalCommit": "795d86d56d92d74c407e6c7efe857383ddd49606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NjYxNg==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532396616", "bodyText": "Sure, I've now made the change to prevent instantiation using the default constructor.", "author": "ravisharda", "createdAt": "2020-11-30T07:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2ODA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2OTA1NQ==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532369055", "bodyText": "Does this @builder generate a seperate builder?", "author": "shrids", "createdAt": "2020-11-30T06:20:20Z", "path": "test/integration/src/main/java/io/pravega/test/integration/demo/ControllerWrapper.java", "diffHunk": "@@ -102,6 +103,21 @@ public ControllerWrapper(final String connectionString, final boolean disableEve\n                              boolean enableAuth, String passwordAuthHandlerInputFilePath,\n                              String tokenSigningKey, boolean isRGWritesWithReadPermEnabled,\n                              int accessTokenTtlInSeconds) {\n+        this (connectionString, disableEventProcessor, disableControllerCluster, controllerPort, serviceHost,\n+                servicePort, containerCount, restPort, enableAuth, passwordAuthHandlerInputFilePath, tokenSigningKey,\n+                isRGWritesWithReadPermEnabled, accessTokenTtlInSeconds, false, \"\", \"\", \"\", \"\", false);\n+    }\n+\n+    @Builder", "originalCommit": "795d86d56d92d74c407e6c7efe857383ddd49606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM4MDA0Ng==", "url": "https://github.com/pravega/pravega/pull/5378#discussion_r532380046", "bodyText": "It generates a builder for the ControllerWrapper based on the parameters used in this Constructor (as opposed to the Class-level annotation we use in the ClusterWrapper). The idea was to avoid interface changes to ControllerWrapper so that the many tests that use it don't need to change.", "author": "ravisharda", "createdAt": "2020-11-30T06:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM2OTA1NQ=="}], "type": "inlineReview"}, {"oid": "26f59c54e2357bd81d884f056b71826ed46685ad", "url": "https://github.com/pravega/pravega/commit/26f59c54e2357bd81d884f056b71826ed46685ad", "message": "Address review comments and remove an unnecessary config\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-11-30T07:18:55Z", "type": "commit"}]}