{"pr_number": 5402, "pr_title": "Issue 5401: Fixing resource leaks in tests", "pr_createdAt": "2020-12-04T02:54:20Z", "pr_url": "https://github.com/pravega/pravega/pull/5402", "timeline": [{"oid": "56280c39116d6da4f9128d95ff370b0f216c35ca", "url": "https://github.com/pravega/pravega/commit/56280c39116d6da4f9128d95ff370b0f216c35ca", "message": "Fixing thread pool leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-04T02:51:10Z", "type": "commit"}, {"oid": "31f4f12088b81e94b95052aaead8ab2f1a6f969f", "url": "https://github.com/pravega/pravega/commit/31f4f12088b81e94b95052aaead8ab2f1a6f969f", "message": "Merge remote-tracking branch 'origin/master' into issue-5401-leaks", "committedDate": "2020-12-04T02:51:50Z", "type": "commit"}, {"oid": "7e13a9b5adf4e099bf82bc0aa9c63b789043e4e7", "url": "https://github.com/pravega/pravega/commit/7e13a9b5adf4e099bf82bc0aa9c63b789043e4e7", "message": "Merge branch 'master' into issue-5401-leaks", "committedDate": "2020-12-04T15:58:00Z", "type": "commit"}, {"oid": "808c8639aaa85dcb2bd262d71f0541e6307a50c6", "url": "https://github.com/pravega/pravega/commit/808c8639aaa85dcb2bd262d71f0541e6307a50c6", "message": "Fixing thread pool leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-04T17:56:48Z", "type": "commit"}, {"oid": "eceac8e181d33f08971d6d0507cd3259f882913b", "url": "https://github.com/pravega/pravega/commit/eceac8e181d33f08971d6d0507cd3259f882913b", "message": "Merge remote-tracking branch 'ap/issue-5401-leaks' into issue-5401-leaks", "committedDate": "2020-12-04T17:56:58Z", "type": "commit"}, {"oid": "4c6822524f655e6c79e57c65f371b26c0e9b6e1f", "url": "https://github.com/pravega/pravega/commit/4c6822524f655e6c79e57c65f371b26c0e9b6e1f", "message": "Fixing thread pool leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-04T19:18:49Z", "type": "commit"}, {"oid": "28f1bfecd5e313a392dbeb0ea6b322bdc5f3e20c", "url": "https://github.com/pravega/pravega/commit/28f1bfecd5e313a392dbeb0ea6b322bdc5f3e20c", "message": "Fixing thread pool leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-04T21:37:33Z", "type": "commit"}, {"oid": "9a9a4b48a022492891d25e01f10f8e2602f4ee83", "url": "https://github.com/pravega/pravega/commit/9a9a4b48a022492891d25e01f10f8e2602f4ee83", "message": "Reverting debug settings.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-05T01:49:01Z", "type": "commit"}, {"oid": "3467ff699cfeb2b8702e132d6b678e7a68b7591b", "url": "https://github.com/pravega/pravega/commit/3467ff699cfeb2b8702e132d6b678e7a68b7591b", "message": "Debugging leaks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-05T21:58:59Z", "type": "commit"}, {"oid": "1048e4034b42ee225020b909ce284b0f9aa92dd4", "url": "https://github.com/pravega/pravega/commit/1048e4034b42ee225020b909ce284b0f9aa92dd4", "message": "Trying to clean more stuff.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-06T03:18:47Z", "type": "commit"}, {"oid": "efb02ac7b323deb05782d41083c4973d03c88e56", "url": "https://github.com/pravega/pravega/commit/efb02ac7b323deb05782d41083c4973d03c88e56", "message": "Trying to clean more stuff.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-06T03:51:52Z", "type": "commit"}, {"oid": "2b63c9945581f703f05c992285bdc66591bbec3f", "url": "https://github.com/pravega/pravega/commit/2b63c9945581f703f05c992285bdc66591bbec3f", "message": "Handling controller client shutdown exceptions that would prevent subsequent resources from being cleaned up.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-06T18:37:57Z", "type": "commit"}, {"oid": "632e22a01706fe7231e55c65c282c9f9e48fe9d0", "url": "https://github.com/pravega/pravega/commit/632e22a01706fe7231e55c65c282c9f9e48fe9d0", "message": "Merge branch 'master' into issue-5401-leaks", "committedDate": "2020-12-06T19:17:58Z", "type": "commit"}, {"oid": "787780c50aa566e87a4f305156150f364f374d85", "url": "https://github.com/pravega/pravega/commit/787780c50aa566e87a4f305156150f364f374d85", "message": "Merge branch 'master' into issue-5401-leaks", "committedDate": "2020-12-07T16:28:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2MTkyNQ==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537661925", "bodyText": "Should all callers of close() use this invokeSafely() helper? Such as KeyValueTableManagerImpl above?", "author": "derekm", "createdAt": "2020-12-07T16:51:34Z", "path": "client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java", "diffHunk": "@@ -208,7 +207,7 @@ public StreamInfo getStreamInfo(String scopeName, String streamName) {\n     @Override\n     public void close() {\n         if (this.controller != null) {\n-            this.controller.close();\n+            Callbacks.invokeSafely(this.controller::close, ex -> log.error(\"Unable to close Controller client.\", ex));", "originalCommit": "787780c50aa566e87a4f305156150f364f374d85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4NzE0OQ==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537687149", "bodyText": "Normally close shouldn't throw anything. But Java's AutoCloseable.close defines a throws Exception to handle the general case.\nWhat I found is that the Controller and Controller client have some issues when closing. They use numerous sub-components and when they shut down, some may hang forever or throw an exception during shutdown. This prevents whatever else is supposed to close next to never be closed and stick in memory forever.\nThe real fix is to figure out what is hanging or throwing exceptions and dealing with them appropriately. However the Controller is not my area of expertise, so I decided to leave that for another time (otherwise I would not be able to finish this by January).", "author": "andreipaduroiu", "createdAt": "2020-12-07T17:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2MTkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2MzkxOA==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537663918", "bodyText": "Is this close() redundant to the @Cleanup annotation a few lines above?", "author": "derekm", "createdAt": "2020-12-07T16:54:10Z", "path": "client/src/test/java/io/pravega/client/stream/impl/ClientFactoryTest.java", "diffHunk": "@@ -105,8 +106,10 @@ public void testEventWriterSealedStream() {\n                 .thenReturn(CompletableFuture.completedFuture(currentSegments));\n \n         EventWriterConfig writerConfig = EventWriterConfig.builder().build();\n+        @Cleanup\n         EventStreamWriter<String> writer = clientFactory.createEventWriter(stream, new JavaSerializer<String>(), writerConfig);\n         assertEquals(writerConfig, writer.getConfig());\n+        writer.close();", "originalCommit": "787780c50aa566e87a4f305156150f364f374d85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4Nzk4MQ==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537687981", "bodyText": "If the test fails somewhere before this line, the writer will never be cleaned up. So whatever connections and thread pools it opens (yes, it does that), will stick around. Cleanup is essentially rewriting the code as a try-finally to make sure that whatever we have declared as needing cleanup will be closed when the code exits", "author": "andreipaduroiu", "createdAt": "2020-12-07T17:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2MzkxOA=="}], "type": "inlineReview"}, {"oid": "99fdf51000e6e49355c1b74d382156716a76aadc", "url": "https://github.com/pravega/pravega/commit/99fdf51000e6e49355c1b74d382156716a76aadc", "message": "Unit test coverage.\nRemoving debugging code.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-07T18:03:44Z", "type": "commit"}, {"oid": "61b665232694f5bee424f87de637d2c36836633e", "url": "https://github.com/pravega/pravega/commit/61b665232694f5bee424f87de637d2c36836633e", "message": "Merge branch 'master' into issue-5401-leaks", "committedDate": "2020-12-07T20:30:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NjAxOQ==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537766019", "bodyText": "Maybe something should be printed to standard error in addition to the system exit.", "author": "tkaitchuck", "createdAt": "2020-12-07T19:21:49Z", "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceFactory.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Creates Thread Pools for use within Pravega codebase.\n+ */\n+@Slf4j\n+final class ExecutorServiceFactory {\n+    //region Members\n+\n+    @VisibleForTesting\n+    static final String DETECTION_LEVEL_PROPERTY_NAME = \"ThreadLeakDetectionLevel\";\n+    @VisibleForTesting\n+    private final ThreadLeakDetectionLevel detectionLevel;\n+    private final CreateScheduledExecutor createScheduledExecutor;\n+    private final CreateShrinkingExecutor createShrinkingExecutor;\n+    private final Runnable onLeakDetected;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory} which extracts the {@link ThreadLeakDetectionLevel}\n+     * from system properties and halts the VM if a leak is detected and {@link ThreadLeakDetectionLevel} is set to\n+     * {@link ThreadLeakDetectionLevel#Aggressive}.\n+     */\n+    ExecutorServiceFactory() {\n+        this(getDetectionLevel(), () -> System.exit(99));", "originalCommit": "99fdf51000e6e49355c1b74d382156716a76aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNjcyMg==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537826722", "bodyText": "At line 256, we print out a log.error. Prior to that we dump the stack trace of that exception that we logged. That should be sufficient info for someone to debug.", "author": "andreipaduroiu", "createdAt": "2020-12-07T20:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NjAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTI4NA==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537769284", "bodyText": "We probably only want to capture this stack trace if the level is not \"none\".", "author": "tkaitchuck", "createdAt": "2020-12-07T19:27:00Z", "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceFactory.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Creates Thread Pools for use within Pravega codebase.\n+ */\n+@Slf4j\n+final class ExecutorServiceFactory {\n+    //region Members\n+\n+    @VisibleForTesting\n+    static final String DETECTION_LEVEL_PROPERTY_NAME = \"ThreadLeakDetectionLevel\";\n+    @VisibleForTesting\n+    private final ThreadLeakDetectionLevel detectionLevel;\n+    private final CreateScheduledExecutor createScheduledExecutor;\n+    private final CreateShrinkingExecutor createShrinkingExecutor;\n+    private final Runnable onLeakDetected;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory} which extracts the {@link ThreadLeakDetectionLevel}\n+     * from system properties and halts the VM if a leak is detected and {@link ThreadLeakDetectionLevel} is set to\n+     * {@link ThreadLeakDetectionLevel#Aggressive}.\n+     */\n+    ExecutorServiceFactory() {\n+        this(getDetectionLevel(), () -> System.exit(99));\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory}.\n+     *\n+     * @param level          The {@link ThreadLeakDetectionLevel} to use.\n+     * @param onLeakDetected A {@link Runnable} that will be invoked if {@link ThreadLeakDetectionLevel} is set to\n+     *                       {@link ThreadLeakDetectionLevel#Aggressive} and a leak is detected.\n+     */\n+    @VisibleForTesting\n+    ExecutorServiceFactory(@NonNull ThreadLeakDetectionLevel level, @NonNull Runnable onLeakDetected) {\n+        this.detectionLevel = level;\n+        this.onLeakDetected = onLeakDetected;\n+\n+        // In all of the below, the ThreadFactory is created in this class, and its toString() returns the pool name.\n+        if (this.detectionLevel == ThreadLeakDetectionLevel.None) {\n+            this.createScheduledExecutor = (size, factory) -> new ScheduledThreadPoolExecutor(size, factory, new CallerRuns(factory.toString()));\n+            this.createShrinkingExecutor = (maxThreadCount, threadTimeout, factory) ->\n+                    new ThreadPoolExecutor(0, maxThreadCount, threadTimeout, TimeUnit.MILLISECONDS,\n+                            new LinkedBlockingQueue<>(), factory, new CallerRuns(factory.toString()));\n+        } else {\n+            // Light and Aggressive need a special executor that overrides the finalize() method.\n+            this.createScheduledExecutor = (size, factory) -> {\n+                logNewThreadPoolCreated(factory.toString());\n+                return new LeakDetectorScheduledExecutorService(size, factory, new CallerRuns(factory.toString()));\n+            };\n+            this.createShrinkingExecutor = (maxThreadCount, threadTimeout, factory) -> {\n+                logNewThreadPoolCreated(factory.toString());\n+                return new LeakDetectorThreadPoolExecutor(0, maxThreadCount, threadTimeout, TimeUnit.MILLISECONDS,\n+                        new LinkedBlockingQueue<>(), factory, new CallerRuns(factory.toString()));\n+            };\n+        }\n+    }\n+\n+    /**\n+     * Gets the {@link ThreadLeakDetectionLevel} from System Properties (Key = {@link #DETECTION_LEVEL_PROPERTY_NAME}).\n+     *\n+     * @return The {@link ThreadLeakDetectionLevel}, or {@link ThreadLeakDetectionLevel#None} if not defined in System\n+     * Properties.\n+     * @throws IllegalArgumentException If the system property defines a value is not valid.\n+     */\n+    @VisibleForTesting\n+    static ThreadLeakDetectionLevel getDetectionLevel() {\n+        return ThreadLeakDetectionLevel.valueOf(\n+                System.getProperty(\"ThreadLeakDetectionLevel\", ThreadLeakDetectionLevel.None.name()));\n+    }\n+\n+    //endregion\n+\n+    //region Factory Methods\n+\n+    /**\n+     * Creates and returns a thread factory that will create threads with the given name prefix.\n+     *\n+     * @param groupName the name of the threads\n+     * @return a thread factory\n+     */\n+    ThreadFactory getThreadFactory(String groupName) {\n+        return getThreadFactory(groupName, Thread.NORM_PRIORITY);\n+    }\n+\n+    /**\n+     * Creates and returns a thread factory that will create threads with the given name prefix and thread priority.\n+     *\n+     * @param groupName the name of the threads\n+     * @param priority  the priority to be assigned to the thread.\n+     * @return a thread factory\n+     */\n+    ThreadFactory getThreadFactory(String groupName, int priority) {\n+        return new ThreadFactory() {\n+            final AtomicInteger threadCount = new AtomicInteger();\n+\n+            @Override\n+            public String toString() {\n+                return groupName;\n+            }\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = new Thread(r, groupName + \"-\" + threadCount.incrementAndGet());\n+                thread.setUncaughtExceptionHandler(new LogUncaughtExceptions());\n+                thread.setDaemon(true);\n+                thread.setPriority(priority);\n+                return thread;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a new ScheduledExecutorService that will use daemon threads with specified priority and names.\n+     *\n+     * @param size           The number of threads in the threadpool\n+     * @param poolName       The name of the pool (this will be printed in logs)\n+     * @param threadPriority The priority to be assigned to the threads\n+     * @return A new executor service.\n+     */\n+    ScheduledExecutorService newScheduledThreadPool(int size, String poolName, int threadPriority) {\n+        ThreadFactory threadFactory = getThreadFactory(poolName, threadPriority);\n+\n+        // Caller runs only occurs after shutdown, as queue size is unbounded.\n+        ScheduledThreadPoolExecutor result = this.createScheduledExecutor.apply(size, threadFactory);\n+\n+        // Do not execute any periodic tasks after shutdown.\n+        result.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n+\n+        // Do not execute any delayed tasks after shutdown.\n+        result.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+\n+        // Remove tasks from the executor once they are done executing. By default, even when canceled, these tasks are\n+        // not removed; if this setting is not enabled we could end up with leaked (and obsolete) tasks.\n+        result.setRemoveOnCancelPolicy(true);\n+        return result;\n+    }\n+\n+    /**\n+     * Operates like Executors.cachedThreadPool but with a custom thread timeout and pool name.\n+     *\n+     * @param maxThreadCount The maximum number of threads to allow in the pool.\n+     * @param threadTimeout  the number of milliseconds that a thread should sit idle before shutting down.\n+     * @param poolName       The name of the threadpool.\n+     * @return A new threadPool\n+     */\n+    ThreadPoolExecutor newShrinkingExecutor(int maxThreadCount, int threadTimeout, String poolName) {\n+        ThreadFactory factory = getThreadFactory(poolName);\n+        return this.createShrinkingExecutor.apply(maxThreadCount, threadTimeout, factory);\n+    }\n+\n+    //endregion\n+\n+    //region ThreadFactory Helper Classes\n+\n+    private static final class LogUncaughtExceptions implements Thread.UncaughtExceptionHandler {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+            log.error(\"Exception thrown out of root of thread: \" + t.getName(), e);\n+        }\n+    }\n+\n+    @Data\n+    private static class CallerRuns implements RejectedExecutionHandler {\n+        private final String poolName;\n+\n+        @Override\n+        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n+            log.debug(\"Caller to executor: \" + poolName + \" rejected and run in the caller.\");\n+            r.run();\n+        }\n+    }\n+\n+    //endregion\n+\n+    //region Leak Detection Pools\n+\n+    private class LeakDetectorScheduledExecutorService extends ScheduledThreadPoolExecutor {\n+        private final Exception stackTraceEx;\n+\n+        LeakDetectorScheduledExecutorService(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n+            super(corePoolSize, threadFactory, handler);\n+            this.stackTraceEx = new Exception();\n+        }\n+\n+        protected void finalize() {\n+            checkThreadPoolLeak(this, this.stackTraceEx);\n+            super.finalize();\n+        }\n+    }\n+\n+    private class LeakDetectorThreadPoolExecutor extends ThreadPoolExecutor {\n+        private final Exception stackTraceEx;\n+\n+        LeakDetectorThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,\n+                                       ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n+            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n+            this.stackTraceEx = new Exception();", "originalCommit": "99fdf51000e6e49355c1b74d382156716a76aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNzI0MQ==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537827241", "bodyText": "This class is only instantiated if level != None. If it's set to None, the code path above will create the base (JDK) thread pool so this code is not even executed.", "author": "andreipaduroiu", "createdAt": "2020-12-07T20:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MDkyNA==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537770924", "bodyText": "It's a bit odd that onLeakDetected is defined elsewhere given that it is only invoked in this Agressive code path. I think this can reasonably be inlined.", "author": "tkaitchuck", "createdAt": "2020-12-07T19:29:26Z", "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceFactory.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Creates Thread Pools for use within Pravega codebase.\n+ */\n+@Slf4j\n+final class ExecutorServiceFactory {\n+    //region Members\n+\n+    @VisibleForTesting\n+    static final String DETECTION_LEVEL_PROPERTY_NAME = \"ThreadLeakDetectionLevel\";\n+    @VisibleForTesting\n+    private final ThreadLeakDetectionLevel detectionLevel;\n+    private final CreateScheduledExecutor createScheduledExecutor;\n+    private final CreateShrinkingExecutor createShrinkingExecutor;\n+    private final Runnable onLeakDetected;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory} which extracts the {@link ThreadLeakDetectionLevel}\n+     * from system properties and halts the VM if a leak is detected and {@link ThreadLeakDetectionLevel} is set to\n+     * {@link ThreadLeakDetectionLevel#Aggressive}.\n+     */\n+    ExecutorServiceFactory() {\n+        this(getDetectionLevel(), () -> System.exit(99));\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link ExecutorServiceFactory}.\n+     *\n+     * @param level          The {@link ThreadLeakDetectionLevel} to use.\n+     * @param onLeakDetected A {@link Runnable} that will be invoked if {@link ThreadLeakDetectionLevel} is set to\n+     *                       {@link ThreadLeakDetectionLevel#Aggressive} and a leak is detected.\n+     */\n+    @VisibleForTesting\n+    ExecutorServiceFactory(@NonNull ThreadLeakDetectionLevel level, @NonNull Runnable onLeakDetected) {\n+        this.detectionLevel = level;\n+        this.onLeakDetected = onLeakDetected;\n+\n+        // In all of the below, the ThreadFactory is created in this class, and its toString() returns the pool name.\n+        if (this.detectionLevel == ThreadLeakDetectionLevel.None) {\n+            this.createScheduledExecutor = (size, factory) -> new ScheduledThreadPoolExecutor(size, factory, new CallerRuns(factory.toString()));\n+            this.createShrinkingExecutor = (maxThreadCount, threadTimeout, factory) ->\n+                    new ThreadPoolExecutor(0, maxThreadCount, threadTimeout, TimeUnit.MILLISECONDS,\n+                            new LinkedBlockingQueue<>(), factory, new CallerRuns(factory.toString()));\n+        } else {\n+            // Light and Aggressive need a special executor that overrides the finalize() method.\n+            this.createScheduledExecutor = (size, factory) -> {\n+                logNewThreadPoolCreated(factory.toString());\n+                return new LeakDetectorScheduledExecutorService(size, factory, new CallerRuns(factory.toString()));\n+            };\n+            this.createShrinkingExecutor = (maxThreadCount, threadTimeout, factory) -> {\n+                logNewThreadPoolCreated(factory.toString());\n+                return new LeakDetectorThreadPoolExecutor(0, maxThreadCount, threadTimeout, TimeUnit.MILLISECONDS,\n+                        new LinkedBlockingQueue<>(), factory, new CallerRuns(factory.toString()));\n+            };\n+        }\n+    }\n+\n+    /**\n+     * Gets the {@link ThreadLeakDetectionLevel} from System Properties (Key = {@link #DETECTION_LEVEL_PROPERTY_NAME}).\n+     *\n+     * @return The {@link ThreadLeakDetectionLevel}, or {@link ThreadLeakDetectionLevel#None} if not defined in System\n+     * Properties.\n+     * @throws IllegalArgumentException If the system property defines a value is not valid.\n+     */\n+    @VisibleForTesting\n+    static ThreadLeakDetectionLevel getDetectionLevel() {\n+        return ThreadLeakDetectionLevel.valueOf(\n+                System.getProperty(\"ThreadLeakDetectionLevel\", ThreadLeakDetectionLevel.None.name()));\n+    }\n+\n+    //endregion\n+\n+    //region Factory Methods\n+\n+    /**\n+     * Creates and returns a thread factory that will create threads with the given name prefix.\n+     *\n+     * @param groupName the name of the threads\n+     * @return a thread factory\n+     */\n+    ThreadFactory getThreadFactory(String groupName) {\n+        return getThreadFactory(groupName, Thread.NORM_PRIORITY);\n+    }\n+\n+    /**\n+     * Creates and returns a thread factory that will create threads with the given name prefix and thread priority.\n+     *\n+     * @param groupName the name of the threads\n+     * @param priority  the priority to be assigned to the thread.\n+     * @return a thread factory\n+     */\n+    ThreadFactory getThreadFactory(String groupName, int priority) {\n+        return new ThreadFactory() {\n+            final AtomicInteger threadCount = new AtomicInteger();\n+\n+            @Override\n+            public String toString() {\n+                return groupName;\n+            }\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = new Thread(r, groupName + \"-\" + threadCount.incrementAndGet());\n+                thread.setUncaughtExceptionHandler(new LogUncaughtExceptions());\n+                thread.setDaemon(true);\n+                thread.setPriority(priority);\n+                return thread;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a new ScheduledExecutorService that will use daemon threads with specified priority and names.\n+     *\n+     * @param size           The number of threads in the threadpool\n+     * @param poolName       The name of the pool (this will be printed in logs)\n+     * @param threadPriority The priority to be assigned to the threads\n+     * @return A new executor service.\n+     */\n+    ScheduledExecutorService newScheduledThreadPool(int size, String poolName, int threadPriority) {\n+        ThreadFactory threadFactory = getThreadFactory(poolName, threadPriority);\n+\n+        // Caller runs only occurs after shutdown, as queue size is unbounded.\n+        ScheduledThreadPoolExecutor result = this.createScheduledExecutor.apply(size, threadFactory);\n+\n+        // Do not execute any periodic tasks after shutdown.\n+        result.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n+\n+        // Do not execute any delayed tasks after shutdown.\n+        result.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+\n+        // Remove tasks from the executor once they are done executing. By default, even when canceled, these tasks are\n+        // not removed; if this setting is not enabled we could end up with leaked (and obsolete) tasks.\n+        result.setRemoveOnCancelPolicy(true);\n+        return result;\n+    }\n+\n+    /**\n+     * Operates like Executors.cachedThreadPool but with a custom thread timeout and pool name.\n+     *\n+     * @param maxThreadCount The maximum number of threads to allow in the pool.\n+     * @param threadTimeout  the number of milliseconds that a thread should sit idle before shutting down.\n+     * @param poolName       The name of the threadpool.\n+     * @return A new threadPool\n+     */\n+    ThreadPoolExecutor newShrinkingExecutor(int maxThreadCount, int threadTimeout, String poolName) {\n+        ThreadFactory factory = getThreadFactory(poolName);\n+        return this.createShrinkingExecutor.apply(maxThreadCount, threadTimeout, factory);\n+    }\n+\n+    //endregion\n+\n+    //region ThreadFactory Helper Classes\n+\n+    private static final class LogUncaughtExceptions implements Thread.UncaughtExceptionHandler {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+            log.error(\"Exception thrown out of root of thread: \" + t.getName(), e);\n+        }\n+    }\n+\n+    @Data\n+    private static class CallerRuns implements RejectedExecutionHandler {\n+        private final String poolName;\n+\n+        @Override\n+        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n+            log.debug(\"Caller to executor: \" + poolName + \" rejected and run in the caller.\");\n+            r.run();\n+        }\n+    }\n+\n+    //endregion\n+\n+    //region Leak Detection Pools\n+\n+    private class LeakDetectorScheduledExecutorService extends ScheduledThreadPoolExecutor {\n+        private final Exception stackTraceEx;\n+\n+        LeakDetectorScheduledExecutorService(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n+            super(corePoolSize, threadFactory, handler);\n+            this.stackTraceEx = new Exception();\n+        }\n+\n+        protected void finalize() {\n+            checkThreadPoolLeak(this, this.stackTraceEx);\n+            super.finalize();\n+        }\n+    }\n+\n+    private class LeakDetectorThreadPoolExecutor extends ThreadPoolExecutor {\n+        private final Exception stackTraceEx;\n+\n+        LeakDetectorThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,\n+                                       ThreadFactory threadFactory, RejectedExecutionHandler handler) {\n+            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n+            this.stackTraceEx = new Exception();\n+        }\n+\n+        protected void finalize() {\n+            checkThreadPoolLeak(this, this.stackTraceEx);\n+            super.finalize();\n+        }\n+    }\n+\n+    private void logNewThreadPoolCreated(String poolName) {\n+        if (this.detectionLevel == ThreadLeakDetectionLevel.Light) {\n+            log.debug(\"Created Thread Pool '{}' with leak detection level set to '{}'.\", poolName, this.detectionLevel);\n+        } else if (this.detectionLevel == ThreadLeakDetectionLevel.Aggressive) {\n+            log.warn(\"Created Thread Pool '{}' with leak detection level set to '{}'. THE VM WILL BE HALTED IF A LEAK IS DETECTED. DO NOT USE IN PRODUCTION.\", poolName, this.detectionLevel);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    void checkThreadPoolLeak(ThreadPoolExecutor e, Exception stackTraceEx) {\n+        if (this.detectionLevel == ThreadLeakDetectionLevel.None) {\n+            // Not doing anything in this case.\n+            return;\n+        }\n+\n+        if (!e.isShutdown() || !e.isTerminated()) {\n+            log.warn(\"THREAD POOL LEAK: {} (ShutDown={}, Terminated={}) finalized without being properly shut down.\",\n+                    e.getThreadFactory(), e.isShutdown(), e.isTerminated(), stackTraceEx);\n+            if (this.detectionLevel == ThreadLeakDetectionLevel.Aggressive) {\n+                // Not pretty, but outputting this stack trace on System.err helps with those unit tests that turned off\n+                // logging.\n+                stackTraceEx.printStackTrace(System.err);\n+                log.error(\"THREAD POOL LEAK DETECTED WITH LEVEL SET TO {}. SHUTTING DOWN.\", ThreadLeakDetectionLevel.Aggressive);\n+                this.onLeakDetected.run();", "originalCommit": "99fdf51000e6e49355c1b74d382156716a76aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNzU5OA==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537827598", "bodyText": "I need this for unit testing. I can't verify System.exit in unit tests since my JVM would quit and not help much.", "author": "andreipaduroiu", "createdAt": "2020-12-07T20:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MDkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MjE0Mg==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537772142", "bodyText": "This call does not block on the GC actually being performed. It merely sets a flag saying it should be done.\nI don't think there is a way to get this to do what you want.", "author": "tkaitchuck", "createdAt": "2020-12-07T19:31:20Z", "path": "common/src/test/java/io/pravega/common/concurrent/ExecutorServiceFactoryTests.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.concurrent;\n+\n+import io.pravega.test.common.IntentionalException;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import lombok.Cleanup;\n+import lombok.val;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Unit tests for the {@link ExecutorServiceFactory} class.\n+ */\n+public class ExecutorServiceFactoryTests {\n+    @After\n+    public void tearDown() {\n+        // Invoke GC and finalization - this will make sure that we catch any leftover thread pools\n+        System.gc();", "originalCommit": "99fdf51000e6e49355c1b74d382156716a76aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyODUzMQ==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537828531", "bodyText": "According to the Javadoc:\nRuns the garbage collector. Calling the gc method suggests that the Java Virtual Machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the Java Virtual Machine has made a best effort to reclaim space from all discarded objects.", "author": "andreipaduroiu", "createdAt": "2020-12-07T20:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MjE0Mg=="}], "type": "inlineReview"}, {"oid": "a479a0bfeb546fc10eb53a0820e96657208d2dc4", "url": "https://github.com/pravega/pravega/commit/a479a0bfeb546fc10eb53a0820e96657208d2dc4", "message": "More cleanup.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-08T04:13:19Z", "type": "commit"}, {"oid": "8ff23a05e6da1db87fbbc3e46cd5d9c1b2139646", "url": "https://github.com/pravega/pravega/commit/8ff23a05e6da1db87fbbc3e46cd5d9c1b2139646", "message": "Merge remote-tracking branch 'origin/master' into issue-5401-leaks", "committedDate": "2020-12-08T04:13:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzNTczNA==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r538035734", "bodyText": "serviceBuilder needs to be closed in the @after method.", "author": "shrids", "createdAt": "2020-12-08T04:58:26Z", "path": "test/integration/src/test/java/io/pravega/test/integration/controller/server/EventProcessorTest.java", "diffHunk": "@@ -94,8 +93,12 @@\n     private ServiceBuilder serviceBuilder;", "originalCommit": "8ff23a05e6da1db87fbbc3e46cd5d9c1b2139646", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjQ2NQ==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r538432465", "bodyText": "Good one. Fixed.", "author": "andreipaduroiu", "createdAt": "2020-12-08T14:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzNTczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNDMwMA==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r537724300", "bodyText": "Was the close() order relevant to release resources in this test?", "author": "RaulGracia", "createdAt": "2020-12-07T18:18:11Z", "path": "client/src/main/java/io/pravega/client/admin/impl/KeyValueTableManagerImpl.java", "diffHunk": "@@ -80,17 +80,17 @@ public KeyValueTableManagerImpl(@NonNull ClientConfig clientConfig) {\n     @Override\n     public void close() {\n         if (this.closed.compareAndSet(false, true)) {\n-            if (this.controller != null) {\n-                this.controller.close();\n-            }\n-\n             if (this.connectionFactory != null) {\n                 this.connectionFactory.close();\n             }\n \n             if (this.executor != null) {\n                 ExecutorServiceHelpers.shutdown(this.executor);\n             }\n+\n+            if (this.controller != null) {", "originalCommit": "99fdf51000e6e49355c1b74d382156716a76aadc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzMzNw==", "url": "https://github.com/pravega/pravega/pull/5402#discussion_r538433337", "bodyText": "In some cases, some of these methods may throw exceptions or hang around forever. While I did try to fix most of them, fixing them was out of scope for this effort, so I did my best to try to close executors before the problematic components.", "author": "andreipaduroiu", "createdAt": "2020-12-08T14:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNDMwMA=="}], "type": "inlineReview"}, {"oid": "edadf133dab66ffcceef19abf2ba3d9c3208f21b", "url": "https://github.com/pravega/pravega/commit/edadf133dab66ffcceef19abf2ba3d9c3208f21b", "message": "More cleanup.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-08T14:30:52Z", "type": "commit"}, {"oid": "a2c87785e2d4d04ad866d0c912203b46f28d1fef", "url": "https://github.com/pravega/pravega/commit/a2c87785e2d4d04ad866d0c912203b46f28d1fef", "message": "Merge branch 'master' into issue-5401-leaks", "committedDate": "2020-12-08T15:40:25Z", "type": "commit"}]}