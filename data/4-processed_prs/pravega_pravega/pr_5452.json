{"pr_number": 5452, "pr_title": "Issue 5451: Refine distributed mode cluster security documentation", "pr_createdAt": "2020-12-27T06:04:43Z", "pr_url": "https://github.com/pravega/pravega/pull/5452", "timeline": [{"oid": "701e97d0a04865fc39ac43f892342cad0ed3b5a6", "url": "https://github.com/pravega/pravega/commit/701e97d0a04865fc39ac43f892342cad0ed3b5a6", "message": "Update securing-distributed-mode-cluster.md\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-12-27T09:01:11Z", "type": "commit"}, {"oid": "d88e564cb3e6490d94cf21df28f127c19f5d9f31", "url": "https://github.com/pravega/pravega/commit/d88e564cb3e6490d94cf21df28f127c19f5d9f31", "message": "Update doc\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-12-27T09:01:11Z", "type": "commit"}, {"oid": "f3e180d2428095d2f5199301931045c21646d948", "url": "https://github.com/pravega/pravega/commit/f3e180d2428095d2f5199301931045c21646d948", "message": "Add a new file for TLS material generation\n\nSigned-off-by: shardr <ravi.sharda@emc.com>\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-12-27T09:01:11Z", "type": "commit"}, {"oid": "3a7d007653382510c28a9aa7b1bca0e59f58fe5b", "url": "https://github.com/pravega/pravega/commit/3a7d007653382510c28a9aa7b1bca0e59f58fe5b", "message": "Update TLS material generation instructions\n\nSigned-off-by: shardr <ravi.sharda@emc.com>\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-12-27T09:01:11Z", "type": "commit"}, {"oid": "8cbd83c1b000a44553b3f4ef0de48ebc7bc62e62", "url": "https://github.com/pravega/pravega/commit/8cbd83c1b000a44553b3f4ef0de48ebc7bc62e62", "message": "Update documentation\n\nSigned-off-by: shardr <ravi.sharda@emc.com>\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-12-27T09:01:11Z", "type": "commit"}, {"oid": "8cbd83c1b000a44553b3f4ef0de48ebc7bc62e62", "url": "https://github.com/pravega/pravega/commit/8cbd83c1b000a44553b3f4ef0de48ebc7bc62e62", "message": "Update documentation\n\nSigned-off-by: shardr <ravi.sharda@emc.com>\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-12-27T09:01:11Z", "type": "forcePushed"}, {"oid": "0df6688874237b158b94c7baf62ab3ff20178f5a", "url": "https://github.com/pravega/pravega/commit/0df6688874237b158b94c7baf62ab3ff20178f5a", "message": "Improve text\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2020-12-27T12:24:20Z", "type": "commit"}, {"oid": "f0df6d06bc5f6d1b3bb9768f83a8745d9afd0da3", "url": "https://github.com/pravega/pravega/commit/f0df6d06bc5f6d1b3bb9768f83a8745d9afd0da3", "message": "Improve text formatting\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-04T06:11:10Z", "type": "commit"}, {"oid": "dfbb41af561808fadb4142fd48df88ccb73d5d4a", "url": "https://github.com/pravega/pravega/commit/dfbb41af561808fadb4142fd48df88ccb73d5d4a", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-06T11:13:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMzc1Ng==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r553503756", "bodyText": "Please fix typo here.", "author": "kotlasaicharanreddy", "createdAt": "2021-01-07T18:23:45Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +102,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |\n+ | `controller.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `controller.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `controller.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `controller.security.auth.enable` | `true` |\n+ | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | `/etc/secrets/password-auth-handler.database` |\n+ | `controller.security.auth.delegationToken.signingKey.basis` | `a-secret-value` |\n \n  [1]: This and other `.password` files are text files containing the password for the corresponding store.\n \n- [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `controller.zk.*` properties.\n+ [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side \n+ TLS configuration properties via the `controller.zk.*` properties.\n \n  [3]: This configuration property is required when using the default Password Auth Handler only.\n \n **Segment Store**\n \n-Segment store supports configuration via a properties file (`config.properties`) or JVM system properties. The table below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+Segment store supports security configuration via a properties file (`config.properties`) or JVM system properties. The table \n+below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to\n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `pravegaservice.security.tls.enable` | true |\n- | `pravegaservice.security.tls.server.certificate.location` | /etc/secrets/segmentstore01.pem |\n- | `pravegaservice.security.tls.server.privateKey.location` | /etc/secrets/segmentstore01.key.pem |\n- | `pravegaservice.zk.connect.security.enable` | false <sup>2</sup> |\n- | `pravegaservice.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `autoScale.controller.connect.security.tls.enable` | true |\n- | `autoScale.controller.connect.security.tls.truststore.location` | /etc/secrets/segmentstore01.key.pem |\n- | `autoScale.controller.connect.security.auth.enable` | true |\n- | `autoScale.security.auth.token.signingKey.basis` | a-secret-value <sup>1</sup>|\n- | `autoScale.controller.connect.security.tls.validateHostName.enable` | true |\n-\n-[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `pravegaservice.zk.*` properties.\n+ | `pravegaservice.security.tls.enable` | `true` |\n+ | `pravegaservice.security.tls.server.certificate.location` | `/etc/secrets/segmentstore01-server-cert.crt` |\n+ | `pravegaservice.security.tls.certificate.autoReload.enable` | `false` |\n+ | `pravegaservice.security.tls.server.privateKey.location` | `/etc/secrets/segmentstore01-server-key.key` |\n+ | `pravegaservice.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `pravegaservice.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `autoScale.controller.connect.security.tls.enable` | `true` |\n+ | `autoScale.controller.connect.security.tls.truststore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `autoScale.controller.connect.security.auth.enable` | `true` |\n+ | `autoScale.security.auth.token.signingKey.basis` | `a-secret-value` <sup>1</sup>|\n+ | `autoScale.controller.connect.security.tls.validateHostName.enable` | `true` |\n+ | `pravega.client.auth.loadDynamic` | `false` |\n+ | `pravega.client.auth.method` | `Basic` |\n+ | `pravega.client.auth.token` | Base64-encoded value of 'username:password' string | \n+\n+[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS \n+configuration properties via the `pravegaservice.zk.*` properties.\n \n [2]: The secret value you use here must match the same value used for other Controller and Segment Store services.\n \n ### Configuring TLS and Credentials on Client Side\n \n-After enabling and configuring TLS and auth on the server-side services, its time to update the clients,\n-so that the they can establish TLS connections with the servers and are allowed access.\n-\n-For TLS, establish trust for the servers' certificates on the client side using one of the following ways:\n+After enabling and configuring TLS and auth on the server-side services, it's time for the clients' setup.\n \n-  1. Supply the client library with the certificate of the trusted CA that has signed the servers' certificates.\n+Clients can be made to trust the server's certificates signed by custom CA's using one of the following ways:\n \n-     ```\n+  1. Configure the client application to use the signing CA's certificate as the truststore. Alternatively, use the \n+     servers' certificate as the truststore. \n+     \n+     ```java\n      ClientConfig clientConfig = ClientConfig.builder()\n-                .controllerURI(\"tls://<DNS-NAME-OR-IP>:9090\")\n-                .trustStore(\"/etc/secrets/ca-cert\")\n+                .controllerURI(\"tls://<dns-name-or-ip>:9090\")\n+                .trustStore(\"/etc/secrets/ca-cert.crt\")\n                 ...\n                 .build();\n      ```\n-\n-  2. Install the CA's certificate in the Java system key store.\n+  2. Install the CA's certificate in the Java system key store. \n   3. Create a custom truststore with the CA's certificate and supply it to the Pravega client application,\n-   via JVM system properties `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`.\n+     via standard JVM system properties `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`.\n \n For auth, client-side configuration depends on the `AuthHandler` implementation used. If your server is configured to\n-use the default `PasswordAuthHandler`, you may supply the credentials as shown below.\n+use the built-in Password Auth Handler that supports \"Basic\" authentication, you may supply the credentials as shown below.\n \n-  ```\n+  ```java\n   ClientConfig clientConfig = ClientConfig.builder()\n-                .controllerURI(\"tls://<DNS-NAME-OR-IP>:9090\")\n-                .trustStore(\"/etc/secrets/ca-cert\")\n+                .controllerURI(\"tls://<dns-name-or-ip>:9090\")\n+                .trustStore(\"/etc/secrets/ca-cert.crt\")\n                 .credentials(new DefaultCredentials(\"changeit\", \"marketinganaylticsapp\"))\n                 .build();\n   ```\n \n #### Server Hostname Verification\n \n-Hostname verification during TLS communications verifies that the DNS name to which the client connects matches the hostname specified in either of the following fields in the server's certificate:\n+For client's server hostname verification to succeed during TLS handshake, the hostname/IP address it uses for accessing the\n+server must match one of the following in the server's certificate:\n \n * Common Name (`CN`) in the certificate's `Subject` field\n-* One of the `Subject Alternative Names` field entries\n+* One of the `Subject Alternative Names` (SAN) field entries\n \n-If the server certificates have a hostname assigned, you have used IP addresses as endpoints for the services, and those hostnames are not accessible from\n-the client nodes, you might need to add mappings of\n-IP addresses and DNS/Host names in the client-side operating system hosts file.\n+Even if the server listens on the loopback address `127.0.0.1` and its certificate is assigned to `localhost`, hostname \n+verification will fail if the client attempts to access the server via `127.0.01`. Fit the verification to pass, ", "originalCommit": "dfbb41af561808fadb4142fd48df88ccb73d5d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MzczMg==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r553783732", "bodyText": "Fixed. Thanks for spotting it.", "author": "ravisharda", "createdAt": "2021-01-08T07:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMzc1Ng=="}], "type": "inlineReview"}, {"oid": "0193f19a20a052c23f52f088f16af7a5f1507e8d", "url": "https://github.com/pravega/pravega/commit/0193f19a20a052c23f52f088f16af7a5f1507e8d", "message": "Improve text and formatting\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-08T06:51:33Z", "type": "commit"}, {"oid": "795926c543ffc30f9e3835a204d122ee7b8306bd", "url": "https://github.com/pravega/pravega/commit/795926c543ffc30f9e3835a204d122ee7b8306bd", "message": "Improve section title\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-08T06:53:09Z", "type": "commit"}, {"oid": "becaa1073421cfcb48dfeb6a1f559cf6edfa3636", "url": "https://github.com/pravega/pravega/commit/becaa1073421cfcb48dfeb6a1f559cf6edfa3636", "message": "Minor formatting change\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-08T06:58:15Z", "type": "commit"}, {"oid": "851dcbab2650b8ebc3c9005eb1f810d15a2d2c47", "url": "https://github.com/pravega/pravega/commit/851dcbab2650b8ebc3c9005eb1f810d15a2d2c47", "message": "Improve title\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-08T07:00:13Z", "type": "commit"}, {"oid": "5a0aeb977f62615edcb7ea69f9af779eb3bb5ff2", "url": "https://github.com/pravega/pravega/commit/5a0aeb977f62615edcb7ea69f9af779eb3bb5ff2", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-08T07:30:59Z", "type": "commit"}, {"oid": "eea3484b46c506f8252a25d8bbcb0c682a9bf623", "url": "https://github.com/pravega/pravega/commit/eea3484b46c506f8252a25d8bbcb0c682a9bf623", "message": "Minor fixes.\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-08T07:36:50Z", "type": "commit"}, {"oid": "759b37f569e2bc878c84a30d142671df25372509", "url": "https://github.com/pravega/pravega/commit/759b37f569e2bc878c84a30d142671df25372509", "message": "Merge remote-tracking branch 'origin/update-tls-material-doc' into update-tls-material-doc", "committedDate": "2021-01-08T07:37:12Z", "type": "commit"}, {"oid": "b126adb20a2ae46ec35f4256785a67d21ca1d74d", "url": "https://github.com/pravega/pravega/commit/b126adb20a2ae46ec35f4256785a67d21ca1d74d", "message": "Fix the name of a configuration\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-08T08:54:56Z", "type": "commit"}, {"oid": "5b4f192f650b008c35953ecdf498c141b1467c11", "url": "https://github.com/pravega/pravega/commit/5b4f192f650b008c35953ecdf498c141b1467c11", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-10T13:49:02Z", "type": "commit"}, {"oid": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "url": "https://github.com/pravega/pravega/commit/a5bd26117446b86324618e7f3b0cd3765bdc4307", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-11T06:39:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI3Nzc0Ng==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555277746", "bodyText": "Capitalize the first letters of certificate signing request.", "author": "fpj", "createdAt": "2021-01-11T19:12:10Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,321 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. \n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the number of sets TLS artifacts sets required for a Pravega cluster: \n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' network identities (DNS names and/or IP addresses) in the certificate's \n+   [Subject Alternative Name (SAN)(https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secured option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this section use command line arguments to pass all inputs to the command. To pass\n+sensitive command arguments via prompts instead, just exclude the corresponding option. For example,\n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit\n+\n+   # Optionally, list the truststore's contents and inspect the output to verify everything is in order. The output \n+   # should show a single entry with alias name `caroot` and entry type `trustedCertEntry`.\n+   $ keytool -list -v -keystore client.truststore.jks -storepass changeit\n+   ```\n+\n+At this point, the following CA and truststore artifacts should be ready:\n+\n+| File | Description | Example command for inspecting the file's Contents |\n+|:-----:|:--------|:--------------|\n+| `ca-cert.crt` | PEM-encoded X.509 certificate of the CA | `$ openssl x509 -in ca-cert.crt -text -noout` |\n+| `ca-key.key` | PEM-encoded file containing the CA's encrypted private key  | `$ openssl pkcs8 -inform PEM -in ca-key.key -topk8` |\n+| `client.truststore.jks` | A password-protected truststore file containing the CA's certificate | `$ keytool -list -v -keystore client.truststore.jks -storepass changeit` |\n+\n+## Generate TLS Certificates and Other TLS Artifacts for the Server\n+\n+Here, we prepare a set of TLS artifacts that can be used by one or more nodes.  \n+\n+We'll use the CA created in the previous stage to sign the server certificate for demonstration, but in real usage you \n+may instead get it signed by an existing internal CA in your environment or a public CA.\n+\n+The high-level steps involved in this stage are:\n+\n+1. Generate a set of server certificate and private key.\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+4. Prepare a keystore containing the signed server certificate and the CA's certificate.\n+5. Export the server certificate's private key.\n+\n+Note that these steps will need to be repeated with different input for each set. We discussed the number of sets \n+required earlier in the [Overview](#overview) section. \n+\n+The above steps are described below: \n+\n+1. Generate a set of server certificate and private key.\n+\n+   The following command will generate a Java JKS keystore containing the following artifacts for the server:\n+   * An X.509 certificate containing the public key identifying the server\n+   * A private key for the public/private key pair\n+\n+   ```bash\n+   $ keytool -storetype JKS -keystore <java-keystore-file-name> -storepass <java-keystore-password>\\\n+           -genkey -keyalg <key-algorithm> -keysize <key-size> -keypass <private-key-password>\\\n+           -alias <alias> -validity <validity>\\\n+           -dname \"<distinguished-name>\"\\\n+           -ext SAN=dns:<hostname1>,dns:<hostname2>,ip:<ipaddress1>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\\\n+              -genkey -keyalg RSA -keysize 2048 -keypass changeit\\\n+              -alias server -validity 365\\\n+              -dname \"CN=server.pravega.io, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown\"\\\n+              -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   \n+   # Optionally, verify the contents of the generated file\n+   $ keytool -list -v -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\n+   ```\n+\n+2. Generate a certificate signing request (CSR) for the server certificate.", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY0MzA3MA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555643070", "bodyText": "I've just a pushed a commit that fixes this as suggested.", "author": "ravisharda", "createdAt": "2021-01-12T09:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI3Nzc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI3ODM2Ng==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555278366", "bodyText": "I think the scope of this document is really just the service part (excludes client), let's make that explicit right in the beginning.", "author": "fpj", "createdAt": "2021-01-11T19:13:23Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,321 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. \n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each ", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY0OTc4Nw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555649787", "bodyText": "Yes, the TLS artifacts are primarily for the servers. The CA certificate and the client truststore may be used on the client-side. Line no. 12 and 13 say the following:\n\"This document describes how to create TLS certificates, keys and other artifacts for the server components. The\ngenerated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\"\nHope that works.", "author": "ravisharda", "createdAt": "2021-01-12T10:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI3ODM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MTM0NQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555291345", "bodyText": "I think this should be:\n\nHere are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster", "author": "fpj", "createdAt": "2021-01-11T19:37:25Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,321 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. \n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the number of sets TLS artifacts sets required for a Pravega cluster: ", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY0OTk3OQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555649979", "bodyText": "Sure, I've changed the statement as suggested.", "author": "ravisharda", "createdAt": "2021-01-12T10:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MTM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MTU4Nw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555291587", "bodyText": "... the least secure option...", "author": "fpj", "createdAt": "2021-01-11T19:37:58Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,321 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. \n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the number of sets TLS artifacts sets required for a Pravega cluster: \n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' network identities (DNS names and/or IP addresses) in the certificate's \n+   [Subject Alternative Name (SAN)(https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secured option. All deployment options support this configuration.  ", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY1MDQ1OA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555650458", "bodyText": "Fixed. Thanks for spotting it.", "author": "ravisharda", "createdAt": "2021-01-12T10:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MjEyMg==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555292122", "bodyText": "... other other... -> ... other...", "author": "fpj", "createdAt": "2021-01-11T19:38:52Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,321 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. \n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the number of sets TLS artifacts sets required for a Pravega cluster: \n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other other configurations listed below. This is the most secure option. ", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY1MDE5Ng==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555650196", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2021-01-12T10:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MjEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MzE2MQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555293161", "bodyText": "When you say DNS names and IP addresses here, do you mean DNS domains and IP ranges? Otherwise, I'm not sure what you mean with network identities.", "author": "fpj", "createdAt": "2021-01-11T19:40:56Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,321 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. \n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the number of sets TLS artifacts sets required for a Pravega cluster: \n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' network identities (DNS names and/or IP addresses) in the certificate's ", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY1MTc0OQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555651749", "bodyText": "I've changed the statement to remove the \"network identities\" to now say the following. Hope this works:\n... by specifying the nodes' DNS names and/or IP addresses", "author": "ravisharda", "createdAt": "2021-01-12T10:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MzE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMwMjA1MA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555302050", "bodyText": "For my own education, isn't Kubernetes Ingress a flavor of reverse proxy?", "author": "fpj", "createdAt": "2021-01-11T19:57:42Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,321 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. \n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the number of sets TLS artifacts sets required for a Pravega cluster: \n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' network identities (DNS names and/or IP addresses) in the certificate's \n+   [Subject Alternative Name (SAN)(https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secured option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead ", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY1MjY2NA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555652664", "bodyText": "Yes, a Kubernetes Ingress may function as a reverse proxy (or as a load balancer).\nAlso, this document is agnostic to how Pravega is deployed.", "author": "ravisharda", "createdAt": "2021-01-12T10:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMwMjA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMwNDc3MA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555304770", "bodyText": "When it says For example, I think you are trying to say that it is going to illustrate a way of passing the passwords directly and another in which the passwords are entered interactively. The leading text does not make very clear what the examples are about.", "author": "fpj", "createdAt": "2021-01-11T20:03:04Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,321 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. \n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the number of sets TLS artifacts sets required for a Pravega cluster: \n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' network identities (DNS names and/or IP addresses) in the certificate's \n+   [Subject Alternative Name (SAN)(https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secured option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this section use command line arguments to pass all inputs to the command. To pass\n+sensitive command arguments via prompts instead, just exclude the corresponding option. For example,", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY1NDc3OA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555654778", "bodyText": "I've changed the text now. Please take a look and see this works better.", "author": "ravisharda", "createdAt": "2021-01-12T10:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMwNDc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1MTI1Mw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555351253", "bodyText": "In which file is the security configuration of clients being discussed in detail?", "author": "fpj", "createdAt": "2021-01-11T21:28:57Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |\n+ | `controller.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `controller.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `controller.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `controller.security.auth.enable` | `true` |\n+ | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | `/etc/secrets/password-auth-handler.database` |\n+ | `controller.security.auth.delegationToken.signingKey.basis` | `a-secret-value` |\n \n  [1]: This and other `.password` files are text files containing the password for the corresponding store.\n \n- [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `controller.zk.*` properties.\n+ [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side \n+ TLS configuration properties via the `controller.zk.*` properties.\n \n  [3]: This configuration property is required when using the default Password Auth Handler only.\n \n **Segment Store**\n \n-Segment store supports configuration via a properties file (`config.properties`) or JVM system properties. The table below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+Segment store supports security configuration via a properties file (`config.properties`) or JVM system properties. The table \n+below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to\n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `pravegaservice.security.tls.enable` | true |\n- | `pravegaservice.security.tls.server.certificate.location` | /etc/secrets/segmentstore01.pem |\n- | `pravegaservice.security.tls.server.privateKey.location` | /etc/secrets/segmentstore01.key.pem |\n- | `pravegaservice.zk.connect.security.enable` | false <sup>2</sup> |\n- | `pravegaservice.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `autoScale.controller.connect.security.tls.enable` | true |\n- | `autoScale.controller.connect.security.tls.truststore.location` | /etc/secrets/segmentstore01.key.pem |\n- | `autoScale.controller.connect.security.auth.enable` | true |\n- | `autoScale.security.auth.token.signingKey.basis` | a-secret-value <sup>1</sup>|\n- | `autoScale.controller.connect.security.tls.validateHostName.enable` | true |\n-\n-[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `pravegaservice.zk.*` properties.\n+ | `pravegaservice.security.tls.enable` | `true` |\n+ | `pravegaservice.security.tls.server.certificate.location` | `/etc/secrets/segmentstore01-server-cert.crt` |\n+ | `pravegaservice.security.tls.certificate.autoReload.enable` | `false` |\n+ | `pravegaservice.security.tls.server.privateKey.location` | `/etc/secrets/segmentstore01-server-key.key` |\n+ | `pravegaservice.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `pravegaservice.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `autoScale.controller.connect.security.tls.enable` | `true` |\n+ | `autoScale.controller.connect.security.tls.truststore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `autoScale.controller.connect.security.auth.enable` | `true` |\n+ | `autoScale.security.auth.token.signingKey.basis` | `a-secret-value` <sup>1</sup>|\n+ | `autoScale.controller.connect.security.tls.validateHostName.enable` | `true` |\n+ | `pravega.client.auth.loadDynamic` | `false` |\n+ | `pravega.client.auth.method` | `Basic` |\n+ | `pravega.client.auth.token` | Base64-encoded value of 'username:password' string | \n+\n+[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS \n+configuration properties via the `pravegaservice.zk.*` properties.\n \n [2]: The secret value you use here must match the same value used for other Controller and Segment Store services.\n \n ### Configuring TLS and Credentials on Client Side\n \n-After enabling and configuring TLS and auth on the server-side services, its time to update the clients,\n-so that the they can establish TLS connections with the servers and are allowed access.\n-\n-For TLS, establish trust for the servers' certificates on the client side using one of the following ways:\n+After enabling and configuring TLS and auth on the server-side services, it's time for the clients' setup.\n \n-  1. Supply the client library with the certificate of the trusted CA that has signed the servers' certificates.\n+Clients can be made to trust the server's certificates signed by custom CA's using one of the following ways:\n \n-     ```\n+  1. Configure the client application to use the signing CA's certificate as the truststore. Alternatively, use the \n+     servers' certificate as the truststore. \n+     \n+     ```java\n      ClientConfig clientConfig = ClientConfig.builder()\n-                .controllerURI(\"tls://<DNS-NAME-OR-IP>:9090\")\n-                .trustStore(\"/etc/secrets/ca-cert\")\n+                .controllerURI(\"tls://<dns-name-or-ip>:9090\")\n+                .trustStore(\"/etc/secrets/ca-cert.crt\")\n                 ...\n                 .build();\n      ```\n-\n-  2. Install the CA's certificate in the Java system key store.\n+  2. Install the CA's certificate in the Java system key store. \n   3. Create a custom truststore with the CA's certificate and supply it to the Pravega client application,\n-   via JVM system properties `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`.\n+     via standard JVM system properties `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`.\n \n For auth, client-side configuration depends on the `AuthHandler` implementation used. If your server is configured to\n-use the default `PasswordAuthHandler`, you may supply the credentials as shown below.\n+use the built-in Password Auth Handler that supports \"Basic\" authentication, you may supply the credentials as shown below.\n \n-  ```\n+  ```java\n   ClientConfig clientConfig = ClientConfig.builder()\n-                .controllerURI(\"tls://<DNS-NAME-OR-IP>:9090\")\n-                .trustStore(\"/etc/secrets/ca-cert\")\n+                .controllerURI(\"tls://<dns-name-or-ip>:9090\")\n+                .trustStore(\"/etc/secrets/ca-cert.crt\")\n                 .credentials(new DefaultCredentials(\"changeit\", \"marketinganaylticsapp\"))\n                 .build();\n   ```\n \n #### Server Hostname Verification\n \n-Hostname verification during TLS communications verifies that the DNS name to which the client connects matches the hostname specified in either of the following fields in the server's certificate:\n+For client's server hostname verification to succeed during TLS handshake, the hostname/IP address it uses for accessing the\n+server must match one of the following in the server's certificate:\n \n * Common Name (`CN`) in the certificate's `Subject` field\n-* One of the `Subject Alternative Names` field entries\n+* One of the `Subject Alternative Names` (SAN) field entries\n \n-If the server certificates have a hostname assigned, you have used IP addresses as endpoints for the services, and those hostnames are not accessible from\n-the client nodes, you might need to add mappings of\n-IP addresses and DNS/Host names in the client-side operating system hosts file.\n+Even if the server listens on the loopback address `127.0.0.1` and its certificate is assigned to `localhost`, hostname \n+verification will fail if the client attempts to access the server via `127.0.0.1`. For the verification to pass, \n+the client must access the server using the hostname assigned on the certificate `localhost` and have a hosts file entry \n+that maps `localhost` to `127.0.0.1` (which is usually already there). \n \n-Alternatively, you may disable hostname verification by invoking `validateHostName(false)` of the ClientConfig builder. It is strongly recommended to avoid disabling hostname verification for production clusters.\n+Similarly, if the server certificate is assigned to a non-routable hostname on the network (say, `controller01.pravega.io`),\n+you might need to add an IP address and DNS/host name mapping in the client's operating system hosts file. \n \n-### Having TLS and Auth Take Effect\n+```\n+10.243.221.34 controller01.pravega.io\n+```\n+\n+If you are reusing preexisting certificate for development/testing on new hosts, you might need to disable hostname \n+verification. To do so, call `validateHostName(false)` of the ClientConfig builder, as shown below. Never disable \n+hostname verification in production.\n \n-To ensure TLS and auth parameters take effect, all the services on the server-side need to be restarted.\n-Existing client applications will need to be restarted as well, after they are reconfigured for TLS and auth.\n+  ```java\n+  ClientConfig clientConfig = ClientConfig.builder()", "originalCommit": "a5bd26117446b86324618e7f3b0cd3765bdc4307", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY1NjY1MA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r555656650", "bodyText": "We don't have a document for it yet, but it is shown here:  https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/securing-standalone-mode-cluster.md. We should enhance the document to include client configuration at some point.", "author": "ravisharda", "createdAt": "2021-01-12T10:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1MTI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2MjU4Mg==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r556262582", "bodyText": "I've created a new issue #5514 for documenting client-side configurations.", "author": "ravisharda", "createdAt": "2021-01-13T04:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1MTI1Mw=="}], "type": "inlineReview"}, {"oid": "8367e8eff2b9a96f887c69aaf76601df88628a41", "url": "https://github.com/pravega/pravega/commit/8367e8eff2b9a96f887c69aaf76601df88628a41", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-12T09:50:47Z", "type": "commit"}, {"oid": "89b3e813d226c23245ca38ff116e2f15b6d81dbf", "url": "https://github.com/pravega/pravega/commit/89b3e813d226c23245ca38ff116e2f15b6d81dbf", "message": "Merge remote-tracking branch 'origin/update-tls-material-doc' into update-tls-material-doc", "committedDate": "2021-01-12T09:51:01Z", "type": "commit"}, {"oid": "ec60547a5643dddf3af1715184492e7853589f2e", "url": "https://github.com/pravega/pravega/commit/ec60547a5643dddf3af1715184492e7853589f2e", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-12T09:51:26Z", "type": "commit"}, {"oid": "d193e25248c13e614e4ad15b060e915be21bc562", "url": "https://github.com/pravega/pravega/commit/d193e25248c13e614e4ad15b060e915be21bc562", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-12T09:59:52Z", "type": "commit"}, {"oid": "26ffc79f051baca79cabb211d8b491524836296a", "url": "https://github.com/pravega/pravega/commit/26ffc79f051baca79cabb211d8b491524836296a", "message": "Merge remote-tracking branch 'origin/update-tls-material-doc' into update-tls-material-doc", "committedDate": "2021-01-12T10:00:02Z", "type": "commit"}, {"oid": "969a1693973e00b87942ae173201e6714619f836", "url": "https://github.com/pravega/pravega/commit/969a1693973e00b87942ae173201e6714619f836", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-13T04:50:51Z", "type": "commit"}, {"oid": "aafb2e024b84b8f98114f32c03cf421b1887b2c5", "url": "https://github.com/pravega/pravega/commit/aafb2e024b84b8f98114f32c03cf421b1887b2c5", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-14T09:02:49Z", "type": "commit"}, {"oid": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "url": "https://github.com/pravega/pravega/commit/82d3315eb85f424d00d6aa8f964ec5b3763f1644", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-14T11:54:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NTIxMA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557685210", "bodyText": "FYI, in MinGW/MSYS bash, -subj argument needs to be -subj \"//C=US\\ST=Washington\\L=Seattle\\O=Pravega\\OU=CA\\CN=Pravega-Stack-CA\". Cf., https://stackoverflow.com/a/31990313", "author": "derekm", "createdAt": "2021-01-14T20:40:21Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxMzQ2NQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557813465", "bodyText": "Sure, thanks. I've now added a comment next to the command that says that.", "author": "ravisharda", "createdAt": "2021-01-15T01:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NTIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NjE5OA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557686198", "bodyText": "Consider listing filenames, ca-key.key and ca-cert.crt. It should be obvious, but just to be explicit.", "author": "derekm", "createdAt": "2021-01-14T20:42:21Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzg1MDg5OA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557850898", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2021-01-15T04:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NjE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4OTc1MA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557689750", "bodyText": "Is it worth suggesting that private key and truststore use different passwords? Is that even preferable?", "author": "derekm", "createdAt": "2021-01-14T20:49:02Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNDI3MQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557814271", "bodyText": "An earlier line 85 says that: A weak password changeit is used everywhere in this document for easier reading. Be sure to replace it with a strong and separate password for each file.\nYes, each password should be different. Reusing a password is usually considered a bad practice.", "author": "ravisharda", "createdAt": "2021-01-15T01:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4OTc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NDAzOQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557694039", "bodyText": "Both ca-key.key and client.truststore.jks are password-protected or encrypted. Consider using the same phrasing for both entries.", "author": "derekm", "createdAt": "2021-01-14T20:57:02Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit\n+\n+   # Optionally, list the truststore's contents and inspect the output to verify everything is in order. The output \n+   # should show a single entry with alias name `caroot` and entry type `trustedCertEntry`.\n+   $ keytool -list -v -keystore client.truststore.jks -storepass changeit\n+   ```\n+\n+At this point, the following CA and truststore artifacts should be ready:\n+\n+| File | Description | Example command for inspecting the file's Contents |\n+|:-----:|:--------|:--------------|\n+| `ca-cert.crt` | PEM-encoded X.509 certificate of the CA | `$ openssl x509 -in ca-cert.crt -text -noout` |\n+| `ca-key.key` | PEM-encoded file containing the CA's encrypted private key  | `$ openssl pkcs8 -inform PEM -in ca-key.key -topk8` |\n+| `client.truststore.jks` | A password-protected truststore file containing the CA's certificate | `$ keytool -list -v -keystore client.truststore.jks -storepass changeit` |", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNDc1Mg==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557814752", "bodyText": "There is a slight difference though: the JKS is a password-protected file, while the key file contains the encrypted key in a PEM file. The key file itself is not encrypted. So, I have left that part of the text as-is. What do you say?", "author": "ravisharda", "createdAt": "2021-01-15T01:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NDAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzg3NDcxNw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557874717", "bodyText": "Yes, I see what you mean. An ASN.1 attribute in the PEM file is encrypted, whereas the entire truststore is encrypted? Your wording is fine!", "author": "derekm", "createdAt": "2021-01-15T05:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NDAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5ODQxNg==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557698416", "bodyText": "I get the following warning from this command:\n\nWarning:\nThe JKS keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using \"keytool -importkeystore -srckeystore server_unsigned.keystore.jks -destkeystore server_unsigned.keystore.jks -deststoretype pkcs12\".\n\nIs this something we should update?", "author": "derekm", "createdAt": "2021-01-14T21:05:50Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit\n+\n+   # Optionally, list the truststore's contents and inspect the output to verify everything is in order. The output \n+   # should show a single entry with alias name `caroot` and entry type `trustedCertEntry`.\n+   $ keytool -list -v -keystore client.truststore.jks -storepass changeit\n+   ```\n+\n+At this point, the following CA and truststore artifacts should be ready:\n+\n+| File | Description | Example command for inspecting the file's Contents |\n+|:-----:|:--------|:--------------|\n+| `ca-cert.crt` | PEM-encoded X.509 certificate of the CA | `$ openssl x509 -in ca-cert.crt -text -noout` |\n+| `ca-key.key` | PEM-encoded file containing the CA's encrypted private key  | `$ openssl pkcs8 -inform PEM -in ca-key.key -topk8` |\n+| `client.truststore.jks` | A password-protected truststore file containing the CA's certificate | `$ keytool -list -v -keystore client.truststore.jks -storepass changeit` |\n+\n+## Generate TLS Certificates and Other TLS Artifacts for the Server\n+\n+Here, we prepare a set of TLS artifacts that can be used by one or more nodes.  \n+\n+We'll use the CA created in the previous stage to sign the server certificate for demonstration, but in real usage you \n+may instead get it signed by an existing internal CA in your environment or a public CA.\n+\n+The high-level steps involved in this stage are:\n+\n+1. Generate a set of server certificate and private key.\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+4. Prepare a keystore containing the signed server certificate and the CA's certificate.\n+5. Export the server certificate's private key.\n+\n+Note that these steps will need to be repeated with different input for each set. We discussed the number of sets \n+required earlier in the [Overview](#overview) section. \n+\n+The above steps are described below: \n+\n+1. Generate a set of server certificate and private key.\n+\n+   The following command will generate a Java JKS keystore containing the following artifacts for the server:\n+   * An X.509 certificate containing the public key identifying the server\n+   * A private key for the public/private key pair\n+\n+   ```bash\n+   $ keytool -storetype JKS -keystore <java-keystore-file-name> -storepass <java-keystore-password>\\\n+           -genkey -keyalg <key-algorithm> -keysize <key-size> -keypass <private-key-password>\\\n+           -alias <alias> -validity <validity>\\\n+           -dname \"<distinguished-name>\"\\\n+           -ext SAN=dns:<hostname1>,dns:<hostname2>,ip:<ipaddress1>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\\\n+              -genkey -keyalg RSA -keysize 2048 -keypass changeit\\\n+              -alias server -validity 365\\\n+              -dname \"CN=server.pravega.io, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown\"\\\n+              -ext SAN=dns:server.abc.com,ip:127.0.0.1", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNTEwNA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557815104", "bodyText": "Yes, that's certainly a future requirement. Currently, Pravega doesn't support pkcs12 files.", "author": "ravisharda", "createdAt": "2021-01-15T01:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5ODQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMTYxMQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557701611", "bodyText": "\"have the CA to sign\" -> \"have the CA sign\"", "author": "derekm", "createdAt": "2021-01-14T21:11:51Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit\n+\n+   # Optionally, list the truststore's contents and inspect the output to verify everything is in order. The output \n+   # should show a single entry with alias name `caroot` and entry type `trustedCertEntry`.\n+   $ keytool -list -v -keystore client.truststore.jks -storepass changeit\n+   ```\n+\n+At this point, the following CA and truststore artifacts should be ready:\n+\n+| File | Description | Example command for inspecting the file's Contents |\n+|:-----:|:--------|:--------------|\n+| `ca-cert.crt` | PEM-encoded X.509 certificate of the CA | `$ openssl x509 -in ca-cert.crt -text -noout` |\n+| `ca-key.key` | PEM-encoded file containing the CA's encrypted private key  | `$ openssl pkcs8 -inform PEM -in ca-key.key -topk8` |\n+| `client.truststore.jks` | A password-protected truststore file containing the CA's certificate | `$ keytool -list -v -keystore client.truststore.jks -storepass changeit` |\n+\n+## Generate TLS Certificates and Other TLS Artifacts for the Server\n+\n+Here, we prepare a set of TLS artifacts that can be used by one or more nodes.  \n+\n+We'll use the CA created in the previous stage to sign the server certificate for demonstration, but in real usage you \n+may instead get it signed by an existing internal CA in your environment or a public CA.\n+\n+The high-level steps involved in this stage are:\n+\n+1. Generate a set of server certificate and private key.\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+4. Prepare a keystore containing the signed server certificate and the CA's certificate.\n+5. Export the server certificate's private key.\n+\n+Note that these steps will need to be repeated with different input for each set. We discussed the number of sets \n+required earlier in the [Overview](#overview) section. \n+\n+The above steps are described below: \n+\n+1. Generate a set of server certificate and private key.\n+\n+   The following command will generate a Java JKS keystore containing the following artifacts for the server:\n+   * An X.509 certificate containing the public key identifying the server\n+   * A private key for the public/private key pair\n+\n+   ```bash\n+   $ keytool -storetype JKS -keystore <java-keystore-file-name> -storepass <java-keystore-password>\\\n+           -genkey -keyalg <key-algorithm> -keysize <key-size> -keypass <private-key-password>\\\n+           -alias <alias> -validity <validity>\\\n+           -dname \"<distinguished-name>\"\\\n+           -ext SAN=dns:<hostname1>,dns:<hostname2>,ip:<ipaddress1>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\\\n+              -genkey -keyalg RSA -keysize 2048 -keypass changeit\\\n+              -alias server -validity 365\\\n+              -dname \"CN=server.pravega.io, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown\"\\\n+              -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   \n+   # Optionally, verify the contents of the generated file\n+   $ keytool -list -v -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\n+   ```\n+\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+\n+   It helps to think of a CSR as an application for getting a certificate signed by a trusted authority. \n+   \n+   A CSR is typically generated on the same server/node that uses the certificate, so that the corresponding private key\n+   doesn't need to be moved anywhere else. In some other environments, CSRs are generated in a central server and the \n+   resulting certificates are distributed to the services that need them.  \n+\n+   ```bash\n+   $ keytool -keystore <java-keystore-file-path> -storepass <java-keystore-password> -alias <alias> \\\n+             -certreq -file <csr-file-path> \\\n+             -storepass <java-keystore-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore server_unsigned.keystore.jks -storepass changeit -alias server \\ \n+             -certreq -file server.csr \\\n+             -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   ```\n+\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+\n+   If you are using a public or internal CA service, follow that CA's process for submitting the CSR and obtaining\n+   a signed certificate. To use the custom CA generated using the steps mentioned [earlier](#stage-1-setting-up-a-certificate-authority-ca) or an internal CA\n+   certificate/key bundle, use the steps below:\n+   \n+   First create a `server-csr.conf` file with the following contents. Replace `alt_names` with the server's hostname/ \n+   IP address that Pravega will use to access the server. If the same certificate is used in multiple servers, add \n+   hostnames/IP addresses of all the servers. \n+   \n+   ```\n+   [req]\n+   req_extensions = v3_req\n+   prompt = no\n+   \n+   [v3_req]\n+   subjectAltName = @alt_names\n+   \n+   [alt_names]\n+   DNS.1 = server.abc.com\n+   DNS.2 = server.pravega.io\n+   IP.1 = 127.0.0.1\n+   ```\n+   \n+   Now, have the CA to sign the certificate:", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMjAyOQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557822029", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2021-01-15T02:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMTYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwNDc0Ng==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557704746", "bodyText": "Consider examples that make clear what C, ST, L, O & OU mean, instead of using \"Unknown\" throughout, such as in the 1st openssl at the top of the document.", "author": "derekm", "createdAt": "2021-01-14T21:17:54Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit\n+\n+   # Optionally, list the truststore's contents and inspect the output to verify everything is in order. The output \n+   # should show a single entry with alias name `caroot` and entry type `trustedCertEntry`.\n+   $ keytool -list -v -keystore client.truststore.jks -storepass changeit\n+   ```\n+\n+At this point, the following CA and truststore artifacts should be ready:\n+\n+| File | Description | Example command for inspecting the file's Contents |\n+|:-----:|:--------|:--------------|\n+| `ca-cert.crt` | PEM-encoded X.509 certificate of the CA | `$ openssl x509 -in ca-cert.crt -text -noout` |\n+| `ca-key.key` | PEM-encoded file containing the CA's encrypted private key  | `$ openssl pkcs8 -inform PEM -in ca-key.key -topk8` |\n+| `client.truststore.jks` | A password-protected truststore file containing the CA's certificate | `$ keytool -list -v -keystore client.truststore.jks -storepass changeit` |\n+\n+## Generate TLS Certificates and Other TLS Artifacts for the Server\n+\n+Here, we prepare a set of TLS artifacts that can be used by one or more nodes.  \n+\n+We'll use the CA created in the previous stage to sign the server certificate for demonstration, but in real usage you \n+may instead get it signed by an existing internal CA in your environment or a public CA.\n+\n+The high-level steps involved in this stage are:\n+\n+1. Generate a set of server certificate and private key.\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+4. Prepare a keystore containing the signed server certificate and the CA's certificate.\n+5. Export the server certificate's private key.\n+\n+Note that these steps will need to be repeated with different input for each set. We discussed the number of sets \n+required earlier in the [Overview](#overview) section. \n+\n+The above steps are described below: \n+\n+1. Generate a set of server certificate and private key.\n+\n+   The following command will generate a Java JKS keystore containing the following artifacts for the server:\n+   * An X.509 certificate containing the public key identifying the server\n+   * A private key for the public/private key pair\n+\n+   ```bash\n+   $ keytool -storetype JKS -keystore <java-keystore-file-name> -storepass <java-keystore-password>\\\n+           -genkey -keyalg <key-algorithm> -keysize <key-size> -keypass <private-key-password>\\\n+           -alias <alias> -validity <validity>\\\n+           -dname \"<distinguished-name>\"\\\n+           -ext SAN=dns:<hostname1>,dns:<hostname2>,ip:<ipaddress1>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\\\n+              -genkey -keyalg RSA -keysize 2048 -keypass changeit\\\n+              -alias server -validity 365\\\n+              -dname \"CN=server.pravega.io, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown\"\\", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNTIzMA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557815230", "bodyText": "Sure, I've made the change now.", "author": "ravisharda", "createdAt": "2021-01-15T01:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwNDc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwNjA1MQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557706051", "bodyText": "consider using server2.abc.com for consistency", "author": "derekm", "createdAt": "2021-01-14T21:20:26Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit\n+\n+   # Optionally, list the truststore's contents and inspect the output to verify everything is in order. The output \n+   # should show a single entry with alias name `caroot` and entry type `trustedCertEntry`.\n+   $ keytool -list -v -keystore client.truststore.jks -storepass changeit\n+   ```\n+\n+At this point, the following CA and truststore artifacts should be ready:\n+\n+| File | Description | Example command for inspecting the file's Contents |\n+|:-----:|:--------|:--------------|\n+| `ca-cert.crt` | PEM-encoded X.509 certificate of the CA | `$ openssl x509 -in ca-cert.crt -text -noout` |\n+| `ca-key.key` | PEM-encoded file containing the CA's encrypted private key  | `$ openssl pkcs8 -inform PEM -in ca-key.key -topk8` |\n+| `client.truststore.jks` | A password-protected truststore file containing the CA's certificate | `$ keytool -list -v -keystore client.truststore.jks -storepass changeit` |\n+\n+## Generate TLS Certificates and Other TLS Artifacts for the Server\n+\n+Here, we prepare a set of TLS artifacts that can be used by one or more nodes.  \n+\n+We'll use the CA created in the previous stage to sign the server certificate for demonstration, but in real usage you \n+may instead get it signed by an existing internal CA in your environment or a public CA.\n+\n+The high-level steps involved in this stage are:\n+\n+1. Generate a set of server certificate and private key.\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+4. Prepare a keystore containing the signed server certificate and the CA's certificate.\n+5. Export the server certificate's private key.\n+\n+Note that these steps will need to be repeated with different input for each set. We discussed the number of sets \n+required earlier in the [Overview](#overview) section. \n+\n+The above steps are described below: \n+\n+1. Generate a set of server certificate and private key.\n+\n+   The following command will generate a Java JKS keystore containing the following artifacts for the server:\n+   * An X.509 certificate containing the public key identifying the server\n+   * A private key for the public/private key pair\n+\n+   ```bash\n+   $ keytool -storetype JKS -keystore <java-keystore-file-name> -storepass <java-keystore-password>\\\n+           -genkey -keyalg <key-algorithm> -keysize <key-size> -keypass <private-key-password>\\\n+           -alias <alias> -validity <validity>\\\n+           -dname \"<distinguished-name>\"\\\n+           -ext SAN=dns:<hostname1>,dns:<hostname2>,ip:<ipaddress1>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\\\n+              -genkey -keyalg RSA -keysize 2048 -keypass changeit\\\n+              -alias server -validity 365\\\n+              -dname \"CN=server.pravega.io, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown\"\\\n+              -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   \n+   # Optionally, verify the contents of the generated file\n+   $ keytool -list -v -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\n+   ```\n+\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+\n+   It helps to think of a CSR as an application for getting a certificate signed by a trusted authority. \n+   \n+   A CSR is typically generated on the same server/node that uses the certificate, so that the corresponding private key\n+   doesn't need to be moved anywhere else. In some other environments, CSRs are generated in a central server and the \n+   resulting certificates are distributed to the services that need them.  \n+\n+   ```bash\n+   $ keytool -keystore <java-keystore-file-path> -storepass <java-keystore-password> -alias <alias> \\\n+             -certreq -file <csr-file-path> \\\n+             -storepass <java-keystore-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore server_unsigned.keystore.jks -storepass changeit -alias server \\ \n+             -certreq -file server.csr \\\n+             -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   ```\n+\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+\n+   If you are using a public or internal CA service, follow that CA's process for submitting the CSR and obtaining\n+   a signed certificate. To use the custom CA generated using the steps mentioned [earlier](#stage-1-setting-up-a-certificate-authority-ca) or an internal CA\n+   certificate/key bundle, use the steps below:\n+   \n+   First create a `server-csr.conf` file with the following contents. Replace `alt_names` with the server's hostname/ \n+   IP address that Pravega will use to access the server. If the same certificate is used in multiple servers, add \n+   hostnames/IP addresses of all the servers. \n+   \n+   ```\n+   [req]\n+   req_extensions = v3_req\n+   prompt = no\n+   \n+   [v3_req]\n+   subjectAltName = @alt_names\n+   \n+   [alt_names]\n+   DNS.1 = server.abc.com\n+   DNS.2 = server.pravega.io", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNTUxNQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557815515", "bodyText": "Sure, I've now renamed the DNS names in the SAN to server1.pravega.io and server2.pravega.io everywhere.", "author": "ravisharda", "createdAt": "2021-01-15T02:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwNjA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxMTQ2Mw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557711463", "bodyText": "Refer to server keystore as \"encrypted.\"\n-storepass should be changeit instead of 1111_aaaa", "author": "derekm", "createdAt": "2021-01-14T21:31:20Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit\n+\n+   # Optionally, list the truststore's contents and inspect the output to verify everything is in order. The output \n+   # should show a single entry with alias name `caroot` and entry type `trustedCertEntry`.\n+   $ keytool -list -v -keystore client.truststore.jks -storepass changeit\n+   ```\n+\n+At this point, the following CA and truststore artifacts should be ready:\n+\n+| File | Description | Example command for inspecting the file's Contents |\n+|:-----:|:--------|:--------------|\n+| `ca-cert.crt` | PEM-encoded X.509 certificate of the CA | `$ openssl x509 -in ca-cert.crt -text -noout` |\n+| `ca-key.key` | PEM-encoded file containing the CA's encrypted private key  | `$ openssl pkcs8 -inform PEM -in ca-key.key -topk8` |\n+| `client.truststore.jks` | A password-protected truststore file containing the CA's certificate | `$ keytool -list -v -keystore client.truststore.jks -storepass changeit` |\n+\n+## Generate TLS Certificates and Other TLS Artifacts for the Server\n+\n+Here, we prepare a set of TLS artifacts that can be used by one or more nodes.  \n+\n+We'll use the CA created in the previous stage to sign the server certificate for demonstration, but in real usage you \n+may instead get it signed by an existing internal CA in your environment or a public CA.\n+\n+The high-level steps involved in this stage are:\n+\n+1. Generate a set of server certificate and private key.\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+4. Prepare a keystore containing the signed server certificate and the CA's certificate.\n+5. Export the server certificate's private key.\n+\n+Note that these steps will need to be repeated with different input for each set. We discussed the number of sets \n+required earlier in the [Overview](#overview) section. \n+\n+The above steps are described below: \n+\n+1. Generate a set of server certificate and private key.\n+\n+   The following command will generate a Java JKS keystore containing the following artifacts for the server:\n+   * An X.509 certificate containing the public key identifying the server\n+   * A private key for the public/private key pair\n+\n+   ```bash\n+   $ keytool -storetype JKS -keystore <java-keystore-file-name> -storepass <java-keystore-password>\\\n+           -genkey -keyalg <key-algorithm> -keysize <key-size> -keypass <private-key-password>\\\n+           -alias <alias> -validity <validity>\\\n+           -dname \"<distinguished-name>\"\\\n+           -ext SAN=dns:<hostname1>,dns:<hostname2>,ip:<ipaddress1>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\\\n+              -genkey -keyalg RSA -keysize 2048 -keypass changeit\\\n+              -alias server -validity 365\\\n+              -dname \"CN=server.pravega.io, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown\"\\\n+              -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   \n+   # Optionally, verify the contents of the generated file\n+   $ keytool -list -v -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\n+   ```\n+\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+\n+   It helps to think of a CSR as an application for getting a certificate signed by a trusted authority. \n+   \n+   A CSR is typically generated on the same server/node that uses the certificate, so that the corresponding private key\n+   doesn't need to be moved anywhere else. In some other environments, CSRs are generated in a central server and the \n+   resulting certificates are distributed to the services that need them.  \n+\n+   ```bash\n+   $ keytool -keystore <java-keystore-file-path> -storepass <java-keystore-password> -alias <alias> \\\n+             -certreq -file <csr-file-path> \\\n+             -storepass <java-keystore-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore server_unsigned.keystore.jks -storepass changeit -alias server \\ \n+             -certreq -file server.csr \\\n+             -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   ```\n+\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+\n+   If you are using a public or internal CA service, follow that CA's process for submitting the CSR and obtaining\n+   a signed certificate. To use the custom CA generated using the steps mentioned [earlier](#stage-1-setting-up-a-certificate-authority-ca) or an internal CA\n+   certificate/key bundle, use the steps below:\n+   \n+   First create a `server-csr.conf` file with the following contents. Replace `alt_names` with the server's hostname/ \n+   IP address that Pravega will use to access the server. If the same certificate is used in multiple servers, add \n+   hostnames/IP addresses of all the servers. \n+   \n+   ```\n+   [req]\n+   req_extensions = v3_req\n+   prompt = no\n+   \n+   [v3_req]\n+   subjectAltName = @alt_names\n+   \n+   [alt_names]\n+   DNS.1 = server.abc.com\n+   DNS.2 = server.pravega.io\n+   IP.1 = 127.0.0.1\n+   ```\n+   \n+   Now, have the CA to sign the certificate:\n+\n+   ```bash\n+   $ openssl x509 -req -CA <ca-cert-file-path> -CAkey <ca-private-key-file-path> \\ \n+           -in <csr-file-path> -out <signed-server-cert-file-path> \\\n+           -days <validity> -CAcreateserial -passin pass:<csr-file-password> \\\n+           -extfile server-csr.conf -extensions v3_req\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ openssl x509 -req -CA ca-cert.crt -CAkey ca-key.key \\\n+        -in server.csr -out server-cert.crt \\\n+        -days 365 -CAcreateserial -passin pass:changeit \\\n+        -extfile server-csr.conf -extensions v3_req\n+   \n+   # Optionally, check the contents of the signed certificate.\n+   $ openssl x509 -in server-cert.crt -text -noout\n+   ```\n+\n+4. Prepare a new keystore containing the signed server certificate and the CA's certificate chain. \n+\n+   ```bash\n+   # Import the CA certificate into a new keystore file.\n+   $ keytool -keystore <server-jks-keystore-file-path> -alias <ca-alias> -noprompt \\\n+                -import -file <ca-cert-file-path> -storepass <server-jks-keystore-password>\n+   \n+   # Import the signed server certificate into the keystore.\n+   $ keytool -keystore <server-jks-keystore-file-path> -alias <server-alias> -noprompt \\\n+                -import -file <signed-server-cert-file-path> -storepass <server-jks-keystore-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore server.keystore.jks -alias CARoot -noprompt \\\n+             -import -file ca-cert.crt -storepass changeit\n+\n+   $ keytool -keystore server.keystore.jks -alias server -noprompt \\\n+                -import -file server-cert.crt -storepass changeit\n+   \n+   # Optionally, list the keystore and inspect the output\n+   $ keytool -list -v -storepass changeit -keystore server.keystore.jks\n+   ```\n+\n+5. Export the server certificate's private key. \n+   \n+   This is a two-step process.\n+   * First, convert the server's keystore in `.jks` format into `.p12` format.\n+\n+     ```bash\n+     $ keytool -importkeystore \\\n+               -srckeystore <server-jks-keystore-file-path> \\\n+               -destkeystore <server-pkcs12-keystore-file-path> \\\n+               -srcstoretype jks -deststoretype pkcs12 \\\n+               -srcstorepass <server-jks-keystore-password> -deststorepass <server-pkcs12-keystore>\n+     ```\n+     \n+     Example:\n+     ```bash\n+     $ keytool -importkeystore \\\n+               -srckeystore server.keystore.jks \\\n+               -destkeystore server.keystore.p12 \\\n+               -srcstoretype jks -deststoretype pkcs12 \\\n+               -srcstorepass changeit -deststorepass changeit\n+     ```\n+     \n+   * Now, export the private key of the server into a `PEM` encoded file. Note that the generated `PEM` file is not protected\n+     by a password. The key itself is password-protected, as we are using the `-nodes` flag. So, be sure\n+     to protect it using operating system's technical and procedural controls.\n+\n+     ```bash\n+     $ openssl pkcs12 -in <server-pkcs12-keystore-file-path> -passin pass:<key-password> \\\n+                      -nodes -out <server-key-file-path>\n+     ```\n+     \n+     Example:\n+     ```bash\n+     $ openssl pkcs12 -in server.keystore.p12 -out server-key.key -passin pass:changeit -nodes\n+     ```\n+\n+Step 5 concludes this stage and the stage is now set for installing the certificates and other TLS artifacts in Pravega.\n+\n+The table below lists the key output of this stage. \n+\n+| File | Description| Command for Inspecting the Contents |\n+|:-----:| :---:|:--------|\n+| `server-cert.crt` | PEM-encoded CA-signed server certificate file | `openssl x509 -in server-cert.crt -text -noout`|\n+| `server-key.key` | PEM-encoded file containing the server's encrypted private key |  `openssl pkcs8 -inform PEM -in server-key.key -topk8` |\n+| `server.keystore.jks` | The server keystore file in .jks format | `keytool -list -v -keystore server.keystore.jks -storepass 1111_aaaa` |", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNTYwMw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557815603", "bodyText": "Nice catch! :) Fixed.", "author": "ravisharda", "createdAt": "2021-01-15T02:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxMTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxMzQxNQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557713415", "bodyText": "Great tutorial!\nShould you point out somewhere that these artifacts will need to be recreated to add hostnames or IPs whenever Pravega is scaled up with additional controllers or segment stores?", "author": "derekm", "createdAt": "2021-01-14T21:35:21Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMTE3MA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557821170", "bodyText": "Yes, it'd help to add that comment. I've now updated the 2nd and the 3rd option mentioned in the Overview section with the suggested change.", "author": "ravisharda", "createdAt": "2021-01-15T02:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxMzQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNDg3Nw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557714877", "bodyText": "To reduce redundancy with the word \"stage\" in this line and the line below, consider:\n\"Step 5 concludes this stage and the stage is now set\" -> \"Step 5 concludes this stage and we are now set\"", "author": "derekm", "createdAt": "2021-01-14T21:38:07Z", "path": "documentation/src/docs/security/generating-tls-artifacts.md", "diffHunk": "@@ -0,0 +1,324 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Creating TLS Certificates, Keys and Other TLS Artifacts\n+\n+This document describes how to create TLS certificates, keys and other artifacts for the server components. The \n+generated CA certificate and Java truststore may also be used on client-side for validating the servers' certificates.\n+\n+   * [Overview](#overview)\n+   * [Setting up a Certificate Authority (CA)](#setting-up-a-certificate-authority-ca)\n+   * [Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server)\n+\n+## Overview\n+\n+A TLS server certificate is an X.509 digital certificate that binds the server's identity (such as the server's \n+DNS name or IP address or both) to the server's public key. The public key is part of the public-private key pair used \n+for asymmetric encryption during the TLS handshake. \n+\n+Each Controller and Segment Store service requires a pair of PEM-encoded TLS certificate and private key. Each \n+service also requires a PEM-encoded certificate of the CA that has signed the server certificates. Moreover, the \n+Controller REST interface requires its certificate and keys in Java JKS formats. We refer to all the required files \n+as TLS artifacts, henceforth. \n+\n+While the TLS certificate is public, the corresponding key is private and must be kept protected (typically\n+in the server that uses the TLS certificate and the key). Each server should use its own set of TLS artifacts; \n+reusing certificates requires reusing private keys as well, and sharing private keys across multiple servers increases \n+the risk that they will be compromised.\n+\n+Here are a few strategies for determining the sets of TLS artifacts required for a Pravega cluster:\n+\n+1. _Use separate TLS artifacts for each host/machine or service_. \n+   \n+   Manual deployments supports this and the other configurations listed below. This is the most secure option. \n+2. _Use two sets of TLS artifacts - one for the Controllers and the other for the Segment Stores_. \n+   \n+   In this case, each certificate is assigned to all the respective nodes (Controllers or Segment Stores) by specifying \n+   the nodes' DNS names and/or IP addresses in the certificate's \n+   [Subject Alternative Name (SAN)](https://en.wikipedia.org/wiki/Subject_Alternative_Name) field. \n+   \n+   Kubernetes and other forms of containerized deployments supports this configuration. \n+3. _Use the same set for all Controllers and Segment Store services_. \n+   \n+   In this case, the certificate must contain the network identity of all the Controller and Segment Store services. This is \n+   the least secure option. All deployment options support this configuration.  \n+   \n+The chosen configuration determines the number of TLS artifacts sets required for a \n+Pravega cluster. Each set can be prepared using the process described later in this document under\n+[Generate TLS Certificates and Other TLS Artifacts for the Server](#generate-tls-certificates-and-other-tls-artifacts-for-the-server). \n+\n+Another important consideration is whether you want to terminate TLS at an external infrastructural component like \n+reverse proxy, Kubernetes Ingress or a load balancer. If TLS is terminated at such an infrastructural component, instead \n+of Pravega services, you will need to generate TLS artifacts for those infrastructural components instead, using similar\n+steps described in this document; however, the exact steps may be slightly different and additional steps may be required to \n+ensure that other parts of the infrastructure can communicate with it. Refer to the respective platform vendor's \n+documentation, \n+such as [this](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress) one from Google Kubernetes Engine, \n+for instructions.\n+\n+**Before you Begin:**\n+\n+The steps described in this document use OpenSSL and Java Keytool to generate TLS artifacts like certificates, keys, \n+Java keystores and Java truststores. Install OpenSSL and Java Development Kit (JDK) on the hosts where the artifacts \n+will be generated.\n+\n+**Note:**\n+* The examples shown in this document use command line arguments to pass all inputs to the command. To pass\n+  sensitive command arguments via prompts instead, just exclude the corresponding option (as shown in the second command\n+  below). \n+\n+  ```bash\n+  # Passwords are passed as command line arguments.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -validity <validity> -genkey \\\n+              -storepass <keystore-password> -keypass <key-password> \\\n+              -dname <distinguished-name> -ext SAN=DNS:<hostname>,\n+\n+  # Passwords (and some other arguments) are to be entered interactively on the prompt.\n+  $ keytool -keystore server01.keystore.jks -alias server01 -genkey\n+  ```\n+* A weak password `changeit` is used everywhere in this document for easier reading. Be sure to replace it with \n+  a strong and separate password for each file.\n+\n+## Setting up a Certificate Authority (CA)\n+\n+If you are planning to use a public CA or an existing private/internal CA, you may skip \n+this part altogether and go directly to the [next section](#generate-tls-certificates-and-other-tls-artifacts-for-the-server).\n+\n+Here, we'll create a CA in the form of a public/private key pair and a self-signed certificate.\n+Later, we'll use this CA certificate/key bundle to sign the servers' certificates.\n+\n+1. Generate a CA certificate and public/private key pair. \n+\n+   ```bash\n+   $ openssl req -new -x509 -keyout <ca-private-key-file-path> -out <ca-cert-file-path> -days <validity-in-days> \\\n+            -subj \"<distinguished_name>\" \\\n+            -passout pass:<ca-private-key-password>\n+   ```\n+\n+   Example:\n+   ```bash\n+   $ openssl req -new -x509 -keyout ca-key.key -out ca-cert.crt -days 365 \\\n+            -subj \"/C=US/ST=Washington/L=Seattle/O=Pravega/OU=CA/CN=Pravega-Stack-CA\" \\\n+            -passout pass:changeit\n+   ```\n+  \n+   The command above will generate the following two PEM-encoded files: \n+   * A file containing the encrypted private key.\n+   * A file containing the CA certificate.\n+   \n+2. Optionally, create a Java truststore containing the CA's certificate. This may be used by client applications if \n+   they configure the truststore using the `javax.net.ssl.trustStore` Java option. \n+   \n+   ```bash\n+   $ keytool -keystore <java-truststore-file-path> -noprompt \\\n+             -alias <trusted-cert-entry-alias> \\\n+             -import -file <ca-cert-file-path> \\\n+             -storepass <java-truststore-file-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore client.truststore.jks -noprompt \\\n+             -alias caroot \\ \n+             -import -file ca-cert.crt \\\n+             -storepass changeit\n+\n+   # Optionally, list the truststore's contents and inspect the output to verify everything is in order. The output \n+   # should show a single entry with alias name `caroot` and entry type `trustedCertEntry`.\n+   $ keytool -list -v -keystore client.truststore.jks -storepass changeit\n+   ```\n+\n+At this point, the following CA and truststore artifacts should be ready:\n+\n+| File | Description | Example command for inspecting the file's Contents |\n+|:-----:|:--------|:--------------|\n+| `ca-cert.crt` | PEM-encoded X.509 certificate of the CA | `$ openssl x509 -in ca-cert.crt -text -noout` |\n+| `ca-key.key` | PEM-encoded file containing the CA's encrypted private key  | `$ openssl pkcs8 -inform PEM -in ca-key.key -topk8` |\n+| `client.truststore.jks` | A password-protected truststore file containing the CA's certificate | `$ keytool -list -v -keystore client.truststore.jks -storepass changeit` |\n+\n+## Generate TLS Certificates and Other TLS Artifacts for the Server\n+\n+Here, we prepare a set of TLS artifacts that can be used by one or more nodes.  \n+\n+We'll use the CA created in the previous stage to sign the server certificate for demonstration, but in real usage you \n+may instead get it signed by an existing internal CA in your environment or a public CA.\n+\n+The high-level steps involved in this stage are:\n+\n+1. Generate a set of server certificate and private key.\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+4. Prepare a keystore containing the signed server certificate and the CA's certificate.\n+5. Export the server certificate's private key.\n+\n+Note that these steps will need to be repeated with different input for each set. We discussed the number of sets \n+required earlier in the [Overview](#overview) section. \n+\n+The above steps are described below: \n+\n+1. Generate a set of server certificate and private key.\n+\n+   The following command will generate a Java JKS keystore containing the following artifacts for the server:\n+   * An X.509 certificate containing the public key identifying the server\n+   * A private key for the public/private key pair\n+\n+   ```bash\n+   $ keytool -storetype JKS -keystore <java-keystore-file-name> -storepass <java-keystore-password>\\\n+           -genkey -keyalg <key-algorithm> -keysize <key-size> -keypass <private-key-password>\\\n+           -alias <alias> -validity <validity>\\\n+           -dname \"<distinguished-name>\"\\\n+           -ext SAN=dns:<hostname1>,dns:<hostname2>,ip:<ipaddress1>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\\\n+              -genkey -keyalg RSA -keysize 2048 -keypass changeit\\\n+              -alias server -validity 365\\\n+              -dname \"CN=server.pravega.io, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown\"\\\n+              -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   \n+   # Optionally, verify the contents of the generated file\n+   $ keytool -list -v -storetype JKS -keystore server_unsigned.keystore.jks -storepass changeit\n+   ```\n+\n+2. Generate a Certificate Signing Request (CSR) for the server certificate.\n+\n+   It helps to think of a CSR as an application for getting a certificate signed by a trusted authority. \n+   \n+   A CSR is typically generated on the same server/node that uses the certificate, so that the corresponding private key\n+   doesn't need to be moved anywhere else. In some other environments, CSRs are generated in a central server and the \n+   resulting certificates are distributed to the services that need them.  \n+\n+   ```bash\n+   $ keytool -keystore <java-keystore-file-path> -storepass <java-keystore-password> -alias <alias> \\\n+             -certreq -file <csr-file-path> \\\n+             -storepass <java-keystore-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore server_unsigned.keystore.jks -storepass changeit -alias server \\ \n+             -certreq -file server.csr \\\n+             -ext SAN=dns:server.abc.com,ip:127.0.0.1\n+   ```\n+\n+3. Submit the CSR to a CA and obtain a signed certificate.\n+\n+   If you are using a public or internal CA service, follow that CA's process for submitting the CSR and obtaining\n+   a signed certificate. To use the custom CA generated using the steps mentioned [earlier](#stage-1-setting-up-a-certificate-authority-ca) or an internal CA\n+   certificate/key bundle, use the steps below:\n+   \n+   First create a `server-csr.conf` file with the following contents. Replace `alt_names` with the server's hostname/ \n+   IP address that Pravega will use to access the server. If the same certificate is used in multiple servers, add \n+   hostnames/IP addresses of all the servers. \n+   \n+   ```\n+   [req]\n+   req_extensions = v3_req\n+   prompt = no\n+   \n+   [v3_req]\n+   subjectAltName = @alt_names\n+   \n+   [alt_names]\n+   DNS.1 = server.abc.com\n+   DNS.2 = server.pravega.io\n+   IP.1 = 127.0.0.1\n+   ```\n+   \n+   Now, have the CA to sign the certificate:\n+\n+   ```bash\n+   $ openssl x509 -req -CA <ca-cert-file-path> -CAkey <ca-private-key-file-path> \\ \n+           -in <csr-file-path> -out <signed-server-cert-file-path> \\\n+           -days <validity> -CAcreateserial -passin pass:<csr-file-password> \\\n+           -extfile server-csr.conf -extensions v3_req\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ openssl x509 -req -CA ca-cert.crt -CAkey ca-key.key \\\n+        -in server.csr -out server-cert.crt \\\n+        -days 365 -CAcreateserial -passin pass:changeit \\\n+        -extfile server-csr.conf -extensions v3_req\n+   \n+   # Optionally, check the contents of the signed certificate.\n+   $ openssl x509 -in server-cert.crt -text -noout\n+   ```\n+\n+4. Prepare a new keystore containing the signed server certificate and the CA's certificate chain. \n+\n+   ```bash\n+   # Import the CA certificate into a new keystore file.\n+   $ keytool -keystore <server-jks-keystore-file-path> -alias <ca-alias> -noprompt \\\n+                -import -file <ca-cert-file-path> -storepass <server-jks-keystore-password>\n+   \n+   # Import the signed server certificate into the keystore.\n+   $ keytool -keystore <server-jks-keystore-file-path> -alias <server-alias> -noprompt \\\n+                -import -file <signed-server-cert-file-path> -storepass <server-jks-keystore-password>\n+   ```\n+   \n+   Example:\n+   ```bash\n+   $ keytool -keystore server.keystore.jks -alias CARoot -noprompt \\\n+             -import -file ca-cert.crt -storepass changeit\n+\n+   $ keytool -keystore server.keystore.jks -alias server -noprompt \\\n+                -import -file server-cert.crt -storepass changeit\n+   \n+   # Optionally, list the keystore and inspect the output\n+   $ keytool -list -v -storepass changeit -keystore server.keystore.jks\n+   ```\n+\n+5. Export the server certificate's private key. \n+   \n+   This is a two-step process.\n+   * First, convert the server's keystore in `.jks` format into `.p12` format.\n+\n+     ```bash\n+     $ keytool -importkeystore \\\n+               -srckeystore <server-jks-keystore-file-path> \\\n+               -destkeystore <server-pkcs12-keystore-file-path> \\\n+               -srcstoretype jks -deststoretype pkcs12 \\\n+               -srcstorepass <server-jks-keystore-password> -deststorepass <server-pkcs12-keystore>\n+     ```\n+     \n+     Example:\n+     ```bash\n+     $ keytool -importkeystore \\\n+               -srckeystore server.keystore.jks \\\n+               -destkeystore server.keystore.p12 \\\n+               -srcstoretype jks -deststoretype pkcs12 \\\n+               -srcstorepass changeit -deststorepass changeit\n+     ```\n+     \n+   * Now, export the private key of the server into a `PEM` encoded file. Note that the generated `PEM` file is not protected\n+     by a password. The key itself is password-protected, as we are using the `-nodes` flag. So, be sure\n+     to protect it using operating system's technical and procedural controls.\n+\n+     ```bash\n+     $ openssl pkcs12 -in <server-pkcs12-keystore-file-path> -passin pass:<key-password> \\\n+                      -nodes -out <server-key-file-path>\n+     ```\n+     \n+     Example:\n+     ```bash\n+     $ openssl pkcs12 -in server.keystore.p12 -out server-key.key -passin pass:changeit -nodes\n+     ```\n+\n+Step 5 concludes this stage and the stage is now set for installing the certificates and other TLS artifacts in Pravega.", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMjExNA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557822114", "bodyText": "Changed as suggested.", "author": "ravisharda", "createdAt": "2021-01-15T02:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNzY2MA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557717660", "bodyText": "Use a filename here that matches the equivalent filename in generating-tls-artifacts.md for consistency.", "author": "derekm", "createdAt": "2021-01-14T21:43:45Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -247,54 +63,31 @@ These steps are discussed in the following sub-sections.\n \n ### Configuring TLS and Auth on Server Side\n \n-This step is about using the certificates, keys, keystores and truststores generated earlier to configure\n-TLS and Auth for the services on the server side.\n-\n-Note that if you enable TLS and Auth on one service, you must enable them for all the other services too. Pravega\n-does not support using TLS and Auth for only some instances of the services.\n-\n You can configure the following services for TLS and Auth:\n \n 1. Controller\n 2. Segment Store\n-3. Zookeeper (optionally)\n-4. Bookkeeper (optionally)\n+3. Zookeeper (optional)\n+4. Bookkeeper (optional)\n \n For information about enabling TLS for Zookeeper and Bookeeper, refer to\n their documentation here:\n * [ZooKeeper SSL Guide](https://cwiki.apache.org/confluence/display/ZOOKEEPER/ZooKeeper+SSL+User+Guide)\n * [BookKeeper - Encryption and Authentication using TLS](https://bookkeeper.apache.org/docs/latest/security/tls/)\n \n-Configuring security for Controllers and Segment Stores is discussed below.\n-\n **Controller**\n \n-Controller services can be configured in three different ways:\n+Controller services can be configured in two different ways:\n \n 1. By specifying the configuration parameter values directly in the `controller.config.properties` file. For example,\n \n    ```\n    controller.security.tls.enable=true\n-   controller.security.tls.server.certificate.location=/etc/secrets/controller01.pem\n-   ```\n-2. By specifying configuration values via corresponding environment variables. For example,\n-\n-   ```bash\n-   # TLS_ENABLED environment variable corresponds to Controller configuration parameter\n-   # \"controller.auth.tlsEnabled\".\n-   $ export TLS_ENABLED: \"true\"\n-   ```\n-\n-   To identify the environment variables corresponding to the configuration parameter, inspect the default\n-   `controller.config.properties` file and locate the variables.\n-\n-   ```\n-   controller.security.tls.enable=${TLS_ENABLED}\n-   controller.security.tls.server.certificate.location=${TLS_CERT_FILE}\n+   controller.security.tls.server.certificate.location=/etc/secrets/controller01-server-cert.crt", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMTE5OA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557821198", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2021-01-15T02:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNzY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxODU1NQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557718555", "bodyText": "\"refer to [this]\" -> \"refer to the [Pravega Security Configurations]\"", "author": "derekm", "createdAt": "2021-01-14T21:45:36Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMTIzOA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557821238", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2021-01-15T02:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxODU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxOTUyOQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557719529", "bodyText": "Use filenames here that match generating-tls-artifacts.md for consistency?", "author": "derekm", "createdAt": "2021-01-14T21:47:21Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMjE4Nw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557822187", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2021-01-15T02:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxOTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcyMTIzOQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557721239", "bodyText": "\"refer to [this]\" -> \"refer to the [Pravega Security Configurations]\"", "author": "derekm", "createdAt": "2021-01-14T21:50:39Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |\n+ | `controller.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `controller.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `controller.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `controller.security.auth.enable` | `true` |\n+ | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | `/etc/secrets/password-auth-handler.database` |\n+ | `controller.security.auth.delegationToken.signingKey.basis` | `a-secret-value` |\n \n  [1]: This and other `.password` files are text files containing the password for the corresponding store.\n \n- [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `controller.zk.*` properties.\n+ [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side \n+ TLS configuration properties via the `controller.zk.*` properties.\n \n  [3]: This configuration property is required when using the default Password Auth Handler only.\n \n **Segment Store**\n \n-Segment store supports configuration via a properties file (`config.properties`) or JVM system properties. The table below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+Segment store supports security configuration via a properties file (`config.properties`) or JVM system properties. The table \n+below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to\n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMTI3Mw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557821273", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2021-01-15T02:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcyMTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MDIyNA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557740224", "bodyText": "\"via the pravegaservice.zk.* properties.\" -> \"via these properties.\"", "author": "derekm", "createdAt": "2021-01-14T22:29:55Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |\n+ | `controller.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `controller.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `controller.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `controller.security.auth.enable` | `true` |\n+ | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | `/etc/secrets/password-auth-handler.database` |\n+ | `controller.security.auth.delegationToken.signingKey.basis` | `a-secret-value` |\n \n  [1]: This and other `.password` files are text files containing the password for the corresponding store.\n \n- [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `controller.zk.*` properties.\n+ [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side \n+ TLS configuration properties via the `controller.zk.*` properties.\n \n  [3]: This configuration property is required when using the default Password Auth Handler only.\n \n **Segment Store**\n \n-Segment store supports configuration via a properties file (`config.properties`) or JVM system properties. The table below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+Segment store supports security configuration via a properties file (`config.properties`) or JVM system properties. The table \n+below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to\n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `pravegaservice.security.tls.enable` | true |\n- | `pravegaservice.security.tls.server.certificate.location` | /etc/secrets/segmentstore01.pem |\n- | `pravegaservice.security.tls.server.privateKey.location` | /etc/secrets/segmentstore01.key.pem |\n- | `pravegaservice.zk.connect.security.enable` | false <sup>2</sup> |\n- | `pravegaservice.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `autoScale.controller.connect.security.tls.enable` | true |\n- | `autoScale.controller.connect.security.tls.truststore.location` | /etc/secrets/segmentstore01.key.pem |\n- | `autoScale.controller.connect.security.auth.enable` | true |\n- | `autoScale.security.auth.token.signingKey.basis` | a-secret-value <sup>1</sup>|\n- | `autoScale.controller.connect.security.tls.validateHostName.enable` | true |\n-\n-[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `pravegaservice.zk.*` properties.\n+ | `pravegaservice.security.tls.enable` | `true` |\n+ | `pravegaservice.security.tls.server.certificate.location` | `/etc/secrets/segmentstore01-server-cert.crt` |\n+ | `pravegaservice.security.tls.certificate.autoReload.enable` | `false` |\n+ | `pravegaservice.security.tls.server.privateKey.location` | `/etc/secrets/segmentstore01-server-key.key` |\n+ | `pravegaservice.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `pravegaservice.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `autoScale.controller.connect.security.tls.enable` | `true` |\n+ | `autoScale.controller.connect.security.tls.truststore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `autoScale.controller.connect.security.auth.enable` | `true` |\n+ | `autoScale.security.auth.token.signingKey.basis` | `a-secret-value` <sup>1</sup>|\n+ | `autoScale.controller.connect.security.tls.validateHostName.enable` | `true` |\n+ | `pravega.client.auth.loadDynamic` | `false` |\n+ | `pravega.client.auth.method` | `Basic` |\n+ | `pravega.client.auth.token` | Base64-encoded value of 'username:password' string | \n+\n+[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS \n+configuration properties via the `pravegaservice.zk.*` properties.", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMTM0Mw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557821343", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2021-01-15T02:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MDIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MDM2Mw==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557740363", "bodyText": "Above 3 lines should be <sup>1</sup>", "author": "derekm", "createdAt": "2021-01-14T22:30:15Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |\n+ | `controller.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `controller.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `controller.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `controller.security.auth.enable` | `true` |\n+ | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | `/etc/secrets/password-auth-handler.database` |\n+ | `controller.security.auth.delegationToken.signingKey.basis` | `a-secret-value` |\n \n  [1]: This and other `.password` files are text files containing the password for the corresponding store.\n \n- [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `controller.zk.*` properties.\n+ [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side \n+ TLS configuration properties via the `controller.zk.*` properties.\n \n  [3]: This configuration property is required when using the default Password Auth Handler only.\n \n **Segment Store**\n \n-Segment store supports configuration via a properties file (`config.properties`) or JVM system properties. The table below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+Segment store supports security configuration via a properties file (`config.properties`) or JVM system properties. The table \n+below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to\n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `pravegaservice.security.tls.enable` | true |\n- | `pravegaservice.security.tls.server.certificate.location` | /etc/secrets/segmentstore01.pem |\n- | `pravegaservice.security.tls.server.privateKey.location` | /etc/secrets/segmentstore01.key.pem |\n- | `pravegaservice.zk.connect.security.enable` | false <sup>2</sup> |\n- | `pravegaservice.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `autoScale.controller.connect.security.tls.enable` | true |\n- | `autoScale.controller.connect.security.tls.truststore.location` | /etc/secrets/segmentstore01.key.pem |\n- | `autoScale.controller.connect.security.auth.enable` | true |\n- | `autoScale.security.auth.token.signingKey.basis` | a-secret-value <sup>1</sup>|\n- | `autoScale.controller.connect.security.tls.validateHostName.enable` | true |\n-\n-[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `pravegaservice.zk.*` properties.\n+ | `pravegaservice.security.tls.enable` | `true` |\n+ | `pravegaservice.security.tls.server.certificate.location` | `/etc/secrets/segmentstore01-server-cert.crt` |\n+ | `pravegaservice.security.tls.certificate.autoReload.enable` | `false` |\n+ | `pravegaservice.security.tls.server.privateKey.location` | `/etc/secrets/segmentstore01-server-key.key` |\n+ | `pravegaservice.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `pravegaservice.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMTM3MA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557821370", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2021-01-15T02:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MDM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MDU4NQ==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557740585", "bodyText": "should be <sub>2</sub>", "author": "derekm", "createdAt": "2021-01-14T22:30:34Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |\n+ | `controller.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `controller.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `controller.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `controller.security.auth.enable` | `true` |\n+ | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | `/etc/secrets/password-auth-handler.database` |\n+ | `controller.security.auth.delegationToken.signingKey.basis` | `a-secret-value` |\n \n  [1]: This and other `.password` files are text files containing the password for the corresponding store.\n \n- [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `controller.zk.*` properties.\n+ [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side \n+ TLS configuration properties via the `controller.zk.*` properties.\n \n  [3]: This configuration property is required when using the default Password Auth Handler only.\n \n **Segment Store**\n \n-Segment store supports configuration via a properties file (`config.properties`) or JVM system properties. The table below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+Segment store supports security configuration via a properties file (`config.properties`) or JVM system properties. The table \n+below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to\n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `pravegaservice.security.tls.enable` | true |\n- | `pravegaservice.security.tls.server.certificate.location` | /etc/secrets/segmentstore01.pem |\n- | `pravegaservice.security.tls.server.privateKey.location` | /etc/secrets/segmentstore01.key.pem |\n- | `pravegaservice.zk.connect.security.enable` | false <sup>2</sup> |\n- | `pravegaservice.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `autoScale.controller.connect.security.tls.enable` | true |\n- | `autoScale.controller.connect.security.tls.truststore.location` | /etc/secrets/segmentstore01.key.pem |\n- | `autoScale.controller.connect.security.auth.enable` | true |\n- | `autoScale.security.auth.token.signingKey.basis` | a-secret-value <sup>1</sup>|\n- | `autoScale.controller.connect.security.tls.validateHostName.enable` | true |\n-\n-[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `pravegaservice.zk.*` properties.\n+ | `pravegaservice.security.tls.enable` | `true` |\n+ | `pravegaservice.security.tls.server.certificate.location` | `/etc/secrets/segmentstore01-server-cert.crt` |\n+ | `pravegaservice.security.tls.certificate.autoReload.enable` | `false` |\n+ | `pravegaservice.security.tls.server.privateKey.location` | `/etc/secrets/segmentstore01-server-key.key` |\n+ | `pravegaservice.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `pravegaservice.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `autoScale.controller.connect.security.tls.enable` | `true` |\n+ | `autoScale.controller.connect.security.tls.truststore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `autoScale.controller.connect.security.auth.enable` | `true` |\n+ | `autoScale.security.auth.token.signingKey.basis` | `a-secret-value` <sup>1</sup>|", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMTQwNA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557821404", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2021-01-15T02:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MDU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1MjUzNA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557752534", "bodyText": "make it more obvious that marketinganaylticsapp is the username... I had to look up that this is DefaultCredentials(password, username).", "author": "derekm", "createdAt": "2021-01-14T22:57:05Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |\n+ | `controller.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `controller.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `controller.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `controller.security.auth.enable` | `true` |\n+ | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | `/etc/secrets/password-auth-handler.database` |\n+ | `controller.security.auth.delegationToken.signingKey.basis` | `a-secret-value` |\n \n  [1]: This and other `.password` files are text files containing the password for the corresponding store.\n \n- [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `controller.zk.*` properties.\n+ [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side \n+ TLS configuration properties via the `controller.zk.*` properties.\n \n  [3]: This configuration property is required when using the default Password Auth Handler only.\n \n **Segment Store**\n \n-Segment store supports configuration via a properties file (`config.properties`) or JVM system properties. The table below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+Segment store supports security configuration via a properties file (`config.properties`) or JVM system properties. The table \n+below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to\n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `pravegaservice.security.tls.enable` | true |\n- | `pravegaservice.security.tls.server.certificate.location` | /etc/secrets/segmentstore01.pem |\n- | `pravegaservice.security.tls.server.privateKey.location` | /etc/secrets/segmentstore01.key.pem |\n- | `pravegaservice.zk.connect.security.enable` | false <sup>2</sup> |\n- | `pravegaservice.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `autoScale.controller.connect.security.tls.enable` | true |\n- | `autoScale.controller.connect.security.tls.truststore.location` | /etc/secrets/segmentstore01.key.pem |\n- | `autoScale.controller.connect.security.auth.enable` | true |\n- | `autoScale.security.auth.token.signingKey.basis` | a-secret-value <sup>1</sup>|\n- | `autoScale.controller.connect.security.tls.validateHostName.enable` | true |\n-\n-[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `pravegaservice.zk.*` properties.\n+ | `pravegaservice.security.tls.enable` | `true` |\n+ | `pravegaservice.security.tls.server.certificate.location` | `/etc/secrets/segmentstore01-server-cert.crt` |\n+ | `pravegaservice.security.tls.certificate.autoReload.enable` | `false` |\n+ | `pravegaservice.security.tls.server.privateKey.location` | `/etc/secrets/segmentstore01-server-key.key` |\n+ | `pravegaservice.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `pravegaservice.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `autoScale.controller.connect.security.tls.enable` | `true` |\n+ | `autoScale.controller.connect.security.tls.truststore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `autoScale.controller.connect.security.auth.enable` | `true` |\n+ | `autoScale.security.auth.token.signingKey.basis` | `a-secret-value` <sup>1</sup>|\n+ | `autoScale.controller.connect.security.tls.validateHostName.enable` | `true` |\n+ | `pravega.client.auth.loadDynamic` | `false` |\n+ | `pravega.client.auth.method` | `Basic` |\n+ | `pravega.client.auth.token` | Base64-encoded value of 'username:password' string | \n+\n+[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS \n+configuration properties via the `pravegaservice.zk.*` properties.\n \n [2]: The secret value you use here must match the same value used for other Controller and Segment Store services.\n \n ### Configuring TLS and Credentials on Client Side\n \n-After enabling and configuring TLS and auth on the server-side services, its time to update the clients,\n-so that the they can establish TLS connections with the servers and are allowed access.\n-\n-For TLS, establish trust for the servers' certificates on the client side using one of the following ways:\n+After enabling and configuring TLS and auth on the server-side services, it's time for the clients' setup.\n \n-  1. Supply the client library with the certificate of the trusted CA that has signed the servers' certificates.\n+Clients can be made to trust the server's certificates signed by custom CA's using one of the following ways:\n \n-     ```\n+  1. Configure the client application to use the signing CA's certificate as the truststore. Alternatively, use the \n+     servers' certificate as the truststore. \n+     \n+     ```java\n      ClientConfig clientConfig = ClientConfig.builder()\n-                .controllerURI(\"tls://<DNS-NAME-OR-IP>:9090\")\n-                .trustStore(\"/etc/secrets/ca-cert\")\n+                .controllerURI(\"tls://<dns-name-or-ip>:9090\")\n+                .trustStore(\"/etc/secrets/ca-cert.crt\")\n                 ...\n                 .build();\n      ```\n-\n-  2. Install the CA's certificate in the Java system key store.\n+  2. Install the CA's certificate in the Java system key store. \n   3. Create a custom truststore with the CA's certificate and supply it to the Pravega client application,\n-   via JVM system properties `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`.\n+     via standard JVM system properties `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`.\n \n For auth, client-side configuration depends on the `AuthHandler` implementation used. If your server is configured to\n-use the default `PasswordAuthHandler`, you may supply the credentials as shown below.\n+use the built-in Password Auth Handler that supports \"Basic\" authentication, you may supply the credentials as shown below.\n \n-  ```\n+  ```java\n   ClientConfig clientConfig = ClientConfig.builder()\n-                .controllerURI(\"tls://<DNS-NAME-OR-IP>:9090\")\n-                .trustStore(\"/etc/secrets/ca-cert\")\n+                .controllerURI(\"tls://<dns-name-or-ip>:9090\")\n+                .trustStore(\"/etc/secrets/ca-cert.crt\")\n                 .credentials(new DefaultCredentials(\"changeit\", \"marketinganaylticsapp\"))", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMTc2Mg==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557821762", "bodyText": "Sure, I have changed them to <password> and <username> now, which should make the order of the two arguments more explicit. Thanks for your meticulous review!", "author": "ravisharda", "createdAt": "2021-01-15T02:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1MjUzNA=="}], "type": "inlineReview"}, {"oid": "7ffa5d59f9e099078d90c53ebdc9571fe62f2a77", "url": "https://github.com/pravega/pravega/commit/7ffa5d59f9e099078d90c53ebdc9571fe62f2a77", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-15T01:52:07Z", "type": "commit"}, {"oid": "97891e7414016dfe4811015656464948551af535", "url": "https://github.com/pravega/pravega/commit/97891e7414016dfe4811015656464948551af535", "message": "Merge remote-tracking branch 'origin/update-tls-material-doc' into update-tls-material-doc", "committedDate": "2021-01-15T01:52:49Z", "type": "commit"}, {"oid": "c17001164296681f3f8730fe321861581c1453ee", "url": "https://github.com/pravega/pravega/commit/c17001164296681f3f8730fe321861581c1453ee", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-15T02:10:39Z", "type": "commit"}, {"oid": "da41bd8f00f652a0f06a23ee6afca5e281232c3b", "url": "https://github.com/pravega/pravega/commit/da41bd8f00f652a0f06a23ee6afca5e281232c3b", "message": "Address review comments\n\nSigned-off-by: rsharda <ravi.sharda@emc.com>", "committedDate": "2021-01-15T02:18:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzg3MjAwOA==", "url": "https://github.com/pravega/pravega/pull/5452#discussion_r557872008", "bodyText": "\"reusing preexisting certificate\" -> \"reusing a preexisting certificate\"", "author": "derekm", "createdAt": "2021-01-15T05:34:25Z", "path": "documentation/src/docs/security/securing-distributed-mode-cluster.md", "diffHunk": "@@ -310,106 +103,134 @@ Controller services can be configured in three different ways:\n       ...          \n    ```\n \n-The following table lists the Controller's TLS and auth parameters and representative values, for quick reference. For a detailed description of these parameters, refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+The following table lists the Controller service's TLS and auth parameters as well as samples values, for quick reference. \n+For a detailed description of these parameters, refer to \n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `controller.security.tls.enable` | true |\n- | `controller.security.tls.server.certificate.location` | /etc/secrets/controller01.pem |\n- | `controller.security.tls.server.privateKey.location` | /etc/secrets/controller01.key.pem |\n- | `controller.security.tls.trustStore.location` | /etc/secrets/ca-cert |\n- | `controller.security.tls.server.keyStore.location` | /etc/secrets/controller01.server.jks |\n- | `controller.security.tls.server.keyStore.pwd.location` | /etc/secrets/controller01.server.jks.password <sup>1</sup> |\n- | `controller.zk.connect.security.enable` | false <sup>2</sup> |\n- | `controller.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `controller.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `controller.security.auth.enable` | true |\n- | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | /etc/secrets/password-auth-handler.inputfile |\n- | `controller.security.auth.delegationToken.signingKey.basis | a-secret-value |\n+ | `controller.security.tls.enable` | `true` |\n+ | `controller.security.tls.server.certificate.location` | `/etc/secrets/controller01-server-cert.crt` |\n+ | `controller.security.tls.server.privateKey.location` | `/etc/secrets/controller01-server-key.key` |\n+ | `controller.security.tls.trustStore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `controller.security.tls.server.keyStore.location` | `/etc/secrets/controller01-server.keystore.jks` |\n+ | `controller.security.tls.server.keyStore.pwd.location` | `/etc/secrets/controller01-server.keystore.jks.password` <sup>1</sup> |\n+ | `controller.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `controller.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `controller.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `controller.security.auth.enable` | `true` |\n+ | `controller.security.pwdAuthHandler.accountsDb.location` <sup>3</sup> | `/etc/secrets/password-auth-handler.database` |\n+ | `controller.security.auth.delegationToken.signingKey.basis` | `a-secret-value` |\n \n  [1]: This and other `.password` files are text files containing the password for the corresponding store.\n \n- [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `controller.zk.*` properties.\n+ [2]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side \n+ TLS configuration properties via the `controller.zk.*` properties.\n \n  [3]: This configuration property is required when using the default Password Auth Handler only.\n \n **Segment Store**\n \n-Segment store supports configuration via a properties file (`config.properties`) or JVM system properties. The table below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to [this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n+Segment store supports security configuration via a properties file (`config.properties`) or JVM system properties. The table \n+below lists its TLS and auth parameters and sample values. For a detailed discription of these parameters refer to\n+[this](https://github.com/pravega/pravega/blob/master/documentation/src/docs/security/pravega-security-configurations.md) document.\n \n  | Configuration Parameter| Example Value |\n  |:-----------------------:|:-------------|\n- | `pravegaservice.security.tls.enable` | true |\n- | `pravegaservice.security.tls.server.certificate.location` | /etc/secrets/segmentstore01.pem |\n- | `pravegaservice.security.tls.server.privateKey.location` | /etc/secrets/segmentstore01.key.pem |\n- | `pravegaservice.zk.connect.security.enable` | false <sup>2</sup> |\n- | `pravegaservice.zk.connect.security.tls.trustStore.location` | /etc/secrets/client.truststore.jks |\n- | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | /etc/secrets/client.truststore.jks.password |\n- | `autoScale.controller.connect.security.tls.enable` | true |\n- | `autoScale.controller.connect.security.tls.truststore.location` | /etc/secrets/segmentstore01.key.pem |\n- | `autoScale.controller.connect.security.auth.enable` | true |\n- | `autoScale.security.auth.token.signingKey.basis` | a-secret-value <sup>1</sup>|\n- | `autoScale.controller.connect.security.tls.validateHostName.enable` | true |\n-\n-[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS configuration properties via the `pravegaservice.zk.*` properties.\n+ | `pravegaservice.security.tls.enable` | `true` |\n+ | `pravegaservice.security.tls.server.certificate.location` | `/etc/secrets/segmentstore01-server-cert.crt` |\n+ | `pravegaservice.security.tls.certificate.autoReload.enable` | `false` |\n+ | `pravegaservice.security.tls.server.privateKey.location` | `/etc/secrets/segmentstore01-server-key.key` |\n+ | `pravegaservice.zk.connect.security.enable` | `false` <sup>2</sup> |\n+ | `pravegaservice.zk.connect.security.tls.trustStore.location` | Unspecified <sup>2</sup>|\n+ | `pravegaservice.zk.connect.security.tls.trustStore.pwd.location` | Unspecified <sup>2</sup>|\n+ | `autoScale.controller.connect.security.tls.enable` | `true` |\n+ | `autoScale.controller.connect.security.tls.truststore.location` | `/etc/secrets/ca-cert.crt` |\n+ | `autoScale.controller.connect.security.auth.enable` | `true` |\n+ | `autoScale.security.auth.token.signingKey.basis` | `a-secret-value` <sup>1</sup>|\n+ | `autoScale.controller.connect.security.tls.validateHostName.enable` | `true` |\n+ | `pravega.client.auth.loadDynamic` | `false` |\n+ | `pravega.client.auth.method` | `Basic` |\n+ | `pravega.client.auth.token` | Base64-encoded value of 'username:password' string | \n+\n+[1]: It is assumed here that Zookeeper TLS is disabled. You may enable it and specify the corresponding client-side TLS \n+configuration properties via the `pravegaservice.zk.*` properties.\n \n [2]: The secret value you use here must match the same value used for other Controller and Segment Store services.\n \n ### Configuring TLS and Credentials on Client Side\n \n-After enabling and configuring TLS and auth on the server-side services, its time to update the clients,\n-so that the they can establish TLS connections with the servers and are allowed access.\n-\n-For TLS, establish trust for the servers' certificates on the client side using one of the following ways:\n+After enabling and configuring TLS and auth on the server-side services, it's time for the clients' setup.\n \n-  1. Supply the client library with the certificate of the trusted CA that has signed the servers' certificates.\n+Clients can be made to trust the server's certificates signed by custom CA's using one of the following ways:\n \n-     ```\n+  1. Configure the client application to use the signing CA's certificate as the truststore. Alternatively, use the \n+     servers' certificate as the truststore. \n+     \n+     ```java\n      ClientConfig clientConfig = ClientConfig.builder()\n-                .controllerURI(\"tls://<DNS-NAME-OR-IP>:9090\")\n-                .trustStore(\"/etc/secrets/ca-cert\")\n+                .controllerURI(\"tls://<dns-name-or-ip>:9090\")\n+                .trustStore(\"/etc/secrets/ca-cert.crt\")\n                 ...\n                 .build();\n      ```\n-\n-  2. Install the CA's certificate in the Java system key store.\n+  2. Install the CA's certificate in the Java system key store. \n   3. Create a custom truststore with the CA's certificate and supply it to the Pravega client application,\n-   via JVM system properties `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`.\n+     via standard JVM system properties `javax.net.ssl.trustStore` and `javax.net.ssl.trustStorePassword`.\n \n For auth, client-side configuration depends on the `AuthHandler` implementation used. If your server is configured to\n-use the default `PasswordAuthHandler`, you may supply the credentials as shown below.\n+use the built-in Password Auth Handler that supports \"Basic\" authentication, you may supply the credentials as shown below.\n \n-  ```\n+  ```java\n   ClientConfig clientConfig = ClientConfig.builder()\n-                .controllerURI(\"tls://<DNS-NAME-OR-IP>:9090\")\n-                .trustStore(\"/etc/secrets/ca-cert\")\n+                .controllerURI(\"tls://<dns-name-or-ip>:9090\")\n+                .trustStore(\"/etc/secrets/ca-cert.crt\")\n                 .credentials(new DefaultCredentials(\"changeit\", \"marketinganaylticsapp\"))\n                 .build();\n   ```\n \n #### Server Hostname Verification\n \n-Hostname verification during TLS communications verifies that the DNS name to which the client connects matches the hostname specified in either of the following fields in the server's certificate:\n+For client's server hostname verification to succeed during TLS handshake, the hostname/IP address it uses for accessing the\n+server must match one of the following in the server's certificate:\n \n * Common Name (`CN`) in the certificate's `Subject` field\n-* One of the `Subject Alternative Names` field entries\n+* One of the `Subject Alternative Names` (SAN) field entries\n \n-If the server certificates have a hostname assigned, you have used IP addresses as endpoints for the services, and those hostnames are not accessible from\n-the client nodes, you might need to add mappings of\n-IP addresses and DNS/Host names in the client-side operating system hosts file.\n+Even if the server listens on the loopback address `127.0.0.1` and its certificate is assigned to `localhost`, hostname \n+verification will fail if the client attempts to access the server via `127.0.0.1`. For the verification to pass, \n+the client must access the server using the hostname assigned on the certificate `localhost` and have a hosts file entry \n+that maps `localhost` to `127.0.0.1` (which is usually already there). \n \n-Alternatively, you may disable hostname verification by invoking `validateHostName(false)` of the ClientConfig builder. It is strongly recommended to avoid disabling hostname verification for production clusters.\n+Similarly, if the server certificate is assigned to a non-routable hostname on the network (say, `controller01.pravega.io`),\n+you might need to add an IP address and DNS/host name mapping in the client's operating system hosts file. \n \n-### Having TLS and Auth Take Effect\n+```\n+10.243.221.34 controller01.pravega.io\n+```\n+\n+If you are reusing preexisting certificate for development/testing on new hosts, you might need to disable hostname ", "originalCommit": "82d3315eb85f424d00d6aa8f964ec5b3763f1644", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6b7a2f261b35f1c39fc3e5e35873664de6bb95d6", "url": "https://github.com/pravega/pravega/commit/6b7a2f261b35f1c39fc3e5e35873664de6bb95d6", "message": "Merge branch 'master' into update-tls-material-doc", "committedDate": "2021-01-15T08:15:49Z", "type": "commit"}]}