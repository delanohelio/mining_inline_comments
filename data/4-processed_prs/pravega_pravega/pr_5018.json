{"pr_number": 5018, "pr_title": "Issue 5009: (SegmentStore) Fixed Segment Attribute Index Truncated Root Pointer", "pr_createdAt": "2020-08-03T16:45:26Z", "pr_url": "https://github.com/pravega/pravega/pull/5018", "timeline": [{"oid": "aad3d0d664f148e5f5da0313a608515e020ebbe2", "url": "https://github.com/pravega/pravega/commit/aad3d0d664f148e5f5da0313a608515e020ebbe2", "message": "Fixed a bug in SegmentAttributeBTreeIndex where it would attempt to initialize the BTreeIndex from a truncated offset.\n\nAdded logback-test.xml for Segment Store Integration tests. This helps debugging.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-03T16:43:22Z", "type": "commit"}, {"oid": "45ce2ebab10ebb12df081ed796169c92bca7e31c", "url": "https://github.com/pravega/pravega/commit/45ce2ebab10ebb12df081ed796169c92bca7e31c", "message": "Reverted unintentional formatting change.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-03T16:47:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1MTE1Nw==", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464551157", "bodyText": "Shall we add something like 'this is usually not a problem' ?\nIf this is not a problem then probably we could log it at info  level", "author": "eolivelli", "createdAt": "2020-08-03T17:19:42Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -466,7 +466,20 @@ private long deserializeValue(ByteArraySegment value) {\n \n         return this.storage.getStreamSegmentInfo(handle.getSegmentName(), timeout)\n                 .thenApply(segmentInfo -> {\n+                    // Get the root pointer from the Segment's Core Attributes.\n                     long rootPointer = this.segmentMetadata.getAttributes().getOrDefault(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, BTreeIndex.IndexInfo.EMPTY.getRootPointer());\n+                    if (rootPointer != BTreeIndex.IndexInfo.EMPTY.getRootPointer() && rootPointer < segmentInfo.getStartOffset()) {\n+                        // The Root Pointer is invalid as it points to an offset prior to the Attribute Segment's Start Offset.\n+                        // The Attribute Segment is updated in 3 sequential steps: 1) Write new BTree pages, 2) Truncate and\n+                        // 3) Update root Pointer.\n+                        // The purpose of the Root Pointer is to provide a location of a consistently written update in case\n+                        // step 1) above fails (it is not atomic). However, if both 1) and 2) complete but 3) doesn't, then\n+                        // it's possible that the existing Root Pointer has been truncated out. In this case, it should be\n+                        // safe to ignore it and let the BTreeIndex read the file from the end (as it does in this case).\n+                        log.warn(\"{}: Root Pointer ({}) is below Attribute Segment's StartOffset ({}). Ignoring.\", this.traceObjectId, rootPointer, segmentInfo.getStartOffset());", "originalCommit": "45ce2ebab10ebb12df081ed796169c92bca7e31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTY5MQ==", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464555691", "bodyText": "Good point. Making it info.", "author": "andreipaduroiu", "createdAt": "2020-08-03T17:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1MTE1Nw=="}], "type": "inlineReview"}, {"oid": "489ffaf03bb488787d7fd6f1839737adbe90dc74", "url": "https://github.com/pravega/pravega/commit/489ffaf03bb488787d7fd6f1839737adbe90dc74", "message": "Code review feedback. Added comments and reduced the logging message severity.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-03T17:29:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0MjQ1OA==", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464542458", "bodyText": "Nit:  The new name is now - ChunkedSegmentStorage", "author": "sachin-j-joshi", "createdAt": "2020-08-03T17:03:00Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "diffHunk": "@@ -771,13 +837,39 @@ public void close() {\n \n         private class TestStorage extends AsyncStorageWrapper {\n             private final SyncStorage wrappedStorage;\n+            private final Map<String, Long> startOffsets;\n             private WriteInterceptor writeInterceptor;\n             private SealInterceptor sealInterceptor;\n             private ReadInterceptor readInterceptor;\n \n             TestStorage(SyncStorage syncStorage, Executor executor) {\n                 super(syncStorage, executor);\n                 this.wrappedStorage = syncStorage;\n+                this.startOffsets = new ConcurrentHashMap<>();\n+            }\n+\n+            @Override\n+            public CompletableFuture<Void> truncate(SegmentHandle handle, long offset, Duration timeout) {\n+                // We need to simulate the ChunkStorageProvider (correct) behavior for truncating segments. While the", "originalCommit": "45ce2ebab10ebb12df081ed796169c92bca7e31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MzY0Mw==", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464573643", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-08-03T17:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0MjQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTg3OA==", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464555878", "bodyText": "A comment explaining how root pointer is always set to a previous value to simulate scenario and where truncation happens would be helpful.", "author": "sachin-j-joshi", "createdAt": "2020-08-03T17:28:44Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "diffHunk": "@@ -627,6 +631,68 @@ public void testRecoveryAfterIncompleteUpdate() {\n         checkIndex(idx2, expectedValues);\n     }\n \n+    /**\n+     * Tests the ability of the Attribute Index to recover correctly after an update has been successfully written to Storage,\n+     * but the previous value of the {@link Attributes#ATTRIBUTE_SEGMENT_ROOT_POINTER} has been truncated out without\n+     * having the new value persisted (most likely due to a system crash).\n+     * In this case, the {@link Attributes#ATTRIBUTE_SEGMENT_ROOT_POINTER} value should be ignored and the index should\n+     * be attempted to be read from Storage without providing hints to where to start reading from.\n+     */\n+    @Test\n+    public void testTruncatedRootPointer() {\n+        val attributeSegmentName = NameUtils.getAttributeSegmentName(SEGMENT_NAME);\n+        val config = AttributeIndexConfig\n+                .builder()\n+                .with(AttributeIndexConfig.MAX_INDEX_PAGE_SIZE, 1024)\n+                .with(AttributeIndexConfig.ATTRIBUTE_SEGMENT_ROLLING_SIZE, 8)\n+                .build();\n+        final int attributeCount = 20;\n+        val attributes = IntStream.range(0, attributeCount).mapToObj(i -> new UUID(i, i)).collect(Collectors.toList());\n+        @Cleanup\n+        val context = new TestContext(config);\n+        populateSegments(context);\n+\n+        // 1. Populate and verify first index.\n+        val expectedValues = new HashMap<UUID, Long>();\n+        long nextValue = 0;\n+        long previousRootPointer = -1;\n+        boolean invalidRootPointer = false;\n+        for (UUID attributeId : attributes) {\n+            val idx = context.index.forSegment(SEGMENT_ID, TIMEOUT).join();\n+\n+            val value = nextValue++;\n+            expectedValues.put(attributeId, value);\n+            val updateBatch = Collections.singletonMap(attributeId, value);\n+\n+            val rootPointer = idx.update(updateBatch, TIMEOUT).join();\n+            val startOffset = context.storage.getStreamSegmentInfo(attributeSegmentName, TIMEOUT).join().getStartOffset();\n+            if (previousRootPointer >= 0) {\n+                context.containerMetadata.getStreamSegmentMetadata(SEGMENT_ID)\n+                        .updateAttributes(Collections.singletonMap(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, previousRootPointer));\n+                invalidRootPointer |= previousRootPointer < startOffset;", "originalCommit": "45ce2ebab10ebb12df081ed796169c92bca7e31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NzU5OQ==", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464557599", "bodyText": "Thanks for adding comment.", "author": "sachin-j-joshi", "createdAt": "2020-08-03T17:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTg3OA=="}], "type": "inlineReview"}, {"oid": "1229aad00c44e6ec18461b17192c5019465e8bd3", "url": "https://github.com/pravega/pravega/commit/1229aad00c44e6ec18461b17192c5019465e8bd3", "message": "ChunkStorageProvider -> ChunkedSegmentStorage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-03T17:57:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTIwNg==", "url": "https://github.com/pravega/pravega/pull/5018#discussion_r464581206", "bodyText": "ChunkStorageProvide  ->  ChunkedSegmentStorage", "author": "sachin-j-joshi", "createdAt": "2020-08-03T18:12:53Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/attributes/AttributeIndexTests.java", "diffHunk": "@@ -771,13 +841,39 @@ public void close() {\n \n         private class TestStorage extends AsyncStorageWrapper {\n             private final SyncStorage wrappedStorage;\n+            private final Map<String, Long> startOffsets;\n             private WriteInterceptor writeInterceptor;\n             private SealInterceptor sealInterceptor;\n             private ReadInterceptor readInterceptor;\n \n             TestStorage(SyncStorage syncStorage, Executor executor) {\n                 super(syncStorage, executor);\n                 this.wrappedStorage = syncStorage;\n+                this.startOffsets = new ConcurrentHashMap<>();\n+            }\n+\n+            @Override\n+            public CompletableFuture<Void> truncate(SegmentHandle handle, long offset, Duration timeout) {\n+                // We need to simulate the ChunkedSegmentStorage (correct) behavior for truncating segments. While the\n+                // legacy RollingStorage would approximate a StartOffset to an offset at most equal to the requested\n+                // Truncation Offset, the ChunkedSegmentStorage is very strict about that, so it will deny any read prior\n+                // to that offset. In addition, the ChunkStorageProvide also returns the correct StartOffset as part of", "originalCommit": "1229aad00c44e6ec18461b17192c5019465e8bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c290e0bcbc81ec17ae5ed26b1dd87d878de5a22", "url": "https://github.com/pravega/pravega/commit/1c290e0bcbc81ec17ae5ed26b1dd87d878de5a22", "message": "ChunkStorageProvider -> ChunkedSegmentStorage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-03T19:51:04Z", "type": "commit"}]}