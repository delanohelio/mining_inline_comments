{"pr_number": 4950, "pr_title": "Issue 4751: ListScopes, CheckStreamExists and CheckScopeExists", "pr_createdAt": "2020-07-17T15:37:37Z", "pr_url": "https://github.com/pravega/pravega/pull/4950", "timeline": [{"oid": "dce823a9ab8367f5f9595da0beb439d5f5d52bdd", "url": "https://github.com/pravega/pravega/commit/dce823a9ab8367f5f9595da0beb439d5f5d52bdd", "message": "Implementation\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-17T12:16:13Z", "type": "commit"}, {"oid": "6ca4c8560822743ce5217f297144963e4a054ca3", "url": "https://github.com/pravega/pravega/commit/6ca4c8560822743ce5217f297144963e4a054ca3", "message": "unit test\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-17T13:43:56Z", "type": "commit"}, {"oid": "93339a95d0d095851b81fe50e49c04bac09173dc", "url": "https://github.com/pravega/pravega/commit/93339a95d0d095851b81fe50e49c04bac09173dc", "message": "merging with master\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-17T13:51:33Z", "type": "commit"}, {"oid": "5306bfb7f97753df7e0ec46b2f9aa230eb260234", "url": "https://github.com/pravega/pravega/commit/5306bfb7f97753df7e0ec46b2f9aa230eb260234", "message": "Merge with master\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-17T15:11:43Z", "type": "commit"}, {"oid": "eb62dbf7275bb70cf9d71ef06b2e4a33dcab2144", "url": "https://github.com/pravega/pravega/commit/eb62dbf7275bb70cf9d71ef06b2e4a33dcab2144", "message": "Unit tests\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-17T15:30:58Z", "type": "commit"}, {"oid": "aee3d78651a5d13535e9feb6428f486f892edb75", "url": "https://github.com/pravega/pravega/commit/aee3d78651a5d13535e9feb6428f486f892edb75", "message": "test fix\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-17T16:32:23Z", "type": "commit"}, {"oid": "e44b329f027cce0f8711c46c44e689c3a4cd023c", "url": "https://github.com/pravega/pravega/commit/e44b329f027cce0f8711c46c44e689c3a4cd023c", "message": "unit test for local cotroller\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-18T01:39:03Z", "type": "commit"}, {"oid": "7147c43c8c74f4b13447fe486b37809003e99035", "url": "https://github.com/pravega/pravega/commit/7147c43c8c74f4b13447fe486b37809003e99035", "message": "checkstyle\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-20T03:34:47Z", "type": "commit"}, {"oid": "325239deea684d9614d690a1b3cfeeaeb50b2822", "url": "https://github.com/pravega/pravega/commit/325239deea684d9614d690a1b3cfeeaeb50b2822", "message": "Merge branch 'master' into issue4751", "committedDate": "2020-07-20T03:35:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0Mzg1Mw==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457443853", "bodyText": "asyncIterator.asIterator() will do the same, but you won't need to explicitly use BlockingAsyncIterator. This will help in case we want to change the implementation later.", "author": "andreipaduroiu", "createdAt": "2020-07-20T14:34:40Z", "path": "client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java", "diffHunk": "@@ -107,13 +107,26 @@ public boolean deleteStream(String scopeName, String streamName) {\n         return  Futures.getThrowingException(controller.deleteStream(scopeName, streamName));\n     }\n \n+    @Override\n+    public Iterator<String> listScopes() {\n+        log.info(\"Listing scopes\");\n+        AsyncIterator<String> asyncIterator = controller.listScopes();\n+        return new BlockingAsyncIterator<>(asyncIterator);", "originalCommit": "325239deea684d9614d690a1b3cfeeaeb50b2822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0NzM1Mw==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457447353", "bodyText": "Why not use asyncIterator.asIterator?\nYour implementation below is incorrect. Both hasNext and next will invoke load which will cause the wrapped iterator to advance. This means you will be skipping over iterator items as you iterate through. Also next is supposed to throw if hasNext() == false", "author": "andreipaduroiu", "createdAt": "2020-07-20T14:38:14Z", "path": "client/src/test/java/io/pravega/client/stream/mock/MockStreamManager.java", "diffHunk": "@@ -181,6 +193,30 @@ public boolean deleteStream(String scopeName, String toDelete) {\n         return Futures.getAndHandleExceptions(controller.deleteStream(scopeName, toDelete), RuntimeException::new);\n     }\n \n+    @Override\n+    public Iterator<String> listScopes() {\n+        AsyncIterator<String> asyncIterator = controller.listScopes();", "originalCommit": "325239deea684d9614d690a1b3cfeeaeb50b2822", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyNDYyNQ==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457524625", "bodyText": "yes, but the load doesnt call asynciterator.getNext unless it has exhausted all existing entries.\nso wrapper iterator will only advance when its getNext gets called and if it returns items then hasNext returns true, false otherwise.", "author": "shiveshr", "createdAt": "2020-07-20T16:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0NzM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyNTE3NA==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457525174", "bodyText": "And next throws exception if you call next when hasNext may have written false.", "author": "shiveshr", "createdAt": "2020-07-20T16:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0NzM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2MTM4Ng==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457561386", "bodyText": "The point is that you are returning an Iterator object which does not conform to the Iterator contracts. If you want to implement a different behavior you will have to return something that does not implement java.util.Iterator.\nAs an example, consider what happens if someone invokes forEachRemaining on your Iterator. Check out the default implementation of that method - that is also the standard way of iterating through an iterator.", "author": "andreipaduroiu", "createdAt": "2020-07-20T17:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0NzM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc3OTc1NQ==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457779755", "bodyText": "i dont completely follow how the behaviour is different for BlockingAsyncIterator from the iterator contract.\nCan you please illustrate with an example.\nIt upholds following contracts (does not provide an implementation for remove method as that is unsupported for this iterator).\n\nif there are elements to iterate over, hasNext will return true.\nnext returns next element in the iteration \"without skipping over any element\".\n\nFollowing is the implementation for load method which is called from both hashNext and next which loads next and canHaveNext values into fields T next and boolean canHaveNext.\nthen hasNext simply returns canHaveNext and next returns next or throws if next is null (canHaveNext is false)\n    private void load() {\n        if (next == null && canHaveNext) {\n            next = asyncIterator.getNext().join();\n            if (next == null) {\n                canHaveNext = false;\n            }\n        }\n    }\n\nforEachRemaining would work correctly as it performs hasNext followed by next call in a loop.", "author": "shiveshr", "createdAt": "2020-07-21T01:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0NzM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4MTM3OA==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457781378", "bodyText": "Oh. My Bad.\nI didnt realize that this mock class also has an implementation and you were referring to that..\ni was talking about BlockingAsyncIterator.\nyes, that implementation in the mock is definitely incorrect. and since it can be used in multiple tests in different ways, i will use BlockingAsyncIterator here too.\nthanks", "author": "shiveshr", "createdAt": "2020-07-21T01:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0NzM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0ODU1MQ==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457448551", "bodyText": "use Futures.exceptionallyExpecting to make this a one-liner.", "author": "andreipaduroiu", "createdAt": "2020-07-20T14:39:30Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/LocalController.java", "diffHunk": "@@ -68,6 +70,45 @@ public LocalController(ControllerService controller, boolean authorizationEnable\n         this.authorizationEnabled = authorizationEnabled;\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> checkScopeExists(String scopeName) {\n+        return this.controller.getScope(scopeName)", "originalCommit": "325239deea684d9614d690a1b3cfeeaeb50b2822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0ODg5OQ==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r457448899", "bodyText": "Futures.exceptionallyExpecting", "author": "andreipaduroiu", "createdAt": "2020-07-20T14:39:50Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/LocalController.java", "diffHunk": "@@ -68,6 +70,45 @@ public LocalController(ControllerService controller, boolean authorizationEnable\n         this.authorizationEnabled = authorizationEnabled;\n     }\n \n+    @Override\n+    public CompletableFuture<Boolean> checkScopeExists(String scopeName) {\n+        return this.controller.getScope(scopeName)\n+                              .handle((r, e) -> {\n+                                  if (e != null) {\n+                                      if (Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException) {\n+                                          return false;\n+                                      } else {\n+                                          throw new CompletionException(e);\n+                                      }\n+                                  }\n+                                  return true;\n+                              });\n+    }\n+\n+    @Override\n+    public AsyncIterator<String> listScopes() {\n+        final Function<String, CompletableFuture<Map.Entry<String, Collection<String>>>> function = token ->\n+                controller.listScopes(token, PAGE_LIMIT)\n+                          .thenApply(result -> new AbstractMap.SimpleEntry<>(result.getValue(), result.getKey()));\n+\n+        return new ContinuationTokenAsyncIterator<>(function, \"\");\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> checkStreamExists(String scopeName, String streamName) {\n+        return this.controller.getStream(scopeName, streamName)", "originalCommit": "325239deea684d9614d690a1b3cfeeaeb50b2822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "286402c01e959a479bb995ed28f308ed153e04a6", "url": "https://github.com/pravega/pravega/commit/286402c01e959a479bb995ed28f308ed153e04a6", "message": "PR comment\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-21T01:32:30Z", "type": "commit"}, {"oid": "c16f248428c7c105980ecc391f1bd801ed693f3f", "url": "https://github.com/pravega/pravega/commit/c16f248428c7c105980ecc391f1bd801ed693f3f", "message": "Merge branch 'issue4751' of https://github.com/shiveshr/pravega-1 into issue4751", "committedDate": "2020-07-21T01:32:53Z", "type": "commit"}, {"oid": "f7723021acab9980f35f2d474b89e7261972596c", "url": "https://github.com/pravega/pravega/commit/f7723021acab9980f35f2d474b89e7261972596c", "message": "Merge branch 'master' into issue4751", "committedDate": "2020-07-21T14:41:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NTE1Ng==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r458545156", "bodyText": "should be scope", "author": "pbelgundi", "createdAt": "2020-07-22T05:35:49Z", "path": "controller/src/main/java/io/pravega/controller/store/stream/StreamMetadataStore.java", "diffHunk": "@@ -217,6 +217,18 @@\n      */\n     CompletableFuture<List<String>> listScopes();\n \n+    /**\n+     * List scopes with pagination. This api continues listing scopes from the supplied continuation token\n+     * and returns a count limited list of scopes and a new continuation token.\n+     *\n+     * @param continuationToken continuation token\n+     * @param limit limit on number of streams to return.", "originalCommit": "f7723021acab9980f35f2d474b89e7261972596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NTQ3Mw==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r458545473", "bodyText": "same here...", "author": "pbelgundi", "createdAt": "2020-07-22T05:36:49Z", "path": "controller/src/main/java/io/pravega/controller/store/stream/StreamMetadataStore.java", "diffHunk": "@@ -217,6 +217,18 @@\n      */\n     CompletableFuture<List<String>> listScopes();\n \n+    /**\n+     * List scopes with pagination. This api continues listing scopes from the supplied continuation token\n+     * and returns a count limited list of scopes and a new continuation token.\n+     *\n+     * @param continuationToken continuation token\n+     * @param limit limit on number of streams to return.\n+     * @param executor executor\n+     * @return A pair of list of streams in scope with the continuation token. ", "originalCommit": "f7723021acab9980f35f2d474b89e7261972596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjIwNw==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r458556207", "bodyText": "Can the auth filter out some scopes, causing us to return less number of scopes than limit?", "author": "pbelgundi", "createdAt": "2020-07-22T06:09:58Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -532,6 +532,126 @@ public void createScope(ScopeInfo request, StreamObserver<CreateScopeStatus> res\n                 responseObserver, requestTag);\n     }\n \n+    @Override\n+    public void listScopes(Controller.ScopesRequest request, StreamObserver<Controller.ScopesResponse> responseObserver) {\n+        RequestTag requestTag = requestTracker.initializeAndTrackRequestTag(requestIdGenerator.get(),\n+                \"listScopes\");\n+        log.info(requestTag.getRequestId(), \"listScope called.\");\n+\n+        final AuthContext ctx;\n+        if (this.grpcAuthHelper.isAuthEnabled()) {\n+            ctx = AuthContext.current();\n+        } else {\n+            ctx = null;\n+        }\n+\n+        Supplier<String> stringSupplier = () -> {\n+            String result = this.grpcAuthHelper.checkAuthorization(\n+                    AuthResourceRepresentation.ofScopes(),\n+                    AuthHandler.Permissions.READ,\n+                    ctx);\n+            log.debug(\"Result of authorization for [{}] and READ permission is: [{}]\",\n+                    AuthResourceRepresentation.ofScopes(), result);\n+            return result;\n+        };\n+        Function<String, CompletableFuture<Controller.ScopesResponse>> scopesFn = delegationToken -> controllerService\n+                .listScopes(request.getContinuationToken().getToken(), pageLimit)\n+                .thenApply(response -> {\n+                    log.debug(\"All scopes in scope with continuation token: {}\", response);\n+                    return Controller.ScopesResponse\n+                            .newBuilder().addAllScopes(response.getKey())\n+                            .setContinuationToken(Controller.ContinuationToken.newBuilder()\n+                                                                              .setToken(response.getValue()).build())\n+                            .build();\n+                });\n+        authenticateExecuteAndProcessResults(stringSupplier, scopesFn, responseObserver, requestTag);", "originalCommit": "f7723021acab9980f35f2d474b89e7261972596c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU2MTgyMw==", "url": "https://github.com/pravega/pravega/pull/4950#discussion_r458561823", "bodyText": "We could, but i kept the authorization part here consistent with the equivalent api in the REST which requires users to have READ permission on \"/\" to be able to invoke list scopes.\nIf we want a different approach for authorization, we should do it consistently on both interfaces.\nI have created a separate issue for the same here:\n#4955", "author": "shiveshr", "createdAt": "2020-07-22T06:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjIwNw=="}], "type": "inlineReview"}, {"oid": "f041f05d847cf0988de47309ed4dcaa050f54ae4", "url": "https://github.com/pravega/pravega/commit/f041f05d847cf0988de47309ed4dcaa050f54ae4", "message": "PR comments\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-22T06:25:52Z", "type": "commit"}, {"oid": "0d423f4efd1a8cc5f4bcf16cce0051377bbe9093", "url": "https://github.com/pravega/pravega/commit/0d423f4efd1a8cc5f4bcf16cce0051377bbe9093", "message": "Merge branch 'issue4751' of https://github.com/shiveshr/pravega-1 into issue4751", "committedDate": "2020-07-22T06:26:17Z", "type": "commit"}, {"oid": "037919ef7ab047683c5e5ab56ceccda414129ed6", "url": "https://github.com/pravega/pravega/commit/037919ef7ab047683c5e5ab56ceccda414129ed6", "message": "filter scopes\n\nSigned-off-by: Shivesh Ranjan <shivesh.ranjan@gmail.com>", "committedDate": "2020-07-22T07:47:56Z", "type": "commit"}]}