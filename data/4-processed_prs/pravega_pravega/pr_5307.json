{"pr_number": 5307, "pr_title": "Issue 5139: Ensure writer does not retry indefinitely to establish a connection with Pravega.", "pr_createdAt": "2020-11-06T11:21:28Z", "pr_url": "https://github.com/pravega/pravega/pull/5307", "timeline": [{"oid": "12dab7cff002d165d0efeaec7923782ae9790da5", "url": "https://github.com/pravega/pravega/commit/12dab7cff002d165d0efeaec7923782ae9790da5", "message": "rough impl\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-05T11:09:07Z", "type": "commit"}, {"oid": "9686177b1b1c9830a258b6670c4c6378bb9e82ce", "url": "https://github.com/pravega/pravega/commit/9686177b1b1c9830a258b6670c4c6378bb9e82ce", "message": "Improve junit.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-06T11:18:08Z", "type": "commit"}, {"oid": "0ec8241d6b86be252374a08ab3edcb874f3cf846", "url": "https://github.com/pravega/pravega/commit/0ec8241d6b86be252374a08ab3edcb874f3cf846", "message": "Refactor code.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-06T11:23:31Z", "type": "commit"}, {"oid": "6245d7d21ed515abb4a27cb224e10262c208bb54", "url": "https://github.com/pravega/pravega/commit/6245d7d21ed515abb4a27cb224e10262c208bb54", "message": "Merge remote-tracking branch 'upstream/master' into issue-5139", "committedDate": "2020-11-06T15:58:41Z", "type": "commit"}, {"oid": "901a67c81bd7de0b7d938e9bccb44213b2d5deb9", "url": "https://github.com/pravega/pravega/commit/901a67c81bd7de0b7d938e9bccb44213b2d5deb9", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-09T06:54:52Z", "type": "commit"}, {"oid": "3ec35b77cfdb97142ff2cb10161cc6862eb14ab1", "url": "https://github.com/pravega/pravega/commit/3ec35b77cfdb97142ff2cb10161cc6862eb14ab1", "message": "Improve junit for inflight events.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-09T08:56:45Z", "type": "commit"}, {"oid": "10ae7a1d869c2e81b6cf53671181254b7dca7e5f", "url": "https://github.com/pravega/pravega/commit/10ae7a1d869c2e81b6cf53671181254b7dca7e5f", "message": "Add junit for flush testing.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-09T10:39:01Z", "type": "commit"}, {"oid": "fdaa67e605a81c49dc1d5af3015740629dd74893", "url": "https://github.com/pravega/pravega/commit/fdaa67e605a81c49dc1d5af3015740629dd74893", "message": "Improve sealed segment handling incase of connection failures.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-09T10:53:55Z", "type": "commit"}, {"oid": "2806e57a335d9cb8da61c97686b344d60cbf9eed", "url": "https://github.com/pravega/pravega/commit/2806e57a335d9cb8da61c97686b344d60cbf9eed", "message": "Fix the junit.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-10T08:50:48Z", "type": "commit"}, {"oid": "a0922991689afc674e758d0481124ddfdf2b0b03", "url": "https://github.com/pravega/pravega/commit/a0922991689afc674e758d0481124ddfdf2b0b03", "message": "Add junit for sealed segment connection failure scenario.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-11T05:40:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMDE4NA==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r521210184", "bodyText": "what about adding a \"return\" ?\nit won't have effect but it may make the code cleaner", "author": "eolivelli", "createdAt": "2020-11-11T09:00:02Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -557,6 +562,10 @@ public void flush() throws SegmentSealedException {\n                 }\n             } catch (Exception e) {\n                 failConnection(e);\n+                if (e instanceof RetriesExhaustedException) {\n+                    //throw an exception to the external world that the flush failed due to RetriesExhaustedException\n+                    Exceptions.sneakyThrow(e);", "originalCommit": "a0922991689afc674e758d0481124ddfdf2b0b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzNTM0Mw==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522035343", "bodyText": "Thanks @eolivelli\nThe intent here was to ensure the user knows that there was a connectivity issue for this synchronous API. Adding a return with a log message will imply the user will not know that some events were not written due to connectivity issues.\n@tkaitchuck is there a better way to communicate this connectivity issue to the user of Pravega?", "author": "shrids", "createdAt": "2020-11-12T11:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMDE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0Mzc3Nw==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522043777", "bodyText": "Exceptions.sneakyThrow(e); throws an exception, and the execution of the method is aborted, so basically it is like we had a \"return\" after   Exceptions.sneakyThrow(e);\nmy concern is only about telling explicitly to the reader of the code that the execution is ending up there (also automatic flow execution tools like spotbugs may be happier)\nnot a big deal, we can keep it as it is now", "author": "eolivelli", "createdAt": "2020-11-12T11:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMDE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzMDE5Nw==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522230197", "bodyText": "Ok, Thanks for clarifying it.\nI have improved the code.", "author": "shrids", "createdAt": "2020-11-12T16:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMDE4NA=="}], "type": "inlineReview"}, {"oid": "eaa0db448dc8962c97f6d578d6e1d64e3bbfff24", "url": "https://github.com/pravega/pravega/commit/eaa0db448dc8962c97f6d578d6e1d64e3bbfff24", "message": "CR Changes: Improve readability.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-12T16:14:41Z", "type": "commit"}, {"oid": "c6b0bbff156f79bdcec778df06f55f8668afab91", "url": "https://github.com/pravega/pravega/commit/c6b0bbff156f79bdcec778df06f55f8668afab91", "message": "Increase retry count for System tests to handle slow clusters.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-12T16:16:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNTg1MA==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522325850", "bodyText": "The typical pattern here is to do:\n throw Exceptions.sneakyThrow(e);\nFor this reason the signature of sneakyThrow returns an exception even though the function never returns. Calling it in this way makes it clear visually that an exception will be thrown from this line and makes static analysis tools like IDEs better able to parse what is going on.", "author": "tkaitchuck", "createdAt": "2020-11-12T18:31:30Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -557,6 +562,11 @@ public void flush() throws SegmentSealedException {\n                 }\n             } catch (Exception e) {\n                 failConnection(e);\n+                if (e instanceof RetriesExhaustedException) {\n+                    //throw an exception to the external world that the flush failed due to RetriesExhaustedException\n+                    Exceptions.sneakyThrow(e);", "originalCommit": "c6b0bbff156f79bdcec778df06f55f8668afab91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYxMzc0MA==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522613740", "bodyText": "fixed it.", "author": "shrids", "createdAt": "2020-11-13T04:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNzE5Ng==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522327196", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                             log.error(\"Error will attempting to establish connection\", t);\n          \n          \n            \n                             log.error(\"Error while attempting to establish connection\", t);", "author": "tkaitchuck", "createdAt": "2020-11-12T18:33:25Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -586,61 +597,64 @@ void reconnect() {\n         }\n         log.debug(\"(Re)connect invoked, Segment: {}, writerID: {}\", segmentName, writerId);\n         state.setupConnection.registerAndRunReleaser(() -> {\n-            Retry.indefinitelyWithExpBackoff(retrySchedule.getInitialMillis(), retrySchedule.getMultiplier(),\n-                                             retrySchedule.getMaxDelay(),\n-                                             t -> log.warn(writerId + \" Failed to connect: \", t))\n-                 .runAsync(() -> {\n-                     log.debug(\"Running reconnect for segment {} writer {}\", segmentName, writerId);\n-\n-                     if (state.isClosed() || state.needSuccessors.get()) {\n-                         // stop reconnect when writer is closed or resend inflight to successors has been triggered.\n-                         return CompletableFuture.completedFuture(null);\n-                     }\n-                     Preconditions.checkState(state.getConnection() == null);\n-                     log.info(\"Fetching endpoint for segment {}, writer {}\", segmentName, writerId);\n-\n-                     return controller.getEndpointForSegment(segmentName)\n-                         // Establish and return a connection to segment store\n-                         .thenComposeAsync((PravegaNodeUri uri) -> {\n-                             log.info(\"Establishing connection to {} for {}, writerID: {}\", uri, segmentName, writerId);\n-                             return establishConnection(uri);\n-                         }, connectionPool.getInternalExecutor())\n-                         .thenCombineAsync(tokenProvider.retrieveToken(),\n-                                           AbstractMap.SimpleEntry<ClientConnection, String>::new,\n-                                           connectionPool.getInternalExecutor())\n-                         .thenComposeAsync(pair -> {\n-                             ClientConnection connection = pair.getKey();\n-                             String token = pair.getValue();\n-\n-                             CompletableFuture<Void> connectionSetupFuture = state.newConnection(connection);\n-                             SetupAppend cmd = new SetupAppend(requestId, writerId, segmentName, token);\n-                             try {\n-                                 connection.send(cmd);\n-                             } catch (ConnectionFailedException e1) {\n-                                 // This needs to be invoked here because call to failConnection from netty may occur before state.newConnection above.\n-                                 state.failConnection(e1);\n-                                 throw Exceptions.sneakyThrow(e1);\n-                             }\n-                             return connectionSetupFuture.exceptionally(t -> {\n-                                 Throwable exception = Exceptions.unwrap(t);\n-                                 if (exception instanceof InvalidTokenException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because token verification failed due to invalid token\",\n-                                             writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 if (exception instanceof SegmentSealedException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because segment is sealed\", writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 if (exception instanceof NoSuchSegmentException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because segment is truncated\", writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 throw Exceptions.sneakyThrow(t);\n-                             });\n-\n-                         }, connectionPool.getInternalExecutor());\n-                 }, connectionPool.getInternalExecutor());\n+            retrySchedule.retryWhen(t -> t instanceof Exception) // retry on all exceptions.\n+              .runAsync(() -> {\n+                  log.debug(\"Running reconnect for segment {} writer {}\", segmentName, writerId);\n+\n+                  if (state.isClosed() || state.needSuccessors.get()) {\n+                      // stop reconnect when writer is closed or resend inflight to successors has been triggered.\n+                      return CompletableFuture.completedFuture(null);\n+                  }\n+                  Preconditions.checkState(state.getConnection() == null);\n+                  log.info(\"Fetching endpoint for segment {}, writer {}\", segmentName, writerId);\n+\n+                  return controller.getEndpointForSegment(segmentName)\n+                      // Establish and return a connection to segment store\n+                      .thenComposeAsync((PravegaNodeUri uri) -> {\n+                          log.info(\"Establishing connection to {} for {}, writerID: {}\", uri, segmentName, writerId);\n+                          return establishConnection(uri);\n+                      }, connectionPool.getInternalExecutor())\n+                      .thenCombineAsync(tokenProvider.retrieveToken(),\n+                                        AbstractMap.SimpleEntry<ClientConnection, String>::new,\n+                                        connectionPool.getInternalExecutor())\n+                      .thenComposeAsync(pair -> {\n+                          ClientConnection connection = pair.getKey();\n+                          String token = pair.getValue();\n+\n+                          CompletableFuture<Void> connectionSetupFuture = state.newConnection(connection);\n+                          SetupAppend cmd = new SetupAppend(requestId, writerId, segmentName, token);\n+                          try {\n+                              connection.send(cmd);\n+                          } catch (ConnectionFailedException e1) {\n+                              // This needs to be invoked here because call to failConnection from netty may occur before state.newConnection above.\n+                              state.failConnection(e1);\n+                              throw Exceptions.sneakyThrow(e1);\n+                          }\n+                          return connectionSetupFuture.exceptionally(t1 -> {\n+                              Throwable exception = Exceptions.unwrap(t1);\n+                              if (exception instanceof InvalidTokenException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because token verification failed due to invalid token\",\n+                                          writerId, segmentName);\n+                                  return null;\n+                              }\n+                              if (exception instanceof SegmentSealedException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because segment is sealed\", writerId, segmentName);\n+                                  return null;\n+                              }\n+                              if (exception instanceof NoSuchSegmentException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because segment is truncated\", writerId, segmentName);\n+                                  return null;\n+                              }\n+                              throw Exceptions.sneakyThrow(t1);\n+                          });\n+\n+                      }, connectionPool.getInternalExecutor());\n+              }, connectionPool.getInternalExecutor()).exceptionally(t -> {\n+                 log.error(\"Error will attempting to establish connection\", t);", "originalCommit": "c6b0bbff156f79bdcec778df06f55f8668afab91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDE5OQ==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522600199", "bodyText": "fixed it.", "author": "shrids", "createdAt": "2020-11-13T04:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNzE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyOTI1NA==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522329254", "bodyText": "If they are completed exceptionally they should probably be removed from inflight as they cannot be subsequently be completed successfully.", "author": "tkaitchuck", "createdAt": "2020-11-12T18:36:55Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -652,6 +666,11 @@ void reconnect() {\n         }\n     }\n \n+    private void failUnackedEvents(Throwable t) {\n+        state.getAllInflightEvents().parallelStream().forEach(event -> event.getAckFuture().completeExceptionally(t));", "originalCommit": "c6b0bbff156f79bdcec778df06f55f8668afab91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYxMzA1OA==", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522613058", "bodyText": "ok, I have updated the code.", "author": "shrids", "createdAt": "2020-11-13T04:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyOTI1NA=="}], "type": "inlineReview"}, {"oid": "f6bf7e60353ebb4085f53816d8e2160c6b293ce8", "url": "https://github.com/pravega/pravega/commit/f6bf7e60353ebb4085f53816d8e2160c6b293ce8", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-13T04:04:48Z", "type": "commit"}, {"oid": "321b84ee9c2f78bcae11721defc74e4553c0a8a4", "url": "https://github.com/pravega/pravega/commit/321b84ee9c2f78bcae11721defc74e4553c0a8a4", "message": "CR Changes: Remove inflight events after connection attempts have terminated.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-13T04:30:31Z", "type": "commit"}, {"oid": "cdf390ef0ea03b4f28b1345792fd980a0359884a", "url": "https://github.com/pravega/pravega/commit/cdf390ef0ea03b4f28b1345792fd980a0359884a", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-13T08:32:23Z", "type": "commit"}, {"oid": "b053b764d5d1eb5ff78a58e99c390b3bdcc3090a", "url": "https://github.com/pravega/pravega/commit/b053b764d5d1eb5ff78a58e99c390b3bdcc3090a", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-13T21:57:12Z", "type": "commit"}, {"oid": "ef3b35c4247eb43976d7a457eb3d66f478c0c500", "url": "https://github.com/pravega/pravega/commit/ef3b35c4247eb43976d7a457eb3d66f478c0c500", "message": "Merge branch 'master' into issue-5139\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-17T04:07:30Z", "type": "commit"}, {"oid": "2d6ed125f6888124f94251d97011a730971e84ec", "url": "https://github.com/pravega/pravega/commit/2d6ed125f6888124f94251d97011a730971e84ec", "message": "Fix import error.\n\nSigned-off-by: Sandeep <sandeep.shridhar@emc.com>", "committedDate": "2020-11-17T04:10:07Z", "type": "commit"}, {"oid": "60f4c3e501095bdbc5138aaf8c5dad5c4014d863", "url": "https://github.com/pravega/pravega/commit/60f4c3e501095bdbc5138aaf8c5dad5c4014d863", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-17T06:09:21Z", "type": "commit"}, {"oid": "32ec7b38931217dedf7dd8124090b799496656b9", "url": "https://github.com/pravega/pravega/commit/32ec7b38931217dedf7dd8124090b799496656b9", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-18T08:37:56Z", "type": "commit"}, {"oid": "572717b94cf98351751abcce3571a5bc27a9f29f", "url": "https://github.com/pravega/pravega/commit/572717b94cf98351751abcce3571a5bc27a9f29f", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-18T10:37:33Z", "type": "commit"}, {"oid": "096a5e11d4e5e981ed8efc219395ccc0fa8b91d5", "url": "https://github.com/pravega/pravega/commit/096a5e11d4e5e981ed8efc219395ccc0fa8b91d5", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-19T15:26:12Z", "type": "commit"}, {"oid": "a7ab28dc568d3eb91f9106318a977c2631bf2781", "url": "https://github.com/pravega/pravega/commit/a7ab28dc568d3eb91f9106318a977c2631bf2781", "message": "Merge branch 'master' into issue-5139", "committedDate": "2020-11-20T04:53:41Z", "type": "commit"}]}