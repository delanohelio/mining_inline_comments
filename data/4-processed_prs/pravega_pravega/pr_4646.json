{"pr_number": 4646, "pr_title": "Issue 4273: Revised Throtting Metrics.", "pr_createdAt": "2020-03-26T23:08:35Z", "pr_url": "https://github.com/pravega/pravega/pull/4646", "timeline": [{"oid": "08601afd11463bf700a6d0af3f33dcb53f935e09", "url": "https://github.com/pravega/pravega/commit/08601afd11463bf700a6d0af3f33dcb53f935e09", "message": "Update K8 client APIs to use their 5.0.0 counterparts.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-02-21T00:13:24Z", "type": "commit"}, {"oid": "25a165d0293c34ee8703fff764e55cf8fda413dd", "url": "https://github.com/pravega/pravega/commit/25a165d0293c34ee8703fff764e55cf8fda413dd", "message": "Merge pull request #1 from co-jo/issue-4464-update-kubernetes-client-version\n\nIssue 4464 update kubernetes client version", "committedDate": "2020-02-21T18:42:03Z", "type": "commit"}, {"oid": "8cc2dd2be26feed2953258ff055c1657aeb57019", "url": "https://github.com/pravega/pravega/commit/8cc2dd2be26feed2953258ff055c1657aeb57019", "message": "Run system tests using alternative flag value.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-02-23T04:43:09Z", "type": "commit"}, {"oid": "c3fcbd2e627f9fc0a0f6bad7e42667db4439e092", "url": "https://github.com/pravega/pravega/commit/c3fcbd2e627f9fc0a0f6bad7e42667db4439e092", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-03-10T22:21:32Z", "type": "commit"}, {"oid": "f5f808cc42831892aeb8e7824c22d499a1f9fa03", "url": "https://github.com/pravega/pravega/commit/f5f808cc42831892aeb8e7824c22d499a1f9fa03", "message": "Merge branch 'master' of https://github.com/pravega/pravega", "committedDate": "2020-03-18T18:44:10Z", "type": "commit"}, {"oid": "27d4118b2f6d4ff8fe401c4a50e4373c4609b057", "url": "https://github.com/pravega/pravega/commit/27d4118b2f6d4ff8fe401c4a50e4373c4609b057", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-03-18T20:55:22Z", "type": "commit"}, {"oid": "0731b7efb28fab80d43ba7e140f4a9a8b9d1007e", "url": "https://github.com/pravega/pravega/commit/0731b7efb28fab80d43ba7e140f4a9a8b9d1007e", "message": "Adjust throttle reporting times to account for possible preemptions.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-03-23T17:45:56Z", "type": "commit"}, {"oid": "151da72384344f58b12920e2329c9c44d6a39869", "url": "https://github.com/pravega/pravega/commit/151da72384344f58b12920e2329c9c44d6a39869", "message": "Properly account for interruptions of active throttlers in our Metrics reporting.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-03-26T20:23:36Z", "type": "commit"}, {"oid": "93452437d7e50640da28458fbcc2c6b824ff2705", "url": "https://github.com/pravega/pravega/commit/93452437d7e50640da28458fbcc2c6b824ff2705", "message": "Merge remote-tracking branch 'upstream/master' into issue-4273-ss-throttling-metrics\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-03-26T23:06:28Z", "type": "commit"}, {"oid": "9c0875f8db675dc0713a5a2575934e52e0dc8a50", "url": "https://github.com/pravega/pravega/commit/9c0875f8db675dc0713a5a2575934e52e0dc8a50", "message": "Merge branch 'master' into issue-4273-ss-throttling-metrics", "committedDate": "2020-03-27T16:47:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI2OQ==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r399571269", "bodyText": "Why do we need three separate metrics here? We can do this using a single metric and change the tag on each publish.\nCheck out https://github.com/pravega/pravega/blob/master/shared/metrics/src/main/java/io/pravega/shared/metrics/MetricsLogAppender.java\nWe use a single metric (ok, two of them MetricsNames.LOG_ERRORS or MetricsNames.LOG_WARNINGS), then in recordEvent we use DYNAMIC_LOGGER to record a value and attach a tag.\nWhat I think we can do in the throttling metrics is define 3 tags (Cache, DurableDataLog and Batching - or better, just get them out of ThrottlerCalculator.DelayResult.getThrottlerName().toString()) and then use a single metric (you can use the one we had before) to report the delay value with the appropriate number.", "author": "andreipaduroiu", "createdAt": "2020-03-27T22:45:55Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/SegmentStoreMetrics.java", "diffHunk": "@@ -154,36 +168,57 @@ public OperationProcessor(int containerId) {\n             this.operationQueueSize = STATS_LOGGER.createStats(MetricsNames.OPERATION_QUEUE_SIZE, this.containerTag);\n             this.operationsInFlight = STATS_LOGGER.createStats(MetricsNames.OPERATION_PROCESSOR_IN_FLIGHT, this.containerTag);\n             this.operationQueueWaitTime = STATS_LOGGER.createStats(MetricsNames.OPERATION_QUEUE_WAIT_TIME, this.containerTag);\n-            this.operationProcessorDelay = STATS_LOGGER.createStats(MetricsNames.OPERATION_PROCESSOR_DELAY_MILLIS, this.containerTag);\n             this.operationCommitLatency = STATS_LOGGER.createStats(MetricsNames.OPERATION_COMMIT_LATENCY, this.containerTag);\n             this.operationLatency = STATS_LOGGER.createStats(MetricsNames.OPERATION_LATENCY, this.containerTag);\n             this.memoryCommitLatency = STATS_LOGGER.createStats(MetricsNames.OPERATION_COMMIT_MEMORY_LATENCY, this.containerTag);\n             this.memoryCommitCount = STATS_LOGGER.createStats(MetricsNames.OPERATION_COMMIT_MEMORY_COUNT, this.containerTag);\n             this.processOperationsLatency = STATS_LOGGER.createStats(MetricsNames.PROCESS_OPERATIONS_LATENCY, this.containerTag);\n             this.processOperationsBatchSize = STATS_LOGGER.createStats(MetricsNames.PROCESS_OPERATIONS_BATCH_SIZE, this.containerTag);\n+            this.operationProcessorCacheDelay = STATS_LOGGER.createStats(", "originalCommit": "9c0875f8db675dc0713a5a2575934e52e0dc8a50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNzk3NQ==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r401817975", "bodyText": "After reading the code, seems in the case there are two tags - container (x1) and throttler (x3) - so it's a best practice to pre-create all possible tag values combinations in advance, and use enum/map to locate them.\nPlease avoid dynamically generating tag values. (Tag values should be, in most cases, constant)", "author": "kevinhan88", "createdAt": "2020-04-01T18:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyMzE1Mw==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r401823153", "bodyText": "The code could be like this:\nthis.containerTag = containerTag(containerId);\nthis.throttler-cache = throttlerTag(\"cache\");\nthis.throttler-batching = throttlerTag(\"batching\");\n...\nDYNAMIC_LOGGER.reportGaugeValue(MetricsNames.OPERATION_PROCESSOR_DELAY_MILLIS, millis, containerTag, whateverThrottlerTag);", "author": "kevinhan88", "createdAt": "2020-04-01T18:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4NTA3Mw==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r401885073", "bodyText": "I attempted using the reportGaugeValue functionality. But I had issues passing in primitive numeric types (Could not change the value of the gauge after the initial argument reference was lost, i.e the method returned). According to the micrometer documentation this is the expected result.\nUsing a Counter or a MeteredEvent also don't seem appropriate for the use case.", "author": "co-jo", "createdAt": "2020-04-01T20:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMTA5Nw==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r401901097", "bodyText": "For example, I wrote two simple tests and stuck them in ThrottlerTests:\n    @Test\n    public void a() throws Exception {\n        DYNAMIC_LOGGER.reportGaugeValue(\"gauge-key\", 10);\n        log.debug(\"gauge-key: {}\", MetricRegistryUtils.getGauge(\"gauge-key\").value());\n        DYNAMIC_LOGGER.reportGaugeValue(\"gauge-key\", 15);\n        log.debug(\"gauge-key: {}\", MetricRegistryUtils.getGauge(\"gauge-key\").value());\n    }\n    @Test\n    public void b() throws Exception {\n        log.debug(\"gauge-key before: {}\", MetricRegistryUtils.getGauge(\"gauge-key\").value());\n        DYNAMIC_LOGGER.reportGaugeValue(\"gauge-key\", 20);\n        log.debug(\"gauge-key after: {}\", MetricRegistryUtils.getGauge(\"gauge-key\").value());\n    }\n\nWhich produced the output:\nStats enabled\ngauge-key: 10.0\ngauge-key: 15.0\nStats enabled\ngauge-key before: 15.0\ngauge-key after: 15.0\n\nHowever I notice this pattern has been used throughout the code-base, for example:\nTransactionMetrics.java\n    public static void reportOpenTransactions(String scope, String streamName, int ongoingTransactions) {\n        DYNAMIC_LOGGER.reportGaugeValue(OPEN_TRANSACTIONS, ongoingTransactions, streamTags(scope, streamName));\n    }\n\nI'm not exactly sure why we can expect this to work.", "author": "co-jo", "createdAt": "2020-04-01T20:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxMDQ2Mg==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r401910462", "bodyText": "Please refer to MetricsProviderTest.java for similar test cases, in particular compare how the metrics registry gets initialized.", "author": "kevinhan88", "createdAt": "2020-04-01T21:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNTcyNA==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r401935724", "bodyText": "Please refer to MetricsProviderTest.java for similar test cases, in particular compare how the metrics registry gets initialized.\n\nI'm not sure I understand. I don't see any difference in usages, with the exception of MetricsProviderTest.java calling freezeGaugeValue before returning.  But that still leaves the question about why the reportOpenTransacitons call is able to work properly.", "author": "co-jo", "createdAt": "2020-04-01T22:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjU0MjAwNw==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r402542007", "bodyText": "Unit tests are supposed to be independent, and be run in any sequence.\nSeems the test b() carries the result of test a (15), it is a test leaking. The first line of test b() should receive an nullpointerexception as the gauge wasn't created by that time.\nPlease refer to MetricsProviderTest again, look for @before which annotates the method to run before EVERY test case.", "author": "kevinhan88", "createdAt": "2020-04-02T18:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI2OQ=="}], "type": "inlineReview"}, {"oid": "cbf91d3d92d2828870d270b2600d76e4c97f8132", "url": "https://github.com/pravega/pravega/commit/cbf91d3d92d2828870d270b2600d76e4c97f8132", "message": "Prepopulate throttler tag sets, instead of constructing them dynamically on each call to `processingDelay`.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-02T18:45:57Z", "type": "commit"}, {"oid": "0338c790c29459a2701f16b36a78512ccd839412", "url": "https://github.com/pravega/pravega/commit/0338c790c29459a2701f16b36a78512ccd839412", "message": "Reformat method call.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-02T21:28:46Z", "type": "commit"}, {"oid": "1da33e0ebee212c9d8e44e1091d056e7080e64fd", "url": "https://github.com/pravega/pravega/commit/1da33e0ebee212c9d8e44e1091d056e7080e64fd", "message": "Merge branch 'master' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-03T14:44:59Z", "type": "commit"}, {"oid": "45f8e1bf43e99fb153bb583f7bf2e0a5c0344a86", "url": "https://github.com/pravega/pravega/commit/45f8e1bf43e99fb153bb583f7bf2e0a5c0344a86", "message": "Randomize containerId to ensure isolation between tests.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-03T18:14:31Z", "type": "commit"}, {"oid": "37b693f0d80214a3e384eca8e44e28d09dad122e", "url": "https://github.com/pravega/pravega/commit/37b693f0d80214a3e384eca8e44e28d09dad122e", "message": "Merge remote-tracking branch 'origin/issue-4273-ss-throttling-metrics' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-03T18:16:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMTY2NA==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r403221664", "bodyText": "why not use Throttler enum directly here?", "author": "kevinhan88", "createdAt": "2020-04-03T18:25:10Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/SegmentStoreMetrics.java", "diffHunk": "@@ -182,8 +180,8 @@ public void currentState(int queueSize, int inFlightCount) {\n             this.operationsInFlight.reportSuccessValue(inFlightCount);\n         }\n \n-        public void processingDelay(int millis) {\n-            this.operationProcessorDelay.reportSuccessValue(millis);\n+        public void processingDelay(int millis, String throttlerName) {", "originalCommit": "37b693f0d80214a3e384eca8e44e28d09dad122e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNzAzNA==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r403227034", "bodyText": "The place where this is called (Throttler.java) uses an Enum type private to the io.pravega.segmentstore.server.logs package.", "author": "co-jo", "createdAt": "2020-04-03T18:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMTY2NA=="}], "type": "inlineReview"}, {"oid": "6aaf08e87c1d09da44762f925af7a0b756c7d481", "url": "https://github.com/pravega/pravega/commit/6aaf08e87c1d09da44762f925af7a0b756c7d481", "message": "Check for null values on the ThrottlerName to avoid calling toString on a null reference.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-07T18:40:37Z", "type": "commit"}, {"oid": "30b113aba03537b58cbc9c55acd70f6c88c541ce", "url": "https://github.com/pravega/pravega/commit/30b113aba03537b58cbc9c55acd70f6c88c541ce", "message": "Merge branch 'master' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-07T18:43:51Z", "type": "commit"}, {"oid": "a19736df6da138806010d3b22e628070d360d891", "url": "https://github.com/pravega/pravega/commit/a19736df6da138806010d3b22e628070d360d891", "message": "Fix checkstyle violations.\n\nSigned-off-by: co-jo <colin.hryniowski@dell.com>", "committedDate": "2020-04-07T23:01:48Z", "type": "commit"}, {"oid": "88d7edb30e12128eae5c24b91e36bfdc13a6c948", "url": "https://github.com/pravega/pravega/commit/88d7edb30e12128eae5c24b91e36bfdc13a6c948", "message": "Merge branch 'issue-4273-ss-throttling-metrics' of https://github.com/co-jo/pravega into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-07T23:02:37Z", "type": "commit"}, {"oid": "4f9134a96f61c5f1fde6bcad92dafd74c4efcbf6", "url": "https://github.com/pravega/pravega/commit/4f9134a96f61c5f1fde6bcad92dafd74c4efcbf6", "message": "All @param to Javadoc comment.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-08T04:22:38Z", "type": "commit"}, {"oid": "d5a76496316b20dccdd00fb0b5789f15a0c250c5", "url": "https://github.com/pravega/pravega/commit/d5a76496316b20dccdd00fb0b5789f15a0c250c5", "message": "All @param to Javadoc comment.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-08T04:23:57Z", "type": "commit"}, {"oid": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "url": "https://github.com/pravega/pravega/commit/ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "message": "Merge branch 'master' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-08T15:30:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNjgwMg==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406536802", "bodyText": "I'm not a big fan of this type of caching, for a couple of reasons:\n\nYou need to do a lookup in this map every time you report something.\nThe map's keys are not the same as the ones that are in ThrottlerCalculator. If we decide (for whatever reason) to rename, remove or add one in there, this will not work.\nIf (continued from 2 above), there is no entry in this map for a throttler name, then it will return null - how will the reporting work? will it throw a NullPtr?\n\nI am OK with generating a new array every time we invoke this. Generating a 4-element array is insignificant compared to all the other work that is done in the Operation Processor so there's no need to try to optimize it.", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:52:31Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/SegmentStoreMetrics.java", "diffHunk": "@@ -148,13 +144,16 @@ private void report() {\n         private final OpStatsLogger processOperationsLatency;\n         private final OpStatsLogger processOperationsBatchSize;\n         private final String[] containerTag;\n+        private final HashMap<String, String[]> throttlerTags = new HashMap<>();", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNzI2OQ==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406537269", "bodyText": "please add a method called getElapsed on TimeoutTimer that does this calculation. Doing so will remove the need to expose getInitial to the outside.", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:54:04Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/Throttler.java", "diffHunk": "@@ -122,6 +122,8 @@ boolean isThrottlingRequired() {\n                 if (remaining > 0 && remaining < delay.get().getDurationMillis()) {\n                     delay.set(delay.get().withNewDelay(remaining));\n                 }\n+                int incurredDelay = (int) (existingDelay.remaining.getInitial().toMillis() - existingDelay.remaining.getRemaining().toMillis());", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNzQ0Mw==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406537443", "bodyText": "Why would this be null?\nAnd even if it is, I still want to see this logged somewhere - this is important for certain debugging activities.", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:54:49Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/Throttler.java", "diffHunk": "@@ -138,13 +140,12 @@ boolean isThrottlingRequired() {\n     }\n \n     private CompletableFuture<Void> throttleOnce(ThrottlerCalculator.DelayResult delay) {\n-        this.metrics.processingDelay(delay.getDurationMillis());\n         if (delay.isMaximum()\n                 || delay.getThrottlerName() == ThrottlerCalculator.ThrottlerName.DurableDataLog) {\n             // Increase logging visibility if we throttle at the maximum limit (which means we're likely to fully block\n             // processing of operations) or if this is due to us not being able to ingest items quickly enough.\n             log.warn(\"{}: Processing delay = {}.\", this.traceObjectId, delay);\n-        } else {\n+        } else if (delay.getThrottlerName() != null) {", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0MzA4Ng==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406543086", "bodyText": "I did not dig too deeply, but It appears that throttle is being called somewhere in the testing code, without having been assigned a Throttler and returns a DelayResult with a default null name. When I called delay.getThrottlerName() on this null value, it halts execution. This was the reason for my TravisCI builds failing. Having said that I think this condition is redundant anyways. Will remove.", "author": "co-jo", "createdAt": "2020-04-10T00:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNzQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc5NDAwNQ==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406794005", "bodyText": "Well, by looking at the code in this else block I don't see how that could happen. log.debug is passed delay, and it will only invoke toString on it if debug-level logging is enabled. I believe it is not (but I am not sure). However if there is a bug like you said, then it must be in the toString implementation of delay, so if anything it should be fixed there.", "author": "andreipaduroiu", "createdAt": "2020-04-10T14:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNzQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNzUxNA==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406537514", "bodyText": "use hasRemaining in TimeoutTimer", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:55:12Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/Throttler.java", "diffHunk": "@@ -159,8 +160,17 @@ boolean isThrottlingRequired() {\n                             result.delayFuture,\n                             ex -> ex instanceof ThrottlingInterruptedException,\n                             this::throttle)\n-                    .whenComplete((r, e) -> this.currentDelay.set(null));\n+                    .whenComplete((r, e) -> {\n+                        if (this.currentDelay.get() != null && currentDelay.get().remaining.getRemaining().toMillis() <= 0) {", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzODA1NQ==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406538055", "bodyText": "Please do not check in commented out code. Either add it back or delete it completely.", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:57:08Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/logs/ThrottlerTests.java", "diffHunk": "@@ -145,6 +161,191 @@ public void testInterruptedDurableDataLogDelay() throws Exception {\n         testInterruptedDelay(ThrottlerCalculator.ThrottlerName.DurableDataLog);\n     }\n \n+    /**\n+     * Tests if interruptible throttlers are correctly reporting the time spent throttled.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testInterruptedIncreasingDelayMetrics() throws Exception {\n+        // Supply monotonically decreasing delays.\n+        val suppliedDelays = Arrays.asList(3000, 4000, 5000);\n+        val delays = Collections.<Integer>synchronizedList(new ArrayList<>());\n+        val calculator = new TestCalculatorThrottler(ThrottlerCalculator.ThrottlerName.Cache);\n+        val nextDelay = suppliedDelays.iterator();\n+        Consumer<Integer> recordDelay = delayMillis -> {\n+            delays.add(delayMillis);\n+            calculator.setDelayMillis(nextDelay.hasNext() ? nextDelay.next() : 0); // 0 means we're done (no more throttling).\n+        };\n+        @Cleanup\n+        TestThrottler t = new TestThrottler(this.containerId, wrap(calculator), executorService(), metrics, recordDelay);\n+\n+        // Set a non-maximum delay and ask to throttle, then verify we throttled the correct amount.\n+        calculator.setDelayMillis(nextDelay.next());\n+        val t1 = t.throttle();\n+        Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());\n+\n+        // For every delay that we want to submit, notify that the cache cleanup has completed, which should cancel the\n+        // currently running throttle cycle and request the next throttling value.\n+        for (int i = 1; i < suppliedDelays.size(); i++) {\n+            // Interrupt the current throttle cycle.\n+            t.notifyThrottleSourceChanged();\n+            Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());\n+\n+            // Wait for the new cycle to begin (we use the recordDelay consumer above to figure this out).\n+            int expectedDelayCount = i + 1;\n+            TestUtils.await(() -> delays.size() == expectedDelayCount, 5, TIMEOUT_MILLIS);\n+        }\n+        TestUtils.await(t1::isDone, 5, TIMEOUT_MILLIS);\n+\n+        String[] tags = { \"container\", String.valueOf(this.containerId), \"throttler\", \"Cache\" };\n+\n+        // Because the supplied delays is monotonically decreasing, only the first delay value should be used to calculate\n+        // the duration supplied.\n+        AssertExtensions.assertLessThanOrEqual(\n+                \"Throttler should be at most the first supplied delay\",\n+                (int) suppliedDelays.get(0),\n+                (int) MetricRegistryUtils.getGauge(MetricsNames.OPERATION_PROCESSOR_DELAY_MILLIS, tags).value()\n+        );\n+    }\n+\n+    /**\n+     * Tests if interruptible throttlers are correctly reporting the time spent throttled.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testInterruptedDecreasingDelayMetrics() throws Exception {\n+        // Supply monotonically decreasing delays.\n+        val suppliedDelays = Arrays.asList(5000, 4000, 3000);\n+        val delays = Collections.<Integer>synchronizedList(new ArrayList<>());\n+        val calculator = new TestCalculatorThrottler(ThrottlerCalculator.ThrottlerName.Cache);\n+        val nextDelay = suppliedDelays.iterator();\n+        Consumer<Integer> recordDelay = delayMillis -> {\n+            delays.add(delayMillis);\n+            calculator.setDelayMillis(nextDelay.hasNext() ? nextDelay.next() : 0); // 0 means we're done (no more throttling).\n+        };\n+        @Cleanup\n+        TestThrottler t = new TestThrottler(this.containerId, wrap(calculator), executorService(), metrics, recordDelay);\n+\n+        // Set a non-maximum delay and ask to throttle, then verify we throttled the correct amount.\n+        calculator.setDelayMillis(nextDelay.next());\n+        val t1 = t.throttle();\n+        Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());\n+\n+        // For every delay that we want to submit, notify that the cache cleanup has completed, which should cancel the\n+        // currently running throttle cycle and request the next throttling value.\n+        for (int i = 1; i < suppliedDelays.size(); i++) {\n+            // Interrupt the current throttle cycle.\n+            t.notifyThrottleSourceChanged();\n+            //Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzODMxNg==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406538316", "bodyText": "I really do not like sleeping in tests (or anywhere else for that matter). Can you rewrite this test without the need to sleep?", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:58:17Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/logs/ThrottlerTests.java", "diffHunk": "@@ -145,6 +161,191 @@ public void testInterruptedDurableDataLogDelay() throws Exception {\n         testInterruptedDelay(ThrottlerCalculator.ThrottlerName.DurableDataLog);\n     }\n \n+    /**\n+     * Tests if interruptible throttlers are correctly reporting the time spent throttled.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testInterruptedIncreasingDelayMetrics() throws Exception {\n+        // Supply monotonically decreasing delays.\n+        val suppliedDelays = Arrays.asList(3000, 4000, 5000);\n+        val delays = Collections.<Integer>synchronizedList(new ArrayList<>());\n+        val calculator = new TestCalculatorThrottler(ThrottlerCalculator.ThrottlerName.Cache);\n+        val nextDelay = suppliedDelays.iterator();\n+        Consumer<Integer> recordDelay = delayMillis -> {\n+            delays.add(delayMillis);\n+            calculator.setDelayMillis(nextDelay.hasNext() ? nextDelay.next() : 0); // 0 means we're done (no more throttling).\n+        };\n+        @Cleanup\n+        TestThrottler t = new TestThrottler(this.containerId, wrap(calculator), executorService(), metrics, recordDelay);\n+\n+        // Set a non-maximum delay and ask to throttle, then verify we throttled the correct amount.\n+        calculator.setDelayMillis(nextDelay.next());\n+        val t1 = t.throttle();\n+        Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());\n+\n+        // For every delay that we want to submit, notify that the cache cleanup has completed, which should cancel the\n+        // currently running throttle cycle and request the next throttling value.\n+        for (int i = 1; i < suppliedDelays.size(); i++) {\n+            // Interrupt the current throttle cycle.\n+            t.notifyThrottleSourceChanged();\n+            Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());\n+\n+            // Wait for the new cycle to begin (we use the recordDelay consumer above to figure this out).\n+            int expectedDelayCount = i + 1;\n+            TestUtils.await(() -> delays.size() == expectedDelayCount, 5, TIMEOUT_MILLIS);\n+        }\n+        TestUtils.await(t1::isDone, 5, TIMEOUT_MILLIS);\n+\n+        String[] tags = { \"container\", String.valueOf(this.containerId), \"throttler\", \"Cache\" };\n+\n+        // Because the supplied delays is monotonically decreasing, only the first delay value should be used to calculate\n+        // the duration supplied.\n+        AssertExtensions.assertLessThanOrEqual(\n+                \"Throttler should be at most the first supplied delay\",\n+                (int) suppliedDelays.get(0),\n+                (int) MetricRegistryUtils.getGauge(MetricsNames.OPERATION_PROCESSOR_DELAY_MILLIS, tags).value()\n+        );\n+    }\n+\n+    /**\n+     * Tests if interruptible throttlers are correctly reporting the time spent throttled.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testInterruptedDecreasingDelayMetrics() throws Exception {\n+        // Supply monotonically decreasing delays.\n+        val suppliedDelays = Arrays.asList(5000, 4000, 3000);\n+        val delays = Collections.<Integer>synchronizedList(new ArrayList<>());\n+        val calculator = new TestCalculatorThrottler(ThrottlerCalculator.ThrottlerName.Cache);\n+        val nextDelay = suppliedDelays.iterator();\n+        Consumer<Integer> recordDelay = delayMillis -> {\n+            delays.add(delayMillis);\n+            calculator.setDelayMillis(nextDelay.hasNext() ? nextDelay.next() : 0); // 0 means we're done (no more throttling).\n+        };\n+        @Cleanup\n+        TestThrottler t = new TestThrottler(this.containerId, wrap(calculator), executorService(), metrics, recordDelay);\n+\n+        // Set a non-maximum delay and ask to throttle, then verify we throttled the correct amount.\n+        calculator.setDelayMillis(nextDelay.next());\n+        val t1 = t.throttle();\n+        Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());\n+\n+        // For every delay that we want to submit, notify that the cache cleanup has completed, which should cancel the\n+        // currently running throttle cycle and request the next throttling value.\n+        for (int i = 1; i < suppliedDelays.size(); i++) {\n+            // Interrupt the current throttle cycle.\n+            t.notifyThrottleSourceChanged();\n+            //Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());\n+\n+            // Wait for the new cycle to begin (we use the recordDelay consumer above to figure this out).\n+            int expectedDelayCount = i + 1;\n+            TestUtils.await(() -> delays.size() == expectedDelayCount, 5, TIMEOUT_MILLIS);\n+        }\n+        TestUtils.await(t1::isDone, 5, TIMEOUT_MILLIS);\n+\n+        String[] tags = { \"container\", String.valueOf(this.containerId), \"throttler\", \"Cache\" };\n+\n+        // Because the supplied delays is monotonically decreasing, only the first delay value should be used to calculate\n+        // the duration supplied.\n+\n+        AssertExtensions.assertGreaterThanOrEqual(\n+                \"Excepted delay to be at least smallest value.\",\n+                 suppliedDelays.get(2),\n+                (int) MetricRegistryUtils.getGauge(MetricsNames.OPERATION_PROCESSOR_DELAY_MILLIS, tags).value()\n+        );\n+\n+        AssertExtensions.assertLessThan(\n+                \"Excepted delay to be strictly less than the max.\",\n+                 suppliedDelays.get(0),\n+                (int) MetricRegistryUtils.getGauge(MetricsNames.OPERATION_PROCESSOR_DELAY_MILLIS, tags).value()\n+        );\n+    }\n+\n+    /**\n+     * Incorporates mutliple types of throttlers using arbitrary throttling amounts to make sure that each throttling\n+     * metric is being properly reported.\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testInterrutedMixedDelayMetrics() throws Exception {\n+        val cacheCalculator = new TestCalculatorThrottler(ThrottlerCalculator.ThrottlerName.Cache);\n+        val batchingCalculator = new TestCalculatorThrottler(ThrottlerCalculator.ThrottlerName.Batching);\n+        val durableDataLogCalculator = new TestCalculatorThrottler(ThrottlerCalculator.ThrottlerName.DurableDataLog);\n+\n+        int cacheDelay = 6000;\n+        int batchingDelay = 5000;\n+        int durableDataLogDelay = 3000;\n+\n+        cacheCalculator.setDelayMillis(cacheDelay);\n+        batchingCalculator.setDelayMillis(batchingDelay);\n+        durableDataLogCalculator.setDelayMillis(durableDataLogDelay);\n+\n+        Consumer<Integer> recordDelay = delayMillis -> { };\n+        ArrayList<ThrottlerCalculator.Throttler> throttlers = new ArrayList<>(Arrays.asList(cacheCalculator, batchingCalculator, durableDataLogCalculator));\n+\n+        @Cleanup\n+        TestThrottler t = new TestThrottler(this.containerId, wrap(throttlers), executorService(), metrics, recordDelay);\n+\n+        val t1 = t.throttle();\n+        Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t1.isDone());\n+\n+        int throttlerActiveTime = 2000;\n+        // Suppose a second goes by.\n+        TimeUnit.MILLISECONDS.sleep(throttlerActiveTime);\n+        // Now the Cache state has changed.\n+        // Change delay of Cache throttler in order to make the ThrottlerCalculator pick up the Batching Throttler.\n+        cacheCalculator.setDelayMillis(1000);\n+        // Change source of throttling.\n+        t.notifyThrottleSourceChanged();\n+        // Wait for the batching throttler to complete.\n+        TestUtils.await(t1::isDone, 5, TIMEOUT_MILLIS);\n+        // Throttler should report it spent at least `throttlerActiveTime` throttled.\n+        AssertExtensions.assertGreaterThanOrEqual(\n+                \"Expected to be greater than the time left uninterrupted.\",\n+                throttlerActiveTime,\n+                (int) getThrottlerMetric(ThrottlerCalculator.ThrottlerName.Cache)\n+        );\n+        // Force an interruption. The throttler should take the min of the left over delay from the previous throttler,\n+        // or the throttling delay originally assigned.\n+        AssertExtensions.assertLessThanOrEqual(\n+                \"Expected to be greater than the time left uninterrupted.\",\n+                 min(batchingDelay, cacheDelay - throttlerActiveTime),\n+                (int) getThrottlerMetric(ThrottlerCalculator.ThrottlerName.Batching)\n+        );\n+\n+        durableDataLogDelay = max(cacheDelay, batchingDelay) + 1000;\n+        // This should force the throttler calculator to pick up the durable data log throttler.\n+        durableDataLogCalculator.setDelayMillis(durableDataLogDelay);\n+        val t2 = t.throttle();\n+        Assert.assertFalse(\"Not expected throttle future to be completed yet.\", t2.isDone());\n+        // Arbitrary amount of time goes by.\n+        TimeUnit.MILLISECONDS.sleep(throttlerActiveTime);", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzODM5OQ==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406538399", "bodyText": "Math.min?", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:58:36Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/logs/ThrottlerTests.java", "diffHunk": "@@ -195,6 +396,26 @@ private ThrottlerCalculator wrap(ThrottlerCalculator.Throttler calculatorThrottl\n         return ThrottlerCalculator.builder().throttler(calculatorThrottler).build();\n     }\n \n+    private ThrottlerCalculator wrap(ArrayList<ThrottlerCalculator.Throttler> throttlers) {\n+        return ThrottlerCalculator.builder().throttlers(throttlers).build();\n+    }\n+\n+    private String[] throttlerTags(ThrottlerCalculator.ThrottlerName name)  {\n+        return  new String[] { \"container\", String.valueOf(this.containerId), \"throttler\", name.toString() };\n+    }\n+\n+    private double getThrottlerMetric(ThrottlerCalculator.ThrottlerName name) {\n+        return MetricRegistryUtils.getGauge(MetricsNames.OPERATION_PROCESSOR_DELAY_MILLIS, throttlerTags(name)).value();\n+    }\n+\n+    private static int min(int a, int b) {", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzODQ0NA==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406538444", "bodyText": "Math.max?", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:58:45Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/logs/ThrottlerTests.java", "diffHunk": "@@ -195,6 +396,26 @@ private ThrottlerCalculator wrap(ThrottlerCalculator.Throttler calculatorThrottl\n         return ThrottlerCalculator.builder().throttler(calculatorThrottler).build();\n     }\n \n+    private ThrottlerCalculator wrap(ArrayList<ThrottlerCalculator.Throttler> throttlers) {\n+        return ThrottlerCalculator.builder().throttlers(throttlers).build();\n+    }\n+\n+    private String[] throttlerTags(ThrottlerCalculator.ThrottlerName name)  {\n+        return  new String[] { \"container\", String.valueOf(this.containerId), \"throttler\", name.toString() };\n+    }\n+\n+    private double getThrottlerMetric(ThrottlerCalculator.ThrottlerName name) {\n+        return MetricRegistryUtils.getGauge(MetricsNames.OPERATION_PROCESSOR_DELAY_MILLIS, throttlerTags(name)).value();\n+    }\n+\n+    private static int min(int a, int b) {\n+        return a < b ? a : b;\n+    }\n+\n+    private static int max(int a, int b) {", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzODU4OA==", "url": "https://github.com/pravega/pravega/pull/4646#discussion_r406538588", "bodyText": "Can't you get this from MetricsTags?", "author": "andreipaduroiu", "createdAt": "2020-04-09T23:59:08Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/logs/ThrottlerTests.java", "diffHunk": "@@ -195,6 +396,26 @@ private ThrottlerCalculator wrap(ThrottlerCalculator.Throttler calculatorThrottl\n         return ThrottlerCalculator.builder().throttler(calculatorThrottler).build();\n     }\n \n+    private ThrottlerCalculator wrap(ArrayList<ThrottlerCalculator.Throttler> throttlers) {\n+        return ThrottlerCalculator.builder().throttlers(throttlers).build();\n+    }\n+\n+    private String[] throttlerTags(ThrottlerCalculator.ThrottlerName name)  {", "originalCommit": "ff9a760808414aa7d7f92d2ef88e10de5b24ece8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bb456ec7b744eb2d1980290e4e9984dbe32c42ef", "url": "https://github.com/pravega/pravega/commit/bb456ec7b744eb2d1980290e4e9984dbe32c42ef", "message": "* Addresses comments made in PR 4646.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-10T22:00:11Z", "type": "commit"}, {"oid": "dcd69ce66e7fb5da4e37e67b7c7157d0577a6c04", "url": "https://github.com/pravega/pravega/commit/dcd69ce66e7fb5da4e37e67b7c7157d0577a6c04", "message": "Merge remote-tracking branch 'origin/issue-4273-ss-throttling-metrics' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-10T22:00:35Z", "type": "commit"}, {"oid": "02a8ce507ad33398455cb4899b20b10d820cdfe0", "url": "https://github.com/pravega/pravega/commit/02a8ce507ad33398455cb4899b20b10d820cdfe0", "message": "Merge branch 'master' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-14T15:45:00Z", "type": "commit"}, {"oid": "62e0f0c6dc88b63c963b66114a8d1457ded34619", "url": "https://github.com/pravega/pravega/commit/62e0f0c6dc88b63c963b66114a8d1457ded34619", "message": "Add tests to missed branches.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-15T16:04:48Z", "type": "commit"}, {"oid": "e59c3e2881dc404058e875256409bd186afab3d7", "url": "https://github.com/pravega/pravega/commit/e59c3e2881dc404058e875256409bd186afab3d7", "message": "Merge remote-tracking branch 'origin/issue-4273-ss-throttling-metrics' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-15T16:05:46Z", "type": "commit"}, {"oid": "93d93d557caa83a05626bd2d83124162dbee0b6e", "url": "https://github.com/pravega/pravega/commit/93d93d557caa83a05626bd2d83124162dbee0b6e", "message": "Merge branch 'master' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-15T16:19:19Z", "type": "commit"}, {"oid": "739f3be18f8c7d9c133c078f260aed08d1340f67", "url": "https://github.com/pravega/pravega/commit/739f3be18f8c7d9c133c078f260aed08d1340f67", "message": "Use toNanos() over toMillis due to truncation.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-15T17:18:12Z", "type": "commit"}, {"oid": "1fb50e065668b9290825dc7ec8e7f723540caa4b", "url": "https://github.com/pravega/pravega/commit/1fb50e065668b9290825dc7ec8e7f723540caa4b", "message": "Merge remote-tracking branch 'origin/issue-4273-ss-throttling-metrics' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-15T17:19:08Z", "type": "commit"}, {"oid": "deaa480a8d19f468e8046db2a5d8e42e89569b9a", "url": "https://github.com/pravega/pravega/commit/deaa480a8d19f468e8046db2a5d8e42e89569b9a", "message": "Fix index used to test throttler name.\n\nSigned-off-by: co-jo <colin.hryniowski@unb.ca>", "committedDate": "2020-04-15T18:03:00Z", "type": "commit"}, {"oid": "f31ddee9b819dda1c6709174c223ff0233fd65d7", "url": "https://github.com/pravega/pravega/commit/f31ddee9b819dda1c6709174c223ff0233fd65d7", "message": "Merge branch 'master' into issue-4273-ss-throttling-metrics", "committedDate": "2020-04-16T17:25:45Z", "type": "commit"}]}