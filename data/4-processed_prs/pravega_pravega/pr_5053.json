{"pr_number": 5053, "pr_title": "Issue 5039: (SegmentStore) RollingStorage can trim Header Chunk on FileSystemStorage", "pr_createdAt": "2020-08-10T17:19:14Z", "pr_url": "https://github.com/pravega/pravega/pull/5053", "timeline": [{"oid": "173e5c6aa63c65408477a582359a3bccf389a82a", "url": "https://github.com/pravega/pravega/commit/173e5c6aa63c65408477a582359a3bccf389a82a", "message": "Added ability to \"atomically\" replace files in FileSystemStorage. No unit tests yet.\nRollingStorage: Partially wired in the replace-enabled SyncStorage. Not yet wired up for truncation.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-07T18:20:42Z", "type": "commit"}, {"oid": "294649cbc6dc7af055e748efda756278b8d26b48", "url": "https://github.com/pravega/pravega/commit/294649cbc6dc7af055e748efda756278b8d26b48", "message": "Unit tests for FileSystemStorage.FileSystemStorageWithReplace. Several bugs were fixed as well.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-07T21:24:04Z", "type": "commit"}, {"oid": "d44db476ff46a6b28e903784dc3f028e7fe93b46", "url": "https://github.com/pravega/pravega/commit/d44db476ff46a6b28e903784dc3f028e7fe93b46", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-07T21:29:29Z", "type": "commit"}, {"oid": "9fc78bd4e25551f870f82b5f24b90751aa8f43a0", "url": "https://github.com/pravega/pravega/commit/9fc78bd4e25551f870f82b5f24b90751aa8f43a0", "message": "Integrated in RollingStorage.\nAdded enable/disable config setting.\nUnit tests.\nIntegration tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-10T17:10:34Z", "type": "commit"}, {"oid": "728de99d4a9fa1c61bb9dc67ca20fbd89d724f55", "url": "https://github.com/pravega/pravega/commit/728de99d4a9fa1c61bb9dc67ca20fbd89d724f55", "message": "Code coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-10T19:12:49Z", "type": "commit"}, {"oid": "b24c90f94879d78425af426fc43bb7068ae73e65", "url": "https://github.com/pravega/pravega/commit/b24c90f94879d78425af426fc43bb7068ae73e65", "message": "Code coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-10T19:13:55Z", "type": "commit"}, {"oid": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "url": "https://github.com/pravega/pravega/commit/e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-5039-trim-header-file", "committedDate": "2020-08-10T19:14:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MzYyMg==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469143622", "bodyText": "It might be a big annoying change, but I'd rather adhere to standard terminology and use rename instead of replace. The rename operation according to the standard (POSIX - IEEE Std 1003.1-2017) says [1]:\n\nIf the link named by the new argument exists, it shall be removed and old renamed to new\n\nso it captures the semantics we want. We are not trying to follow the standard strictly here, but sticking to terminology.\n[1] https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html", "author": "fpj", "createdAt": "2020-08-12T09:53:26Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/SyncStorage.java", "diffHunk": "@@ -216,6 +216,40 @@ default SegmentHandle create(String streamSegmentName, SegmentRollingPolicy roll\n      */\n     boolean supportsTruncation();\n \n+    /**\n+     * Gets a value indicating whether this {@link SyncStorage} implementation can replace whole Segments with new contents.\n+     *\n+     * @return True or false.\n+     */\n+    default boolean supportsReplace() {\n+        return false;\n+    }\n+\n+    /**\n+     * Replaces a Segment with the given contents.  Please refer to the actual implementing class for more details with\n+     * respect to behavior, atomicity and recovery mechanisms.\n+     *\n+     * @param segment A {@link SegmentHandle} representing the Segment to replace.\n+     * @param contents A {@link BufferView} representing the new contents of the Segment.\n+     * @throws StreamSegmentNotExistsException When the given Segment does not exist in Storage.\n+     * @throws StorageNotPrimaryException      When this Storage instance is no longer primary for this Segment (it was\n+     *                                         fenced out).\n+     * @throws UnsupportedOperationException   If {@link #supportsReplace()} returns false.\n+     */\n+    default void replace(SegmentHandle segment, BufferView contents) throws StreamSegmentException {", "originalCommit": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMyNjMwMg==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469326302", "bodyText": "But I am not renaming a file here. What I need is to set the contents of a Segment to a given buffer. I have that buffer in contents and this method is expected to set that as the actual contents of segment. Whether or not a rename operation happens behind the scenes to implement this is a different story.\nFor example, in ExtendedS3Storage this may be accomplished by a putObjectRequest that overwrites a target object - no need for rename.\nFor this fix, we do not need or care about renaming segments. We care about \"atomically\" replacing the contents of a segment with some other contents that we have already generated (in memory).", "author": "andreipaduroiu", "createdAt": "2020-08-12T15:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MzYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0ODkyMQ==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469148921", "bodyText": "Since this case is not the regular, expected path, I'd say this log message is at least info.", "author": "fpj", "createdAt": "2020-08-12T10:03:04Z", "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorage.java", "diffHunk": "@@ -458,5 +466,225 @@ private Void doDelete(SegmentHandle handle) throws IOException {\n         throw Exceptions.sneakyThrow(e);\n     }\n \n+    protected boolean isFileNotFoundException(Exception e) {\n+        return e instanceof NoSuchFileException\n+                || e instanceof FileNotFoundException\n+                || e instanceof StreamSegmentNotExistsException;\n+    }\n+\n+    protected Path getPath(String segmentName) {\n+        return Paths.get(config.getRoot(), segmentName);\n+    }\n+\n+    //endregion\n+\n+    //region FileSystemStorageWithReplace\n+\n+    /**\n+     * {@link FileSystemStorage} implementation with \"atomic\" replace support.\n+     *\n+     * The {@link #replace} method works as follows:\n+     * 1. Creates a new temporary file and writes the replacement contents in it.\n+     * 2. Attempts to atomically rename (move) the temp file back into the original file. If unable to, deletes the original\n+     * file and then renames it.\n+     *\n+     * Since there is no guarantee that this operation is atomic, all methods have an auto-recovery built-in, which works\n+     * as follows:\n+     * 1. If the requested segment file does exist, everything works as in {@link FileSystemStorage}. Even if there exist\n+     * a temporary file, the sole existence of the base file indicates that we had an interrupted execution of {@link #replace},\n+     * so we cannot rely on that temporary file's existence.\n+     * 2. If the requested segment file does not exist, and there exists an associated temporary file, then the temporary\n+     * file is renamed back into the original file. This is safe because we only delete the original file after we have\n+     * fully written the temp file, so the latter contains all the data we wish to include.\n+     * 3. If neither the segment file nor the associated temp file exist, then a {@link StreamSegmentNotExistsException}\n+     * is thrown.\n+     */\n+    @VisibleForTesting\n+    static class FileSystemStorageWithReplace extends FileSystemStorage {\n+        @VisibleForTesting\n+        static final String TEMP_SUFFIX = \".replace.tmp\";\n+\n+        private FileSystemStorageWithReplace(FileSystemStorageConfig config) {\n+            super(config);\n+        }\n+\n+        //region FileSystemStorage Overrides\n+\n+        @Override\n+        protected SegmentHandle doCreate(String streamSegmentName) throws IOException {\n+            String tempSegmentName = getTempSegmentName(streamSegmentName);\n+            if (!super.doExists(streamSegmentName) && super.doExists(tempSegmentName)) {\n+                // Segment file does not exist, but temp one does. This represents an incomplete replace operation.\n+                // Finalize it now and report that the Segment does indeed exist.\n+                finalizeRename(getTempSegmentName(streamSegmentName), streamSegmentName);\n+                throw new FileAlreadyExistsException(streamSegmentName);\n+            }\n+\n+            return super.doCreate(streamSegmentName);\n+        }\n+\n+        @Override\n+        protected Void doDelete(SegmentHandle handle) throws IOException {\n+            // Clean up any incomplete replace leftovers.\n+            String tempSegmentName = getTempSegmentName(handle.getSegmentName());\n+            if (super.doExists(tempSegmentName)) {\n+                Files.delete(getPath(tempSegmentName));\n+                try {\n+                    return super.doDelete(handle);\n+                } catch (IOException ex) {\n+                    // It's OK if the segment file does not exist. That is likely the result of a partial replace.\n+                    return null;\n+                }\n+            }\n+\n+            return super.doDelete(handle);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenWrite(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenWrite);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenRead(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenRead);\n+        }\n+\n+        @Override\n+        protected SegmentProperties doGetStreamSegmentInfo(String streamSegmentName) throws IOException {\n+            return withRecovery(streamSegmentName, super::doGetStreamSegmentInfo);\n+        }\n+\n+        @Override\n+        protected Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws IOException {\n+            return withRecovery(sourceSegment, source -> super.doConcat(targetHandle, offset, source));\n+        }\n+\n+        @Override\n+        protected boolean doExists(String streamSegmentName) {\n+            return super.doExists(streamSegmentName) || super.doExists(getTempSegmentName(streamSegmentName));\n+        }\n+\n+        @Override\n+        public boolean supportsReplace() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void replace(@NonNull SegmentHandle segment, @NonNull BufferView contents) throws StreamSegmentException {\n+            String segmentName = segment.getSegmentName();\n+            execute(segment.getSegmentName(), () -> replaceExistingFile(segmentName, contents));\n+        }\n+\n+        @Override\n+        public SyncStorage withReplaceSupport() {\n+            return this;\n+        }\n+\n+        //endregion\n+\n+        private <T, TEx extends Exception> T withRecovery(String segmentName, RecoverableAction<T, TEx> toExecute) throws TEx {\n+            try {\n+                return toExecute.apply(segmentName);\n+            } catch (Exception ex) {\n+                String tmpName = getTempSegmentName(segmentName);\n+                if (isFileNotFoundException(ex) && super.doExists(tmpName)) {\n+                    // Incomplete replace operation detected. Finish it up.\n+                    log.info(\"Incomplete replace operation detected for '{}'. Finalizing.\", segmentName);\n+                    finalizeRename(tmpName, segmentName);\n+\n+                    // Should be done now. Retry original operation.\n+                    log.debug(\"Replace finalized for '{}'. Retrying operation.\", segmentName);\n+                    return toExecute.apply(segmentName);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        private Void replaceExistingFile(String segmentName, BufferView contents) throws IOException, StreamSegmentException {\n+            boolean baseExists = super.doExists(segmentName);\n+            boolean shouldReseal = baseExists && super.getStreamSegmentInfo(segmentName).isSealed();\n+\n+            // Check temp file already exists.\n+            String tmpSegmentName = getTempSegmentName(segmentName);\n+            if (super.doExists(tmpSegmentName)) {\n+                if (baseExists) {\n+                    // We have both a temp file and a segment file. This is most likely the result of an incomplete replace,\n+                    // however we still have the original segment file around. It is safe to delete the temp file now.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Deleting temp file before new replace attempt.\", segmentName);", "originalCommit": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzMzA3NQ==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469333075", "bodyText": "Done.", "author": "andreipaduroiu", "createdAt": "2020-08-12T15:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0ODkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1MDQyMw==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469150423", "bodyText": "Same suggestion about the severity of the log message.", "author": "fpj", "createdAt": "2020-08-12T10:06:01Z", "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorage.java", "diffHunk": "@@ -458,5 +466,225 @@ private Void doDelete(SegmentHandle handle) throws IOException {\n         throw Exceptions.sneakyThrow(e);\n     }\n \n+    protected boolean isFileNotFoundException(Exception e) {\n+        return e instanceof NoSuchFileException\n+                || e instanceof FileNotFoundException\n+                || e instanceof StreamSegmentNotExistsException;\n+    }\n+\n+    protected Path getPath(String segmentName) {\n+        return Paths.get(config.getRoot(), segmentName);\n+    }\n+\n+    //endregion\n+\n+    //region FileSystemStorageWithReplace\n+\n+    /**\n+     * {@link FileSystemStorage} implementation with \"atomic\" replace support.\n+     *\n+     * The {@link #replace} method works as follows:\n+     * 1. Creates a new temporary file and writes the replacement contents in it.\n+     * 2. Attempts to atomically rename (move) the temp file back into the original file. If unable to, deletes the original\n+     * file and then renames it.\n+     *\n+     * Since there is no guarantee that this operation is atomic, all methods have an auto-recovery built-in, which works\n+     * as follows:\n+     * 1. If the requested segment file does exist, everything works as in {@link FileSystemStorage}. Even if there exist\n+     * a temporary file, the sole existence of the base file indicates that we had an interrupted execution of {@link #replace},\n+     * so we cannot rely on that temporary file's existence.\n+     * 2. If the requested segment file does not exist, and there exists an associated temporary file, then the temporary\n+     * file is renamed back into the original file. This is safe because we only delete the original file after we have\n+     * fully written the temp file, so the latter contains all the data we wish to include.\n+     * 3. If neither the segment file nor the associated temp file exist, then a {@link StreamSegmentNotExistsException}\n+     * is thrown.\n+     */\n+    @VisibleForTesting\n+    static class FileSystemStorageWithReplace extends FileSystemStorage {\n+        @VisibleForTesting\n+        static final String TEMP_SUFFIX = \".replace.tmp\";\n+\n+        private FileSystemStorageWithReplace(FileSystemStorageConfig config) {\n+            super(config);\n+        }\n+\n+        //region FileSystemStorage Overrides\n+\n+        @Override\n+        protected SegmentHandle doCreate(String streamSegmentName) throws IOException {\n+            String tempSegmentName = getTempSegmentName(streamSegmentName);\n+            if (!super.doExists(streamSegmentName) && super.doExists(tempSegmentName)) {\n+                // Segment file does not exist, but temp one does. This represents an incomplete replace operation.\n+                // Finalize it now and report that the Segment does indeed exist.\n+                finalizeRename(getTempSegmentName(streamSegmentName), streamSegmentName);\n+                throw new FileAlreadyExistsException(streamSegmentName);\n+            }\n+\n+            return super.doCreate(streamSegmentName);\n+        }\n+\n+        @Override\n+        protected Void doDelete(SegmentHandle handle) throws IOException {\n+            // Clean up any incomplete replace leftovers.\n+            String tempSegmentName = getTempSegmentName(handle.getSegmentName());\n+            if (super.doExists(tempSegmentName)) {\n+                Files.delete(getPath(tempSegmentName));\n+                try {\n+                    return super.doDelete(handle);\n+                } catch (IOException ex) {\n+                    // It's OK if the segment file does not exist. That is likely the result of a partial replace.\n+                    return null;\n+                }\n+            }\n+\n+            return super.doDelete(handle);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenWrite(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenWrite);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenRead(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenRead);\n+        }\n+\n+        @Override\n+        protected SegmentProperties doGetStreamSegmentInfo(String streamSegmentName) throws IOException {\n+            return withRecovery(streamSegmentName, super::doGetStreamSegmentInfo);\n+        }\n+\n+        @Override\n+        protected Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws IOException {\n+            return withRecovery(sourceSegment, source -> super.doConcat(targetHandle, offset, source));\n+        }\n+\n+        @Override\n+        protected boolean doExists(String streamSegmentName) {\n+            return super.doExists(streamSegmentName) || super.doExists(getTempSegmentName(streamSegmentName));\n+        }\n+\n+        @Override\n+        public boolean supportsReplace() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void replace(@NonNull SegmentHandle segment, @NonNull BufferView contents) throws StreamSegmentException {\n+            String segmentName = segment.getSegmentName();\n+            execute(segment.getSegmentName(), () -> replaceExistingFile(segmentName, contents));\n+        }\n+\n+        @Override\n+        public SyncStorage withReplaceSupport() {\n+            return this;\n+        }\n+\n+        //endregion\n+\n+        private <T, TEx extends Exception> T withRecovery(String segmentName, RecoverableAction<T, TEx> toExecute) throws TEx {\n+            try {\n+                return toExecute.apply(segmentName);\n+            } catch (Exception ex) {\n+                String tmpName = getTempSegmentName(segmentName);\n+                if (isFileNotFoundException(ex) && super.doExists(tmpName)) {\n+                    // Incomplete replace operation detected. Finish it up.\n+                    log.info(\"Incomplete replace operation detected for '{}'. Finalizing.\", segmentName);\n+                    finalizeRename(tmpName, segmentName);\n+\n+                    // Should be done now. Retry original operation.\n+                    log.debug(\"Replace finalized for '{}'. Retrying operation.\", segmentName);\n+                    return toExecute.apply(segmentName);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        private Void replaceExistingFile(String segmentName, BufferView contents) throws IOException, StreamSegmentException {\n+            boolean baseExists = super.doExists(segmentName);\n+            boolean shouldReseal = baseExists && super.getStreamSegmentInfo(segmentName).isSealed();\n+\n+            // Check temp file already exists.\n+            String tmpSegmentName = getTempSegmentName(segmentName);\n+            if (super.doExists(tmpSegmentName)) {\n+                if (baseExists) {\n+                    // We have both a temp file and a segment file. This is most likely the result of an incomplete replace,\n+                    // however we still have the original segment file around. It is safe to delete the temp file now.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Deleting temp file before new replace attempt.\", segmentName);\n+                    super.doDelete(super.doOpenWrite(tmpSegmentName));\n+                } else {\n+                    // Temp file exists, but the segment file does not. This may be the result of an incomplete replace,\n+                    // in which case we need to finalize that one to prevent deleting (what could be) the only persisted\n+                    // copy of our data.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Finalizing before new replace attempt.\", segmentName);", "originalCommit": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MjI2OA==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469162268", "bodyText": "When we say On Windows..., is it referring to the Windows implementation of the JVM or a Windows file system (FAT, NTFS)? I ask because it is the LTS implementation that needs to implement rename, right?\nAlso, is the behavior reflected here documented anywhere we can point to or was this validated manually?", "author": "fpj", "createdAt": "2020-08-12T10:29:13Z", "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorage.java", "diffHunk": "@@ -458,5 +466,225 @@ private Void doDelete(SegmentHandle handle) throws IOException {\n         throw Exceptions.sneakyThrow(e);\n     }\n \n+    protected boolean isFileNotFoundException(Exception e) {\n+        return e instanceof NoSuchFileException\n+                || e instanceof FileNotFoundException\n+                || e instanceof StreamSegmentNotExistsException;\n+    }\n+\n+    protected Path getPath(String segmentName) {\n+        return Paths.get(config.getRoot(), segmentName);\n+    }\n+\n+    //endregion\n+\n+    //region FileSystemStorageWithReplace\n+\n+    /**\n+     * {@link FileSystemStorage} implementation with \"atomic\" replace support.\n+     *\n+     * The {@link #replace} method works as follows:\n+     * 1. Creates a new temporary file and writes the replacement contents in it.\n+     * 2. Attempts to atomically rename (move) the temp file back into the original file. If unable to, deletes the original\n+     * file and then renames it.\n+     *\n+     * Since there is no guarantee that this operation is atomic, all methods have an auto-recovery built-in, which works\n+     * as follows:\n+     * 1. If the requested segment file does exist, everything works as in {@link FileSystemStorage}. Even if there exist\n+     * a temporary file, the sole existence of the base file indicates that we had an interrupted execution of {@link #replace},\n+     * so we cannot rely on that temporary file's existence.\n+     * 2. If the requested segment file does not exist, and there exists an associated temporary file, then the temporary\n+     * file is renamed back into the original file. This is safe because we only delete the original file after we have\n+     * fully written the temp file, so the latter contains all the data we wish to include.\n+     * 3. If neither the segment file nor the associated temp file exist, then a {@link StreamSegmentNotExistsException}\n+     * is thrown.\n+     */\n+    @VisibleForTesting\n+    static class FileSystemStorageWithReplace extends FileSystemStorage {\n+        @VisibleForTesting\n+        static final String TEMP_SUFFIX = \".replace.tmp\";\n+\n+        private FileSystemStorageWithReplace(FileSystemStorageConfig config) {\n+            super(config);\n+        }\n+\n+        //region FileSystemStorage Overrides\n+\n+        @Override\n+        protected SegmentHandle doCreate(String streamSegmentName) throws IOException {\n+            String tempSegmentName = getTempSegmentName(streamSegmentName);\n+            if (!super.doExists(streamSegmentName) && super.doExists(tempSegmentName)) {\n+                // Segment file does not exist, but temp one does. This represents an incomplete replace operation.\n+                // Finalize it now and report that the Segment does indeed exist.\n+                finalizeRename(getTempSegmentName(streamSegmentName), streamSegmentName);\n+                throw new FileAlreadyExistsException(streamSegmentName);\n+            }\n+\n+            return super.doCreate(streamSegmentName);\n+        }\n+\n+        @Override\n+        protected Void doDelete(SegmentHandle handle) throws IOException {\n+            // Clean up any incomplete replace leftovers.\n+            String tempSegmentName = getTempSegmentName(handle.getSegmentName());\n+            if (super.doExists(tempSegmentName)) {\n+                Files.delete(getPath(tempSegmentName));\n+                try {\n+                    return super.doDelete(handle);\n+                } catch (IOException ex) {\n+                    // It's OK if the segment file does not exist. That is likely the result of a partial replace.\n+                    return null;\n+                }\n+            }\n+\n+            return super.doDelete(handle);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenWrite(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenWrite);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenRead(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenRead);\n+        }\n+\n+        @Override\n+        protected SegmentProperties doGetStreamSegmentInfo(String streamSegmentName) throws IOException {\n+            return withRecovery(streamSegmentName, super::doGetStreamSegmentInfo);\n+        }\n+\n+        @Override\n+        protected Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws IOException {\n+            return withRecovery(sourceSegment, source -> super.doConcat(targetHandle, offset, source));\n+        }\n+\n+        @Override\n+        protected boolean doExists(String streamSegmentName) {\n+            return super.doExists(streamSegmentName) || super.doExists(getTempSegmentName(streamSegmentName));\n+        }\n+\n+        @Override\n+        public boolean supportsReplace() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void replace(@NonNull SegmentHandle segment, @NonNull BufferView contents) throws StreamSegmentException {\n+            String segmentName = segment.getSegmentName();\n+            execute(segment.getSegmentName(), () -> replaceExistingFile(segmentName, contents));\n+        }\n+\n+        @Override\n+        public SyncStorage withReplaceSupport() {\n+            return this;\n+        }\n+\n+        //endregion\n+\n+        private <T, TEx extends Exception> T withRecovery(String segmentName, RecoverableAction<T, TEx> toExecute) throws TEx {\n+            try {\n+                return toExecute.apply(segmentName);\n+            } catch (Exception ex) {\n+                String tmpName = getTempSegmentName(segmentName);\n+                if (isFileNotFoundException(ex) && super.doExists(tmpName)) {\n+                    // Incomplete replace operation detected. Finish it up.\n+                    log.info(\"Incomplete replace operation detected for '{}'. Finalizing.\", segmentName);\n+                    finalizeRename(tmpName, segmentName);\n+\n+                    // Should be done now. Retry original operation.\n+                    log.debug(\"Replace finalized for '{}'. Retrying operation.\", segmentName);\n+                    return toExecute.apply(segmentName);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        private Void replaceExistingFile(String segmentName, BufferView contents) throws IOException, StreamSegmentException {\n+            boolean baseExists = super.doExists(segmentName);\n+            boolean shouldReseal = baseExists && super.getStreamSegmentInfo(segmentName).isSealed();\n+\n+            // Check temp file already exists.\n+            String tmpSegmentName = getTempSegmentName(segmentName);\n+            if (super.doExists(tmpSegmentName)) {\n+                if (baseExists) {\n+                    // We have both a temp file and a segment file. This is most likely the result of an incomplete replace,\n+                    // however we still have the original segment file around. It is safe to delete the temp file now.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Deleting temp file before new replace attempt.\", segmentName);\n+                    super.doDelete(super.doOpenWrite(tmpSegmentName));\n+                } else {\n+                    // Temp file exists, but the segment file does not. This may be the result of an incomplete replace,\n+                    // in which case we need to finalize that one to prevent deleting (what could be) the only persisted\n+                    // copy of our data.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Finalizing before new replace attempt.\", segmentName);\n+                    finalizeRename(tmpSegmentName, segmentName);\n+                }\n+            } else if (!baseExists) {\n+                throw new StreamSegmentNotExistsException(segmentName);\n+            }\n+\n+            // Write given contents to temp file.\n+            val tmpHandle = super.doCreate(tmpSegmentName);\n+            try {\n+                super.doWrite(tmpHandle, 0, contents.getReader(), contents.getLength());\n+                if (shouldReseal) {\n+                    super.doSeal(tmpHandle);\n+                }\n+            } catch (Exception ex) {\n+                log.warn(\"Unable to write to temporary file when attempting to replace '{}'. Original file has not been touched. Cleaning up.\",\n+                        segmentName, ex);\n+                super.doDelete(tmpHandle);\n+                throw ex;\n+            }\n+\n+            // Sanity check #1 (only executes in tests).\n+            assert super.doGetStreamSegmentInfo(tmpSegmentName).getLength() == contents.getLength();\n+\n+            // Rename file. After this is done, the replace operation is complete.\n+            finalizeRename(tmpSegmentName, segmentName);\n+\n+            // Sanity check #2 (only executes in tests).\n+            assert super.doGetStreamSegmentInfo(segmentName).getLength() == contents.getLength();\n+            return null;\n+        }\n+\n+        @SneakyThrows(StreamSegmentReplaceException.class)\n+        private void finalizeRename(String fromSegmentName, String toSegmentName) {\n+            val fromFile = getPath(fromSegmentName).toFile().getAbsoluteFile();\n+            val toFile = getPath(toSegmentName).toFile().getAbsoluteFile();\n+            boolean renamed = fromFile.renameTo(toFile);\n+            if (!renamed) {\n+                // On Windows, renameTo does not replace.", "originalCommit": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMyNDA5Ng==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469324096", "bodyText": "The Javadoc for File.renameTo states that this operation may not be atomic or may not succeed if a file with the destination name already exists, so that is enough to warrant the if block and the subsequent 2-step rename.\nWith respect to Windows, I am unaware of the inner details on what the requirements are. For this code, I got inspired from the AtomicFileOutputStream (both in the HDFS repository and ZooKeeper repository - they look nearly identical save for a few diffs).", "author": "andreipaduroiu", "createdAt": "2020-08-12T14:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MjI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzNDE2NA==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469334164", "bodyText": "Added some clarifying comment on this.", "author": "andreipaduroiu", "createdAt": "2020-08-12T15:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MjI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2NjA0Mw==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469166043", "bodyText": "Maybe add a debug or trace log to record the rename.", "author": "fpj", "createdAt": "2020-08-12T10:36:52Z", "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorage.java", "diffHunk": "@@ -458,5 +466,225 @@ private Void doDelete(SegmentHandle handle) throws IOException {\n         throw Exceptions.sneakyThrow(e);\n     }\n \n+    protected boolean isFileNotFoundException(Exception e) {\n+        return e instanceof NoSuchFileException\n+                || e instanceof FileNotFoundException\n+                || e instanceof StreamSegmentNotExistsException;\n+    }\n+\n+    protected Path getPath(String segmentName) {\n+        return Paths.get(config.getRoot(), segmentName);\n+    }\n+\n+    //endregion\n+\n+    //region FileSystemStorageWithReplace\n+\n+    /**\n+     * {@link FileSystemStorage} implementation with \"atomic\" replace support.\n+     *\n+     * The {@link #replace} method works as follows:\n+     * 1. Creates a new temporary file and writes the replacement contents in it.\n+     * 2. Attempts to atomically rename (move) the temp file back into the original file. If unable to, deletes the original\n+     * file and then renames it.\n+     *\n+     * Since there is no guarantee that this operation is atomic, all methods have an auto-recovery built-in, which works\n+     * as follows:\n+     * 1. If the requested segment file does exist, everything works as in {@link FileSystemStorage}. Even if there exist\n+     * a temporary file, the sole existence of the base file indicates that we had an interrupted execution of {@link #replace},\n+     * so we cannot rely on that temporary file's existence.\n+     * 2. If the requested segment file does not exist, and there exists an associated temporary file, then the temporary\n+     * file is renamed back into the original file. This is safe because we only delete the original file after we have\n+     * fully written the temp file, so the latter contains all the data we wish to include.\n+     * 3. If neither the segment file nor the associated temp file exist, then a {@link StreamSegmentNotExistsException}\n+     * is thrown.\n+     */\n+    @VisibleForTesting\n+    static class FileSystemStorageWithReplace extends FileSystemStorage {\n+        @VisibleForTesting\n+        static final String TEMP_SUFFIX = \".replace.tmp\";\n+\n+        private FileSystemStorageWithReplace(FileSystemStorageConfig config) {\n+            super(config);\n+        }\n+\n+        //region FileSystemStorage Overrides\n+\n+        @Override\n+        protected SegmentHandle doCreate(String streamSegmentName) throws IOException {\n+            String tempSegmentName = getTempSegmentName(streamSegmentName);\n+            if (!super.doExists(streamSegmentName) && super.doExists(tempSegmentName)) {\n+                // Segment file does not exist, but temp one does. This represents an incomplete replace operation.\n+                // Finalize it now and report that the Segment does indeed exist.\n+                finalizeRename(getTempSegmentName(streamSegmentName), streamSegmentName);\n+                throw new FileAlreadyExistsException(streamSegmentName);\n+            }\n+\n+            return super.doCreate(streamSegmentName);\n+        }\n+\n+        @Override\n+        protected Void doDelete(SegmentHandle handle) throws IOException {\n+            // Clean up any incomplete replace leftovers.\n+            String tempSegmentName = getTempSegmentName(handle.getSegmentName());\n+            if (super.doExists(tempSegmentName)) {\n+                Files.delete(getPath(tempSegmentName));\n+                try {\n+                    return super.doDelete(handle);\n+                } catch (IOException ex) {\n+                    // It's OK if the segment file does not exist. That is likely the result of a partial replace.\n+                    return null;\n+                }\n+            }\n+\n+            return super.doDelete(handle);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenWrite(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenWrite);\n+        }\n+\n+        @Override\n+        protected SegmentHandle doOpenRead(String streamSegmentName) throws StreamSegmentNotExistsException {\n+            return withRecovery(streamSegmentName, super::doOpenRead);\n+        }\n+\n+        @Override\n+        protected SegmentProperties doGetStreamSegmentInfo(String streamSegmentName) throws IOException {\n+            return withRecovery(streamSegmentName, super::doGetStreamSegmentInfo);\n+        }\n+\n+        @Override\n+        protected Void doConcat(SegmentHandle targetHandle, long offset, String sourceSegment) throws IOException {\n+            return withRecovery(sourceSegment, source -> super.doConcat(targetHandle, offset, source));\n+        }\n+\n+        @Override\n+        protected boolean doExists(String streamSegmentName) {\n+            return super.doExists(streamSegmentName) || super.doExists(getTempSegmentName(streamSegmentName));\n+        }\n+\n+        @Override\n+        public boolean supportsReplace() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void replace(@NonNull SegmentHandle segment, @NonNull BufferView contents) throws StreamSegmentException {\n+            String segmentName = segment.getSegmentName();\n+            execute(segment.getSegmentName(), () -> replaceExistingFile(segmentName, contents));\n+        }\n+\n+        @Override\n+        public SyncStorage withReplaceSupport() {\n+            return this;\n+        }\n+\n+        //endregion\n+\n+        private <T, TEx extends Exception> T withRecovery(String segmentName, RecoverableAction<T, TEx> toExecute) throws TEx {\n+            try {\n+                return toExecute.apply(segmentName);\n+            } catch (Exception ex) {\n+                String tmpName = getTempSegmentName(segmentName);\n+                if (isFileNotFoundException(ex) && super.doExists(tmpName)) {\n+                    // Incomplete replace operation detected. Finish it up.\n+                    log.info(\"Incomplete replace operation detected for '{}'. Finalizing.\", segmentName);\n+                    finalizeRename(tmpName, segmentName);\n+\n+                    // Should be done now. Retry original operation.\n+                    log.debug(\"Replace finalized for '{}'. Retrying operation.\", segmentName);\n+                    return toExecute.apply(segmentName);\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        private Void replaceExistingFile(String segmentName, BufferView contents) throws IOException, StreamSegmentException {\n+            boolean baseExists = super.doExists(segmentName);\n+            boolean shouldReseal = baseExists && super.getStreamSegmentInfo(segmentName).isSealed();\n+\n+            // Check temp file already exists.\n+            String tmpSegmentName = getTempSegmentName(segmentName);\n+            if (super.doExists(tmpSegmentName)) {\n+                if (baseExists) {\n+                    // We have both a temp file and a segment file. This is most likely the result of an incomplete replace,\n+                    // however we still have the original segment file around. It is safe to delete the temp file now.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Deleting temp file before new replace attempt.\", segmentName);\n+                    super.doDelete(super.doOpenWrite(tmpSegmentName));\n+                } else {\n+                    // Temp file exists, but the segment file does not. This may be the result of an incomplete replace,\n+                    // in which case we need to finalize that one to prevent deleting (what could be) the only persisted\n+                    // copy of our data.\n+                    log.debug(\"Incomplete replace operation detected for '{}'. Finalizing before new replace attempt.\", segmentName);\n+                    finalizeRename(tmpSegmentName, segmentName);\n+                }\n+            } else if (!baseExists) {\n+                throw new StreamSegmentNotExistsException(segmentName);\n+            }\n+\n+            // Write given contents to temp file.\n+            val tmpHandle = super.doCreate(tmpSegmentName);\n+            try {\n+                super.doWrite(tmpHandle, 0, contents.getReader(), contents.getLength());\n+                if (shouldReseal) {\n+                    super.doSeal(tmpHandle);\n+                }\n+            } catch (Exception ex) {\n+                log.warn(\"Unable to write to temporary file when attempting to replace '{}'. Original file has not been touched. Cleaning up.\",\n+                        segmentName, ex);\n+                super.doDelete(tmpHandle);\n+                throw ex;\n+            }\n+\n+            // Sanity check #1 (only executes in tests).\n+            assert super.doGetStreamSegmentInfo(tmpSegmentName).getLength() == contents.getLength();\n+\n+            // Rename file. After this is done, the replace operation is complete.\n+            finalizeRename(tmpSegmentName, segmentName);\n+\n+            // Sanity check #2 (only executes in tests).\n+            assert super.doGetStreamSegmentInfo(segmentName).getLength() == contents.getLength();\n+            return null;\n+        }\n+\n+        @SneakyThrows(StreamSegmentReplaceException.class)\n+        private void finalizeRename(String fromSegmentName, String toSegmentName) {", "originalCommit": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzNDI0MA==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469334240", "bodyText": "Done.", "author": "andreipaduroiu", "createdAt": "2020-08-12T15:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2NjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2OTEzNA==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469169134", "bodyText": "This is the only call that feels odd when comparing to the other calls in the interface. To be able to get rid of it, we would need to make FileSystemStorage support it directly rather than have a derived class FileSystemStorageWithReplace, which seems possible and it is not clear to me whether it is incorrect or simply undesirable.", "author": "fpj", "createdAt": "2020-08-12T10:43:28Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/SyncStorage.java", "diffHunk": "@@ -216,6 +216,40 @@ default SegmentHandle create(String streamSegmentName, SegmentRollingPolicy roll\n      */\n     boolean supportsTruncation();\n \n+    /**\n+     * Gets a value indicating whether this {@link SyncStorage} implementation can replace whole Segments with new contents.\n+     *\n+     * @return True or false.\n+     */\n+    default boolean supportsReplace() {\n+        return false;\n+    }\n+\n+    /**\n+     * Replaces a Segment with the given contents.  Please refer to the actual implementing class for more details with\n+     * respect to behavior, atomicity and recovery mechanisms.\n+     *\n+     * @param segment A {@link SegmentHandle} representing the Segment to replace.\n+     * @param contents A {@link BufferView} representing the new contents of the Segment.\n+     * @throws StreamSegmentNotExistsException When the given Segment does not exist in Storage.\n+     * @throws StorageNotPrimaryException      When this Storage instance is no longer primary for this Segment (it was\n+     *                                         fenced out).\n+     * @throws UnsupportedOperationException   If {@link #supportsReplace()} returns false.\n+     */\n+    default void replace(SegmentHandle segment, BufferView contents) throws StreamSegmentException {\n+        throw new UnsupportedOperationException(\"replace() is not implemented\");\n+    }\n+\n+    /**\n+     * Returns a new {@link SyncStorage} instance for the same Storage type as this one, but with {@link #replace} support\n+     * enabled. If there is no such implementation, this instance is returned.\n+     *\n+     * @return Either this instance or a new {@link SyncStorage} instance based on this one that can perform replaces.\n+     */\n+    default SyncStorage withReplaceSupport() {", "originalCommit": "e662cb359cdd10b7ac2eec36ef0bbceba157a7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMyOTk1MQ==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r469329951", "bodyText": "FileSystemWithReplace does a bit of extra work for every file access and catches certain exceptions. To prevent that overhead from happening on every single LTS call which could negatively affect performance (and open the door for more hacks in the future (since it's easy to use such functionality once there), I decided to explicitly offer this as a separate piece of functionality. The only place where this functionality is required is in RollingStorage for the header file. Furthermore, SyncStorage is the internal LTS contract, not the external one (that one is Storage) so nobody else outside of RollingStorage would even have access to this.\nThis is not a long-term solution. We are doing it as a short-term fix until SLTS will replace RollingStorage (SLTS does not have the problem that this PR is fixing).\nIn other words, I'm deliberately trying to make it hard for people to accidentally use this feature and not slip through future code reviews unnoticed. We do not plan to support this functionality long term.", "author": "andreipaduroiu", "createdAt": "2020-08-12T15:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2OTEzNA=="}], "type": "inlineReview"}, {"oid": "144d7770ccbd19b340e4a23552d89a9179d09571", "url": "https://github.com/pravega/pravega/commit/144d7770ccbd19b340e4a23552d89a9179d09571", "message": "More logging.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-12T15:13:20Z", "type": "commit"}, {"oid": "4ab3905766b9d2bc9aeafb3262f720819d8078ef", "url": "https://github.com/pravega/pravega/commit/4ab3905766b9d2bc9aeafb3262f720819d8078ef", "message": "Merge branch 'master' into issue-5039-trim-header-file", "committedDate": "2020-08-12T22:27:36Z", "type": "commit"}, {"oid": "b9cf0cc375fd247b4e30dd7b1dfb6d0dd919500b", "url": "https://github.com/pravega/pravega/commit/b9cf0cc375fd247b4e30dd7b1dfb6d0dd919500b", "message": "Merge branch 'master' into issue-5039-trim-header-file", "committedDate": "2020-08-13T14:40:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxNDcwNw==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r470014707", "bodyText": "To confirm one thing: are we omitting this configuration in config.properties intentionally?\nAlso, is the full property name filesystem.replace.enable?\nAnd, to be consistent with other properties, it should be enable rather than enabled.", "author": "fpj", "createdAt": "2020-08-13T14:56:21Z", "path": "bindings/src/main/java/io/pravega/storage/filesystem/FileSystemStorageConfig.java", "diffHunk": "@@ -24,6 +24,7 @@\n     //region Config Names\n \n     public static final Property<String> ROOT = Property.named(\"root\", \"/fs/\");\n+    public static final Property<Boolean> REPLACE_ENABLED = Property.named(\"replace.enabled\", false);", "originalCommit": "b9cf0cc375fd247b4e30dd7b1dfb6d0dd919500b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzOTQ0Mw==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r470039443", "bodyText": "is the full property name filesystem.replace.enable\n\nYes.\n\nare we omitting this configuration in config.properties intentionally?\n\nYes. This is to support a stop-gap fix for RollingStorage which will not be needed once SLTS will replace it. I do not want to advertise it to potential users and stir confusion when it will not be there anymore. I do want it configurable in case it causes issues and someone wants to disable it until a fix is found.", "author": "andreipaduroiu", "createdAt": "2020-08-13T15:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxNDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MjQ2MA==", "url": "https://github.com/pravega/pravega/pull/5053#discussion_r470042460", "bodyText": "it should be enable rather than enabled.\n\nFixed.", "author": "andreipaduroiu", "createdAt": "2020-08-13T15:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxNDcwNw=="}], "type": "inlineReview"}, {"oid": "c94bf9974d48d2fc01dac7ff76401c0d92e106d7", "url": "https://github.com/pravega/pravega/commit/c94bf9974d48d2fc01dac7ff76401c0d92e106d7", "message": "Fixed config property name.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-08-13T15:34:47Z", "type": "commit"}, {"oid": "821e52427fcf8ee2f999e089544f8f6fd9313e83", "url": "https://github.com/pravega/pravega/commit/821e52427fcf8ee2f999e089544f8f6fd9313e83", "message": "Merge branch 'master' into issue-5039-trim-header-file", "committedDate": "2020-08-13T22:09:25Z", "type": "commit"}, {"oid": "3cc55788c7ba3e6a598c86057671da01b2107827", "url": "https://github.com/pravega/pravega/commit/3cc55788c7ba3e6a598c86057671da01b2107827", "message": "Merge branch 'master' into issue-5039-trim-header-file", "committedDate": "2020-08-14T10:13:50Z", "type": "commit"}, {"oid": "2f5035d378622082b1476dbfa981a04516b640fd", "url": "https://github.com/pravega/pravega/commit/2f5035d378622082b1476dbfa981a04516b640fd", "message": "Merge branch 'master' into issue-5039-trim-header-file", "committedDate": "2020-08-14T14:46:21Z", "type": "commit"}]}