{"pr_number": 4768, "pr_title": "Issue 4774: Optimize reader computations", "pr_createdAt": "2020-05-04T14:11:13Z", "pr_url": "https://github.com/pravega/pravega/pull/4768", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODUyMw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r420998523", "bodyText": "Using a member variable is error prone. (In fact there is a case this logic does not cover: if the segments change as a result of calling updateGroupStateIfNeeded, the next time through the above while loop it will pass in stale data resulting in an invalid state.)\nInstead it may be better to just use a local variables by computing the position on 128 an passing it into updateGroupStateIfNeeded, then modifying the offset for the segment read from before returning it.", "author": "tkaitchuck", "createdAt": "2020-05-06T18:21:04Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +156,8 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        lastPosition = getPosition();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEyNTAzMA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421125030", "bodyText": "Maybe I'm mistaken, but your suggestion implies that we should be able to \"update\" the offsets of a PositionImpl object in some way, so we don't have to instantiate it twice anyway, right? I don't know if this is possible at the moment, as this object seems to be read-only and uses unmodifiable collections in its getters.", "author": "RaulGracia", "createdAt": "2020-05-06T22:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MTEzOQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422281139", "bodyText": "I think we can avoid this. See my comments below.", "author": "tkaitchuck", "createdAt": "2020-05-08T17:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDY4Nw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421000687", "bodyText": "I optimized this method, I don't think this reordering is needed anymore.", "author": "tkaitchuck", "createdAt": "2020-05-06T18:24:42Z", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -339,15 +348,15 @@ private boolean shouldAcquireSegment() throws ReaderNotInReaderGroupException {\n             if (acquireTimer.hasRemaining()) {\n                 return false;\n             }\n-            if (state.getCheckpointForReader(readerId) != null) {\n-                return false;\n-            }\n             if (state.getNumberOfUnassignedSegments() == 0) {\n                 if (doesReaderOwnTooManySegments(state)) {\n                     acquireTimer.reset(calculateAcquireTime(readerId, state));\n                 }\n                 return false;\n             }\n+            if (state.getCheckpointForReader(readerId) != null) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExNTY0NA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421115644", "bodyText": "It does if acquireTimer.hasRemaining() is false quite often, which seems to be the case. By doing this, we are preventing the execution of getCheckpointForReader() thanks to the modification in the implementation of doesReaderOwnTooManySegments. If it finally turns out that there is a problem in the way acquireTimer is being set, then we can fix it and revert this change.", "author": "RaulGracia", "createdAt": "2020-05-06T21:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjUxNw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421002517", "bodyText": "I am confused by this, because this method should only be invoked once per checkpoint interval. If that's set to say 20sec then this new time logic is totally redundant. Am I missing something?", "author": "tkaitchuck", "createdAt": "2020-05-06T18:27:50Z", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -213,13 +216,19 @@ Segment findSegmentToReleaseIfRequired() {\n      * the reader with the least assigned to it.\n      */\n     private boolean doesReaderOwnTooManySegments(ReaderGroupState state) {\n-        Map<String, Double> sizesOfAssignemnts = state.getRelativeSizes();\n+        // The previous calculation for this method is cached during TIME_UNIT to prevent excessive per-event computations.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExNDc1NQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r421114755", "bodyText": "You are right, this method is being invoked much more often than it should, as I understand its goal. This method is invoked in two different places, and the one that takes a lot of CPU cycles comes from shouldAcquireSegment(), which as you can see, it can be potentially invoked on every read event only if acquireTimer.hasRemaining() is false most of the time, which seems to be what is going on according to the flamegraphs. The acquireTimer should be generally in the order of seconds, right? So maybe I can spend some more time to see if this timer is incorrectly set at some point.", "author": "RaulGracia", "createdAt": "2020-05-06T21:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzAwMA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422277000", "bodyText": "Replace this with a standard for loop. It will be faster.", "author": "tkaitchuck", "createdAt": "2020-05-08T17:41:07Z", "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -97,12 +97,12 @@ void beginNewCheckpoint(String checkpointId, Set<String> currentReaders, Map<Seg\n     }\n     \n     String getCheckpointForReader(String readerName) {\n-        OptionalInt min = getCheckpointsForReader(readerName).stream().mapToInt(checkpoints::indexOf).min();\n-        if (min.isPresent()) {\n-            return checkpoints.get(min.getAsInt());\n-        } else {\n+        List<String> checkpointsForReader = getCheckpointsForReader(readerName);\n+        if (checkpointsForReader.isEmpty()) {\n             return null;\n         }\n+        OptionalInt min = checkpointsForReader.stream().mapToInt(checkpoints::indexOf).min();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NTgzOQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422285839", "bodyText": "Also if the checkpoints can be ordered, we can eliminate this loop all together and just take the first element from the list.", "author": "tkaitchuck", "createdAt": "2020-05-08T17:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0MzkwNg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424443906", "bodyText": "Fixed.", "author": "RaulGracia", "createdAt": "2020-05-13T13:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzQ1NQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422277455", "bodyText": "This does not need to be an atomic reference, it is guarded by the readers lock, so it can be re-assigned.", "author": "tkaitchuck", "createdAt": "2020-05-08T17:42:05Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -73,16 +74,19 @@\n     private boolean closed;\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n+    // Ranges map is heavily used to build Position objects that are returned to the client. While there is no change\n+    // in segment distribution, we reuse the same map instance for performance reasons. But this map should have a\n+    // copy-on-write behavior to do not impact all the Position objects referencing the previous version of it.\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private final AtomicReference<Map<Segment, Range>> ranges = new AtomicReference<>(new HashMap<>());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0NDAwMg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424444002", "bodyText": "Done.", "author": "RaulGracia", "createdAt": "2020-05-13T13:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NzQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3ODE3Nw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422278177", "bodyText": "Let's make ownedSegments a List<Entry<Segment, Long>> and adapt positionImpl to store this. This will be much cheaper to construct.", "author": "tkaitchuck", "createdAt": "2020-05-08T17:43:34Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -172,11 +179,12 @@ private void blockFor(long timeoutMs) {\n     }\n \n     private PositionInternal getPosition() {\n-        Map<Segment, Long> ownedSegments = new HashMap<>(sealedSegments);\n+        Map<Segment, Long> ownedSegments = new HashMap<>(sealedSegments.size() + readers.size());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0Njg4Mw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424446883", "bodyText": "I did that change but didn't show much improvement. Instead, I opted for another kind of optimization in which ownedSegments is re-used and we batch the changes of offsets for every read. A set of Position objects that reference the same ownedSegments object, will also have a reference to a list of  List<Entry<Segment, Long>> segmentOffsetUpdates. Each Position object will then lazily apply the updates to segment offsets up to the point the event was read. This has proved to make readers much faster reading small events, specially when multiple segments are involved.", "author": "RaulGracia", "createdAt": "2020-05-13T13:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3ODE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MzkzMw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422283933", "bodyText": "Rather than passing this in, we can probably avoid creating it all together. position is used in four places:\n\non line 209 where the reader is checkpointing. (This is rare and we can call getPosition() inside of this if without concern)\non line 218. This is the same situation as the above. It only occurs on checkpoint.\nwhen calling acquireSegmentsIfNeeded. However this method doesn't actually use the position passed in unless a timer has passed. So perhaps having this method call shouldAquireSegment first would avoid the need for position most of the time.\nupdateLagIfNeeded here the situation is the same as the above, it's based on a timer. So we could easily have a block that does:\n\nif (shouldAquireSegment() || shouldUpdateLag()) {\n    PositionImpl position = getPosition();\n    // The code currently in lines 231-235 here.\n}", "author": "tkaitchuck", "createdAt": "2020-05-08T17:55:09Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -196,8 +204,7 @@ private PositionInternal getPosition() {\n      * have been persisted.\n      */\n     @GuardedBy(\"readers\")\n-    private String updateGroupStateIfNeeded() throws ReaderNotInReaderGroupException {\n-        PositionInternal position = (lastPosition == null) ? getPosition() : lastPosition;\n+    private String updateGroupStateIfNeeded(PositionInternal position) throws ReaderNotInReaderGroupException {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0NzQxMg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424447412", "bodyText": "Thanks, I have applied this change (with some additions to that condition).", "author": "RaulGracia", "createdAt": "2020-05-13T13:42:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MzkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjQ0Mg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422286442", "bodyText": "Let's just make this into a class of it's own. It muddies things to have it here.", "author": "tkaitchuck", "createdAt": "2020-05-08T17:59:54Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -377,14 +386,36 @@ public Type fetchEvent(EventPointer pointer) throws NoSuchEventException {\n             return ImmutableList.copyOf(readers);\n         }\n     }\n-    \n+\n+    // Ranges management region", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0NzgxNA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424447814", "bodyText": "Created a CopyOnWriteMapUtils class to contain all this functionality.", "author": "RaulGracia", "createdAt": "2020-05-13T13:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4NjgxMQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422286811", "bodyText": "HashMap already provides a constructor that does these two lines.", "author": "tkaitchuck", "createdAt": "2020-05-08T18:00:45Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -377,14 +386,36 @@ public Type fetchEvent(EventPointer pointer) throws NoSuchEventException {\n             return ImmutableList.copyOf(readers);\n         }\n     }\n-    \n+\n+    // Ranges management region\n+\n     @VisibleForTesting\n     Map<Segment, Range> getRanges() {\n         synchronized (readers) {\n-            return ImmutableMap.copyOf(ranges);\n+            return ImmutableMap.copyOf(ranges.get());\n         }\n     }\n \n+    private void copyOnPutSegmentRange(Segment segment, Range range) {\n+        Map<Segment, Range> newRanges = copyRanges();\n+        newRanges.put(segment, range);\n+        ranges.set(newRanges);\n+    }\n+\n+    private void copyOnRemoveSegmentRange(Segment segment) {\n+        Map<Segment, Range> newRanges = copyRanges();\n+        newRanges.remove(segment);\n+        ranges.set(newRanges);\n+    }\n+\n+    private Map<Segment, Range> copyRanges() {\n+        Map<Segment, Range> newRanges = new HashMap<>(2 * ranges.get().size());\n+        newRanges.putAll(ranges.get());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4Nzg1Ng==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422287856", "bodyText": "Shouldn't that be Preconditions.checkArgument(multiplier >= 1, ...", "author": "tkaitchuck", "createdAt": "2020-05-08T18:03:01Z", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -405,7 +403,9 @@ private int calculateNumSegmentsToAcquire(ReaderGroupState state) {\n \n     @VisibleForTesting\n     static Duration calculateAcquireTime(String readerId, ReaderGroupState state) {\n-        return TIME_UNIT.multipliedBy(state.getNumberOfReaders() - state.getRanking(readerId));\n+        int multiplier = state.getNumberOfReaders() - state.getRanking(readerId);\n+        Preconditions.checkArgument(multiplier >= TIME_UNIT.getSeconds(), \"Invalid acquire timer multiplier\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0ODA5NQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424448095", "bodyText": "In this case is the same, but I changed it to what you suggest.", "author": "RaulGracia", "createdAt": "2020-05-13T13:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4Nzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwOTc2OQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422309769", "bodyText": "I think we can move the isReaderOnline check to below the acquireTimer.hasRemaining check.", "author": "tkaitchuck", "createdAt": "2020-05-08T18:46:52Z", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupStateManager.java", "diffHunk": "@@ -343,9 +343,7 @@ private boolean shouldAcquireSegment() throws ReaderNotInReaderGroupException {\n                 return false;\n             }\n             if (state.getNumberOfUnassignedSegments() == 0) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0ODM4Mg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r424448382", "bodyText": "Done.", "author": "RaulGracia", "createdAt": "2020-05-13T13:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwOTc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxMTY4NA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r422311684", "bodyText": "Having a shouldAquireSegment() on groupstate would also make this method more efficient because the call to getLag() (above) could be avoided if we don't actually need to acquire a segment.", "author": "tkaitchuck", "createdAt": "2020-05-08T18:50:42Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -272,14 +281,14 @@ private boolean acquireSegmentsIfNeeded(PositionInternal position) throws Reader\n                 long endOffset = groupState.getEndOffsetForSegment(newSegment.getKey().getSegment());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2Njg3NA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426366874", "bodyText": "we can use the pattern checkpointIndex.compute(host, k -> { if k == null  } )", "author": "shrids", "createdAt": "2020-05-18T04:44:08Z", "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -114,14 +109,14 @@ private void recomputeCheckpointIndex() {\n         for (Entry<String, List<String>> entry : uncheckpointedHosts.entrySet()) {\n             String checkpointId = entry.getKey();\n             for (String host : entry.getValue()) {\n-                List<String> checkpointsForHost = checkpointIndex.get(host);\n-                if (checkpointsForHost == null) {\n-                    checkpointsForHost = new ArrayList<>();\n-                    checkpointIndex.put(host, checkpointsForHost);\n-                }\n+                List<String> checkpointsForHost = checkpointIndex.computeIfAbsent(host, k -> new ArrayList<>());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzOTg2MA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426439860", "bodyText": "The code that this line is replacing was basically putting a new ArrayList object as an initialization value for a non-existing key. Just wanted to express the same logic in a more concise way.", "author": "RaulGracia", "createdAt": "2020-05-18T08:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2Njg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3NjA4MA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426376080", "bodyText": "Given that ranges is guarded by readers   @GuardedBy(\"readers\") why do we need to create a copy? isn't it redundant ?", "author": "shrids", "createdAt": "2020-05-18T05:26:04Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -240,7 +277,7 @@ private void releaseSegmentsIfNeeded(PositionInternal position) throws ReaderNot\n             if (reader != null) {\n                 if (groupState.releaseSegment(segment, reader.getOffset(), getLag(), position)) {\n                     readers.remove(reader);\n-                    ranges.remove(reader.getSegmentId());\n+                    ranges = CopyOnWriteMapUtils.remove(ranges, reader.getSegmentId());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNzY4Mw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426437683", "bodyText": "The reason is that the ranges map is referenced by many PositionImpl objects (i.e, every time that readNextEvent() returns an event and there is no change in segments, the same ranges map is reused). This means that we cannot modify this map if there is a change in segments, as it would impact to all the previous PositionImpl objects and they would be in an inconsistent state. So, every time there is a change in the segments, we need the variable ranges to point to a new map object and apply the change in segments to the new map.", "author": "RaulGracia", "createdAt": "2020-05-18T08:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3NjA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUxNjczMg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426516732", "bodyText": "the maps need to be wrapped with java.util.Collections#unmodifiableMap and the updates should be wrapped with Collections.unmodifiableList().", "author": "shrids", "createdAt": "2020-05-18T10:10:34Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -154,8 +168,18 @@\n         } \n         lastRead = Sequence.create(segment.getSegmentId(), offset);\n         int length = buffer.remaining() + WireCommands.TYPE_PLUS_LENGTH_SIZE;\n-        return new EventReadImpl<>(deserializer.deserialize(buffer), getPosition(),\n-                                   new EventPointerImpl(segment, offset, length), null);\n+        addSegmentOffsetUpdateIfNeeded(segment, offset + length);\n+        return new EventReadImpl<>(deserializer.deserialize(buffer),\n+                PositionImpl.builder().ownedSegments(ownedSegments).segmentRanges(ranges).updatesToSegmentOffsets(segmentOffsetUpdates).build(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NTY5MA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r427175690", "bodyText": "Thanks, I have done this change.", "author": "RaulGracia", "createdAt": "2020-05-19T09:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUxNjczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU0NzI5MA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r428547290", "bodyText": "@shrids I just moved the immutability of these collections to the PositionImpl builder itself, so it takes effect to all the usages of such builder.", "author": "RaulGracia", "createdAt": "2020-05-21T09:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUxNjczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMDY5Nw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r426530697", "bodyText": "ownedSegments can be modified by the different thread while iterating here.", "author": "shrids", "createdAt": "2020-05-18T10:36:42Z", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -66,26 +75,29 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n \n     @Override\n     public Set<Segment> getOwnedSegments() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         return Collections.unmodifiableSet(ownedSegments.keySet());\n     }\n \n     @Override\n     public Map<Segment, Long> getOwnedSegmentsWithOffsets() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         return Collections.unmodifiableMap(ownedSegments);\n     }\n     \n     @Override\n     Map<SegmentWithRange, Long> getOwnedSegmentRangesWithOffsets() {\n+        applySegmentOffsetUpdatesIfNeeded();\n         HashMap<SegmentWithRange, Long> result = new HashMap<>();\n         for (Entry<Segment, Long> entry : ownedSegments.entrySet()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NjMwNg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r427176306", "bodyText": "Correct, good catch. Now, when applySegmentOffsetUpdatesIfNeeded() is executed, the PositionImpl object copies the ownedSegments map and only then sets the right offsets representing the point at which the event was read.", "author": "RaulGracia", "createdAt": "2020-05-19T09:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMDY5Nw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkxNzg4Nw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r427917887", "bodyText": "This isn't exactly threadsafe, right? updateToSegmentOffsets can be modified in the EventStreamReaderImpl thread. Yeah, the elements are added to segmentOffsetUpdates  under a lock and the code reads only until this.version. I always try to avoid this pattern.\n@tkaitchuck  @RaulGracia thoughts?", "author": "shrids", "createdAt": "2020-05-20T10:52:44Z", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +230,20 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments.set(new HashMap<>(ownedSegments.get()));\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.get().put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNDE1OA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r428524158", "bodyText": "Thanks for the comment @shrids. I assume that your concern is about the possibility of getting a ConcurrentModificationException while looping over a list that could be subject to concurrent appends (totally valid concern). To test whether this is thread safe or not, I have tested the following:\n\nThread is continuously adding elements on a list.\nAnother thread is continuously iterating the same list.\n\nI have tried 2 variants for thread 2:\n\nLooping over the entire list:\n\nfor (Integer element: elements) { //do X on element }\n\n\nEmulating what we do in this PR (take a point in the list before the end and iterate up to that point):\n\nfor (int j = 0; j < elements.size(); j++) {//do X on element}\n\nFor case 1, I consistently get ConcurrentModificationException on every execution. However, after many executions of this experiment, I have not seen any occurrence of this problem for case 2. I accept that this may not be a usual pattern, but is the most efficient approach I could come up so far and it seems to be thread safe.", "author": "RaulGracia", "createdAt": "2020-05-21T08:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkxNzg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNTY3OA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429205678", "bodyText": "With the current implementation of ArrayList i do not see the possibility of an errror, given that we guarantee only one thread is performing the add. The resize impl of the ArrayList would not cause an error here too. It is just that the pattern is unconventional and I have always avoided it.", "author": "shrids", "createdAt": "2020-05-22T12:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkxNzg4Nw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "6a3cf0f106d3a75e7cd4063adf1077196823dae6", "url": "https://github.com/pravega/pravega/commit/6a3cf0f106d3a75e7cd4063adf1077196823dae6", "message": "Reduce number of calls to doesReaderOwnTooManySegments\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:27Z", "type": "commit"}, {"oid": "49280700ad582291a307763ade2f86bf0aa1de9d", "url": "https://github.com/pravega/pravega/commit/49280700ad582291a307763ade2f86bf0aa1de9d", "message": "Relate the frequency of segment load checks to the reader group state update period\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:28Z", "type": "commit"}, {"oid": "674a28343fc0eb0879b81097050cbb5cf4fa81d0", "url": "https://github.com/pravega/pravega/commit/674a28343fc0eb0879b81097050cbb5cf4fa81d0", "message": "Exploit lazy evaluation to avoid extra executions of acquireSegmentsIfNeeded.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:28Z", "type": "commit"}, {"oid": "e04373f849fb3fe4c041f88d3093ea93a49c8342", "url": "https://github.com/pravega/pravega/commit/e04373f849fb3fe4c041f88d3093ea93a49c8342", "message": "Reduce number of getCheckpointForReader executions.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:29Z", "type": "commit"}, {"oid": "75dc939b0f312ffaca04da82e6f9e6e3562eea29", "url": "https://github.com/pravega/pravega/commit/75dc939b0f312ffaca04da82e6f9e6e3562eea29", "message": "Undo change in condition.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:30Z", "type": "commit"}, {"oid": "2b32b27de8b8197e5e3cac4e78aa5a86e8d2cf95", "url": "https://github.com/pravega/pravega/commit/2b32b27de8b8197e5e3cac4e78aa5a86e8d2cf95", "message": "Use release timer instead of fetchStateTimer, as it may not give opportunities for execution to doesReaderOwnTooManySegments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:30Z", "type": "commit"}, {"oid": "f21982ddf6850a756c81db8e5d37f82d1e42b977", "url": "https://github.com/pravega/pravega/commit/f21982ddf6850a756c81db8e5d37f82d1e42b977", "message": "Add precondition check on the minimum amount of acquire time.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:31Z", "type": "commit"}, {"oid": "b223cacab5b7bb9d676692f26d788f366517135b", "url": "https://github.com/pravega/pravega/commit/b223cacab5b7bb9d676692f26d788f366517135b", "message": "Add a timer to control the number of doesReaderOwnTooManySegments executions.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:32Z", "type": "commit"}, {"oid": "51ba4a49ff4ea706b67c18e23eb9916fce889290", "url": "https://github.com/pravega/pravega/commit/51ba4a49ff4ea706b67c18e23eb9916fce889290", "message": "Reduce watermarking related compute cycles if watermarking is not enabled.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:32Z", "type": "commit"}, {"oid": "081c0b0ac446d0595fa985e1254ffd99e98e8426", "url": "https://github.com/pravega/pravega/commit/081c0b0ac446d0595fa985e1254ffd99e98e8426", "message": "Undo condition change based on watermarking readers.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:33Z", "type": "commit"}, {"oid": "9a7bcf83a14bb3be8f29e2015cff870156553923", "url": "https://github.com/pravega/pravega/commit/9a7bcf83a14bb3be8f29e2015cff870156553923", "message": "Cache result of doesReaderOwnTooManySegments to do not execute it so frequently.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:33Z", "type": "commit"}, {"oid": "5f432709d02031d350dda7f92e11539fe27dc7f0", "url": "https://github.com/pravega/pravega/commit/5f432709d02031d350dda7f92e11539fe27dc7f0", "message": "Fix comment.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:35Z", "type": "commit"}, {"oid": "0e070ae05b0eb724a23f186bbbac79079727dc66", "url": "https://github.com/pravega/pravega/commit/0e070ae05b0eb724a23f186bbbac79079727dc66", "message": "Removed unnecessary else in condition.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:36Z", "type": "commit"}, {"oid": "c5622a1e2e951144286b1e2ee44ff6b2f2b854e9", "url": "https://github.com/pravega/pravega/commit/c5622a1e2e951144286b1e2ee44ff6b2f2b854e9", "message": "Fix checkstyle.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:36Z", "type": "commit"}, {"oid": "9b0683907031998d373fadc518408280bc8bb41e", "url": "https://github.com/pravega/pravega/commit/9b0683907031998d373fadc518408280bc8bb41e", "message": "Test reusing last getPostion call.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:37Z", "type": "commit"}, {"oid": "254799955167e45a2af3e29e9965849de940228f", "url": "https://github.com/pravega/pravega/commit/254799955167e45a2af3e29e9965849de940228f", "message": "Update lastPosition upon a segment change in updateGroupStateIfNeeded().\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:37Z", "type": "commit"}, {"oid": "e64bf9696d1ed1e99286f75af7412d63b2f47ab9", "url": "https://github.com/pravega/pravega/commit/e64bf9696d1ed1e99286f75af7412d63b2f47ab9", "message": "Update last position after end of segment or segment truncated.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:38Z", "type": "commit"}, {"oid": "1d79279032c5df7ffaa8d829008825d9b9b52597", "url": "https://github.com/pravega/pravega/commit/1d79279032c5df7ffaa8d829008825d9b9b52597", "message": "Attempting some improvements on getCheckpointForReader and re-using segment ranges without creating new maps for every event.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:38Z", "type": "commit"}, {"oid": "af307dcf42d3b0816cb08c13934cd3e26176e657", "url": "https://github.com/pravega/pravega/commit/af307dcf42d3b0816cb08c13934cd3e26176e657", "message": "Fix tests.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:39Z", "type": "commit"}, {"oid": "5c239531c5fe2489c10452d1750ab9d820cc19f7", "url": "https://github.com/pravega/pravega/commit/5c239531c5fe2489c10452d1750ab9d820cc19f7", "message": "Most changes from PR comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:40Z", "type": "commit"}, {"oid": "faccb9438e07c67d04bbe01f4a2ac6adf6fe92ab", "url": "https://github.com/pravega/pravega/commit/faccb9438e07c67d04bbe01f4a2ac6adf6fe92ab", "message": "Minor changes.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:40Z", "type": "commit"}, {"oid": "4e3d424c8a99759e87f0c54d3b37aa23718c69a0", "url": "https://github.com/pravega/pravega/commit/4e3d424c8a99759e87f0c54d3b37aa23718c69a0", "message": "Fixed import.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:41Z", "type": "commit"}, {"oid": "699b3430d771f0e025a2626d0f83cb2b2af9ff47", "url": "https://github.com/pravega/pravega/commit/699b3430d771f0e025a2626d0f83cb2b2af9ff47", "message": "Changed precondition check based on PR comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:41Z", "type": "commit"}, {"oid": "e65350829153ad7064f757a64bfc65603989d53a", "url": "https://github.com/pravega/pravega/commit/e65350829153ad7064f757a64bfc65603989d53a", "message": "Fix checkstyle.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:42Z", "type": "commit"}, {"oid": "df31859f3010f1f51eca24d208c1203155864ca2", "url": "https://github.com/pravega/pravega/commit/df31859f3010f1f51eca24d208c1203155864ca2", "message": "Added test class for copy-on-write utility class.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:42Z", "type": "commit"}, {"oid": "e880adaa1457c4253e1c373078ccf50f22f69769", "url": "https://github.com/pravega/pravega/commit/e880adaa1457c4253e1c373078ccf50f22f69769", "message": "Exploratory analysis for batched segment offset updates.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:43Z", "type": "commit"}, {"oid": "dc78ecaa1ce78a2158d05fb665c142a8421be570", "url": "https://github.com/pravega/pravega/commit/dc78ecaa1ce78a2158d05fb665c142a8421be570", "message": "Continue working on lazy batched updates for offset segments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:43Z", "type": "commit"}, {"oid": "51002fd47fa8ab5d81e16a32c4729e6585b131e7", "url": "https://github.com/pravega/pravega/commit/51002fd47fa8ab5d81e16a32c4729e6585b131e7", "message": "Fixed race condition in test.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:44Z", "type": "commit"}, {"oid": "e305d01921d5fb921add6c7cf271eff12093fbd3", "url": "https://github.com/pravega/pravega/commit/e305d01921d5fb921add6c7cf271eff12093fbd3", "message": "Make equals and hashcode in PositionImpl to apply segment offset updates if needed. Added PositionImpl tests.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:45Z", "type": "commit"}, {"oid": "e50cf7b32a0e8bd856f9be88f4f5bf6530615af4", "url": "https://github.com/pravega/pravega/commit/e50cf7b32a0e8bd856f9be88f4f5bf6530615af4", "message": "Fix checkstyle.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:45Z", "type": "commit"}, {"oid": "dff29578e25b5c6086e713ae9ee0c6ce7511c619", "url": "https://github.com/pravega/pravega/commit/dff29578e25b5c6086e713ae9ee0c6ce7511c619", "message": "Added new test for PositionImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:46Z", "type": "commit"}, {"oid": "2514e2ede13ea2ed28d00fce87571f36eff42c91", "url": "https://github.com/pravega/pravega/commit/2514e2ede13ea2ed28d00fce87571f36eff42c91", "message": "Clean up ownedSegments and segmentOffsetUpdates on closeAt().\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:47Z", "type": "commit"}, {"oid": "2cb09eec2d2ed8bfc7f7ab7c83367cca26b62d83", "url": "https://github.com/pravega/pravega/commit/2cb09eec2d2ed8bfc7f7ab7c83367cca26b62d83", "message": "Added tests for Position object returned to application in EventStreamReaderImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:47Z", "type": "commit"}, {"oid": "fbc73dcf64c79445eb655964b5ddd53f78bd270f", "url": "https://github.com/pravega/pravega/commit/fbc73dcf64c79445eb655964b5ddd53f78bd270f", "message": "Make objects passed to PositionImpl immutable.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:48Z", "type": "commit"}, {"oid": "2a02a05e98b73080ba765d440c65559baaae4973", "url": "https://github.com/pravega/pravega/commit/2a02a05e98b73080ba765d440c65559baaae4973", "message": "Make objects passed to PositionImpl immutable in the builder method itself.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:48Z", "type": "commit"}, {"oid": "61bf190bbe015145bc8670b4dfc50b0b458721dc", "url": "https://github.com/pravega/pravega/commit/61bf190bbe015145bc8670b4dfc50b0b458721dc", "message": "Fixed chackstyle.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:49Z", "type": "commit"}, {"oid": "9096ebf28f7b41e5cf0c41782d9aa66bd61275bb", "url": "https://github.com/pravega/pravega/commit/9096ebf28f7b41e5cf0c41782d9aa66bd61275bb", "message": "No need for AtomicReference in PositionImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:05:49Z", "type": "commit"}, {"oid": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "url": "https://github.com/pravega/pravega/commit/461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "message": "Delete extra space.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-22T16:47:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDY2NA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429464664", "bodyText": "These names are just uuids for the most part, this sort of sorting is meaningless. The time order is the order they are in the checkpoints list. If the list for each host can be maintained in this order (Should be easy as it is the natural order in which they are added) then there is no need to sort, and we can just get the first element every time.", "author": "tkaitchuck", "createdAt": "2020-05-22T21:46:00Z", "path": "client/src/main/java/io/pravega/client/stream/impl/CheckpointState.java", "diffHunk": "@@ -114,14 +109,14 @@ private void recomputeCheckpointIndex() {\n         for (Entry<String, List<String>> entry : uncheckpointedHosts.entrySet()) {\n             String checkpointId = entry.getKey();\n             for (String host : entry.getValue()) {\n-                List<String> checkpointsForHost = checkpointIndex.get(host);\n-                if (checkpointsForHost == null) {\n-                    checkpointsForHost = new ArrayList<>();\n-                    checkpointIndex.put(host, checkpointsForHost);\n-                }\n+                List<String> checkpointsForHost = checkpointIndex.computeIfAbsent(host, k -> new ArrayList<>());\n                 checkpointsForHost.add(checkpointId);\n             }\n         }\n+        // Sort checkpoints per reader so we have fast access based on time ordering.\n+        for (List<String> checkpointsForHost: checkpointIndex.values()) {\n+            checkpointsForHost.sort(String::compareTo);", "originalCommit": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MDExMg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430250112", "bodyText": "Done.", "author": "RaulGracia", "createdAt": "2020-05-26T08:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTkwMw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429471903", "bodyText": "Given the constants you selected this is going to add ~30MB of memory overhead per reader in a user's application. I don't consider this tradeoff worthwhile. See above for how we can avoid this.", "author": "tkaitchuck", "createdAt": "2020-05-22T22:00:04Z", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -22,23 +22,28 @@\n import java.nio.ByteBuffer;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n import lombok.Builder;\n-import lombok.EqualsAndHashCode;\n import lombok.SneakyThrows;\n \n import static io.pravega.common.io.serialization.RevisionDataOutput.COMPACT_LONG_MAX;\n \n-@EqualsAndHashCode(callSuper = false)\n public class PositionImpl extends PositionInternal {\n \n     private static final PositionSerializer SERIALIZER = new PositionSerializer();\n-    private final Map<Segment, Long> ownedSegments;\n+    private Map<Segment, Long> ownedSegments;\n     private final Map<Segment, Range> segmentRanges;\n \n+    // If this field is set, it means that we will need to apply the updates on the ownedSegments.\n+    private transient List<Entry<Segment, Long>> updatesToSegmentOffsets;", "originalCommit": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MDAzOQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430250039", "bodyText": "You are right in the case that the copy of the list is necessary, but I think that the current approach of referencing it may be feasible and is the one that provides the actual read throughput speedup.", "author": "RaulGracia", "createdAt": "2020-05-26T08:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5Mzk5Nw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430693997", "bodyText": "No. That map will be ~30mb and there is one per EventStreamReader.", "author": "tkaitchuck", "createdAt": "2020-05-26T20:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429473356", "bodyText": "This computation is wrong. The updatesToSegmentOffsets list is passed in without copying it. This means that if a caller holds onto one position object, and then calls readNext the first position object will be updated and have the wrong value. Please add a test for this.", "author": "tkaitchuck", "createdAt": "2020-05-22T22:02:17Z", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {\n+        this.ownedSegments = Collections.unmodifiableMap(ownedSegments);\n+        this.updatesToSegmentOffsets = Collections.unmodifiableList((updatesToSegmentOffsets == null) ? Collections.emptyList() : updatesToSegmentOffsets);", "originalCommit": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI0OTUzMQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430249531", "bodyText": "I have added an integration test to verify that the concurrent access and appends to updatesToSegmentOffsets. It shows that the optimization is safe and the offsets are correctly calculated.", "author": "RaulGracia", "createdAt": "2020-05-26T08:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5NjYzMQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430696631", "bodyText": "Perhaps I am missing something, but I don't see any actual concurrency in the test.", "author": "tkaitchuck", "createdAt": "2020-05-26T20:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDM1Mg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090352", "bodyText": "Now the new test (integration/ReadTest.java) involves different threads for writing events, reading events and checking positions objects, so all this activity should happen concurrently. If there is any issue in PositionImpl when reading the segmentOffsetUpdates list is also being used by EventStreamReaderImpl, the test should fail.", "author": "RaulGracia", "createdAt": "2020-05-28T20:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzY0Ng==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429473646", "bodyText": "How?! This is all static methods?", "author": "tkaitchuck", "createdAt": "2020-05-22T22:03:25Z", "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+@NotThreadSafe", "originalCommit": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MDE5NA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430250194", "bodyText": "Removed.", "author": "RaulGracia", "createdAt": "2020-05-26T08:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDQ1Nw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429474457", "bodyText": "The semantics of which of these collections are copied or not should be spelled out in a javadoc. It would avoid the bug below.", "author": "tkaitchuck", "createdAt": "2020-05-22T22:07:09Z", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -55,37 +62,42 @@ public PositionImpl(Map<SegmentWithRange, Long> segments) {\n     }\n     \n     @Builder(builderClassName = \"PositionBuilder\")\n-    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges) {\n-        this.ownedSegments = ownedSegments;\n+    PositionImpl(Map<Segment, Long> ownedSegments, Map<Segment, Range> segmentRanges, List<Entry<Segment, Long>> updatesToSegmentOffsets) {", "originalCommit": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MTMyMw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430251323", "bodyText": "Yes, I definitely can add javadoc explaining the main purpose of this builder and the way it is currently used. But I prefer to defer this task until we agree the final way to do this (whether passing updatesToSegmentOffsets is valid or not).", "author": "RaulGracia", "createdAt": "2020-05-26T08:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDI4OA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090288", "bodyText": "I have added javadoc to clarify the goal of the builder method.", "author": "RaulGracia", "createdAt": "2020-05-28T20:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDk1Mw==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r429474953", "bodyText": "Because a copy is needed anyway (see comments below) this is actually going to make things slower. It would be better to simply in the getPosition() method iterate over the readers and construct the List<Entry<Segment, Long>> with only one entry per-segment. This is faster, avoids both of the need collections here, and the need to try to cache the position object.", "author": "tkaitchuck", "createdAt": "2020-05-22T22:09:37Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -60,6 +62,10 @@\n \n     // Base waiting time for a reader on an idle segment waiting for new data to be read.\n     private static final long BASE_READER_WAITING_TIME_MS = ReaderGroupStateManager.TIME_UNIT.toMillis();\n+    // As an optimization to do not generate Position objects on every event read, we define a base map of segments and\n+    // then a batch of updates to the offsets of these segments, one per event read. Internally, the Position object can\n+    // derive the right offsets at which the event was read by lazily replying such updates up to the point it was read.\n+    private static final long MAX_BUFFERED_SEGMENT_OFFSET_UPDATES = 1000;", "originalCommit": "461d9f293d9cadb3fbd561bf2fe7dde97e0a3481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDIyOA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090228", "bodyText": "I have added a performance comparison comparing your suggestion with this PR. For 1 segment, your approach is at par with this PR in terms of speed. But as more segments are handled by the reader, the performance decreases, given that the list to copy is larger.", "author": "RaulGracia", "createdAt": "2020-05-28T20:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3NDk1Mw=="}], "type": "inlineReview"}, {"oid": "2e24c4400fb98a32029d91c76a88d1abad63709a", "url": "https://github.com/pravega/pravega/commit/2e24c4400fb98a32029d91c76a88d1abad63709a", "message": "Address review comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-25T11:23:46Z", "type": "commit"}, {"oid": "2e0cd7c79e8ee73024742aab059d19a00e31fbd0", "url": "https://github.com/pravega/pravega/commit/2e0cd7c79e8ee73024742aab059d19a00e31fbd0", "message": "Address review comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-25T11:25:36Z", "type": "commit"}, {"oid": "74d69aafeca84ed43a0ec3907671866797ff8623", "url": "https://github.com/pravega/pravega/commit/74d69aafeca84ed43a0ec3907671866797ff8623", "message": "Make CopyOnWriteMapUtils final.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-25T11:26:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY4NTI0Ng==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430685246", "bodyText": "This lock is not guarding updatesToSegmentOffsets because it is shared by many objects.", "author": "tkaitchuck", "createdAt": "2020-05-26T20:21:45Z", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +229,19 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDE4NA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090184", "bodyText": "Correct, at this point we want to ensure that multiple threads invoking methods on a PositionImpl object execute this method under a lock, so building the internal state of the object is executed only once.", "author": "RaulGracia", "createdAt": "2020-05-28T20:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY4NTI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MjUxNQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r430692515", "bodyText": "@shrids 's intuition was correct. This call to updatesToSegmentOffsets.get(i) is not thread safe. The list may not be synchronized in any way between the thread calling readNextEvent and the thread calling this method. As such this could endup reading garbage data.", "author": "tkaitchuck", "createdAt": "2020-05-26T20:35:00Z", "path": "client/src/main/java/io/pravega/client/stream/impl/PositionImpl.java", "diffHunk": "@@ -196,4 +229,19 @@ public static Position fromBytes(ByteBuffer buff) {\n         return SERIALIZER.deserialize(new ByteArraySegment(buff));\n     }\n \n+    private synchronized void applySegmentOffsetUpdatesIfNeeded() {\n+        // No updates, so nothing to do.\n+        if (this.updatesToSegmentOffsets == null || this.updatesToSegmentOffsets.isEmpty()) {\n+            return;\n+        }\n+        // We are going to modify ownedSegments to match the segment offsets at the time this event was read, so copying\n+        // the map of ownedSegments to do not impact to the map referenced by other PositionImpl objects.\n+        this.ownedSegments = new HashMap<>(ownedSegments);\n+        // Apply all the Segment offset updates up to the point in which this event was read.\n+        for (int i = 0; i < this.version; i++) {\n+            this.ownedSegments.put(this.updatesToSegmentOffsets.get(i).getKey(), this.updatesToSegmentOffsets.get(i).getValue());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5MDE0NA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r432090144", "bodyText": "You are right. In the case of using an ArrayList in that way, an internal resize can be triggered by one thread adding new elements, which might lead another thread to read garbage when executing this method in PositionImpl that reads that list. A solution to this is to use an \"structurally immutable\" list, wrapped by a List for convenience. This is currently achieved by using ArrayList.asList() for initializing updatesToSegmentOffsets. Any attempt to add or delete elements from the list will result in UnsupportedOperationException, while set and get methods are allowed (similar to an array).", "author": "RaulGracia", "createdAt": "2020-05-28T20:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MjUxNQ=="}], "type": "inlineReview"}, {"oid": "9508aba3c43c065ca91ea8a5b586983f93259810", "url": "https://github.com/pravega/pravega/commit/9508aba3c43c065ca91ea8a5b586983f93259810", "message": "Ensure that segmentOffsetUpdatesList is structurally immutable and improved test.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-28T11:26:46Z", "type": "commit"}, {"oid": "9508aba3c43c065ca91ea8a5b586983f93259810", "url": "https://github.com/pravega/pravega/commit/9508aba3c43c065ca91ea8a5b586983f93259810", "message": "Ensure that segmentOffsetUpdatesList is structurally immutable and improved test.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-28T11:26:46Z", "type": "forcePushed"}, {"oid": "a19c3981fd831b63f67cae159bc60057c1ef5008", "url": "https://github.com/pravega/pravega/commit/a19c3981fd831b63f67cae159bc60057c1ef5008", "message": "Add javadoc to builder method in PositionImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-28T19:35:29Z", "type": "commit"}, {"oid": "a19c3981fd831b63f67cae159bc60057c1ef5008", "url": "https://github.com/pravega/pravega/commit/a19c3981fd831b63f67cae159bc60057c1ef5008", "message": "Add javadoc to builder method in PositionImpl.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-28T19:35:29Z", "type": "forcePushed"}, {"oid": "4b5e9b72c4836f140ed3f183df87124155d3a67b", "url": "https://github.com/pravega/pravega/commit/4b5e9b72c4836f140ed3f183df87124155d3a67b", "message": "Minor improvements in comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-29T06:48:30Z", "type": "commit"}, {"oid": "4b5e9b72c4836f140ed3f183df87124155d3a67b", "url": "https://github.com/pravega/pravega/commit/4b5e9b72c4836f140ed3f183df87124155d3a67b", "message": "Minor improvements in comments.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-29T06:48:30Z", "type": "forcePushed"}, {"oid": "22202507353957beebe2c36116476019e31bf5d2", "url": "https://github.com/pravega/pravega/commit/22202507353957beebe2c36116476019e31bf5d2", "message": "Cache in memory scoped segment name instead of constructing on each call as it is checked on each event read.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-05-29T18:15:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjc0Mg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433502742", "bodyText": "This optimization may burn us for users which serialize the position objects. (This is recommended behaviour and required for exactly once delivery). Please verify this solution actually improves performance in that case, and not just the no-op processing case. If it makes things significantly worse, then I don't think we should pursue it to improve performance for some users at the expense of others.", "author": "tkaitchuck", "createdAt": "2020-06-01T21:33:58Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -60,6 +63,10 @@\n \n     // Base waiting time for a reader on an idle segment waiting for new data to be read.\n     private static final long BASE_READER_WAITING_TIME_MS = ReaderGroupStateManager.TIME_UNIT.toMillis();\n+    // As an optimization to avoid creating a new ownedSegments map per event read, we define a base map of segments and", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxMTc3MA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435311770", "bodyText": "As I have reported, we have performed a benchmark in which we have serialized each and every PositionImpl event. While this is not a realistic case, it was just for benchmarking purposes. In this case, the current state of the PR is 1.5x-2x better than master. While this is not the goal of this optimization, we just verified that this scenario is also improved.", "author": "RaulGracia", "createdAt": "2020-06-04T14:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzYxMA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433503610", "bodyText": "This annotation does not actually hold anymore. There are paths to read from this not guarded by the 'readers' lock. If you want to keep this approach please make a threadsafe datastructure in common which follows this model. Then this class will simply have a final member and no annotation will be required.", "author": "tkaitchuck", "createdAt": "2020-06-01T21:36:03Z", "path": "client/src/main/java/io/pravega/client/stream/impl/EventStreamReaderImpl.java", "diffHunk": "@@ -74,12 +81,18 @@\n     @GuardedBy(\"readers\")\n     private final List<EventSegmentReader> readers = new ArrayList<>();\n     @GuardedBy(\"readers\")\n-    private final Map<Segment, Range> ranges = new HashMap<>();\n+    private Map<Segment, Range> ranges = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private final Map<Segment, Long> sealedSegments = new HashMap<>();\n     @GuardedBy(\"readers\")\n     private Sequence lastRead;\n     @GuardedBy(\"readers\")\n+    private Map<Segment, Long> ownedSegments = new HashMap<>();\n+    @GuardedBy(\"readers\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxOTIwNg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435319206", "bodyText": "One of the approaches taken by this PR is to use as input for building PositionImpl objects references to the collections they need to build their state instead of copies (specially map copies are a main performance bottleneck and a source of GC activity). While we do not make unsafe accesses or manipulations from PositionImpl objects to these shared collections, multiple PositionImpl object may point to ownedSegments, ranges and segmentOffsetUpdates. Shall I remove @GuardedBy(\"readers\") from these three collections?\n(Note that start adding locks here would impact on performance, so I prefer not to use additional synchronization. In my view, the current code has been reviewed and intensively benchmarked to be sure that is thread safe).", "author": "RaulGracia", "createdAt": "2020-06-04T14:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk2MTYwNg==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435961606", "bodyText": "I have removed the annotation from the collections that are passed as references to the PositionImpl builder.", "author": "RaulGracia", "createdAt": "2020-06-05T14:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzM3Ng==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r433513376", "bodyText": "Rather than externalizing the logic, I would rather have it internalized to a single class. For example can we Make a CopyOnWriteHashMap which internally does the copies? Because this would allow callers to not need to understand the details of the implementation.", "author": "tkaitchuck", "createdAt": "2020-06-01T22:00:10Z", "path": "common/src/main/java/io/pravega/common/util/CopyOnWriteMapUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utils class that contains copy-on-write methods for maps.\n+ */\n+public final class CopyOnWriteMapUtils {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3NDkyMQ==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435374921", "bodyText": "This was my first attempt, but then I changed my mind because I'm not fully convinced that it is the most clear way to do this. While I understand that having a CopyOnWriteHashMap makes the logic implicit, the problem is that it may lead to mistakes in this specific use case. That is, if we assume to have a CopyOnWriteHashMap for ranges, for instance, like:\nprivate Map<Segment, Range> ranges = new CopyOnWriteHashMap<>();\nThen someone could easily make the mistake of building the PositionImpl object in the way we are doing right now:\nPositionImpl.builder().ownedSegments(ownedSegments)\n                                     .segmentRanges(ranges)\n                                     .updatesToSegmentOffsets(segmentOffsetUpdates.subList(0, segmentOffsetUpdatesIndex))\n                                     .build();\n\nBut this is wrong, because we are using ranges in PositionImpl which would be a CopyOnWriteHashMap whose internal state would be changing on every put/remove. Therefore, we would need to build the PositionImpl object by using something like ranges.getInnerMap() that returns the actual HashMap inside CopyOnWriteHashMap (which is not in the contract of Map). This was my concern, but if you still want me to use a CopyOnWriteHashMap instead of the current utility class, then fine.", "author": "RaulGracia", "createdAt": "2020-06-04T16:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk2MTkyOA==", "url": "https://github.com/pravega/pravega/pull/4768#discussion_r435961928", "bodyText": "Added CopyOnWriteHashMap according to your comment.", "author": "RaulGracia", "createdAt": "2020-06-05T14:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzM3Ng=="}], "type": "inlineReview"}, {"oid": "4bdee85459be6912be2d744e259344df52c02b5e", "url": "https://github.com/pravega/pravega/commit/4bdee85459be6912be2d744e259344df52c02b5e", "message": "Optimize lazy construction of PositionImpl object state.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-06-03T11:38:11Z", "type": "commit"}, {"oid": "4bdee85459be6912be2d744e259344df52c02b5e", "url": "https://github.com/pravega/pravega/commit/4bdee85459be6912be2d744e259344df52c02b5e", "message": "Optimize lazy construction of PositionImpl object state.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-06-03T11:38:11Z", "type": "forcePushed"}, {"oid": "6c509a43880596e4b386d49124c8a59318175352", "url": "https://github.com/pravega/pravega/commit/6c509a43880596e4b386d49124c8a59318175352", "message": "Fix spotbugs.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-06-03T13:28:14Z", "type": "commit"}, {"oid": "6c509a43880596e4b386d49124c8a59318175352", "url": "https://github.com/pravega/pravega/commit/6c509a43880596e4b386d49124c8a59318175352", "message": "Fix spotbugs.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-06-03T13:28:14Z", "type": "forcePushed"}, {"oid": "a940b202da3953dc2709778781a1942a911b65e4", "url": "https://github.com/pravega/pravega/commit/a940b202da3953dc2709778781a1942a911b65e4", "message": "Replaced CopyOnWriteMapUtils by a CopyOnWriteMap implementation. Removed GuardedBy annotation from ranges, ownedSegments and segmentOffsetUpdates as they may be (safely) accessed by PositionImpl objects.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-06-05T11:16:20Z", "type": "commit"}, {"oid": "a940b202da3953dc2709778781a1942a911b65e4", "url": "https://github.com/pravega/pravega/commit/a940b202da3953dc2709778781a1942a911b65e4", "message": "Replaced CopyOnWriteMapUtils by a CopyOnWriteMap implementation. Removed GuardedBy annotation from ranges, ownedSegments and segmentOffsetUpdates as they may be (safely) accessed by PositionImpl objects.\n\nSigned-off-by: Ra\u00fal Gracia <raul.gracia@emc.com>", "committedDate": "2020-06-05T11:16:20Z", "type": "forcePushed"}, {"oid": "d893db7f75b24d4355e58dfbc5bb4425b320b794", "url": "https://github.com/pravega/pravega/commit/d893db7f75b24d4355e58dfbc5bb4425b320b794", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls", "committedDate": "2020-06-05T11:17:06Z", "type": "commit"}, {"oid": "d6083baf57ad00acec0b3a185b752d4c8600703c", "url": "https://github.com/pravega/pravega/commit/d6083baf57ad00acec0b3a185b752d4c8600703c", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls", "committedDate": "2020-06-05T23:38:43Z", "type": "commit"}, {"oid": "26a7aa54b591bfe9da25b6732199104c263a2dab", "url": "https://github.com/pravega/pravega/commit/26a7aa54b591bfe9da25b6732199104c263a2dab", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls", "committedDate": "2020-06-06T13:54:24Z", "type": "commit"}, {"oid": "0716c66578965c4ae5ee56bc948f77189057c5cc", "url": "https://github.com/pravega/pravega/commit/0716c66578965c4ae5ee56bc948f77189057c5cc", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls", "committedDate": "2020-06-08T10:17:15Z", "type": "commit"}, {"oid": "bcc1a8079f20db280948ff617c6d45c5f132aaf9", "url": "https://github.com/pravega/pravega/commit/bcc1a8079f20db280948ff617c6d45c5f132aaf9", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls", "committedDate": "2020-06-08T15:09:22Z", "type": "commit"}, {"oid": "84b10eb198c29aabb171e8ebf58491f2e5cfce27", "url": "https://github.com/pravega/pravega/commit/84b10eb198c29aabb171e8ebf58491f2e5cfce27", "message": "Merge branch 'master' into issue-reduce-segment-offload-calls", "committedDate": "2020-06-08T15:56:09Z", "type": "commit"}]}